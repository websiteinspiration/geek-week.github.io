<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦕 ⬇️ ⛪️ Tampilkan hasil pencarian dan masalah kinerja 👨🏿‍🏭 🌊 👩🏻‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salah satu skenario khas di semua aplikasi yang sudah dikenal adalah mencari data sesuai dengan kriteria tertentu dan menampilkannya dalam bentuk yang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Tampilkan hasil pencarian dan masalah kinerja</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/epam_systems/blog/493438/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salah satu skenario khas di semua aplikasi yang sudah dikenal adalah mencari data sesuai dengan kriteria tertentu dan menampilkannya dalam bentuk yang mudah dibaca. </font><font style="vertical-align: inherit;">Mungkin juga ada peluang tambahan untuk menyortir, mengelompokkan, membuat halaman. </font><font style="vertical-align: inherit;">Tugasnya, secara teori, sepele, tetapi ketika menyelesaikannya, banyak pengembang membuat sejumlah kesalahan, yang kemudian menderita karena kinerja. </font><font style="vertical-align: inherit;">Mari kita coba mempertimbangkan berbagai solusi untuk masalah ini dan merumuskan rekomendasi untuk memilih implementasi yang paling efektif.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ms/kc/-s/mskc-s_1t4wcxa9w7i04zg4cjjq.jpeg" alt="gambar"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opsi Paging # 1</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Opsi paling sederhana yang muncul di benak Anda adalah membuat paginasi hasil pencarian dalam bentuk paling klasik.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rd/xx/vs/rdxxvst5xhcdfxzvlgrob1csxdk.png" width="498" height="232"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan aplikasi menggunakan database relasional. </font><font style="vertical-align: inherit;">Dalam hal ini, untuk menampilkan informasi dalam formulir ini, Anda perlu menjalankan dua query SQL:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dapatkan baris untuk halaman saat ini.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hitung jumlah total baris yang cocok dengan kriteria pencarian - ini diperlukan untuk menampilkan halaman.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan kueri pertama menggunakan database uji MS SQL </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AdventureWorks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk server 2016 </font><font style="vertical-align: inherit;">sebagai contoh </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk tujuan ini, kami akan menggunakan tabel Sales.SalesOrderHeader:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kueri di atas akan menampilkan 50 pesanan pertama dari daftar yang diurutkan dalam urutan menurun berdasarkan tanggal penambahan, dengan kata lain, 50 pesanan terakhir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini berjalan cepat berdasarkan pengujian, tetapi mari kita lihat rencana eksekusi dan statistik I / O:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rw/e8/u8/rwe8u8un-1t5bm3yttan4qsfqrg.png" width="624" height="144"></div><br>
<pre><code class="plaintext hljs">Table 'SalesOrderHeader'. Scan count 1, logical reads 698, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda bisa mendapatkan statistik I / O untuk setiap permintaan dengan menjalankan perintah SET STATISTICS IO ON di runtime kueri. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat dari rencana eksekusi, sumber daya paling intensif adalah untuk mengurutkan semua baris dalam tabel sumber berdasarkan tanggal mereka ditambahkan. </font><font style="vertical-align: inherit;">Dan masalahnya adalah semakin banyak baris muncul di tabel, semakin sulit penyortirannya. </font><font style="vertical-align: inherit;">Dalam praktiknya, situasi seperti itu harus dihindari, jadi tambahkan indeks pada tanggal penambahan dan lihat apakah konsumsi sumber daya telah berubah:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/7y/so/g1/7ysog13xd9kalhv9fakieghj4je.png" width="720" height="148"></div><br>
<pre><code class="plaintext hljs">Table 'SalesOrderHeader'. Scan count 1, logical reads 165, physical reads 0, read-ahead reads 5, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jelas, itu menjadi jauh lebih baik. </font><font style="vertical-align: inherit;">Tetapi apakah semua masalah telah diselesaikan? </font><font style="vertical-align: inherit;">Mari kita ubah permintaan pencarian untuk pesanan di mana total biaya barang melebihi $ 100:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">WHERE</span> SubTotal &gt; <span class="hljs-number">100</span>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yn/_c/7s/yn_c7stdebp1utx8_ck4fbrvxjq.png" width="800" height="137"></div><br>
<pre><code class="plaintext hljs">Table 'SalesOrderHeader'. Scan count 1, logical reads 1081, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memiliki situasi yang lucu: rencana kueri sedikit lebih buruk daripada yang sebelumnya, tetapi jumlah sebenarnya pembacaan logis hampir dua kali lipat dengan pemindaian tabel penuh. </font><font style="vertical-align: inherit;">Ada jalan keluar - jika kita membuat harga komposit dari indeks yang ada dan menambahkan harga total barang sebagai bidang kedua, maka sekali lagi kita mendapatkan 165 pembacaan logis:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> IX_SalesOrderHeader_OrderDate_SubTotal <span class="hljs-keyword">on</span> Sales.SalesOrderHeader(OrderDate, SubTotal);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Serangkaian contoh ini dapat dilanjutkan untuk waktu yang lama, tetapi dua pemikiran utama yang ingin saya ungkapkan di sini adalah:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menambahkan kriteria baru atau urutan apa pun ke permintaan pencarian dapat secara signifikan mempengaruhi kecepatan pelaksanaannya.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi jika kita perlu mengurangi hanya sebagian dari data, dan tidak semua hasil yang sesuai dengan kondisi pencarian, ada banyak cara untuk mengoptimalkan permintaan seperti itu.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita beralih ke permintaan kedua, yang disebutkan di bagian paling awal - ke yang menghitung jumlah rekaman yang memenuhi kriteria pencarian. </font><font style="vertical-align: inherit;">Ambil contoh yang sama - temukan pesanan yang harganya lebih dari $ 100:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">WHERE</span> SubTotal &gt; <span class="hljs-number">100</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan adanya indeks komposit yang ditunjukkan di atas, kami memperoleh:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nb/tg/yz/nbtgyzsg7her2lswpnfq2jbmotk.png" width="517" height="197"></div><br>
<pre><code class="plaintext hljs">Table 'SalesOrderHeader'. Scan count 1, logical reads 698, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fakta bahwa kueri melewati seluruh indeks tidak mengejutkan, karena bidang SubTotal tidak di posisi pertama, sehingga kueri tidak dapat menggunakannya. Masalahnya dipecahkan dengan menambahkan indeks lain ke bidang SubTotal, dan sebagai hasilnya sudah hanya 48 pembacaan logis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat memberikan beberapa contoh lagi permintaan untuk menghitung kuantitas, tetapi esensinya tetap sama: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mendapatkan sepotong data dan menghitung jumlah total adalah dua permintaan yang berbeda secara mendasar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan masing-masing memerlukan langkah-langkah sendiri untuk optimasi. Dalam kasus umum, Anda tidak dapat menemukan kombinasi indeks yang berfungsi sama baiknya untuk kedua kueri.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, salah satu persyaratan penting yang harus diklarifikasi ketika mengembangkan solusi pencarian adalah apakah benar-benar penting bagi bisnis untuk melihat jumlah objek yang ditemukan. </font><font style="vertical-align: inherit;">Sering terjadi tidak. </font><font style="vertical-align: inherit;">Dan navigasi ke nomor halaman tertentu, menurut saya, adalah solusi dengan ruang lingkup yang sangat sempit, karena sebagian besar skenario paging terlihat seperti "pergi ke halaman berikutnya."</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opsi Paging # 2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan pengguna tidak peduli tentang mengetahui jumlah objek yang ditemukan. </font><font style="vertical-align: inherit;">Mari kita coba untuk menyederhanakan halaman pencarian:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tc/pr/1t/tcpr1teevrkdz8tcwsbjmx_dl5i.png" width="498" height="230"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada kenyataannya, hanya fakta bahwa tidak ada cara untuk pergi ke nomor halaman tertentu telah berubah, dan sekarang tabel ini tidak perlu tahu berapa banyak dari mereka dapat ditampilkan. Tetapi muncul pertanyaan - bagaimana tabel mengetahui jika ada data untuk halaman berikutnya (untuk menampilkan tautan "Next" dengan benar)? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jawabannya sangat sederhana: Anda dapat mengurangi dari database satu catatan lebih dari yang Anda perlu tampilkan, dan kehadiran catatan "tambahan" ini akan menunjukkan apakah ada bagian berikutnya. Jadi, untuk mendapatkan satu halaman data, Anda hanya perlu menyelesaikan satu permintaan, yang secara signifikan meningkatkan kinerja dan membuatnya lebih mudah untuk mendukung fungsi ini. Dalam praktik saya, ada kasus ketika menolak untuk menghitung jumlah total rekaman yang mempercepat output hasil sebanyak 4-5 kali.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk pendekatan ini, ada beberapa opsi untuk antarmuka pengguna: perintah "back" dan "forward", seperti dalam contoh di atas, tombol "load more", yang hanya menambahkan bagian baru ke hasil yang ditampilkan, "scrolling tak terbatas", yang bekerja pada prinsip "load more" ", Tetapi sinyal untuk mendapatkan bagian selanjutnya adalah pengguna untuk menggulir semua hasil yang ditampilkan hingga akhir. </font><font style="vertical-align: inherit;">Apa pun solusi visualnya, prinsip pengambilan sampel data tetap sama.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuansa penerapan paging</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam semua contoh kueri di atas, pendekatan "offset + angka" digunakan, ketika kueri itu sendiri menunjukkan urutan baris hasil dan berapa banyak baris yang harus dikembalikan. </font><font style="vertical-align: inherit;">Pertama, pertimbangkan cara terbaik untuk mengatur transfer parameter dalam kasus ini. </font><font style="vertical-align: inherit;">Dalam praktiknya, saya bertemu beberapa cara:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nomor seri halaman yang diminta (pageIndex), ukuran halaman (pageSize).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nomor seri catatan pertama yang akan dikembalikan (startIndex), jumlah maksimum catatan sebagai hasil (hitungan).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nomor seri catatan pertama yang akan dikembalikan (startIndex), nomor seri catatan terakhir yang akan dikembalikan (endIndex).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada pandangan pertama, mungkin terlihat bahwa ini sangat mendasar sehingga tidak ada perbedaan. </font><font style="vertical-align: inherit;">Tapi ini tidak begitu - opsi yang paling nyaman dan universal adalah yang kedua (startIndex, count). </font><font style="vertical-align: inherit;">Ada beberapa alasan untuk ini:</font></font><br>
<br>
<ul>
<li>    +1 ,  ,    pageIndex  pageSize  . ,    50   .    ,      ,  .   «+1»    , ,          1  51,   —  51  101  ..     51   pageIndex,      52  102  .. ,             —     «» ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opsi ketiga tidak masuk akal sama sekali, karena untuk mengeksekusi query di sebagian besar database, Anda masih perlu mentransfer kuantitas, bukan indeks dari catatan terakhir. </font><font style="vertical-align: inherit;">Biarkan pengurangan startIndex dari endIndex dan operasi aritmatika dasar, tetapi berlebihan di sini.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita harus menggambarkan kekurangan implementasi paging melalui "offset + kuantitas":</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mendapatkan setiap halaman berikutnya akan lebih mahal dan lebih lambat dari yang sebelumnya, karena basis data masih harus melalui semua catatan "dari awal" sesuai dengan kriteria pencarian dan urutkan, dan kemudian berhenti pada fragmen yang diinginkan.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak semua DBMS dapat mendukung pendekatan ini.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada beberapa alternatif, tetapi mereka juga tidak sempurna. </font><font style="vertical-align: inherit;">Yang pertama dari pendekatan ini disebut "paging keyset" atau "metode pencarian" dan terdiri dari yang berikut: setelah menerima bagian, Anda bisa mengingat nilai-nilai bidang dalam catatan terakhir pada halaman, dan kemudian menggunakannya untuk mendapatkan bagian berikutnya. </font><font style="vertical-align: inherit;">Misalnya, kami melakukan permintaan berikut:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan dalam catatan terakhir kami mendapat nilai tanggal pesanan '2014-06-29'. </font><font style="vertical-align: inherit;">Kemudian, untuk mendapatkan halaman berikutnya, Anda dapat mencoba melakukan ini:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">WHERE</span> OrderDate &lt; <span class="hljs-string">'2014-06-29'</span>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya adalah bahwa OrderDate adalah bidang yang tidak unik, dan kondisi yang disebutkan di atas kemungkinan akan melewati banyak baris yang diperlukan. </font><font style="vertical-align: inherit;">Untuk membuat permintaan ini tidak ambigu, Anda perlu menambahkan bidang unik ke kondisi (misalkan 75074 adalah nilai terakhir dari kunci utama dari bagian pertama):</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Sales.SalesOrderHeader
<span class="hljs-keyword">WHERE</span> (OrderDate = <span class="hljs-string">'2014-06-29'</span> <span class="hljs-keyword">AND</span> SalesOrderID &lt; <span class="hljs-number">75074</span>)
   <span class="hljs-keyword">OR</span> (OrderDate &lt; <span class="hljs-string">'2014-06-29'</span>)
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> OrderDate <span class="hljs-keyword">DESC</span>, SalesOrderID <span class="hljs-keyword">DESC</span>
<span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ROWS</span>
<span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">NEXT</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Opsi ini akan bekerja dengan benar, tetapi dalam kasus umum akan sulit untuk mengoptimalkan, karena kondisinya mengandung operator OR. Jika nilai kunci utama tumbuh dengan pertumbuhan OrderDate, maka kondisinya dapat disederhanakan dengan hanya menyaring filter oleh SalesOrderID. Tetapi jika tidak ada korelasi ketat antara nilai-nilai kunci primer dan bidang di mana hasilnya diurutkan - di sebagian besar DBMSs ini OR tidak dapat dihindari. Pengecualian yang saya ketahui adalah PostgreSQL, di mana perbandingan tuple didukung sepenuhnya, dan kondisi di atas dapat dituliskan sebagai “WHERE (OrderDate, SalesOrderID) &lt;('2014-06-29', 75074). Jika Anda memiliki kunci komposit dengan dua bidang ini, permintaan serupa harus cukup mudah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendekatan alternatif kedua dapat ditemukan, misalnya, di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API gulir ElasticSearch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cosmos DB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - saat kueri di samping data mengembalikan pengenal khusus yang dengannya Anda bisa mendapatkan kumpulan data berikutnya. </font><font style="vertical-align: inherit;">Jika pengenal ini memiliki masa pakai tak terbatas (seperti pada Comsos DB), maka ini adalah cara yang bagus untuk menerapkan paging dengan transisi berurutan antar halaman (opsi # 2 yang disebutkan di atas). </font><font style="vertical-align: inherit;">Kerugian yang mungkin terjadi: tidak semua DBMS didukung; </font><font style="vertical-align: inherit;">pengidentifikasi batch yang diterima berikutnya mungkin memiliki masa hidup terbatas, yang umumnya tidak cocok untuk menerapkan interaksi pengguna (seperti API gulir ElasticSearch).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penyaringan kompleks</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memperumit tugas lebih lanjut. </font><font style="vertical-align: inherit;">Misalkan ada persyaratan untuk mengimplementasikan apa yang disebut pencarian segi, yang akrab bagi semua orang dari toko online. </font><font style="vertical-align: inherit;">Contoh di atas berdasarkan tabel pesanan tidak terlalu indikatif dalam kasus ini, jadi kami akan beralih ke tabel Produk dari database AdventureWorks:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/di/ws/13/diws13cm-qjxoy3igxslnbvizca.png" width="595" height="234"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa gagasan pencarian segi? </font><font style="vertical-align: inherit;">Dalam hal itu, untuk setiap elemen filter, jumlah catatan yang cocok dengan kriteria ini ditampilkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan mempertimbangkan filter yang dipilih di semua kategori lainnya</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, jika kita memilih kategori Sepeda dan warna Hitam dalam contoh ini, tabel hanya akan menampilkan sepeda hitam, tetapi pada saat yang sama:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk setiap kriteria grup "Kategori", jumlah produk dari kategori ini dalam warna hitam akan ditampilkan.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk setiap kriteria kelompok Warna, jumlah sepeda warna itu akan ditampilkan.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut adalah contoh keluaran hasil untuk kondisi seperti ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/y8/v2/q2/y8v2q2j76mcfnmjmirzu8jrnhyu.png" width="605" height="234"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika selain menandai kategori "Pakaian", meja juga akan menampilkan pakaian hitam yang tersedia. </font><font style="vertical-align: inherit;">Jumlah produk hitam di bagian "Warna" juga akan dihitung ulang sesuai dengan kondisi baru, hanya di bagian "Kategori" tidak ada yang akan berubah ... Saya harap contoh ini cukup untuk memahami algoritme pencarian segi yang sudah dikenal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang bayangkan bagaimana ini dapat diimplementasikan pada basis relasional. </font><font style="vertical-align: inherit;">Setiap kelompok kriteria, seperti Kategori dan Warna, akan memerlukan permintaan terpisah:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> pc.ProductCategoryID, pc.Name, <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> Production.Product p
  <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Production.ProductSubcategory ps <span class="hljs-keyword">ON</span> p.ProductSubcategoryID = ps.ProductSubcategoryID
  <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Production.ProductCategory pc <span class="hljs-keyword">ON</span> ps.ProductCategoryID = pc.ProductCategoryID
<span class="hljs-keyword">WHERE</span> p.Color = <span class="hljs-string">'Black'</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> pc.ProductCategoryID, pc.Name
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DESC</span>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mf/79/az/mf79azaflzgu-1gatq4gtbhcdzw.png" width="331" height="90"></div><br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> Color, <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> Production.Product p
  <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Production.ProductSubcategory ps <span class="hljs-keyword">ON</span> p.ProductSubcategoryID = ps.ProductSubcategoryID
<span class="hljs-keyword">WHERE</span> ps.ProductCategoryID = <span class="hljs-number">1</span> <span class="hljs-comment">--Bikes</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Color
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DESC</span>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/ec/r5/cfecr5njjmi93lsdrei1teygmhi.png" width="190" height="110"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang salah dengan keputusan ini? </font><font style="vertical-align: inherit;">Sangat sederhana - skalanya tidak baik. </font><font style="vertical-align: inherit;">Setiap bagian filter memerlukan kueri terpisah untuk menghitung jumlah, dan kueri ini bukan yang termudah. </font><font style="vertical-align: inherit;">Di toko online, di beberapa bagian, mungkin ada beberapa lusin bagian dari filter, yang dapat menjadi masalah serius untuk kinerja. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biasanya, setelah pernyataan ini, mereka menawarkan saya beberapa solusi, yaitu:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gabungkan semua jumlah kuantitas menjadi satu permintaan. </font><font style="vertical-align: inherit;">Secara teknis, ini dimungkinkan menggunakan kata kunci UNION, hanya saja ini tidak akan banyak membantu dalam kinerja - bagaimanapun, database harus mengeksekusi masing-masing fragmen dari awal.</font></font></li>
<li> .      ,    .   ,      . ,   10 «»,     5 .   «»    ,       -.         9- ,  ,        .     50 ,    ,     2<sup>50</sup>.         ,  .     ,            5-10 . ,          ,  -  ,      ,                (     ).</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untungnya, tugas semacam itu telah lama memiliki solusi yang cukup efektif yang dapat diprediksi bekerja pada sejumlah besar data. Untuk salah satu opsi ini, masuk akal untuk membagi perhitungan ulang faset dan membuat halaman hasil menjadi dua panggilan paralel ke server dan mengatur antarmuka pengguna sedemikian rupa sehingga memuat data pada aspek “tidak mengganggu” dengan tampilan hasil pencarian.</font></font><br>
<br>
<ul>
<li>   «»   . ,        ,       ,   ,      — «1425  , ?»       ,    «».                 «».  ,   ,             .        -. ,       ,        .</li>
<li> search engine      ,   Solr, ElasticSearch, Sphinx  .      «»         .    ,          ,       —     .      ,  search engine       ,    :     ,    ,    ;       search engine      .       —     .      « ».          «»    ,   ,            .      ,   -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">transactional outbox</a>      .</li>
</ul><br>
<h2></h2><br>
<ol>
<li>     —  ,             .   «»  «» —    ,      :<br>
<ul>
<li>                   —       .</li>
<li>   ,         ,    ,     .  -          —    .</li>
</ul></li>
<li>                ,          —         #2.</li>
<li>     faceted search,        :<br>
<ul>
<li>        .</li>
<li> search engine   Solr, ElasticSearch, Sphinx  .   ,         ,            . </li>
</ul></li>
<li>   faceted search              .      ,   ,        .</li>
<li>   SQL   ,   ,    ,           (   «» ).           ,   —  «».           ,        .</li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id493426/index.html">Organisasi kode dalam layanan microser dan pendekatan saya menggunakan arsitektur heksagonal dan DDD</a></li>
<li><a href="../id493428/index.html">"Kami tidak akan memunculkan teori konspirasi." Bicara tentang konferensi ML dengan orang-orang dari perusahaan sains dan TI</a></li>
<li><a href="../id493430/index.html">Arsitektur Net untuk Aplikasi Web</a></li>
<li><a href="../id493432/index.html">Mengapa tidak memulai karier di perusahaan kecil non-IT</a></li>
<li><a href="../id493436/index.html">Program untuk mengubah hak akses dan mendaftar nama file / direktori di Bash</a></li>
<li><a href="../id493440/index.html">Influencer Marketing in China: berdasarkan apa dan apa influencer dapat menawarkan dalam konteks keadaan darurat</a></li>
<li><a href="../id493442/index.html">Pengingat APD</a></li>
<li><a href="../id493444/index.html">Proyek "Kaca". Cangkir Teh / Kopi Sekali Pakai Efisiensi Energi</a></li>
<li><a href="../id493446/index.html">Bacaan Akhir Pekan: 10 Cerita Suara Tidak Biasa - Dari Permainan Mata-Mata dan Teori Konspirasi hingga ASMR yang Santai</a></li>
<li><a href="../id493448/index.html">Routing efisien pegas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>