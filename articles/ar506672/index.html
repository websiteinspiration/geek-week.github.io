<!doctype html>
<html class="no-js" lang="ar">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💚 🚻 💠 SwiftUI على الرفوف: الرسوم المتحركة ، الجزء 2 ⛵️ 🏰 🙁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="هذا هو الجزء الثاني من قصة الرسوم المتحركة في SwiftUI. في المقالة الأولى ، نظرنا في أمثلة بسيطة لأساسيات كيفية عمل الرسوم المتحركة في SwiftUI. في هذا ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SwiftUI على الرفوف: الرسوم المتحركة ، الجزء 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506672/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="صورة"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هذا هو الجزء الثاني من قصة الرسوم المتحركة في SwiftUI. في </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المقالة</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الأولى </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;">،</font></a><font style="vertical-align: inherit;"> نظرنا في أمثلة بسيطة لأساسيات كيفية عمل الرسوم المتحركة في SwiftUI. في هذا الجزء ، سنذهب إلى أبعد من ذلك ، وسنحلل بالتفصيل المثال المعلن عنه مع الرسوم المتحركة بألوان قوس قزح. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif" alt="صورة"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
تحت القطع سوف تجد تحليلاً لتوقيت الرسوم المتحركة ، وإنشاء آلية منحنى التوقيت الخاصة بك للعمل في الرسوم المتحركة الخطية المتكررة ، وأمثلة على تنفيذ التدرجات المختلفة وبعض الحيل المثيرة للاهتمام التي ستساعدك على فهم كيفية عمل الرسوم المتحركة تحت غطاء المحرك.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
دعني أذكرك بأنني تجسست على فكرة تنفيذ مثل هذه الرسوم المتحركة </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هنا</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . هناك ، اتخذ المؤلفون المسار الأقل مقاومة ، ونفذوا الطريقة الأكثر وضوحًا لتطبيق هذا المفهوم من خلال تحريك الشكل. المبدأ بسيط: كل موجة هي كفاف محدد بمنحنى بيزييه ، وتؤثر معلمة "الوقت" على موضع الحدود اليمنى لهذه الموجة. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هكذا تبدو الرسوم المتحركة النهائية: من </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="صورة"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
أجل الوضوح ، سوف أنشر الموجات قليلاً بشكل عمودي. من السهل القيام بذلك ، أضفت للتو في نهاية NotchWave تحريك المحيط بالكامل إلى ارتفاع الموجة ، وفقًا للمرحلة الحالية من الرسوم المتحركة:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">return</span> p.applying(.<span class="hljs-keyword">init</span>(translationX: <span class="hljs-number">0</span>, y: height * <span class="hljs-keyword">self</span>.phase))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
حسنًا وأيضًا .drowingGroup () من الضروري عدم نسيان قطع الاتصال - هذا لا يعني أن الصورة تتجاوز حدود الإطار الثابت. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z3/zv/bi/z3zvbiseywno8t1fnt-i0ugcqgm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
النهج بسيط ، ينتج النتيجة المرجوة ... ولكن بدا لي مملاً للغاية. </font><font style="vertical-align: inherit;">تبين أن طريقي أطول بكثير ، ولن أقول أن النتيجة النهائية ستكون أفضل إلى حد ما على الأقل ، لكنها ستكون مثيرة للاهتمام على طول الطريق. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
إذا كنت لا تزال غير مدرك جيدًا لمبادئ عمل الرسوم المتحركة في SwiftUI ، فإنني أوصي بشدة بقراءة </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المقالة السابقة</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">وأريد الخوض في شفرة المصدر على </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">جيثب</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">العمل مع التدرجات</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في البداية ، اخترت نهجًا مختلفًا. لقد وجدت أنه من المفيد أكثر التعامل مع الرسوم المتحركة لإزاحة الأشياء من الرسوم المتحركة للنماذج (ما زلت أسمي بنية شكل النموذج). يمكن أن تعمل الإزاحة مع أي شيء - الأشكال المختلفة والصور وطريقة عرض أخرى. كمهمة تعليمية ، أردت تنفيذ انتقال سلس للألوان من موجة إلى أخرى. في المفهوم الأصلي ، كان شيء من هذا القبيل. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في المجمل ، يقدم SwiftIUI ثلاثة استخدامات ممكنة للتدرج - الخطي ، الدائري ، الزاوي. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t7/o6/7d/t7o67dwcm_v5svufist7tfp0kwe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في التعليمات البرمجية ، يبدو هذا نوعًا من مُنشئ الكتلة. لاحظ كيف يتم تقسيم الموجة بأكملها.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wa/af/el/waafeltt9cgiasfzxg1gjexwc8i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يتميز التدرج الخطي بنقطة بداية ونهاية للتدرج. </font><font style="vertical-align: inherit;">هذه ليست نقاط CGPoint ذات إحداثيات مطلقة (x: y :) ، ولكن نقاط UnitPoint ، أي </font><font style="vertical-align: inherit;">إحداثيات نسبية ، حيث يتم تحديد x: y: بأجزاء من عرض وارتفاع المنطقة المحددة لهذا العرض. </font><font style="vertical-align: inherit;">هناك أيضًا نقاط محددة مسبقًا تتوافق مع الزوايا (.topLeading ، .bottomTrailing ، إلخ) ونقاط منتصف الجانبين (.top ، .trailing ، وما إلى ذلك).</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
    .fill(<span class="hljs-type">LinearGradient</span>(<font></font>
         gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
          startPoint: .leading,<font></font>
          endPoint: .trailing))<font></font>
    .frame(width: <span class="hljs-keyword">self</span>.gradientLength)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
جزء التدرج الخطي هو "المطاط". </font><font style="vertical-align: inherit;">لها عرض ثابت ، ولكن ارتفاعها غير محدد. </font><font style="vertical-align: inherit;">وبالتالي ، سيتم تعبئة المبلغ بالكامل. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
قصة أكثر تعقيدًا قليلاً مع تدرج دائري. </font><font style="vertical-align: inherit;">نشير إلى النقطة - مركز الدائرة ، نصف قطر بداية التدرج ونصف قطر نهاية التدرج. </font><font style="vertical-align: inherit;">نصف القطر بالفعل بالأرقام المطلقة ، أي </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">النقاط</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لا يزال مركز الدائرة معينًا على أنه UnitPoint.</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
     .fill(<span class="hljs-type">RadialGradient</span>(<font></font>
          gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">0</span>),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">1</span>)]),<font></font>
          center: .bottomTrailing,<font></font>
          startRadius: <span class="hljs-keyword">self</span>.topRadius,<font></font>
          endRadius: <span class="hljs-keyword">self</span>.topRadius + <span class="hljs-keyword">self</span>.gradientLength)<font></font>
                )<font></font>
    .frame(height: <span class="hljs-keyword">self</span>.topRadius)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
للقطعة ذات الدائرة العلوية ارتفاع ثابت ، لكنها تمتد أفقيًا. بعد كل شيء ، قمنا بتعيين نصف قطر ثابت محدد في النقاط ، لذلك ليس هناك حاجة لصق مستطيل تمدد إضافي من اللون الأساسي ، كما هو الحال مع التدرج الخطي. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
أصعب تطبيق هو التدرج الزاوي. يتم إعطاؤه بزاوية البداية والنهاية ، وكذلك الاتجاه. كما ترى من قائمة الرموز ، فإن العمل مع الزوايا ليس مناسبًا جدًا. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
عليك أن تتذكر مسار علم المثلثات المدرسي من أجل حساب الزاوية المطلوبة ، إذا كنت بحاجة إلى بدء التدرج الزاوي عند نقطة واحدة والانتهاء عند نقطة أخرى.</font></font><br>
<br>
<pre><code class="swift hljs">       
<span class="hljs-type">Rectangle</span>()<font></font>
      .fill(<span class="hljs-type">AngularGradient</span>(<font></font>
            gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.angularGradientMiddleStop(blockWidth: geometry.size.width)),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
            center: .bottomLeading,<font></font>
            startAngle: <span class="hljs-keyword">self</span>.directionTo(gradientPart: <span class="hljs-keyword">self</span>.start, blockWidth: geometry.size.width),<font></font>
            endAngle: <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)))<font></font>
<font></font>
...<font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">directionTo</span><span class="hljs-params">(gradientPart: Color, blockWidth: CGFloat)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> angleOf = gradientAngles(blockWidth: blockWidth)
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>.zero
        <span class="hljs-keyword">switch</span> gradientPart{
            <span class="hljs-keyword">case</span> start: angle = angleOf.start
            <span class="hljs-keyword">case</span> middle: angle = angleOf.middle
            <span class="hljs-keyword">case</span> end: angle = angleOf.end
            <span class="hljs-keyword">default</span>: <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"there is no gradient stop with that color: \(gradientPart)"</span>)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gradientAngles</span><span class="hljs-params">(blockWidth: CGFloat)</span></span> -&gt; (start: <span class="hljs-type">Angle</span>, middle: <span class="hljs-type">Angle</span>, end: <span class="hljs-type">Angle</span>){
        <span class="hljs-keyword">let</span> blockHeight = <span class="hljs-keyword">self</span>.bottomRadius
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: blockHeight)
        <span class="hljs-keyword">let</span> topRight = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength)
        <span class="hljs-keyword">let</span> topGradientStarts = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength * (<span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop))
        <span class="hljs-keyword">let</span> startAngle = center.radialDirection(to: topRight)
        <span class="hljs-keyword">let</span> middleAngle = center.radialDirection(to: topGradientStarts)
        <span class="hljs-keyword">let</span> endAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)
        <span class="hljs-keyword">return</span> (start: startAngle, middle: middleAngle, end: endAngle)<font></font>
    }<font></font>
<font></font>
...<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">CGPoint</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">radialDirection</span><span class="hljs-params">(to point: CGPoint)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> deltaX =  point.x - <span class="hljs-keyword">self</span>.x
        <span class="hljs-keyword">let</span> deltaY =  point.y - <span class="hljs-keyword">self</span>.y
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span> deltaX == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaY == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaX / -deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(-deltaX / deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
التدرج الزاوي ، وهو ذيل الموجة ، هو أيضًا مطاط ، ولكن بالفعل في العرض - يشغل نصف الحجم المتبقي. في الواقع ، هذا هو السبب في وجود الكثير من علم المثلثات. أنا أعرف موضع نقاط محددة على حدود الشاشة حيث يجب أن يكون لون معين (لأنني ألصق تدرجًا دائريًا بزاوية). علاوة على ذلك ، لا تعتمد قيم الزوايا فقط على نصف قطر التدرج السفلي ، ولكن أيضًا على عرض الكتلة نفسها مع التدرج. لأول مرة منذ المدرسة ، التقطت قلم رصاص وتذكرت الجبر :)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
تستخدم الخيارات الثلاثة وصفًا واحدًا للألوان داخل التدرج. </font><font style="vertical-align: inherit;">هذه قائمة بسيطة من الألوان في مصفوفة. </font><font style="vertical-align: inherit;">سيكون توزيعهم موحدًا على شريحة معينة. </font><font style="vertical-align: inherit;">يمكنك تحسين التوزيع باستخدام مصفوفة من عناصر التوقف. </font><font style="vertical-align: inherit;">في الواقع ، هذا هو نفس تعداد الألوان ، فقط لكل منها يتم الإشارة إلى الإحداثيات على قطعة واحدة حيث سيتم تحديد موقعها. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
وهكذا ، قمت بإنشاء موجة بنفس الشكل تقريبًا كما في المفهوم الأصلي. </font><font style="vertical-align: inherit;">ومع ذلك ، فإن الانتقال من لون إلى آخر ليس الآن حادًا ، ولكنه سلس ، مما قد يجعل الرسوم المتحركة أكثر سلاسة.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اللون ليس كما يبدو</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هناك نقطة واحدة تتعلق بالألوان. </font><font style="vertical-align: inherit;">لإنشاء تأثير موجة متدحرجة ، قررت أن أجعل الانتقال بين الألوان ليس خطيًا تمامًا. </font><font style="vertical-align: inherit;">إذا نظرت عن كثب ، ستلاحظ أن التدرج أكثر حدة عند الحافة نفسها ، وبعيدًا عن الحافة ، تتدفق أكثر سلاسة إلى اللون الرئيسي. </font></font><br>
<img src="https://habrastorage.org/webt/hb/k-/f-/hbk-f-u1tcrri8furxdgeg8tx50.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لقد حققت ذلك عن طريق حساب اللون المتوسط ​​، وإنشاء تدرج باستخدام هذا التوزيع:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اللون الأولي - 0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
اللون المتوسط ​​- 0.3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
اللون النهائي - 1</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
نشأت المشكلة مع حساب متوسط ​​لونين. يعني SwiftUI استخدام كائن اللون للتدرجات ، وتم إغرائي. في الواقع ، إذا كنت ترغب في العمل باستخدام الألوان تمامًا مثل كائنات RGB ، فاستخدم في البداية UIColor في نموذجك ، لأن اللون ليس لديه وصول مباشر إلى اللون. لا يمكنك بسهولة تحويلها مرة أخرى إلى UIColor أيضًا. الحل الوحيد </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(غير)</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> المناسب الذي وجدته </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هنا</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هو الحصول على انعكاس المرآة من خلال تحليل تمثيل السلسلة. مثل هذا المرجل ، ولكن لا توجد خيارات أخرى حتى الآن.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
وهذا ليس خطأ وليس إغفال. </font><font style="vertical-align: inherit;">النقطة هي أن SwiftUI في كائن اللون لا يكرر وظائف UIColor. </font><font style="vertical-align: inherit;">إذا كنت بحاجة إلى العمل مع قنوات RGB - استخدمه. </font><font style="vertical-align: inherit;">اللون في SwiftUI هو عرض يحتوي على بعض الألوان الأساسية ، وقد تختلف قيمته المحددة قليلاً اعتمادًا على موقع النجوم في السماء - يتم تحديد لون RGB محدد فقط في وقت الرسم على الشاشة. </font><font style="vertical-align: inherit;">تقول الوثائق</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SwiftUI يحلها فقط إلى قيمة ملموسة قبل استخدامها في بيئة معينة.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، ولكن المقصود بالبيئة: لون الجدار خلف ظهر المستخدم ، أو موضوع تصميم iOS غير واضح. </font><font style="vertical-align: inherit;">إذا كان هذا لا يناسبك ، فاستخدم UIColor أصلاً.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الرسوم المتحركة التي لا نهاية لها</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يتم تحديد الرسوم المتحركة بواسطة معدّل .imimation () ويبدأ بعد تهيئة العرض في المُعدِّل </font></font><code>.onAppear()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عن طريق تغيير </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المتغير. </font><font style="vertical-align: inherit;">ونتيجة لذلك ، </font></font><code>.rotationEffect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يشترك </font><font style="vertical-align: inherit;">المُعدِّل </font><font style="vertical-align: inherit;">في تلقي بيانات متحركة في الفاصل الزمني من "كان" إلى "أصبح" ، بما يتوافق مع مؤقت النظام. </font><font style="vertical-align: inherit;">تحدثنا عن هذا في الجزء الأخير.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
       <span class="hljs-keyword">return</span> <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>))
            <span class="hljs-type">Spacer</span>()<font></font>
       }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/fl/dw/_0/fldw_0xguydvz5fe_-2tpcp3qkm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
من خلال تشغيل الرسوم المتحركة التي لا نهاية لها بهذه الطريقة ، يجب أن تفهم أن أي تغيير لاحق في المعدلات المتحركة سوف "يكسر" ذلك. </font><font style="vertical-align: inherit;">على سبيل المثال ، إذا قمت ، بعد البدء ، لسبب ما ، بتغيير قيمة الزاوية إلى 0 ، تحصل على هذا التأثير:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ad/vi/iv/adviivgxhwuw0rwwv1itknh2kie.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لماذا ا؟ الإجابة في آلية الرسوم المتحركة للانتقال من رسم متحرك إلى آخر. في مثالنا ، عند ظهور العرض الأول على الشاشة ، بدأنا انتقالًا متحركًا من 0 إلى 90. يخزن العرض في الواقع القيمة النهائية فقط 90 ، ولا يتم تخزين القيمة الأصلية 0 في أي مكان. يعرف محرك الرسوم المتحركة الموضع الحالي للرسم المتحرك والقيمة الحالية للرسوم المتحركة. عند النقطة الزمنية 0.5 ، ستكون 45. ماذا يحدث إذا قام المستخدم في هذه اللحظة بتغيير القيمة إلى 0؟ الجواب: سوف تبدأ الرسوم المتحركة لتغيير القيمة من 45 إلى 0. ولكن فقط بصريا ، فإن الدورة ليست مغلقة ، ولكنها مكسورة.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بالإضافة إلى ذلك ، هناك حالات "يتعطل فيها" الرسم المتحرك أيضًا إذا كانت طريقة العرض الخاصة بك تستخدمOservservObject ، أو معلمات أخرى تتسبب في عرض العرض مرة أخرى. لحل هذه المشكلة ، يحتوي معدّل .imimation على معلمة animation (: value :). بتمرير القيمة هناك ، نشير إلى العارض أن إعادة تشغيل الرسوم المتحركة مطلوبة فقط عندما تتغير هذه القيمة.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ومع ذلك ، دعنا نكتشف كيفية إيقاف الرسوم المتحركة إذا لم نعد بحاجة إليها. للقيام بذلك ، تحتاج إلى تقديم شيئين. من الواضح أنه يجب أن نخبر SwiftUI أن الرسوم المتحركة التي لا نهاية لها لم تعد هناك حاجة إليها ، واستبدالها بالنهائي المعتاد. لكن هذا لا يكفى. يعد معدّل .animation () تعليمات حول التوقيتات المطلوب استخدامها ، ولكن يتم وصف التدوير نفسه داخل معدّل .rotationEffect () ، وهو مُشترك بالفعل لاستلام قيم جديدة لزاوية التدوير حسب المؤقت. لإيقاف الدوران ، نحتاج إلى تغيير قيمته أيضًا.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animation)<font></font>
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.angle == <span class="hljs-number">90</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">self</span>.animation = .<span class="hljs-keyword">default</span>
                }<span class="hljs-keyword">else</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span>
                    <span class="hljs-keyword">self</span>.animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/-o/-d/ui/-o-dui_0ep12qm5zwovo2iedvjm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
كما كان من قبل ، أدى تغيير قيمة الزاوية إلى بدء رسم متحرك جديد (الذي بدا مكسورًا) ، سيتم أيضًا تغيير هذا التغيير ، ولكن الآن مع توقيت الرسوم المتحركة العادية. هذا هو السبب ، يتوقف مربعنا عن الدوران ليس على الفور ، ولكن كما لو كان التباطؤ. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يمكن كتابة نفس الشيء بإيجاز أكثر قليلاً ، إذا قمت بتعليق جميع الوظائف في </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">متغير </font><font style="vertical-align: inherit;">واحد </font><font style="vertical-align: inherit;">من نوع التشغيل / الإيقاف:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isStarted = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
حتى هذه اللحظة ، كان كل شيء سهلاً نسبيًا. ولكن لاحظ أن جميع الأحداث هنا يتم إنشاؤها داخل العرض. </font></font><code>.onAppear{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم استدعاؤها من قبل النظام ، </font></font><code>onTapGesture{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وبطبيعة الحال ، من قبل المستخدم. ومع ذلك ، ماذا لو كنت ترغب في تغليف الرسوم المتحركة بالكامل داخل عرض واحد ، وتمريرها / إيقافها فقط؟ لا يعني SwiftUI إمكانية وجود أي طرق رئيسية من طريقة العرض الرئيسية. نظريًا ، يمكنك تخزين عرض الطفل كهيكل واستدعاء طرق تحويره ، ولكن </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لا يمكن تغيير متغيرات عرض الطفل بهذه الطريقة ، جربته - لا يعمل. الطريقة الوحيدة لفعل شيء كهذا هي استخدام Combine PassthroughSubject ، كما فعلت في المقالة. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في الواقع ، كل شيء أبسط بكثير. إذا وضعت بوضوح على الرفوف في الرأس ، فهذا</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هذه هي الحالة الداخلية للعرض ، وعدم محاولة التلاعب بها من الخارج ، سيكون الحل الصحيح بسيطًا جدًا:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButtonFromOutside</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectParentView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isOn = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">AnimatedRectStopButtonFromOutside</span>(isStarted: isOn)
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isOn.toggle()<font></font>
            }<font></font>
        }.onAppear(){<font></font>
            <span class="hljs-keyword">self</span>.isOn = <span class="hljs-literal">true</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في هذه الحالة ، لا نحتاج إلى </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اشتراك لتحديث العرض داخل العرض الفرعي - يتم تحديثه بالفعل ككل عندما تتغير المعلمة الخارجية إليه. </font><font style="vertical-align: inherit;">في بعض الأحيان يكون غير مناسب. </font><font style="vertical-align: inherit;">في بعض الأحيان لا نرغب في تهيئة العرض الفرعي مرة أخرى - على سبيل المثال ، حتى لا نقطع الرسوم المتحركة ، أو في init () تحدث بعض العمليات الحسابية المعقدة والمستهلكة للموارد (الاستعلامات ، على سبيل المثال). </font><font style="vertical-align: inherit;">في هذه الحالات ، من الأفضل استخدام كيانات الكائنات ، والتي يمكن رصد تغييراتها باستخدام معدِّل onReceive.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تعديل الحالة أثناء تحديث العرض</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هناك شيء آخر يستحق التغطية. قمنا بإجراء قيمتين فقط من 0 و 90 درجة. يؤدي إيقاف تشغيل الرسم المتحرك إلى إعادة تعيين الزاوية إلى 0. ولكن هل من الممكن إيقاف الرسم المتحرك مؤقتًا في اللحظة التي قمنا فيها بالنقر فوق الزر ومتابعته مرة أخرى من نفس المكان عند الاستئناف؟ دعونا نلقي نظرة على الرمز الذي يسمح بهذا:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRect</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> externalStarted = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(started externalStarted: <span class="hljs-type">Bool</span>){
        <span class="hljs-keyword">self</span>.externalStarted = externalStarted
        <span class="hljs-keyword">self</span>._internalStarted = <span class="hljs-type">State</span>(initialValue: !externalStarted)<span class="hljs-comment">//forse to start animation</span><font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-comment">//thats wrong. It just hiding a problem from SwiftUI not solving it</span>
        <span class="hljs-type">DispatchQueue</span>.main.async {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted == <span class="hljs-literal">false</span>{
                <span class="hljs-comment">// print("stop animation")</span>
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">false</span>
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted {
             <span class="hljs-comment">//    print("start animation")</span>
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">true</span>
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
       }<font></font>
         <font></font>
       <span class="hljs-keyword">return</span>  <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.red)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(internalStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e9/ci/ge/e9cigegcoxid1l9skuw2qxle238.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
الفكرة الرئيسية هي تتبع الوقت في بداية الرسوم المتحركة. بعد مرور بعض الوقت ، عندما يكون الأمر متروكًا لنا لإيقاف الرسوم المتحركة ، سنتمكن من التحقق من عدد دورات الرسوم المتحركة الكاملة التي مرت ، وتخمين زاوية دوران المربع الذي نراه في الوقت الحالي. بعد ذلك ، يمكننا تعيين </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هذه القيمة بالضبط لمتغير زاوية الدوران. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لكي يعمل هذا النهج ، نحتاج إلى تتبع بداية الرسوم المتحركة ونهايتها. لن يعمل الحرف الأول (). لا يمكننا الوصول </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إلى المعلمات </font><font style="vertical-align: inherit;">الموجودة </font><font style="vertical-align: inherit;">للحصول على وقت البدء السابق للرسوم المتحركة. هذا هو رمز </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المتغيرات. داخل init ، يمكنك فقط تعيين الحالة الأولية لهذا المتغير ، ولكن في نهاية التهيئة ، إذا كان العرض موجودًا بالفعل قبل init () ، </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">فسيتم استعادة </font><font style="vertical-align: inherit;">قيمة </font><font style="vertical-align: inherit;">المتغيرات.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لذلك ، يتم هنا تنفيذ المعلمة let externalStarted (التي نتحكم فيها من الخارج) ، والمعلمة </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الداخلية var varStarted ، والتي نتحكم فيها مباشرةً بالصورة المتحركة. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
كان هناك مفقود واحد فقط - بعض المُعدِّلات التي ستتحقق من توافقها وتحديثها إذا لزم الأمر ، مثل .onRecieve () ، للعمل فقط مع كل عرض. </font><font style="vertical-align: inherit;">ثم فكرت - بعد كل شيء ، يتم استدعاء الجسم لكل رسم ، فلماذا لا يتم هذا الفحص مباشرة فيه؟ </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
اتضح أن SwiftUI يقسم كثيرًا ، إذا كانت طريقة العرض أثناء تغيير قيمة </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المتغيرات ، فإنها تعطي</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تعديل الحالة أثناء تحديث العرض ، سيؤدي هذا إلى سلوك غير محدد.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ويمنع مثل هذا التغيير. ثم ذهبت لاختراق قذر ، واستخدم DispatchQueue.main.async. ولكن دعونا نرى لماذا هذا الاختراق القذر ، ولماذا لا يتم ذلك مطلقًا؟ </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هذه هي المشكلة في الواقع. إذا كتبنا داخل الجسم بعض الغباء الواضح مثل i + = 1 ، حيث أنا نوعًا ما</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">متغير ، ثم نحصل على حلقة لا نهائية. في وقت العرض ، نجعل العرض في الذاكرة غير ذي صلة - لأننا قمنا بتغيير البيانات الأولية للعرض. هذا يعني أنه فور اكتمال العرض ، سيتم وضع العرض الخاص بنا في قائمة الانتظار لإعادة العرض ، ولكن حتى ذلك الحين سنجعله غير ذي صلة على الفور. نحن نخلق دورة لا نهاية لها بأيدينا. المكالمة غير المتزامنة في هذه الحالة لا تغير أي شيء. إنه يحول قليلاً بدء الجولة التالية إلى اللحظة "مباشرة بعد التقديم". وبالتالي ، فإن المكالمة غير المتزامنة لا تحل المشكلة ، بل تخفيها فقط ، مما يمنع SwiftUI من خداعنا بأنفها. يبدو الأمر وكأنه في السيارة تمزق لمبة "فحص المحرك".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
من ناحية ، ما هو الخطأ في ذلك؟ في أي لغة برمجة ، هناك العديد من الطرق لتصوير نفسك في القدم إذا لم تفهم ما تفعله. ولكن من ناحية أخرى ، فإن هذا النهج ليس على الإطلاق كيف يجب أن يعمل SwiftUI. العمل مع طريقة العرض في وقت التشغيل أمر سيئ. نعم ، يمكنك التغلب على كعبيك في الصدر ، مع التأكد من كتابة الرمز الصحيح الذي لن ينتهي به الأمر في حلقة لا نهاية لها ... ولكن الأمر يشبه استرجاع غير آمن للخيار - إنه مجرد ممارسة سيئة. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
كما قلت ، في مثل هذه الحالات ، يجب عليك استخدام Combine ، وتمرير قيمة جديدة باستخدام PassthroughSubject. ولكن يمكنك الحصول على من خلال ObservableObject المعتاد من خلال الاشتراك في حدث willChange الخاص به.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandlerTest</span>
    <span class="hljs-keyword">let</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandlerTest</span>){
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)<font></font>
       }.onReceive(animationHandler.objectWillChange){<font></font>
            <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
            <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                withAnimation(.<span class="hljs-keyword">none</span>){<span class="hljs-comment">//not working:(((</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
                }<font></font>
            }<span class="hljs-keyword">else</span> {
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
        }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span>
            <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
النقطة المثيرة للجدل هنا هي استخدام قيم الكائن نفسه في الاشتراك في الإخطار بأن الكائن سيتم تغييره فقط. </font><font style="vertical-align: inherit;">حتى الآن ، في أمثلتي ، لدي كائن معدل بالفعل. </font><font style="vertical-align: inherit;">على ما يبدو ، تأتي الإشعارات مع بعض التأخير. </font><font style="vertical-align: inherit;">ولكن لا يمكنني أن أضمن أن هذا سيكون هو الحال دائمًا ، لذلك أنصحك إما باستخدام إشعارات didChange ذاتية الصنع ، أو PassthroughSubject ، لتمرير القيمة الجديدة من خلالها.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wj/ou/nd/wjoundfihtxhnar7iucx7rrkvnm.gif"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الرسوم المتحركة</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
كما ترى على gif ، لا تتوقف الرسوم المتحركة على الفور. </font><font style="vertical-align: inherit;">إنها تحتاج لبعض الوقت. </font><font style="vertical-align: inherit;">هذا لأنه عندما نعين قيمة وسيطة للزاوية ، فإننا نستخدم أيضًا رسمًا متحركًا معينًا - الافتراضي.</font></font><br>
<br>
<pre><code class="swift hljs">.animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هذا يؤدي إلى سلوك غير عادي. </font><font style="vertical-align: inherit;">على الرغم من البساطة النسبية لكل ما أصفه ، تظل مجموعة من الفروق الدقيقة في التفاعل تحت الغطاء بحيث تبدو الصورة سلسة دائمًا ، حتى إذا لم يبرمج المبرمج المهمل شيئًا ما. </font><font style="vertical-align: inherit;">لذلك ، فإن الرسم المتحرك الافتراضي هو الربيع. </font><font style="vertical-align: inherit;">هو الأنسب لمحاكاة قوانين الفيزياء. </font><font style="vertical-align: inherit;">وهذه حركة قصيرة إلى حد ما ، حوالي 0.2 ثانية. </font><font style="vertical-align: inherit;">إذا لم يكن للرسوم المتحركة للانتقال إلى حالة جديدة (الزاوية المحسوبة والموضحة من قبلنا) الوقت المناسب لتناسب بشكل افتراضي 0.2 ثانية بشكل افتراضي حتى يتم التبديل من سرعة الرسوم المتحركة الحالية مع تباطؤ جميل إلى توقف كامل ، فإن SwiftUI نفسه سيضيف حلقة أخرى من الرسوم المتحركة التي لا نهاية لها ، والتي يتم تشغيلها في الإصدار المسرَّع.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z0/b0/so/z0b0soljlzjqudxhek_irdxgyoy.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لتجنب ذلك ، يكفي عدم استخدام الرسوم المتحركة الافتراضية. </font><font style="vertical-align: inherit;">بالنسبة إلى المربع السفلي ، أوقفت الرسوم المتحركة لإيقاف التدوير مثل هذا:</font></font><br>
<br>
<pre><code class="swift hljs">                
.animation(animationHandler.isStarted ? animation : <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
أو يمكنك حساب القيمة المطلوبة للمعلمة بشكل أكثر دقة في وقت التوقف ، ولكن لهذا ، لا تحتاج فقط إلى افتراض اللحظة الحالية للرسوم المتحركة فحسب ، بل تعرفها تمامًا. </font><font style="vertical-align: inherit;">سأوضح أدناه كيفية القيام بذلك.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حركة عدة موجات في رسم متحرك واحد</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
العودة إلى الرسوم المتحركة بألوان قوس قزح. </font><font style="vertical-align: inherit;">لذا ، لدينا الأمواج بأنفسنا ، دعنا نعلمهم التحرك. </font><font style="vertical-align: inherit;">أول شيء أود القيام به هو تشغيل رسوم متحركة لا نهاية لها. </font><font style="vertical-align: inherit;">قررت أن أفعل ذلك بهذه الطريقة: سيكون لدي </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">متغير </font><font style="vertical-align: inherit;">واحد </font><font style="vertical-align: inherit;">مسؤول عن الموقع الحالي للرسوم المتحركة. </font><font style="vertical-align: inherit;">في الحالة 0 ، ستكون الموجة الأولى في البداية ، والأخيرة في النهاية. </font><font style="vertical-align: inherit;">سوف تتداخل الأمواج نفسها. </font><font style="vertical-align: inherit;">وبالتالي ، سيعتمد طول الجزء المرئي من كل موجة على عدد الموجات. </font><font style="vertical-align: inherit;">قمت بتطبيق هذا باستخدام ZStack ، الذي يسرد جميع الموجات ، ومعدل .wavePosition الخاص بي ، والذي أحسب فيه الموضع الحالي لكل موجة في لحظة الرسوم المتحركة ، والترتيب الذي تتداخل فيه.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الكثير من التعليمات البرمجية</font></font></b>
                        <div class="spoiler_text"><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpWavePosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">let</span> wave: <span class="hljs-type">WaveDescription</span>
    <span class="hljs-keyword">let</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    <span class="hljs-keyword">var</span> time: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> currentPosition: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
                <span class="hljs-keyword">self</span>.time = newValue
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(wave: <span class="hljs-type">WaveDescription</span>, time: <span class="hljs-type">CGFloat</span>, animationHandler: <span class="hljs-type">AnimationHandler</span>){
        <span class="hljs-keyword">self</span>.wave = wave
        <span class="hljs-keyword">self</span>.time = time
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-number">0</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(forWave: Int, ofWaves: Int, overTime: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{<font></font>
<font></font>
        <span class="hljs-keyword">let</span> time = overTime - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(overTime))
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(ofWaves)
        <span class="hljs-keyword">let</span> initialPosition = oneWaveWidth * <span class="hljs-type">CGFloat</span>(forWave)
        <span class="hljs-keyword">let</span> currentPosition = initialPosition + time
        <span class="hljs-keyword">let</span> fullRounds = <span class="hljs-type">Int</span>(currentPosition)
        <span class="hljs-keyword">var</span> result = currentPosition - <span class="hljs-type">CGFloat</span>(fullRounds)
        <span class="hljs-keyword">if</span> fullRounds &gt; <span class="hljs-number">0</span> &amp;&amp; result == <span class="hljs-number">0</span>{
            <span class="hljs-comment">// at the end of the round it should be 1, not 0</span>
            result = <span class="hljs-number">1</span><font></font>
        }<font></font>
 <span class="hljs-comment">//       print("wave \(forWave) in time \(overTime) was at position \(result)")</span>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(wave.totalWavesCount)
        <span class="hljs-keyword">var</span> thisIsFirstWave = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> currentPosition &lt; oneWaveWidth{<font></font>
            thisIsFirstWave = <span class="hljs-literal">true</span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span>
            <span class="hljs-type">Group</span>{<font></font>
                content<font></font>
                            .offset(x: -wave.width + currentPosition * (wave.width +  wave.gradientLength),<font></font>
                            <span class="hljs-comment">//to watch how waves move uncoment this</span>
                           <span class="hljs-comment">// y: CGFloat(self.waveInd * 20))</span>
                        y:<span class="hljs-number">0</span>)<font></font>
                    .zIndex(-<span class="hljs-type">Double</span>(currentPosition))<font></font>
                    .transition(.identity)<font></font>
                    .animation(<span class="hljs-literal">nil</span>)<font></font>
<font></font>
                <span class="hljs-keyword">if</span> thisIsFirstWave{<font></font>
                    content<font></font>
                        .offset(x: wave.gradientLength, y: <span class="hljs-number">0</span>)<font></font>
                        .zIndex(-<span class="hljs-number">2</span>)<font></font>
                        .transition(.identity)<font></font>
                        .animation(<span class="hljs-literal">nil</span>)<font></font>
                }<font></font>
            }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">positionOfSharp</span><span class="hljs-params">(wave: WaveDescription, inTime: CGFloat, animationHandler: AnimationHandler)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">SharpWavePosition</span>(wave: wave, time: inTime, animationHandler: animationHandler))<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpRainbowView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">let</span> waves: [<span class="hljs-type">SharpGradientBorder</span>]
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> rainbowPosition: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandler</span>,<font></font>
        backgroundColor: <span class="hljs-type">Color</span> = .clear<font></font>
    ){<font></font>
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">let</span> bottomRadius = animationHandler.waveGeometry.bottomRadius
        <span class="hljs-keyword">let</span> topRadius = animationHandler.waveGeometry.topRadius
        <span class="hljs-keyword">let</span> gradientLength = animationHandler.waveGeometry.gradientLength
        <span class="hljs-keyword">let</span> rainbowColors = animationHandler.rainbowColors
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">var</span> lastColor = rainbowColors.last <span class="hljs-keyword">else</span> {<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"no colors to display in rainbow"</span>)}
        <span class="hljs-keyword">var</span> allWaves = [<span class="hljs-type">SharpGradientBorder</span>]()
        <span class="hljs-keyword">for</span> color <span class="hljs-keyword">in</span> rainbowColors{
            <span class="hljs-keyword">let</span> view = <span class="hljs-type">SharpGradientBorder</span>(start: color,<font></font>
                                      end: lastColor,<font></font>
                                      bottomRadius: bottomRadius,<font></font>
                                      topRadius: topRadius,<font></font>
                                      gradientLength: gradientLength)<font></font>
            allWaves.append(view)<font></font>
            lastColor = color<font></font>
        }<font></font>
        <span class="hljs-keyword">self</span>.waves = allWaves<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">VStack</span>{
                <span class="hljs-type">ZStack</span>{
                    <span class="hljs-type">ForEach</span>(<span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){ind <span class="hljs-keyword">in</span>
                        <span class="hljs-keyword">self</span>.waves[ind]<font></font>
                            .positionOfSharp(wave: <span class="hljs-type">WaveDescription</span>(ind: ind,<font></font>
                                                    totalWavesCount: <span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">count</span>,<font></font>
                                                    width: geometry.size.width,<font></font>
                                                    baseColor: <span class="hljs-keyword">self</span>.waves[ind].end,<font></font>
                                                    gradientLength: <span class="hljs-keyword">self</span>.waves[ind].bottomRadius + <span class="hljs-keyword">self</span>.waves[ind].topRadius),<font></font>
                                             inTime: <span class="hljs-keyword">self</span>.rainbowPosition,<font></font>
                                             animationHandler: <span class="hljs-keyword">self</span>.animationHandler)<font></font>
                            .animation(<span class="hljs-keyword">self</span>.animationHandler.isStarted ? <span class="hljs-keyword">self</span>.animation : .linear(duration: <span class="hljs-number">0</span>))<font></font>
                    }<font></font>
                }<font></font>
     <span class="hljs-comment">//           .clipped()</span><font></font>
            }<font></font>
<font></font>
        }<font></font>
        .onAppear(){<font></font>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.rainbowPosition = <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
        .onReceive(animationHandler.objectWillChange){<font></font>
             <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
             <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                <span class="hljs-keyword">let</span> newPosition = <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"animated from \(self.rainbowPosition - 1) to \(self.rainbowPosition) stopped at \(newPosition)"</span>)
                    <span class="hljs-keyword">self</span>.rainbowPosition = newPosition<font></font>
             }<span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">self</span>.rainbowPosition += <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
 </code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في المرة الأولى التي يتم فيها عرض العرض على الشاشة ، نقوم بتغيير الحالة من 0 إلى 1 ، مما يجعل الموجات تعمل بلا توقف حول الشاشة ، مع مراعاة الرسوم المتحركة الخطية المعلنة. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/vr/ym/bgvrymyoubpekjmpgnsrtxxgco8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
عندما تصل حافة الموجة إلى الحافة اليمنى ، سيكون موضعها التالي في البداية ، وراء حافة الشاشة. ستبدو كما لو كانت ستختفي ببساطة من نهاية الموجة ، وتعرض الركيزة الخلفية ، والتي نود تجنبها. لهذا الغرض ، ظهرت كتلة if ... في المعدل ، في دالة body () ، حيث يتم رسم نسخة من الموجة الأولى المفقودة من الشاشة.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/6m/vt/si6mvtiimlv73kxy4c4imperxc4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يرجى ملاحظة أنه كان عليّ نقل الخصائص الهندسية لكل موجة في شكل معلمات التعديل. </font><font style="vertical-align: inherit;">كانت المشكلة أنني كنت بحاجة إلى إعادة تعريف مؤشر z لكل موجة بناءً على مرحلة الرسوم المتحركة الحالية. </font><font style="vertical-align: inherit;">يمكنني استخراج عرض المنطقة المرئية باستخدام معدّل GeometryReader {} بالداخل ، ومع ذلك ، واجهت حقيقة أنه يمنع تغيير ترتيب تراكب الأمواج. </font><font style="vertical-align: inherit;">يعمل معدّل .zIndex () فقط في سياق الحاوية الأولى ZStack {} أعلى التسلسل الهرمي للعرض. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يقوم GeometryReader بقطع هذا الاتصال ، ويتوقف zIndex () عن العمل. </font><font style="vertical-align: inherit;">إذا كنت تعتقد حتى هذه اللحظة أن GeometryReader طريقة غير ضارة للحصول على بيانات حول حجم العرض الحالي ، فهذا ليس صحيحًا تمامًا.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الرسوم المتحركة التدفق</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
نقطة أخرى مهمة هي فهم الرسوم المتحركة للمعدلات المضمنة داخل المعدلات الخاصة بك. عند نقطة ما ، تقترب كل موجة من حافة الشاشة ، لتحصل على أقصى إزاحة أفقية ، ثم تنتقل إلى وضع البداية ، لتحصل على الحد الأدنى للإزاحة. هذا هو نفس التغيير مثل أي تغيير آخر ، وهو متحرك ، حتى داخل الرسوم المتحركة. بعد كل شيء ، الرسوم المتحركة هي مجرد نقل متكرر للغاية للقيم إلى المُعدِّل ، وسيتم تنفيذها أيضًا مع الرسوم المتحركة ، بغض النظر عن مدى غرابة الصوت. اتضح أنه داخل الرسم المتحرك ، بتمرير قيمة جديدة داخل هذا المعدل ، نقوم فقط بتغيير نقطة النهاية للرسوم المتحركة المتحركة الحالية. اتضح أن كل موجة ، تصل إلى حافة الشاشة ، تستدير وتطفو مرة أخرى. لكنها لا تصل إلى البداية أيضًا ، ولكن عاجلاً أم آجلاً ستلحق بالوظيفة المطلوبة ،ثم يبدأ في التحرك من اليسار إلى اليمين مرة أخرى.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/aj/xp/ky/ajxpkyp6nxn-e6ixzzrv7y-g-c4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يمكنك حل هذه المشكلة عن طريق إدخال معدّل .imimation (لا شيء). وبالتالي ، أقوم بإيقاف تشغيل الرسوم المتحركة لجميع المعدلات المطبقة أعلاه في النص. هذا هو المنطق العام لعمل أي مُعدِّل: فهو يغير ما هو موجود على مدخلاته ، وعلى المُدخلات لدينا نتيجة عمل جميع المُعدِّلات السابقة.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بشكل عام ، تعمل هنا سلسلة هرمية كاملة من الرسوم المتحركة المختلفة. الإعداد الافتراضي هو الذي سيتم استخدامه لعرض التغييرات على جميع المُعدِّلات ، ما لم تحدد خلاف ذلك للعرض الخاص بك. لدينا خيط من التنفيذ (دعنا نقول أن هذا هو الرئيسي) ، حيث يتم استدعاء الجسم. نفترض أنه يحتوي على معلمة animation ، والتي يتم فحصها في كل مرة يتلقى فيها المُعدِل قيمة جديدة. إذا كان المعدّل يدعم الرسوم المتحركة (يتوافق مع بروتوكول AnimatableModifier) ​​، وتم تمكين الرسوم المتحركة للبث (يتم استخدام بعض الرسوم المتحركة المحددة ، وليس .لا شيء أو لا شيء) ، فسيتم تغيير الحركة. هذا ما نقوم به ، مع إرفاق بعض التعليمات البرمجية لتغيير </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المعلمات في كتلة withAnimation {} - نحن نصف حركة معينة في سلسلة المحادثات الحالية ، ثم نقوم بإجراء نوع من التغيير</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">متغير. في هذه الحالة ، مع Animation {} ، يعد هذا نوعًا من معادلة المعاملة ، وسيتم تنشيط جميع التغييرات التي تم إجراؤها على هذه المعاملة. نتيجة لذلك ، داخل نفس الدفق ، تبدأ دورة ترجمة هذه التغييرات إلى كل طريقة عرض تابعة ، وتتلقى معدّلات طريقة العرض هذه قيمة جديدة ، والاشتراك لتلقي قيم وسيطة من AnimatableData. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بالإضافة إلى ذلك ، هناك عناصر في الرسوم المتحركة لا يمكنك التأثير عليها. على سبيل المثال ، يتم تحريك موضع شريط التمرير في حد ذاته ، بواسطة آليات داخلية ، ولا يوجد شيء يمكن القيام به حيال ذلك.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
وبالتالي ، يعد withAnimation () طريقة لبدء الرسم المتحرك الافتراضي للعمل الذي يتم تنفيذه. ولكن بالنسبة إلى طرق عرض معينة ، يمكنك تحديد الرسوم المتحركة الخاصة بك بشكل صريح باستخدام معدّل animation (). في هذه الحالة ، تتلقى المعدلات والنماذج التي تشكل المحتوى الذي تم تمريره إلى .imimation () (كل ما هو مدرج في التعليمات البرمجية قبل تطبيق .animation ()) التوقيت الذي تصفه وتتجاهل حركة التدفق. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في مُعدِّل WavePosition ، أستخدم .imilation (لا شيء) للتخلص من الرسوم المتحركة المضمنة للإزاحة ، وبالتالي أرشدني إلى تجاهل الرسوم المتحركة الحالية للتيار.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
نفس القصة مع الغطاء النهائي. دعني أذكرك بالاستنتاجات من المقالة الأخيرة. في الواقع ، لدينا هياكل تعديل N WavePosition في ذاكرتنا ، واحدة لكل موجة. ويحصلون جميعًا على قيمة موضع جديدة من مؤقت النظام ، ويحسبون موضع كل موجة في نقطة زمنية معينة. هذا يعني أن لدينا أيضًا قبعات نهاية N لكل موجة. الأمر فقط أنه يتم عرض واحد منهم فقط في أي وقت ، وذلك بفضل كتلة if {}. ومع ذلك ، فإن نفس الكتلة تضع لنا خنزير. يتم أيضًا اختفاء ومظهر العرض مع الرسوم المتحركة للبث. هذا يعني أنه يتم استخدام معدّل النقل لتحريك مظهر واختفاء العرض بعد تغيير الحالة. عادة ، يتم استخدام .opacity بشكل افتراضي ، ولكن لسبب ما. تم استخدام الشريحة بدلاً من ذلك بالنسبة لي. لا أحد يناسبني ، لذا ألغيت هذه الرسوم المتحركة للتو ،باستخدام .transition (.identity).</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تحديث. </font><font style="vertical-align: inherit;">أثناء تحضير المقالة ، ظهر Xcode 11.4 ، حيث يبدو أنه تم إعادة صياغة الانتقال بشكل افتراضي. </font><font style="vertical-align: inherit;">على الأقل الآن علقت على .transition (.identity) دون أي مشاكل ولم أتلق المشكلة التي تسببت في إضافتها.</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">توقيت الرسوم المتحركة</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
والآن نأتي أخيرًا إلى السؤال الأكثر إثارة للاهتمام: كيف تجعل الموجات تتحرك بسرعة؟ </font><font style="vertical-align: inherit;">كالعادة ، سوف آتي من مكان بعيد.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في الواقع ، الرسوم المتحركة هي وصف لسرعة رسم متحرك معين. يمكننا تحديد المسار من النقطة A إلى النقطة B داخل المُعدِّل نفسه ، ولكن SwiftUI يقرر متى ونوع قيمة AnimatableData التي يتم تمريرها إليه. يفعل ذلك بمنحنى توقيت. افترض أننا أخذنا النقطة A كمنشأ ، وضع علامة على النقطة B كنقطة بإحداثيات (1 ؛ 1). أفقيًا ، سنحدد الوقت المنقضي (تستغرق الحركة من النقطة A إلى النقطة B وحدة واحدة من الوقت). عمودي - المسافة المقطوعة في أجزاء من الوحدة. عند استخدام الرسوم المتحركة الخطية ، نحصل مباشرة. إذا أردنا جعل الحركة مشابهة قليلاً للحاضر ، فعلينا أولاً أن نقضي بعض الوقت في التسارع ، وفي النهاية على الكبح. الحق </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هنا</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكنك اللعب بخيارات مختلفة من خلال رسم المنحنى الخاص بك ومقارنة الرسوم المتحركة المتحركة مع تلك القياسية. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في SwiftUI ، تُستخدم منحنيات Bezier لأنواع مختلفة من الرسوم المتحركة. </font><font style="vertical-align: inherit;">في أي حال ، يجب أن يبدأ عند (0 ؛ 0) وينتهي عند (1 ؛ 1). </font><font style="vertical-align: inherit;">يتم تحديد انحناء الخط بواسطة نقاط التحكم.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">منحنى التوقيت المتداخل داخل الرسوم المتحركة الخطية التي لا نهاية لها</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لذا ، ما الذي يتعين علينا القيام به لتحقيق الحركة المتسارعة لكل موجة (easyIn) داخل الرسوم المتحركة الخطية ذات الحلقات؟ </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
كان الخيار الأكثر تفصيلاً الذي يمكن أن أتوصل إليه هو تنفيذ منحنى التوقيت الخاص بي ، وتحويل التدفق الخطي للوقت معه إلى نوع .easeIn. </font><font style="vertical-align: inherit;">باستخدام هذا المثال ، يمكنك أن تفهم جيدًا كيفية عمل ذلك.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
الفكرة بسيطة. سنجعل فئتنا الخاصة ، بناءً على المسار - منحنى Bezier الذي سنحدد به المسافة من النقطة A إلى النقطة B ، والتي يجب عرضها في كل نقطة زمنية محددة. في الواقع ، هذه هي بالضبط كيفية عمل الرسوم المتحركة في SwiftUI ، وفي أي إطار آخر مع وظائف مماثلة. باستخدام منحنى التوقيت ، يتم تحويل الثواني والثواني الحقيقية (التي تتدفق غالبًا ، مع ذلك ، بشكل خطي) إلى أجزاء من المسافة (بتعبير أدق ، أجزاء من المقطع المتحرك - ناقل AnimatableData ، الذي يمثل التغيير الذي تم إجراؤه). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هنا أول تنفيذ لي:</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getActualPosition</span><span class="hljs-params">(of position: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-keyword">let</span> correctPosition = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">min</span>(position, <span class="hljs-number">1</span>), <span class="hljs-number">0</span>) / duration
        <span class="hljs-keyword">let</span> trimmingCurve = <span class="hljs-type">TimingCurve</span>.superEaseInPath
        <span class="hljs-keyword">if</span> correctPosition &lt; <span class="hljs-number">0.0000001</span>{
            <span class="hljs-keyword">let</span> reversedCurve = <span class="hljs-type">Path</span>(<span class="hljs-type">UIBezierPath</span>(cgPath: trimmingCurve.cgPath).reversing().cgPath)
            <span class="hljs-comment">//trim to start point is impossible, so reverce the curve and get last point</span>
            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = reversedCurve.currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve start point"</span>)}
            <span class="hljs-keyword">return</span> point.y<font></font>
        }<font></font>
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = trimmingCurve.trimmedPath(from: <span class="hljs-number">0</span>, to: correctPosition).currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve point at \(position)"</span>)}
        <span class="hljs-keyword">return</span> point.y * <span class="hljs-keyword">self</span>.duration<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
على ما يبدو ، كنت أحمق قليلا. بحكم التعريف ، يجب أن أجد نقطة على المنحنى تتوافق مع القيمة المعطاة لـ X وأعيدها إلى Y. لم أتمكن من العثور على طريقة قياسية قياسية لحل هذه المشكلة ، أو نمط شائع ، لذلك قررت تكييف طريقة القطع الحالية لهذه الأغراض ( ) قررت أن بإمكاني إعادة النظر في النهج جيدًا ، والحصول على النقطة المطلوبة من خلال الحصول على جزء المسار المقابل لجزء المسافة المقطوعة. بالنسبة للصفر ، ستُرجع هذه الطريقة القيمة 0 ، أما الرقم 1 فسيُرجع الرقم 1 ، حسنًا ، في الوسط ، ربما ، سيكون كل شيء صحيحًا تقريبًا.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
كنت على علم بأن هذا النهج لن يعطي نتيجة دقيقة للغاية ، ولكن شدة المشكلة ظهرت لاحقًا عندما حاولت إعادة إنتاج نفس الرسوم المتحركة بالضبط بطريقة قياسية. لقد فوجئت بمدى اختلافه ، وقررت التحقق من الرسم البياني إلى أي مدى ستكون النقاط التي تم الحصول عليها بهذه الطريقة من المنحنى الأصلي. النتيجة لم ترضيني. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fl/ed/s-/fleds-cdj4f8ellnui32gn-kiyk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ليست النقاط بعيدة عن المنحنى المطلوب فحسب ، بل إن طبيعة المنحنى مشوهة. هناك شبك إضافي ، لست بحاجة إليه على الإطلاق. ونتيجة لذلك ، كان لا يزال عليّ التوصل إلى طريقة دقيقة نسبيًا للعثور على نقطة على منحنى بيزيير ، مع معرفة إحداثية واحدة فقط:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
اضطررت إلى تخزين الكثير من الأجزاء في الذاكرة ، والتي تقع نهاياتها على منحنى معين. البحث عن Y بواسطة X معين مع هذا النهج هو البحث عن المقطع المقابل ، وتقسيمه إلى النصف ، إذا لزم الأمر ، حتى يقع أحد حدود هذا الجزء بالقرب من النقطة المطلوبة بما فيه الكفاية. في هذه الحالة ، نجد النقطة مع إحداثيات X المطلوبة تقع على هذا المقطع ونعيدها Y. إذا كنت تعرف طرقًا أبسط لإيجاد نقطة تقع على منحنى Bezier عشوائي ، باستخدام إحداثي معين ، اكتب في التعليقات. أعتقد أنه يمكن أن يكون مفيدا للكثيرين. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
نتيجة لذلك ، النقاط قريبة جدًا من الرسم البياني:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/bk/qi/wxbkqitda0fmf516tl1vjarqgoq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لقد صنعت كائنًا منفردًا لإنشاء منحنى توقيت لنقاط التحكم وتخزين مجموعة من المقاطع التي يتم البحث فيها عن ص. وبالتالي ، كل ما أحتاجه للعثور على نقطة معينة على المنحنى هو العثور على المقطع الذي ستقع فيه هذه النقطة ، وتقسيمه إلى نصفين حتى تصبح إحدى نهايات المقطع قريبة بشكل كافٍ من هذه النقطة للوقوع في خطأ معين ، ثم تُقسم قيمة Y خطيًا على X المعطى ، مع استبدال جزء من المنحنى بهذا المقطع. أنا لا أدعي أن هذه هي أفضل طريقة ، وأنها ستعمل في جميع الحالات. مرة أخرى ، اكتب في التعليقات إذا كنت تعرف طرقًا أفضل.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بمساعدة هذه الأداة ، يصبح تحويل الرسوم المتحركة الخطية إلى غير خطية أمرًا بسيطًا. </font><font style="vertical-align: inherit;">كل ما هو مطلوب هو وصف المنحنى بنقطتي تحكم ، وإعادة حساب الموضع على المقطع وفقًا لهذا المنحنى. </font><font style="vertical-align: inherit;">إذا كانت الرسوم المتحركة لفترات مختلفة مطلوبة ، فما زلنا نستخدم منحنى الوحدة باستخدام المعامل المناسب للإحداثيات X.</font></font><br>
<br>
<pre><code class="swift hljs">        
<span class="hljs-keyword">self</span>.timing = <span class="hljs-type">TimingCurve</span>.superEaseIn(duration: <span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> animatedPosition = timing.getY(onX: currentPosition)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هذه هي الطريقة التي تبدو بها الرسوم المتحركة ، جنبًا إلى جنب مع منحنى التوقيت الخاص بنا: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vf/f0/fe/vff0fe07bgvlvqhhuok5vy_w8ga.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
للحصول على الرمز الكامل ، مرحبًا بك في </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، شاهد ملف TimingCurveView. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بعد فهمك لهذا المثال ، ستفهم 100٪ كيفية ترتيب توقيت الرسوم المتحركة. </font><font style="vertical-align: inherit;">بالمناسبة ، يمكنك استخدام هذه المعرفة ، لأن SwiftUI يسمح لك بإنشاء منحنى التوقيت الخاص بك لنقاط التحكم باستخدام وظيفة timingCurve () ، واستخدامها مثل أي رسوم متحركة أخرى.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">انتقال</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
الآن ، لدينا رسوم متحركة لا نهاية لها مقبولة. يبقى فقط لمعرفة كيفية تشغيله وإيقافه. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
فكرة تحريك المظهر هي جعل كتلة الرسوم المتحركة تظهر فقط في المكان الذي تم تشغيله بالفعل ، ولكن سيتم سحب الستارة منه ، مثل ستارة في المسرح. إذا قمنا بمزامنة سرعة الستارة مع سرعة الموجات داخل الرسوم المتحركة ، وفي الستارة نفسها جعلنا التدرج من لون الخلفية إلى لون الموجة الحادثة الحالية ، نحصل على تأثير مرئي ، كما لو كانت هذه الستارة هي أول موجة متدحرجة. لمزامنة سرعة الحركة ، نستخدم ببساطة التوقيت نفسه لتحريك حركة الموجة. لحسن الحظ ، نحن نعرف الآن كيفية القيام بذلك.</font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.timingCurve(<span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.y),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.y),<font></font>
                                duration: <span class="hljs-number">1</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يسمح لك Animation.timingCurve (x: y :) بتعيين توقيت الرسوم المتحركة الخاص بك بناءً على نقاط التحكم في منحنيات Bezier. </font><font style="vertical-align: inherit;">عند الإخراج ، نحصل على كائن رسوم متحركة كامل ، مثل المألوف. الخطي (المدة: 1) ، والذي يمكن استخدامه دون قيود. </font><font style="vertical-align: inherit;">وبالنظر إلى أنني أستخدم نفس نقاط التحكم تمامًا في الرسوم المتحركة الموجية ، ستكون الرسوم المتحركة متزامنة.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سيكون من الأنسب تنظيم الكود ...</font></font></b>
                        <div class="spoiler_text">   .<br>
<br>
 ,           ,    ,          …     ,     ,     .  -  ,        —    .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يمكن تعطيل الرسوم المتحركة بالطريقة نفسها ، يجب أن تتسلق الستارة فقط على كتلة الرسوم المتحركة ، وتغلقها تدريجيًا. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
نشأت المشكلة الأولى في الوقت الذي كنت بحاجة فيه للحصول على الحالة الحالية للرسوم المتحركة من أجل اختيار لون الستارة. </font><font style="vertical-align: inherit;">للقيام بذلك ، قمت بإنشاء برنامج ObservableObject ، والذي أقوم بتمريره داخل المعدل ، وأقوم بتغييره داخل أداة تعيين AnimatableData. </font><font style="vertical-align: inherit;">من المهم أن نفهم هنا أن تغيير خاصية النشر @ 60 مرة في الثانية ليس هو ما تحتاجه على الإطلاق. </font><font style="vertical-align: inherit;">هذه هي كيفية تغيير </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المتغيرات داخل كتلة الجسم. </font><font style="vertical-align: inherit;">لا نحتاج إلى بدء أي شيء عندما تتغير حالة الرسوم المتحركة. </font><font style="vertical-align: inherit;">ولكن إذا احتجنا ، يمكننا معرفة حالة الرسوم المتحركة في أي وقت.</font></font><br>
<br>
<pre><code class="swift hljs">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">if</span> animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.time = newValue
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.time != <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition{
                    <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition = <span class="hljs-keyword">self</span>.time<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)
            <span class="hljs-keyword">if</span> currentPosition &lt; <span class="hljs-number">0.01</span>{<font></font>
                animationHandler.currentWaveBaseColor = wave.baseColor<font></font>
            }<font></font>
        }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هذا هو السبب في أنني لم أشترك في SharpRainbowView لتتبع تغييرات AnimationHendler: </font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لتوضيح تشغيل هذه الستائر ، سأقوم بتشغيل عرض ما يحدث خارج العرض ، مع تعليق .clipped (). بالإضافة إلى ذلك ، سوف أقوم بتحريك الستارة فوق الرسوم المتحركة قليلاً ، من أجل الوضوح. الآن أصبح الأمر أكثر وضوحًا ، أليس كذلك؟ </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/uf/0k/6suf0klfghhgxj95qfnrxd29zpe.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
كان يجب أن تكون الستائر قصيرة بحيث يتزامن المسار الذي تنتقل فيه كل موجة وستارة (وإلا فإنه سيتحول إلى عدم التزامن في الرسوم المتحركة) ، ولكن في نفس الوقت ، تمكنت من الاختفاء تمامًا من الشاشة. في نفس الوقت ، يتم ترتيب الستارة بتدرج من ثلاثة ألوان. هذا واضح للعيان على ستارة الإغلاق. هذا بسبب ذيول طويلة أحببتها كثيرًا في البداية.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
الشيء هو أن الموجة الأولى هي تدرج الألوان الأخيرة والأولى للصفيف المرسل. قد لا يتطابق أي منها مع لون الخلفية. لذلك ، كانت هناك حاجة للستائر بشكل عام. لجعل الستارة نغمتين ، من لون الخلفية إلى اللون الأساسي للموجة الأولى ، منعني طول الستارة. إنها ببساطة لا تتداخل مع الذيل الطويل للموجة الأولى ، ويتم الحصول على حد بلون واحد ، وذيل آخر. لذلك ، كان علي أن أصنع الستارة بقدر ثلاثة ألوان - أولاً من الخلفية إلى لون الموجة الأخيرة ، ثم من لون الموجة الأخيرة إلى الأولى. ثم يتناسب ذيل الموجة الأولى بشكل جيد مع حدود الستارة.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لنفس الأسباب تقريبًا ، جعلوا ستارة الإغلاق ثلاثية الألوان أيضًا. خلاف ذلك ، بدت الحدود غير طبيعية. ولكن نتيجة لذلك ، تحولت "الموجة" الأولى (ونعلم الآن أن هذا هو الستار الموضح في Transition.truncate) لتكون قصيرة. وعلى الرغم من أنها تتحرك بشكل متزامن تمامًا مع الموجة الأولى ، أي تسارع ، وليس خطي ، لا يتغير عرضه بمرور الوقت ، على الرغم من أن عرض الموجات اللاحقة يزيد بشكل مرئي. يمكن هزيمة ذلك عن طريق تغيير عرض الستارة ديناميكيًا ، لكنني كنت كسولًا بصراحة. دعونا نعتبر هذا واجبات منزلية لأولئك الذين يرغبون في الغوص في هذه الآليات وتدخين رمز (أعتذر لمثل هؤلاء الأشخاص مقدمًا ، هناك الكثير من آثار تجاربي التي يمكن أن تربكك).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هناك مشكلة واحدة. </font><font style="vertical-align: inherit;">إذا قمت بالضغط على الزر في وقت غير ناجح ، ستغطي ستارة الإغلاق الموجة التالية بالكاد. </font><font style="vertical-align: inherit;">لا تبدو جيدة للغاية. </font><font style="vertical-align: inherit;">يمكنك حل المشكلة عن طريق تقديم تأخير طفيف في إخفاء العرض مع الرسوم المتحركة. </font><font style="vertical-align: inherit;">لدينا طريقة لمعرفة الموقع الحالي للرسوم المتحركة ، نحتاج فقط إلى تأجيل بداية الانتقال قليلاً ، وستظهر الموجة الأخيرة دائمًا بشكل كامل.</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle animation"</span>).onTapGesture {<font></font>
                withAnimation(){<font></font>
                    <span class="hljs-keyword">var</span> delay: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.isShown{
                        <span class="hljs-keyword">let</span> waveChangeTime: <span class="hljs-type">Double</span> = <span class="hljs-type">Double</span>(<span class="hljs-number">1</span>) /  <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.rainbowColors.<span class="hljs-built_in">count</span>)
                        <span class="hljs-keyword">let</span> currentTime = <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition)
                        <span class="hljs-keyword">let</span> wavesPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(currentTime / waveChangeTime))<font></font>
                        delay =  (wavesPassed + <span class="hljs-number">1</span>) * waveChangeTime - currentTime<font></font>
                        delay = <span class="hljs-built_in">max</span>(delay - <span class="hljs-number">0.05</span>, <span class="hljs-number">0</span>)
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">"currentTime: \(currentTime); delay \(delay)"</span>)<font></font>
                    }<font></font>
                    <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + delay) {
                        <span class="hljs-keyword">self</span>.isShown.toggle()<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بالطبع ، يمكنك أيضًا جعل الستارة عرضًا متغيرًا لخلق الوهم بسرعات مختلفة للحدود بين الخلفية والستارة ، والستارة والموجة الأولى ، ولكن الآن تبدو الموجة الأولى غير طبيعية بعض الشيء ، لكنني بالفعل كسول جدًا لدرجة لا تقلق.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يحب الانتقال بطانة خنزير</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بشكل عام ، الرسوم المتحركة للمظهر والاختفاء ، بالنسبة لي ، هي أداة رائعة جدًا. ولكن يبدو أن هذا المفهوم جديد ، ولا تتعامل معه جميع الأدوات بشكل طبيعي. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لذا ، فإن معدّل .rotation3DEffect () يعمل على عكس العرض بنجاح مع بعض الرسوم المتحركة المعقدة في الداخل ، لكنه لا يعرف كيفية عكس .transition. كان من المخيب للآمال كتابة رمز موجز ، ومعرفة كيف تنتشر أمواجك بعيدًا عن وسط الشاشة ، ثم ترى ذلك على اليسار شاهد الستائر تعمل من اليسار إلى اليمين. اضطررت إلى كتابة مجموعة من الصفيحة المتداخلة ، بحيث يمكن أن يعمل معدّل الانتقال في كلا الاتجاهين.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pn/3c/fg/pn3cfg8f6zsersnfgdv5_ixrqu8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
أيضًا ، معدّل drowingGroup () ، الذي يمكنك من خلاله توصيل Metal لنقل وحدة معالجة الرسوميات ZStack مع عدد كبير من طريقة العرض المتداخلة ، خاصة طريقة العرض مع التدرجات ، لا يعرف كيفية الانتقال. </font><font style="vertical-align: inherit;">إنه لا يفهم الرسوم المتحركة للمظهر والاختفاء التي وصفتها أنت واستبدلها ببعضه.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لكن كيف نخفي شريط الحالة؟</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بسيط جدا. يحتوي SwiftUI على معدّل .statisBar (مخفي :). هنا فقط واجهة برمجة التطبيقات للتحكم في الانتقال لشريط الحالة الذي لا يوفره SwiftUI. للقيام بذلك ، سيتعين علينا الاستفادة من قدرات UIKit. يستخدم ملف SceneDelegate UIHostingController لتحويل عرض SwiftUI إلى UCit ViewController. في هذه المرحلة ، يكون من الأنسب استخدام بعض وظائف UIKit العالمية ، مثل العمل مع شريط الحالة ، أو تعطيل إيماءات النظام المرتبطة بحافة الشاشة (يفضل شاشة الشاشة أو الإشارة إلى النظام). يمكنك الوراثة من UIHostingController عن طريق تجاوز قيم بعض خصائص النظام ، واستخدام هذا السليل لتمرير العرض الخاص بك إلى rootViewController. لسوء الحظ ، لا يقبل سوى عدد محدود من الانتقالات شريط الحالة: .fade و .slide و .none. الافتراضي هو تلاشي ،وهي مناسبة هنا بشكل أفضل ، لذا دعنا نتركها كما هي. دعونا نأمل أن يستمر توسيع هذه الوظيفة.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
من أجل مزامنة الاختباء وظهور شريط الحالة مع حركة الموجة ، قمت بإنشاء طريقة عرض منفصلة ، حيث أقوم بتغيير قيمة هذه المعلمة بوقف مؤقت:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarHider</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isShown: <span class="hljs-type">Bool</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalIsShown = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">true</span>{
            <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="hljs-number">0.7</span>){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">false</span>{
            <span class="hljs-type">DispatchQueue</span>.main.async(){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-type">Spacer</span>()<font></font>
            .statusBar(hidden: internalIsShown)<font></font>
            .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0.3</span>))<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في الواقع ، تم تشكيل فاصل بسيط () هنا ، والذي أحتاجه بالفعل ، ولكن معدّل شريط الحالة ملفوف فوقه. بشكل عام ، بالطبع ، كان من غير المنطقي أن تقوم Apple بإخراج هذه الوظيفة إلى المعدلات ، مثل هذا لا ينطبق على العرض المحدد الذي تقوم بتعديله ، ولكن على ما يبدو لم يكتشف كيفية القيام بذلك بشكل أفضل. أكثر إثارة للاهتمام هو شيء آخر. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يستخدم نفس الاختراق القذر الذي اعتبرناه سابقًا: داخل الجسم ، أقوم ببعض الإجراءات في وقت التشغيل ، أثناء تغيير قيمة </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المتغير. المنطق ككل هو نفسه ، هناك معلمة هيكل يتم إرسالها من الخارج ، </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ومتغير يتم تعديله بعد مرور بعض الوقت ، مما يؤدي إلى اختفاء شريط الحالة أو ظهوره.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في هذه الحالة ، كنت بحاجة إلى هذا الاختراق لأن التحكم في الرسوم المتحركة لشريط الحالة هو وظيفة UIKit التي لا تزال سيئة التطوير في SwiftUI. </font><font style="vertical-align: inherit;">من الناحية النظرية ، أود أن أنقل الرسوم المتحركة المؤجلة لبدء التشغيل إلى معدّل .statusBar (مخفي :) ، ولكن هذا لا يعمل. </font><font style="vertical-align: inherit;">تم إصلاح الرسوم المتحركة للإخفاء وظهور شريط الحالة ، ولا يمكن تغييره بواسطة SwiftUI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في الواقع ، لم يمنعني شيء من إجراء نفس التغيير بشكل غير متزامن مع التأخير المطلوب ، ليس داخل هذا العرض ، ولكن في الأم ، حتى عندما نقر المستخدم على الزر - ولكن دعنا نتركه نصبًا تذكاريًا لمحاولاتي لمعرفة ما هو (وسبب آخر لإخباره) أن هذا لا ينبغي القيام به).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وكيف تم حشو حجم وموضع شريط الحالة فيEnvironment؟</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Environment (يجب عدم الخلط بينه وبينEnvironmentObject) عبارة عن غلاف يتيح الوصول إلى قائمة ثابتة من المتغيرات التي تعكس بيئة تطبيقنا. على سبيل المثال ، اتجاه الشاشة ، أو سمة لون نظام التشغيل. يسمح الغلاف نفسه بالاشتراك في طريقة العرض لتغيير هذه المعلمات. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يمكن توسيع هذه القائمة. اكتشفت أن امتلاكEnvironment يمكنه الوصول إلى حجم وموضع شريط الحالة سيكون صحيحًا. هنا كيف فعلت ذلك:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarFrame</span>: <span class="hljs-title">EnvironmentKey</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> defaultValue: <span class="hljs-type">CGRect</span> {
        <span class="hljs-type">CGRect</span>()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">EnvironmentValues</span> </span>{
    <span class="hljs-keyword">var</span> statusBarFrame: <span class="hljs-type">CGRect</span>{
        <span class="hljs-keyword">get</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>]<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>] = newValue<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
قمت بإنشاء بنية ذات قيمة افتراضية ثابتة. </font><font style="vertical-align: inherit;">بعد ذلك ، قمت بتوسيع بنية نظام SystemValues ​​عن طريق إضافة خاصية حسابي الخاصة ، والتي يشير المصطلح والمضيف منها إلى النوع الذي أنشأته. </font><font style="vertical-align: inherit;">يتم استخدام النوع هنا ، لأن EnvironmentValues ​​تطبق الرمز المنخفض الذي تقوم بتمرير النوع إليه وتحصل على القيمة المخزنة المقابلة لهذا النوع. </font><font style="vertical-align: inherit;">ليست قيمة هذا النوع ، ولكن القيمة المخزنة في القاموس الشرطي ، حيث النوع نفسه هو المفتاح. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يتم الوصول إلى القيمة فيEnvironment باستخدام keyPath \ .statusBarFrame. </font><font style="vertical-align: inherit;">على سبيل المثال ، لتمرير قيمة البيئة إلى كل عرض أسفل التسلسل الهرمي:</font></font><br>
<br>
<pre><code class="swift hljs">.environment(\.statusBarFrame, statusBarFrame) 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
وفي العرض نفسه لاسترداد القيمة من المتجر:</font></font><br>
<br>
<pre><code class="swift hljs">@<span class="hljs-type">Environment</span>(\.statusBarFrame) <span class="hljs-keyword">var</span> statusBarframe: <span class="hljs-type">CGRect</span> 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بالمناسبة ، للعمل مع شريط الحالة في كائن UIWindowScene في IOS 13 ، ظهرت السمة statusBarManager. </font><font style="vertical-align: inherit;">يمكن استخلاص بعض المعلمات منه. </font><font style="vertical-align: inherit;">ولكن الآن لا يمكنك إدارتها. </font><font style="vertical-align: inherit;">كما أفهمها ، كان من الممكن في وقت سابق الوصول إلى شريط حالة ViewController وإضافة عرض فرعي إليه. </font><font style="vertical-align: inherit;">على ما يبدو ، أغلقوا المقعد. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بشكل عام ، أود أن أنقل وظائف معدّل .statusBar (مخفي :) هنا بالضبط ، هنا سيكون أكثر ملاءمة ، بالنسبة لي. </font><font style="vertical-align: inherit;">أعتقد أن المطورين سيصلون إلى هذه النقطة عاجلاً أم آجلاً.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">استنتاج</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
حسنًا ، أعتقد أنه في هذا المثال الرائع ، يمكن اعتبار رحلة إلى الرسوم المتحركة باستخدام أدوات SwiftUI كاملة. باستخدام أمثلة بسيطة ، تحدثت عن أدوات الرسوم المتحركة الرئيسية ، وأخبرت كيف تعمل بالضبط تحت غطاء المحرك ، وكيف يجب استخدامها ولماذا بالضبط. باستخدام أمثلة أكثر تعقيدًا ، أظهرت صعوبات نموذجية قد تواجهك وطرق التغلب عليها.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هل كان الرمز الخاص بي ، بالمقارنة مع المثال الوارد في المقالة أعلاه ، أنظف أو أكثر وضوحًا أو أقصر أو ربما يكون من الأسهل الحفاظ عليه؟ ربما لا. هل تستهلك موارد أقل؟ للأسف لا. ربما يكون نهجي أكثر شمولية ، لكن هذا ليس دقيقًا. ومع ذلك ، هناك مهمة واحدة يؤديها بشكل أفضل بالتأكيد. يوضح بشكل أعمق عملية SwiftUI تحت غطاء المحرك. باستخدامه ، يمكنك وضع الرسوم المتحركة على الرفوف في رأسك وتطبيقها بحرية في تطبيقاتك.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
تم نشر SwiftUI بنشاط. </font><font style="vertical-align: inherit;">حتى الآن ، بعد أسبوعين من كتابة الرمز للمقالة الأولى ، الآن ، بعد التحقق من الرمز في الإصدار الحالي من Xcode ، أرى كيف تم إصلاح بعض الأخطاء التي كان علي تجاوزها بالفعل. </font><font style="vertical-align: inherit;">لذلك ، بقيت قليلاً مع المقالة. </font><font style="vertical-align: inherit;">كان لا بد من قطع شيء لعدم أهميته ، وكل شيء آخر - للتحقق مرة أخرى. </font><font style="vertical-align: inherit;">ويشاء. </font><font style="vertical-align: inherit;">SwiftUI هو بالتأكيد مستقبل تطوير iOS الأصلي ، ومن المفيد للغاية الوقوف في أصوله وملاحظة كيفية تطويره.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">خاتمة</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في عملية إعداد المواد لهذه المقالة ، قمت أيضًا بوضع الكثير من الأشياء في رأسي. </font><font style="vertical-align: inherit;">اكتشفت الكثير من الفروق الدقيقة التي لم تكن لدي أي فكرة عنها عندما بدأت للتو في كتابتها. </font><font style="vertical-align: inherit;">لذلك ، أحث كل من لديه خبرة بالفعل في تطوير SwiftUI - لا تخجل ، شارك تجربتك ومعرفتك. </font><font style="vertical-align: inherit;">هذا مفيد جدًا للمجتمع وللكامل لمعرفتك الخاصة. </font><font style="vertical-align: inherit;">هذا أكثر برودة من </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">طريقة البطة</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، وهناك أيضًا حاجة لصياغة الإجابة. </font><font style="vertical-align: inherit;">الشيء الرئيسي هو ألا تكون كسولًا للبحث عن مثل هذه الإجابة حتى لا يكون محرجًا </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أن يظهر الأولاد</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar506648/index.html">Laravel Digest (8-14 يونيو 2020)</a></li>
<li><a href="../ar506658/index.html">تم إصدار GitLab 13.0 مع مجموعات Gitaly والتسلسل الهرمي الملحمي على خرائط الطريق والنشر التلقائي لـ ECS</a></li>
<li><a href="../ar506662/index.html">التقسيم التكيفي لمنحنيات بيزير من الدرجة الثانية والثالثة</a></li>
<li><a href="../ar506664/index.html">ملخص المواد الطازجة من عالم الواجهة الأمامية للأسبوع الماضي رقم 419 (8-14 يونيو 2020)</a></li>
<li><a href="../ar506666/index.html">قوام ORM ، ولكن هل يستحق ذلك؟</a></li>
<li><a href="../ar506676/index.html">قطر: المركز العالمي للزرع والمدينة الليلية</a></li>
<li><a href="../ar506680/index.html">.NET Core vs Node.js. الحجج والحقائق</a></li>
<li><a href="../ar506684/index.html">كيف قمت بنقل dedic.ru إلى صفحات github وكنت راضيًا</a></li>
<li><a href="../ar506686/index.html">الأحداث الرقمية في موسكو من 15 إلى 21 يونيو</a></li>
<li><a href="../ar506688/index.html">الأحداث الرقمية في سان بطرسبرج من 15 إلى 21 يونيو</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>