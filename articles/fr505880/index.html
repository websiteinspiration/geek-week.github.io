<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔋 🏇🏿 🚶🏾 Comment écrire votre index dans Tarantool 😥 😪 😃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tarantool est un serveur d'applications et une base de données. La partie serveur est écrite en C, et l'utilisateur dispose d'une interface Lua pour t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Comment écrire votre index dans Tarantool</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/505880/"><img src="https://habrastorage.org/webt/_w/oc/me/_wocmecfrb1lnc7gdoodtf3j3y4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tarantool est un serveur d'applications et une base de données. </font><font style="vertical-align: inherit;">La partie serveur est écrite en C, et l'utilisateur dispose d'une interface Lua pour travailler avec. </font><font style="vertical-align: inherit;">De plus, Tarantool est un produit open source, ce qui signifie que le code source est dans le domaine public, et vous pouvez librement développer et distribuer des logiciels basés sur Tarantool. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais aujourd'hui, l'histoire sera un peu différente: à propos de l'expérience, à propos de l'écriture de votre propre structure de données pour la recherche (courbe d'ordre Z) et à l'intégrer dans l'écosystème Tarantool existant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je suis développeur dans l'équipe Tarantool Solution, je ne suis pas directement impliqué dans le développement de Tarantool, mais je suis un utilisateur actif. </font><font style="vertical-align: inherit;">Par conséquent, pour moi, cette expérience est une tentative de comprendre comment Tarantool fonctionne à bas niveau.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce que Tarantool et où stocke-t-il les données?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qu'est-ce que Tarantool? Dans le monde des bases de données, il se positionne comme une technologie en mémoire. Le moteur memtx vous permet de stocker toutes vos données dans la RAM, tout en respectant tous les principes de l'ACID. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un analogue des tables relationnelles dans Tarantool est l'espace, qui est conçu pour stocker des tuples (tuples). Contrairement aux tables relationnelles, les tuples dans un espace peuvent généralement être de longueur arbitraire. Pour les stocker, une structure de données de recherche doit être créée et la clé de recherche est la clé primaire, toujours unique.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez également créer des structures supplémentaires - des index secondaires qui stockent uniquement un pointeur sur un tuple. </font><font style="vertical-align: inherit;">L'index secondaire peut ne pas être unique, cependant, ce n'est que le comportement externe visible par l'utilisateur. </font><font style="vertical-align: inherit;">Les champs d'index principal sont implicitement ajoutés à tout index non unique. </font><font style="vertical-align: inherit;">Cela garantit la stabilité du tri des tuples dans l'index. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tarantool prend en charge différents types d'index:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, dans </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-Tree</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (et si absolument précis, alors B + * - Tree). </font><font style="vertical-align: inherit;">Beaucoup de [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-Tree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] a été </font><font style="vertical-align: inherit;">écrit sur la structure des B-arbres </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Je note seulement que les données sont stockées sous forme triée, en plus, vous pouvez rechercher par le préfixe de la clé indexée.</font></font></li>
<li>   <strong>hash-</strong>. ,      .    .    B-,      ,  .    .</li>
<li><strong>R-Tree</strong>.      .    «» , ,  .       — .     ,       .        .   ,      ,    .</li>
<li><strong>Bitset</strong>. ,     .   ,            ,   .</li>
</ul><br>
<h3> Z-,   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'où est venue l'idée d'écrire votre index, et assez exotique? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois, je suis tombé sur des articles d'Amazon [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1, 2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ], qui parlaient d'une structure telle que la courbe d'ordre Z, ou la courbe de Morton. Il s'agit d'une recette pour l'emplacement des données "multidimensionnelles" à l'intérieur d'une structure plate (courbe d'ordre Z), qui s'inscrit ensuite dans un arbre B. Une telle approche devrait aider à éviter une analyse continue des données. En général, les informations sur tout objet avec un certain ensemble de caractéristiques peuvent être considérées comme des données multidimensionnelles. Par exemple, la taille, le poids, la taille du pied, etc. la personne. La plupart des bases de données utilisent R-Tree à cet effet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un peu sur la façon dont la courbe de l'ordre Z est structurée.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/363/a10/2c9/363a102c99adb088e19052945e6298fb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une courbe d'ordre Z, également connue sous le nom de courbe de Morton, est obtenue en entrelaçant des bits des coordonnées d'un point dans l'espace. </font><font style="vertical-align: inherit;">Les adresses Z ainsi obtenues ont la propriété de localité. </font><font style="vertical-align: inherit;">Les points situés à proximité dans un espace multidimensionnel seront toujours situés à proximité lorsqu'ils sont affichés sur une ligne plate. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un mélange schématiquement similaire ressemble à ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6eb/04c/f2b/6eb04cf2b6ac3f0b26613a774c8f479d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment ça fonctionne? </font><font style="vertical-align: inherit;">Nous limitons une certaine région dans l'espace - un hypercube (il y aura un rectangle dans un espace à deux dimensions) - à l'aide de deux points situés sur la diagonale, qui sont affichés en deux points sur la ligne. </font><font style="vertical-align: inherit;">Et nous obtenons un effet secondaire désagréable: certains points vont au-delà de la boîte englobante:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/991/fd9/889/991fd9889fa6f3b4b30fd7adecfcd436.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, nous ne pouvons pas simplement parcourir cette courbe. Mais, armé d'un algorithme spécial, nous pouvons faire un saut en partant à l'étranger, en revenant à la zone de recherche. Dès que nous dépassons le point extrême de la courbe (appelons-le upper_bound), la recherche est terminée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque vous travaillez avec l'arbre B, nous aurions un ensemble d'intervalles, et cette requête conduirait à une analyse séquentielle de l'arbre B, ce qui prendrait beaucoup de temps avec un grand ensemble de données. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mon intérêt a été alimenté par d'autres publications sur cette courbe. Par exemple, comment il a été intégré à TransBase [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ], une base de données propriétaire. Et, malheureusement pour moi, je n'ai trouvé aucune implémentation open source de cette structure.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La courbe sous-jacente de l'arbre B présente plusieurs avantages par rapport à l'arbre R. </font><font style="vertical-align: inherit;">Par exemple, une meilleure occupation et compacité. </font><font style="vertical-align: inherit;">Inconvénients: la plupart des algorithmes utilisés sont limités par le processeur. </font><font style="vertical-align: inherit;">A titre de comparaison, j'ai décidé d'utiliser Tarantool: j'étais intéressé par les vitesses de lecture / insertion, ainsi que par la consommation mémoire. </font><font style="vertical-align: inherit;">Il est impossible de ne pas mentionner qu'un sujet similaire a déjà été soulevé sur Habré, mais pour les petites dimensions (2-3) et en relation avec la base de données de disques PostgreSQL [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZcurvePostgres</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ].</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que fallait-il pour intégrer Tarantool?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai trouvé des implémentations simples de cette structure pour les dimensions 2-3, mais je voulais comparer les performances avec l'index R-Tree existant, donc je ne voulais pas me limiter aux petites dimensions. J'ai choisi la même dimension que R-Tree - 20. Pour cela, j'avais besoin d'une bitmap prenant en charge certaines opérations primitives: extraction / modification d'un bit, décalage, opérations logiques OR / AND. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour le prototype, j'ai pris l'implémentation open source trouvée, mais j'ai rapidement conclu que je n'avais pas besoin d'un bitmap à usage général: la longueur de la clé est toujours un multiple de 64, donc certaines opérations sont grandement simplifiées. J'ai écrit ma propre implémentation en fonction de ce que j'avais. De plus, au lieu d'utiliser les fonctions système pour allouer de la mémoire, j'ai commencé à utiliser des allocateurs spéciaux implémentés dans Tarantool [</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peut-être que le cœur de l'index est un ensemble d'algorithmes pour travailler avec la courbe Z. </font><font style="vertical-align: inherit;">À savoir, calculer l'adresse Z (à l'aide de tables de recherche spéciales), vérifier si l'adresse Z appartient à la zone de recherche et détecter la première occurrence dans la zone de recherche, à partir du point spécifié. </font><font style="vertical-align: inherit;">Si vous recherchez bien sur le Web, vous pouvez trouver des publications scientifiques décrivant ces algorithmes, alors tout ce que j'avais à faire était de les implémenter, de les déboguer et, si possible, de les optimiser. </font><font style="vertical-align: inherit;">Il était censé stocker les adresses Z à l'intérieur de l'arbre B déjà implémenté utilisé pour l'index TREE.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment est organisé le traitement des données?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cas le plus général, le tuple nous parvient. Il s'agit d'un tableau de données au format pack de messages. Et dans le cas idéal, il suffirait d'isoler les champs indexés, de mélanger leurs bits et d'insérer l'adresse avec le pointeur sur le tuple à l'intérieur de l'arbre B.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, tout serait si simple si nous travaillions uniquement avec le type non signé, lorsque les représentations binaires triées des nombres correspondraient aux nombres triés dans une représentation naturelle. Les entiers signés ont leurs propres règles de présentation, les nombres à virgule flottante ont les leurs. Et cela devait déboucher sur un dénominateur commun. Étant donné que nous stockons l'adresse Z séparément des données elles-mêmes, nous pouvons effectuer toutes les transformations sur nos clés, l'essentiel est de maintenir l'ordre de tri. Cela peut être fait en utilisant de simples manipulations au niveau du bit. Par exemple, pour les entiers signés, vous pouvez simplement inverser l'octet de poids fort. Pour d'autres types, il existe des transformations similaires, quoique légèrement plus complexes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tous les types numériques tiennent sur 8 octets, donc la clé résultante aura une taille de N * 8 octets, où N est la dimension de notre espace. Que faire des cordes? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La recherche de préfixes est une situation assez courante lorsque vous travaillez avec des chaînes. Et il est tout à fait possible de soutenir. Les 8 premiers octets de la chaîne peuvent très bien être utilisés comme clé. Si la chaîne est plus courte, elle peut être complétée par des zéros. Le support des chaînes impose une limitation fondamentale à notre index: nous perdons l'unicité. Même si les lignes diffèrent dans le neuvième octet, alors du point de vue du système, elles seront toujours les mêmes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons le code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'API d'index se compose d'un ensemble spécifique de méthodes. Nous ne les considérerons pas individuellement, nous ne passerons en revue que les plus élémentaires, à savoir les opérations de recherche et d'insertion.</font></font><br>
<br>
<code>get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- rechercher un article par la touche complète. Fonctionne uniquement pour les index uniques. Notre index ne peut pas être unique, par conséquent, la fonction est remplacée par une version générique spéciale qui renvoie l'erreur «Fonction d'index non prise en charge». </font></font><br>
<br>
<code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- insérer un élément. Examinons plus en détail.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>
<span class="hljs-title">memtx_zcurve_index_replace</span><span class="hljs-params">(struct index *base, struct tuple *old_tuple,
        struct tuple *new_tuple, <span class="hljs-keyword">enum</span> dup_replace_mode mode,
        struct tuple **result)</span>
</span>{<font></font>
    (<span class="hljs-keyword">void</span>)mode;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_zcurve_index</span> *<span class="hljs-title">index</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">memtx_zcurve_index</span> *)<span class="hljs-title">base</span>;</span>
    <span class="hljs-keyword">if</span> (new_tuple) {
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_zcurve_data</span> <span class="hljs-title">new_data</span>;</span><font></font>
        new_data.tuple = new_tuple;<font></font>
        new_data.z_address = extract_zaddress(new_tuple,<font></font>
                &amp;index-&gt;bit_array_pool, index);<font></font>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_zcurve_data</span> <span class="hljs-title">dup_data</span>;</span>
        dup_data.tuple = <span class="hljs-literal">NULL</span>;<font></font>
        dup_data.z_address = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
        <span class="hljs-keyword">int</span> tree_res = memtx_zcurve_insert(&amp;index-&gt;tree, new_data,<font></font>
                &amp;dup_data);<font></font>
        <span class="hljs-keyword">if</span> (tree_res) {<font></font>
            diag_set(OutOfMemory, MEMTX_EXTENT_SIZE,<font></font>
                     <span class="hljs-string">"memtx_zcurve_index"</span>, <span class="hljs-string">"replace"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (dup_data.tuple != <span class="hljs-literal">NULL</span>) {<font></font>
            *result = dup_data.tuple;<font></font>
            z_value_free(&amp;index-&gt;bit_array_pool, dup_data.z_address);<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (old_tuple) {
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_zcurve_data</span> <span class="hljs-title">old_data</span>, <span class="hljs-title">deleted_value</span>;</span><font></font>
        old_data.tuple = old_tuple;<font></font>
        old_data.z_address = extract_zaddress(old_tuple,<font></font>
                &amp;index-&gt;bit_array_pool, index);<font></font>
        memtx_zcurve_delete_value(&amp;index-&gt;tree, old_data, &amp;deleted_value);<font></font>
        z_value_free(&amp;index-&gt;bit_array_pool, old_data.z_address);<font></font>
        z_value_free(&amp;index-&gt;bit_array_pool, deleted_value.z_address);<font></font>
    }<font></font>
    *result = old_tuple;<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À quoi devez-vous faire attention? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En termes de l'indice, il n'y avait pas de </font><font style="vertical-align: inherit;">transactions étaient </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Toute leur logique est exécutée dans cette méthode, qui reçoit les anciens et les nouveaux tuples, ainsi que des </font></font><code>mode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">informations sur si l'index est unique ou non. </font><font style="vertical-align: inherit;">Notre index ne peut pas être unique, donc aucune vérification supplémentaire n'est requise et vous pouvez immédiatement insérer un tuple. </font></font><br>
<br>
<code>memtx_zcurve_insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>memtx_zcurve_delete_value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- les méthodes de l'arbre B, qui ont déjà été implémentées dans Tarantool et sont utilisées dans l'index TREE régulier. </font><font style="vertical-align: inherit;">Nous ne nous attarderons pas sur eux séparément. </font><font style="vertical-align: inherit;">Contrairement à TREE ordinaire, nous stockons non seulement un tuple, mais aussi une adresse z - les bits mixtes des parties indexées. </font><font style="vertical-align: inherit;">La fonction en est responsable </font></font><code>extract_zadress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<code>create_iterator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- de Lua nous nous référons à cette méthode dans le cas de </font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'a et</font></font><code>pairs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'et.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> struct iterator *
<span class="hljs-title">memtx_zcurve_index_create_iterator</span><span class="hljs-params">(struct index *base, <span class="hljs-keyword">enum</span> iterator_type type,
                                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, <span class="hljs-keyword">uint32_t</span> part_count)</span>
</span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_zcurve_index</span> *<span class="hljs-title">index</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">memtx_zcurve_index</span> *)<span class="hljs-title">base</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_engine</span> *<span class="hljs-title">memtx</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">memtx_engine</span> *)<span class="hljs-title">base</span>-&gt;<span class="hljs-title">engine</span>;</span><font></font>
<font></font>
    assert(part_count == <span class="hljs-number">0</span> || key != <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> (type != ITER_EQ &amp;&amp; type != ITER_ALL &amp;&amp; type != ITER_GE) {<font></font>
        diag_set(UnsupportedIndexFeature, base-&gt;def,<font></font>
                 <span class="hljs-string">"requested iterator type"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">uint8_t</span> index_dim = base-&gt;def-&gt;key_def-&gt;part_count;
    <span class="hljs-keyword">if</span> (part_count == <span class="hljs-number">0</span>) {
        <span class="hljs-comment">/*
         * If no key is specified, downgrade equality
         * iterators to a full range.
         */</span><font></font>
        type = ITER_GE;<font></font>
        key = <span class="hljs-literal">NULL</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index_dim * <span class="hljs-number">2</span> == part_count<font></font>
               &amp;&amp; type != ITER_ALL) {<font></font>
        <span class="hljs-comment">/*
         * If part_count is twice greater than key_def.part_count
         * set iterator to range query
         */</span><font></font>
        type = ITER_GE;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tree_iterator</span> *<span class="hljs-title">it</span> = <span class="hljs-title">mempool_alloc</span>(&amp;<span class="hljs-title">memtx</span>-&gt;<span class="hljs-title">zcurve_iterator_pool</span>);</span>
    <span class="hljs-keyword">if</span> (it == <span class="hljs-literal">NULL</span>) {<font></font>
        diag_set(OutOfMemory, <span class="hljs-keyword">sizeof</span>(struct tree_iterator),
                 <span class="hljs-string">"memtx_zcurve_index"</span>, <span class="hljs-string">"iterator"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
    }<font></font>
<font></font>
    iterator_create(&amp;it-&gt;base, base);<font></font>
    it-&gt;pool = &amp;memtx-&gt;zcurve_iterator_pool;<font></font>
    it-&gt;base.next = tree_iterator_start;<font></font>
    it-&gt;base.<span class="hljs-built_in">free</span> = tree_iterator_free;<font></font>
    it-&gt;type = type;<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (part_count == <span class="hljs-number">0</span> || type == ITER_ALL) {<font></font>
        it-&gt;lower_bound = zeros(&amp;index-&gt;bit_array_pool, index_dim);<font></font>
        it-&gt;upper_bound = ones(&amp;index-&gt;bit_array_pool, index_dim);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == ITER_EQ) {<font></font>
        it-&gt;lower_bound = mp_decode_key(&amp;index-&gt;bit_array_pool,<font></font>
                key, index_dim, index);<font></font>
        it-&gt;upper_bound = <span class="hljs-literal">NULL</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (base-&gt;def-&gt;key_def-&gt;part_count == part_count) {<font></font>
        it-&gt;lower_bound = mp_decode_key(&amp;index-&gt;bit_array_pool,<font></font>
                key, index_dim, index);<font></font>
        it-&gt;upper_bound = ones(&amp;index-&gt;bit_array_pool, index_dim);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (base-&gt;def-&gt;key_def-&gt;part_count * <span class="hljs-number">2</span> == part_count) {<font></font>
        it-&gt;lower_bound  = z_value_create(&amp;index-&gt;bit_array_pool, index_dim);<font></font>
        it-&gt;upper_bound  = z_value_create(&amp;index-&gt;bit_array_pool, index_dim);<font></font>
        mp_decode_part(key, part_count, index, it-&gt;lower_bound, it-&gt;upper_bound);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        unreachable();<font></font>
    }<font></font>
    it-&gt;tree_iterator = memtx_zcurve_invalid_iterator();<font></font>
    it-&gt;current.tuple = <span class="hljs-literal">NULL</span>;<font></font>
    it-&gt;current.z_address = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> (struct iterator *)it;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fonction de la clé transmise, nous calculons les bornes inférieure et supérieure de la demande. </font><font style="vertical-align: inherit;">Cependant, jusqu'à présent, cet itérateur ne pointe vers rien. </font><font style="vertical-align: inherit;">Il existe plusieurs types d'itérateurs au total. </font><font style="vertical-align: inherit;">Dans notre cas, c'est TOUT - obtenir tous les éléments; </font><font style="vertical-align: inherit;">EQ - éléments de réception dont l'adresse z correspond à celle transmise; </font><font style="vertical-align: inherit;">et GE est la sélection d'éléments dans l'hypercube. </font></font><br>
<br>
<code>destroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- suppression de l'index. </font><font style="vertical-align: inherit;">Dans le cas de l'index secondaire, il libère simplement la mémoire allouée à la structure de recherche. </font><font style="vertical-align: inherit;">Et si l'index est principal, il supprime alors physiquement les tuples stockés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout le code est disponible sur: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/olegrok/tarantool/tree/z-order-curve-index</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Voyons ce qui s'est passé et résumons.</font></font><br>
<br>
<pre><code class="lua hljs">space = box.schema.space.<span class="hljs-built_in">create</span>(<span class="hljs-string">'myspace'</span>, { engine = <span class="hljs-string">'memtx'</span> })<font></font>
pk = space:create_index(<span class="hljs-string">'primary'</span>, { <span class="hljs-built_in">type</span> = <span class="hljs-string">'tree'</span>, parts = {{<span class="hljs-number">1</span>, <span class="hljs-string">'unsigned'</span>}}, unique = <span class="hljs-literal">true</span>})<font></font>
sk = space:create_index(<span class="hljs-string">'secondary'</span>, { <span class="hljs-built_in">type</span> = <span class="hljs-string">'zcurve'</span>, parts = {{<span class="hljs-number">2</span>, <span class="hljs-string">'unsigned'</span>}, {<span class="hljs-number">3</span>, <span class="hljs-string">'unsigned'</span>}}})
<span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span>,<span class="hljs-number">5</span> <span class="hljs-keyword">do</span> <span class="hljs-keyword">for</span> j=<span class="hljs-number">0</span>,<span class="hljs-number">5</span> <span class="hljs-keyword">do</span> space:<span class="hljs-built_in">insert</span>{i * <span class="hljs-number">6</span> + j, i, j} <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>
<span class="hljs-comment">-- returns all tuples</span>
pk:<span class="hljs-built_in">select</span>{}
<span class="hljs-comment">-- (2 &lt;= x &lt;= 3) and (3 &lt;= y &lt;= 5)</span>
sk:<span class="hljs-built_in">select</span>{<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>}
<span class="hljs-comment">---</span>
- — [<span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">21</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">16</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">17</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]<font></font>
  - [<span class="hljs-number">23</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<font></font>
…<font></font>
<span class="hljs-comment">-- (x == 2) and (y == 3)</span>
sk:<span class="hljs-built_in">select</span>{<span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
<span class="hljs-comment">---</span>
- — [<span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-comment">-- (2 &lt;= x &lt;= 3)</span>
sk:<span class="hljs-built_in">select</span>({<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, box.NULL, box.NULL})
<span class="hljs-comment">---</span>
- — [<span class="hljs-number">12</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>]<font></font>
  - [<span class="hljs-number">18</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>]<font></font>
  - [<span class="hljs-number">13</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<font></font>
  - [<span class="hljs-number">19</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]<font></font>
  - [<span class="hljs-number">14</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]<font></font>
  - [<span class="hljs-number">20</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]<font></font>
  - [<span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">21</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">16</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">17</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]<font></font>
  - [<span class="hljs-number">23</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<font></font>
...<font></font>
<span class="hljs-comment">-- (x &gt;= 2) and (y &gt;= 3)</span>
sk:<span class="hljs-built_in">select</span>({<span class="hljs-number">2</span>, box.NULL, <span class="hljs-number">3</span>, box.NULL})
<span class="hljs-comment">---</span>
- — [<span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">21</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">27</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">33</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">16</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">17</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]<font></font>
  - [<span class="hljs-number">23</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<font></font>
  - [<span class="hljs-number">28</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">34</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">29</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<font></font>
  - [<span class="hljs-number">35</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]<font></font>
...</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et la performance?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'est avéré que tout n'est pas aussi rose que je l'ai décrit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À partir d'un moment donné, la courbe de l'ordre Z commence à s'affaisser de manière significative en termes de vitesse d'accès aux données. perf top a montré que la plupart du temps est consacré à vérifier que le point appartient à la zone de recherche et à calculer le point suivant auquel vous devez sauter. Les deux opérations ont une complexité linéaire en fonction de la longueur de clé - à mesure que la dimension augmente, la longueur augmente également.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70e/338/fd1/70e338fd15af8701c3a5696ebfb3ea2a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De l'agréable - la consommation de mémoire est 2-3 fois inférieure et l'insertion est légèrement plus rapide que le R-Tree. </font><font style="vertical-align: inherit;">Ce qui n'est pas particulièrement pertinent, car les mesures ont été effectuées avec WAL désactivé. </font><font style="vertical-align: inherit;">Tout d'abord, dans un environnement de production, en cas de panne, un WAL désactivé peut entraîner une perte de données. </font><font style="vertical-align: inherit;">Deuxièmement, malgré le fait que l'écriture sur le WAL utilise l'approche par lots, elle continue d'écrire sur le disque, ce qui est des milliers de fois plus lent que de travailler avec de la RAM.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ee/e73/e29/9eee73e29d809963c069a9f7414f524a.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c0/8b9/159/2c08b91598dbefe2855ede4d05a593ca.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est également intéressant de comparer avec l'arbre B. </font><font style="vertical-align: inherit;">Ici, comme prévu, la courbe sera plus rapide qu'un balayage complet et vérifiera que chaque point appartient à une zone donnée. </font><font style="vertical-align: inherit;">Même si la vérification est plus légère que dans le cas de la courbe d'ordre Z, où tout se résume à une comparaison au niveau du bit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les nombres sur le graphique diffèrent dans l'ordre de l'arbre R - le test a été légèrement modifié.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/ae5/44d/140ae544d6ba527bffe6bc4d814f609d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour le test, j'ai généré un ensemble de points et comparé la durée de la requête en utilisant la courbe Z et le balayage conventionnel.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résumer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le monde en mémoire, cette structure s'est avérée ne pas être la meilleure façon, cependant, elle a encore des avantages:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prend moins d'espace.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typé, contrairement à R-Tree (pertinent uniquement pour Tarantool).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela vaut la peine de regarder de plus près s'il n'y a qu'un B-Tree et que vous devez effectuer des requêtes multidimensionnelles (non pertinentes pour Tarantool).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce fut une expérience intéressante. </font><font style="vertical-align: inherit;">Il est peu probable que la solution que j'ai proposée fasse partie de Tarantool. </font><font style="vertical-align: inherit;">Cependant, n'ayez pas peur d'expérimenter. </font><font style="vertical-align: inherit;">Et si vous avez des suggestions et des solutions, n'hésitez pas à les partager.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sources</font></font></h2><br>
<a name="B-Tree"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[B-Tree]: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Index dans PostgreSQL - 4 / Blog de Postgres Professional / Habr </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-tree / Habr </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-tree data structure / OTUS Blog. </font><font style="vertical-align: inherit;">Éducation en ligne / magazine geek</font></font></a><br>
<br>
<a name="ZcurvePostgres"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ZcurvePostgres]: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À propos de Z-order et R-tree / geek magazine </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z-order vs R-tree, suite / geek magazine</font></font></a><br>
<br>
<a name="1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indexation Z-Order pour les requêtes à multiples facettes dans Amazon DynamoDB: Partie 1 | </font><font style="vertical-align: inherit;">Blog de la base de données AWS</font></font></a><br>
<br>
<a name="1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indexation d'ordre Z pour les requêtes à multiples facettes dans Amazon DynamoDB: Partie 2 | </font><font style="vertical-align: inherit;">Blog de la base de données AWS</font></font></a><br>
<br>
<a name="3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intégration de l'arborescence UB dans un noyau de système de base de données</font></font></a><br>
<br>
<a name="4"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/tarantool/small</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr505850/index.html">Polymorphisme basé sur le concept C ++ dans le code produit: PassManager dans LLVM</a></li>
<li><a href="../fr505856/index.html">De Brute-Force à la tentative de confidentialité - ce à quoi les fournisseurs de SaaS sont confrontés</a></li>
<li><a href="../fr505860/index.html">Spring Boot, Hibernate et Kotlin pour les débutants étape par étape</a></li>
<li><a href="../fr505870/index.html">Comment promouvoir les jeux et applications mobiles au Japon, en Corée et en Chine</a></li>
<li><a href="../fr505872/index.html">Histoire des véhicules sans pilote</a></li>
<li><a href="../fr505884/index.html">Spear phishing: expérience de la création de fichiers exécutables conditionnellement malveillants pour les e-mails de phishing</a></li>
<li><a href="../fr505888/index.html">Analyser YouTube, y compris les données téléchargées, sans l'API YouTube</a></li>
<li><a href="../fr505896/index.html">Semaine de sécurité 24: Zoom et confidentialité du navigateur Brave</a></li>
<li><a href="../fr505898/index.html">Claude Shannon: valet de tous les métiers, farceur et père de la théorie de l'information</a></li>
<li><a href="../fr505900/index.html">Dépendances personnelles: pleine grandeur 40 mm, sans fil, pendant 72 heures pour 8000 roubles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>