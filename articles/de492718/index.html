<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧖 🏬 🤜🏾 Sicherheit durch Benutzereinschränkung oder Erstellen einer Sicherheitsanfälligkeit 👨‍🔧 📡 👨🏽‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Jahr 2019 wurde im CDN-Netzwerk die Sicherheitsanfälligkeit CPDoS Cache Poisoned Denial of Service entdeckt , die es ermöglicht, den HTTP-Cache des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sicherheit durch Benutzereinschränkung oder Erstellen einer Sicherheitsanfälligkeit</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492718/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Jahr 2019 wurde im </font><font style="vertical-align: inherit;">CDN-Netzwerk die </font><font style="vertical-align: inherit;">Sicherheitsanfälligkeit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPDoS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cache Poisoned Denial of Service </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">entdeckt</font></a><font style="vertical-align: inherit;"> , die es ermöglicht, den HTTP-Cache des CDN-Anbieters zu vergiften und einen Denial-of-Service zu verursachen. </font><font style="vertical-align: inherit;">Die Sicherheitsanfälligkeit hat noch nicht viel Hype ausgelöst, da sie bei echten Angriffen nicht beobachtet wurde. </font><font style="vertical-align: inherit;">Aber ich möchte separat über eine der Cache-Vergiftungsmethoden sprechen. </font><font style="vertical-align: inherit;">Überschreiben der HTTP-Methode.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rb/7j/wy/rb7jwy3an79ykaffwer39l297eu.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn andere Varianten der Ausnutzung der Sicherheitsanfälligkeit auf die eine oder andere Weise auf Fehlern oder Merkmalen der Anforderungsänderung durch einen Vermittler beruhen, basiert die Methode Override-Variante auf der gleichnamigen Taktik, die nicht Teil des HTTP-Standards ist, zusätzliche Probleme mit sich bringt und die aufgrund von Unachtsamkeit entstanden und verbreitet wurden Beziehung zur Sicherheit. </font><font style="vertical-align: inherit;">Hier werden wir es betrachten.</font></font><br>
<a name="habracut"></a><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurz über CPDoS, wenn Sie es verpasst haben</font></font></b><div class="spoiler_text"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"> </a> ,         URI  method   .<br>
<br>
      ,       ,       ,         ,      -   .       —            -  -   -,      ,    -     ,      .           ,         .<br>
<br>
            ,    . ,  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">   -</a>.      -   ,       ,      .<br>
<br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Begrenzen Sie den Client, weniger kann - weniger wird brechen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Notwendigkeit, die Methode in der Anforderung zu überschreiben, ergab sich aus der Tatsache, dass einige Webanwendungsfirewalls und HTTP-Client-Implementierungen sehr begrenzt waren und die Ausführung anderer Methoden als GET und POST nicht zuließen. Das Problem ist nicht, dass es sich um eine Implementierungsbeschränkung handelte, sondern dass es sich um eine absichtliche Einschränkung von HTTP-Clients durch eine Sicherheitsrichtlinie handelte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist klar, dass alles gut gemeint ausgeführt wurde, um den beengten Datenverkehr zu unterbinden, der für normale HTTP-Clients nicht dem Standard entspricht. Aus Sicherheitsgründen wurden jedoch alle Methoden außer GET und POST abgeschnitten. Möglicherweise, weil dies die einzigen Methoden sind, die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht optional sind und</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für Allzweckserver </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">erforderlich sind</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum eine derart strenge Beschränkung eingeführt werden musste, ist nicht klar. Ja, Angriffe mit der Einführung verschiedener Zeichen, um den Parser zu verwirren, sind nur das Hobby von Textprotokollen. Sie könnten jedoch etwas mehr Methoden zulassen, z. B. mindestens diejenigen, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die im Standard selbst beschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.iana.org/assignments/http-methods/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bei IANA registriert sind</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es hat sich nicht gelohnt, die Methodenprüfung vollständig zu entfernen, aber Sie können eine Reihe der beliebtesten Methoden wählen und diejenigen ausschließen, die das Interaktionsprotokoll ändern und die Arbeit mit Verbindungen auf dem Proxyserver (CONNECT) unterbrechen. Aber nein, es stellte sich heraus, dass eine Sicherheitsrichtlinie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unnötige</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einschränkungen und Verbote für Kunden </font><font style="vertical-align: inherit;">einführte </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und die Kunden waren auf die falschen beschränkt. </font><font style="vertical-align: inherit;">Sie wollten die Variabilität von Nachrichten von HTTP-Clients begrenzen und die von diesen WAFs geschützten Clients, die Endanwendungsserver und ihre Entwickler einschränken. </font><font style="vertical-align: inherit;">Jetzt hatten die Entwickler nur noch zwei Methoden, die nicht immer ausreichten, um die Logik des HTTP-Clients zu beschreiben.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einschränkungen werden erstellt, um sie zu überwinden.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es war zu erwarten, dass diese übermäßige Einschränkung früher oder später die Webentwickler stören würde. Die Ironie ist, dass es so einfach ist, solche WAFs nicht loszuwerden. Besonders wenn sie mit Kunden oder Anbietern zusammen sind. Die Sicherheitsrichtlinien anderer Menschen in Frage zu stellen, ist eine katastrophale Angelegenheit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund der Flexibilität von HTTP ist es nicht schwierig, diese Einschränkung zu umgehen. Fügen Sie der Anforderung einfach etwas hinzu, bei dem Sie die Methode überschreiben können. Strict WAF überprüft nur die Methode in der Anforderungszeile (der ersten Zeile der Anfrage) und freut sich, dort ein genehmigtes GET oder POST zu sehen. Das Backend kann das hinzugefügte Element analysieren und die reale Methode daraus extrahieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://fandry.blogspot.com/2012/03/x-" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reihe von </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://docs.inpaas.com/docs/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikeln </font></font></a> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://fandry.blogspot.com/2012/03/x-" rel="nofollow"><font style="vertical-align: inherit;">googeln </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://docs.inpaas.com/docs/" rel="nofollow"><font style="vertical-align: inherit;">, </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wirklich eine </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.infoworld.com/article/3249687/how-to-implement-a-delegatinghandler-for-x-" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reihe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">darüber, wie fehlerhafte Proxys REST-Anwendungen beschädigt haben und wie die Autoren die reale Methode in einem separaten Header übergeben mussten. </font><font style="vertical-align: inherit;">In allen Fällen wird vorgeschlagen, dass Sie ungefähr denselben Header eingeben (X-HTTP-Methode, X-HTTP-Methodenüberschreibung oder X-Methodenüberschreibung - die Schreibweise variiert etwas), um eine überschriebene Methode anzugeben. </font><font style="vertical-align: inherit;">Sehr, sehr selten kann man Referenzen finden, die für den gleichen Zweck der Abfragekomponenten-URI verwendet werden können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was in diesen Artikeln fehlt, ist der Abschnitt Sicherheitsüberlegungen. </font><font style="vertical-align: inherit;">Und sie sind es einfach.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist das Überschreiben von Methoden sicher?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manchmal vergessen Entwickler von Webanwendungen, dass sich zwischen dem Client und dem Server möglicherweise Zwischen-Teilnehmer befinden, die über das HTTP-Protokoll interagieren: Proxys, Web-Caches von Anbietern, CDN und WAF. Die Verbreitung von TLS verringert die Wahrscheinlichkeit eines zwischengeschalteten Teilnehmers zwischen Client und Server erheblich. Höchstwahrscheinlich ist der einzige Proxy zwischen dem Client und dem Backend ein eigener Server mit Nginx. Eine solche Konfiguration ist einfach genug, um sie vor der Veröffentlichung in typischen Szenarien zu testen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber wir bewegen uns in das Zeitalter von CDN und immer mehr Anwendungen werden sich hinter CDNs verstecken, die den Benutzerverkehr lesen und manipulieren. </font><font style="vertical-align: inherit;">Backends direkt bedienen Benutzer fast nie und verstecken sich hinter Reverse-Proxys, um die Reaktionsfähigkeit und Leistung zu erhöhen. </font><font style="vertical-align: inherit;">Daher müssen Sie sich daran erinnern, wie sich das Überschreiben einer Methode auf die Verarbeitung einer Anforderung auf einem Vermittlungsserver auswirken kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Angriffe, über die ich sprechen möchte, gelten hauptsächlich für HTTP / 1.1. </font><font style="vertical-align: inherit;">HTTP / 2 erbt in gewisser Weise das Verhalten des alten Standards, in gewisser Weise geht es seinen eigenen Weg, sodass die Anwendbarkeit jedes Angriffs auf den neuen Standard separat betrachtet wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cache-Angriffe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den meisten Fällen berücksichtigen Zwischenserver keine Methodenüberschreibungen, überprüfen nicht die Header der X-HTTP-Methodenüberschreibungsfamilie und arbeiten mit der Anforderung mithilfe ihrer Hauptmethode aus der Anforderungszeile. Und da die überschriebene Methode nicht im Schlüssel zur Suche nach einer Anforderung im Cache enthalten ist (Methode + URI), können solche Server POST nicht von POST + X-HTTP-Methodenüberschreibung: LÖSCHEN unterscheiden. Dies bedeutet, dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie das Zwischenspeichern von</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anforderungen an einen bestimmten URI </font><i><font style="vertical-align: inherit;">nicht zulassen können,</font></i><font style="vertical-align: inherit;"> wenn das Backend überschriebene Methoden überwachen und ausführen kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das CPDoS-Dokument enthält ein gutes Beispiel dafür, was passiert, wenn Sie eine solche Anforderung zwischenspeichern. Wenn ein Angreifer eine POST-Anforderung als GET-Anforderung tarnt, erkennt der Proxy die Ersetzungen nicht und behandelt die Anforderung als legitime GET-Anforderung. Das Backend erkennt jedoch die überschriebene Methode und führt das im Header X-HTTP-Method-Override - POST beschriebene Verb aus. Da die POST-Methode für den Ziel-URI nicht definiert ist, generiert der Server einen Fehler. Ferner wird die Backend-Antwort als Antwort auf die ursprüngliche Methode - GET - im Cache gespeichert. Jetzt gibt jede nächste GET-Anforderung für denselben URI einen zwischengespeicherten Fehler zurück.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/0r/bv/_q/0rbv_qeocdxi9b4ctw2rschthgw.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich ist der Angriff etwas breiter als im Dokument dargestellt. Die Autoren konzentrierten sich darauf, den Fehler im Cache zu speichern, der nicht überall (bereits) reproduziert werden kann. Wenn jedoch die angeforderte Methode für den ausgewählten URI definiert ist und erfolgreich ausgeführt wird, erhält der Proxy eine Antwort mit dem Status 200 und speichert sie zwischen. Dann nachfolgende Anforderungen derselben URI, um Antworten auf die völlig falsche Methode zu erhalten. In diesem Szenario besteht keine Anforderung mehr mit einem Cache-Fehler von 4XX-Antworten, wie in der ursprünglichen CPDoS-Beschreibung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das umgekehrte Problem kann auftreten. Wenn ein seriöser HTTP-Client eine GET + X-HTTP-Methodenüberschreibung: PATCH-Anforderung sendet (dies ist schlecht, aber dazu später mehr) und der Cache bereits eine GET-Antwort hat, erhält der Client diese zwischengespeicherte Antwort. In diesem Fall erhält das Backend niemals eine PATCH-Anforderung, die die Anwendungslogik sowohl auf dem Client als auch auf dem Server verletzen kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können die Auswirkung auf den Cache verringern, indem Sie die richtigen Cache-Richtlinien erstellen und die Ressourcen in zwei Gruppen aufteilen: diejenigen, für die die Methodenüberschreibungsoperation nicht akzeptabel oder nicht erforderlich ist, Antworten auf diese können zwischengespeichert werden, und diejenigen, für die die Methodenüberschreibungsoperation erforderlich ist, und jede Zwischenspeicherung solcher Antworten ist nicht akzeptabel . Je weniger Ressourcen zwischengespeichert werden, desto weniger nützlich ist das CDN und je mehr Datenverkehr das Backend erreicht, desto stärker ist die Anwendung einer HTTP-Flut ausgesetzt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher ist es besser, den HTTP-Cache so oft wie möglich zu verwenden. Dazu muss der Cache-Server zwischen Anforderungen mit unterschiedlichen überschriebenen Methoden unterscheiden können. Die erste Möglichkeit besteht darin, die Methodenüberschreibung der Abfragekomponente an den URI zu übertragen:</font></font><br>
<br>
<pre><code class="plaintext hljs">POST /some-uri HTTP/1.1<font></font>
X-HTTP-Method-Override: DELETE<font></font>
   ↓  ↓   ↓<font></font>
POST /some-uri?method=DELETE HTTP/1.1<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt sehen Anforderungen mit unterschiedlichen Methoden für den Cache unterschiedlich aus, da sie unterschiedliche Schlüssel erhalten. Einige Proxys ziehen es vor, Antworten auf Anforderungen, die die Abfragekomponente im URI enthalten, nicht zwischenzuspeichern. Dies wirkt sich jedoch nur auf die Caching-Effizienz aus. Diese Methode löst immer Probleme mit falschem Caching. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine andere Möglichkeit besteht darin, die Methodenüberschreibung in einem separaten Header zu belassen, aber einen Sekundärschlüssel einzugeben, um die Antwort im Cache zu finden. Dies ist mit dem Vary-Header möglich. Bei der Bearbeitung der Anforderung wiederholt der Server den Header mit der Methodenüberschreibung und gibt den Namen dieses Headers im Vary-Header wieder. Bei den folgenden Anforderungen verwendet der Cache-Server dann den Wert der überschriebenen Methode als Sekundärschlüssel, wenn nach einer Anforderung im Cache gesucht wird.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/oh/1n/rd/oh1nrdf3x18yktd6moekwlr01-w.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Methode funktioniert, wenn der Zwischenserver mit Sekundärschlüsseln arbeiten kann. </font><font style="vertical-align: inherit;">Dies ist normalerweise der Fall, aber die Proxy-Vertrauensstufe, die alle Methoden außer GET und POST schneidet, ist normalerweise niedriger und es ist besser, dies zu überprüfen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Überschreiben einer Methode durch eine Entität innerhalb des Anforderungshauptteils hat genau die gleichen Nachteile wie das Überschreiben eines zusätzlichen Headers - es ist außerhalb der Sichtbarkeit des Caches.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachrichtenwarteschlangenangriffe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst wenn Cache-Angriffe geschlossen sind, ist das noch nicht alles. </font><font style="vertical-align: inherit;">Ein Angreifer kann durch Überschreiben einer Methode versuchen, den Rahmen der Antwort zu ändern und dadurch die Entsprechung der Anforderungs-Antwort-Paare für andere Clients zu verletzen. </font><font style="vertical-align: inherit;">Oder zwingen Sie die Serverseite der Anwendung, dieselbe Anforderung mehrmals zu verarbeiten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Wichtigste, was dafür erforderlich ist, ist ein Zwischenserver, der im Reverse-Proxy-Modus arbeitet. Das heißt, jeder Caching- oder CDN-Server. Ein solcher Proxy unterstützt eine relativ kleine Anzahl von Verbindungen zum Backend und multipliziert Anforderungen von vielen Clients in jedem von ihnen. Dies ist sowohl erforderlich, um die Unterstützung einer großen Anzahl von Clientverbindungen von den Backends zum Proxyserver zu übernehmen, als auch um die Last zwischen den Backends auszugleichen. Die Beendigung von TLS-Verbindungen erfolgt auch auf dem Proxy. Client-Verbindungen werden niemals direkt mit dem Backend verbunden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da sich jetzt Anforderungen von verschiedenen Clients in derselben Verbindung zwischen dem Backend und dem Proxy befinden, ist es erforderlich, eine eindeutige Entsprechung zwischen den Anforderungs-Antwort-Paaren aufrechtzuerhalten. Die meisten Proxys </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leiten keine Pipeline</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Pipelines) Anfragen an das Backend und arbeitet damit im Request-Response-Modus. Der Request-Response-Modus ist einfacher und unterliegt praktisch einer Bedrohung - dem Blockieren von Verbindungen. Wenn Sie die Verbindung an einem einzelnen Anforderungs-Antwort-Paar hängen lassen, können Sie eine Verzögerung oder sogar eine Verweigerung der Verarbeitung der folgenden Anforderungen verursachen (z. B. wenn es Ihnen gelingt, die Warteschlangen von Proxy-Anforderungen zu überlaufen).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Produktivere Proxy-Pipeline-Anforderungen an das Backend - Auf diese Weise können Sie sofort ein Paket von Anforderungen an den Server senden und auf deren Ausführung warten. Die Leistung ist höher, aber es gibt mehr Bedrohungen. Erstens verschwindet das Problem der Head-of-Line-Blockierung nirgendwo - selbst wenn das Backend die Abfrage-Pipeline harken und parallel ausführen kann, können sie nicht gesendet werden, wenn die erste hängt. Zweitens, wenn Sie den Antwortrahmen unterbrechen, können Sie den Proxy verwirren und die Korrespondenz der Anforderungs-Antwort-Paare unterbrechen, dann können einige Clients die Antworten anderer Personen erhalten oder zumindest einen sofortigen Verbindungsabschluss mit dem Backend erreichen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/td/wn/rj/tdwnrjiw4ekrsl7l1aqda-hhyzi.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfachste und unterhaltsamste Neudefinition einer Methode besteht darin, GET durch das Verb HEAD zu ersetzen. Wenn die Antwort auf die erste einen Körper hat, dann nicht auf die zweite. Darüber hinaus sind alle anderen Header identisch, einschließlich derjenigen, die den Rahmen für die Anforderung bereitstellen. Wenn der Proxy einen solchen überschriebenen HEAD an den Server umleitet, erwartet er vom Server nicht nur Antwortheader, sondern auch den Antworttext, den das Backend nicht senden wird. Wenn der Proxy und der Server im Anforderungs- / Antwortmodus interagieren, bleibt die Verbindung hängen, bis sie durch eine Zeitüberschreitung unterbrochen wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Server die folgenden Antworten sendet (Pipeline-Modus), können diese nicht als unabhängige Antworten analysiert werden, sondern als Teil der vorherigen, unvollständigen Antwort an das GET. Der Proxy platziert sie (oder einen Teil davon) im Hauptteil der "GET" -Antwort und sendet sie an den Angreifer, um sie zu lesen. Sie können ein solches Pseudo-GET erstellen, um eine große Datei zu empfangen und Datenverkehr zwischen dem Proxy und dem Backend zu sichern. Der Erfolg hängt davon ab, wie das Backend die Inhaltslänge und die Übertragungscodierung platziert: Chunk-Header, um Nachrichten zu rahmen. Mit dem ersten können Sie fast immer einen Speicherauszug erstellen, mit dem zweiten werden häufig Analysefehler generiert und eine Trennung vom Backend verursacht. Wenn Sie überhaupt kein Glück haben, kann das Pseudo-GET mehrere Antworten in seiner Gesamtheit abdecken und kurz vor der nächsten Antwort enden.Der Proxy kann dieses Problem überhaupt nicht erkennen und für weitere Antworten in diesem Zusammenhang wird die Korrespondenz zwischen Anfrage und Antwort verletzt.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ee/ds/h9/eedsh90uounshmxglkz5aconiim.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst wenn alles, was durch Überschreiben der Methode erreicht wurde, das Schließen der Verbindung zwischen dem Proxy und dem Backend war, kann dies für einen Angriff ausreichen. </font><font style="vertical-align: inherit;">Sie können Serviceanfragen mit solchen Anfragen auslösen - Verbindungen mit Backends werden ständig unterbrochen. </font><font style="vertical-align: inherit;">Es gibt nicht so viele davon, und das erneute Öffnen nimmt Zeit in Anspruch. Infolgedessen können Sie die Leistung der Proxy-Backend-Verbindung erheblich verringern und dadurch die Bandbreite des Dienstes verringern.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatische Spam-Wiedergabe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe oben gesagt, dass Anfragen der Form GET + X-HTTP-Method-Override: PATCH von seriösen Clients schlecht sind. Und das ist schlecht, weil Methoden zwei Eigenschaften haben: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sicherheit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idempotenz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sicherheit bedeutet, dass die Methode den Status des Servers nicht ändert (schreibgeschützt) und uns im Kontext dieses Artikels nicht interessiert. Die Idempotenz der Methode stellt sicher, dass wiederholte Anforderungen den gleichen Effekt haben wie eine einzelne Anforderung. Sie können eine Analogie ziehen: </font></font><code>(a = 5)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- idempotente Anfrage und </font></font><code>(a += 2) </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- nicht idempotente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Eigenschaft interessiert uns. Wenn die Verbindung zwischen Client und Server plötzlich unterbrochen wird, kann der Client die Anforderung automatisch erneut senden, da er weiß, dass die Methode idempotent ist. Proxies verhalten sich genauso. Nicht idempotente Anforderungen werden nicht automatisch wiederholt, da nicht bekannt ist, wie sie sich auf den Server auswirken und was der Client am Ende erhält. Ich denke, jeder kennt die Popups im Browser: "Sind Sie sicher, dass Sie die Anfrage wiederholen möchten?" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie eine nicht idempotente Methode als idempotent maskieren, wird sie im Fehlerfall nicht verworfen, sondern erneut zum Server umgeleitet. Selbst wenn der Client die tatsächliche Anforderungsmethode berücksichtigt, bevor er die Anforderung erneut sendet, hilft dies nicht viel, da der Proxyserver die Methodenüberschreibung nicht kennt und solche Anforderungen wiederholt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein Angreifer in der Lage ist, die Trennung zwischen dem Backend und den Clients zu erzwingen, kann er den Server veranlassen, nicht idempotente Anforderungen mehrmals auszuführen und die Zuverlässigkeit und Vorhersagbarkeit der Anwendung zu verringern. </font><font style="vertical-align: inherit;">Im vorherigen Abschnitt haben wir gerade einen Weg gefunden, wie Sie mit derselben Methodenüberschreibung Verbindungsunterbrechungen verursachen können. </font><font style="vertical-align: inherit;">Obwohl zu beachten ist, dass das Internet per Definition ein unzuverlässiges Netzwerk ist und die Anwendung selbst in Gefahr ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Schutz vor diesem Angriff sollten Sie nur Methoden verwenden, die der Anforderung keine neuen Eigenschaften als Transport hinzufügen. </font><font style="vertical-align: inherit;">POST ist ein guter Kandidat, da es standardmäßig weder sicher noch idempotent ist.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das alte HTTP / 1.1, wie bei HTTP / 2?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTP / 2 hat die Art und Weise geändert, wie Anforderungen zwischen Knoten transportiert werden, hat jedoch ihre lexikalische Bedeutung nicht geändert. Daher verhält sich HTTP / 2 bei Angriffen, die sich auf den Anforderungswert beziehen, gleich. Transportangriffe werden jedoch nicht reproduziert, da sie bereits im Standard berücksichtigt sind. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angriffe auf den Cache werden</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf ähnliche Weise wie HTTP / 1 reproduziert, und der Schutz ist ähnlich. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Message Queuing-Angriffe gelten</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht für HTTP / 2. Die darin enthaltenen HTTP-Nachrichten sind in separate Frames mit separaten Frame-Headern unterteilt, die die Länge und das Ende der Nachricht explizit bestimmen. Als ob der Angreifer die Methode nicht ändern und die HTTP-Header ändern würde, hat dies keine Auswirkungen auf den Nachrichtenrahmen. Das Stehlen der Antwort wird fehlschlagen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angriffe auf die Wiederholung nicht idempotenter Nachrichten sind</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auch unter Berücksichtigung der Tatsache anwendbar, dass es in HTTP / 2 solche gibt</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benachrichtigungsmechanismus der zuletzt verarbeiteten Anfrage</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In HTTP / 2 werden mehrere Anforderungen in demselben TCP multipliziert und erzeugen so </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flows</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jeder Thread hat eine eigene Nummer. </font><font style="vertical-align: inherit;">Wenn der HTTP / 2-Server die Verbindung trennt, kann er die Nummer der zuletzt verarbeiteten Anforderung in GOAWAY angeben. </font><font style="vertical-align: inherit;">Anfragen mit einer höheren Nummer können immer sicher umgeleitet werden, Anfragen mit einer niedrigeren Nummer werden nur umgeleitet, wenn sie idempotent sind. </font><font style="vertical-align: inherit;">Wenn eine Anforderung mit einer überschriebenen Methode für einen Proxyserver idempotent aussieht, leitet der Proxy sie an den Server weiter.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So überschreiben Sie eine Methode sicher</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die kurze Antwort ist auf keinen Fall. Es ist besser, überhaupt keine Methodenüberschreibungen zu verwenden. Deaktivieren Sie gegebenenfalls die Unterstützung im Backend vollständig. Blockieren Sie überschreibende Methoden für HTTP-Clients. Verweigern Sie Proxy / WAF, wodurch die "zusätzlichen" Methoden abgeschnitten werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie irgendwie mit der Neudefinition der Methode leben müssen, dann verhindern Sie genügend Änderungen am Backend. Zunächst ist es ratsam, die Methode nur über die Abfragekomponente des URI zu überschreiben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens sollte es eine weiße Liste der Transformation von Methoden geben: welche als "Transport" akzeptabel sind und welche die resultierenden sind. </font><font style="vertical-align: inherit;">Es sollte keine verallgemeinerten Transformationsfunktionen geben, wenn eine Methode von einer überschrieben werden kann. </font><font style="vertical-align: inherit;">Die "Transport" -Methode sollte nicht die Eigenschaften von Sicherheit und Idempotenz haben, wenn die resultierende dies nicht tut. </font><font style="vertical-align: inherit;">Gefährliche Transformationen sollten verboten werden, der gleiche Ersatz GET -&gt; HEAD.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muss ich einen Problem-Proxy / WAF patchen?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Proxy nur die Methoden GET und POST implementiert und die anderen aus dem einen oder anderen Grund blockiert, auf jeden Fall ja. </font><font style="vertical-align: inherit;">Sie können es hauptsächlich für GET und POST optimieren, aber das Blockieren anderer Methoden ist eine schlechte Idee. </font><font style="vertical-align: inherit;">Was immer noch zu Misstrauen gegenüber dem Produkt führt: Wenn grundlegende Dinge blockiert sind, was kann man von der Umsetzung komplexerer Probleme erwarten?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich Sorgen über die Sicherheit geschützter Webanwendungen machen, kann es sinnvoll sein, Anwendungen vor Richtlinien zum Überschreiben unsicherer Methoden zu schützen. </font><font style="vertical-align: inherit;">Im allgemeinen Fall ist es natürlich unmöglich, die Anwendung vollständig vor falschen Überschreibungen zu schützen, ohne die Details der Implementierung der Webanwendung zu kennen, aber Sie können teilweise Benutzer abdecken, die das Problem einfach nicht kennen. </font><font style="vertical-align: inherit;">Es ist nicht nur erforderlich, den eigenen Cache vor einer Vergiftung zu schützen, sondern auch das Aktivieren oder Deaktivieren des Überschreibens für jede geschützte Anwendung zu ermöglichen. </font><font style="vertical-align: inherit;">Um dies zu tun, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Überblick über </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">häufig verwendete Header.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X-HTTP-Methode, X-HTTP-Methodenüberschreibung und X-Methodenüberschreibung. </font><font style="vertical-align: inherit;">Das Verfolgen der Neudefinition in der Abfragekomponente des URI ist wenig sinnvoll: Der Cache vergiftet eine solche Anforderung nicht, und die Abfrage kann sehr lang sein und ein völlig beliebiges Format haben.</font></font><br>
<br>
<h2>      ?</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sicherheitsentwickler beschränken Anwendungsentwickler nicht auf Sicherheitsrichtlinien. </font><font style="vertical-align: inherit;">Sie werden immer noch herausfinden, wie sie um sie herumkommen können. Je flexibler das Protokoll ist, desto einfacher ist es, dies zu tun. </font><font style="vertical-align: inherit;">Es ist sehr wahrscheinlich, dass sie Sie nicht treten und warten, bis Sie die Einschränkungen vernünftiger machen, sondern sie einfach umgehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie herausgefunden haben, wie etwas in das Protokoll implementiert werden soll, es jedoch eines der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlüsselkonzepte des</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Standards </font><font style="vertical-align: inherit;">überschreibt oder </font><font style="vertical-align: inherit;">diesem zuwiderläuft, treten mit Sicherheit Kompatibilitäts- und Sicherheitsprobleme auf. </font><font style="vertical-align: inherit;">Und sie müssen gleichzeitig mit der Entscheidung abgedeckt werden. </font><font style="vertical-align: inherit;">Jedes Mal. </font><font style="vertical-align: inherit;">Wenn Sie diesen Rat befolgt haben und keine Sicherheitswarnungen gesehen haben, duplizieren Sie den Rat nicht im gesamten Internet. </font><font style="vertical-align: inherit;">Seien Sie immer kritisch gegenüber der Entscheidung und finden Sie heraus, was </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schief gehen könnte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstelle eines Nachwortes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf welche Proxy-Server-Probleme sind Sie gestoßen? </font><font style="vertical-align: inherit;">Was musste umgangen werden und wie?</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de492706/index.html">Gedächtnisarchive: Wie das Gehirn Erinnerungen codiert und reproduziert</a></li>
<li><a href="../de492708/index.html">Globales Satelliten-Internet - gibt es Neuigkeiten aus den Bereichen?</a></li>
<li><a href="../de492710/index.html">Dorniger Weg des Kandidaten durch verschiedene HRM-Systeme</a></li>
<li><a href="../de492712/index.html">Beherrschung der Entwicklung durch Testen in Android mithilfe von UI-Tests</a></li>
<li><a href="../de492714/index.html">Effektive Arbeit von zu Hause aus: allgemein und persönlich</a></li>
<li><a href="../de492720/index.html">Diskussion: Projektdateidienst</a></li>
<li><a href="../de492724/index.html">Björn Straustrup beantwortet die Top 5 C ++ - Fragen mit Stapelüberlauf</a></li>
<li><a href="../de492726/index.html">OS Sivelkiriya: Softwareentwicklungsprozess</a></li>
<li><a href="../de492728/index.html">Sternchen und Versand in Telegramm / Slack / E-Mail verpasst</a></li>
<li><a href="../de492730/index.html">US-Verteidigungsministerium: Ethik für KI und unbemannte Fahrzeuge</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>