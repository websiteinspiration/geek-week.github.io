<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñ üè¨ ü§úüèæ Sicherheit durch Benutzereinschr√§nkung oder Erstellen einer Sicherheitsanf√§lligkeit üë®‚Äçüîß üì° üë®üèΩ‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Jahr 2019 wurde im CDN-Netzwerk die Sicherheitsanf√§lligkeit CPDoS Cache Poisoned Denial of Service entdeckt , die es erm√∂glicht, den HTTP-Cache des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sicherheit durch Benutzereinschr√§nkung oder Erstellen einer Sicherheitsanf√§lligkeit</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492718/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Jahr 2019 wurde im </font><font style="vertical-align: inherit;">CDN-Netzwerk die </font><font style="vertical-align: inherit;">Sicherheitsanf√§lligkeit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPDoS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cache Poisoned Denial of Service </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">entdeckt</font></a><font style="vertical-align: inherit;"> , die es erm√∂glicht, den HTTP-Cache des CDN-Anbieters zu vergiften und einen Denial-of-Service zu verursachen. </font><font style="vertical-align: inherit;">Die Sicherheitsanf√§lligkeit hat noch nicht viel Hype ausgel√∂st, da sie bei echten Angriffen nicht beobachtet wurde. </font><font style="vertical-align: inherit;">Aber ich m√∂chte separat √ºber eine der Cache-Vergiftungsmethoden sprechen. </font><font style="vertical-align: inherit;">√úberschreiben der HTTP-Methode.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rb/7j/wy/rb7jwy3an79ykaffwer39l297eu.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn andere Varianten der Ausnutzung der Sicherheitsanf√§lligkeit auf die eine oder andere Weise auf Fehlern oder Merkmalen der Anforderungs√§nderung durch einen Vermittler beruhen, basiert die Methode Override-Variante auf der gleichnamigen Taktik, die nicht Teil des HTTP-Standards ist, zus√§tzliche Probleme mit sich bringt und die aufgrund von Unachtsamkeit entstanden und verbreitet wurden Beziehung zur Sicherheit. </font><font style="vertical-align: inherit;">Hier werden wir es betrachten.</font></font><br>
<a name="habracut"></a><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurz √ºber CPDoS, wenn Sie es verpasst haben</font></font></b><div class="spoiler_text"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"> </a> ,         URI  method   .<br>
<br>
      ,       ,       ,         ,      -   .       ‚Äî            -  -   -,      ,    -     ,      .           ,         .<br>
<br>
            ,    . ,  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">   -</a>.      -   ,       ,      .<br>
<br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Begrenzen Sie den Client, weniger kann - weniger wird brechen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Notwendigkeit, die Methode in der Anforderung zu √ºberschreiben, ergab sich aus der Tatsache, dass einige Webanwendungsfirewalls und HTTP-Client-Implementierungen sehr begrenzt waren und die Ausf√ºhrung anderer Methoden als GET und POST nicht zulie√üen. Das Problem ist nicht, dass es sich um eine Implementierungsbeschr√§nkung handelte, sondern dass es sich um eine absichtliche Einschr√§nkung von HTTP-Clients durch eine Sicherheitsrichtlinie handelte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist klar, dass alles gut gemeint ausgef√ºhrt wurde, um den beengten Datenverkehr zu unterbinden, der f√ºr normale HTTP-Clients nicht dem Standard entspricht. Aus Sicherheitsgr√ºnden wurden jedoch alle Methoden au√üer GET und POST abgeschnitten. M√∂glicherweise, weil dies die einzigen Methoden sind, die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht optional sind und</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr Allzweckserver </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">erforderlich sind</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum eine derart strenge Beschr√§nkung eingef√ºhrt werden musste, ist nicht klar. Ja, Angriffe mit der Einf√ºhrung verschiedener Zeichen, um den Parser zu verwirren, sind nur das Hobby von Textprotokollen. Sie k√∂nnten jedoch etwas mehr Methoden zulassen, z. B. mindestens diejenigen, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die im Standard selbst beschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.iana.org/assignments/http-methods/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bei IANA registriert sind</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es hat sich nicht gelohnt, die Methodenpr√ºfung vollst√§ndig zu entfernen, aber Sie k√∂nnen eine Reihe der beliebtesten Methoden w√§hlen und diejenigen ausschlie√üen, die das Interaktionsprotokoll √§ndern und die Arbeit mit Verbindungen auf dem Proxyserver (CONNECT) unterbrechen. Aber nein, es stellte sich heraus, dass eine Sicherheitsrichtlinie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unn√∂tige</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einschr√§nkungen und Verbote f√ºr Kunden </font><font style="vertical-align: inherit;">einf√ºhrte </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und die Kunden waren auf die falschen beschr√§nkt. </font><font style="vertical-align: inherit;">Sie wollten die Variabilit√§t von Nachrichten von HTTP-Clients begrenzen und die von diesen WAFs gesch√ºtzten Clients, die Endanwendungsserver und ihre Entwickler einschr√§nken. </font><font style="vertical-align: inherit;">Jetzt hatten die Entwickler nur noch zwei Methoden, die nicht immer ausreichten, um die Logik des HTTP-Clients zu beschreiben.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einschr√§nkungen werden erstellt, um sie zu √ºberwinden.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es war zu erwarten, dass diese √ºberm√§√üige Einschr√§nkung fr√ºher oder sp√§ter die Webentwickler st√∂ren w√ºrde. Die Ironie ist, dass es so einfach ist, solche WAFs nicht loszuwerden. Besonders wenn sie mit Kunden oder Anbietern zusammen sind. Die Sicherheitsrichtlinien anderer Menschen in Frage zu stellen, ist eine katastrophale Angelegenheit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund der Flexibilit√§t von HTTP ist es nicht schwierig, diese Einschr√§nkung zu umgehen. F√ºgen Sie der Anforderung einfach etwas hinzu, bei dem Sie die Methode √ºberschreiben k√∂nnen. Strict WAF √ºberpr√ºft nur die Methode in der Anforderungszeile (der ersten Zeile der Anfrage) und freut sich, dort ein genehmigtes GET oder POST zu sehen. Das Backend kann das hinzugef√ºgte Element analysieren und die reale Methode daraus extrahieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://fandry.blogspot.com/2012/03/x-" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reihe von </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://docs.inpaas.com/docs/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikeln </font></font></a> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://fandry.blogspot.com/2012/03/x-" rel="nofollow"><font style="vertical-align: inherit;">googeln </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://docs.inpaas.com/docs/" rel="nofollow"><font style="vertical-align: inherit;">, </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wirklich eine </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.infoworld.com/article/3249687/how-to-implement-a-delegatinghandler-for-x-" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reihe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dar√ºber, wie fehlerhafte Proxys REST-Anwendungen besch√§digt haben und wie die Autoren die reale Methode in einem separaten Header √ºbergeben mussten. </font><font style="vertical-align: inherit;">In allen F√§llen wird vorgeschlagen, dass Sie ungef√§hr denselben Header eingeben (X-HTTP-Methode, X-HTTP-Methoden√ºberschreibung oder X-Methoden√ºberschreibung - die Schreibweise variiert etwas), um eine √ºberschriebene Methode anzugeben. </font><font style="vertical-align: inherit;">Sehr, sehr selten kann man Referenzen finden, die f√ºr den gleichen Zweck der Abfragekomponenten-URI verwendet werden k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was in diesen Artikeln fehlt, ist der Abschnitt Sicherheits√ºberlegungen. </font><font style="vertical-align: inherit;">Und sie sind es einfach.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist das √úberschreiben von Methoden sicher?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manchmal vergessen Entwickler von Webanwendungen, dass sich zwischen dem Client und dem Server m√∂glicherweise Zwischen-Teilnehmer befinden, die √ºber das HTTP-Protokoll interagieren: Proxys, Web-Caches von Anbietern, CDN und WAF. Die Verbreitung von TLS verringert die Wahrscheinlichkeit eines zwischengeschalteten Teilnehmers zwischen Client und Server erheblich. H√∂chstwahrscheinlich ist der einzige Proxy zwischen dem Client und dem Backend ein eigener Server mit Nginx. Eine solche Konfiguration ist einfach genug, um sie vor der Ver√∂ffentlichung in typischen Szenarien zu testen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber wir bewegen uns in das Zeitalter von CDN und immer mehr Anwendungen werden sich hinter CDNs verstecken, die den Benutzerverkehr lesen und manipulieren. </font><font style="vertical-align: inherit;">Backends direkt bedienen Benutzer fast nie und verstecken sich hinter Reverse-Proxys, um die Reaktionsf√§higkeit und Leistung zu erh√∂hen. </font><font style="vertical-align: inherit;">Daher m√ºssen Sie sich daran erinnern, wie sich das √úberschreiben einer Methode auf die Verarbeitung einer Anforderung auf einem Vermittlungsserver auswirken kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Angriffe, √ºber die ich sprechen m√∂chte, gelten haupts√§chlich f√ºr HTTP / 1.1. </font><font style="vertical-align: inherit;">HTTP / 2 erbt in gewisser Weise das Verhalten des alten Standards, in gewisser Weise geht es seinen eigenen Weg, sodass die Anwendbarkeit jedes Angriffs auf den neuen Standard separat betrachtet wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cache-Angriffe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den meisten F√§llen ber√ºcksichtigen Zwischenserver keine Methoden√ºberschreibungen, √ºberpr√ºfen nicht die Header der X-HTTP-Methoden√ºberschreibungsfamilie und arbeiten mit der Anforderung mithilfe ihrer Hauptmethode aus der Anforderungszeile. Und da die √ºberschriebene Methode nicht im Schl√ºssel zur Suche nach einer Anforderung im Cache enthalten ist (Methode + URI), k√∂nnen solche Server POST nicht von POST + X-HTTP-Methoden√ºberschreibung: L√ñSCHEN unterscheiden. Dies bedeutet, dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie das Zwischenspeichern von</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anforderungen an einen bestimmten URI </font><i><font style="vertical-align: inherit;">nicht zulassen k√∂nnen,</font></i><font style="vertical-align: inherit;"> wenn das Backend √ºberschriebene Methoden √ºberwachen und ausf√ºhren kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das CPDoS-Dokument enth√§lt ein gutes Beispiel daf√ºr, was passiert, wenn Sie eine solche Anforderung zwischenspeichern. Wenn ein Angreifer eine POST-Anforderung als GET-Anforderung tarnt, erkennt der Proxy die Ersetzungen nicht und behandelt die Anforderung als legitime GET-Anforderung. Das Backend erkennt jedoch die √ºberschriebene Methode und f√ºhrt das im Header X-HTTP-Method-Override - POST beschriebene Verb aus. Da die POST-Methode f√ºr den Ziel-URI nicht definiert ist, generiert der Server einen Fehler. Ferner wird die Backend-Antwort als Antwort auf die urspr√ºngliche Methode - GET - im Cache gespeichert. Jetzt gibt jede n√§chste GET-Anforderung f√ºr denselben URI einen zwischengespeicherten Fehler zur√ºck.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/0r/bv/_q/0rbv_qeocdxi9b4ctw2rschthgw.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich ist der Angriff etwas breiter als im Dokument dargestellt. Die Autoren konzentrierten sich darauf, den Fehler im Cache zu speichern, der nicht √ºberall (bereits) reproduziert werden kann. Wenn jedoch die angeforderte Methode f√ºr den ausgew√§hlten URI definiert ist und erfolgreich ausgef√ºhrt wird, erh√§lt der Proxy eine Antwort mit dem Status 200 und speichert sie zwischen. Dann nachfolgende Anforderungen derselben URI, um Antworten auf die v√∂llig falsche Methode zu erhalten. In diesem Szenario besteht keine Anforderung mehr mit einem Cache-Fehler von 4XX-Antworten, wie in der urspr√ºnglichen CPDoS-Beschreibung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das umgekehrte Problem kann auftreten. Wenn ein seri√∂ser HTTP-Client eine GET + X-HTTP-Methoden√ºberschreibung: PATCH-Anforderung sendet (dies ist schlecht, aber dazu sp√§ter mehr) und der Cache bereits eine GET-Antwort hat, erh√§lt der Client diese zwischengespeicherte Antwort. In diesem Fall erh√§lt das Backend niemals eine PATCH-Anforderung, die die Anwendungslogik sowohl auf dem Client als auch auf dem Server verletzen kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen die Auswirkung auf den Cache verringern, indem Sie die richtigen Cache-Richtlinien erstellen und die Ressourcen in zwei Gruppen aufteilen: diejenigen, f√ºr die die Methoden√ºberschreibungsoperation nicht akzeptabel oder nicht erforderlich ist, Antworten auf diese k√∂nnen zwischengespeichert werden, und diejenigen, f√ºr die die Methoden√ºberschreibungsoperation erforderlich ist, und jede Zwischenspeicherung solcher Antworten ist nicht akzeptabel . Je weniger Ressourcen zwischengespeichert werden, desto weniger n√ºtzlich ist das CDN und je mehr Datenverkehr das Backend erreicht, desto st√§rker ist die Anwendung einer HTTP-Flut ausgesetzt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher ist es besser, den HTTP-Cache so oft wie m√∂glich zu verwenden. Dazu muss der Cache-Server zwischen Anforderungen mit unterschiedlichen √ºberschriebenen Methoden unterscheiden k√∂nnen. Die erste M√∂glichkeit besteht darin, die Methoden√ºberschreibung der Abfragekomponente an den URI zu √ºbertragen:</font></font><br>
<br>
<pre><code class="plaintext hljs">POST /some-uri HTTP/1.1<font></font>
X-HTTP-Method-Override: DELETE<font></font>
   ‚Üì  ‚Üì   ‚Üì<font></font>
POST /some-uri?method=DELETE HTTP/1.1<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt sehen Anforderungen mit unterschiedlichen Methoden f√ºr den Cache unterschiedlich aus, da sie unterschiedliche Schl√ºssel erhalten. Einige Proxys ziehen es vor, Antworten auf Anforderungen, die die Abfragekomponente im URI enthalten, nicht zwischenzuspeichern. Dies wirkt sich jedoch nur auf die Caching-Effizienz aus. Diese Methode l√∂st immer Probleme mit falschem Caching. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine andere M√∂glichkeit besteht darin, die Methoden√ºberschreibung in einem separaten Header zu belassen, aber einen Sekund√§rschl√ºssel einzugeben, um die Antwort im Cache zu finden. Dies ist mit dem Vary-Header m√∂glich. Bei der Bearbeitung der Anforderung wiederholt der Server den Header mit der Methoden√ºberschreibung und gibt den Namen dieses Headers im Vary-Header wieder. Bei den folgenden Anforderungen verwendet der Cache-Server dann den Wert der √ºberschriebenen Methode als Sekund√§rschl√ºssel, wenn nach einer Anforderung im Cache gesucht wird.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/oh/1n/rd/oh1nrdf3x18yktd6moekwlr01-w.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Methode funktioniert, wenn der Zwischenserver mit Sekund√§rschl√ºsseln arbeiten kann. </font><font style="vertical-align: inherit;">Dies ist normalerweise der Fall, aber die Proxy-Vertrauensstufe, die alle Methoden au√üer GET und POST schneidet, ist normalerweise niedriger und es ist besser, dies zu √ºberpr√ºfen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das √úberschreiben einer Methode durch eine Entit√§t innerhalb des Anforderungshauptteils hat genau die gleichen Nachteile wie das √úberschreiben eines zus√§tzlichen Headers - es ist au√üerhalb der Sichtbarkeit des Caches.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachrichtenwarteschlangenangriffe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst wenn Cache-Angriffe geschlossen sind, ist das noch nicht alles. </font><font style="vertical-align: inherit;">Ein Angreifer kann durch √úberschreiben einer Methode versuchen, den Rahmen der Antwort zu √§ndern und dadurch die Entsprechung der Anforderungs-Antwort-Paare f√ºr andere Clients zu verletzen. </font><font style="vertical-align: inherit;">Oder zwingen Sie die Serverseite der Anwendung, dieselbe Anforderung mehrmals zu verarbeiten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Wichtigste, was daf√ºr erforderlich ist, ist ein Zwischenserver, der im Reverse-Proxy-Modus arbeitet. Das hei√üt, jeder Caching- oder CDN-Server. Ein solcher Proxy unterst√ºtzt eine relativ kleine Anzahl von Verbindungen zum Backend und multipliziert Anforderungen von vielen Clients in jedem von ihnen. Dies ist sowohl erforderlich, um die Unterst√ºtzung einer gro√üen Anzahl von Clientverbindungen von den Backends zum Proxyserver zu √ºbernehmen, als auch um die Last zwischen den Backends auszugleichen. Die Beendigung von TLS-Verbindungen erfolgt auch auf dem Proxy. Client-Verbindungen werden niemals direkt mit dem Backend verbunden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da sich jetzt Anforderungen von verschiedenen Clients in derselben Verbindung zwischen dem Backend und dem Proxy befinden, ist es erforderlich, eine eindeutige Entsprechung zwischen den Anforderungs-Antwort-Paaren aufrechtzuerhalten. Die meisten Proxys </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leiten keine Pipeline</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Pipelines) Anfragen an das Backend und arbeitet damit im Request-Response-Modus. Der Request-Response-Modus ist einfacher und unterliegt praktisch einer Bedrohung - dem Blockieren von Verbindungen. Wenn Sie die Verbindung an einem einzelnen Anforderungs-Antwort-Paar h√§ngen lassen, k√∂nnen Sie eine Verz√∂gerung oder sogar eine Verweigerung der Verarbeitung der folgenden Anforderungen verursachen (z. B. wenn es Ihnen gelingt, die Warteschlangen von Proxy-Anforderungen zu √ºberlaufen).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Produktivere Proxy-Pipeline-Anforderungen an das Backend - Auf diese Weise k√∂nnen Sie sofort ein Paket von Anforderungen an den Server senden und auf deren Ausf√ºhrung warten. Die Leistung ist h√∂her, aber es gibt mehr Bedrohungen. Erstens verschwindet das Problem der Head-of-Line-Blockierung nirgendwo - selbst wenn das Backend die Abfrage-Pipeline harken und parallel ausf√ºhren kann, k√∂nnen sie nicht gesendet werden, wenn die erste h√§ngt. Zweitens, wenn Sie den Antwortrahmen unterbrechen, k√∂nnen Sie den Proxy verwirren und die Korrespondenz der Anforderungs-Antwort-Paare unterbrechen, dann k√∂nnen einige Clients die Antworten anderer Personen erhalten oder zumindest einen sofortigen Verbindungsabschluss mit dem Backend erreichen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/td/wn/rj/tdwnrjiw4ekrsl7l1aqda-hhyzi.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfachste und unterhaltsamste Neudefinition einer Methode besteht darin, GET durch das Verb HEAD zu ersetzen. Wenn die Antwort auf die erste einen K√∂rper hat, dann nicht auf die zweite. Dar√ºber hinaus sind alle anderen Header identisch, einschlie√ülich derjenigen, die den Rahmen f√ºr die Anforderung bereitstellen. Wenn der Proxy einen solchen √ºberschriebenen HEAD an den Server umleitet, erwartet er vom Server nicht nur Antwortheader, sondern auch den Antworttext, den das Backend nicht senden wird. Wenn der Proxy und der Server im Anforderungs- / Antwortmodus interagieren, bleibt die Verbindung h√§ngen, bis sie durch eine Zeit√ºberschreitung unterbrochen wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Server die folgenden Antworten sendet (Pipeline-Modus), k√∂nnen diese nicht als unabh√§ngige Antworten analysiert werden, sondern als Teil der vorherigen, unvollst√§ndigen Antwort an das GET. Der Proxy platziert sie (oder einen Teil davon) im Hauptteil der "GET" -Antwort und sendet sie an den Angreifer, um sie zu lesen. Sie k√∂nnen ein solches Pseudo-GET erstellen, um eine gro√üe Datei zu empfangen und Datenverkehr zwischen dem Proxy und dem Backend zu sichern. Der Erfolg h√§ngt davon ab, wie das Backend die Inhaltsl√§nge und die √úbertragungscodierung platziert: Chunk-Header, um Nachrichten zu rahmen. Mit dem ersten k√∂nnen Sie fast immer einen Speicherauszug erstellen, mit dem zweiten werden h√§ufig Analysefehler generiert und eine Trennung vom Backend verursacht. Wenn Sie √ºberhaupt kein Gl√ºck haben, kann das Pseudo-GET mehrere Antworten in seiner Gesamtheit abdecken und kurz vor der n√§chsten Antwort enden.Der Proxy kann dieses Problem √ºberhaupt nicht erkennen und f√ºr weitere Antworten in diesem Zusammenhang wird die Korrespondenz zwischen Anfrage und Antwort verletzt.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ee/ds/h9/eedsh90uounshmxglkz5aconiim.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst wenn alles, was durch √úberschreiben der Methode erreicht wurde, das Schlie√üen der Verbindung zwischen dem Proxy und dem Backend war, kann dies f√ºr einen Angriff ausreichen. </font><font style="vertical-align: inherit;">Sie k√∂nnen Serviceanfragen mit solchen Anfragen ausl√∂sen - Verbindungen mit Backends werden st√§ndig unterbrochen. </font><font style="vertical-align: inherit;">Es gibt nicht so viele davon, und das erneute √ñffnen nimmt Zeit in Anspruch. Infolgedessen k√∂nnen Sie die Leistung der Proxy-Backend-Verbindung erheblich verringern und dadurch die Bandbreite des Dienstes verringern.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatische Spam-Wiedergabe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe oben gesagt, dass Anfragen der Form GET + X-HTTP-Method-Override: PATCH von seri√∂sen Clients schlecht sind. Und das ist schlecht, weil Methoden zwei Eigenschaften haben: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sicherheit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idempotenz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sicherheit bedeutet, dass die Methode den Status des Servers nicht √§ndert (schreibgesch√ºtzt) und uns im Kontext dieses Artikels nicht interessiert. Die Idempotenz der Methode stellt sicher, dass wiederholte Anforderungen den gleichen Effekt haben wie eine einzelne Anforderung. Sie k√∂nnen eine Analogie ziehen: </font></font><code>(a = 5)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- idempotente Anfrage und </font></font><code>(a += 2) </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- nicht idempotente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Eigenschaft interessiert uns. Wenn die Verbindung zwischen Client und Server pl√∂tzlich unterbrochen wird, kann der Client die Anforderung automatisch erneut senden, da er wei√ü, dass die Methode idempotent ist. Proxies verhalten sich genauso. Nicht idempotente Anforderungen werden nicht automatisch wiederholt, da nicht bekannt ist, wie sie sich auf den Server auswirken und was der Client am Ende erh√§lt. Ich denke, jeder kennt die Popups im Browser: "Sind Sie sicher, dass Sie die Anfrage wiederholen m√∂chten?" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie eine nicht idempotente Methode als idempotent maskieren, wird sie im Fehlerfall nicht verworfen, sondern erneut zum Server umgeleitet. Selbst wenn der Client die tats√§chliche Anforderungsmethode ber√ºcksichtigt, bevor er die Anforderung erneut sendet, hilft dies nicht viel, da der Proxyserver die Methoden√ºberschreibung nicht kennt und solche Anforderungen wiederholt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein Angreifer in der Lage ist, die Trennung zwischen dem Backend und den Clients zu erzwingen, kann er den Server veranlassen, nicht idempotente Anforderungen mehrmals auszuf√ºhren und die Zuverl√§ssigkeit und Vorhersagbarkeit der Anwendung zu verringern. </font><font style="vertical-align: inherit;">Im vorherigen Abschnitt haben wir gerade einen Weg gefunden, wie Sie mit derselben Methoden√ºberschreibung Verbindungsunterbrechungen verursachen k√∂nnen. </font><font style="vertical-align: inherit;">Obwohl zu beachten ist, dass das Internet per Definition ein unzuverl√§ssiges Netzwerk ist und die Anwendung selbst in Gefahr ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Schutz vor diesem Angriff sollten Sie nur Methoden verwenden, die der Anforderung keine neuen Eigenschaften als Transport hinzuf√ºgen. </font><font style="vertical-align: inherit;">POST ist ein guter Kandidat, da es standardm√§√üig weder sicher noch idempotent ist.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das alte HTTP / 1.1, wie bei HTTP / 2?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTP / 2 hat die Art und Weise ge√§ndert, wie Anforderungen zwischen Knoten transportiert werden, hat jedoch ihre lexikalische Bedeutung nicht ge√§ndert. Daher verh√§lt sich HTTP / 2 bei Angriffen, die sich auf den Anforderungswert beziehen, gleich. Transportangriffe werden jedoch nicht reproduziert, da sie bereits im Standard ber√ºcksichtigt sind. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angriffe auf den Cache werden</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf √§hnliche Weise wie HTTP / 1 reproduziert, und der Schutz ist √§hnlich. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Message Queuing-Angriffe gelten</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht f√ºr HTTP / 2. Die darin enthaltenen HTTP-Nachrichten sind in separate Frames mit separaten Frame-Headern unterteilt, die die L√§nge und das Ende der Nachricht explizit bestimmen. Als ob der Angreifer die Methode nicht √§ndern und die HTTP-Header √§ndern w√ºrde, hat dies keine Auswirkungen auf den Nachrichtenrahmen. Das Stehlen der Antwort wird fehlschlagen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angriffe auf die Wiederholung nicht idempotenter Nachrichten sind</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auch unter Ber√ºcksichtigung der Tatsache anwendbar, dass es in HTTP / 2 solche gibt</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benachrichtigungsmechanismus der zuletzt verarbeiteten Anfrage</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In HTTP / 2 werden mehrere Anforderungen in demselben TCP multipliziert und erzeugen so </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flows</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jeder Thread hat eine eigene Nummer. </font><font style="vertical-align: inherit;">Wenn der HTTP / 2-Server die Verbindung trennt, kann er die Nummer der zuletzt verarbeiteten Anforderung in GOAWAY angeben. </font><font style="vertical-align: inherit;">Anfragen mit einer h√∂heren Nummer k√∂nnen immer sicher umgeleitet werden, Anfragen mit einer niedrigeren Nummer werden nur umgeleitet, wenn sie idempotent sind. </font><font style="vertical-align: inherit;">Wenn eine Anforderung mit einer √ºberschriebenen Methode f√ºr einen Proxyserver idempotent aussieht, leitet der Proxy sie an den Server weiter.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So √ºberschreiben Sie eine Methode sicher</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die kurze Antwort ist auf keinen Fall. Es ist besser, √ºberhaupt keine Methoden√ºberschreibungen zu verwenden. Deaktivieren Sie gegebenenfalls die Unterst√ºtzung im Backend vollst√§ndig. Blockieren Sie √ºberschreibende Methoden f√ºr HTTP-Clients. Verweigern Sie Proxy / WAF, wodurch die "zus√§tzlichen" Methoden abgeschnitten werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie irgendwie mit der Neudefinition der Methode leben m√ºssen, dann verhindern Sie gen√ºgend √Ñnderungen am Backend. Zun√§chst ist es ratsam, die Methode nur √ºber die Abfragekomponente des URI zu √ºberschreiben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens sollte es eine wei√üe Liste der Transformation von Methoden geben: welche als "Transport" akzeptabel sind und welche die resultierenden sind. </font><font style="vertical-align: inherit;">Es sollte keine verallgemeinerten Transformationsfunktionen geben, wenn eine Methode von einer √ºberschrieben werden kann. </font><font style="vertical-align: inherit;">Die "Transport" -Methode sollte nicht die Eigenschaften von Sicherheit und Idempotenz haben, wenn die resultierende dies nicht tut. </font><font style="vertical-align: inherit;">Gef√§hrliche Transformationen sollten verboten werden, der gleiche Ersatz GET -&gt; HEAD.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muss ich einen Problem-Proxy / WAF patchen?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Proxy nur die Methoden GET und POST implementiert und die anderen aus dem einen oder anderen Grund blockiert, auf jeden Fall ja. </font><font style="vertical-align: inherit;">Sie k√∂nnen es haupts√§chlich f√ºr GET und POST optimieren, aber das Blockieren anderer Methoden ist eine schlechte Idee. </font><font style="vertical-align: inherit;">Was immer noch zu Misstrauen gegen√ºber dem Produkt f√ºhrt: Wenn grundlegende Dinge blockiert sind, was kann man von der Umsetzung komplexerer Probleme erwarten?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich Sorgen √ºber die Sicherheit gesch√ºtzter Webanwendungen machen, kann es sinnvoll sein, Anwendungen vor Richtlinien zum √úberschreiben unsicherer Methoden zu sch√ºtzen. </font><font style="vertical-align: inherit;">Im allgemeinen Fall ist es nat√ºrlich unm√∂glich, die Anwendung vollst√§ndig vor falschen √úberschreibungen zu sch√ºtzen, ohne die Details der Implementierung der Webanwendung zu kennen, aber Sie k√∂nnen teilweise Benutzer abdecken, die das Problem einfach nicht kennen. </font><font style="vertical-align: inherit;">Es ist nicht nur erforderlich, den eigenen Cache vor einer Vergiftung zu sch√ºtzen, sondern auch das Aktivieren oder Deaktivieren des √úberschreibens f√ºr jede gesch√ºtzte Anwendung zu erm√∂glichen. </font><font style="vertical-align: inherit;">Um dies zu tun, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den √úberblick √ºber </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h√§ufig verwendete Header.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X-HTTP-Methode, X-HTTP-Methoden√ºberschreibung und X-Methoden√ºberschreibung. </font><font style="vertical-align: inherit;">Das Verfolgen der Neudefinition in der Abfragekomponente des URI ist wenig sinnvoll: Der Cache vergiftet eine solche Anforderung nicht, und die Abfrage kann sehr lang sein und ein v√∂llig beliebiges Format haben.</font></font><br>
<br>
<h2>      ?</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sicherheitsentwickler beschr√§nken Anwendungsentwickler nicht auf Sicherheitsrichtlinien. </font><font style="vertical-align: inherit;">Sie werden immer noch herausfinden, wie sie um sie herumkommen k√∂nnen. Je flexibler das Protokoll ist, desto einfacher ist es, dies zu tun. </font><font style="vertical-align: inherit;">Es ist sehr wahrscheinlich, dass sie Sie nicht treten und warten, bis Sie die Einschr√§nkungen vern√ºnftiger machen, sondern sie einfach umgehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie herausgefunden haben, wie etwas in das Protokoll implementiert werden soll, es jedoch eines der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schl√ºsselkonzepte des</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Standards </font><font style="vertical-align: inherit;">√ºberschreibt oder </font><font style="vertical-align: inherit;">diesem zuwiderl√§uft, treten mit Sicherheit Kompatibilit√§ts- und Sicherheitsprobleme auf. </font><font style="vertical-align: inherit;">Und sie m√ºssen gleichzeitig mit der Entscheidung abgedeckt werden. </font><font style="vertical-align: inherit;">Jedes Mal. </font><font style="vertical-align: inherit;">Wenn Sie diesen Rat befolgt haben und keine Sicherheitswarnungen gesehen haben, duplizieren Sie den Rat nicht im gesamten Internet. </font><font style="vertical-align: inherit;">Seien Sie immer kritisch gegen√ºber der Entscheidung und finden Sie heraus, was </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schief gehen k√∂nnte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstelle eines Nachwortes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf welche Proxy-Server-Probleme sind Sie gesto√üen? </font><font style="vertical-align: inherit;">Was musste umgangen werden und wie?</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de492706/index.html">Ged√§chtnisarchive: Wie das Gehirn Erinnerungen codiert und reproduziert</a></li>
<li><a href="../de492708/index.html">Globales Satelliten-Internet - gibt es Neuigkeiten aus den Bereichen?</a></li>
<li><a href="../de492710/index.html">Dorniger Weg des Kandidaten durch verschiedene HRM-Systeme</a></li>
<li><a href="../de492712/index.html">Beherrschung der Entwicklung durch Testen in Android mithilfe von UI-Tests</a></li>
<li><a href="../de492714/index.html">Effektive Arbeit von zu Hause aus: allgemein und pers√∂nlich</a></li>
<li><a href="../de492720/index.html">Diskussion: Projektdateidienst</a></li>
<li><a href="../de492724/index.html">Bj√∂rn Straustrup beantwortet die Top 5 C ++ - Fragen mit Stapel√ºberlauf</a></li>
<li><a href="../de492726/index.html">OS Sivelkiriya: Softwareentwicklungsprozess</a></li>
<li><a href="../de492728/index.html">Sternchen und Versand in Telegramm / Slack / E-Mail verpasst</a></li>
<li><a href="../de492730/index.html">US-Verteidigungsministerium: Ethik f√ºr KI und unbemannte Fahrzeuge</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>