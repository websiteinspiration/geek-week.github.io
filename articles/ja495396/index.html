<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏻 🤳 🖖🏾 コンセプトの第一印象 🐘 👨🏿‍🤝‍👨🏻 💂🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私は新しいC ++ 20機能-概念を扱うことにしました。
 
 Concepts（または概念、ロシア語を話すWikiが書いているように）は、非常に興味深く、長い間欠けていた便利な機能です。
 
 本質的には、テンプレートの引数を入力することです。
 
 C ++ 20より前のテンプレートの主な問題は...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>コンセプトの第一印象</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495396/"><img src="https://habrastorage.org/webt/qd/ja/kc/qdjakcxd4173w_juzv5fx3bf0_o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は新しいC ++ 20機能-概念を扱うことにしました。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concepts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概念</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ロシア語を話すWikiが書いているように）は、非常に興味深く、長い間欠けていた便利な機能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本質的には、テンプレートの引数を入力することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 20より前のテンプレートの主な問題は、テンプレート用に設計されていないものも含めて、テンプレート内の何でも代用できることです。つまり、テンプレートシステムは完全に型指定されていませんでした。その結果、テンプレートに間違ったパラメーターを渡すと、信じられないほど長く、完全に読み取り不可能なエラーメッセージが発生しました。彼らはさまざまな言語ハックの助けを借りてこれに対抗しようとしましたが、私は言及しません（私は対処しなければなりませんでした）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
概念は、この誤解を修正するように設計されています。</font><font style="vertical-align: inherit;">テンプレートにタイピングシステムが追加され、非常に強力です。</font><font style="vertical-align: inherit;">そして今、このシステムの特徴を理解し、インターネットで入手できる資料の研究を始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
率直に言って、私は少しショックを受けています:) C ++はすでに複雑な言語ですが、少なくとも言い訳があります。</font><font style="vertical-align: inherit;">言語を設計するときに、テンプレートのメタプログラミングが規定されずに発見されました。</font><font style="vertical-align: inherit;">そして、言語の次のバージョンを開発するとき、多くのコードが世界中で作成されたため、彼らはこの「発見」に適応することを余儀なくされました。</font><font style="vertical-align: inherit;">コンセプトは根本的に新しい機会です。</font><font style="vertical-align: inherit;">そして、私には、それらの実装にはすでにある程度の不透明性が存在しているようです。</font><font style="vertical-align: inherit;">おそらく、これは継承された機能の膨大な量を考慮に入れる必要性の結果でしょうか？</font><font style="vertical-align: inherit;">それを理解してみましょう...</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般情報</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンセプトは、テンプレート構文に基づく新しい言語エンティティです。</font><font style="vertical-align: inherit;">概念には、名前、パラメーター、および本体-概念のパラメーターに応じて定数（つまり、コンパイル段階で計算される）の論理値を返す述語があります。</font><font style="vertical-align: inherit;">このような：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt; 
<span class="hljs-keyword">concept</span> Even = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;  <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> FourByte = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
技術的には、概念はboolのようなテンプレートconstexpr式に非常に似ています。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> EvenX = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> FourByteX = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的な表現で概念を使用することもできます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Even&lt;<span class="hljs-number">2</span>&gt;; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
概念の主な考え方は、テンプレートのtypenameまたはclassキーワードの代わりに使用できるということです。</font><font style="vertical-align: inherit;">メタタイプ（「タイプのタイプ」）のように。</font><font style="vertical-align: inherit;">したがって、静的型付けがテンプレートに導入されています。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;FourByte T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp; t)</span> </span>{}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、テンプレートパラメータとしてintを使用すると、ほとんどの場合のコードがコンパイルされます。</font><font style="vertical-align: inherit;">ダブルの場合は、短くてわかりやすいエラーメッセージが表示されます。</font><font style="vertical-align: inherit;">テンプレートのシンプルで明確なタイピング、これまでのところすべてが大丈夫です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要とする</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、新しい「コンテキスト」C ++ 20キーワードで、二重の目的があります。requires句とrequire式です。</font><font style="vertical-align: inherit;">後で説明するように、この奇妙なキーワードの節約は混乱を招きます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表現が必要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、検討には表現が必要です。</font><font style="vertical-align: inherit;">アイデアは非常に優れています。この単語には中括弧で囲まれたブロックがあり、その中のコードはコンパイルのために評価されます。</font><font style="vertical-align: inherit;">確かに、コード</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はC ++ではなく、C ++に近い特別な言語で</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記述すべきですが</font><b><font style="vertical-align: inherit;">、独自の特性があります</font></b><font style="vertical-align: inherit;">（これが最初の奇妙な点です。C++コードだけを作成することはかなり可能でした）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードが正しい場合-式が必要ですがtrueを返し、そうでない場合はfalseを返します。</font><font style="vertical-align: inherit;">もちろん、コード自体は、sizeofやdecltypeの式のように、決してコード生成に入りません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、この単語は文脈に依存し、テンプレートの内部でのみ機能します。つまり、テンプレートの外部では機能しません。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b = <span class="hljs-keyword">requires</span> { <span class="hljs-number">3.14</span> &gt;&gt; <span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてテンプレートで-してください：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> Shiftable = <span class="hljs-keyword">requires</span>(T i) { i&gt;&gt;<span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてそれはうまくいきます：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Shiftable&lt;<span class="hljs-keyword">int</span>&gt;; <span class="hljs-comment">// true</span>
<span class="hljs-keyword">bool</span> b2 = Shiftable&lt;<span class="hljs-keyword">double</span>&gt;; <span class="hljs-comment">// false</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
require式の主な用途は、概念の作成です。</font><font style="vertical-align: inherit;">たとえば、これはタイプ内のフィールドとメソッドの存在を確認する方法です。</font><font style="vertical-align: inherit;">非常に人気のあるケース。</font></font><br>
<br>
<pre><code class="plaintext hljs">template &lt;typename T&gt;<font></font>
concept Machine = <font></font>
  requires(T m) {  //   `m` ,   Machine<font></font>
	m.start();     //    `m.start()` <font></font>
	m.stop();      //   `m.stop()`<font></font>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、テストされたコードで必要になる可能性のあるすべての変数（テンプレートパラメータだけでなく）は、括弧で宣言する必要があり、式が必要です。</font><font style="vertical-align: inherit;">何らかの理由で、変数を宣言することは不可能です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部での型チェックには</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここから、必要なコードと標準C ++の違いが始まります。</font><font style="vertical-align: inherit;">返されたタイプをチェックするために、特別な構文が使用されます。オブジェクトは中括弧で囲まれ、矢印が配置され、その後、タイプが満たす必要のある概念が記述されます。</font><font style="vertical-align: inherit;">また、直接型を使用することはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数の戻り値がintに変換できることを確認します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">int</span>&gt;;<font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
戻り関数が正確にintであることを確認します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::same_as&lt;<span class="hljs-keyword">int</span>&gt;; <font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（std :: same_asおよびstd :: convertible_toは標準ライブラリの概念です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中括弧でチェックされる型の式を囲まないと、コンパイラーはそれらが何を望んでいるかを理解せず、文字列全体をコンパイルのためにチェックする必要がある単一の式として解釈します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部が必要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
requireキーワードは、requires式の中で特別な意味を持っています。</font><font style="vertical-align: inherit;">ネストされたrequire-expressions（すでに中括弧がない）は、コンパイルではなく、trueまたはfalseであるかどうかがチェックされます。</font><font style="vertical-align: inherit;">そのような式がfalseであることが判明した場合、囲んでいる式はすぐにfalseであることが判明します（さらにコンパイル分析が中断されます）。</font><font style="vertical-align: inherit;">一般的なフォーム：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> { <font></font>
  expression;         <span class="hljs-comment">// expression is valid</span>
  <span class="hljs-keyword">requires</span> predicate; <span class="hljs-comment">// predicate is true</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
述語として、例えば、以前に定義された概念またはタイプ特性を使用することができます。</font><font style="vertical-align: inherit;">例：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(Iter it) {
  <span class="hljs-comment">//     (   Iter   *  ++)</span><font></font>
  *it++;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_convertible_v&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、ネストされたrequire-expressionsは、有効性がチェックされる中括弧内のコードで許可されます。</font><font style="vertical-align: inherit;">ただし、あるrequire-expressionを別の内部に単純に書き込む場合、ネストされた式（ネストされたrequireキーワードを含む全体としてのすべて）の妥当性がチェックされるだけです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">typename</span> T::value_type x) { ++x; }; <span class="hljs-comment">//     , </span>
												<span class="hljs-comment">//     !</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、doubleを持つ奇妙なフォームが必要になります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span> <span class="hljs-params">(<span class="hljs-keyword">typename</span> T::value_type x)</span> </span>{ ++x; }; <span class="hljs-comment">//       "++x"</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが「requires」からのこのような楽しいエスケープシーケンスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、2つのrequireの別の組み合わせは、この時間句（下記を参照）と式です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span><span class="hljs-params">(T x, T y)</span> </span>{ <span class="hljs-keyword">bool</span>(x &lt; y); }
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">equivalent</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; x, T <span class="hljs-keyword">const</span>&amp; y)</span>
</span>{
  <span class="hljs-keyword">return</span> !(x &lt; y) &amp;&amp; !(y &lt; x);<font></font>
};</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">句が必要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、テンプレートタイプの制限を宣言するために、requiresという単語の別の使用法に移りましょう。</font><font style="vertical-align: inherit;">これは、typenameの代わりに概念名を使用する代わりになります。</font><font style="vertical-align: inherit;">次の例では、3つのメソッドはすべて同等です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  require</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
	<span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span></span>;<font></font>
<font></font>
<span class="hljs-comment">//   require (  )</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span> <span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;</span>;<font></font>
<font></font>
<span class="hljs-comment">//    typename</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;Sortable Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span>  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
require宣言では、論理演算子で結合されたいくつかの述語を使用できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s;<font></font>
 <font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// ok</span>
  fun(s);  <span class="hljs-comment">// compiler error</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、コンパイルエラーが発生した場合は、いずれかの条件を反転させます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; !is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これもコンパイルしない例です</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> !<span class="hljs-function">is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;	</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この理由は、一部の式を解析するときに発生するあいまいさです。</font><font style="vertical-align: inherit;">たとえば、そのようなテンプレートでは次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">bool</span>)&amp;<span class="hljs-function">T::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
unsignedの属性-演算子またはfoo（）関数のプロトタイプを明確にすることはできません。</font><font style="vertical-align: inherit;">したがって、開発者は、trueまたはfalseのリテラルの手掛かりのみを括弧なしで使用すると、value、value、T :: value、ns :: trait :: valueのbool型のフィールドの名前をrequire句の引数として使用できると判断しました。タイプConceptのコンセプト名。式が必要です。</font><font style="vertical-align: inherit;">その他はすべて括弧で囲む必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!is_trivial_v&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、requires句の述語機能について</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の例を考えてみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、requiresはネストされたvalue_typeタイプに依存する特性を使用します。</font><font style="vertical-align: inherit;">テンプレートに渡すことができるネストされたタイプが任意のタイプにあるかどうかは、事前にはわかりません。</font><font style="vertical-align: inherit;">たとえば、単純なint型をそのようなテンプレートに渡すと、コンパイルエラーが発生しますが、テンプレートの2つの特殊化がある場合、エラーは発生しません。</font><font style="vertical-align: inherit;">別の専門分野が選択されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"1"</span>; } <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"2"</span>; } <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// displays: "2"</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、特殊化は、require節の述部がfalseを返した場合だけでなく、正しくない場合にも破棄されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
述語を囲む括弧は、requires節では述語の逆が述語自体の反対ではないことを覚えておく重要な注意事項です。</font><font style="vertical-align: inherit;">そう、</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特性が正しく、trueを返すことを意味します。</font><font style="vertical-align: inherit;">どこで</font></font><br>
<br>
<pre><code class="cpp hljs">!is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の述語</font><font style="vertical-align: inherit;">
の</font><font style="vertical-align: inherit;">実際の論理反転はNOT（「特性は正しく、trueを返す」）==「特性は正しくない、またはfalseを返す」-これは、概念を明示的に定義することにより、少し複雑な方法で実現されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> value_type_valid_and_trivial <font></font>
  = is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;; <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!value_type_valid_and_trivial&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">論理積と論理和</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
論理結合演算子と論理和演算子は通常のように見えますが、実際には通常のC ++とは少し異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの非常によく似たコードスニペットを考えてみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は括弧のない述語です：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		|| <span class="hljs-function"><span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目は角括弧付きです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> (<span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		 || <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
違いは括弧内のみです。</font><font style="vertical-align: inherit;">ただし、このため、2番目のテンプレートには、「require-clause」によって結合された2つの制約はありませんが、通常の論理ORによって結合された1つの制約があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この違いは次のとおりです。</font><font style="vertical-align: inherit;">コードを検討する</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::optional&lt;<span class="hljs-keyword">int</span>&gt; oi {};
<span class="hljs-keyword">int</span> i {};<font></font>
fun(i, oi);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、テンプレートは型intおよびstd ::オプションでインスタンス化されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のケースでは、int :: value_type型が無効であるため、最初の制限は満たされません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、オプションのタイプ::: value_typeは有効で、2番目の特性はtrueを返します。制約間にOR演算子があるため、述語全体が全体として満たされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のケースでは、これは無効なタイプを含む単一の式です。これは、一般に無効であり、述部が満たされないためです。</font><font style="vertical-align: inherit;">そのため、単純な括弧は、何が起こっているのかをいつの間にか変化させます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論として</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、概念のすべての機能がここに示されているわけではありません。私はそれ以上進めませんでした。しかし、第一印象として-非常に興味深いアイデアとやや奇妙な混乱した実装。そして、繰り返しが必要な面白い構文は、本当に混乱します。英語の単語が本当に少ないので、完全に異なる目的で1つの単語を使用する必要がありましたか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイルされたコードのアイデアは間違いなく良いです。構文マクロの「準引用」に多少似ています。しかし、戻り値の型をチェックするための特別な構文を混同する価値はありましたか？私見、これのためには、単に別のキーワードを作成する必要があるでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「true / false」と「compiles / does not compile」の概念が1つのヒープに暗黙的に混在しているため、角括弧付きのジョークも間違っています。</font><font style="vertical-align: inherit;">これらは異なる概念であり、厳密に異なるコンテキストに存在する必要があります（私はそれがどこから来たのかを理解しています-コンパイルされていないコードが特殊化を検討対象から黙って除外したSFINAEルールから）。</font><font style="vertical-align: inherit;">しかし、概念の目標がコードをできるだけ明示的にすることである場合、これらすべての暗黙的なものを新しい機能にドラッグする価値はありましたか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事は、に基づいて、主に書かれた</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/01/29/requires-expressionの</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/03/26/requires-clause</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
（はるか例や興味深い特徴があります）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
からの私の追加と他のソース、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての例を確認できます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wandbox.org</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja495380/index.html">偉大なエジプトのファイアウォール</a></li>
<li><a href="../ja495384/index.html">マイクロソフトレドモンドでのインターンシップ経験とオファーの取得</a></li>
<li><a href="../ja495388/index.html">eSportsの祖先となった1970年代のテレビ番組</a></li>
<li><a href="../ja495390/index.html">STM32CubeMonitorは試してみる価値があります</a></li>
<li><a href="../ja495392/index.html">フロントエンドでバグを検索する方法：4つのメインステージ</a></li>
<li><a href="../ja495398/index.html">Ro.Ri.Re</a></li>
<li><a href="../ja495400/index.html">SPIインターフェイスを介してSDカードを操作します。VHDL実装</a></li>
<li><a href="../ja495402/index.html">昨年、ようやくブラックホールの写真を撮りました。それで？</a></li>
<li><a href="../ja495404/index.html">たるみ株は有望ですか？Pythonで分析しましょう</a></li>
<li><a href="../ja495408/index.html">＃02-そして、バイト全体では十分ではありません... | 変化の十字架</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>