<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚≠êÔ∏è üíáüèæ üêù Investigation: what is higher than thread priorities in Windows? ü•É üë©üèº‚Äçü§ù‚Äçüë®üèæ üê•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This investigation, like many others, began with the fact that I was doing my own business, not trying to look for problems for myself. This time, all...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Investigation: what is higher than thread priorities in Windows?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498498/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This investigation, like many others, began with the fact that I was doing my own business, not trying to look for problems for myself. This time, all I did was open the lid of the laptop and tried to log into the system. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the first few times, when this resulted in a delay of twenty seconds, I ignored the problem, hoping that it would resolve itself. The next few times I thought about the investigation, but performance problems that arise even before you logged in are more difficult to solve, and I was lazy. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When I noticed that I was avoiding closing the laptop because I was afraid of these too frequent delays, I realized that it was time to do this seriously. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortunately, I recently fixed the </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">UIforETW</font></a><font style="vertical-align: inherit;"> ring buffer </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trace</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">making it reliable, so I started it and started to wait for the next delay event. I did not have to wait long. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It took me several times to get the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ETW trace</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> completely fine with me </font><font style="vertical-align: inherit;">. And since this territory was unfamiliar to me, it took some time to figure out what was happening. I still did not fully understand the problem, but 90% understood the reasons for its occurrence. I managed to learn a lot, including some new details about the Windows scheduler, and I also found an absolutely effective solution. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The ideal trace that I eventually recorded when loading into Microsoft Windows Performance Analyzer (WPA) looks like this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/031/72d/34903172d4e4c5f85b33a02255942315.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard events, windows in focus and CPU usage.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
This table and two graphs contain a ton of information. The top table ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generic Events</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) shows the recorded keystrokes for UIforETW. I tried to press a key (virtual key code 162) once per second until a password input field appears. Since these 17 keystrokes are selected, in the graph below they are shown with vertical blue lines for simplified visualization of the execution time of critical events. The x-axis represents the time in seconds.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The horizontal bars in the upper graph ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Window in Focus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) show which process has focus during this time. </font><font style="vertical-align: inherit;">There are six different processes in total. </font><font style="vertical-align: inherit;">The </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tracing off</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> period </font><font style="vertical-align: inherit;">is the short time during which the laptop was closed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The bottom graph shows </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU usage</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Information is obtained from context switching data, therefore it must be completely accurate and complete. </font><font style="vertical-align: inherit;">In this trace, a value of 100% indicates the moment when all eight logical processors of my four-core eight-thread notebook were used. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having received the trace data, I had to figure out what my laptop secretly does when the cover is closed and until the moment I return to the system.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Storm before the lull</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As we can see, the laptop at the beginning of the trace of the laptop is relatively simple, as it should be. Then I closed its lid. This seems to have caused a spike in CPU activity and a change in the focus of windows. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Window in Focus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> changed from UIforETW to Idle, then to csrss, back to Idle, to LogonUI, and then back to Idle. Who would have thought?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
During this interval, the laptop performed approximately 17 seconds of CPU processing of various types. Part of it is the work needed to shut off. Part - these are programs (including internal Google tools) that are registered in the Task Scheduler for the execution of ‚ÄúWhen a user locks a workstation‚Äù - it makes sense. I even noticed that work is being done to create UI elements for logging in when the user continues to work - you need to be prepared in advance, right?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
17 seconds of CPU - quite a long time for the laptop to go to sleep. </font><font style="vertical-align: inherit;">Even on my laptop with four cores and eight threads, the process takes more than four seconds. </font><font style="vertical-align: inherit;">On my home laptop, it takes more than 13 seconds of CPU time to fall asleep, and almost all of them go to Windows code. </font><font style="vertical-align: inherit;">Does the </font><font style="vertical-align: inherit;">diagnostic policy service </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">really</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> need to run a couple of SruDbTableSearches before the laptop can rest? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I think this excessive work when going to sleep is </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also a</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> problem, but this is not </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the very</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> problem I am looking for. </font><font style="vertical-align: inherit;">So I just decided to turn my back on her. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And only much later I realized that it was during this time that the grains of destruction of my bug were thrown ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sleep</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After blocking the laptop, there is no CPU activity. </font><font style="vertical-align: inherit;">In this particular test, the laptop was locked for about 16 seconds.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convulsive awakening</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The activity of the CPU upon transition to sleep is incomparable with when it began to awaken. </font><font style="vertical-align: inherit;">During this time, my overloaded laptop took about 172 seconds of CPU time (!!!) for 22.6 seconds. </font><font style="vertical-align: inherit;">This is a lot of work. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the mysteries of this process is the drop in CPU usage to almost zero about a second after the initial outburst of activity. </font><font style="vertical-align: inherit;">This short period of downtime seems rather abnormal, given the chaos surrounding it. </font><font style="vertical-align: inherit;">But I think that this feature is not related to the problem, so I did not pay attention to it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another mystery is why </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so many</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programs come to life after this brief pause. It's funny that the most serious intruder responsible for 31.6 out of 172 seconds of the CPU was Windows Performance Analyzer (WPA) - the very program that I use to analyze traces. The three copies I left running are working hard on rendering my UI, even though it is not yet visible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, dark patterns occur when trying to initialize laptop devices. KeStallExecutionProcessor is a waiting loop, and it was strange to see that this is the most executable function of the entire system. Is a second-odd wait cycle the only way to start equipment? </font><font style="vertical-align: inherit;">Is it </font><font style="vertical-align: inherit;">really necessary to spend 700 ms CPU time initializing the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mouse and keyboard</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? Should Microsoft and Intel ignore Microsoft's recommendation on</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a maximum of 50 microseconds</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa7/c4e/cf4/fa7c4ecf4fe56c7c9014ee252f4557b0.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drivers of a waiting cycle. </font><font style="vertical-align: inherit;">i8042prt.sys is written by Microsoft. </font><font style="vertical-align: inherit;">The following two are created by Intel. </font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ultimately, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">many</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> programs are </font><font style="vertical-align: inherit;">actively running during this time </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Most of them seem to be facing the same problem as WPA - they are desperate to draw pixels on a hidden screen, and this alludes to a Windows bug. </font><font style="vertical-align: inherit;">But even without this bug explorer.exe and other programs actively seek </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">something</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to do. </font><font style="vertical-align: inherit;">But in the end, although this excessive CPU usage is a necessary </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">part of the</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> problem, it is not </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> problem </font><em><font style="vertical-align: inherit;">itself</font></em><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">So again I stopped paying attention to her.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Focus</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When analyzing traces, it is important to find out when important actions occur. The main evidence was input events, because I stopped clicking on control after the password input form appeared. Here are the last three keystrokes of the control key in an approximate form on the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Window in Focus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chart </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/158/50d/6f9/15850d6f9eecb243c2984cd4988c6bb1.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It seems that the critical events are getting the focus of LockApp.exe, after which the focus gets LogonUI.exe almost instantly. </font><font style="vertical-align: inherit;">Presumably, I entered the password in LogonUI.exe (it is convenient that the trace did not intercept keyboard events), after which the focus briefly switched to explorer, and then to UIforETW, from which I started. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It also looks like LogonUI.exe cannot get focus before LockApp.exe - this pattern repeats itself in all the traces I studied. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, after more than a thousand words dedicated to solving this riddle, we finally have a clear question that we can investigate: why does LockApp.exe get focus after exiting the downtime, it takes twenty seconds?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have a question? </font><font style="vertical-align: inherit;">Great, let's answer it</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU Usage (Precise)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> data obtained from content switching, </font><font style="vertical-align: inherit;">I quickly found that within twenty seconds after waking LockApp.exe received less than one millisecond of CPU time, and for more than 14 seconds (from 35.158 s to 49.827 s) did not work generally:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f50/5dc/954/f505dc954915bdbf5a857eac5c4303f4.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LockApp does not work at all for a long time</font></font></i><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The documentation on the meaning of the columns in the CPU Usage (Precise) tables is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If a process or thread has not been running for some time, and you want to find out why, usually important clues can be found in the first context switch after a long lull, namely switching to 49.827 seconds of tracing. </font><font style="vertical-align: inherit;">I reordered the columns to show more data from this context switch:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/23d/7ca/7f423d7cad82b87f4c5556551b0e8fec.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LockApp is prepared but not executed. Strange ...</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Count, equal to 1 means that we look at the data for a single context switch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Time Since Last, equal to 38.2 million microseconds, means that this thread will not execute within 38.2 seconds. This in itself is neither good nor bad. Idle flows save energy, and in the end the laptop was in a dream for some time. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Switch-In Time simply tells us when exactly the thread fits in the CPU ‚Äî when the context switches to that thread. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And now we go to the Ready column. He tells us how long the thread was </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ready</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to execute, but not executed. In other words, this thread was </font><font style="vertical-align: inherit;">waiting for </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">something</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (lock, handle) and this </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is something</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">was freed or initiated, but the thread still </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">did not run</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for 19.493 seconds. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To better understand the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ready (us)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> column </font><font style="vertical-align: inherit;">, you can take a look at the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ready Time (s)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> column </font><font style="vertical-align: inherit;">. He tells us when the stream is prepared. We see that for 30.333 seconds of tracing, this thread was prepared for execution, but did not execute until 49.827 seconds. This seems to be important. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This arrangement of columns otherwise shows us the same context switch:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07f/b5c/c85/07fb5cc85d3dfc066a6c3cbd508ef7d7.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Thread Stack and Ready Thread Stack</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
So, this thread (which the New Thread Stack expected NtWaitForWorkViaWorkerFactory to show) was ordered to wake up (the system process calling KeSetEvent) shortly after I opened the notebook lid for 30.333 seconds of tracing. </font><font style="vertical-align: inherit;">But it started not then (which would be ‚Äúgood‚Äù), but after 19.494 s, and this is bad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typically, when conducting such an analysis of expectations, I spend a lot of time figuring out why the stream is waiting and what caused it to not be ready. </font><font style="vertical-align: inherit;">But this was the first time I was doing an analysis of expectations, in which it was not important, and the question was why this ready-made thread is not executed.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cases ...</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Most people don‚Äôt spend so much time studying ETW traces, so an explanation is needed here. </font><font style="vertical-align: inherit;">This is </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">very</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> strange. </font><font style="vertical-align: inherit;">If the thread is ready, then it usually starts instantly, or after a few milliseconds. </font><font style="vertical-align: inherit;">The readiness of the stream, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as the name implies</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , means that the stream is ready for execution and almost nothing can interfere with it. </font><font style="vertical-align: inherit;">But let's figure out what can prevent the execution of a finished thread.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread priority</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At first I suggested that this is a simple case of CPU ‚Äúhunger‚Äù. Dozens of processes require CPU time, and because of this, LockApp does not get the right one until the load decreases. However, this theory </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not quite</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> correspond to the symptoms, because LockApp process could take about 18 seconds </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">even</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> without getting CPU time.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The CPU hunger theory is good because it is verifiable. I managed to increase the priority of the LockApp process using the Task Manager (during one of the brief periods when it was not suspended by the UWP system), therefore, in the final trace that I used for this post, LockApp was executed with high priority. A regular Windows thread runs with a priority of about 8-10. The highest priority with which a regular (non-real-time) Windows thread can run is 15. My ETW traces showed that LockApp always worked with priority 13 or higher. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here's a CPU timeline for critical 19.494 seconds, grouped and colored by priority of thread ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New In Pri</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the current priority that was assigned to the thread). </font><font style="vertical-align: inherit;">We see that threads with priorities 4, 8, 9, and 10 consume the vast majority of CPU time, especially at the end:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81b/7d5/431/81b7d5431d0a307a93d2250fec9f2b1c.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using CPU by Priority</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Here is another image with hidden threads with priorities 0-12. </font><font style="vertical-align: inherit;">Each time the graph drops below 12.5% ‚Äã‚Äã(which means one logical processor of the CPU time of my eight-thread notebook), LockApp </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> be launched, and it becomes absolutely unbelievable that priority prevents it from being executed so often when many threads with lower or equal priority get a ton of time.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ec/c2c/66b/2ecc2c66b4df4902a3c5be388596524f.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Priority CPU usage, high priority threads only</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminate priority inversion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is speculation that Windows priority inversion algorithms are so conducive to other threads that LockApp.exe is blocked. </font><font style="vertical-align: inherit;">But since the graphs shown above demonstrate that true priorities are used in planning decisions, this assumption (always unconvincing) will have to be abandoned.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stack core unloading</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When I talked about this puzzle on Twitter, one of the commentators suggested that </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the thread core stack was unloaded</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">I was not familiar with this situation, but after </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">John Werth</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 's explanations </font><font style="vertical-align: inherit;">(he understands in his field) I </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">turned off the swapping of the kernel stack</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and rebooted the computer. </font><font style="vertical-align: inherit;">Nothing changed. </font><font style="vertical-align: inherit;">In fact, I did not think that this would help, given that I have 32 GB of memory, and the problem occurs repeatedly and often; </font><font style="vertical-align: inherit;">but it was better to be sure of this.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pause process</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since LockApp is a modern UWP application, it is subject to restrictions similar to those of smartphone apps. Among other things, this means that it can be suspended when not in the foreground, and then ‚Äúunfreeze‚Äù when returned to the foreground. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">James Forshaw</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proposed </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recording Microsoft-Windows-Kernel-Process ETW</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to get data on this. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Events are designed to cause maximum confusion. The name of the task </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Process Freeze is</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> used both for ‚Äúdefrosting‚Äù and for ‚Äúfreezing‚Äù, and the version of the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">win: Stop</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> event </font><font style="vertical-align: inherit;">means that the process is starting (stopped freezing), and the version of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">win: Start</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">means that the process stops (starts to freeze). All this is extremely logical, but very confusing. If the event names were divided into Freeze and Thaw, then there would be less confusion. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is no documentation for these events, but thanks to the analysis, I determined that these events are always created by the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Background Tasks / Broker Infrastructure Service</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The name and process ID of the corresponding process are indicated in the FrozenProcessID field.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e04/32f/424/e0432f42442fa30ad0f7e6ed77f8d1c2.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessFreeze Events (also used for defrosting) It</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
was interesting to investigate this provider - it has many promising events - but in the end it turned out that LockApp did not pause or defrost during tracing. </font><font style="vertical-align: inherit;">However, this provider seemed quite useful, so I </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modified UIforETW</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> so that future versions always wrote it down.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have already ruled out everything</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
None of the theories described above seemed to me very likely, and now we have all excluded them. </font><font style="vertical-align: inherit;">I began to look for help, and asked me to give me ideas from a friend from Microsoft. </font><font style="vertical-align: inherit;">And at that moment I discovered that the flow priority 0-31 so well known in Windows is actually just five low priority bits of a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">full</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> priority system.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use of official position</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It turned out that my ignorance was my own fault. </font><font style="vertical-align: inherit;">If I carefully read all 108 pages of the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Threads</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> section </font><font style="vertical-align: inherit;">of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows Internals, 7th Edition, Part 1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , I would understand what was happening. </font><font style="vertical-align: inherit;">If you want to jump ahead, then this topic is revealed on pages </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">287 to 295</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This super-priority field that I did not know about is called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rank</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It appears in WPA as a default hidden column (to find it, you have to open the View Editor) called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NewThreadRank</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">When planning threads, Thread Rank has priority over priority. </font><font style="vertical-align: inherit;">Almost all streams have Rank 0, and a stream with Rank 0 always has a higher priority than a stream with Rank 2. By including a column</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NewThreadRank</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and looking at the left side of the table, we can immediately see the problem:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/374/745/f0e/374745f0eeaee797c6a8472f62d5b3f4.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rank is more important than priority</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
. LockApp.exe streams have Rank 2, which means that, despite priority 14, they have the lowest priority in the system.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An almost complete explanation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since it turned out that LockApp.exe threads have Rank 2, they can only be executed when </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">none</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of the threads with Rank 0 ‚Äúwant‚Äù to run. </font><font style="vertical-align: inherit;">Since many applications (for unknown reasons) actively render their invisible screens, they fight for every crumb of CPU time, leaving nothing for higher ranks. </font><font style="vertical-align: inherit;">Once LockApp.exe receives a tiny fraction of the CPU time, it quickly moves to Rank 0 (and the CPU load drops), after which the login process is performed in the usual way.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having learned this information, I began to study how LockApp‚Äôs rank changes over time. In the last few seconds before going to sleep, LockApp suddenly moved from rank 0 to 2. The rank is designed to prevent the CPU from taking up too much time, such as when </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows Photos is too keen on unwanted background processing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and makes the transition from rank 2 to 19:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbc/b93/e8b/cbcb93e8bc2145f78e5ea10edba3fa8e.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft.Photos goes down the rank</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
From the documentation you can understand that the main purpose of the stream rank is the fair sharing of CPU time between sessions on the machine so that the processes of one user do not harm others. Both of these options for using the rank make it clear that the rank of the stream should only increase if it uses a lot of CPU time, and when the laptop went to sleep, LockApp.exe used only 79.3 ms of CPU time, and the rest of the system - 17 from the CPU time . Nevertheless, the OS for some reason decided to downgrade LockApp to 2 in the process of going to sleep. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The OS changes the rank of the stream only if it belongs to the ‚Äúplanning group‚Äù ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KSCHEDULING_GROUP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), and most threads in a typical Windows installation are not members. </font><font style="vertical-align: inherit;">Consequently, most threads are not subject to a change in rank, so they can spend CPU time the way they want.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remaining puzzles</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unfortunately, it is still unclear why LockApp.exe drops to Rank 2 before turning on sleep. I will assume that LockApp is in the planning group, and probably one of the algorithms behaves incorrectly. But I could not find an API to investigate this, and time was running out. If you know any details, then write in the comments to the original article. The very principle of using rank as the most important component in planning decisions should, it seems to me, inevitably break down if most of the processes in the system are not involved in it - threads in planning groups always run the risk of being left without the necessary resources. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamic Resource Allocation Planning</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFSS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) is doomed to fail if most threads are not involved.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also, I do not know why so many applications remain active after going to sleep. This is usually explained by the fact that ‚Äúmany timers end when the laptop is in sleep mode for several hours,‚Äù but this explanation is not suitable if the laptop was in a dream for only a few seconds, and the WPA rendering behavior indicates that something happens in the window system something wrong. Add to that bad-behavior applications and wait-cycle drivers, and everything is stacked over time by the CPU.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The fact that CPU storms die down and LockApp start up at the same time leads to an obvious explanation: LockApp can only work when the CPU demand drops. </font><font style="vertical-align: inherit;">But there is an equally convincing explanation: as soon as LockApp gets the ability to run (or, possibly, LogonUI gets it), the CPU demand drops. </font><font style="vertical-align: inherit;">Both explanations work, but I think the second is more plausible, because otherwise we cannot explain why the seemingly endless rendering of WPA suddenly stops.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solution to the problem</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As soon as I realized that LockApp.exe is a separate application that has problems with launching, and that raising its priority does not help, I disabled it. </font><font style="vertical-align: inherit;">The file DisableLockScreen.reg helped me with this:</font></font><br>
<br>
<blockquote>Windows Registry Editor Version 5.00<br>
[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Personalization]<br>
‚ÄúNoLockScreen‚Äù=dword:00000001</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By turning off the lock screen, the laptop wakes up immediately after opening the cover. </font><font style="vertical-align: inherit;">I did not notice either braking or storms of the CPU, and now it takes one step less to enter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first twitter post</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I posted when I first encountered the problem contains a timeline for an investigation that may be useful to someone. </font><font style="vertical-align: inherit;">In addition, a lot of smart people from twitter came to the post, thanks to them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When I returned to the article, I found out that after turning the lock screen back on, the problem disappeared. </font><font style="vertical-align: inherit;">A simple reboot did not fix it - in February I rebooted many times, but we probably won‚Äôt know why it was lost.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discussions</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r / programming</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r / Windows10</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacker news</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en498486/index.html">How to expand English-language semantics for search advertising in a narrow niche</a></li>
<li><a href="../en498490/index.html">An effective certification system that will allow you to become a better leader</a></li>
<li><a href="../en498492/index.html">Honey, we kill bureaucracy: how digitalization is changing the dialogue between suppliers and X5</a></li>
<li><a href="../en498494/index.html">JEP 360: Sealed Types (Preview)</a></li>
<li><a href="../en498496/index.html">Announcement of the online mitap PiterJS # 46: performance, complex UI components and CSS-in-TS</a></li>
<li><a href="../en498500/index.html">What to see in quarantine? A selection of materials from Technostream (part 1)</a></li>
<li><a href="../en498504/index.html">New Year greetings and COVID-19: how hackers use the news</a></li>
<li><a href="../en498510/index.html">X. An overview of the boxed version of telephony and connecting to a remote site</a></li>
<li><a href="../en498512/index.html">Fighting traffic jams in a small town for a small budget: results of 6 months of the project</a></li>
<li><a href="../en498516/index.html">Postman - AutoMetrica Metrics in AppMetrica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>