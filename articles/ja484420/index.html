<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏻 👲🏾 📳 人気のBattlEye antichitaの変更とそれらを回避する方法 🗂️ 👩‍🚀 👈🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="BattlEyeシェルコードのメジャーアップデート
 時間が経つにつれ、アンチチートが変化し、製品の有効性を高めるために、それらに機能が現れたり消えたりします。1年前に、BattlEyeシェルコードの詳細な説明を私のブログ（Habréの翻訳）に用意しました。この記事のこの部分は、シェルコードに加えら...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>人気のBattlEye antichitaの変更とそれらを回避する方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484420/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/c7/fe/zdc7ferp6hnuf19n_aid_mh4tca.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BattlEyeシェルコードのメジャーアップデート</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間が経つにつれ、アンチチートが変化し、製品の有効性を高めるために、それらに機能が現れたり消えたりします。</font><font style="vertical-align: inherit;">1年前に、BattlEyeシェルコードの詳細な説明を私の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブログ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><font style="vertical-align: inherit;">Habréの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に用意しました。この記事のこの部分は、シェルコードに加えられた変更を単純に反映したものです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブラックリストに登録されたタイムスタンプ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前回のBattlEye分析では、シャドウ禁止リストには2つのコンパイルタイムスタンプしかあり</font><font style="vertical-align: inherit;">
ませんでした</font><font style="vertical-align: inherit;">。開発者がさらに追加することを決めたようです。</font><font style="vertical-align: inherit;">残りのタイムスタンプを特定できず、2つの</font><b><font style="vertical-align: inherit;">0xF *******</font></b><font style="vertical-align: inherit;">が作成されたハッシュですVisual Studioの確定的アセンブリ。</font><font style="vertical-align: inherit;">タイムスタンプを特定してくれた@mottikrausとT0B1に感謝します。</font></font><br>
<br>
<code>0x5B12C900 (action_x64.dll)<br>
0x5A180C35 (TerSafe.dll, Epic Games)<br>
0xFC9B9325 (?)<br>
0x456CED13 (d3dx9_32.dll)<br>
0x46495AD9 (d3dx9_34.dll)<br>
0x47CDEE2B (d3dx9_32.dll)<br>
0x469FF22E (d3dx9_35.dll)<br>
0x48EC3AD7 (D3DCompiler_40.dll)<br>
0x5A8E6020 (?)<br>
0x55C85371 (d3dx9_32.dll)<br>
0x456CED13 (?)<br>
0x46495AD9 (D3DCompiler_40.dll)<br>
0x47CDEE2B (D3DX9_37.dll)<br>
0x469FF22E (?)<br>
0x48EC3AD7 (?)<br>
0xFC9B9325 (?)<br>
0x5A8E6020 (?)<br>
0x55C85371 (?)</code><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュールのチェック</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主な分析が示したように、BattlEyeの主要な機能はモジュールの列挙であり、最後の分析の瞬間から、別のモジュールがリストに追加されました。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">void</span> battleye::misc::module_unknown1()<font></font>
{<font></font>
    <span class="hljs-keyword">if</span> (!GetProcAddress(current_module, <span class="hljs-string">"NSPStartup"</span>))
		<span class="hljs-keyword">return</span>;<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (optional_header.data_directory[<span class="hljs-number">4</span>].size == <span class="hljs-number">0x1B20</span> || <font></font>
        optional_header.data_directory[<span class="hljs-number">4</span>].size == <span class="hljs-number">0xE70</span> || <font></font>
        optional_header.data_directory[<span class="hljs-number">4</span>].size == <span class="hljs-number">0x1A38</span> ||<font></font>
        timestamp &gt;= <span class="hljs-number">0x5C600000</span> &amp;&amp; timestamp &lt; <span class="hljs-number">0x5C700000</span>)<font></font>
    {<font></font>
	    report_module_unknown report = {};<font></font>
        report.unknown = <span class="hljs-number">0</span>;<font></font>
        report.report_id = <span class="hljs-number">0x35</span>;<font></font>
        report.val1 = <span class="hljs-number">0x5C0</span>;<font></font>
        report.timestamp = timestamp;<font></font>
        report.image_size = optional_header.size_of_image;<font></font>
        report.entrypoint = optional_header.address_of_entry_point;<font></font>
        report.directory_size = optional_header.data_directory[<span class="hljs-number">4</span>].size;<font></font>
		<font></font>
        battleye::report(&amp;report, <span class="hljs-keyword">sizeof</span>(report), <span class="hljs-literal">false</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リダイレクトテーブルのサイズはここでチェックされるため、これはおそらく特定のプロキシdllの検出です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィンドウのタイトル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前の分析では、さまざまなチートプロバイダーにウィンドウ名のフラグが付けられていましたが、それ以降、シェルコードはこれらのウィンドウヘッダーのチェックを停止しました。</font><font style="vertical-align: inherit;">ウィンドウのタイトルのリストは完全に置き換えられました：</font></font><br>
<br>
<code>Chod's<br>
Satan5</code><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像名</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BattlEyeは非常に原始的な検出方法を使用することで悪名高く、そのうちの1つは画像名のブラックリストです。</font><font style="vertical-align: inherit;">毎年、画像の禁止された名前のリストは長くなり、過去11か月間に5つの新しい名前が追加されてい</font><font style="vertical-align: inherit;">
ます。リストの項目のいずれかに対応する名前のモジュールが存在しても、すぐに禁止されるわけではないことに注意してください。</font><font style="vertical-align: inherit;">レポートエンジンは、モジュールに関する基本情報も伝達します。これは、BattlEyeサーバーでのチートと衝突を区別するために最もよく使用されます。</font></font><br>
<br>
<code>frAQBc8W.dll<br>
C:\\Windows\\mscorlib.ni.dll<br>
DxtoryMM_x64.dll<br>
Project1.dll<br>
OWClient.dll<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7-zip</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7-Zipは広く使用されており、チートシーンの参加者はコードボイド（コードキャビティ）のメモリフィラーとして引き続き使用しています。 BattlEyeは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">質の低い整合性チェックを</font><font style="vertical-align: inherit;">実行することでこれに対処しようとし</font><font style="vertical-align: inherit;">ますが、前回の記事から変更されています。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">module::check_7zip</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> module_handle = GetModuleHandleA(<span class="hljs-string">"..\\..\\Plugins\\ZipUtility\\ThirdParty\\7zpp\\dll\\Win64\\7z.dll"</span>);
    <span class="hljs-comment">// --- REMOVED ---</span>
	<span class="hljs-comment">// if (module_handle &amp;&amp; *(int*)(module_handle + 0x1000) != 0xFF1441C7)</span><font></font>
	<font></font>
	<span class="hljs-comment">// --- ADDED ---</span>
    <span class="hljs-keyword">if</span> (module_handle &amp;&amp; *(<span class="hljs-keyword">int</span>*)(module_handle + <span class="hljs-number">0x1008</span>) != <span class="hljs-number">0x83485348</span>)<font></font>
    {<font></font>
      sevenzip_report.unknown_1 = <span class="hljs-number">0</span>;<font></font>
      sevenzip_report.report_id = <span class="hljs-number">0x46</span>;<font></font>
      sevenzip_report.unknown_2 = <span class="hljs-number">0</span>;<font></font>
      sevenzip_report.data1 = *(__int64*)(module_handle + <span class="hljs-number">0x1000</span>;<font></font>
      sevenzip_report.data2 = *(__int64*)(module_handle + <span class="hljs-number">0x1008</span>;<font></font>
      battleye::report(&amp;sevenzip_report, <span class="hljs-keyword">sizeof</span>(sevenzip_report), <span class="hljs-literal">false</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BattlEye開発者は、私の以前の記事で多くのユーザーが、BattlEyeによってチェックされている場所に目的のバイトをコピーするだけでこのチェックをバイパスするようになったと推測しているようです。</font><font style="vertical-align: inherit;">彼らはどのように状況を修正しましたか？</font><font style="vertical-align: inherit;">検証を8バイトシフトし、整合性をチェックする同じ悪い方法を引き続き使用しました。</font><font style="vertical-align: inherit;">読み取り専用の実行可能セクションであり、必要なのは7-Zipをディスクからダウンロードして、移動したパーティションを相互に比較することだけです。</font><font style="vertical-align: inherit;">矛盾がある場合は、何かが間違っています。</font><font style="vertical-align: inherit;">真剣に、みんな、整合性チェックを実行することはそれほど難しくありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワークチェック</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TCPテーブルの列挙は引き続き機能しますが、Cloudflare IPアドレスにフラグを付けることについて開発者を批判する以前の分析をリリースした後も、このチェックは削除されました。</font><font style="vertical-align: inherit;">Anti-cheatは、xera.phが接続に使用するポートを引き続き報告しますが、開発者は、接続のあるプロセスにアクティブな保護があるかどうかを判断する新しいチェックを追加しました（おそらくこれはハンドラーを使用して行われます）。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">void</span> network::scan_tcp_table<font></font>
{<font></font>
    <span class="hljs-built_in">memset</span>(local_port_buffer, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(local_port_buffer);<font></font>
 <font></font>
    <span class="hljs-keyword">for</span> (iteration_index = <span class="hljs-number">0</span>; iteration_index; &lt; <span class="hljs-number">500</span> ++iteration_index)<font></font>
    {<font></font>
        <span class="hljs-comment">// GET NECESSARY SIZE OF TCP TABLE</span>
        <span class="hljs-keyword">auto</span> table_size = <span class="hljs-number">0</span>;<font></font>
        GetExtendedTcpTable(<span class="hljs-number">0</span>, &amp;table_size, <span class="hljs-literal">false</span>, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, <span class="hljs-number">0</span>);<font></font>
 <font></font>
        <span class="hljs-comment">// ALLOCATE BUFFER OF PROPER SIZE FOR TCP TABLE</span>
        <span class="hljs-keyword">auto</span> allocated_ip_table = (MIB_TCPTABLE_OWNER_MODULE*)<span class="hljs-built_in">malloc</span>(table_size);<font></font>
 <font></font>
        <span class="hljs-keyword">if</span> (GetExtendedTcpTable(allocated_ip_table, &amp;table_size, <span class="hljs-literal">false</span>, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, <span class="hljs-number">0</span>) != NO_ERROR)
            <span class="hljs-keyword">goto</span> cleanup;<font></font>
 <font></font>
        <span class="hljs-keyword">for</span> (entry_index = <span class="hljs-number">0</span>; entry_index &lt; allocated_ip_table-&gt;dwNumEntries; ++entry_index)<font></font>
        {<font></font>
            <span class="hljs-comment">// --- REMOVED ---</span>
            <span class="hljs-comment">// const auto ip_address_match_1 = </span>
            <span class="hljs-comment">//     allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656B1468; // 104.20.107.101</span>
            <span class="hljs-comment">// </span>
            <span class="hljs-comment">// const auto ip_address_match_2 = </span>
            <span class="hljs-comment">//     allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656C1468; // 104.20.108.101</span><font></font>
 <font></font>
            <span class="hljs-comment">// +++ ADDED +++</span>
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> target_process = OpenProcess(QueryLimitedInformation, <span class="hljs-number">0</span>, ip_table-&gt;table[entry_index].dwOwningPid);
			<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> <span class="hljs-keyword">protected</span> = target_process == INVALID_HANDLE &amp;&amp; GetLastError() == <span class="hljs-number">0x57</span>;<font></font>
 <font></font>
			<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">protected</span>)<font></font>
            {<font></font>
                CloseHandle(target_process);<font></font>
				<span class="hljs-keyword">return</span>;<font></font>
			}<font></font>
 <font></font>
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> port_match = <font></font>
                allocated_ip_table-&gt;table[entry_index].dwRemotePort == <span class="hljs-number">20480</span>;<font></font>
 <font></font>
            <span class="hljs-keyword">for</span> (port_index = <span class="hljs-number">0</span>;<font></font>
                 port_index &lt; <span class="hljs-number">10</span> &amp;&amp; <font></font>
                 allocated_ip_table-&gt;table[entry_index].dwLocalPort != <font></font>
                    local_port_buffer[port_index];<font></font>
                 ++port_index)<font></font>
            {<font></font>
                <span class="hljs-keyword">if</span> (local_port_buffer[port_index])
                    <span class="hljs-keyword">continue</span><font></font>
 <font></font>
                tcp_table_report.unknown = <span class="hljs-number">0</span>;<font></font>
                tcp_table_report.report_id = <span class="hljs-number">0x48</span>;<font></font>
                tcp_table_report.module_id = <span class="hljs-number">0x5B9</span>;<font></font>
                tcp_table_report.data = <font></font>
                    BYTE1(allocated_ip_table-&gt;table[entry_index].dwLocalPort) | <font></font>
                    (LOBYTE(allocated_ip_table-&gt;table[entry_index.dwLocalPort) &lt;&lt; <span class="hljs-number">8</span>;<font></font>
 <font></font>
                battleye::report(&amp;tcp_table_report, <span class="hljs-keyword">sizeof</span>(tcp_table_report), <span class="hljs-literal">false</span>);<font></font>
 <font></font>
                local_port_buffer[port_index] = allocated_ip_table-&gt;table[entry_index].dwLocalPort;<font></font>
                <span class="hljs-keyword">break</span><font></font>
 <font></font>
            }<font></font>
        }<font></font>
 <font></font>
cleanup:<font></font>
        <span class="hljs-comment">// FREE TABLE AND SLEEP</span>
        <span class="hljs-built_in">free</span>(allocated_ip_table);<font></font>
        Sleep(<span class="hljs-number">10</span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IChooseYouと要約に感謝</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BattlEyeスタックバイパス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハッキングゲームは猫とネズミの絶え間ないゲームなので、新しいトリックの噂が火のように広がっています。この部分では、アンチチートのBattlEyeの大手プロバイダーによって最近兵器に追加された新しいヒューリスティック手法について説明します。ほとんどの場合、これらの手法はスタックウォーキングと呼ばれます。通常、これらは関数を処理し、スタックを調べて、この関数を具体的に誰が呼び出したかを調べることによって実装されます。なぜこれを行う必要があるのですか？他のプログラムと同様に、ビデオゲームハックには、キーボードから情報を取得したり、コンソールに出力したり、特定の数式を計算したりするために使用する一連の既知の関数があります。さらに、ビデオゲームのハッキングは、メモリ内またはディスク上にあるかどうかにかかわらず、その存在を隠し、アンチチートソフトウェアがそれらを見つけられないようにするのが大好きです。しかし、チートプログラムが忘れているのは定期的に他のライブラリの関数を呼び出します。これを使用して、未知のチートを発見的に検出できます。次のような機能のスタックトラバーサルエンジンを実装することにより</font></font><code>std::print</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、これらのチートは偽装されていても見つけることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BattlEye </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「スタックバイパス」を</font><strong><font style="vertical-align: inherit;">実装しました</font></strong><font style="vertical-align: inherit;">が、これは公表されておらず、記事の公開時には噂しかありませんでした。引用符に注意してください。ここに表示されるのは、実際のスタックトラバーサルではなく、呼び出しアドレスの戻りアドレスとダンプのチェックの組み合わせです。真のスタックトラバーサル実装は、スタックを通過して実際のコールスタックを生成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BattlEyeに関する以前の記事で説明したように、アンチチートシステムは、実行中にシェルコードを動的にゲームにストリーミングします。これらのシェルコードはサイズとタスクが異なり、同時に送信されません。このようなシステムの注目すべき特性は、研究者がマルチプレイヤーマッチ中にアンチチートを動的に分析する必要があることで、このアンチチートの特性の決定が複雑になります。また、チート対策により、さまざまなユーザーにさまざまな対策を適用できます。たとえば、殺人と死亡の比率が異常に高い人にのみ、より侵襲的なモジュールを転送することなどが可能になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのシェルコードの1つであるBattlEyeは、このスタック分析を実行します。私たちはそれを</font><em><font style="vertical-align: inherit;">shellcode8kb</font></em><font style="vertical-align: inherit;">と呼び</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは</font><font style="vertical-align: inherit;">、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ここで</font></a><font style="vertical-align: inherit;">説明</font><font style="vertical-align: inherit;">した</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shellcodemain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">比べてわずかに小さいため</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AddVectoredExceptionHandler</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を使用するこの小さなシェルコード</font><font style="vertical-align: inherit;">は、ベクトル化された例外ハンドラーを準備し、次の関数に割り込みトラップを設定します。</font><font style="vertical-align: inherit;">
これを行うには、標準的に使用される関数のリストを繰り返しトラバースし、対応する関数の最初の命令を</font><strong><font style="vertical-align: inherit;">int3</font></strong><font style="vertical-align: inherit;">に設定し</font><strong><font style="vertical-align: inherit;">ます</font></strong></font><br>
<br>
<code>GetAsyncKeyState<br>
GetCursorPos<br>
IsBadReadPtr<br>
NtUserGetAsyncKeyState<br>
GetForegroundWindow<br>
CallWindowProcW<br>
NtUserPeekMessage<br>
NtSetEvent<br>
sqrtf<br>
__stdio_common_vsprintf_s<br>
CDXGIFactory::TakeLock<br>
TppTimerpExecuteCallback</code><br>
<br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブレークポイントとして使用されます。ブレークポイントを設定した後、対応する関数へのすべての呼び出しは、例外ハンドラーを通過します。例外ハンドラーは、レジスターとスタックに完全にアクセスできます。このアクセス権があると、例外ハンドラーは呼び出しプログラムのアドレスをスタックの一番上からダンプし、ヒューリスティック条件の1つが満たされると、呼び出し関数の32バイトがダンプされ、レポート識別子</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x31</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とともにBattlEyeサーバーに送信されます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">__int64 <span class="hljs-title">battleye::exception_handler</span><span class="hljs-params">(_EXCEPTION_POINTERS *exception)</span>
</span>{
    <span class="hljs-keyword">if</span> (exception-&gt;ExceptionRecord-&gt;ExceptionCode != STATUS_BREAKPOINT)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> caller_function = *(__int64 **)exception-&gt;ContextRecord-&gt;Rsp;<font></font>
    MEMORY_BASIC_INFORMATION caller_memory_information = {};<font></font>
    <span class="hljs-keyword">auto</span> desired_size = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-comment">// QUERY THE MEMORY PAGE OF THE CALLER</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> call_failed = NtQueryVirtualMemory(<font></font>
                                GetCurrentProcess(), <font></font>
                                caller_function, <font></font>
                                MemoryBasicInformation, <font></font>
                                &amp;caller_memory_information, <font></font>
                                <span class="hljs-keyword">sizeof</span>(caller_memory_information), <font></font>
                                &amp;desired_size) &lt; <span class="hljs-number">0</span>;<font></font>
    <font></font>
    <span class="hljs-comment">// IS THE MEMORY SOMEHOW NOT COMMITTED? (WOULD SUGGEST VAD MANIPULATIUON)</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> non_commit = caller_memory_information.State != MEM_COMMIT;
    <span class="hljs-comment">// IS THE PAGE EXECUTABLE BUT DOES NOT BELONG TO A PROPERLY LOADED MODULE?</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> foreign_image = caller_memory_information.Type != MEM_IMAGE &amp;&amp; caller_memory_information.RegionSize &gt; <span class="hljs-number">0x2000</span>;
    <span class="hljs-comment">// IS THE CALL BEING SPOOFED BY NAMAZSO?</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> spoof = *(_WORD *)caller_function == <span class="hljs-number">0x23FF</span>; <span class="hljs-comment">// jmp qword ptr [rbx]</span><font></font>
<font></font>
    <span class="hljs-comment">// FLAG ALL ANBORMALITIES</span>
    <span class="hljs-keyword">if</span> (call_failed || non_commit || foreign_image || spoof)<font></font>
    {<font></font>
        report_stack.unknown = <span class="hljs-number">0</span>;<font></font>
        report_stack.report_id = <span class="hljs-number">0x31</span>;<font></font>
        report_stack.hook_id = hook_id;<font></font>
        report_stack.caller = (__int64)caller_function;<font></font>
        report_stack.function_dump[<span class="hljs-number">0</span>] = *caller_function;<font></font>
        report_stack.function_dump[<span class="hljs-number">1</span>] = caller_function[<span class="hljs-number">1</span>];<font></font>
        report_stack.function_dump[<span class="hljs-number">2</span>] = caller_function[<span class="hljs-number">2</span>];<font></font>
        report_stack.function_dump[<span class="hljs-number">3</span>] = caller_function[<span class="hljs-number">3</span>];
        <span class="hljs-keyword">if</span> (!call_failed)<font></font>
        {<font></font>
            report_stack.allocation_base = caller_memory_information.AllocationBase;<font></font>
            report_stack.base_address = caller_memory_information.BaseAddress;<font></font>
            report_stack.region_size = caller_memory_information.RegionSize;<font></font>
            report_stack.type_protect_state = caller_memory_information.Type | caller_memory_information.Protect | caller_memory_information.State;<font></font>
        }<font></font>
        <font></font>
        battleye::report(&amp;report_stack, <span class="hljs-keyword">sizeof</span>(report_stack), <span class="hljs-literal">false</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のように、例外ハンドラーは、メモリページに異常な変更があった場合、または関数が既知のプロセスモジュールに属していない場合（メモリページタイプMEM_IMAGEが手動マッパーによって設定されていなかった場合）、すべての呼び出し関数をダンプします。また</font><font style="vertical-align: inherit;">、チートがこのシステムコールにバインドせず、モジュールがスタックダンプから隠れるように、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NtQueryVirtualMemoryの</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しに失敗したときに呼び出し関数を</font><font style="vertical-align: inherit;">ダンプします。最後の条件は実際には非常に興味深いものであり、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jmp qword ptr [rbx]ガジェット</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用してすべての呼び出し関数をマークし</font><font style="vertical-align: inherit;">ます。これは、「戻りアドレスの偽装」に使用される方法です。彼は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解放されます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シークレットクラブのニックネームのナマソの同僚。</font><font style="vertical-align: inherit;">BattlEyeの開発者は、人々がゲームでこのスプーフィング手法を使用していることを知り、直接狙うことに決めたようです。</font><font style="vertical-align: inherit;">namazsosによって記述された方法がうまく機能すること、ここでは言及する価値があります。異なるガジェットを使用するか、完全に異なるか、単に異なるレジスタを使用するだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BattlEye開発者のヒント：（</font></font><code>CDXGIFactory::TakeLock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偶然または意図的に）CCパディングを</font><font style="vertical-align: inherit;">有効にした</font><font style="vertical-align: inherit;">ため、</font><font style="vertical-align: inherit;">使用する</font><font style="vertical-align: inherit;">メモリ</font><font style="vertical-align: inherit;">は無効です</font><font style="vertical-align: inherit;">。これは、コンパイルするたびに大きく異なります。</font><font style="vertical-align: inherit;">互換性を最大にするには、パディング（署名の最初のバイト）を削除する必要があるため、より多くの不正</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
行為</font><font style="vertical-align: inherit;">者をキャッチする可能性があります:) </font><font style="vertical-align: inherit;">BattlEyeサーバーに送信される完全な構造は次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">unaligned</span> <span class="hljs-title">battleye_stack_report</span>
{</span><font></font>
  __int8  unknown;<font></font>
  __int8  report_id;<font></font>
  __int8  val0;<font></font>
  __int64 caller;<font></font>
  __int64 function_dump[<span class="hljs-number">4</span>];<font></font>
  __int64 allocation_base;<font></font>
  __int64 base_address;<font></font>
  __int32 region_size;<font></font>
  __int32 type_protect_state;<font></font>
};</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BattlEyeでのハイパーバイザー認識</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハッキングゲームの分野での猫とマウスのゲームは、悪用と不正行為との戦いにおける革新の源であり続けています。ハッキングゲームでの仮想化テクノロジーの使用は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DdiMon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Satoshi Tandaや</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hvpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Peter Benes </font><font style="vertical-align: inherit;">などの使いやすいハイパーバイザーの出現後、活発に発展し始めました</font><font style="vertical-align: inherit;">。これらの2つのプロジェクトは、エントリのしきい値が低く、詳細なドキュメントがあるため、アンダーグラウンドハッカーシーンのほとんどの有料チートで使用されています。これらのリリースは、ハイパーバイザーの分野での軍拡競争を加速させる可能性が高く、ハイパーバイザーは現在、ゲームハッカーのコミュニティに現れ始めています。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wlan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">というニックネームを持つ最大のゲームハッキングコミュニティの管理者が、この状況について次のように述べています</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームをハッキングするためのすぐに使用できるハイパーバイザーシステムの登場により、BattlEyeのようなアンチチートが仮想化の一般化された認識に焦点を合わせることが避けられなくなりました。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハイパーバイザーが広く使用されているのは、アンチチートの最近の改善によるもので、ハッカーが従来の方法でゲームを変更する機会はほとんどありませんでした。</font><font style="vertical-align: inherit;">仮想化は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">syscallフック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MMU仮想化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などのメカニズムを使用して情報の非表示を簡素化するため、ハイパーバイザーの人気はアンチチートを回避する単純さで説明でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近、BattlEyeは、時間ベースの検出を使用して、上記のプラットフォーム（DdiMon、hvpp）などの一般的なハイパーバイザーの認識を実装しました。この認識は、非標準のCPUID命令時間値を検出しようとします。 CPUIDは実際の機器では比較的低コストの命令であり、通常200サイクルしか必要ありません。仮想環境では、イントロスペクションエンジンによる不要な操作が原因で、実行に10倍の時間がかかることがあります。イントロスペクションエンジンは、任意の基準に基づいて、ゲストに返されるデータを追跡し、条件付きで変更するため、実際の機器とは異なり、期待どおりに操作を実行するだけです。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">楽しい事実：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUIDは無条件のシリアル化を伴う命令と同様に無条件の出力を伴う命令であるため、これらの一時的な認識手順でアクティブに使用されます。</font><font style="vertical-align: inherit;">これは、CPUIDが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バリア</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として使用され、</font><font style="vertical-align: inherit;">その前後の命令が確実に実行されることを</font><font style="vertical-align: inherit;">意味し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">この場合、タイミングは通常の命令の並べ替えとは無関係になります。</font><font style="vertical-align: inherit;">無条件の終了を実行する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XSETBVの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ような命令を使用することもできますが</font><font style="vertical-align: inherit;">、独立したタイミングを保証するには、その前または後に並べ替えが発生せず、タイミングの信頼性に影響を与えないように、何らかのバリア命令が必要になります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">認識</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、BattlEye「BEClient2」モジュールからの認識手順です。</font><font style="vertical-align: inherit;">私はそのリバースエンジニアリングを実行し、コードを疑似Cで再作成してから、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">twitterに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投稿しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私のつぶやきの翌日、BattlEyeの開発者たちは予期せずBEClient2の難読化を変更し、これがモジュールの分析を妨げることを期待していたようです。</font><font style="vertical-align: inherit;">以前の難読化は1年以上変更されていませんが、私のツイートの翌日に変更されました-印象的なスピード。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">void</span> battleye::take_time()<font></font>
{<font></font>
    <span class="hljs-comment">// SET THREAD PRIORITY TO THE HIGHEST</span>
    <span class="hljs-keyword">const</span> auto old_priority = SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);<font></font>
<font></font>
    <span class="hljs-comment">// CALCULATE CYCLES FOR 1000MS</span>
    <span class="hljs-keyword">const</span> auto timestamp_calibrator = __rdtsc();<font></font>
    Sleep(<span class="hljs-number">1000</span>);
    <span class="hljs-keyword">const</span> auto timestamp_calibration = __rdtsc() - timestamp_calibrator;<font></font>
<font></font>
    <span class="hljs-comment">// TIME CPUID</span>
    auto total_time = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (std::size_t count = <span class="hljs-number">0</span>; count &lt; <span class="hljs-number">0x6694</span>; count++)<font></font>
    {<font></font>
        <span class="hljs-comment">// SAVE PRE CPUID TIME</span>
        <span class="hljs-keyword">const</span> auto timestamp_pre = __rdtsc();<font></font>
<font></font>
        std::uint32_t cpuid_data[<span class="hljs-number">4</span>] = {};<font></font>
        __cpuid(cpuid_data, <span class="hljs-number">0</span>);<font></font>
<font></font>
        <span class="hljs-comment">// SAVE THE DELTA</span><font></font>
        total_time += __rdtsc() - timestamp_pre;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// SAVE THE RESULT IN THE GLOBAL REPORT TABLE</span>
    battleye::report_table[<span class="hljs-number">0x1A8</span>] = <span class="hljs-number">10000000</span> * total_time / timestamp_calibration / <span class="hljs-number">0x65</span>;<font></font>
<font></font>
    <span class="hljs-comment">// RESTORE THREAD PRIORITY</span><font></font>
    SetThreadPriority(GetCurrentThread(), old_priority);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上で述べたように、これは無条件にインターセプトされた命令を使用する最も一般的な認識手法です。</font><font style="vertical-align: inherit;">ただし、偽の時間に対して脆弱であるため、次のセクションでこれについて詳しく説明します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">認識バイパス</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この認識方法には問題があります。 1つ目は、通常、2つの方法でVMCSのTSCをオフセットするか、CPUIDが実行されるたびにTSCを小さくするという、偽の時間を要する傾向があります。時間ベースの攻撃に対処する方法は他にもたくさんありますが、後者の方が実装がはるかに簡単です。これは、命令の実行時間が実際の機器での実行の同期の1または2クロックサイクル以内であることを保証できるためです。今回の偽造技術を発見する難しさは、開発者の経験に依存します。次のセクションでは、BattlEyeで作成された実装の偽造と改善について見ていきます。この認識方法の欠陥の2番目の理由は、異なるプロセッサーでのCPUID遅延（ランタイム）がシートの値によって大きく異なるためです。完了するまでに最大70〜300クロックサイクルかかる場合があります。この認識手順の3番目の問題は、SetThreadPriorityを使用することです。このWindows関数は、特定のストリーム記述子の優先度値を設定するために使用されますが、OSは常に要求を待機するわけではありません。この関数は、スレッドの優先度を上げるための提案にすぎず、それが発生するという保証はありません。したがって、この方法は、中断や他のプロセスの影響を受ける可能性があります。この関数は、スレッドの優先度を上げるための提案にすぎず、それが発生するという保証はありません。したがって、この方法は、中断や他のプロセスの影響を受ける可能性があります。この関数は、スレッドの優先度を上げるための提案にすぎず、それが発生するという保証はありません。したがって、この方法は、中断や他のプロセスの影響を受ける可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、認識を迂回することは簡単であり、時間を偽造する前述の手法は、この認識方法を効果的に無効にします。</font><font style="vertical-align: inherit;">BattlEyeの開発者がこの方法を改善したい場合は、次のセクションでいくつかの推奨事項を説明します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改善</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この機能は多くの方法で改善できます。まず、意図的に割り込みを無効にし、CR8を最高のIRQLに変更することで、スレッドの優先順位を強制できます。このチェックを1つのCPUコアで分離することも理想的です。別の改善点：異なるタイマーを使用する必要がありますが、それらの多くはTSCほど正確ではありませんが、APERFタイマーまたは実際のパフォーマンスクロックと呼ばれるタイマーが1つあります。このタイマーは、不正を行うのがより難しく、論理プロセッサがC0電源状態にあるときにのみカウンターを蓄積するため、このタイマーをお勧めします。これは、TSCを使用する優れた代替手段です。 ACPER、HPET、PITタイマー、GPUタイマー、NTPタイマー、またはAPERFと同様のPPERFタイマーを使用することもできますが、命令の実行として認識される測定をカウントします。これの欠点は中間オペレーターが無効にできるHWPを有効にする必要があるため、役に立たないことに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、カーネルで実行する必要がある認識手順の改良版です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">battleye::take_time</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> cpuid_regs[<span class="hljs-number">4</span>] = {};<font></font>
<font></font>
    _disable();<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> aperf_pre = __readmsr(IA32_APERF_MSR) &lt;&lt; <span class="hljs-number">32</span>;<font></font>
    __cpuid(&amp;cpuid_regs, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> aperf_post = __readmsr(IA32_APERF_MSR) &lt;&lt; <span class="hljs-number">32</span>;<font></font>
    <font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> aperf_diff = aperf_post - aperf_pre;<font></font>
    <font></font>
    <span class="hljs-comment">// CPUID IET ARRAY STORE</span>
    <span class="hljs-comment">// BATTLEYE REPORT TABLE STORE</span><font></font>
    <font></font>
    _enable();<font></font>
}</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IETは命令実行時間の略です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、CPUIDランタイムは大きく異なる可能性があるため、一般的なハイパーバイザーを検出する手順は依然として非常に信頼できない場合があります。 2つの命令のIETを比較することをお勧めします。それらの1つは、CPUIDよりも長い実行遅延を持つ必要があります。たとえば、FYL2XP1-CPUID命令の平均IETよりも完了するまでに少し時間がかかる算術命令です。さらに、ハイパーバイザーにトラップを発生させず、その時間を確実に測定できます。これら2つの関数を使用して、プロファイリング関数はIET命令のCPUIDとFYL2XP1を格納するための配列を作成できます。 APERFタイマーを使用すると、算術命令の初期クロックを取得し、その命令を実行して、そのクロックのデルタを計算できます。結果は、N個のプロファイリングサイクルのIET配列に格納され、平均値が取得され、CPUIDのプロセスが繰り返されます。 CPUID命令の実行時間が算術命令よりも長い場合、算術命令はCPUIDを実行して製造元またはバージョンに関する情報を取得するよりも多くの時間を算術命令に費やすことができないため、これはシステムが仮想であるという信頼できる兆候です。この認識手順では、TSCオフセット/スケーリングを使用してこれらを検出することもできます。CPUIDを実行して製造元またはバージョン情報を取得するよりも。この認識手順では、TSCオフセット/スケーリングを使用してこれらを検出することもできます。CPUIDを実行して製造元またはバージョン情報を取得するよりも。この認識手順では、TSCオフセット/スケーリングを使用してこれらを検出することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しますが、開発者は単一コアでこのチェックを実行するためにコンピューティングコアへのバインディングを強制的に有効にし、割り込みを無効にし、一貫性と信頼性のあるデータを保証するためにIRQLに最大値を設定するよう強制する必要があります。</font><font style="vertical-align: inherit;">はるかに多くの労力を必要とするため、BattlEye開発者がこれを実装することを決定した場合、それは驚くべきことです。</font><font style="vertical-align: inherit;">カーネルドライバーでは、BattlEyeが他の2つの仮想マシン認識ルーチンを使用しますが、これは別の記事のトピックです。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja484408/index.html">RUTM時代</a></li>
<li><a href="../ja484410/index.html">便利な開発者の習慣</a></li>
<li><a href="../ja484412/index.html">最新の自動車エレクトロニクスアーキテクチャ向けのNXP S32Gプロセッサ</a></li>
<li><a href="../ja484414/index.html">バックアップログのアーカイバの選択</a></li>
<li><a href="../ja484418/index.html">Motoriki Ilya Chekh CEO：時々彼らは実験的な義足から理想的な仕事を期待し、そして彼らは失望する</a></li>
<li><a href="../ja484424/index.html">Nvidia Orin-ロボット車両用のチップ</a></li>
<li><a href="../ja484426/index.html">私と私の原付け。非効率なスケーリング</a></li>
<li><a href="../ja484428/index.html">投資家のいない新興企業のアイデアを選択する：反対から</a></li>
<li><a href="../ja484430/index.html">世界初のHDR対応VRメガネ：パナソニックのプロトタイプについて知られていること</a></li>
<li><a href="../ja484436/index.html">Неблагодарный opensource: разработчик самого быстрого веб сервера удалил его репозиторий</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>