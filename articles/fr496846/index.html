<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏽 🥤 🍭 Mécanique du langage des piles et des pointeurs 👨🏼‍⚖️ 🎵 🤙🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prélude
 Il s'agit du premier des quatre articles de la série qui fournira un aperçu de la mécanique et de la conception des pointeurs, des piles, des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Mécanique du langage des piles et des pointeurs</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496846/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prélude</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit du premier des quatre articles de la série qui fournira un aperçu de la mécanique et de la conception des pointeurs, des piles, des tas, de l'analyse d'échappement et de la sémantique Go / pointeur. </font><font style="vertical-align: inherit;">Ce message concerne les piles et les pointeurs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Table des matières:</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mécanique du langage sur les piles et les pointeurs</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mécanique du langage sur l'analyse d'évasion</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traduction</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mécanique du langage sur le profilage de la mémoire</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Philosophie de conception sur les données et la sémantique</font></font></a></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introduction</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne vais pas dissimuler - les pointeurs sont difficiles à comprendre. </font><font style="vertical-align: inherit;">S'ils sont mal utilisés, les pointeurs peuvent provoquer des erreurs désagréables et même des problèmes de performances. </font><font style="vertical-align: inherit;">Cela est particulièrement vrai lors de l'écriture de programmes compétitifs ou multithread. </font><font style="vertical-align: inherit;">Sans surprise, de nombreuses langues essaient de cacher des pointeurs aux programmeurs. </font><font style="vertical-align: inherit;">Cependant, si vous écrivez dans Go, vous ne pouvez pas échapper aux pointeurs. </font><font style="vertical-align: inherit;">Sans une compréhension claire des pointeurs, il vous sera difficile d'écrire du code propre, simple et efficace.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bordures de cadre</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les fonctions sont exécutées dans les limites des trames qui fournissent un espace mémoire séparé pour chaque fonction correspondante. Chaque trame permet à la fonction de fonctionner dans son propre contexte et fournit également un contrôle de flux. Une fonction a un accès direct à la mémoire à l'intérieur de son cadre via un pointeur, mais l'accès à la mémoire à l'extérieur du cadre nécessite un accès indirect. Pour qu'une fonction accède à la mémoire en dehors de sa trame, cette mémoire doit être utilisée conjointement avec cette fonction. La mécanique et les limites fixées par ces limites doivent être comprises et étudiées en premier.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsqu'une fonction est appelée, une transition entre deux trames se produit. Le code passe de la trame de la fonction appelante à la trame de la fonction appelée. Si les données sont nécessaires pour appeler la fonction, ces données doivent être transférées d'une trame à l'autre. Le transfert de données entre deux trames dans Go se fait "par valeur". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'avantage de la transmission de données «par valeur» est la lisibilité. La valeur que vous voyez dans l'appel de fonction est ce qui est copié et accepté de l'autre côté. C'est pourquoi j'associe «passer par la valeur» avec WYSIWYG, car ce que vous voyez est ce que vous obtenez. Tout cela vous permet d'écrire du code qui ne cache pas le coût de basculement entre deux fonctions. Cela aide à maintenir un bon modèle mental de la façon dont chaque appel de fonction affectera le programme pendant la transition.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardez ce petit programme qui appelle une fonction en passant des données entières "par valeur": </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 1:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">04</span>
<span class="hljs-number">05</span>    <span class="hljs-comment">// Declare variable of type int with a value of 10.</span>
<span class="hljs-number">06</span>    count := <span class="hljs-number">10</span>
<span class="hljs-number">07</span>
<span class="hljs-number">08</span>    <span class="hljs-comment">// Display the "value of" and "address of" count.</span>
<span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">10</span>
<span class="hljs-number">11</span>    <span class="hljs-comment">// Pass the "value of" the count.</span>
<span class="hljs-number">12</span>    increment(count)
<span class="hljs-number">13</span>
<span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">15</span> }
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc <span class="hljs-keyword">int</span>)</span></span> {
<span class="hljs-number">19</span>
<span class="hljs-number">20</span>    <span class="hljs-comment">// Increment the "value of" inc.</span>
<span class="hljs-number">21</span>    inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]"</span>)
<span class="hljs-number">23</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque votre programme Go démarre, le runtime crée le programme principal pour commencer à exécuter tout le code, y compris le code à l'intérieur de la fonction principale. Gorutin est le chemin d'exécution qui s'intègre dans le thread du système d'exploitation, qui s'exécute finalement sur un noyau. À partir de la version 1.8, chaque goroutine est fourni avec un bloc initial de mémoire continue de 2048 octets, qui forme l'espace de pile. Cette taille de pile initiale a changé au fil des ans et pourrait changer à l'avenir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La pile est importante car elle fournit un espace mémoire physique pour les limites de trame qui sont données à chaque fonction individuelle. Au moment où le goroutine principal exécute la fonction principale du listing 1, la pile de programmes (à un niveau très élevé) ressemblera à ceci: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z4/7w/l0/z47wl0tm16nh5u-gf8u9m0kemba.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la figure 1, vous pouvez voir qu'une partie de la pile a été «encadrée» pour la fonction principale. </font><font style="vertical-align: inherit;">Cette section est appelée le " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cadre de pile</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", et c'est ce cadre qui indique la limite de la fonction principale sur la pile. </font><font style="vertical-align: inherit;">Le cadre est défini comme faisant partie du code qui s'exécute lorsque la fonction est appelée. </font><font style="vertical-align: inherit;">Vous pouvez également voir que la mémoire de la variable count a été allouée à 0x10429fa4 à l'intérieur du cadre pour main. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un autre point intéressant, illustré sur la figure 1. Toute la mémoire de pile sous la trame active n'est pas valide, mais la mémoire de la trame active et au-dessus est valide. </font><font style="vertical-align: inherit;">Vous devez comprendre clairement la frontière entre la partie valide et non valide de la pile.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adresses</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les variables sont utilisées pour attribuer un nom à un emplacement de mémoire spécifique pour améliorer la lisibilité du code et vous aider à comprendre avec quelles données vous travaillez. </font><font style="vertical-align: inherit;">Si vous avez une variable, alors vous avez une valeur en mémoire, et si vous avez une valeur en mémoire, alors elle doit avoir une adresse. </font><font style="vertical-align: inherit;">Sur la ligne 09, la fonction principale appelle la fonction println intégrée pour afficher la "valeur" et l '"adresse" de la variable de comptage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'utilisation de l'esperluette «&amp;» pour obtenir l'adresse de l'emplacement d'une variable n'est pas nouvelle, d'autres langues utilisent également cet opérateur. </font><font style="vertical-align: inherit;">La sortie de la ligne 09 devrait ressembler à la sortie ci-dessous si vous exécutez du code sur une architecture 32 bits telle que Go Playground: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 3:</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appel de fonction</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, sur la ligne 12, la fonction principale appelle la fonction d'incrémentation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 4:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">12</span>    increment(count)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faire un appel de fonction signifie que le programme doit créer une nouvelle section de mémoire sur la pile. Cependant, tout est un peu plus compliqué. Pour réussir un appel de fonction, il est prévu que les données soient transférées à travers la limite de trame et placées dans une nouvelle trame pendant la transition. En particulier, une valeur entière devrait être copiée et transmise pendant l'appel. Vous pouvez voir cette exigence en regardant la déclaration de la fonction d'incrémentation à la ligne 18. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 5:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc <span class="hljs-keyword">int</span>)</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous regardez à nouveau l'appel à la fonction d'incrémentation sur la ligne 12, vous verrez que le code passe la «valeur» du nombre de variables. Cette valeur sera copiée, transférée et placée dans un nouveau cadre pour la fonction d'incrémentation. N'oubliez pas que la fonction d'incrémentation ne peut lire et écrire en mémoire que dans sa propre trame, elle a donc besoin de la variable inc pour obtenir, stocker et accéder à sa propre copie de la valeur de compteur transmise. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juste avant que le code à l'intérieur de la fonction d'incrémentation ne commence à s'exécuter, la pile du programme (à un niveau très élevé) ressemblera à ceci: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 2:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2g/jw/n9/2gjwn96mbhikaxys6ftv3cf4s14.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez voir qu'il y a maintenant deux images sur la pile - une pour le principal et une en dessous pour l'incrément. </font><font style="vertical-align: inherit;">À l'intérieur du cadre pour l'incrémentation, vous pouvez voir la variable inc contenant la valeur 10, qui a été copiée et transmise lors de l'appel de fonction. </font><font style="vertical-align: inherit;">L'adresse variable inc est 0x10429f98, et elle est moins en mémoire car les trames sont poussées sur la pile, qui ne sont que des détails d'implémentation qui ne veulent rien dire. </font><font style="vertical-align: inherit;">L'important est que le programme récupère la valeur de comptage dans le cadre pour principal et place une copie de cette valeur dans le cadre pour augmenter à l'aide de la variable inc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le reste du code à l'intérieur incrémente incrémente et affiche la "valeur" et l '"adresse" de la variable inc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 6:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">21</span>    inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La sortie de la ligne 22 dans la cour de récréation devrait ressembler à ceci: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 7:</font></font><br>
<br>
<pre><code class="go hljs">inc:    Value Of[ <span class="hljs-number">11</span> ]  Addr Of[ <span class="hljs-number">0x10429f98</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici à quoi ressemble la pile après avoir exécuté les mêmes lignes de code: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/59/1o/kv/591okvkseze5gjqum4k8hp-qv34.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir exécuté les lignes 21 et 22, la fonction d'incrémentation se termine et renvoie le contrôle à la fonction principale. </font><font style="vertical-align: inherit;">Ensuite, la fonction principale affiche à nouveau la "valeur" et l '"adresse" du nombre de variables locales sur la ligne 14. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 8:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>,count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La sortie complète du programme dans la cour de récréation devrait ressembler à ceci: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 9:</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]<font></font>
inc:    Value Of[ <span class="hljs-number">11</span> ]  Addr Of[ <span class="hljs-number">0x10429f98</span> ]<font></font>
count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La valeur de comptage dans la trame pour principal est la même avant et après l'appel à l'incrémentation.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retour des fonctions</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qu'arrive-t-il réellement à la mémoire de la pile lorsque la fonction se termine et que le contrôle revient à la fonction appelante? La réponse courte n'est rien. Voici à quoi ressemble la pile après le retour de la fonction d'incrémentation: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 4: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qq/ve/-n/qqve-nygmg0jnhsnwrubpchwfky.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La pile ressemble exactement à la figure 3, sauf que la trame associée à la fonction d'incrémentation est désormais considérée comme une mémoire non valide. Cela est dû au fait que le cadre principal est maintenant actif. La mémoire créée pour la fonction d'incrémentation est restée intacte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'effacement de la trame mémoire de la fonction de retour sera une perte de temps, car on ne sait pas si cette mémoire sera à nouveau nécessaire. </font><font style="vertical-align: inherit;">Le souvenir est donc resté tel qu'il était. </font><font style="vertical-align: inherit;">Lors de chaque appel de fonction, lorsqu'une trame est prise, la mémoire de pile de cette trame est effacée. </font><font style="vertical-align: inherit;">Cela se fait en initialisant toutes les valeurs qui correspondent au cadre. </font><font style="vertical-align: inherit;">Étant donné que toutes les valeurs sont initialisées comme leur "valeur zéro", les piles sont correctement effacées à chaque appel de fonction.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partage de valeur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et s'il était important que la fonction d'incrémentation fonctionne directement avec la variable de comptage qui existe à l'intérieur du cadre pour principal? </font><font style="vertical-align: inherit;">C'est ici que vient le temps des pointeurs. </font><font style="vertical-align: inherit;">Les pointeurs ont un objectif: partager une valeur avec une fonction afin que la fonction puisse lire et écrire cette valeur, même si la valeur n'existe pas directement dans son cadre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous ne pensez pas que vous devez «partager» la valeur, vous n'avez pas besoin d'utiliser un pointeur. </font><font style="vertical-align: inherit;">Lors de l'apprentissage des pointeurs, il est important de penser que l'utilisation d'un dictionnaire propre, et non d'opérateurs ou de syntaxe. </font><font style="vertical-align: inherit;">N'oubliez pas que les pointeurs sont destinés à être partagés et lorsque vous lisez le code, remplacez l'opérateur &amp; par l'expression «partage».</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Types de pointeurs</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour chaque type que vous avez déclaré ou qui a été déclaré directement par la langue elle-même, vous obtenez un type de pointeur gratuit que vous pouvez utiliser pour le partage. Il existe déjà un type intégré appelé int, il existe donc un type de pointeur nommé * int. Si vous déclarez un type nommé User, vous obtenez gratuitement un type de pointeur nommé * User. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tous les types de pointeurs ont deux caractéristiques identiques. Tout d'abord, ils commencent par le caractère *. Deuxièmement, ils ont tous la même taille en mémoire et une représentation occupant 4 ou 8 octets qui représentent l'adresse. Sur les architectures 32 bits (par exemple, dans la cour de récréation), les pointeurs nécessitent 4 octets de mémoire et sur les architectures 64 bits (par exemple, votre ordinateur), ils nécessitent 8 octets de mémoire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la spécification, les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">types de pointeurs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont considérés comme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des littéraux de type</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui signifie qu'il s'agit de types sans nom composés d'un type existant.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accès mémoire indirect</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardez ce petit programme qui fait un appel de fonction, en passant l'adresse "par valeur". </font><font style="vertical-align: inherit;">Cela séparera la variable de comptage du cadre de pile de main avec la fonction d'incrémentation: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 10:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">04</span>
<span class="hljs-number">05</span>    <span class="hljs-comment">// Declare variable of type int with a value of 10.</span>
<span class="hljs-number">06</span>    count := <span class="hljs-number">10</span>
<span class="hljs-number">07</span>
<span class="hljs-number">08</span>    <span class="hljs-comment">// Display the "value of" and "address of" count.</span>
<span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\t\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">10</span>
<span class="hljs-number">11</span>    <span class="hljs-comment">// Pass the "address of" count.</span>
<span class="hljs-number">12</span>    increment(&amp;count)
<span class="hljs-number">13</span>
<span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\t\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">15</span> }
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc *<span class="hljs-keyword">int</span>)</span></span> {
<span class="hljs-number">19</span>
<span class="hljs-number">20</span>    <span class="hljs-comment">// Increment the "value of" count that the "pointer points to". (dereferencing)</span>
<span class="hljs-number">21</span>    *inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]\tValue Points To["</span>, *inc, <span class="hljs-string">"]"</span>)
<span class="hljs-number">23</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trois modifications intéressantes ont été apportées au programme d'origine. </font><font style="vertical-align: inherit;">Le premier changement est à la ligne 12: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 11:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">12</span>    increment(&amp;count)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette fois, à la ligne 12, le code ne copie pas et transmet la "valeur" à la variable de comptage, mais transmet son "adresse" au lieu de la variable de comptage. Vous pouvez maintenant dire: «Je partage» le nombre de variables avec l'incrément de fonction. C'est ce que dit l'opérateur &amp; - «partager». </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sachez qu'il s'agit toujours de «passage par valeur» et que la seule différence est que la valeur que vous passez est l'adresse, pas l'entier. Les adresses sont également des valeurs; c'est ce qui est copié et passé à travers la bordure du cadre pour appeler la fonction. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que la valeur d'adresse est copiée et transmise, vous avez besoin d'une variable à l'intérieur du cadre d'incrémentation pour obtenir et enregistrer cette adresse entière. Une déclaration de variable de pointeur entier est à la ligne 18. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 12:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc *<span class="hljs-keyword">int</span>)</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous avez transmis l'adresse de la valeur de type User, alors la variable devra être déclarée comme * User. Malgré le fait que toutes les variables de pointeur stockent des valeurs d'adresse, aucune adresse ne peut leur être transmise, uniquement les adresses associées au type de pointeur. Le principe de base du partage d'une valeur est que la fonction de réception doit lire ou écrire sur cette valeur. Vous avez besoin d'informations sur le type de n'importe quelle valeur pour y lire et y écrire. Le compilateur s'assurera que seules les valeurs associées au type de pointeur correct sont utilisées avec cette fonction. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici à quoi ressemble la pile après avoir appelé la fonction d'incrémentation: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 5:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uk/ak/zj/ukakzj1mpr_9m3thjmv2i04e_hw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La figure 5 montre à quoi ressemble la pile lorsque le "passage par valeur" est effectué en utilisant l'adresse comme valeur. La variable de pointeur à l'intérieur du cadre pour la fonction d'incrémentation pointe désormais vers la variable de comptage, qui est située à l'intérieur du cadre pour principal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, en utilisant la variable pointeur, la fonction peut effectuer une opération indirecte de lecture et de modification pour la variable count située à l'intérieur du cadre pour main. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 13:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">21</span>    *inc++</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette fois, le caractère * agit comme un opérateur et est appliqué à la variable pointeur. L'utilisation de * comme opérateur signifie "la valeur vers laquelle pointe le pointeur". Une variable pointeur fournit un accès indirect à la mémoire en dehors du cadre de la fonction qui l'utilise. Parfois, cette lecture ou écriture indirecte est appelée déréférencement de pointeur. La fonction d'incrémentation doit toujours avoir une variable pointeur dans sa trame, qu'elle peut lire directement pour effectuer un accès indirect. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La figure 6 montre à quoi ressemble la pile après la ligne 21. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 6: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rn/ph/vi/rnphvi1x69rrhspljslmvxilauq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici la sortie finale de ce programme: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 14:</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]              Addr Of[ <span class="hljs-number">0x10429fa4</span> ]<font></font>
inc:    Value Of[ <span class="hljs-number">0x10429fa4</span> ]      Addr Of[ <span class="hljs-number">0x10429f98</span> ]   Value Points To[ <span class="hljs-number">11</span> ]<font></font>
count:  Value Of[ <span class="hljs-number">11</span> ]              Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez remarquer que la «valeur» de la variable de pointeur inc correspond à «l'adresse» de la variable de comptage. </font><font style="vertical-align: inherit;">Cela établit une relation de partage qui a permis un accès indirect à la mémoire en dehors de la trame. </font><font style="vertical-align: inherit;">Dès que la fonction d'incrémentation écrit à travers le pointeur, le changement est visible pour la fonction principale lorsque le contrôle lui est retourné.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les variables de pointeur ne sont pas spéciales</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les variables de pointeur ne sont pas spéciales car ce sont les mêmes variables que toute autre variable. </font><font style="vertical-align: inherit;">Ils ont une allocation de mémoire et contiennent du sens. </font><font style="vertical-align: inherit;">Il se trouve que toutes les variables de pointeur, quel que soit le type de valeur vers lequel elles peuvent pointer, ont toujours la même taille et la même présentation. </font><font style="vertical-align: inherit;">Ce qui peut être déroutant, c'est que le caractère * agit comme un opérateur dans le code et est utilisé pour déclarer un type de pointeur. </font><font style="vertical-align: inherit;">Si vous pouvez distinguer une déclaration de type d'une opération de pointeur, cela peut aider à éliminer une certaine confusion.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce message décrit le but des pointeurs, le fonctionnement de la pile et la mécanique des pointeurs dans Go. </font><font style="vertical-align: inherit;">Il s'agit de la première étape de la compréhension de la mécanique, des principes de conception et des techniques d'utilisation nécessaires pour écrire du code cohérent et lisible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au final, voici ce que vous avez appris:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les fonctions sont exécutées dans les limites de la trame, qui fournissent un espace mémoire séparé pour chaque fonction correspondante.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsqu'une fonction est appelée, une transition entre deux trames se produit.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'avantage de la transmission de données «par valeur» est la lisibilité.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La pile est importante car elle fournit un espace mémoire physique pour les limites de trame qui sont données à chaque fonction individuelle.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toute la mémoire de la pile sous la trame active n'est pas valide, mais la mémoire de la trame active et au-dessus est valide.</font></font></li>
<li>   ,         .</li>
<li>    ,   ,      .</li>
<li>    —    ,        ,         .</li>
<li>   ,  ,   ,     ,      .</li>
<li>-          ,   .</li>
<li>-   - ,      ,     .     ,    .</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr496832/index.html">Visite photo: que font-ils dans le laboratoire de nanophotonique hybride et d'optoélectronique du New Physics Institute ITMO</a></li>
<li><a href="../fr496836/index.html">QSerializer: solution pour une sérialisation JSON / XML simple</a></li>
<li><a href="../fr496838/index.html">Méthodologie de déploiement de projet utilisée par Slack</a></li>
<li><a href="../fr496840/index.html">Musk pense que 12 000 satellites n'interféreront pas avec les astronomes. Son opinion n'est pas conforme au modèle</a></li>
<li><a href="../fr496842/index.html">Un modèle épidémique simple avec des outils de base Python</a></li>
<li><a href="../fr496848/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 340 (du 6 au 12 avril)</a></li>
<li><a href="../fr496850/index.html">Plugin Maven pour JPackage de Java 14</a></li>
<li><a href="../fr496852/index.html">Tri en douceur</a></li>
<li><a href="../fr496856/index.html">Maison intelligente sans télécommandes, mais avec un cube</a></li>
<li><a href="../fr496858/index.html">FOSS News n ° 11 - une revue des logiciels libres et open source du 6 au 12 avril 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>