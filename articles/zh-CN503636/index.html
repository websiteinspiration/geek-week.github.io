<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤬 👋🏼 👌 服务器上什么样的负载会形成网络机制？ 🈁 🚞 🚣🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在分析服务器的网络子系统的操作时，通常会注意诸如延迟，系统吞吐量和每秒可处理的数据包数量（PPS，每秒数据包）等指标。使用这些指标是为了了解所研究的计算机可以在最大负载下工作。而且，尽管这些指标很重要，并且通常可以说出很多关于系统的信息，但它们并未提供有关网络数据包处理对服务器上运行的程序有何影响的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>服务器上什么样的负载会形成网络机制？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/503636/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在分析服务器的网络子系统的操作时，通常会注意诸如延迟，系统吞吐量和每秒可处理的数据包数量（PPS，每秒数据包）等指标。使用这些指标是为了了解所研究的计算机可以在最大负载下工作。而且，尽管这些指标很重要，并且通常可以说出很多关于系统的信息，但它们并未提供有关网络数据包处理对服务器上运行的程序有何影响的信息。</font><font style="vertical-align: inherit;">
该材料旨在研究服务器上网络机制所产生的负载。特别是，我们将讨论网络问题解决方案可以从Linux系统上运行的各种进程“窃取”多少处理器时间。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/q_/0y/ya/q_0yyareydlakrio4dbunpbt8fu.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux上的网络数据包处理</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在处理相应的IRQ时，Linux在处理器执行的任何处理的上下文中处理大量数据包。</font><font style="vertical-align: inherit;">系统记帐引擎会将用于此目的的处理器周期分配给当前正在执行的任何进程。</font><font style="vertical-align: inherit;">即使此过程与网络数据包处理无关，也将执行此操作。</font><font style="vertical-align: inherit;">例如，一条命令</font></font><code>top</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能表明一个进程似乎正在使用超过99％的处理器资源，但实际上60％的处理器时间将花费在处理数据包上。</font><font style="vertical-align: inherit;">这意味着进程本身解决了自己的问题，仅使用40％的CPU资源。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入站处理程序</font></font><code>net_rx_action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常执行得非常非常快。例如，小于25μs。 （此数据来自使用eBPF进行的测量。如果您对详细信息感兴趣，请单击</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a> <code>net_rx_action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。）在将任务推迟到另一个SoftIRQ周期之前，处理器每个NAPI实例（NIC或RPS）最多可以处理64个数据包。可以不间断地接连进行多达10个SoftIRQ周期，这大约需要2毫秒（您可以通过阅读about来了解更多信息</font></font><code>__do_softirq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。如果在经过最大周期数或时间之后，SoftIRQ向量仍然存在未解决的问题，则这些问题的解决方案将延迟在线程中执行</font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定的CPU。</font><font style="vertical-align: inherit;">发生这种情况时，从获取有关网络操作产生的处理器负载的信息的意义上讲，该系统变得更加透明（尽管这种分析是在假设研究的是SoftIRQ的情况下进行的，它与数据包处理有关，与其他无关）。 。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
获得上述指标的一种方法是使用</font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="plaintext hljs">sudo perf record -a \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:irq_handler_entry,irq:irq_handler_exit<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:softirq_entry --filter="vec == 3" \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:softirq_exit --filter="vec == 3"&nbsp; \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e napi:napi_poll \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- sleep 1<font></font>
<font></font>
sudo perf script<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果如下：</font></font><br>
<br>
<pre><code class="plaintext hljs">swapper &nbsp; &nbsp; 0 [005] 176146.491879: irq:irq_handler_entry: irq=152 name=mlx5_comp2@pci:0000:d8:00.0<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491880:&nbsp; irq:irq_handler_exit: irq=152 ret=handled<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491880: &nbsp; &nbsp; irq:softirq_entry: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491942:&nbsp; &nbsp; &nbsp; &nbsp; napi:napi_poll: napi poll on napi struct 0xffff9d3d53863e88 for device eth0 work 64 budget 64<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491943:&nbsp; &nbsp; &nbsp; irq:softirq_exit: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491943: &nbsp; &nbsp; irq:softirq_entry: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491971:&nbsp; &nbsp; &nbsp; &nbsp; napi:napi_poll: napi poll on napi struct 0xffff9d3d53863e88 for device eth0 work 27 budget 64<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491971:&nbsp; &nbsp; &nbsp; irq:softirq_exit: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.492200: irq:irq_handler_entry: irq=152 name=mlx5_comp2@pci:0000:d8:00.0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，处理器处于空闲状态（因此会出现</font></font><code>swapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该进程</font><font style="vertical-align: inherit;">的条目</font><font style="vertical-align: inherit;">），在CPU 5上为Rx队列调用IRQ，两次调用SoftIRQ处理，首先处理64个数据包，然后处理27个。在229μs之后调用下一个IRQ，然后重新开始循环。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该数据是在空闲系统上获得的。但是在处理器上，可以执行任何任务。在这种情况下，将发生上述事件序列，从而中断此任务并执行IRQ / SoftIRQ任务。同时，系统计费将中断进程归因于处理器所创建的负载。结果，通常对常规处理器负载监视工具隐藏网络分组处理任务。它们是在“受害者程序”的背景下，在一些随机选择的过程中执行的。这使我们提出了一些问题。如何估计处理数据包过程中断的时间？如何比较两种不同的网络解决方案，以了解它们对计算机上解决的各种任务的影响较小？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当使用RSS，RPS，RFS机制时，数据包处理通常分布在处理器内核之间。</font><font style="vertical-align: inherit;">因此，上述分组处理序列与每个特定CPU有关。</font><font style="vertical-align: inherit;">随着数据包到达率的提高（我认为我们可以谈论每秒100,000个数据包以及更高的速度），每个CPU每秒必须处理数千或数万个数据包。</font><font style="vertical-align: inherit;">处理如此多的数据包将不可避免地影响服务器上执行的其他任务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑一种评估这种效果的方法。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">禁用分布式数据包处理</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，让我们通过禁用RPS并设置流控制规则来停止数据包的分布式处理，该规则旨在组织对我们已知的唯一CPU上与特定MAC地址有关的所有数据包的处理。</font><font style="vertical-align: inherit;">我的系统在802.3ad配置中聚合了2个NIC。</font><font style="vertical-align: inherit;">网络任务被分配给计算机上运行的单个虚拟机。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
网络适​​配器上的RPS禁用如下：</font></font><br>
<br>
<pre><code class="plaintext hljs">for d in eth0 eth1; do<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;find /sys/class/net/${d}/queues -name rps_cpus |<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;while read f; do<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 0 | sudo tee ${f}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;done<font></font>
done<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，我们设置流控制规则以确保数据包进入使用单个CPU的测试虚拟机：</font></font><br>
<br>
<pre><code class="plaintext hljs">DMAC=12:34:de:ad:ca:fe<font></font>
sudo ethtool -N eth0 flow-type ether dst ${DMAC} action 2<font></font>
sudo ethtool -N eth1 flow-type ether dst ${DMAC} action 2<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
禁用RPS并使用流控制规则使我们能够确保所有发往虚拟机的数据包都在同一CPU上处理。</font><font style="vertical-align: inherit;">为了确保将数据包发送到应将其发送到的队列，可以使用类似</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ethq</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的命令</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后，您可以使用找出此队列属于哪个CPU </font></font><code>/proc/interrupts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在我的情况下，通过CPU 5处理转弯2。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenSSL速度命令</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我可以使用实用程序</font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font><font style="vertical-align: inherit;">分析负责处理传入流量的SoftIRQ运行时</font></font><code>bpf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是这种方法非常复杂。另外，观察过程本身肯定会影响结果。一种更简单，更易理解的解决方案是使用某些任务来识别由网络操作对系统造成的负载，该任务会在系统上造成已知负载。例如，这是</font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于测试OpenSSL性能</font><font style="vertical-align: inherit;">的命令</font><font style="vertical-align: inherit;">。这将使您找出程序实际获得了多少处理器资源，并将其与应该接收的资源量进行比较（这将有助于找出在网络任务上花费了多少资源）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该团队</font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几乎</font><font style="vertical-align: inherit;">是</font><font style="vertical-align: inherit;">100％的用户空间团队。如果将其绑定到某个CPU，则在执行测试期间，它将使用其所有可用资源。该团队的工作方式是将计时器设置为指定的时间间隔（例如，为了使计算更容易，需要10秒），运行测试，然后在触发计时器时使用</font></font><code>times</code><code>()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它来找出程序实际获得了多少处理器时间。从角度来看，</font></font><code>syscall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它看起来像这样：</font></font><br>
<br>
<pre><code class="plaintext hljs">alarm(10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0<font></font>
times({tms_utime=0, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726601344<font></font>
--- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL} ---<font></font>
rt_sigaction(SIGALRM, ...) = 0<font></font>
rt_sigreturn({mask=[]}) = 2782545353<font></font>
times({tms_utime=1000, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726602344<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也就是说，事实证明，在调用</font></font><code>alarm()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和检查结果</font><font style="vertical-align: inherit;">之间</font><font style="vertical-align: inherit;">很少进行系统调用。如果程序没有被中断，或者中断很少，那么时间</font></font><code>tms_utime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将与测试时间一致（在这种情况下为10秒）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于这是一项仅在用户空间中执行的测试，因此出现的任何系统时间</font></font><code>times()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都将对系统造成额外的负担。事实证明，尽管</font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个在CPU上运行的进程，但CPU本身可能正忙于其他事情。例如，处理网络数据包：</font></font><br>
<br>
<pre><code class="plaintext hljs">alarm(10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0<font></font>
times({tms_utime=0, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726617896<font></font>
--- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL} ---<font></font>
rt_sigaction(SIGALRM, ...) = 0<font></font>
rt_sigreturn({mask=[]}) = 4079301579<font></font>
times({tms_utime=178, tms_stime=571, tms_cutime=0, tms_cstime=0}) = 1726618896<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里您可以看到</font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以在处理器上工作7.49秒（178 + 571，以0.01 s为单位的测量单位）。</font><font style="vertical-align: inherit;">但同时5.71秒。</font><font style="vertical-align: inherit;">此间隔由系统时间表示。</font><font style="vertical-align: inherit;">由于他</font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不忙于内核空间的任何事务，因此这意味着5.71秒。</font><font style="vertical-align: inherit;">-这是系统上一些额外负载的结果。</font><font style="vertical-align: inherit;">也就是说，这是为了满足系统需求而“窃取”进程的时间。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用openssl speed命令检测由网络机制引起的系统负载</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们已经弄清了团队的工作方式</font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们将看看它在几乎不活动的服务器上产生的结果：</font></font><br>
<br>
<pre><code class="plaintext hljs">$ taskset -c 5 openssl speed -seconds 10 aes-256-cbc &gt;/dev/null<font></font>
Doing aes-256 cbc for 10s on 16 size blocks: 66675623 aes-256 cbc's in 9.99s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 18096647 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 4607752 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 1162429 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 145251 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 72831 aes-256 cbc's in 10.00s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，我们被告知该程序花费9.99到10秒来处理不同大小的块。这证实了系统机制不会占用程序的处理器时间。现在，使用</font></font><code>netperf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们将通过处理来自两个来源的数据包来加载服务器。再次运行测试：</font></font><br>
<br>
<pre><code class="plaintext hljs">$ taskset -c 5 openssl speed -seconds 10 aes-256-cbc &gt;/dev/null<font></font>
Doing aes-256 cbc for 10s on 16 size blocks: 12061658 aes-256 cbc's in 1.96s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 3457491 aes-256 cbc's in 2.10s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 893939 aes-256 cbc's in 2.01s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 201756 aes-256 cbc's in 1.86s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 25117 aes-256 cbc's in 1.78s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 13859 aes-256 cbc's in 1.89s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果与在空闲服务器上获得的结果非常不同。预计每个测试将在10秒内执行，但是</font></font><code>times()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">报告实际执行时间为1.78到2.1秒。这意味着在过程的上下文中</font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或中</font><font style="vertical-align: inherit;">，剩余的时间（从7.9到8.22秒不等）花费在处理数据包</font><font style="vertical-align: inherit;">上</font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看一下团队</font></font><code>top</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在分析刚刚完成的发布时</font><font style="vertical-align: inherit;">会给出什么</font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">PID USER&nbsp; &nbsp; &nbsp; PR&nbsp; NI&nbsp; &nbsp; VIRT&nbsp; &nbsp; RES&nbsp; &nbsp; SHR S&nbsp; %CPU %MEM &nbsp; &nbsp; TIME+ COMMAND&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P&nbsp;<font></font>
&nbsp;8180 libvirt+&nbsp; 20 &nbsp; 0 33.269g 1.649g 1.565g S 279.9&nbsp; 0.9&nbsp; 18:57.81 qemu-system-x86 &nbsp; &nbsp; 75<font></font>
&nbsp;8374 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 99.4&nbsp; 0.0 &nbsp; 2:57.97 vhost-8180&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 89<font></font>
&nbsp;1684 dahern&nbsp; &nbsp; 20 &nbsp; 0 &nbsp; 17112 &nbsp; 4400 &nbsp; 3892 R&nbsp; 73.6&nbsp; 0.0 &nbsp; 0:09.91 openssl&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;38 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 26.2&nbsp; 0.0 &nbsp; 0:31.86 ksoftirqd/5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，您可能会认为它</font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">占用了CPU 5大约73％的资源，而</font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">剩余的资源已获得。</font><font style="vertical-align: inherit;">但是实际上，在上下文中</font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，执行的程序包数量如此之多，以至于程序本身仅占用处理器时间的18-21％即可解决其问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果将网络负载减少到1个流，您</font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会</font><font style="vertical-align: inherit;">感觉到</font><font style="vertical-align: inherit;">99％的系统资源已被消耗。</font></font><br>
<br>
<pre><code class="plaintext hljs">&nbsp;&nbsp;PID USER&nbsp; &nbsp; &nbsp; PR&nbsp; NI&nbsp; &nbsp; VIRT&nbsp; &nbsp; RES&nbsp; &nbsp; SHR S&nbsp; %CPU %MEM &nbsp; &nbsp; TIME+ COMMAND&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P<font></font>
&nbsp;8180 libvirt+&nbsp; 20 &nbsp; 0 33.269g 1.722g 1.637g S 325.1&nbsp; 0.9 166:38.12 qemu-system-x86 &nbsp; &nbsp; 29<font></font>
44218 dahern&nbsp; &nbsp; 20 &nbsp; 0 &nbsp; 17112 &nbsp; 4488 &nbsp; 3996 R&nbsp; 99.2&nbsp; 0.0 &nbsp; 0:28.55 openssl&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
&nbsp;8374 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 64.7&nbsp; 0.0&nbsp; 60:40.50 vhost-8180&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 55<font></font>
&nbsp;&nbsp;&nbsp;38 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 S &nbsp; 1.0&nbsp; 0.0 &nbsp; 4:51.98 ksoftirqd/5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但实际上，事实证明，在用户空间中运行的程序在预期的10秒中只有大约4秒：</font></font><br>
<br>
<pre><code class="plaintext hljs">Doing aes-256 cbc for 10s on 16 size blocks: 26596388 aes-256 cbc's in 4.01s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 7137481 aes-256 cbc's in 4.14s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 1844565 aes-256 cbc's in 4.31s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 472687 aes-256 cbc's in 4.28s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 59001 aes-256 cbc's in 4.46s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 28569 aes-256 cbc's in 4.16s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
传统的进程监视工具表明该程序几乎使用了所有处理器资源，但实际上，事实证明，有55-80％的CPU资源用于处理网络数据包。</font><font style="vertical-align: inherit;">同时，系统的吞吐量看起来很高（每25 Gb / s线超过22 Gb / s），但这对在该系统中运行的进程产生了巨大影响。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们研究了一个示例，该示例说明了数据包处理机制如何从一个简单但不太重要的基准中“窃取”处理器时钟。</font><font style="vertical-align: inherit;">但是在真实服务器上，受到类似影响的进程可以是任何东西。</font><font style="vertical-align: inherit;">这些可以是虚拟机的虚拟处理器，仿真器线程，虚拟主机线程。</font><font style="vertical-align: inherit;">这些可能是不同的系统过程，对其的影响可能会对这些过程和整个系统的性能产生不同的影响。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您是否在分析服务器时考虑了与网络操作相关的负载对其实际性能的影响？</font></font></b><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/a_/bs/aa/a_bsaactpbr8fltzymtkhqbw1d4.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN503624/index.html">上周第416期（2020年5月18日至24日）来自前端世界的新鲜材料摘要</a></li>
<li><a href="../zh-CN503626/index.html">测试。ISTQB认证错误或解决了百万个示例</a></li>
<li><a href="../zh-CN503630/index.html">增强现实眼镜：我们现在在哪里？</a></li>
<li><a href="../zh-CN503632/index.html">1000和1个帖子：生日快乐，哈伯❤</a></li>
<li><a href="../zh-CN503634/index.html">在Vue源代码中发现5个有趣的JavaScript</a></li>
<li><a href="../zh-CN503638/index.html">令人惊讶的是，只有少数程序员拥有6个有用的习惯</a></li>
<li><a href="../zh-CN503642/index.html">如何在硅谷使用LinkedIn，Facebook，Google</a></li>
<li><a href="../zh-CN503648/index.html">“ ss -s”的输出是什么意思</a></li>
<li><a href="../zh-CN503650/index.html">VKCup 2020第一阶段</a></li>
<li><a href="../zh-CN503652/index.html">5月25日至5月31日在莫斯科举行的数字活动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>