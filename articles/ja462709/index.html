<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📈 👈🏿 🧑🏽‍🤝‍🧑🏼 PHPでの変異テスト：コードカバレッジの定性的測定 🤙🏼 😏 👈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="テストの品質を評価するには？多くの人は、誰もが知っている最も人気のあるメトリック、つまりコードカバレッジに依存しています。ただし、これは量的指標であり、質的指標ではありません。これは、テストでカバーされているコードの量を示しますが、これらのテストがどの程度適切に記述されているかは示しません。 
 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PHPでの変異テスト：コードカバレッジの定性的測定</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/462709/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストの品質を評価するには？</font><font style="vertical-align: inherit;">多くの人は、誰もが知っている最も人気のあるメトリック、つまりコードカバレッジに依存しています。</font><font style="vertical-align: inherit;">ただし、これは量的指標であり、質的指標ではありません。</font><font style="vertical-align: inherit;">これは、テストでカバーされているコードの量を示しますが、これらのテストがどの程度適切に記述されているかは示しません。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを理解する1つの方法は、突然変異テストです。</font><font style="vertical-align: inherit;">このツールは、ソースコードに小さな変更を加え、その後テストを再実行することで、役に立たないテストと低品質のカバレッジを特定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
で、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">月内のBadoo PHPミートアップ、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私はあなたが発生する可能性のあるPHPコードとどのような問題のための突然変異の試験を整理する方法について話しました。</font><font style="vertical-align: inherit;">ビデオは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から</font><font style="vertical-align: inherit;">入手でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。テキスト版については、猫へようこそ。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qc/xz/fi/qcxzfinlil5-p8zjwtafifv2mqu.jpeg"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変異検査とは</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
意味を説明するために、いくつかの例を示します。それらは単純で、場所によっては誇張されており、明白に見える場合があります（ただし、実際の例は通常非常に複雑で、目で見ることはできません）。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状況を考えてみましょう。私たちは大人であると主張する基本的な機能を持っていて、それをテストするテストがあります。テストにはdataProviderがあります。つまり、17歳と19歳の2つのケースをテストします。 isAdultが100％カバーしていることは、多くの人にとって明らかだと思います。唯一の行。テストで行います。すべてが素晴らしいです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/w2/qq/ag/w2qqagnuajffn5ubmkgwnbsubpg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、よく調べてみると、プロバイダーの記述が不十分であり、境界条件をテストしていないことがわかります。18歳は境界条件としてテストされていません。 &gt;記号を&gt; =に置き換えることができ、テストはそのような変更をキャッチしません。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の例、もう少し複雑。セッターとゲッターを含む単純なオブジェクトを作成する関数があります。設定するフィールドは3つあり、buildPromoBlock関数が期待するオブジェクトを実際に収集することを確認するテストがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/a6/mr/eq/a6mreqjphzfwflq35qxf5skwfle.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
よく見ると、いくつかのプロパティをtrueに設定するsetSomethingもあります。しかし、テストではそのような主張はありません。つまり、この行をbuildPromoBlockから削除できます。テストではこの変更をキャッチしません。同時に、3つの行すべてがテスト中に実行されたため、buildPromoBlock関数のカバレッジは100％です。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの2つの例は、突然変異テストとは何かを示しています。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムを分解する前に、簡単に定義します。変異テストは、コードに小さな変更を加えることで、意図的にそれを壊し始めた悪意のあるピノキオまたはジュニアヴァシャのアクションを模倣できるメカニズムです。&gt;記号を&lt;、= by！=などに置き換えます。適切な目的で行うこのような変更ごとに、変更された行をカバーするテストを実行します。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストで何も表示されなかった場合、または落下しなかった場合は、おそらく十分に効果的ではありません。それらは境界ケースをテストせず、アサーションを含みません：おそらくそれらは改善される必要があります。テストが落ちる場合、それらはクールです。彼らはそのような変化から本当に守ります。したがって、コードを解読するのはより困難です。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、アルゴリズムを分析しましょう。とても簡単です。ミューテーションテストを実行するために最初に行うことは、ソースコードを取得することです。次に、コードカバレッジを取得して、どの文字列に対してどのテストを実行するかを確認します。その後、ソースコードを調べて、いわゆるミュータントを生成します。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ミュータントは単一のコード変更です。つまり、比較で&gt;記号があった特定の関数を使用し、もしこの記号を&gt; =-に変更すると、変異体が得られます。その後、テストを実行します。突然変異の例を次に示します（&gt;を&gt;&gt;に置き換えました）。&nbsp; </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tu/fe/rm/tufermumemlipcqjluus2h-bzmm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、突然変異はランダムに行われるのではなく、特定のルールに従って行われます。突然変異テスト応答はべき等です。同じコードでミューテーションテストを何度実行しても、同じ結果が得られます。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、変更された行をカバーするテストを実行します。</font><font style="vertical-align: inherit;">対象外にしてください。</font><font style="vertical-align: inherit;">すべてのテストを実行する最適ではないツールがあります。</font><font style="vertical-align: inherit;">しかし、優れたツールは必要なものだけを追い払うでしょう。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、結果を評価します。</font><font style="vertical-align: inherit;">テストが落ちた-その後、すべてが正常です。</font><font style="vertical-align: inherit;">それらが落下しなかった場合、それらは非常に効果的ではありません。&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指標&nbsp;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変異テストはどのような指標を提供しますか？これにより、コードカバレッジがさらに3つ追加されます。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、最初に、用語を分析しましょう。&nbsp; </font></font><br>
<br>
<img width="400" src="https://habrastorage.org/webt/_6/pu/yz/_6puyzoefm_yith6s0ep8yzwqao.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
殺されたミュータントの概念があります。これらは、私たちのテストが「釘付け」したミュータントです（つまり、彼らはそれらをキャッチしました）。&nbsp; </font></font><br>
<br>
<img width="400" src="https://habrastorage.org/webt/3b/7o/it/3b7oitf-byu91zv3jbooogylvna.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エスケープされたミュータント（生き残ったミュータント）の概念があります。これらは、何とか罰を避けたミュータントです（つまり、テストはそれらをキャッチしませんでした）。&nbsp; </font></font><br>
<br>
<img width="400" src="https://habrastorage.org/webt/dw/8a/ye/dw8ayeaxuwut_6rcbdchfdm0cfg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、カバードミュータント-テストでカバーされたミュータントと、その反対のカバーされていないミュータントの概念があり、どのテストでもまったくカバーされていません（つまり、コードがあり、ビジネスロジックがあり、変更できますが、単一のテストはできません）変更をチェックしません）。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
突然変異テストによって得られる主な指標は、MSI（突然変異スコアインジケーター）です。これは、殺された突然変異体の総数とその総数の比率です。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の指標は、ミューテーションコードカバレッジです。</font><font style="vertical-align: inherit;">これは、定量的ではなく、単に定性的なものです。定期的に実行して実行できるビジネスロジックの量を示しているため、テストがキャッチされます。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後の指標はMSI、つまりよりソフトなMSIです。</font><font style="vertical-align: inherit;">この場合、テストでカバーされたミュータントについてのみMSIを計算します。&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">突然変異テストの問題</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜプログラマーの半分未満がこのツールについて聞いたのですか？</font><font style="vertical-align: inherit;">なぜそれがどこでも使用されていないのですか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">低速&nbsp;</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の問題（主な問題の1つ）は、突然変異テストの速度です。コードでは、最も単純なクラスであっても、何十もの突然変異演算子がある場合、何百もの突然変異を生成できます。ミューテーションごとに、テストを実行する必要があります。たとえば、5,000の単体テストを10分間実行した場合、変異テストには数時間かかることがあります。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを平準化するために何ができますか？複数のスレッドでテストを並行して実行します。複数の車にストリームを投げます。できます。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の方法は、増分実行です。毎回ブランチ全体の変異指標をカウントする必要はありません-ブランチの差分を取ることができます。機能ブランチを使用する場合、これを行うのは簡単です。変更されたファイルに対してのみテストを実行し、ウィザードで何が行われているかを確認し、比較、分析します。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次にできることは、ミューテーションチューニングです。ミューテーション演算子は変更できるため、それらが機能する特定のルールを設定でき、意図的に問題を引き起こしたミューテーションを停止できます。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要な点：突然変異テストは単体テストにのみ適しています。</font><font style="vertical-align: inherit;">統合テストのために実行できるという事実にもかかわらず、統合（エンドツーエンドのような）テストは実行速度がはるかに遅く、より多くのコードに影響を与えるため、これは明らかに失敗したアイデアです。</font><font style="vertical-align: inherit;">結果を待つことはありません。</font><font style="vertical-align: inherit;">原則として、このメカニズムは単体テスト専用に開発および開発されました。&nbsp;</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンドレスミュータント</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
突然変異テストで発生する可能性のある2番目の問題は、いわゆる無限突然変異体です。たとえば、単純なコード、単純なforループがあり&nbsp; </font></font><br>
<br>
<img src="https://habrastorage.org/webt/no/tr/az/notrazetuv221u41t1g8rfbkmlc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。i++をi--に置き換えると、ループは無限ループになります。あなたのコードは長い間残ります。そして、突然変異テストはそのような突然変異をかなり頻繁に生成します。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初にできることは、ミューテーションチューニングです。明らかに、forループでi ++をi--に変更することは非常に悪い考えです。99％のケースでは、無限ループになります。したがって、ツールでこれを行うことは禁止されています。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような問題からユーザーを保護する2番目の最も重要なことは、実行のタイムアウトです。</font><font style="vertical-align: inherit;">たとえば、同じPHPUnitには、スタックされている場所に関係なく、タイムアウトによってテストを完了する機能があります。</font><font style="vertical-align: inherit;">PCNTLを介したPHPUnitはコールバックを切断し、時間自体を計算します。</font><font style="vertical-align: inherit;">テストが一定期間失敗した場合、それは単にテストを失敗させ、そのようなケースは強制終了ミュータントと見なされます。これは、ミューテーションを生成したコードが実際に問題をキャッチするテストによって実際にチェックされ、コードが機能しなくなったことを示します。&nbsp;</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同一の突然変異体</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題は、突然変異テストの理論に存在します。</font><font style="vertical-align: inherit;">実際には、ほとんど発生しませんが、それについて知っておく必要があります。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それを説明する古典的な例を考えてみましょう。</font><font style="vertical-align: inherit;">変数Aの-1による乗算とAの-1による除算があります。</font><font style="vertical-align: inherit;">一般的なケースでは、これらの演算は同じ結果になります。</font><font style="vertical-align: inherit;">Aの符号を変更します。したがって、2つの符号を相互に変更できる変異があります。</font><font style="vertical-align: inherit;">このような変異によるプログラムの論理は侵害されません。</font><font style="vertical-align: inherit;">テストし、それをキャッチしてはいけません、落ちてはいけません。</font><font style="vertical-align: inherit;">そのような同一の変異体のために、いくつかの困難が生じます。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
普遍的な解決策はありません-誰もが自分の方法でこの問題を解決します。</font><font style="vertical-align: inherit;">おそらく、ある種のミュータント登録システムが役立つでしょう。</font><font style="vertical-align: inherit;">Badooは今、同じようなことを考えています。それらをまねます。&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは理論です。</font><font style="vertical-align: inherit;">PHPはどうですか？&nbsp;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変異検査には2つの有名なツールがあります。HumbugとInfectionです。</font><font style="vertical-align: inherit;">記事を準備しているときに、どちらが優れているかを話し、これが感染であるという結論に達したいと思いました。&nbsp;</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、Humbugのページに行くと、次のことがわかりました。Humbugは、感染を支持して時代遅れであると宣言しました。</font><font style="vertical-align: inherit;">したがって、私の記事の一部は無意味であることが判明しました。</font><font style="vertical-align: inherit;">したがって、感染は本当に良いツールです。</font><font style="vertical-align: inherit;">ありがとうございました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">borNfree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それを作成したミンスクから。それは本当にクールに動作します。箱から直接取り出して、通してから実行できます。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは感染症が本当に好きでした。使いたかった。しかし、2つの理由でできませんでした。感染には、ミュータントのテストを正しく正確に実行するためのコードカバレッジが必要です。ここには2つの方法があります。実行時に直接計算できます（ただし、100,000の単体テストがあります）。または、現在のマスターについて計算することもできます（ただし、いくつかのスレッドで10の非常に強力なマシンのクラウド上でのアセンブリには1時間半かかります）。すべてのミューテーション実行でこれを行うと、ツールはおそらく機能しません。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完成したものをフィードするオプションがありますが、PHPUnit形式では、これは一連のXMLファイルです。それは貴重な情報を含んでいるという事実に加えて、彼らは構造の束、いくつかの括弧と他のものに沿ってドラッグします。一般的に、コードカバレッジの重さは約30 GBであり、それをすべてのクラウドマシンにドラッグし、常にディスクから読み取る必要があると考えました。一般的に、アイデアはまあまあです。&nbsp; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の問題はさらに重大でした。私たちは素晴らしいライブラリ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">SoftMocks</font></a><font style="vertical-align: inherit;">を持っています</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これにより、テストが難しいレガシーコードを処理し、テストを正常に作成できます。 SoftMocksを必要としないように新しいコードを作成しているにもかかわらず、私たちは積極的にそれを使用しており、近い将来にそれを拒否することはありません。したがって、このライブラリはInfectionと互換性がありません。これは、変更の変更にほとんど同じアプローチを使用するためです。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SoftMocksはどのように機能しますか？それらはファイルのインクルードをインターセプトし、変更されたインクルードに置き換えます。つまり、クラスAを実行する代わりに、SoftMocksはクラスAを別の場所に作成し、元の場所ではなく別の場所に接続します。感染は同じように機能しますが、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">stream_wrapper_register（）を</font></a><font style="vertical-align: inherit;">介してのみ機能し</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは同じことを行いますが、システムレベルで行います。その結果、SoftMocksとInfectionのどちらでも機能します。テストにはSoftMocksが必要なので、これら2つのツールを友だちにすることは非常に困難です。これはおそらく可能ですが、この場合、感染症にかかりすぎて、そのような変更の意味が単純に失われます。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
困難を克服して、私たちは小さな楽器を書きました。私たちは、Infectionからミューテーションオペレーターを借りました（これらはクールに記述されており、非常に使いやすくなっています）。 stream_wrapper_register（）を通じてミューテーションを実行する代わりに、SoftMocksを通じてミューテーションを実行します。つまり、ボックスからツールを使用します。私たちのツールザは、内部コードカバレッジサービスの友です。つまり、オンデマンドで、すべてのテストを実行せずに、ファイルまたは行のカバレッジを受け取ることができます。これは非常に迅速に行われます。しかし、それは簡単です。 Infectionにあらゆる種類のツールと機能（たとえば、複数のスレッドで起動する）がたくさんある場合、私たちのツールにはそのようなものはありません。しかし、この欠点を軽減するために内部インフラストラクチャを使用しています。たとえば、クラウドを介して複数のスレッドで同じテストを実行します。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どうやって使うの？&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は手動実行です。これが最初に行うことです。作成したすべてのテストは、変異テストによって手動で検証されます。これは次のようになり&nbsp; </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-5/xc/t1/-5xct1pygkkjfkxsvr8rhcf-rpc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。あるファイルの変異テストを実行しました。結果を得た：16変異体。これらのうち、15人がテストによって殺され、1人がエラーで転落しました。突然変異によって死者が出るとは言わなかった。私たちは何かを簡単に変更できます：戻り値の型を無効にするか、何か他のものにします。私たちのテストが落ち始めるので、それは可能です、それは殺されたミュータントと見なされます。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それにもかかわらず、時々それはエラーに特別な注意を払う価値があるという理由で、感染はそのような変異体を別のカテゴリーに区別します。何か奇妙なことが起こり、ミュータントは殺されたとは正しく考えられていません。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目に使用するのは、マスターに関するレポートです。 1日1回、夜間に、開発インフラストラクチャがアイドル状態のときに、コードカバレッジに関するレポートを生成します。その後、同じ変異検査レポートを作成します。これは次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gf/br/oc/gfbroc92o5cn5xe7a1q3fmwcofm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードカバレッジPHPUnitに関するレポートを少なくとも1度見た場合、私たちのツールを類推して作成したため、インターフェイスが似ていることに気付くでしょう。彼は単に、ディレクトリ内の特定のファイルのすべての主要な指標を計算しました。また、特定の目標を設定しました（実際には、各指標によってどの目標をガイドする必要があるかをまだ決定していないため、上限から除外し、まだ遵守していませんが、将来的にレポートを簡単に作成できるように存在します）。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、最も重要な最後のことは、他の2つの結果です。プログラマーは怠惰な人々です。私は怠惰です。私はすべてが機能するのが好きで、余分なジェスチャーをする必要はありません。開発者が自分のブランチをプッシュすると、自分のブランチとブランチマスターのインジケーターが自動的に増分カウントされるようにしました。&nbsp;</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k2/i6/mu/k2i6murvfrlvwfjx-fklewrj2so.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、2つのファイルを実行して、この結果を得ました。</font><font style="vertical-align: inherit;">マスターでは548のミュータントがあり、400が殺されました別のファイルによると-63に対して147です。私のブランチでは、両方のケースでミュータントの数が増加しました。</font><font style="vertical-align: inherit;">しかし、最初のファイルではミュータントが釘付けになり、2番目のファイルでは彼が脱出した。</font><font style="vertical-align: inherit;">当然、MSI指標は下落した。</font><font style="vertical-align: inherit;">このようなことにより、時間を無駄にしたくない人でも、手で変異テストを実行し、自分の行った結果を確認し、注意を払うことができます（コードレビューのプロセスでレビュー担当者が行うのとまったく同じ方法です）。&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数値を示すことは依然として困難です。指標はありませんでしたが、現在は表示されていますが、比較するものはありません。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
突然変異テストは心理的効果という点で言えます。</font><font style="vertical-align: inherit;">ミューテーションテストを通じてテストを実行し始めると、思わずより優れたテストの作成を開始し、品質テストの作成は必然的にコードの記述方法に変化をもたらします-破ることができるすべてのケースをカバーする必要があると考え始め、それを開始しますより良い構造で、よりテストしやすくします。&nbsp;&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは専ら主観的な意見です。</font><font style="vertical-align: inherit;">しかし、私の同僚の何人かはほぼ同じフィードバックを与えました：彼らが仕事で常に変異テストを使い始めたとき、彼らはテストをよりよく書き始めました、そして多くは彼らがコードをよりよく書き始めたと言いました。&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果&nbsp;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードカバレッジは、監視する必要がある重要なメトリックです。</font><font style="vertical-align: inherit;">しかし、この指標は何も保証しません。それはあなたが安全であるという意味ではありません。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ミューテーションテストはユニットテストを改善するのに役立ち、コードカバレッジの追跡は理にかなっています。</font><font style="vertical-align: inherit;">PHP用のツールはすでにあるので、小さなプロジェクトに問題がなければ、今すぐ入手して試してください。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少なくとも変異テストを手動で実行することから始めます。</font><font style="vertical-align: inherit;">この簡単なステップを踏んで、それが何をもたらすかを見てください。</font><font style="vertical-align: inherit;">きっと気に入ると思います。&nbsp;</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja462699/index.html">サービスメッシュ、「データプレーン」、「コントロールプレーン」（サービスメッシュデータプレーンとコントロールプレーン）</a></li>
<li><a href="../ja462701/index.html">AVRマイクロコントローラー用のアセンブラーコードジェネレーターライブラリ。パート2</a></li>
<li><a href="../ja462703/index.html">スマートフォンから制御されるロシアの「最も安い」回転式改札口</a></li>
<li><a href="../ja462705/index.html">ReactJSアプリケーションの上位5つのバグ</a></li>
<li><a href="../ja462707/index.html">Kubernetesで実行されているアプリケーションの開発者向けのツール</a></li>
<li><a href="../ja462717/index.html">二人の横綱の戦い</a></li>
<li><a href="../ja462723/index.html">TLA +で猫を捕まえる</a></li>
<li><a href="../ja462725/index.html">三角法のトリック</a></li>
<li><a href="../ja462727/index.html">2019年6〜7月のJoomlaダイジェスト</a></li>
<li><a href="../ja462729/index.html">VSBIでのナラティブデザインに関する公開講義の夜</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>