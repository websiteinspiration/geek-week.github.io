<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏐 💩 🥊 完全に私を見て：モバイルプラットフォームでライブビデオを最大限に活用する 🏞️ 👝 👚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="モバイルデバイスでビデオを再生する最も簡単な方法は、システム上の既存のプレーヤーとのリンクを開くことですが、これが常に効果的であるとは限りません。
 
 ExoPlayerを使用して最適化するか、コーデックとソケットのみを使用して独自のビデオプレーヤーを作成することもできます。この記事では、ストリー...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>完全に私を見て：モバイルプラットフォームでライブビデオを最大限に活用する</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/467669/"><img src="https://habrastorage.org/webt/3z/wx/89/3zwx89x0wbx0euzwj3a_f8vttwo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モバイルデバイスでビデオを再生する最も簡単な方法は、システム上の既存のプレーヤーとのリンクを開くことですが、これが常に効果的であるとは限りません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ExoPlayerを使用して最適化するか、コーデックとソケットのみを使用して独自のビデオプレーヤーを作成することもできます。この記事では、ストリーミングとビデオ再生の作業、およびビデオの開始の遅延を減らし、ストリーマーとビューア間の応答時間を減らし、電力消費と鉄の負荷を最適化する方法について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定のアプリケーションの例を見てみましょう。Odnoklassnikiモバイルクライアント（ビデオが再生される場所）とOK Live（ブロードキャストが電話から1080pにストリーミングされる場所）です。</font><font style="vertical-align: inherit;">コード例とともに、参照によるビデオの再生方法に関するマスタークラスはありません。</font><font style="vertical-align: inherit;">ストーリーは、ビデオが内部からどのように見えるか、そしてビデオプレーヤーとビデオストリーミングの一般的なアーキテクチャを理解することで、どのようなシステムも理解し、改善できるかに焦点を当てます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この資料は</font><font style="vertical-align: inherit;">、</font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">メビウス</font></a></b><font style="vertical-align: inherit;">会議から</font><font style="vertical-align: inherit;">の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アレクサンダー</font></font></b><font style="vertical-align: inherit;"></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トボル</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">@alatobol</font></a></b><font style="vertical-align: inherit;">）および</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イヴァングリゴリエフ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@ivan_a</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">の報告の筆記録に基づいてい</font><font style="vertical-align: inherit;">ます。</font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a></b><font style="vertical-align: inherit;"></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/e1JYFRwHzkQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手始めに-Odnoklassnikiのビデオに関するいくつかの数字。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1日あたりのピーク時の平均VODトラフィック（ビデオオンデマンド）は、1秒あたり1.5テラビットを超え、ライブブロードキャストの場合も1秒あたり3テラビットを超えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、OKで1日あたり8億7千万回を超えるビデオビューがあり、その半分以上がモバイルデバイスからのものです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xt/nl/ij/xtnlijaizuntzzpkihtkpi-juws.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリーミングの歴史を見ると、2007年にモバイルビデオがYouTubeに登場しました。後でこの列車に乗りましたが、2014〜2015年にはすでにモバイルデバイスで4Kビデオの再生があり、近年は積極的にプレーヤーの開発を行っています。これと会話についていきます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2015年にペリスコープで発生した2番目の傾向は、電話からの放送でした。</font><font style="vertical-align: inherit;">モバイルネットワーク経由でフルHDビデオをストリーミングできるOKライブアプリケーションをリリースしました。</font><font style="vertical-align: inherit;">資料の後半では、ストリーミングについても話します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオを操作するためのAPIについては説明しませんが、今は深く掘り下げ、内部で何が起こっているのかを調べます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4d/ne/-v/4dne-vlspxhbv3rm3wxixirrc8o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カメラでビデオを撮影すると、コーデック、そこからソケット、サーバー（VODかLiveかに関係なく）に到達します。</font><font style="vertical-align: inherit;">そして、サーバーは逆の順序でそれを聴衆に配布します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
KPIプレーヤーから始めましょう。</font><font style="vertical-align: inherit;">私たちは彼に何を望みますか？</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のフレームが速い。</font><font style="vertical-align: inherit;">ユーザーは再生の開始を待ちたくありません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファリングの欠如。</font><font style="vertical-align: inherit;">誰もが胴体にぶつかることを好まない。</font></font></li>
<li> .  4K-    ,     4K « »:         ,  1080       .</li>
<li>  UX.  ,        ,       .</li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このように多くの問題があります。 4Kビデオのストリームは大きく、ネットワークに問題があるモバイルデバイスに取り組んでいます。ビデオ形式やさまざまなデバイスのコンテナーにはさまざまな機能があり、デバイス自体も問題になる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iOSまたはAndroidのどこでビデオが早く開始すると思いますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、どんな答えでも正解です。何を、どこで、どのようにプレイするかによります。ロシアの地域のネットワークがそれほど良くない場合、AVPlayerは約800ミリ秒で起動します。しかし、同じネットワークで、異なるフォーマットを再生するAndroidのExoPlayerは、660ミリ秒で起動します。 iOSでプレーヤーを作成すると、さらに高速に実行できるようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/eb/jl/ao/ebjlao75uhegqjpd6mn-nfjuakk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーの平均を測定するというニュアンスがあり、iOSデバイスの平均電力はAndroidよりも高いです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
資料の最初の部分は理論的なものです。ビデオとは何か、Liveプレーヤーのアーキテクチャはどのようなものかを調べます。</font><font style="vertical-align: inherit;">そして、第2部では、プレーヤーを比較して、いつ独自のものを作成するかについて話しましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート1</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオとは</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も基本的なものから始めましょう。</font><font style="vertical-align: inherit;">ビデオは毎秒60枚または24枚の画像です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、これを写真一式と一緒に保存するのはかなり高価です。</font><font style="vertical-align: inherit;">したがって、これらはこのように格納されます。一部のフレームは参照フレーム（Iフレーム）と呼ばれ、他のフレーム（BフレームとPフレーム）は「差分」と呼ばれます。</font><font style="vertical-align: inherit;">実際には、jpgファイルとそれに対する特定の一連の変更があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lf/rk/nt/lfrknthpx0phqp5u7psr0if5j78.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GOP（画像のグループ）の概念もあります。これは、参照フレームで始まり、一連の差分で続く独立したフレームのセットです。</font><font style="vertical-align: inherit;">個別に再生したり、解凍したりすることができます。</font><font style="vertical-align: inherit;">同時に、グループ内のopornikを失った場合、残りのフレームは関連しなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くのコーディングアルゴリズム、変換行列、モーション検索などがあります。これがコーデックの違いです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コーデックのパフォーマンス</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/q7/mj/ts/q7mjtslvjdqlperjccv0etipmgk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古典的なH.264は2003年から知られ、よく発達しています。その有効性をベースに考えます。彼はどこでも働き、遊ぶ。 CPU / GPUのハードウェアサポートがあります（iOSとAndroidの両方）。これは、それをコーディングできる特別なコプロセッサ、またはこれをすばやく実行できる組み込みの命令セットのいずれかがあることを意味します。平均して、ハードウェアサポートは最大10倍高速のパフォーマンスを提供し、バッテリー寿命を節約します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2010年には、GoogleのVP8が登場しました。効率的にはH.264と変わりません。まあ、実際にはコーデックの有効性は非常に物議を醸すものです。額では、圧縮された元のビデオの比率として測定されますが、異なるビデオアーティファクトがあることは明らかです。したがって、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">リンク</font></a><font style="vertical-align: inherit;">を提供します</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSUからのコーデックの詳細な比較。ここでは、VP8はソフトウェア組織に焦点を当てているため、どこにでもドラッグでき、ネイティブのH.264サポートがない場合のフォールバックとして通常使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2013年に、新世代のコーデックが登場しました-H.265（HEVC）とVP9。 H.265コーデックにより50％の効率が向上しますが、Androidビデオでエンコードすることはできません。デコーダーはAndroid 5.0以降でのみ表示されました。しかし、iOSではサポートがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H.265-VP9に代わるものがあります。すべて同じですが、Googleでサポートされています。そうですね、V9はYouTubeで、H.265はNetflixです。したがって、誰もが独自の特性を持っています。1つはiOSで動作せず、もう1つはAndroidで問題が発生します。結局、多くはH.264のままです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将来的には、AV1コーデックが約束され、すでにソフトウェアが実装されており、その効率は2013コーデックより35％高くなっています。</font><font style="vertical-align: inherit;">ChromeとFirefoxで利用可能になり、2020年にはGoogleがハードウェアサポートを約束します。おそらく、私たちはすべてそれに移行するでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、彼らは最近、H.266 / JVECコーデックを発表し、すべてがより良く、より速くなると述べました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主なパターン：コーデックの効率が高いほど、デバイスが必要とするコンピューティングリソースが多くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、デフォルトでは、全員がH.264を使用しますが、特定のデバイスでは複雑になる場合があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">品質、解像度、ビットレート</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2019年には、ユーザーが1つの品質で動画をアップロードまたはストリーミングし、さまざまな品質のラインを切り取って、最適なデバイスを送信することで、適応品質で誰も驚かないでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、ビデオの解像度がビットレートと相関している必要があります。</font><font style="vertical-align: inherit;">解像度が2倍になると、ビットレートも2倍になります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/f0/y_/vgf0y_ve9h6r_0r-bvioww1qivw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、低ビットレートで高解像度を圧縮したり、その逆の場合、アーティファクトまたはビットレートの無駄な書き込みが発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンコードされたビデオのビットレートは、初期の情報量とどのように比較されますか？</font><font style="vertical-align: inherit;">4K画面では、ほぼ6 Gb /秒の情報を再生できます（すべてのピクセルとその周波数を60フレーム/秒でカウントした場合）、コーデックのビットレートは50 Mb /秒です。</font><font style="vertical-align: inherit;">つまり、コーデックはビデオを最大100倍に圧縮します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配送技術</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オーディオとビデオにいくつかのコーデックがパックされています。家に置いておくだけなら、オーディオとビデオが何秒から始まるかを示す小さなインデックスを追加することで、すべてのオーディオとビデオを追加できます。ただし、ビデオを電話に配信することはできません。オンラインでビューアにストリーミングするには、ストリーミングとセグメントの2つの主要なプロトコルクラスがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yd/mn/bp/ydmnbpqbfq8p19nbq2wmdx4ktzi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリーミングプロトコルは、サーバーとクライアントにも何らかの状態があり、データを送信することを意味します。サーバーは、たとえば品質を調整できます。多くの場合、これはUDP接続です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなプロトコルはサーバーにとって非常に複雑であり、配信が困難です。負荷の高い翻訳の場合、HTTP上で機能するセグメント化されたプロトコルを使用し、nginxとCDNでキャッシュできるため、配布がはるかに簡単です。また、サーバーは何の責任も負いません。この場合、ステートレスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セグメント配信の様子：既存のビデオをセグメントに分割し、オーディオとビデオのヘッダー、MPEG-TSおよびMP4をトランスポートの例として添付します。電話では、セグメントがどこにどのような品質であるかに関する情報をマニフェストに提供し、このマニフェストは定期的に更新できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
歴史的に、AppleはHLSを介して配信し、AndroidはDASHを介して配信します。それらの違いを見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古いHLSから始めましょう。低、中、高など、利用可能なすべての品質を表すマニフェストがあります。これらの品質にはビットレートがあり、プレーヤーはすぐに適切なものを選択できます。彼は品質を選択し、セグメントへのリンクのリストを含むネストされたマニフェストを取得します。これらのセグメントの期間も表示されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v5/xw/1r/v5xw1rnetgtu4wzdg7zmxsy2dqa.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここには興味深い機能があります。最初のフレームの再生を開始するには、さらに2つのラウンドトリップを行う必要があります。最初のリクエストはメインのマニフェストを取得し、2番目はネストされたマニフェストを取得してから、データ自体にアクセスするだけです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hy/2u/af/hy2uafqbmeujkyq9ishlykfqppc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の難点：HLSはHTTP経由でインターネット上で動作するように設計されていましたが、従来のMPEG-2トランスポートストリームは、完全に異なる目的で開発されたビデオデータのコンテナーとして選択されました。その結果、追加のヘッダーが取得されます。HLSの場合、これは完全に役に立たず、オーバーヘッドを追加するだけです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tm/ks/hs/tmkshszo_5atstyrbip1r64qs84.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークのオーバーヘッドと解析の複雑さを追加します。DASHで4Kを、ChromeでHLSを再生しようとすると、コンピューターがHLSパケットで「離陸」したときに違いが感じられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Appleはこれを解決しようとしています。 2016年、彼らはFragmented MPEG-4を使用する可能性を発表しました。HLSでのDASHのサポートがいくつかありましたが、追加のRTTとその機能は消えていません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xa/zy/ai/xazyaila94udoix88ia0vvea0yq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DASHは少し簡単に見えます。1つのマニフェストにすべての品質が含まれており、各品質はセグメントのセットです。</font><font style="vertical-align: inherit;">1つのセグメントを再生して1つの品質で再生し、次に次のセグメントから別のセグメントに切り替えて速度が向上したことを理解できます。</font><font style="vertical-align: inherit;">すべてのセグメントは常に参照フレームで始まり、切り替えが可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここから選択するかについての小さなプレートです：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mq/n1/pk/mqn1pkjswjel-yxavreufexrrjm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ではHLSは、歴史的にサポートされているビデオコーデックはH.264のみをしている、あなたは、MPEG-DASHでいずれかを突き出すことができます。</font><font style="vertical-align: inherit;">HLSの主な問題は、最初の追加の往復であり、4.0を搭載したiOSとAndroidの両方でうまく機能します。</font><font style="vertical-align: inherit;">また、DASHは主にGoogle（ChromeおよびAndroid）でサポートされており、iOSでは再生できません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレーヤーのアーキテクチャ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオを大雑把に整理したので、プレーヤーの様子を見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/li/uj/ra/liujrart9xshdsg8d1ffcgztm6g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワーク部分から始めましょう。ビデオを開始するとき、プレーヤーはマニフェストに従い、何らかの形で品質を選択し、次にセグメントに従い、ダウンロードし、フレームをデコードし、バッファーに十分なフレームがあることを理解してから再生を開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレーヤーの一般的なアーキテクチャ：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-z/n2/1q/-zn21q-9ufwdrtdwgongpnk9bcg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データの送信元となるネットワークパーツ、ソケットがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後-デマルチプレクサまたはトランスポート（HLS / DASH）からオーディオおよびビデオストリームを取得する何らかのもの。彼女はそれらを適切なコーデックに送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コーデックはビデオとオーディオをデコードしてから、最も興味深いことが起こります。ビデオとオーディオを同時に再生するには、コーデックを同期させる必要があります。これには、タイムスタンプに基づくさまざまなメカニズムがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、テクスチャ、サーフェス、GL、またはメタルのどこかにレンダリングする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして入力には、データをロードしてバッファを制御するロード制御があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのプレーヤーで負荷制御はどのように見えますか？ダウンロードする必要があるデータの量があります。プレーヤーは、ダウンロードされるまで待機してから再生を開始し、さらにダウンロードします。ダウンロードが停止する最大バッファ制限があります。その後、再生が進むにつれ、バッファー内のデータ量が減少し、ロードを開始する最小の境界線ができます。だからこれも生きている：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4z/qj/rr/4zqjrrvsfqngzhxe9dx6h_kncfw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインループスレッドはどのように見えますか？</font><font style="vertical-align: inherit;">ゲーマーは「目盛りスレッド」の概念に精通しており、ここにあるようです。</font><font style="vertical-align: inherit;">すべてを1つのバッファーにスタックするネットワークを担当する部分があります。</font><font style="vertical-align: inherit;">解凍してコーデックに送信するエクストラクターがあり、中間バッファーでレンダリングが行われます。</font><font style="vertical-align: inherit;">そして、それらをシフトして制御し、同期を処理するティックがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1e/1f/g6/1e1fg6x4ncbeslmzch3timofmfs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外部では、メッセージキューを介していくつかのコマンドを送信し、リスナーを介していくつかの情報を受信するアプリケーションがあります。</font><font style="vertical-align: inherit;">また、バックプレッシャが表示され、品質が低下することがあります。たとえば、バッファが不足したり、レンダリングが処理できない（たとえば、ドロップフレームが表示される）場合などです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見積もり</font></font></h3> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
適応するとき、プレーヤーは2つの主要なパラメーターに依存します。ネットワーク速度とバッファー内の在庫データです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外観：最初に、たとえば720pなど、特定の品質が再現されます。</font><font style="vertical-align: inherit;">バッファが増え、キャッシュがどんどん増えています。</font><font style="vertical-align: inherit;">その後、速度が向上し、さらにダウンロードできるようになり、バッファが増加します。</font><font style="vertical-align: inherit;">この時点で、次の品質を試すことができるときに、最小バッファーのいくつかの境界を踏んでいることがわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ef/ti/ch/eftichq4decehj34b_ekowarlmi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
慎重に試してみる必要があることは明らかです。ネットワーク速度の点でこの品質を満たすことができるかどうかを推定する推定値もあります。</font><font style="vertical-align: inherit;">この評価に当てはまり、バッファの在庫が許す場合は、たとえば1080pに切り替えて再生を続けます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">過圧保護</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちとともに、それは試行錯誤を経て時間とともに現れました。必要なのは、機器にわずかな負荷をかけた場合です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再生中にネットワークが鈍くなったり、バックエンドでリソースが不足したりする場合があります。プレーヤーが再生を再開すると、追いつき始めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この瞬間までに膨大な数のセグメントセットがプレーヤーのマニフェストに蓄積されており、すぐにすべてをすぐにダウンロードして、「トラフィックの打撃」を受けています。クライアントでタイムアウトが発生し、プレーヤーがデータの再リクエストを開始すると、状況が悪化する可能性があります。したがって、システムに背圧を提供することが不可欠です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、私たちが使用する最初の簡単な方法は、サーバーのスロットルです。</font><font style="vertical-align: inherit;">彼はトラフィックが終了し、品質が低下し、同じブローが発生しないように顧客を故意に遅くすることを理解しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bn/ed/nz/bnednzqso81wrz0doypdlaa2phq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これは推定量にはあまり影響しません。</font><font style="vertical-align: inherit;">同じ「ねじれ」を生成できます。</font><font style="vertical-align: inherit;">したがって、可能であれば、マニフェストからの品質の削除をサポートします。</font><font style="vertical-align: inherit;">これを行うには、定期的にマニフェストを更新するか、フィードバックチャネルがある場合は、品質を削除するコマンドを与えると、プレーヤーは自動的に品質の低い別のマニフェストに切り替えます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">選手</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iOSではネイティブAVPlayerしかありませんが、Androidでは選択肢があります。ネイティブのMediaPlayerがありますが、アプリケーションが「それらと連携する」オープンソースのJavaベースのExoPlayerがあります。彼らの長所と短所は何ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つすべてを比較します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tf/cr/lg/tfcrlg3alc4srbn9r3plynsxqna.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アダプティブストリーミングの場合、ExoPlayerはDASH / HLSを再生し、他のプロトコル用の多くの拡張可能なモジュールを備えていますが、AVPlayerの方が劣っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オペレーティングシステムのバージョンのサポートは、原則として、どこにいても適しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プリフェッチとは、1つのビデオの終了後に、以下をテープで再生し、それをプリロードすることがわかっている場合です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネイティブプレーヤーのバグ修正に問題があります。</font><font style="vertical-align: inherit;">ExoPlayerの場合、アプリケーションの新しいバージョンにロールバックするだけですが、ネイティブAVPlayerおよびMediaPlayerでは、バグは次のOSリリースでのみ修正されます。</font><font style="vertical-align: inherit;">私たちはこれを苦痛に遭遇しました：iOS 8.01ではビデオの再生が不十分になり、iOS 8.02ではポータル全体が機能しなくなり、8.03ではすべてが再び機能しました。</font><font style="vertical-align: inherit;">この場合、私たちに依存するものは何もありませんでした。座って、Appleが次のバージョンをリリースするのを待ちました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ExoPlayerチームは、オーディオの場合のエネルギー消費の非効率性について話します。</font><font style="vertical-align: inherit;">Googleからの一般的な推奨事項は次のとおりです。音声を再生するには、Exo以外のすべてについてMediaPlayerを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
了解しました。Androidではビデオ用にDASHを備えたExoPLayerを使用し、iOSではHLSを備えたAVPlayerを使用します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クイック最初のフレーム</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しますが、最初のフレームまでの時間を覚えておいてください。</font><font style="vertical-align: inherit;">HLS iOSでの外観：マニフェストの背後にある最初のRTT、次にネストされたマニフェストの背後にある別のRTT-セグメントの取得と再生。</font><font style="vertical-align: inherit;">Androidでは、1つのRTTは少なく、少し良く開始されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gu/b7/hx/gub7hxr1ex5bhq6vanms80ht7x0.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファサイズ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、バッファを扱いましょう。</font><font style="vertical-align: inherit;">再生を開始する前にダウンロードする必要があるデータの最小量があります。</font><font style="vertical-align: inherit;">AVPlayerでは、この値はAVPlayerItem preferredForwardBufferDurationを使用して構成されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lm/cs/mg/lmcsmgwqpuukx1lsowi_xuneiba.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Androidでは、ExoPlayerにはさらに多くの構成メカニズムがあります。</font><font style="vertical-align: inherit;">開始に必要なのと同じ最小バッファーがあります。</font><font style="vertical-align: inherit;">しかし、リバフには別の設定もあります（ネットワークが落ちた場合、バッファーからのデータがなくなり、バッファーが返されます）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bs/wn/gj/bswngj3l6icqyk3detrxe82ve2s.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
利益は何ですか？</font><font style="vertical-align: inherit;">良好なネットワークがあれば、すぐに開始し、最初の短いフレームを目指して戦います。初めてチャンスをつかむことができます。</font><font style="vertical-align: inherit;">ただし、再生中にネットワークが故障した場合、繰り返し問題が発生しないように、リバフ中に再生するバッファリングを増やす必要があることは明らかです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元の品質</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/ec/1r/ns/ec1rnsjfbh1yk0cxiusj5x06w7g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iOS上のHLSにはクールな問題があります。それは常に、m3u8マニフェストの最初の品質から再生を開始します。あなたが彼に返すものは始まります。その後、ダウンロード速度が測定され、通常の品質で再生が開始されます。これが許されるべきでないことは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
論理最適化-品質を再ソートします。サーバー上（preferredqualityにパラメーターを追加することにより、マニフェストを再ソートします）、またはクライアント上（これを行うプロキシーを作成します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Androidには、このためのDefaultBandwidthMeterパラメータがあります。それはあなたの帯域のデフォルトの帯域幅を考慮した値を与えます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vs/b3/m8/vsb3m8lvbwp3kwuc2mi9btg3im4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仕組み：コードには定数の巨大なテーブルがあり、パラメーターは単純です-国（地域）と接続のタイプ（wi-fi、2G、3G、4G）。意味は何ですか？たとえば、Wi-Fiがあり、米国にいる場合、初期帯域幅は5.6 Mbpsです。 3Gが700 kbpsの場合。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Googleの見積もりによると、ロシアの4Gはアメリカの2〜3倍高速であることがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロシアが大きな国であることは明らかであり、そのような体制は私たちにまったく似合わなかった。したがって、単純に実行したい場合は、現在のネットワークの以前の値を覚えて、念のために1ユニットを差し引いて開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、世界中でビデオを再生する大規模なアプリケーションがある場合は、サブネットの統計情報を収集し、開始する品質をサーバーから推奨します。</font><font style="vertical-align: inherit;">バッファリング後は、バッファの値を増やすことをお勧めします（Androidでは、これは簡単に許可されます）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">巻き戻しをスピードアップする方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーがビデオを特定の場所（シーク）に巻き戻した場合、参照フレーム内ではなく、その間にある可能性があります。したがって、それまでの参照からのものはすべてダウンロードしてデコードする必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ay/be/50/aybe50r6ymkweqtj9wygtuhdxga.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、ユーザーが2時間の映画を見る場合、プラスまたはマイナスの秒は彼にとって重要ではありません。したがって、iOSでは、ビデオが特定の間隔できちんとカットされていることがわかっている場合は、それを計算してその参照フレームに送信することができます（プラスのデルタは、その前ではなく、その直後にあります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バージョン2.7.0以降のExoPlayerでは、巻き戻し方法を指定できるようになり、「次のフレームに」というオプションがあります。この場合、彼は最も近いフレームを1秒前に、3秒後ろに検索します。そんな中で見つけて、巻き戻します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3j/3a/i_/3j3ai__smnqi_oytag8ny1rico0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオが最初から開始せず（そしてほとんどすべてのビデオホスティング会社がユーザーが最後にビデオを視聴したときまでの時間を覚えている場合）、ある位置に巻き戻す場合は、Androidで（mediaSource）を準備してから、AndroidでseekTo（）を行わないでください。</font><font style="vertical-align: inherit;">そうする場合、最初から最初からプレイする準備をしてから、巻き戻します。</font><font style="vertical-align: inherit;">これらの行を入れ替えてください。これにより、大幅に高速化</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pe/oy/d_/peoyd_g_aartazc_lofykbivmn0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
することができました。ビデオを変更しても（一方が最初に再生され、次にもう一方が再生される）、コーデックを手放さない方が良いでしょう。</font><font style="vertical-align: inherit;">これは非常にコストのかかる操作（約100ミリ秒）であり、次のビデオを同じデコーダー設定で再生する可能性が高く、完全に適しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0l/uh/7s/0luh7sbufo5x4qmxbscuzvd-xwk.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iOSではすべてが単純にレンダリングされますが、Androidでは多くの異なるレガシーなものが存在します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くはTextureViewでレンダリングします。オプションは、それがメモリの独立した領域であり、フレーム全体をコピーし、UIと同期してアニメーション化されているという点で優れています。しかし、マイナス面もあります-発売が大幅に遅れ、電力消費が高いことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SurfaceViewがあります。すぐに開始できますが、ビデオメモリの穴です。そのため、一部の古いAndroidデバイスでは、スクロールすると、さまざまなアーティファクトの形で穴が表示されます。 YouTubeは最初、再生中にビデオをスクロールすることはなかったので、それに適していました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、GLSurfaceView-最初の2つの中間のオプションがあります。レンダリングを提出すると、古いデバイスのテクスチャが遅いという問題を修正できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yx/tw/wg/yxtwwgajtkdlsclcsyadebja9cg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論：ExoPlayerを注意深く調整すると、最初のフレームを23％高速化できることがわかりました。</font><font style="vertical-align: inherit;">「krutilok」の数が10％減少しました。</font><font style="vertical-align: inherit;">そして、このすべての調整により、ビューの約4％が追加されました。</font><font style="vertical-align: inherit;">これらの4％が必要ですか-自分で決めてください。しかし、難しくはありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論：Androidの推奨事項</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他のすべてのExoPlayerが存在する場合は、音楽にMediaPlayerを使用します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開始、シーク、スワップの最適化</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたの見積もりを書いてください、それは交換するのは簡単です</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推奨される正しいビューを使用する</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論：iOSの推奨事項</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IOSは難しくなっています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPlayerのHLSに追加のRTTがあります</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独自の見積もり</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPlayer＃一時停止後にメインストリームの速度を低下させる</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネイティブ-ソースなし、iOSリリースでのみ更新</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、「あらゆるライブプレーヤーのアーキテクチャ」をベースにして、独自のDASHプレーヤーにガスを当てることにしました。</font><font style="vertical-align: inherit;">私たちは使用しました：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cURLまたはGCDAsyncSocket</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVAssetReader、それからそれを放棄</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CADisplayLink</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVSampleBufferDisplayLayer</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これには時間がかかりますが、いくつかの高速化がありました。</font><font style="vertical-align: inherit;">最初のフレームまでの時間が28％短縮され、「ツイスト」が6％短縮されました。</font><font style="vertical-align: inherit;">しかし、最も楽しいのは、HLSからDASHに切り替えると、平均消費ビットレートが100 kbit / s増加し、ビュー数が6％増加したことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、iOSの推奨事項は次のようになります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開始とシークを最適化する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HLS over Fragmented mp4を使用する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DASHプレーヤーを作成する</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレイヤーもクロスプラットフォームにしようと考えています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の部分の結論：</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオ、標準プレーヤーアーキテクチャ、プレーヤーの比較とチューニングについて学びました。 </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">適切なストリーミング形式を選択する（mp4のみではない）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">適切なプレーヤーを選択してください（ExoPlayer、AVPlayer）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">firstFrame、seek、emptyBufferの統計を収集する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレーヤーを調整して、見積もりを確認します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレーヤーを記述します（特にこれを行う必要がある場合）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたが深刻な何かをしたい場合は、バーを上げます。</font><font style="vertical-align: inherit;">私たちは基準を4Kに引き上げ、すべてのバグを発見しました：パフォーマンス、解析、すべてにおいて。</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今ストリーミングについて。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート2：DIYビデオストリーミング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モバイルデバイスからビデオを送信する必要がある場合はどうすればよいですか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ji/0p/pk/ji0ppk9wacev99cddvsw0alqjj0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カメラのキャプチャとエンコーディングのためのAPIが必要です。</font><font style="vertical-align: inherit;">これらのAPIは、iOSおよびAndroid上のカメラとハードウェアエンコーダーへのアクセスを提供します。これは非常に重要です。ソフトウェアよりもはるかに高速に動作します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソケット：お気に入りのフレームワークで何らかのラッパーを使用するか、POSIXソケットを使用してすべてをネイティブモードで実行し、クロスプラットフォームのネットワークパーツを作成できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーミングから何を達成したいですか？</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">低遅延</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">放送品質が良い</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオとオーディオの安定性</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファストスタート</font></font></li>
</ul><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、何を戦わなければならないでしょうか？</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">低帯域幅</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遅延</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーディオとビデオの中断</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開始遅延（N x RTT、通常は開始をRTTの数として計算すると便利です）</font></font></li>
</ul><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜ低遅延が必要ですか？</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/-b/ae/va/-baevaqjpxvp9nnr2ecdrjmgqr4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のケースは聴衆との対話です。</font><font style="vertical-align: inherit;">クイズやライブ通話などの機能がありますが、遅延は非常に重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クイズでは、質問をしてタイマーを設定します。ユーザーがバッファー内のデータ量が異なる場合、ユーザーの状態は同じではなく、応答時間も異なります。</font><font style="vertical-align: inherit;">そして、同じバッファーを実現する唯一の方法は、待ち時間を短くすることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在開発中のシナリオはライブ通話です。</font><font style="vertical-align: inherit;">ストリーマをライブで呼び出して彼と話すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目のケースは、4Kでのスポーツ放送です。</font><font style="vertical-align: inherit;">たとえば、ビールとチップスでワールドカップを見て、壁の後ろの隣人も同じことを見ています。</font><font style="vertical-align: inherit;">彼らがすでにゴールを持っていて、それでも30秒のバッファリングがあるなら、彼らはずっと早く喜び、群衆を作り始め、話題全体を台無しにします。</font><font style="vertical-align: inherit;">人々は遅れがより少ない競争相手に行きます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">適応</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、私たちが持っているネットワークは異なっているので、それぞれに適応する必要があります。これを行うために、ビデオとオーディオのビットレートを変更します（さらに、ビデオでは、100倍変更できます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
適応する時間がない、または適応能力を使い果たしていないことがわかった場合、一部のフレームをドロップできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、ビデオの解像度も変更する必要があります。 1つの解像度でビットレートの全範囲を100回エンコードすると、結果が悪くなります。たとえば、FullHDビデオと480pを同じビットレート300 kbpsでエンコードすると、優れたFullHDの画質が低下するように見えます。高解像度ではコーデックが難しく、画像が崩れます。画像自体のエンコードにビットを費やす代わりに、オーバーヘッド部分をエンコードします。したがって、解像度はビットレートと一致する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
適応を伴う一般的なコーディングスキームは次のとおりです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kk/xs/xu/kkxsxux2cegqqdg5w9cuny-wzps.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オンザフライでビットレートを変更できるソースがあり、ネットワークがあります。</font><font style="vertical-align: inherit;">すべてのデータはネットワークに送られます。何らかの形でネットワークからフィードバックを得て、送信されるデータの量を増やすことができるか、減らすことができるかを理解しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリーマには、ソースとしてMediaCodecまたはVideoToolboxがあります（プラットフォームによって異なります）。</font><font style="vertical-align: inherit;">そして、再生中、すべてはサーバートランスコーダーによって行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワーク上-すでに話し合っており、今後も話し合うさまざまなネットワークプロトコル。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">妥協の三角形</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリーミングについて詳しく調べ始めると、いくつかの妥協点に遭遇します。</font><font style="vertical-align: inherit;">特に、コーナーには三角形があり、その信頼性は信頼性（ドロップなし）、スループットは帯域幅（ネットワークの使用量）、低遅延は低遅延（低遅延になる）です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zz/pc/xm/zzpcxmj1krgbg9qpfgxbb2q32wi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのパラメーターの1つを最適化し始めると、残りは必然的に失敗します。</font><font style="vertical-align: inherit;">一度にすべてを手に入れることはできません。何かを犠牲にする必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロトコル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日目にするプロトコルは、RTMPとWebRTCが標準プロトコルで、OKMPがカスタムプロトコルです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RTMPはTCPの上で実行され、他の2つはUDPを使用することは言及する価値があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTMP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼は何を与えるのですか？ある意味で、これはすべてのサービス（YouTube、Twitch、Flash、OK）でサポートされている標準です。ユーザーがライブストリームをアップロードできるようにするために使用します。ライブストリームをサードパーティのサービスにストリーミングする場合は、おそらくRTMPを使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリーマーからプレーヤーまでに達成できた最小遅延は300ミリ秒ですが、これは天気の良いときに理想的なネットワークです。実際のネットワークがある場合、遅延は通常2〜3秒に拡大し、ネットワークに問題がある場合は数十秒に拡大する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RTMPは、オンザフライで解像度とビットレートの変更をサポートします（上記の他のプロトコルも同様ですが、オンザフライで変更がないというRTMPに関する誤った情報があります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マイナス点は、TCPに基づいて構築されていることです（これがなぜ悪いのかは後で説明します）、遅延は制御できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
三角形を見ると、RTMPは低レイテンシを提供できません。入手できますが、保証は一切ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、RTMPは少しがらくたです。Adobeはこれを行わないため、RTCDは新しいコーデックをサポートしていません。また、ドキュメントは非常に古く、曲がっています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/e_/p6/sm/e_p6sm4qifhwi6ftl0hgl-aiodk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TCPがライブブロードキャストに適さないのはなぜですか？ TCPは配信を保証します。ソケットに配置したデータは、そこに配置した順序と形式で正確に配信されます。何も削除または再配置されません。 TCPはこれを行うか、または終了します。しかし、これは遅延保証が除外されていることを意味します-彼は古いデータを落とすことができないでしょう、それはおそらく、おそらく送信する必要はありません。バッファ、バックログなどが増加し始めます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nt/vw/tb/ntvwtb4fybykxeul4gf9cmhlnva.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、行頭ブロッキング問題。ストリーミングだけでなく、他の多くの場合にも見られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは何ですか？最初は空のレシーバーバッファーがあります。どこかからデータを受信して​​います：大量のデータと大量のIPパケット。最初のIPパケットを受信しました。受信側では、recv（）メソッドを使用して、このパケットを減算し、データを取得し、損失し、レンダリングします。しかし、突然、2番目のパケットが失われました。次は何が起こる？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
失われたIPパケットを回復するために、TCPは再送信する必要があります。これを実現するには、RTTを費やす必要がありますが、再送信も失われる可能性があるため、サイクルを繰り返します。多くのパッケージがある場合、これは確かに起こります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、2番目のパッケージを待機しているため、読み取ることができない大量のデータが続きます。彼は5分前に起こった放送フレームを示しましたが、もはや必要ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の問題を理解するために、RTMPの適応を見てみましょう。送信側で適応を行います。ネットワークがデータをソケットに入れる速度でクラミングできない場合、バッファーはいっぱいになり、ソケットはEWOULDBLOCKを通知するか、この時点でブロックが使用されている場合はブロックされます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oy/6z/uy/oy6zuyjliks8epvjx4g83uq5d_m.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現時点でのみ問題があることを理解しており、品質を下げる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の速度が4 Mbpsのネットワークがあるとします。ソケットサイズとして250 KBを選択しました（この速度では0.5秒に相当します）。突然ネットワークが10回失敗しました-これは通常の状況です。 400 kbpsです。バッファはすぐに0.5秒でいっぱいになり、そのときだけ、スイッチを切る必要があることを理解しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/te/7l/0p/te7l0pkef3gz8ntjm7gq27yvxnm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし今問題は、5秒間送信される250 KBのバッファがあることです。私たちはすでに完全に遅れています。最初に古いデータを駆除する必要があります。その後、新しい適応されたデータだけがリアルタイムに追いつきます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何をすべきか？ここで私たちの「妥協の三角形」はちょうど関連しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s2/0k/fa/s20kfaykbgel7si5vtpcjiwla1w.jpeg"><br>
<br>
<ul>
<li>  sender-,   0,5  — 0,1 .     ,     «»   .  , TCP   , ,   sender- ,  RTT,      ,    .</li>
<li>  receiver-.     , -      . , ,  low latency,     5- .</li>
<li>    .  TCP     —  ,   .   reliability,        .</li>
</ul><br>
<br>
<h3>WebRTC</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、経験を考慮に入れ、UDP上で実行されるC ++ライブラリです。 iOS、Androidでのビルド、ブラウザーへの組み込み、HTML5のサポート。 P2P通話のために投獄されているため、遅延は0.1〜1秒です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gu/jv/co/gujvcogf5z-3szbr4b3fqxcs38m.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マイナス点としては、これは削除できないレガシーが豊富な一体型ライブラリです。さらに、P2Pコールに重点を置いているため、低レイテンシを優先します。私たちはこれを望んでいたように見えますが、そのために、彼女は他のパラメータを犠牲にしています。また、優先順位を変更する設定はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、ライブラリーはサーバーなしで2つのクライアントの会話を行うためのクライアント指向であることにも注意してください。サーバーでサードパーティを検索するか、独自に作成する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何を選択するか-RTMPまたはWebRTC？</font><font style="vertical-align: inherit;">両方のプロトコルを実装し、さまざまなシナリオでテストしました。</font><font style="vertical-align: inherit;">グラフでは、WebRTCの遅延は小さいですがスループットは低く、RTMPはその逆です。</font><font style="vertical-align: inherit;">そしてそれらの間には穴があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、この穴を完全にカバーし、WebRTCとRTMPモードの両方で機能するプロトコルを作成したかったのです。</font><font style="vertical-align: inherit;">彼らはそれを作ってOKMPと名付けた。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xq/8y/p1/xq8yp1lyi_jxdqc8h-tyzw0grgi.jpeg"><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Okmp</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、UDPの柔軟なプロトコルです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多重化をサポートします。これはどういう意味ですか：セッション内にはいくつかのチャネルがあります（OK Liveの場合-マネージャー、オーディオ、ビデオ）。各チャネル内では、データは特定の順序で配信されることが保証されています（ただし、それら自体は配信されることが保証されていません）。チャネル間の順序は重要ではないため、保証されていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは何を与えるのですか？まず、チャネルに優先順位を付ける機会がありました。コントロールチャネルの優先度が高く、音声は中程度、ビデオは低いと言えます。ビデオのジッターと不均一なビデオ配信は簡単にマスキングでき、ユーザーはオーディオの不快な吃音よりもビデオの問題による問題が少なくなります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vd/nq/pp/vdnqppsvt33b7j82m2hxdgnf1ag.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、プロトコルにはオプションの配信保証があります。特定のチャネルでは、配信が保証されたTCPモードで動作しており、他のチャネルでは、一部のドロップを許可していると言えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、遅延が保証されます。TCPチャネルで遅延が保証されることはなく、ドロップが許可されている他のしきい値ではしきい値が設定されます。その後、データがドロップし始め、古いデータの配信が停止します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、オーディオの場合は1秒、ビデオの場合は0.5秒です。しきい値が異なるのはなぜですか？これは別の優先順位付けメカニズムです。音声がスムーズであることが私たちにとってより重要であるため、まずビデオをドロップし始めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのプロトコルは柔軟に構成されています。単一の操作モードはありません。ユーザーが目に見える効果なしに目的のモードに切り替えるためにその場で設定を変更します。</font><font style="vertical-align: inherit;">何のために？</font><font style="vertical-align: inherit;">たとえば、同じビデオ通話の場合：ビデオ通話がストリームで開始された場合、それを低レイテンシモードに静かに転送します。</font><font style="vertical-align: inherit;">その後、スループットモードに戻って最高の品質を実現します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装の課題</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zv/jl/wk/zvjlwkvrqjhldwib10ocewpc7iu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、UDPでプロトコルを作成する場合、いくつかの問題が発生します。</font><font style="vertical-align: inherit;">TCPを使用して、UDPに自分で書き込む必要があるメカニズムを取得します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パケット化/パケット化解除。</font><font style="vertical-align: inherit;">MTUネットワークに適合するように、データを自分でサイズが約1.5 KBのパケットにカットする必要があります。</font></font></li>
<li>Reordering.      ,         .   ,   sequence   ,      .</li>
<li>Losses. ,  .   , receiver    sender’,  «    ,    »,  sender    .   .</li>
<li>Flow Control.  Receiver   ,     ,      ,    ,     .   TCP  send ,    UDP  ,    ,  receiver   ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">輻輳制御。</font><font style="vertical-align: inherit;">同様のことが、この場合にのみネットワークが停止しました。</font><font style="vertical-align: inherit;">亡くなったネットワークにパケットを送信すると、接続だけでなく隣接する接続も破壊されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暗号化 </font><font style="vertical-align: inherit;">暗号化を処理する必要がある</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...その他</font></font></li>
</ul><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OKMPとRTMP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RTMPの代わりにOKMPを使い始めたとき、何が得られましたか？</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OKLiveビットレートの平均増加は30％です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジッタ（不均一なパケット到着の測定）-0％（平均して同じ）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジッタオーディオ--25％</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジッタビデオ-40％</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オーディオとビデオの変更-私たちのプロトコルの優先順位のデモンストレーション。</font><font style="vertical-align: inherit;">音声の方が優先されますが、動画のおかげで順調に進んでいます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーミング用のプロトコルを選択する方法</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/_l/g3/vs/_lg3vsf20spfixqon5z0m4fwa0w.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
低レイテンシが必要な場合-WebRTC。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外部サービスで作業したり、サードパーティのサービスでビデオを公開したりする場合は、RTMPを使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スクリプトに合わせたプロトコルが必要な場合は、独自のプロトコルを実装してください。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja467659/index.html">更新されたHyperX FURY DDR4メモリの追加構成の例を使用して、タスクの実行を大幅にスピードアップします</a></li>
<li><a href="../ja467661/index.html">Seryozhaの線量計。パートI. Polimaster-核種ハンター</a></li>
<li><a href="../ja467663/index.html">.NET Coreでのハードウェア固有の命令のサポート（現在はSIMDだけではありません）</a></li>
<li><a href="../ja467665/index.html">ROSトラックトロリー。パート5. rvizおよびgazeboでの作業：xacro、新しいセンサー</a></li>
<li><a href="../ja467667/index.html">組織プロジェクト計画（パート4）</a></li>
<li><a href="../ja467671/index.html">NLXレトロコンピュータ</a></li>
<li><a href="../ja467673/index.html">組み込みのGo機能</a></li>
<li><a href="../ja467675/index.html">SwiftUIでのStoreオブジェクトを使用したアプリケーション状態のモデリング</a></li>
<li><a href="../ja467677/index.html">テストまたはタイプ</a></li>
<li><a href="../ja467679/index.html">PyCrunch-IDEでのインテリジェントなテスト実行とビジュアルコードカバレッジ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>