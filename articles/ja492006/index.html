<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🔬 🐣 👶🏻 PWAの威力：300行のニューラルネットワークJSコードを備えたビデオ監視システム 🕟 🧙 🙆🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！
 
 Webブラウザーはオペレーティングシステムのほとんどの機能をゆっくりと、しかし確実に実装します。Webバージョン（PWA）を作成できる場合、ネイティブアプリケーションを開発する理由はますます少なくなります。クロスプラットフォーム、豊富なAPI、TS / JSでの高い開発速...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PWAの威力：300行のニューラルネットワークJSコードを備えたビデオ監視システム</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492006/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Webブラウザー</font><font style="vertical-align: inherit;">はオペレーティングシステムのほとんどの機能を</font><font style="vertical-align: inherit;">ゆっくりと、しかし確実に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装し</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。Webバージョン（PWA）を作成できる場合、ネイティブアプリケーションを開発する理由はますます少なくなります。クロスプラットフォーム、豊富なAPI、TS / JSでの高い開発速度、さらにはV8エンジンのパフォーマンス-これらすべてがプラスです。ブラウザは長い間、ビデオストリームを操作してニューラルネットワークを実行することができました。つまり、オブジェクト認識を備えたビデオ監視システムを作成するためのすべてのコンポーネントがあります。この</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">触発されて</font><font style="vertical-align: inherit;">、私はデモを共有したい実用的なレベルのレベルにすることを決めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションはカメラからのビデオを記録し、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">COCO-SSD</font></a><font style="vertical-align: inherit;">で認識できるようにフレームを定期的に送信します</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、人が検出された場合、7秒の部分のビデオフラグメントがGmail-API経由で指定されたメールに送信され始めます。大人のシステムと同様に、事前記録が実行されます。つまり、検出の瞬間まで1つのフラグメント、検出されたすべてのフラグメント、および1つ後に保存されます。インターネットが利用できない場合、または送信中にエラーが発生した場合、ビデオはローカルのダウンロードフォルダーに保存されます。電子メールを使用すると、サーバー側を使用せずにすぐに所有者に通知できます。攻撃者がデバイスを手に入れてすべてのパスワードをクラックした場合、受信者からメールを削除することはできません。マイナス点-Base64（1台のカメラには十分ですが）によるトラフィックの過剰使用、および多くの電子メールから最終的なビデオファイルを収集する必要性。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動作するデモはこちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
発生する問題は次のとおりです。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1）ニューラルネットワークはプロセッサに大きな負荷をかけます。メインスレッドで実行すると、ビデオに遅延が表示されます。したがって、ここではすべてがスムーズであるわけではありませんが、認識は別のスレッド（ワーカー）に配置されます。デュアルコアの先史時代のLinuxでは、すべてが完全に並列ですが、かなり新しい4コアの携帯電話では、（ワーカーで）認識された時点で、メインスレッドも遅延し始めます。これは、ユーザーインターフェイスで顕著です。幸い、これはビデオの品質には影響しませんが、認識頻度を減らします（自動的に負荷に合わせて調整されます）。この問題はおそらく、Androidの異なるバージョンがコア、SIMDの存在、使用可能なビデオカード機能などによってスレッドを分散する方法に関連しています。自分でそれを理解することはできません。TensorFlowの内部がわからないので、情報に感謝します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2）FireFox。</font><font style="vertical-align: inherit;">アプリケーションはChrome / Chromium / Edgeで</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正常に動作し</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ますが、FireFoxでの認識は著しく遅くなります。さらに、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ImageCapture</font></a><font style="vertical-align: inherit;">はまだ実装されていません</font><font style="vertical-align: inherit;">（もちろん、これは&lt;video&gt;からフレームをキャプチャすることで回避できますが、それは標準であるため、キツネにとっては残念です。 API）。</font><font style="vertical-align: inherit;">一般に、ブラウザ間の完全なアクセシビリティもありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だから、すべてが順番に。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カメラとマイクの入手</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">this</span>.video = <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'video'</span>)
<span class="hljs-keyword">this</span>.canvas = <span class="hljs-keyword">this</span>.querySelectorAll(<span class="hljs-string">'canvas'</span>)[<span class="hljs-number">0</span>]<font></font>
<font></font>
<span class="hljs-keyword">this</span>.stream = <span class="hljs-keyword">await</span> navigator.mediaDevices.getUserMedia(<font></font>
   {<span class="hljs-attr">video</span>: {<span class="hljs-attr">facingMode</span>: {<span class="hljs-attr">ideal</span>: <span class="hljs-string">"environment"</span>}}, <span class="hljs-attr">audio</span>: <span class="hljs-literal">true</span>}<font></font>
)<font></font>
<span class="hljs-keyword">this</span>.video.srcObject = <span class="hljs-keyword">this</span>.stream
<span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
   <span class="hljs-keyword">this</span>.video.onloadedmetadata = <span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> resolve()<font></font>
})<font></font>
<span class="hljs-keyword">this</span>.W = <span class="hljs-keyword">this</span>.bbox.width = <span class="hljs-keyword">this</span>.canvas.width = <span class="hljs-keyword">this</span>.video.videoWidth
<span class="hljs-keyword">this</span>.H = <span class="hljs-keyword">this</span>.bbox.height = <span class="hljs-keyword">this</span>.canvas.height = <span class="hljs-keyword">this</span>.video.videoHeight
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、携帯電話/タブレット（またはコンピューター/ラップトップの最初のカメラ）のメインカメラを選択し、標準のビデオプレーヤーでストリームを表示します。その後、メタデータが読み込まれてサービスキャンバスのサイズを設定するのを待ちます。</font><font style="vertical-align: inherit;">アプリケーション全体がasync / awaitのスタイルで記述されているため、統一性を保つためにコールバックAPI（かなり多くあります）をPromiseに変換する必要があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオキャプチャ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオをキャプチャするには2つの方法があります。</font><font style="vertical-align: inherit;">1つ目は、受信ストリームからフレームを直接読み取り、キャンバスに表示し、それらを変更（たとえば、地理情報とタイムスタンプを追加）してから、キャンバスからデータを取得します-レコーダーの場合は発信ストリームとして、ニューラルネットワークの場合は個別の画像として。</font><font style="vertical-align: inherit;">この場合、&lt;video&gt;要素なしで実行できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">this</span>.capture = <span class="hljs-keyword">new</span> ImageCapture(<span class="hljs-keyword">this</span>.stream.getVideoTracks()[<span class="hljs-number">0</span>])
<span class="hljs-keyword">this</span>.recorder = <span class="hljs-keyword">new</span> MediaRecorder(<span class="hljs-keyword">this</span>.canvas.captureStream(), {<span class="hljs-attr">mimeType</span> : <span class="hljs-string">"video/webm"</span>})<font></font>
<font></font>
grab_video()<font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">grab_video</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">this</span>.canvas.drawImage(<span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.capture.grabFrame(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
	<span class="hljs-keyword">const</span> img = <span class="hljs-keyword">this</span>.canvas.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.W, <span class="hljs-keyword">this</span>.H)<font></font>
	... <span class="hljs-comment">//    -   img</span>
	... <span class="hljs-comment">//   -    </span>
        <span class="hljs-built_in">window</span>.requestAnimationFrame(<span class="hljs-keyword">this</span>.grab_video.bind(<span class="hljs-keyword">this</span>))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の方法（FFで動作）は、標準のビデオプレーヤーを使用してキャプチャすることです。</font><font style="vertical-align: inherit;">ちなみに、キャンバス上のフレームごとの表示とは異なり、消費するプロセッサ時間は少なくなりますが、碑文を追加することはできません。</font></font><br>
<br>
<pre><code class="javascript hljs">...<font></font>
async <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">grab_video</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">this</span>.canvas.drawImage(<span class="hljs-keyword">this</span>.video, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
	...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションは最初のオプションを使用します。その結果、認識プロセス中にビデオプレーヤーをオフにすることができます。</font><font style="vertical-align: inherit;">プロセッサを節約するために、入力ストリームから記録が実行され、キャンバス上のフレームの描画は、認識速度に応じた頻度で、ニューラルネットワークのピクセルの配列を取得するためにのみ使用されます。</font><font style="vertical-align: inherit;">プレーヤーに配置された別のキャンバスで人物の周りにフレームを描画します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニューラルネットワークの読み込みと人間の検出</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはすべてひどくシンプルです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">workerを開始し</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、モデルを（かなり長く）ロードした後、メインスレッドに空のメッセージを送信します。onmessageイベントでは開始ボタンが表示され、その後ワーカーは画像を受信する準備が整います。</font><font style="vertical-align: inherit;">完全なワーカーコード：</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-keyword">async</span> () =&gt; {<font></font>
  self.importScripts(<span class="hljs-string">'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js'</span>)<font></font>
  self.importScripts(<span class="hljs-string">'https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd'</span>)<font></font>
<font></font>
  <span class="hljs-keyword">let</span> model = <span class="hljs-keyword">await</span> cocoSsd.load()<font></font>
  self.postMessage({})<font></font>
<font></font>
  self.onmessage = <span class="hljs-keyword">async</span> (ev) =&gt; {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> model.detect(ev.data)
    <span class="hljs-keyword">const</span> person = result.find(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.class === <span class="hljs-string">'person'</span>)
    <span class="hljs-keyword">if</span> (person) <font></font>
      self.postMessage({<span class="hljs-attr">ok</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bbox</span>: person.bbox})
    <span class="hljs-keyword">else</span>
      self.postMessage({<span class="hljs-attr">ok</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">bbox</span>: <span class="hljs-literal">null</span>})<font></font>
  }<font></font>
})()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインスレッドでは</font><font style="vertical-align: inherit;">、ワーカーから前の結果を受け取った後でのみ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grab_video（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">開始し</font></a><font style="vertical-align: inherit;">ます。つまり、検出頻度はシステムの負荷に依存します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">録画</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">this</span>.recorder.rec = <span class="hljs-keyword">new</span> MediaRecorder(<span class="hljs-keyword">this</span>.stream, {<span class="hljs-attr">mimeType</span> : <span class="hljs-string">"video/webm"</span>})
<span class="hljs-keyword">this</span>.recorder.rec.ondataavailable = <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> {
   <span class="hljs-keyword">this</span>.chunk = ev.data
   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.detected) {
      <span class="hljs-keyword">this</span>.send_chunk()<font></font>
   } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.recorder.num &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>.send_chunk()
      <span class="hljs-keyword">this</span>.recorder.num--<font></font>
   }<font></font>
}<font></font>
...<font></font>
this.recorder.rec.start()<font></font>
<span class="hljs-keyword">this</span>.recorder.num = <span class="hljs-number">0</span>
<span class="hljs-keyword">this</span>.recorder.interval = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
   <span class="hljs-keyword">this</span>.recorder.rec.stop()
   <span class="hljs-keyword">this</span>.recorder.rec.start()<font></font>
}, CHUNK_DURATION)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レコーダーが停止するたびに（固定間隔を使用）、ondataavailableイベントが発生し、Blob形式で記録されたフラグメントが転送され、this.chunkに保存され、非同期に送信されます。はい、this.send_chunk（）はpromiseを返しますが、関数には長い時間がかかり（Base64でのエンコード、電子メールの送信、またはファイルのローカル保存）、それが実行されるのを待たず、結果を処理しないため、待機する必要はありません。新しいビデオクリップが送信できる頻度よりも頻繁に表示されることが判明した場合でも、JSエンジンは開発者に約束のラインを透過的に配置し、遅かれ早かれすべてのデータが送信/記録されます。注意する価値がある唯一のものは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">send_chunk（）</font></a><font style="vertical-align: inherit;">関数の内部です</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> this.chunkリンクはCHUNK_DURATION秒ごとにラビングされるため、最初の待機の前に、slice（）メソッドを使用してBlobのクローンを作成する必要があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gmail API</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手紙を送るために使用されます。</font><font style="vertical-align: inherit;">APIはかなり古く、一部はpromiseにあり、一部はコールバックにあり、ドキュメントやサンプルは豊富ではないため、完全なコードを提供します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">承認</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">アプリケーションとクライアントキーはGoogleデベロッパーコンソールで取得します。</font><font style="vertical-align: inherit;">ポップアップ認証ウィンドウで、Googleはアプリケーションが検証されていないことを報告します。入力するには、[詳細設定]をクリックする必要があります。</font><font style="vertical-align: inherit;">Googleでアプリケーションを確認するのは簡単な作業ではないことが判明したので、ドメイン（私が持っていない）の所有権を確認し、メインページを正しく配置する必要があるので、気にしないことにしました。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'https://apis.google.com/js/api.js'</span>)<font></font>
gapi.load(<span class="hljs-string">'client:auth2'</span>, <span class="hljs-keyword">async</span> () =&gt; {
   <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> gapi.client.init({
         <span class="hljs-attr">apiKey</span>: API_KEY,
         <span class="hljs-attr">clientId</span>: CLIENT_ID,
         <span class="hljs-attr">discoveryDocs</span>: [<span class="hljs-string">'https://www.googleapis.com/discovery/v1/apis/gmail/v1/rest'</span>],
         <span class="hljs-attr">scope</span>: <span class="hljs-string">'https://www.googleapis.com/auth/gmail.send'</span><font></font>
      }) <font></font>
      <span class="hljs-keyword">if</span> (!gapi.auth2.getAuthInstance().isSignedIn.je) {
         <span class="hljs-keyword">await</span> gapi.auth2.getAuthInstance().signIn()<font></font>
      }<font></font>
      <span class="hljs-keyword">this</span>.msg.innerHTML = <span class="hljs-string">''</span>
      <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'nav'</span>).style.display = <span class="hljs-string">''</span>
   } <span class="hljs-keyword">catch</span>(e) {
      <span class="hljs-keyword">this</span>.msg.innerHTML = <span class="hljs-string">'Gmail authorization error: '</span> + <span class="hljs-built_in">JSON</span>.stringify(e, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>)<font></font>
   }<font></font>
})<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メール送信</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Base64でエンコードされた文字列は連結できません。これは不便です。</font><font style="vertical-align: inherit;">バイナリ形式でビデオを送信する方法は、私はまだ理解していませんでした。</font><font style="vertical-align: inherit;">最後の行では、コールバックをpromiseに変換します。</font><font style="vertical-align: inherit;">残念ながら、これはかなり頻繁に行われる必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> send_mail(subject, mime_type, body) {
   <span class="hljs-keyword">const</span> headers = {
      <span class="hljs-string">'From'</span>: <span class="hljs-string">''</span>,
      <span class="hljs-string">'To'</span>: <span class="hljs-keyword">this</span>.email,
      <span class="hljs-string">'Subject'</span>: <span class="hljs-string">'Balajahe CCTV: '</span> + subject,
      <span class="hljs-string">'Content-Type'</span>: mime_type,
      <span class="hljs-string">'Content-transfer-encoding'</span>: <span class="hljs-string">'base64'</span><font></font>
   }<font></font>
   <span class="hljs-keyword">let</span> head = <span class="hljs-string">''</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(headers)) head += k + <span class="hljs-string">': '</span> + v + <span class="hljs-string">'\r\n'</span>
   <span class="hljs-keyword">const</span> request = gapi.client.gmail.users.messages.send({
      <span class="hljs-string">'userId'</span>: <span class="hljs-string">'me'</span>,
      <span class="hljs-string">'resource'</span>: { <span class="hljs-string">'raw'</span>: btoa(head + <span class="hljs-string">'\r\n'</span> + body) }<font></font>
   })<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {<font></font>
      request.execute(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
         <span class="hljs-keyword">if</span> (!res.code) <font></font>
            resolve() <font></font>
         <span class="hljs-keyword">else</span> <font></font>
            reject(res)<font></font>
      })<font></font>
   })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオクリップをディスクに保存します。</font><font style="vertical-align: inherit;">非表示のハイパーリンクを使用します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'a'</span>)<font></font>
URL.revokeObjectURL(a.href)<font></font>
a.href = URL.createObjectURL(chunk)<font></font>
a.download = name<font></font>
a.click()</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Webコンポーネントの世界における状態管理</font></font></h4><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">
提示されたアイデアを続けて</font><font style="vertical-align: inherit;">、私はそれを</font><font style="vertical-align: inherit;">論理的な終わりの</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不条理</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（lulzのみ）に持ち込み、状態の制御を上下逆にしました。</font><font style="vertical-align: inherit;">通常、JS変数が状態と見なされ、DOMが現在の表示のみである場合、私の場合、データソースはDOM自体であり（Webコンポーネントは存続期間の長いDOMノードであるため）、JS側でデータを使用するために、Webコンポーネントはゲッターを提供します/各フォームフィールドのセッター。</font><font style="vertical-align: inherit;">したがって、たとえば、スタイル設定で不快なチェックボックスの代わりに、単純な&lt;button&gt;が使用され、ボタンの「値」（trueが押され、falseが押される）はクラス属性の値であり、次のようにスタイルを設定できます。</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-tag">button</span><span class="hljs-selector-class">.true</span> {<span class="hljs-attribute">background-color</span>: red}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のような値を取得します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">get</span> <span class="hljs-title">detecting</span>() { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'#detecting'</span>).className === <span class="hljs-string">'true'</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは生産性を落とすための良い方法なので、これを本番環境で使用することはお勧めできません。</font><font style="vertical-align: inherit;">仮想DOMも無料ではありませんが、ベンチマークは行いませんでした。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オフラインモード</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、小さなPWAを追加します。つまり、</font><font style="vertical-align: inherit;">すべてのネットワーク要求をキャッシュし、アプリケーションをインターネットにアクセスせずに動作させる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Service Worker</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">インストール</font><font style="vertical-align: inherit;">します。</font><font style="vertical-align: inherit;">小さなニュアンス-サービスワーカーに関する記事では、通常、次のアルゴリズムを提供します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インストールイベント-キャッシュの新しいバージョンを作成し、必要なすべてのリソースをキャッシュに追加します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アクティブ化イベントで-現在のバージョンを除くすべてのバージョンのキャッシュを削除します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フェッチイベントでは、まずキャッシュからリソースを取得しようとします。見つからない場合は、ネットワークリクエストを送信し、その結果をキャッシュに追加します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、このようなスキームは2つの理由で不便です。まず、ワーカーのコードで必要なすべてのリソースの最新リストを取得する必要があります。サードパーティのライブラリを使用する大規模なプロジェクトでは、アタッチされたすべてのインポート（動的なインポートを含む）を追跡するようにしてください。 2番目の問題-ファイルを変更するときは、Service Workerのバージョンを上げる必要があります。これにより、新しいWorkerのインストールと以前のWorkerの無効化が発生します。これは、ブラウザーが閉じているか開いている場合にのみ発生します。単純なページの更新は役に立ちません-古いキャッシュを持つ古いワーカーは機能します。そして、私のクライアントがブラウザのタブを永久に保持しないという保証はどこにありますか？したがって、最初にネットワークリクエストを作成し、その結果を非同期で（権限解決cache.put（ev.request、resp.clone（））を待たずに）キャッシュに追加します。ネットワークが利用できない場合は、キャッシュから取得します。一日を失うほうがいい5分後に飛ぶ©。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未解決の問題</font></font></h4><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部の携帯電話では、ニューラルネットワークが遅くなります。おそらく私の場合、COCO-SSDは最良の選択ではありませんが、私はMLの専門家ではないため、最初に聞いたものを採用しました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Base64形式ではなく、元のバイナリでGAPI経由でビデオを送信する方法の例は見つかりませんでした。</font><font style="vertical-align: inherit;">これにより、プロセッサ時間とネットワークトラフィックの両方が節約されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セキュリティがわかりませんでした。</font><font style="vertical-align: inherit;">ローカルデバッグの目的で、localhostドメインをGoogleアプリケーションに追加しましたが、誰かがアプリケーションキーを使用してスパムを送信し始めた場合、Googleはキー自体または送信者のアカウントをブロックしますか？</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フィードバックに感謝します。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github上のソース。</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご清聴ありがとうございました。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja491994/index.html">CocoapodsからSwift Package Managerへの移行</a></li>
<li><a href="../ja491996/index.html">C ++のコルーチンの詳細</a></li>
<li><a href="../ja492000/index.html">非常に最初の製品。バーンアウト</a></li>
<li><a href="../ja492002/index.html">光を吸収する翼：スーパーブラックバタフライの秘密</a></li>
<li><a href="../ja492004/index.html">プログラマーからマネージャーに成長する方法（「海の愛人になりたい」）</a></li>
<li><a href="../ja492008/index.html">ITモチベーション調査の結果：開発者は自分の仕事に満足していますか？</a></li>
<li><a href="../ja492010/index.html">設計システムのダークサイドとそれをどうするか</a></li>
<li><a href="../ja492012/index.html">Gyenno安定化調理器具は最大80％の振戦を補償します</a></li>
<li><a href="../ja492016/index.html">ABPおよびすべて、すべて、すべて：データセンターへの自動予約エントリー</a></li>
<li><a href="../ja492018/index.html">速度の超過：高度道路交通システムの分野におけるリスクと脆弱性</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>