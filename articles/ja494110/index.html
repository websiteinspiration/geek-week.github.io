<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎯 🚼 👩‍👧‍👧 JavaScriptとUIのプロパティベースのテスト：自動テストへの珍しいアプローチ 🍄 👨🏽‍🔬 🚢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Falcon Heavy Demo Mission
 
 Writingテストは退屈です。そして、退屈なことは常に遅れています。私の名前はナジムガファロフです。私は Mail.ru Cloud Solutionsのインターフェース開発者です。この記事では、自動化されたテストへの少し変わったアプローチ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>JavaScriptとUIのプロパティベースのテスト：自動テストへの珍しいアプローチ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/494110/"><img src="https://habrastorage.org/webt/cv/a8/98/cva898pabv5cwmeqrewsi_27lry.jpeg" alt="エロンムスクのテスラロードスター"><br>
<i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falcon Heavy Demo Mission</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Writingテストは退屈です。</font><font style="vertical-align: inherit;">そして、退屈なことは常に遅れています。</font><font style="vertical-align: inherit;">私の名前はナジムガファロフです。私は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mail.ru Cloud Solutionsの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェース開発者です。</font><font style="vertical-align: inherit;">この記事では、自動化されたテストへの少し変わったアプローチを紹介します。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">従来のテストの何が問題で、何をすべきか</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、次のような加算関数があるとします。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">a, b</span>) </span>{
   <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは皆、単体テストの重要性を理解しています。</font><font style="vertical-align: inherit;">この関数のテストを書いてみましょう：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> {equal} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>)<font></font>
<font></font>
<span class="hljs-keyword">const</span> actual = sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">const</span> expected = <span class="hljs-number">3</span><font></font>
<font></font>
equal(actual, expected)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力には1と2を渡し、出力には3を期待します。すべてが単純です-これは、例に基づく古典的な単体テスト、いわゆる例ベースのテストです。</font><font style="vertical-align: inherit;">テストはうまくいきました、誰もが幸せです、あなたは本番にロールすることができます。</font><font style="vertical-align: inherit;">しかし、あなたの同僚、すばらしいエンタープライズプログラマーが活躍します。</font><font style="vertical-align: inherit;">かつて彼はあなたの合計関数が必要でしたが、何らかの理由で少し調整することにしました：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">a, b</span>) </span>{
 <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードにはいくつかの問題がありますが、一方で、すべてのテストに合格し、TDDは、テストに合格するための最小限のコードを記述する必要があることを教えてくれます。</font><font style="vertical-align: inherit;">これは本当です。</font><font style="vertical-align: inherit;">10代の怒りを克服して、別のテストを作成します-4と8に合格し、12を期待します。</font></font><br>
<br>
<pre><code class="javascript hljs">equal(<font></font>
 sum(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>),
 <span class="hljs-number">12</span><font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、エンタープライズプログラマーは落ち着きません。</font><font style="vertical-align: inherit;">テストが失敗しないように、合計関数をもう一度修正します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">a, b</span>) </span>{
 <span class="hljs-keyword">if</span> (a == <span class="hljs-number">4</span> &amp;&amp; b == <span class="hljs-number">8</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>
 <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに多くの例をテストスイートに追加でき、これは無限に続きます。</font><font style="vertical-align: inherit;">この瞬間、あなたは「なぜ彼らは彼を雇っただけなのですか？」と考えますが、どこへも行きません。</font><font style="vertical-align: inherit;">あなたは秘密の武器を解放します-ランダムに：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> a = <span class="hljs-built_in">Math</span>.random()
<span class="hljs-keyword">const</span> b = <span class="hljs-built_in">Math</span>.random()
<span class="hljs-keyword">const</span> actual = sum(a, b)
<span class="hljs-keyword">const</span> expected = a + b<font></font>
<font></font>
equal(actual, expected)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これですべてが正常になりましたが、このようなテストの大きな問題は、テストコードで関数の実装を複製することです。</font><font style="vertical-align: inherit;">つまり、ある実装を使用して別の実装をテストします。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これで、最新に保つ必要がある同じ関数の2つの実装ができました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明らかに、総和関数はかなり原始的ですが、コードが総和よりも複雑なものを実行する場合を想像してください。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、この方法でコードをテストすると、2組の入力データのみでテストしたので、これはかなり賢いことがわかります。</font></font><br>
<br>
<pre><code class="javascript hljs">equal( sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), <span class="hljs-number">3</span> )<font></font>
equal( sum(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>), <span class="hljs-number">12</span> )
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このテストは、コードがこれら2つのケースでのみ正しく機能することを示しています。負の数や浮動小数点数などの境界ケースをテストするのが良いことだと私たちの最高の人は認識しています。しかし、これはまだ開発者の偏見を反映しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しますが、のろわれたエンタープライズプログラマー（地獄からのエンタープライズ開発者）には問題があります。この用語は</font><font style="vertical-align: inherit;">、F＃の有名な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポピュラライザ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">である</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Scott Vlashin</font></a><font style="vertical-align: inherit;">によって導入されました</font><font style="vertical-align: inherit;">。エンタープライズプログラマーは非現実的だと思うかもしれません。健康な会社では、一人の普通の人が機能を破壊することはありませんが、多くの場合、私たち自身がこのように行動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A + Bよりもはるかに複雑な関数を記述します。実装の過程で、一般的にではなく、特定の特定のケースで機能するコードを記述できます。</font><font style="vertical-align: inherit;">これは悪意によるものではなく、無意識のうちに無意識と失明によるものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで何ができるでしょうか。</font><font style="vertical-align: inherit;">考えましょう。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A + B</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
AまたはBのテストを結ぶことは意味がありません。中央にあるもの、つまりプラス記号自体をテストする必要があります。</font><font style="vertical-align: inherit;">つまり、入力と出力ではなくプロパティに焦点を当てたテストを作成する必要があります。</font><font style="vertical-align: inherit;">これらのプロパティは、適切な実装のためにtrueでなければなりません。</font><font style="vertical-align: inherit;">したがって、総和の特性について考えてみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可換性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
学校のカリキュラムによると、私たちはこの性質を知っています。「金額は、用語の場所の変更から変化しません。</font><font style="vertical-align: inherit;">つまり、加算にはシフトの特性があります-可換性。</font><font style="vertical-align: inherit;">実装がこのプロパティに一致することを確認するテストを書いてみましょう：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> actual = sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">const</span> expected = sum(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<font></font>
<font></font>
equal(actual, expected)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このテストの良い点は、特別なマジックナンバーだけでなく、あらゆる入力で機能することです。</font><font style="vertical-align: inherit;">このようなことを妨げるものは何もありません。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> rand = <span class="hljs-built_in">Math</span>.random
<span class="hljs-keyword">const</span> [n1, n2] = [ rand(), rand() ]<font></font>
<font></font>
<span class="hljs-keyword">const</span> actual = sum( n1, n2 )
<span class="hljs-keyword">const</span> expected = sum( n2, n1 )<font></font>
<font></font>
equal(actual, expected)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの数値の加算は毎日行うものではありませんが、同様のアプローチを数学演算だけでなく、実際のWebサービス、データベース、さらにはインターフェースのテストにも使用できます。</font><font style="vertical-align: inherit;">したがって、次の2つの数値の除算の例：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">div</span> (<span class="hljs-params">dividend, divisor</span>) </span>{
 <span class="hljs-keyword">return</span> dividend / divisor<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィキペディアに行くと、部門</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の右側に分配</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特性</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">があることがわかりました</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">つまり、2つの数値の合計をある除数で除算することは、それらを個別に除算することと同じです。</font><font style="vertical-align: inherit;">これをテストしてみましょう。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> [n1, n2, n3] = [rand(), rand(), rand()]<font></font>
<font></font>
<span class="hljs-keyword">const</span> left = div(n1 + n2, n3)
<span class="hljs-keyword">const</span> right = div(n1, n3) + div(n2, n3)<font></font>
<font></font>
equal(left, right)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今度はこのテストをループで何度も実行し、忍耐力をもって、次の入力データの組み合わせを取得します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> [n1, n2, n3] = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ゼロでゼロを除算するとNaNが得られるため、テストは失敗します。</font></font><br>
<br>
<pre><code class="javascript hljs">assert.js:<span class="hljs-number">85</span>
 <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(obj);<font></font>
 ^<font></font>
<font></font>
AssertionError [ERR_ASSERTION]: <span class="hljs-literal">NaN</span> == <span class="hljs-literal">NaN</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ご存知のように、NaNはNaNと等しくありません。</font><font style="vertical-align: inherit;">これは通常のJavaScriptの動作ですが、除算関数でゼロをチェックする必要があることがわかりました。</font><font style="vertical-align: inherit;">テストをさらに1サイクルでスピンし、毎回ランダムデータの新しい部分を生成します。</font><font style="vertical-align: inherit;">ある時点で、次の組み合わせが得られます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> [n1, n2, n3] = [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-347</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてテストは再び落ちる：</font></font><br>
<br>
<pre><code class="javascript hljs">assert.js:<span class="hljs-number">85</span>
 <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(obj);<font></font>
 ^<font></font>
<font></font>
AssertionError [ERR_ASSERTION]:<font></font>
<span class="hljs-number">-0.008645533141210375</span> == <span class="hljs-number">-0.008645533141210374</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、</font><font style="vertical-align: inherit;">浮動小数点数</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の丸め</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">不正確さです</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">つまり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">通常の制限です</font></a><font style="vertical-align: inherit;">が、入力データを生成すると、これらの制限が明確になります。</font><font style="vertical-align: inherit;">ここで、関数では、明示的な丸めまたは計算エラーを削減するアルゴリズム（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カハンおばあちゃん</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズムなど）について考える必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定期的にテストを書いたように見えますが、私たちの想像力から魔法の価値はありません。</font><font style="vertical-align: inherit;">任意の値を使用し、さまざまな入力データに対して何度もテストを実行する機会を得て、仕様自体、つまり関数の動作を確認します。単一の例での動作ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはプロパティベースのテストです。</font><font style="vertical-align: inherit;">これは次のことを組み合わせたものです。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初に、入力データについて説明します-どのランダムデータを生成する必要があるかをシステムに伝えます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、予想されるプロパティ-テストに合格するためのいくつかの条件について説明します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、このテストを何度も何度も実行します。</font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティを識別する方法は？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の機能のプロパティを特定するには、最初に要件を定式化する必要があります。</font><font style="vertical-align: inherit;">このようなテストでは、ランダムなデータを生成する必要さえありません。</font><font style="vertical-align: inherit;">特定の例のプロパティを確認できます。たとえば、非常に異なる値、一部の境界ケースなどです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、最初</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、指定したセットで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数が</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">同一である</font></a><font style="vertical-align: inherit;">ことを確認します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">つまり、すべての有効な値で正しく機能します。</font></font><br>
<br>
<math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>(</mo><mi mathvariant=&quot;normal&quot;>&amp;#x2200;</mi><mi>x</mi><mo>&amp;#x2208;</mo><mi>X</mi><mo stretchy=&quot;false&quot;>)</mo><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="14.137ex" height="2.634ex" viewBox="0 -809.3 6086.6 1134.2" role="img" focusable="false" style="vertical-align: -0.755ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhiPeAnOVqWNaSx86ISHi63McToFAQ#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhiPeAnOVqWNaSx86ISHi63McToFAQ#MJMAIN-2200" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhiPeAnOVqWNaSx86ISHi63McToFAQ#MJMATHI-78" x="946" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhiPeAnOVqWNaSx86ISHi63McToFAQ#MJMAIN-2208" x="1796" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhiPeAnOVqWNaSx86ISHi63McToFAQ#MJMATHI-58" x="2741" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhiPeAnOVqWNaSx86ISHi63McToFAQ#MJMAIN-29" x="3594" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhiPeAnOVqWNaSx86ISHi63McToFAQ#MJMATHI-50" x="3983" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhiPeAnOVqWNaSx86ISHi63McToFAQ#MJMAIN-28" x="4735" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhiPeAnOVqWNaSx86ISHi63McToFAQ#MJMATHI-78" x="5124" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhiPeAnOVqWNaSx86ISHi63McToFAQ#MJMAIN-29" x="5697" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi mathvariant="normal">∀</mi><mi>x</mi><mo>∈</mo><mi>X</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1">(\forall x\in X) P(x)</script><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、手動でこれらのXを置き換えることによってサイクルでテストを実行することを禁じている人はいませんが、落ちたテストを再現する確実な方法が必要です。</font><font style="vertical-align: inherit;">幸い、このための既製のフレームワークがあります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フレームワーク</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご存知のように、プログラミングのすべての最高は、もともとHaskellの世界で発明されました。</font><font style="vertical-align: inherit;">20年前、プロパティテストのアイデアが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QuickCheck</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フレームワークに実装されました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、Haskellエコシステムでのこの形式のテストが実際に優勢です。</font><font style="vertical-align: inherit;">JavaScriptにはいくつかのライブラリがありますが、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSVerify</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast-checkの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2つに焦点を当て</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> jsc = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jsverify'</span>)<font></font>
<font></font>
jsc.assertForall(<font></font>
 jsc.integer, jsc.integer,<font></font>
 (a, b) =&gt; a + b === b + a<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、最初に説明した、加算の並進プロパティの簡単なテストです。私たちは型なし言語を持っているので、どういうわけか私たちが期待する引数をフレームワークに伝える必要があります。ここでは、2つの数値が必要で、最後の引数で述語を渡していると言います。デフォルトでは、JSVerifyはテストを100回実行し、そのたびに新しい入力値のペアを生成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
減算の再配置プロパティを確認してみましょう。もちろん、減算にはそのような特性がないので、エラーのあるオブジェクトを取得してそれを結論付けます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> subtractionIsCommutative = jsc.checkForall(<font></font>
 jsc.integer, jsc.integer,<font></font>
 (a, b) =&gt; a - b === b - a<font></font>
)<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(subtractionIsCommutative)<font></font>
<font></font>
{<font></font>
 <span class="hljs-attr">counterexample</span>: [ <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ],
 <span class="hljs-attr">tests</span>: <span class="hljs-number">1</span>,
 <span class="hljs-attr">shrinks</span>: <span class="hljs-number">4</span>,
 <span class="hljs-attr">rngState</span>: <span class="hljs-string">'0e168f30eac572b94d'</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムは、反例0と1での最初のテストの後に落ちたと言います。RngStateは、乱数ジェネレーターの状態です。</font><font style="vertical-align: inherit;">この場合、テストデータはランダムに決定されます。</font><font style="vertical-align: inherit;">乱数ジェネレーターがシードを表示します。シードをテストランナーに差し込んで、倒れたケースを再現できます。</font><font style="vertical-align: inherit;">デバッグに便利で、CI / CDの再現性に役立ちます。</font></font><br>
<br>
<pre><code class="bash hljs">mocha test.js --jsverifyRngState 0e168f30eac572b94d</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSVerifyにはタイプ用の小さなDSLがあり、レコードを少し減らすことができます。</font><font style="vertical-align: inherit;">これは便利な場合があります。たとえば、カスタムタイプが必要な場合は、次のように書く方が簡単です。</font></font><br>
<br>
<pre><code class="javascript hljs">jsc.assert(jsc.forall(
 <span class="hljs-string">'{ name: asciinestring; age: nat }'</span>,<font></font>
 (obj) =&gt; {<font></font>
     <span class="hljs-built_in">console</span>.log(obj) <span class="hljs-comment">// { name: '9lfpy', age: 34 }</span>
     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
 }<font></font>
))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なんでそうなの：</font></font><br>
<br>
<pre><code class="javascript hljs">jsc.record({
 <span class="hljs-attr">name</span>: jsc.asciinestring,
 <span class="hljs-attr">age</span>: jsc.nat,<font></font>
})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご希望の方法を選択してください。</font><font style="vertical-align: inherit;">したがって、バックエンドから取得したオブジェクトなど、独自のタイプを生成できます。</font><font style="vertical-align: inherit;">十分な組み込みジェネレータがない場合は、簡単に独自のジェネレータを作成できます。</font><font style="vertical-align: inherit;">文字列だけでなく、メールアドレスを含む文字列が必要だとします。</font><font style="vertical-align: inherit;">次のようにして生成できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> emailGenerator = jsc<font></font>
 .asciinestring.generator<font></font>
 .map(<span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${str}</span>@example.com`</span>)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実生活では</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを実際の生活にどのように適用できるかを見てみましょう。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クエリ文字列</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリは、</font><font style="vertical-align: inherit;">毎週600万ダウンロードされています。</font><font style="vertical-align: inherit;">このパッケージは、4,000を超える他のパッケージの依存関係にリストされています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クエリ文字列は、1つの単純なことを行います。URL文字列をオブジェクトに解析し、逆に、オブジェクトからURLまたはその一部を生成できます。</font></font><br>
<br>
<pre><code class="javascript hljs">queryString.parseUrl(<span class="hljs-string">'https://foo.bar?foo=bar'</span>)
<span class="hljs-comment">//=&gt; {url: 'https://foo.bar', query: {foo: 'bar'}}</span><font></font>
<font></font>
queryString.stringify({<span class="hljs-attr">b</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>})
<span class="hljs-comment">//=&gt; 'b=1&amp;c=2&amp;a=3'</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然のことながら、このライブラリーは、多くの古典的な例ベースのテストでカバーされています。合計400行</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のテストコード</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、いくつのテストが記述されていても、すべてのオプションを考慮することはできません。新しい例を発明する代わりに、高速チェックライブラリの作成者は、ライブラリ</font><font style="vertical-align: inherit;">のプロパティに焦点を当てた</font><font style="vertical-align: inherit;">単一の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を作成しました。</font></font><br>
<br>
<pre><code class="javascript hljs">fastCheck.property(<font></font>
 queryParamsArbitrary, optionsArbitrary,<font></font>
 (object, options) =&gt; deepEqual(<font></font>
   queryString.parse(queryString.stringify(object, options), options),<font></font>
   object<font></font>
 )<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クエリ文字列は古典的な反転です。つまり、すべてのオブジェクトをクエリ文字列に変換する必要があります。この文字列が解析される場合は、元のオブジェクトを取得する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご存知のように、彼はすぐに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バグを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見つけました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼は同じアプローチを使用して悪名高い左パッドライブラリをテストし、</font><font style="vertical-align: inherit;">文字列など</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、Unicode</font></a><font style="vertical-align: inherit;">メイン</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">プレーン</font></a><font style="vertical-align: inherit;">以外の文字を含む文字列の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バグ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">発見しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
しかし、どのようにしてバグを見つけるプロパティを簡単に推測できたのでしょうか。</font><font style="vertical-align: inherit;">すべて彼は人気のある物件に精通しているからです。</font><font style="vertical-align: inherit;">それらも見てみましょう。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反転</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは、トールキンのストーリー「ゼアアンドバック」を称えるビルボテストとしても知られています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暗号化機能があるとしましょう。</font><font style="vertical-align: inherit;">結果に復号化が適用されると、最初のメッセージが表示されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> string = <span class="hljs-string">'ANY_STRING'</span>
<span class="hljs-keyword">const</span> encrypted = encrypt(string)<font></font>
<font></font>
expect( decrypt(encrypted) ).toBe( string )</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのメッセージを暗号化したかは関係ありません。どの行でもかまいません。</font><font style="vertical-align: inherit;">したがって、それを生成できます。</font><font style="vertical-align: inherit;">同じことは、シリアライゼーション-デシリアライゼーション、エンコーディング-デコーディング、ロスレス圧縮などにも使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、クエリ文字列をテストしたときに見たプロパティです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj = {<span class="hljs-attr">any</span>: <span class="hljs-string">'object'</span>}<font></font>
<font></font>
_.isEqual(<font></font>
   <span class="hljs-built_in">JSON</span>.parse( <span class="hljs-built_in">JSON</span>.stringify(obj) ),<font></font>
   obj,<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
書き込み/読み取り、挿入/検索も、厳密な反転ではない場合でも、このパターンに一致します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可逆性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、反転の特殊なケースは往復です。</font><font style="vertical-align: inherit;">これは、リバーシブル関数を使用して2回適用する場合です。</font></font><br>
<br>
<pre><code class="javascript hljs">_.isEqual(<font></font>
 [...array].reverse().reverse(),<font></font>
 array,<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、関数が配列を反転する場合、内部に任意のデータを含む配列を生成し、2回反転すると、結果の結果は元の配列に対応するはずです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不変性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不変条件の検索とは、関数を適用しても変化しないものを検索することです。</font><font style="vertical-align: inherit;">ソート機能があるとしましょう。</font><font style="vertical-align: inherit;">配列にソートを適用する場合、この配列の長さは変更されません。</font></font><br>
<br>
<pre><code class="javascript hljs">equal(<font></font>
 [...array].sort().length,<font></font>
 array.length,<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、配列の要素も変更しないでください。順序を変更できますが、それら自体は変更されません。元の配列の各要素は、並べ替えられた配列で検出される必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サイズ、長さ、内容は、関数が変更すべきでないものを変更しないことを確認するための優れた機能です。</font><font style="vertical-align: inherit;">通常、このようなチェックだけでは不十分ですが、他のプロパティに対するカウンターチェックとして機能することがよくあります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">べき等</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、べき等プロパティに。</font><font style="vertical-align: inherit;">関数を再適用すると、このプロパティは最初に使用したときと同じ結果になります。</font><font style="vertical-align: inherit;">たとえば、配列を1回ソートした場合、再ソートしても何も変わりません。</font></font><br>
<br>
<pre><code class="javascript hljs">_.isEqual(<font></font>
 [...array].sort().sort(),<font></font>
 array.sort(),<font></font>
)</code></pre><br>
<pre><code class="javascript hljs">string.padStart(<span class="hljs-number">10</span>) === string.padStart(<span class="hljs-number">10</span>).padStart(<span class="hljs-number">10</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一意の値のフォーマット、検索、正規化、セットへの既存の要素の追加-これらのすべての操作は、再適用しても何も変更しないでください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">証明するのが難しく、簡単に確認できます。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この特性は通常、迷路の例で示されます。</font><font style="vertical-align: inherit;">迷路から抜け出す方法を見つけるのは難しいですが、関数が抜け出す方法を知っている場合は、テストするのは簡単です。指示に従うだけです。</font><font style="vertical-align: inherit;">結果として、それは出口へと私たちを導くはずです。</font><font style="vertical-align: inherit;">最短経路はわかりませんが、少なくとも、これが出口に至る正しい経路であると確信しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの例は、並べ替え関数です。</font><font style="vertical-align: inherit;">配列を正しくソートすることは非常に困難です。</font><font style="vertical-align: inherit;">しかし、並べ替えの結果は簡単に確認できます。配列の要素を順番に取得して、後続の要素と比較する必要があります。</font><font style="vertical-align: inherit;">昇順でソートする場合、現在の要素は常に次の要素よりも小さい（またはそれに等しい）必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リファレンス実装</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは、テストオラクルとも呼ばれます。</font><font style="vertical-align: inherit;">同じことを行う2つの関数があるとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、独自の並べ替え機能を実装することがありました。</font><font style="vertical-align: inherit;">同時に、JavaScriptにソート関数が組み込まれており、これを参照として使用します。</font><font style="vertical-align: inherit;">テストオラクルのアイデアは、私たちのソートの結果をリファレンスの結果と比較することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ランダムデータを生成し、それを両方の関数にフィードして、結果が一致することを確認できます。</font></font><br>
<br>
<pre><code class="javascript hljs">_.isEqual(<font></font>
 [...array].sort(),<font></font>
 fastestSortingAlgorithm(array),<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、古いコードをリファクタリングする場合に適したテンプレートです。</font><font style="vertical-align: inherit;">新しい実装が、古い実装と同じ結果を生成することを確認できます。</font><font style="vertical-align: inherit;">この場合のテストオラクルは、リファレンス実装の対応プロパティをチェックします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">落ちないで</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、少なくとも関数が落ちないという性質があります。</font><font style="vertical-align: inherit;">このタイプのテストはファジングと呼ばれ、不正またはランダムなデータをアプリケーション入力に送信し、システムがクラッシュするかどうか、フリーズ、内部ロジック違反、または予期しない動作がないかどうかを確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
APIがあるとしましょう。どのペンを引っ張るか、どのデータを転送するかは関係ありません。いずれの場合も、サーバーは500を応答すべきではありません。このプロパティ自体はほとんど意味がありませんが、開始点としては機能します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UIテスト</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
商品のバスケットが入ったオンラインストアがあるとします。テストする必要があります。</font><font style="vertical-align: inherit;">最初に、使用可能なアクションを決定する必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バスケットに商品を追加できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">商品を取り除く。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空のごみ箱。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、プロパティを表示します。控えめに言って、商品の数量を負の数量にすることはできません：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バスケット&gt; = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。同時に、バスケット内の商品の数はカタログ内にありません：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バスケット&lt;=カタログ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。そして、バスケット全体の合計は、その中で最も高価な製品の価格を下回ることはできません：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sum（バスケット）&gt; = max（グッズ）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、サイクルで有効な一連のアクションを何度も生成し、各ステップの後にすべてのプロパティを確認します。相対的に言えば、ランダムな順序で、バスケットに何かを何度も追加したり、何かを削除したり、空にしたりします。そして、各ステップの後に、すべてのプロパティの真実を確認してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなテストを行うと、通常のe2eテストと同様に、ユーザーインターフェイスを使用してボタンをクリックできます。</font><font style="vertical-align: inherit;">ただし、プレゼンテーションがモデルの純粋な機能であるフレームワークが前面にある場合は、モデルを簡単に操作できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは、Spotify開発者</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がプレイリスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">テストする</font></a><font style="vertical-align: inherit;">ために</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">採用しました</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティベースのテストの長所と短所</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長所</font></font></h3><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティベースのテストは、多くの例ベースのテストに取って代わります。つまり、コードを少なくして、より多くのテストを取得できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そのようなテスト自体は、あなたが考えなかったかもしれない極端なケースを見つけることができます：ゼロによる除算、絵文字付きの行など。</font></font></li>
<li>  ,            — -    ,   .     ,   .</li>
<li>    ,  ,     ,       .</li>
<li>      .     -,         ,   .</li>
</ol><br>
<h3></h3><br>
<ol>
<li>     .       .</li>
<li>     ,       . Property-based    ,  ,   .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各テストは100回実行する必要があるため、テストの実行時間はわずかに増加します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このようなテストは、誤った安心感を与えます。</font><font style="vertical-align: inherit;">関数のいくつかのプロパティを識別したとします。これにより、実装が正しいことを確信できます。</font><font style="vertical-align: inherit;">ただし、プロパティが必要な場合がありますが、十分ではありません。</font><font style="vertical-align: inherit;">たとえば、乗算関数は加算と同じ方法で移動できるという特性がありますが、これらの関数はわずかに異なることを行います。</font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古典的なテストを拒否するべきではありませんが、プロパティに基づいたテストとそれらを組み合わせることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、例に基づく古典的なテストで基本的な機能をカバーでき、重要な機能をプロパティテストでさらにカバーできます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HolyJS Piter 2019</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panda Meetup＃22</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からのレポートのテキスト版です</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<hr><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他に読むべきもの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技術的負債がプロジェクトをいかに殺しているか</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独立した開発者としての私の2年目</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デジタルトランスフォーメーションニュースを掲載した電報チャネル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja494096/index.html">イントラネットの展開。経験、間違い、推奨事項</a></li>
<li><a href="../ja494098/index.html">Jetbrains KTorおよびR2DBCの例に関する反応データへの命令的アプローチ</a></li>
<li><a href="../ja494100/index.html">ITスペシャリストをトレーニングするための教育センターの理想的なモデルを作成するために必要なもの</a></li>
<li><a href="../ja494106/index.html">健康な人のためのページオブジェクトクラスを作成するためのヒント</a></li>
<li><a href="../ja494108/index.html">パーソナライズされたインターフェイス。パート1.コンセプトの長所と短所</a></li>
<li><a href="../ja494114/index.html">数を減らし、react-redux、redux-sagaのコードを読みやすくする方法</a></li>
<li><a href="../ja494118/index.html">COVID-19 Telegram-bot // FAQの質問に自動的に回答します</a></li>
<li><a href="../ja494124/index.html">8ビットコンピューターの組み立て：チップの数を6に減らす方法</a></li>
<li><a href="../ja494126/index.html">トップサイエンス。2月のメディア10：カニのゾンビフェミニスト、先史時代のサンショウウオおよび誇張されたアルコール依存症</a></li>
<li><a href="../ja494128/index.html">ハックスペースニューロン-ハッカーがモスクワで集まる場所</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>