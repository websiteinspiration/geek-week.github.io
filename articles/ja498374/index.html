<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐯 🔘 💯 GPUコンピューティング-なぜ、いつ、どのように。さらにいくつかのテスト 🍱 ✌️ 🦀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ビデオカードではおもちゃを遊ぶだけでなく、ニューラルネットワークのトレーニング、暗号通貨の記憶、科学計算など、ゲームに関係のないこともできることは誰もが以前から知っています。どのようにそれはあなたがそれを読むことができ、起こっここでは、私はの話題に触れてみたかったGPUがに興味があるかもしれなぜ普通...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>GPUコンピューティング-なぜ、いつ、どのように。さらにいくつかのテスト</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dbtc/blog/498374/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオカードではおもちゃを遊ぶだけでなく、ニューラルネットワークのトレーニング、暗号通貨の記憶、科学計算など、ゲームに関係のないこともできることは誰もが以前から知っています。どのようにそれはあなたがそれを読むことができ、起こっ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここでは</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、私はの話題に触れてみたかった</font></font><i><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUがに興味があるかもしれなぜ</font></font></strong></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">普通のプログラマ（GameDevに関連していない）</font></font><i><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのようにアプローチする</font></font></strong></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことに多くの時間を費やすことなく、GPUの開発を、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するかどうかこの方向に目を向け、</font><strong><font style="vertical-align: inherit;">得られる利益を「指先で把握</font></strong><font style="vertical-align: inherit;">」</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">してください。</font></font></strong>&nbsp;<br>
<br>
<div style="text-align:center;"><img width="800" src="https://habrastorage.org/getpro/habr/post_images/3ee/2ac/893/3ee2ac8936a685e6993966cfa40f53fd.jpg"></div><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は</font><font style="vertical-align: inherit;">、HighLoad ++ </font><font style="vertical-align: inherit;">での私の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレゼンテーション</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">基づいて書かれました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">主にNVIDIAが提供するテクノロジーについて説明します。</font><font style="vertical-align: inherit;">私は製品を宣伝する目的はありません。単に例として挙げただけで、競合するメーカーでも同様のものが見つかることは確かです。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUを信頼する理由</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのプロセッサを異なる基準に従って比較できます。おそらく最も一般的なのは、コアの頻度と数、キャッシュのサイズなどですが、最終的に、プロセッサが単位時間あたりに実行できる操作の数、これがどのような種類の操作であるかに関心がありますが、別の質問です一般的なメトリックは、1秒あたりの浮動小数点演算の数-フロップです。ウォームとソフトを比較したい場合、そして私たちのケースではGPUとCPUを比較したい場合、このメトリックは便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のグラフは、プロセッサとビデオカードの時間経過に伴うこれらの同じフロップの増加を示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e2/048/3f5/5e20483f59e87b0a395b0fae0e6495c5.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（データはオープンソースから収集され、2019年から20年のデータはありません。すべてがそれほど美しいわけ</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ではないためです</font><i><font style="vertical-align: inherit;">が、GPUがまだ勝っています）</font></i><font style="vertical-align: inherit;">まあ、それは魅力的ですね。</font><font style="vertical-align: inherit;">すべての計算をCPUからGPUにシフトし、8倍の最高のパフォーマンスを実現します！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、もちろん、すべてがそれほど単純なわけではありません。</font><font style="vertical-align: inherit;">すべてを取得してGPUに転送することはできません。その理由については、後で詳しく説明します。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUアーキテクチャとCPUとの比較</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CPUのアーキテクチャと基本的な要素をよく知っている多くの写真を紹介します。</font></font><br>
<br>
<div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/df0/8c2/4c3/df08c24c3fe92cd97356670729c318cd.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUコア</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
何が特別なのですか？</font><font style="vertical-align: inherit;">1つのコアと多数の補助ブロック。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、GPUアーキテクチャを見てみましょう。</font></font><br>
<br>
<div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/0fe/138/0cc/0fe1380ccbb321b289d16e39a499009a.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUコア</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ビデオカードには多くの処理コア（通常は数千）がありますが、それらはブロックにまとめられています。NVIDIAビデオカード（通常はそれぞれ32）には、次のような共通の要素があります。と登録。 GPUコアと論理要素のアーキテクチャーは、CPU上よりもはるかに単純です。つまり、プリフェッチャーやブランチプレディクターなどはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、これらはCPUとGPUのアーキテクチャの違いの重要なポイントであり、実際には、制限を課すか、逆に、GPUで効果的に読み取ることができる可能性を広げます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はもう1つ重要な点について触れませんでした。通常、ビデオカードとプロセッサはメモリを相互に「破壊」せず、ビデオカードにデータを書き込んで結果を読み取りません。これらは個別の操作であり、システムの「ボトルネック」となる可能性があります。ポンプ時間とサイズのグラフデータは記事の後半に記載されています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUの制限と機能</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアーキテクチャは実行可能なアルゴリズムにどのような制限を課しますか：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUで計算している場合、1つのコアのみを選択することはできません。コアのブロック全体が割り当てられます（NVIDIAの場合は32）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのコアは同じ命令を実行しますが、データは異なります（これについては後で説明します）。このような計算は、単一命令複数データまたはSIMDと呼ばれます（NVIDIAはその改良を導入しています）。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロジックブロックと汎用レジスターの比較的単純なセットのため、GPUは実際には分岐を嫌い、実際にはアルゴリズムの複雑なロジックを好みません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはどのような機会を開きます：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際、これらの同じSIMD計算の高速化。</font><font style="vertical-align: inherit;">最も単純な例は、行列の要素ごとの加算です。それを分析してみましょう。</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古典的なアルゴリズムのSIMD表現への削減</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変換</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AとBの2つの配列があり、配列Bの要素を配列Aの各要素に追加する必要があります。以下はCの例ですが、この言語を話さない人にもわかると思います。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *A, <span class="hljs-keyword">float</span> *B, size)</span>
</span>{ 
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) <font></font>
   { <font></font>
       A[i] += B[i]<font></font>
   } <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ループ内の要素の古典的なループバックと線形ランタイム。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、そのようなコードがGPUをどのように探すかを見てみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *A, <span class="hljs-keyword">float</span> *B, size)</span> 
</span>{ 
   <span class="hljs-keyword">int</span> i = threadIdx.x; 
   <span class="hljs-keyword">if</span> (i &lt; size) <font></font>
      A[i] += B[i] <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで既に興味深いことに、どこにも宣言していないように見えるthreadIdx変数が表示されました。はい、そのシステムは私たちに提供します。前の例では、配列が3つの要素で構成されており、3つの並列スレッドで実行したいとします。これを行うには、別のパラメーター（インデックスまたはストリーム番号）を追加する必要があります。これは、ビデオカードが行うことですが、静的変数としてインデックスを渡し、x、y、zなどの複数のディメンションを同時に処理できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つのニュアンスとして、一度に多数の並列ストリームを開始する場合は、ストリームをブロックに分割する必要があります（ビデオカードのアーキテクチャ上の機能）。最大ブロックサイズはビデオカードによって異なり、計算を実行する要素のインデックスは次のように取得する必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> i = blockIdx.x * blockDim.x + threadIdx.x; <span class="hljs-comment">// blockIdx –  , blockDim –  , threadIdx –    </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、私たちが持っているものは、同じコードを実行するが、インデックスが異なり、したがってデータ、つまり、</font><font style="vertical-align: inherit;">同じSIMD。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは最も単純な例ですが、GPUを使用する場合は、タスクを同じ形式にする必要があります。</font><font style="vertical-align: inherit;">残念ながら、これは常に可能であるとは限らず、場合によっては博士論文の対象になることもありますが、それでもなお、古典的なアルゴリズムをこの形式にすることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集計</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、SIMD表現への集計キャストがどのように見えるかを見てみましょう。</font></font><br>
&nbsp;<br>
<div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/ecd/78a/bba/ecd78abbaff0c1be8799c1337f7652f8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
n個の要素の配列があります。</font><font style="vertical-align: inherit;">最初の段階で、n / 2スレッドを開始し、各スレッドが2つの要素を追加します。</font><font style="vertical-align: inherit;">1回の反復で、配列の要素の半分を加算します。</font><font style="vertical-align: inherit;">そして、最後の2つの要素を集約するまで、ループ内で新しく作成された配列に対して同じことを繰り返します。</font><font style="vertical-align: inherit;">ご覧のとおり、配列のサイズが小さいほど、開始できる並列スレッドが少なくなります。</font><font style="vertical-align: inherit;">GPUでは、十分に大きなサイズの配列を集約することは理にかなっています。</font><font style="vertical-align: inherit;">このようなアルゴリズムは、要素の合計の計算（ちなみに、使用しているデータタイプのオーバーフローの可能性を忘れないでください）、最大値、最小値、または単に検索を行うために使用できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕分け</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、ソートはすでにかなり複雑に見えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPUで最も人気のある2つのソートアルゴリズムは次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビットニックソート</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基数ソート</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、基数ソートは依然としてより頻繁に使用されており、本番環境に対応した実装が一部のライブラリにあります。</font><font style="vertical-align: inherit;">私はこれらのアルゴリズムがどのように機能するか詳細に分析しません;興味がある人は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.codeproject.com/Articles/543451/Parallel-Radix-Sort-on-the-GPU-using-Cplusplus-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でradix-sortの説明を見つけることができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ますAMP</font></a><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://stackoverflow.com/a/26229897</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
しかし、ソートなどの非線形アルゴリズムでさえ、SIMDビューに縮小できるという考え方があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今、GPUから取得できる実数を見る前に、結局、この奇跡のテクノロジーをどのようにプログラミングするかを考えてみましょう。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どこから始めれば</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPUでのプログラミングに使用できる最も一般的な2つのテクノロジー：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opencl</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クーダ</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpenCLは、次のようなほとんどのビデオカードメーカーでサポートされている標準です。</font><font style="vertical-align: inherit;">モバイルデバイスでは、OpenCLで記述されたコードもCPUで実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C / C ++からOpenCLを使用できます。他の言語へのバインダーがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpenCLの場合、私は「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCL in Action」という本を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も気に入っていました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">また、GPUのさまざまなアルゴリズムについても説明します。</font><font style="vertical-align: inherit;">BitonicソートとRadixソート。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CUDAは、NVIDIA独自のテクノロジーとSDKです。</font><font style="vertical-align: inherit;">C / C ++で書くか、他の言語へのバインディングを使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpenCLとCUDAの比較は多少正しくありません。</font><font style="vertical-align: inherit;">1つは標準で、もう1つはSDK全体です。</font><font style="vertical-align: inherit;">それにもかかわらず、無料でNVIDIAカードでしか機能しないにもかかわらず、このテクノロジーは独自仕様であるにもかかわらず、多くの人々がビデオカードの開発にCUDAを選択しています。</font><font style="vertical-align: inherit;">これにはいくつかの理由があります。</font></font><br>
<br>
<ul>
<li>  API</li>
<li>    </li>
<li>,   GPU,      (host) </li>
<li> ,  ..  </li>
<li>   </li>
<li>  </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特別な機能には、CUDAに標準のC / C ++コードをコンパイルできる独自のコンパイラが付属しているという事実が含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が出会った中で最も包括的なCUDAブックは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Professional CUDA C Programming</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でしたが、それはすでに少し古くなっていますが、NVIDIAカードのプログラミングの技術的なニュアンスの多くに対処しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これらの本を読んだり、ビデオカード用の独自のプログラムを作成したり、テストやデバッグを行ったりして、これが自分には向かないことを発見したくない場合はどうすればよいでしょうか。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が言ったように、GPUの下での開発の複雑さを隠す多数のライブラリがあります：XGBoost、cuBLAS、TensorFlow、PyTorchなど、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">スラスト</font></a><font style="vertical-align: inherit;">ライブラリを検討します</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、他のライブラリよりも専門性が低いため、並べ替え、検索、集計などの基本的なアルゴリズムを実装し、高い確率でタスクに適用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thrustは、標準STLアルゴリズムをGPUベースのアルゴリズムで「置き換える」ことを目的とするC ++ライブラリです。</font><font style="vertical-align: inherit;">たとえば、このライブラリをビデオカードに使用して数値の配列を並べ替えると、次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">thrust::host_vector&lt;DataType&gt; <span class="hljs-title">h_vec</span><span class="hljs-params">(size)</span></span>; <span class="hljs-comment">//    </span>
<span class="hljs-built_in">std</span>::generate(h_vec.begin(), h_vec.end(), rand); <span class="hljs-comment">//   </span>
thrust::device_vector&lt;DataType&gt; d_vec = h_vec; <span class="hljs-comment">//        &nbsp;</span>
thrust::sort(d_vec.begin(), d_vec.end()); <span class="hljs-comment">//    </span>
thrust::copy(d_vec.begin(), d_vec.end(), h_vec.begin()); <span class="hljs-comment">//   ,     </span>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（例はNVIDIAのコンパイラーでコンパイルする必要があることを忘れないでください）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、thrust :: sortはSTLの類似したアルゴリズムと非常に似ています。このライブラリは、多くの困難、特にビデオカード上で実行されるサブプログラム（より正確にはカーネル）の開発を隠しますが、同時に柔軟性を奪います。たとえば、数ギガバイトのデータを並べ替える場合は、カードにデータを送信して並べ替えを開始し、並べ替えの実行中にカードにさらにデータを送信するのが合理的です。このアプローチはレイテンシ非表示と呼ばれ、サーバーマップリソースをより効率的に使用できますが、残念ながら、高レベルのライブラリを使用する場合、そのような機会は隠されたままです。しかし、プロトタイピングとパフォーマンスの測定については、それらはまったく同じです。特に推力を使用すると、データ転送が提供するオーバーヘッドを測定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小さな</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ベンチマーク</font></a><font style="vertical-align: inherit;">を書いた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GPUでさまざまな量のデータを使用していくつかの一般的なアルゴリズムを実行するこのライブラリーを使用して、結果を見てみましょう。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUアルゴリズムの結果</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPUをテストするために、Tesla k80ビデオカードを使用してAWSでインスタンスを取得しました。これは、これまでで最も強力なサーバーカード（最も強力なTesla v100）ではありませんが、最も手頃な価格で搭載されています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4992 CUDAカーネル</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24 GBのメモリ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">480 Gb /秒-メモリ帯域幅&nbsp;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CPUのテストでは、Intel XeonプロセッサCPU E5-2686 v4 @ 2.30GHzのインスタンスを使用しました</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変換</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/930/6e1/687/9306e1687be5ee95c29c8aac7b2ae337.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUとCPUでの変換実行時間（ミリ秒）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ご覧のとおり、配列要素の通常の変換は、GPUとCPUの両方でほぼ同じ時間です。</font><font style="vertical-align: inherit;">なぜ？</font><font style="vertical-align: inherit;">データをカードに送信して戻すためのオーバーヘッドは、パフォーマンスの向上全体を消費し（オーバーヘッドについては個別に説明します）、カードでの計算は比較的少ないためです。</font><font style="vertical-align: inherit;">また、プロセッサはSIMD命令もサポートしていることを忘れないでください。単純なケースでは、コンパイラがそれらを効果的に使用できます。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPUで集約がどのように効率的に行われるかを見てみましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集計</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c92/d0e/cb9/c92d0ecb96c32866000e6948f5da61f9.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUおよびCPUでの集計実行時間（ミリ秒）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
集計の例では、データ量の増加に伴い、パフォーマンスが大幅に向上しました。</font><font style="vertical-align: inherit;">また、カードのメモリに大量のデータを送り込み、1つの集計値しか取り戻されないことにも注意する必要があります。</font><font style="vertical-align: inherit;">カードからRAMにデータを転送するためのオーバーヘッドは最小限です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も興味深い例である、ソートに移りましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕分け</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fde/504/8da/fde5048da5084d1f0902c9362b21d939.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUとCPUへのソート時間（ミリ秒）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
データアレイ全体をビデオカードに送信し、その逆も同様ですが、GPU 800 MBのデータでのソートは、プロセッサーでのソートよりも約25倍高速です。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ転送オーバーヘッド</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変換の例からわかるように、GPUが適切に並列処理されるタスクでも効果的であるかどうかは必ずしも明らかではありません。</font><font style="vertical-align: inherit;">この理由は、コンピューターのRAMからビデオカードのメモリにデータを転送するためのオーバーヘッドです（ゲームコンソールでは、メモリはCPUとGPUの間で共有され、データを転送する必要はありません）。</font><font style="vertical-align: inherit;">ビデオカードの特性の1つは、カードの理論上の帯域幅を決定するメモリ帯域幅またはメモリ帯域幅です。</font><font style="vertical-align: inherit;">Tesla k80の場合は480 GB /秒、Tesla v100の場合はすでに900 GB /秒です。</font><font style="vertical-align: inherit;">また、PCI Expressバージョンとカードへのデータ転送方法の実装はスループットに影響します。たとえば、これは複数の並列ストリームで実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アマゾンクラウドのTesla k80グラフィックカードで得られた実際の結果を見てみましょう。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/798/fb5/613/798fb56139f6158566232bc6283b24e7.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データをGPUに転送し、データを並べ替えてRAMに転送する時間（ミリ秒）</font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HtoD-データを</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPU </font><font style="vertical-align: inherit;">ビデオカードに転送する</font><font style="vertical-align: inherit;">実行- </font><font style="vertical-align: inherit;">ビデオカードで</font><font style="vertical-align: inherit;">並べ替え</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DtoH-データをビデオカードからRAMにコピーする</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最初に注意することは、ビデオカードからのデータの読み取りがそこに書いてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目-ビデオカードを使用する場合、350マイクロ秒からレイテンシを取得できます。これは、一部の低レイテンシアプリケーションではすでに十分な場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下のグラフは、より多くのデータのオーバーヘッドを示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/653/b96/d18653b96af325f35fade713bdaa8dae.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データをGPUに転送し、データを並べ替えてRAMに転送するまでの時間（ミリ秒）</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーの使用</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も一般的な質問は、ゲームのビデオカードとサーバーのカードの違いです。</font><font style="vertical-align: inherit;">特性によると非常に似ていますが、価格は大きく異なります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/203/01b/741/20301b7418ee616d9611f42d2b4a8f5d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバー（NVIDIA）とゲームカードの主な違い：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">製造元の保証</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ゲームカードはサーバー用に設計されていません）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消費者向けグラフィックスカードで</font><font style="vertical-align: inherit;">起こりうる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想化の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーカード上のエラー修正メカニズムの可用性</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並列スレッドの数（CUDAコアではない）またはHyper-Qのサポート。これにより、CPUのいくつかのスレッドからカードを操作できます。たとえば、あるスレッドからカードにデータをアップロードし、別のスレッドから計算を開始できます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは、おそらく、私が見つけた主な重要な違いです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチスレッド</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオカードで最も単純なアルゴリズムを実行する方法と期待できる結果を理解したら、次の論理的な質問は、複数の並列要求を処理するときのビデオカードの動作です。答えとして、GPUでのコンピューティングの2つのグラフと、4コアと32コアのプロセッサーがあります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a1/1f6/022/0a11f6022198a582929f384be357fe43.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マトリックスが1000 x 60ミリ秒のGPUおよびCPUで数学的計算を実行するのにかかる時間</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このグラフは、1000 x 60要素のマトリックスを使用して計算を実行します。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかのプログラムストリームから</font><font style="vertical-align: inherit;">開始</font><font style="vertical-align: inherit;">され、各CPUストリームのGPU用に個別のストリームが作成されます（Hyper-Qが使用されます）。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、プロセッサはこの負荷に非常によく対応していますが、GPUごとの1つの要求のレイテンシは、並列要求の数が増えると大幅に増加します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e09/22c/7fb/e0922c7fba0ef001cca97c7a99817c83.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マトリックスが10,000 x 60ミリ秒のGPUとCPUで数学的計算を実行する時間</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
。2番目のグラフでは、計算は同じですが、マトリックスが10倍長く、そのような負荷でのGPUの動作ははるかに良好です。これらのグラフは非常に目安であり、結論付けることができます。負荷時の動作は、負荷自体の性質に依存します。プロセッサは、マトリックス計算も非常に効率的に処理できますが、ある程度は処理できます。ビデオカードの場合、計算負荷が小さい場合、パフォーマンスはほぼ直線的に低下するのが特徴です。負荷と並列スレッドの数が増えると、ビデオカードの処理能力が向上します。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまな状況でGPUがどのように動作するかを仮定することは困難ですが、ご覧のとおり、特定の条件下では、サーバーカードは複数の並列ストリームからのリクエストを非常に効率的に処理できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトでGPUを使用することを決定した場合に発生する可能性のあるいくつかの質問について説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リソース制限</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに述べたように、ビデオカードの2つの主なリソースは、コンピューティングコアとメモリです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、ビデオカードを使用するいくつかのプロセスまたはコンテナがあり、それらの間でビデオカードを共有できるようにしたいとします。</font><font style="vertical-align: inherit;">残念ながら、このための単純なAPIはありません。</font><font style="vertical-align: inherit;">NVIDIAは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vGPU</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクノロジーを提供</font><font style="vertical-align: inherit;">していますが、サポートされているカードのリストにTesla k80カードが見つかりませんでした。説明から理解できる限り、テクノロジーは計算よりも仮想ディスプレイに重点を置いています。</font><font style="vertical-align: inherit;">おそらくAMDはもっと適切なものを提供しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、プロジェクトでGPUを使用する場合は、アプリケーションがビデオカードを排他的に使用するか、割り当てられたメモリの量と計算に使用されるコアの数をプログラムで制御するという事実に依存する必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナーとGPU</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リソース制限を把握した場合、次の論理的な質問：サーバーに複数のビデオカードがある場合はどうなりますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでも、使用するGPUをアプリケーションレベルで決定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つのより便利な方法は、Dockerコンテナーです。</font><font style="vertical-align: inherit;">通常のコンテナを使用できますが、NVIDIAは、</font><font style="vertical-align: inherit;">さまざまなソフトウェア、ライブラリ、ドライバの最適化されたバージョンを備えた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NGC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナを提供しています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">1つのコンテナーに対して、使用されるGPUの数とコンテナーへの可視性を制限できます。</font><font style="vertical-align: inherit;">コンテナー使用量のオーバーヘッドは約3％です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスターで作業する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の質問、同じサーバーまたはクラスター内の複数のGPUで1つのタスクを実行する場合はどうすればよいですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スラストまたはより低いレベルのソリューションに類似したライブラリを選択した場合、タスクは手動で解決する必要があります。</font><font style="vertical-align: inherit;">機械学習やニューラルネットワークなどの高レベルのフレームワークは、通常、箱から出してすぐに複数のカードを使用する機能をサポートしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、たとえば、NVIDIAは、カード間の直接データ交換のためのインターフェースを提供しています</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-NVLINKは</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、PCI Expressよりもはるかに高速です。</font><font style="vertical-align: inherit;">また、他のPCI Expressデバイスからカードのメモリに直接アクセスするための技術があります</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-GPUDirect RDMA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を含む。</font><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワーク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推奨事項</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトでGPUを使用することを検討している場合、GPUは次の場合に最適です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスクをSIMDビューに減らすことができます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算（キャッシュ）の前にマップ上のほとんどのデータをロードすることが可能です</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">課題は集中的なコンピューティングです</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、事前に質問する必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並列クエリの数&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのくらいの待ち時間が予想されますか</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">負荷に1枚のカードが必要ですか？複数のカードを備えたサーバーまたはGPUサーバーのクラスターが必要ですか？&nbsp;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以上で、この資料がお役に立てば、正しい判断が下せるようになることを願っています。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
githubの上のベンチマーク結果- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/tishden/gpu_benchmark/tree/master/cuda</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
トピックに加えて、報告書の記録</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「GPUデータベース-アーキテクチャ、パフォーマンスおよび使用のための展望」</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
NVIDIA NGCコンテナウェビナー- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のhttp ：//bit.ly/2UmVIVt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://bit.ly/2x4vJKF</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja498362/index.html">キングストンはSSDの出荷においてリーダーシップを維持しています。</a></li>
<li><a href="../ja498366/index.html">Yandex開発者が毎日実装しているアルゴリズム</a></li>
<li><a href="../ja498368/index.html">1つのスイッチのストーリー</a></li>
<li><a href="../ja498370/index.html">SAP UI5と確認ウィンドウ：再びコンテキストについて</a></li>
<li><a href="../ja498372/index.html">ネットワークシミュレータチュートリアルns-3。第5章</a></li>
<li><a href="../ja498378/index.html">アジャイルによるスラムのイブニングスクールのお知らせ</a></li>
<li><a href="../ja498380/index.html">動作中のオーバートンのウィンドウ：パンデミックを使用して私たちの自由を制限する方法</a></li>
<li><a href="../ja498390/index.html">IAR + Clion =友情</a></li>
<li><a href="../ja498392/index.html">18のGitLab機能がオープンソースに</a></li>
<li><a href="../ja498394/index.html">Screaming FrogとNetpeak Spiderの7つの無料アナログ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>