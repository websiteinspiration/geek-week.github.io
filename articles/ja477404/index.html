<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌🏽 🙍🏾 👱🏿 C ++でオブジェクトを頻繁に作成および削除する問題 🚇 🕺🏻 ☮️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私が働いている会社は独自のトラフィックフィルタリングシステムを作成し、DDoS攻撃、ボット、パーサーなどからビジネスを保護しています。この製品はリバースプロキシなどのプロセスに基づいており、大量のトラフィックをリアルタイムで分析し、最終的には正当なユーザーリクエストのみを通過させ、すべての悪意のある...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C ++でオブジェクトを頻繁に作成および削除する問題</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/variti/blog/477404/"><img src="https://habrastorage.org/webt/fb/bt/53/fbbt53apqltc7isyigy39vkizmk.jpeg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が働いている会社は独自のトラフィックフィルタリングシステムを作成し、DDoS攻撃、ボット、パーサーなどからビジネスを保護しています。</font><font style="vertical-align: inherit;">この製品は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リバースプロキシ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などのプロセスに基づいて</font><font style="vertical-align: inherit;">おり、大量のトラフィックをリアルタイムで分析し、最終的には正当なユーザーリクエストのみを通過させ、すべての悪意のあるリクエストを除外します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主な機能は、当社のサービスが無制限の着信トラフィックで機能することです。そのため、ワークステーションのすべてのリソースをできるだけ効率的に使用することが非常に重要です。</font><font style="vertical-align: inherit;">最新の標準やBoostと呼ばれる一連のライブラリなど、最新のC ++での多くの開発経験がこれに役立ちます。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リバースプロキシ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リバースプロキシに戻り、C ++とboost.asioでそれを実装する方法を見てみましょう。まず、サーバーセッションとクライアントセッションという2つのオブジェクトが必要です。サーバーセッションはブラウザとの接続を確立および維持し、クライアントセッションはサービスとの接続を確立および維持します。また、内部メモリ付きの作業をカプセル化するストリームバッファも必要です。このバッファには、サーバーセッションがソケットから読み取り、クライアントセッションがソケットに書き込みます。サーバーセッションとクライアントセッションの例は、boost.asioのドキュメントに記載されています。ストリームバッファの操作方法については、こちらをご覧ください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例からリバースプロキシプロトタイプを収集した後、そのようなアプリケーションはおそらく無制限の着信トラフィックを処理しないことが明らかになります。次に、コードをより複雑にします。 ioコンテキストのマルチスレッド、wokers、プールなどについて考えてみましょう。特に、サーバーとクライアントのセッション間でメモリをコピーすることに関連する時期尚早の最適化について。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのようなメモリコピーについて話しているのですか？</font><font style="vertical-align: inherit;">実際のところ、フィルタリングの際、トラフィックは常に変更されずに送信されるわけではありません。</font><font style="vertical-align: inherit;">次の例を見てください。この例では、1つのヘッダーを削除し、代わりに2つのヘッダーを追加しています。</font><font style="vertical-align: inherit;">同様のアクションが実行されるユーザークエリの数は、サービス内のロジックが複雑になるにつれて増加します。</font><font style="vertical-align: inherit;">このような場合、データを不注意にコピーすることはできません。</font><font style="vertical-align: inherit;">リクエスト全体の1％のみが変更され、99％が変更されない場合、この1％にのみ新しいメモリを割り当てる必要があります。</font><font style="vertical-align: inherit;">これは、このboost :: asio :: const_bufferおよびboost :: asio :: mutable_bufferを使用して、1つのエンティティで複数の連続するメモリブロックを表すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーリクエスト：</font></font><br>
<br>
<pre><code class="plaintext hljs">Browser -&gt; Proxy:<font></font>
<font></font>
&gt; POST / HTTP/1.1<font></font>
&gt; User-Agent: curl/7.29.0<font></font>
&gt; Host: 127.0.0.1:50080<font></font>
&gt; Accept: */*<font></font>
&gt; Content-Length: 5888903<font></font>
&gt; Content-Type: application/x-www-form-urlencoded<font></font>
&gt; ...<font></font>
<font></font>
Proxy -&gt; Service:<font></font>
<font></font>
&gt; POST / HTTP/1.1<font></font>
&gt; User-Agent: curl/7.29.0<font></font>
&gt; Host: 127.0.0.1:50080<font></font>
&gt; Accept: */*<font></font>
&gt; Transfer-Encoding: chunked<font></font>
&gt; Content-Type: application/x-www-form-urlencoded<font></font>
&gt; Expect: 100-continue<font></font>
&gt; ...<font></font>
<font></font>
Service -&gt; Proxy:<font></font>
<font></font>
&lt; HTTP/1.1 200 OK<font></font>
<font></font>
Proxy -&gt; Browser<font></font>
<font></font>
&lt; HTTP/1.1 200 OK</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、十分にスケーリングでき、あらゆる種類の最適化が可能な既製のアプリケーションができました。本番環境でリリースすることで、どれだけ長く安定して機能するかについて非常に満足しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間の経過とともに、私たちはますます多くの顧客を持ち始め、どのトラフィックも成長しました。ある時点で、大規模な攻撃を撃退しながらパフォーマンスが低下するという問題に直面しました。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーティリティを使用してサービスを分析した後、</font><font style="vertical-align: inherit;">負荷のあるヒープを</font><font style="vertical-align: inherit;">使用した</font><font style="vertical-align: inherit;">すべての操作が一番上にあることがわかりました。次に</font><font style="vertical-align: inherit;">、実際のトラフィックに基づいて生成された</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yandexタンク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とカートリッジ</font><font style="vertical-align: inherit;">を使用して、テスト回路で同様の状況を再現しました</font><font style="vertical-align: inherit;">。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">アンプを</font></a><font style="vertical-align: inherit;">介してサービスに固執する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次の画像を見ました... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アンプのスクリーンショット（woslab）：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tz/ks/d9/tzksd9oddf-rhcfphtkxkun-pdg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スクリーンショットでは、オペレーターは67秒働いており、オペレーターはさらに97秒削除しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況は私たちを動揺させました。オペレーター新規およびオペレーター削除でのアプリケーション滞在時間を削減する方法は？これは、ヒープ上で頻繁に作成および削除されるオブジェクトの一定の割り当てを放棄することによって実行できることは論理的です。私たちは3つのアプローチを決めました。それらの2つは標準です：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトプール</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタック割り当て</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。アプリケーションの起動段階でプールに編成されたクライアントセッションは、最初のアプローチに適しています。 2番目のアプローチは、ユーザーリクエストが最初から最後まで同じスタックで、つまり同じioコンテキストハンドラーで処理されるすべての場所で使用されます。これについては詳しく説明しません。 3番目のアプローチについては、最も難しくて興味深いので、もっとよく説明します。これは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スラブ割り当て</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはスラブ分配</font><font style="vertical-align: inherit;">と呼ば</font><font style="vertical-align: inherit;">れます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スラブ配布のアイデアは新しいものではありません。これは、Solarisで開発および実装され、後でLinuxカーネルに移行されました。また、同じタイプの頻繁に使用されるオブジェクトは、プールに格納する方が簡単であるという事実があります。必要なときにプールからオブジェクトを取り出し、作業が完了するとそれを返します。オペレーターnewおよびオペレーターdeleteの呼び出しはありません！さらに、最小限の初期化。スラブコアでは、セマフォ、ファイル記述子、プロセス、およびスレッドにディストリビューションが使用されます。私たちの場合、サーバーとクライアントのセッションだけでなく、それらの内部にあるすべてのものに完全に当てはまりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図（スラブの分布）：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zb/k2/u8/zbk2u8m0jexhso3nmkttzxkvrw0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スラブアロケーターがカーネル内にあるという事実に加えて、それらの実装はユーザー空間にも存在します。それらの数は少なく、活発に開発されているものは一般的に少数です。という図書館に立ち寄りました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libsmall</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tarantoolの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">必要なものがすべて揃っています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小::アロケータ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小:: slab_cache（スレッドローカル）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小::スラブ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小さな::アリーナ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小：クォータ</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小さな::スラブ構造は、特定のタイプのオブジェクトを含むプールです。</font><font style="vertical-align: inherit;">構造small :: slab_cacheは、特定のタイプのオブジェクトを持つプールのさまざまなリストを含むキャッシュです。</font><font style="vertical-align: inherit;">構造小さな::アロケーターは、必要なキャッシュを選択し、その中の適切なプールを探して、要求されたオブジェクトが分散されるコードです。</font><font style="vertical-align: inherit;">small :: arenaオブジェクトとsmall :: quotaオブジェクトの機能は、以下の例から明らかになります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラップ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
libsmallライブラリはC ++ではなくCで記述されているため、標準のC ++ライブラリに透過的に統合するためにいくつかのラッパーを開発する必要がありました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variti :: slab_allocator</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バリティ::スラブ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数:: thread_local_slab</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variti :: slab_allocate_shared</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
variti :: slab_allocatorクラスは、独自のアロケーターを作成するときに標準で規定されている最小要件を実装します。 variti ::スラブクラスの内部では、libsmallライブラリを使用するすべての作業がカプセル化されています。なぜvariti :: thread_local_slabが必要なのですか？実際のところ、配布スラブキャッシュはスレッドローカルオブジェクトです。つまり、各スレッドには独自のキャッシュのセットがあります。これは、新しいオブジェクトを配布するときにブロックされる操作の数をゼロに減らすために行われます。したがって、各スレッドのメモリにvariti :: slabクラスのインスタンスを配置し、そのアクセスはvariti :: thread_local_slabラッパーを使用して制御されます。テンプレート関数varitiについて:: slab_allocate_sharedは後で説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
variti :: slab_allocatorクラスの内部では、すべてが非常に単純です。彼は、あるタイプから別のタイプに、たとえばvoidからcharに再バインドすることができます。興味深いことに、メモリが分散スラブを使い果たした場合は、例外std :: bad_allocに対するnullptrの普及に注意を払うことができます。残りは、variti :: thread_local_slabラッパー内で呼び出しを転送します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スニペット（slab_allocator.hpp）：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">slab_allocator</span> {</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
  <span class="hljs-keyword">using</span> value_type = T;
  <span class="hljs-keyword">using</span> pointer = value_type*;
  <span class="hljs-keyword">using</span> const_pointer = <span class="hljs-keyword">const</span> value_type*;
  <span class="hljs-keyword">using</span> reference = value_type&amp;;
  <span class="hljs-keyword">using</span> const_reference = <span class="hljs-keyword">const</span> value_type&amp;;<font></font>
<font></font>
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rebind</span> {</span>
    <span class="hljs-keyword">using</span> other = slab_allocator&lt;U&gt;;<font></font>
  };<font></font>
<font></font>
  slab_allocator() {}<font></font>
<font></font>
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<font></font>
  slab_allocator(<span class="hljs-keyword">const</span> slab_allocator&lt;U&gt;&amp; other) {}<font></font>
<font></font>
  <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* = <span class="hljs-literal">nullptr</span>)</span> </span>{
    <span class="hljs-keyword">auto</span> p = <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(thread_local_slab::allocate(<span class="hljs-keyword">sizeof</span>(T) * n));
    <span class="hljs-keyword">if</span> (!p &amp;&amp; n)
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::bad_alloc();
    <span class="hljs-keyword">return</span> p;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(T* p, <span class="hljs-keyword">size_t</span> n)</span> </span>{<font></font>
    thread_local_slab::deallocate(p, <span class="hljs-keyword">sizeof</span>(T) * n);<font></font>
  }<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">slab_allocator</span>&lt;void&gt; {</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
  <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">void</span>;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-keyword">void</span>*;
  <span class="hljs-keyword">using</span> const_pointer = <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*;<font></font>
<font></font>
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rebind</span> {</span>
    <span class="hljs-keyword">typedef</span> slab_allocator&lt;U&gt; other;<font></font>
  };<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
variti :: slabコンストラクタとデストラクタがどのように実装されているかを見てみましょう。コンストラクターでは、すべてのオブジェクトに合計1 GiB以下のメモリを割り当てます。この場合の各プールのサイズは1 MiBを超えません。配布できるオブジェクトの最小サイズは2バイトです（実際、libsmallは必要な最小サイズ（8バイト）に増やします）。スラブ配布を通じて利用可能な残りのオブジェクトは、2の倍数になります（定数2.fで設定）。合計、サイズ8、16、32などのオブジェクトを配布できます。要求されたオブジェクトのサイズが24バイトの場合、メモリからオーバーヘッドが発生します。ディストリビューションはこのオブジェクトを返しますが、サイズが32バイトのオブジェクトに対応するプールに配置されます。残りの8バイトはアイドル状態になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スニペット（slab.hpp）：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>* <span class="hljs-title">phys_to_virt_p</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p)</span>
</span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(p) + <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">std</span>::thread::id); }
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">phys_to_virt_n</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n)</span>
</span>{ <span class="hljs-keyword">return</span> n - <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">std</span>::thread::id); }
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>* <span class="hljs-title">virt_to_phys_p</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p)</span>
</span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(p) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">std</span>::thread::id); }
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">virt_to_phys_n</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n)</span>
</span>{ <span class="hljs-keyword">return</span> n + <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">std</span>::thread::id); }<font></font>
<font></font>
<span class="hljs-keyword">inline</span> <span class="hljs-built_in">std</span>::<span class="hljs-function">thread::id&amp; <span class="hljs-title">phys_thread_id</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p)</span>
</span>{ <span class="hljs-keyword">return</span> *<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::thread::id*&gt;(p); }  <font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">slab</span> :</span> <span class="hljs-keyword">public</span> noncopyable {
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
  slab() {<font></font>
    small::quota_init(&amp; quota_, <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<font></font>
    small::slab_arena_create(&amp;arena_, &amp; quota_, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>, MAP_PRIVATE);<font></font>
    small::slab_cache_create(&amp;cache_, &amp;arena_);<font></font>
    small::allocator_create(&amp;allocator_, &amp;cache_, <span class="hljs-number">2</span>, <span class="hljs-number">2.f</span>);<font></font>
  }<font></font>
<font></font>
  ~slab() {<font></font>
    small::allocator_destroy(&amp;allocator_);<font></font>
    small::slab_cache_destroy(&amp;cache_);<font></font>
    small::slab_arena_destroy(&amp;arena_);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n)</span> </span>{
    <span class="hljs-keyword">auto</span> phys_n = virt_to_phys_n(n);
    <span class="hljs-keyword">auto</span> phys_p = small::<span class="hljs-built_in">malloc</span>(&amp;allocator_, phys_n);
    <span class="hljs-keyword">if</span> (!phys_p)
      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
    phys_thread_id(phys_p) = <span class="hljs-built_in">std</span>::this_thread::get_id();
    <span class="hljs-keyword">return</span> phys_to_virt_p(phys_p);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">size_t</span> n)</span> </span>{
    <span class="hljs-keyword">auto</span> phys_p = virt_to_phys_p(<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(p));
    <span class="hljs-keyword">auto</span> phys_n = virt_to_phys_n(n);<font></font>
    assert(phys_thread_id(phys_p) == <span class="hljs-built_in">std</span>::this_thread::get_id());<font></font>
    small::<span class="hljs-built_in">free</span>(&amp;allocator_, phys_p, phys_n);<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
  small::quota quota_;<font></font>
  small::slab_arena arena_;<font></font>
  small::slab_cache cache_;<font></font>
  small::allocator allocator_;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの制限はすべて、variti :: slabクラスの特定のインスタンスに適用されます。各スレッドには独自のスレッドがあるため（スレッドローカルと考えます）、プロセスの合計制限は1 GiBではなく、スラブ分散が使用されるスレッドの数に正比例します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チャート（std :: thread :: id）：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_8/65/jy/_865jyoyp0qqoz7-tgsgmjsc9b0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、スレッドローカルを使用すると、マルチスレッドアプリケーションでのスラブ配布の作業を高速化できます。一方で、非同期アプリケーションのアーキテクチャに深刻な制限を課します。</font><font style="vertical-align: inherit;">同じストリーム内のオブジェクトを要求して返す必要があります。</font><font style="vertical-align: inherit;">これをboost.asioの一部として行うと、非常に問題が発生することがあります。</font><font style="vertical-align: inherit;">明らかに誤った状況を追跡するために、各オブジェクトの最初に、allocateメソッドが呼び出されるストリームの識別子を配置します。</font><font style="vertical-align: inherit;">次に、この識別子はdeallocateメソッドで検証されます。</font><font style="vertical-align: inherit;">ヘルパーphys_to_virt_pおよびvirt_to_phys_pがこれを支援します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スニペット（thread_local_slab.hpp）：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thread_local_slab</span> :</span> <span class="hljs-keyword">public</span> noncopyable {
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n)</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">size_t</span> n)</span></span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スニペット（thread_local_slab.cpp）：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">thread_local</span> slab* slab_;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">thread_local_slab::initialize</span><span class="hljs-params">()</span> </span>{ slab_ = <span class="hljs-keyword">new</span> slab(slab_cfg_); }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">thread_local_slab::finalize</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">delete</span> slab_; }
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">thread_local_slab::malloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n)</span> </span>{ <span class="hljs-keyword">return</span> slab_-&gt;<span class="hljs-built_in">malloc</span>(n); }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">thread_local_slab::free</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">size_t</span> n)</span> </span>{ slab_-&gt;<span class="hljs-built_in">free</span>(p, n); }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリームの制御が失われた場合（異なるioコンテキスト間でオブジェクトを転送する場合）、スマートポインターを使用すると、オブジェクトを正しく解放できます。</font><font style="vertical-align: inherit;">彼が行うすべてのことは、オブジェクトを配布し、そのioコンテキストを覚えて、それをstd :: shared_ptrでカスタムディバイダーでラップすることです。これにより、オブジェクトはすぐには配布に戻されませんが、以前に保存されたioコンテキストで実行されます。</font><font style="vertical-align: inherit;">これは、各ioコンテキストが単一のスレッドで実行されるときにうまく機能します。</font><font style="vertical-align: inherit;">そうでなければ、残念ながら、このアプローチは適用できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スニペット（slab_helper.hpp）：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Allocator, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt; <span class="hljs-title">slab_allocate_shared</span><span class="hljs-params">(Allocator allocator, Args... args)</span> </span>{<font></font>
  T* p = allocator.allocate(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">new</span> ((<span class="hljs-keyword">void</span>*)p) T(<span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...);
  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(p, [allocator](T* p) {
    p-&gt;~T();
    allocator.deallocate(p);
  })</span></span>;
  <span class="hljs-keyword">return</span> ptr;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Allocator, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt; <span class="hljs-title">slab_allocate_shared</span><span class="hljs-params">(Allocator allocator, boost::asio::io_service* io, Args... args)</span> </span>{<font></font>
  T* p = allocator.allocate(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">new</span> ((<span class="hljs-keyword">void</span>*)p) T(<span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...);
  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(p, [allocator, io](T* p) {
    io-&gt;post([allocator, p]() {
      p-&gt;~T();
      allocator.deallocate(p);
    });
  })</span></span>;
  <span class="hljs-keyword">return</span> ptr;<font></font>
};</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
libsmallのラッピング作業が完了した後、最初にストリームバッファー内のchunアロケーターをスラブに移動しました。</font><font style="vertical-align: inherit;">これはとても簡単でした。</font><font style="vertical-align: inherit;">肯定的な結果を得たので、スラブアロケーターを最初にストリームバッファー自体に適用し、次にサーバーおよびクライアントセッション内のすべてのオブジェクトに適用しました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バリティ::チャンク</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バリティ:: streambuf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数:: server_session</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数:: client_session</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、追加の問題を解決する必要がありました。つまり、単純なオブジェクト、複合オブジェクト、およびコレクションをスラブアロケーターに転送します。</font><font style="vertical-align: inherit;">オブジェクトの最初の2つのクラスに深刻な問題がなかった場合（複合オブジェクトは単純なオブジェクトに削減されます）、コレクションを変換するときに深刻な問題が発生しました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std ::リスト</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: deque</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std ::ベクトル</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std ::文字列</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std ::マップ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unordered_map</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スラブ分布を使用する場合の主な制限の1つは、さまざまなタイプのオブジェクトの数が多すぎないようにすることです（数が少ないほど良い）。このコンテキストでは、一部のコレクションはスラブアロケーターの概念によく当てはまる場合がありますが、そうでない場合もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
std :: list slabの場合、アロケーターはうまく機能します。このコレクションは、リンクされたリストを使用して内部的に実装され、その各要素のサイズは固定されています。したがって、新しいデータをスラブ配布のstd ::リストに追加すると、新しいタイプのオブジェクトは表示されません。上記の条件を満たしています！ std ::マップも同様に配置されています。唯一の違いは、その内部はリンクされたリストではなく、ツリーであることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
std :: dequeの場合、状況はより複雑になります。このコレクションは、チャンクへのポインタを含む連続したメモリブロックを通じて実装されます。チャンクは非常に正確ですが、std :: dequeはstd :: listと同じように動作しますが、それらが終了すると、このメモリブロックが再配布されます。スラブアロケーターの観点から見ると、各メモリの再配分は新しいタイプのオブジェクトです。コレクションに追加されるオブジェクトの数はユーザーに直接依存し、制御不能に増大する可能性があります。この状況は受け入れられないので、可能であればstd :: dequeのサイズを事前に制限するか、std ::リストを優先しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
std :: vectorとstd :: stringを使用すると、さらに複雑になります。</font><font style="vertical-align: inherit;">これらのコレクションの実装は、std :: dequeにいくらか似ていますが、連続したメモリブロックの成長が大幅に速くなる点が異なります。</font><font style="vertical-align: inherit;">std :: vectorとstd :: stringをstd :: dequeに、最悪の場合はstd :: listに置き換えました。</font><font style="vertical-align: inherit;">はい、私たちは機能性とどこかでさえパフォーマンスを失いました、しかしこれはすべてが考え出された最適化よりはるかに少ない最終的な状況に影響を与えました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
std :: unordered_mapでもまったく同じことを行い、std :: dequeを介して実装された自己記述型のvariti :: flat_mapを優先して破棄しました。</font><font style="vertical-align: inherit;">同時に、たとえばnginxのhttpリクエストヘッダーで行われるように、頻繁に使用されるキーを個別の変数にキャッシュしました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーセッションとクライアントセッションのスラブアロケーターへの完全な転送が完了すると、1つの束での作業に費やす時間を1.5倍以上削減しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アンプのスクリーンショット（coldslab）：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ls/yx/l_/lsyxl_b6xngl5xap-t5erwn4now.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スクリーンショットでは、オペレーターの新規作業は32秒、オペレーターの削除は24秒でした。このときまでに、ヒープを操作する他の関数が追加されました：smalloc-21秒、mslab_alloc-37秒、smfree-8秒、mslab_free-21秒。合計、143秒と161秒。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、これらの測定は、スラブディストリビューションのキャッシュを初期化せずに、サービスを開始した直後に行われました。ヤンデックス戦車からの発砲を繰り返した結果、全体像は改善されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アンプのスクリーンショット（hotslab）：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gc/zj/kt/gczjkt5r8yedhniu5afswdjqk2y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スクリーンショットでは、オペレーターの新規作業は20秒、smalloc-16秒、mslab_alloc-27秒、オペレーターの削除-16秒、smfree-7秒、mslab_free-17秒でした。</font><font style="vertical-align: inherit;">161秒に対して合計103秒。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
測定表：</font></font><br>
<br>
<pre><code class="plaintext hljs">                     woslab    coldslab     hotslab<font></font>
operator new            67s         32s         20s<font></font>
smalloc                   -         21s         16s<font></font>
mslab_alloc               -         37s         27s<font></font>
operator delete         94s         24s         16s<font></font>
smfree                    -          8s          7s<font></font>
mslab_free                -         21s         17s<font></font>
<font></font>
summary                161s        143s        103s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実生活では、スラブアロケータは長いメモリの割り当てと解放の問題を解決するだけでなく、断片化も減らすため、結果はさらに良くなるはずです。</font><font style="vertical-align: inherit;">スラブがないと、時間の経過とともに、オペレーター新規およびオペレーター削除の操作が遅くなるだけです。</font><font style="vertical-align: inherit;">スラブを使用すると、常に同じレベルのままになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のように、スラブアロケータは、頻繁に使用されるオブジェクトのメモリ割り当て問題を正常に解決します。</font><font style="vertical-align: inherit;">オブジェクトの頻繁な作成と削除の問題があなたに関係がある場合は、それらに注意してください。</font><font style="vertical-align: inherit;">ただし、アプリケーションのアーキテクチャに課せられる制限を忘れないでください。</font><font style="vertical-align: inherit;">すべての複雑なオブジェクトを単純にスラブ分布に配置できるわけではありません。</font><font style="vertical-align: inherit;">時々、あなたはたくさんあきらめなければなりません！</font><font style="vertical-align: inherit;">まあ、アプリケーションのアーキテクチャが複雑になればなるほど、マルチスレッドの観点から、オブジェクトを正しいキャッシュに返すことに注意しなければならないことがよくあります。</font><font style="vertical-align: inherit;">スラブアロケーターの使用を考慮に入れて、すぐにアプリケーションアーキテクチャを作成した場合は簡単ですが、後の段階で統合することを決定した場合は、明らかに問題が発生します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">応用</font></font></h3><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ソースコードをチェックしてください</font><font style="vertical-align: inherit;">！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja477390/index.html">Kubernetesでのネットワーク遅延のデバッグ</a></li>
<li><a href="../ja477392/index.html">オープンマイク：バックエンド。スピーカー募集</a></li>
<li><a href="../ja477396/index.html">コースへの登録方法...最後に移動</a></li>
<li><a href="../ja477400/index.html">プロダクトマネージャーの職業について：理想を達成する方法？</a></li>
<li><a href="../ja477402/index.html">Keras深層学習モデルをPython Webアプリケーションとしてデプロイする</a></li>
<li><a href="../ja477406/index.html">テクニカルサポートとサポート。雇用市場と給与に関する素晴らしい研究。2年間で何が変わったのですか？</a></li>
<li><a href="../ja477408/index.html">JavaFXチュートリアル：高度なレイアウト</a></li>
<li><a href="../ja477414/index.html">データエンジニア-21世紀の最もセクシーな職業</a></li>
<li><a href="../ja477416/index.html">ハッシュはいつ有害か</a></li>
<li><a href="../ja477418/index.html">3ステップでの3面屈折</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>