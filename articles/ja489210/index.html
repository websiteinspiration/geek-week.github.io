<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>➡️ 🕵🏻 ⛷️ Linuxコードのパフォーマンステストと例 👨🏽‍🔧 💘 👷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私がJavaを学び始めたとき、私が解決しようとした最初のタスクの1つは偶数/奇数を決定することでした。私はこれを行う方法をいくつか知っていましたが、インターネットで「正しい」方法を探すことにしました。見つかったすべてのリンクに関する情報は、除算の残りを取得するために、形式x％2の唯一の正しい解決策に...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Linuxコードのパフォーマンステストと例</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489210/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私がJavaを学び始めたとき、私が解決しようとした最初のタスクの1つは偶数/奇数を決定することでした。私はこれを行う方法をいくつか知っていましたが、インターネットで「正しい」方法を探すことにしました。見つかったすべてのリンクに関する情報は、除算の残りを取得するために、形式x％2の唯一の正しい解決策について教えてくれました。余りが0の場合、数値は偶数であり、余りが1の場合、奇数です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZXスペクトラムの時代以来、私は別の方法を思い出しました。これは、バイナリシステムでの数値の表現に関連付けられています。 10進法の任意の数は、2の累乗の合計として記述できます。たとえば、1バイトでこれが8ビットの場合、10進法の任意の数値は、128 + 64 + 32 + 16 + 8 + 4 + 2 + 1の合計として表すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、2の累乗のシーケンスにすぎません。数値をバイナリシステムに変換する場合、数値を考慮する必要がある場合、バイナリ表現では1になります。必要でない場合、0になります</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。例：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 = 1010（8 + 0 + 2 + 0）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
13 = 1101（8 + 4 + 0 + 1）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
200 = 11001000（128 + 64 + 0 + 0 + 8 + 0 + 0 + 0）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
奇数は値1で2のゼロ乗しか与えないという事実にすぐに注意を払うことができます。他のすべての2乗は定義により偶数になります。</font><font style="vertical-align: inherit;">これは自動的に2進数システムの観点から、任意の数のパリティをチェックする場合、それがどんなに大きくても、整数をチェックする必要がないことを意味します。</font><font style="vertical-align: inherit;">最初のビット（右端）のみをチェックする必要があります。</font><font style="vertical-align: inherit;">0の場合、数値は偶数になります。他のすべてのビットは偶数を与え、逆も同様です。右端のビットが1の場合、他のすべてのビットは偶数の値しか与えないため、数値は奇数であることが保証されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数の正しいビットのみをチェックするには、いくつかの方法を使用できます。</font><font style="vertical-align: inherit;">それらの1つはバイナリANDです。</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイナリAND（AND）は次のルールで機能します。任意の数値に適用する場合、それを元の論理ANDと呼び、数値0とすると、そのような演算の結果は常に0になります。これにより、不要なビットをゼロにできます。オリジナル1に申し込むとオリジナルがもらえます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイナリシステムでは、次のように書くのは簡単です：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 AND 0 = 0（オリジナルをゼロ）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 AND 0 = 0（オリジナルをゼロ）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 AND 1 = 0（オリジナルを変更しない）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 AND 1 = 1（オリジナルを変更しない）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここからいくつかの単純なルール。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのユニットのAND演算をすべての数値（すべてのビットがオン）に適用すると、最初の数値は同じになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのゼロのANDを任意の数（すべてのビットがオフ）に適用すると、0になります</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。次に例を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AND 0をバイト13に適用すると、0が取得されます。10進数では、13 AND 0 = 0のよう</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
になります。AND0をバイト200に適用すると、0が取得されるか、200 AND 0 = 0が簡単に書き留められます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは逆です。 13に含まれるすべてのビットに適用すると、1バイトは8ユニットになり、オリジナルが取得されます。</font><font style="vertical-align: inherit;">2進法では00001101 AND 11111111 = 00001101または10進法では13 AND 255 = 13 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
200の場合、それぞれ11001000 AND 11111111 = 11001000、または10進法では200 AND 255 = 200</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイナリ検証</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パリティの数を確認するには、右端のビットのみを確認する必要があります。 0の場合、数値は偶数で、1の場合、数値は偶数ではありません。 ANDを使用すると、一部のビットを元のままにでき、一部をリセットできることを知っているため、右端のビットを除くすべてのビットをリセットできます。例：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイナリシステムの13は1101です。それにAND 0001を適用しましょう（すべてのビットをリセットしますが、最後のビットは元のままです）。 1101では、最後のビットを除くすべてのビットを0に変更して0001を取得します。元の数からは最後のビットのみを取得しました。 10進法では、13 AND 1 = 1のようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイナリ11001000の数値200の同じもの。同じスキームに従って、それに00000001を適用し、すべてのビットをゼロにし、最後をそのままにし、00000000を取得し、ANDを使用して左の7つのゼロをリセットし、最後の0を取得します。元の番号から。 10進法では、200 AND 1 = 0の</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
よう</font><font style="vertical-align: inherit;">に見えます。</font><font style="vertical-align: inherit;">したがって、任意の数値にAND 1コマンドを適用すると、0または1が得られます。結果が0の場合、数値は偶数です。 1の場合、数は奇数です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaでは、バイナリANDは＆と記述されます。したがって、200＆1 = 0（偶数）および13＆1 = 1（奇数）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、偶数を決定するための少なくとも2つの方法を意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X％2-2つの</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X </font><font style="vertical-align: inherit;">による除算の残りを介して</font><font style="vertical-align: inherit;">＆1-バイナリANDを介して</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OR、AND、XORなどのバイナリ演算は、最短時間でプロセッサによって処理されます。</font><font style="vertical-align: inherit;">しかし、除算演算は重要なタスクであり、それを実行するには、プロセッサが多くの命令を処理し、基本的にプログラム全体を実行する必要があります。</font><font style="vertical-align: inherit;">ただし、たとえば数値を2ですばやく除算できるバイナリの左シフト演算と右シフト演算があります。問題は、コンパイラがこの最適化を使用するかどうか、およびこれら2つの比較の間に違いがあるかどうかです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コーディング</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9,000,000,000の数値を1サイクルで順番に処理するプログラムを作成し、除算の残りの部分を決定することによって、それらが偶数/奇数に属するかどうかを決定します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OddEvenViaMod</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>{
                <span class="hljs-keyword">long</span> i=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> odds=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> evens=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) {<font></font>
                        evens++;<font></font>
                        }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                        odds++;<font></font>
                        }<font></font>
                i++;<font></font>
                } <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-number">9000000000L</span>);<font></font>
                System.out.println(<span class="hljs-string">"Odd "</span> + odds);<font></font>
                System.out.println(<span class="hljs-string">"Even "</span> + evens);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、まったく同じように書き込みますが、文字通り2つの文字を変更し、バイナリANDで同じことをチェックします。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OddEvenViaAnd</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>{
                <span class="hljs-keyword">long</span> i=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> odds=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> evens=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) {<font></font>
                        evens++;<font></font>
                        }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                        odds++;<font></font>
                        }<font></font>
                i++;<font></font>
                } <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-number">9000000000L</span>);<font></font>
                System.out.println(<span class="hljs-string">"Odd "</span> + odds);<font></font>
                System.out.println(<span class="hljs-string">"Even "</span> + evens);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、これら2つのプログラムを何とか比較する必要があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linuxに関するリソース。</font><font style="vertical-align: inherit;">CPU</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オペレーティングシステムの作成、特にプログラム間のリソースの公平な配分には、膨大な時間が費やされています。</font><font style="vertical-align: inherit;">一方で、これは良いことです。2つのプログラムを実行しているので、それらが並行して動作することを確認できますが、一方で、プログラムのパフォーマンスを確認する必要がある場合は、他のプログラムからのプログラムへの外部の影響を制限または少なくとも減らすことが非常に必要です。プログラムとオペレーティングシステム。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に理解するのはプロセッサです。</font><font style="vertical-align: inherit;">各プロセスのLinux OSはビットマスクを格納します。これは、アプリケーションで使用できるカーネルと使用できないカーネルを示します。</font><font style="vertical-align: inherit;">このマスクは、tasksetコマンドを使用して表示および変更できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、私のプロセッサのコア数を見てみましょう：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# grep -c processor /proc/cpuinfo<font></font>
4<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のコンピューターには4コアのプロセッサーがあります。</font><font style="vertical-align: inherit;">そのうちの1つを自分のニーズに割り当てます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらすべてが現在topコマンドで使用されているかどうかを確認しましょう。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# top
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「1」を押すと、各コアの情報が個別に表示されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">top - 13:44:11 up 1 day, 23:26,  7 users,  load average: 1.48, 2.21, 2.02<font></font>
Tasks: 321 total,   1 running, 320 sleeping,   0 stopped,   0 zombie<font></font>
%Cpu0  :  7.7 us,  6.8 sy,  0.0 ni, 85.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :  9.2 us,  4.2 sy,  0.0 ni, 86.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  7.6 us,  3.4 sy,  0.0 ni, 89.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  :  8.4 us,  4.2 sy,  0.0 ni, 87.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
KiB Mem : 16210820 total,   296972 free, 10072092 used,  5841756 buff/cache<font></font>
KiB Swap: 16777212 total, 16777212 free,        0 used.  5480568 avail Mem<font></font>
....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、すべてのコアがほぼ同じように使用されていることがわかります。</font><font style="vertical-align: inherit;">（usとsyおよびidインジケーターは各コアでほぼ同じです）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、tasksetコマンドで同じことを確認してみましょう。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -p 1<font></font>
pid 1's current affinity mask: f<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16進法のビットマスク「F」は、10進法で15、2進法で1111（8 + 4 + 2 + 1）を意味します。</font><font style="vertical-align: inherit;">すべてのビットが有効です。つまり、すべてのコアがPID 1のプロセスによって使用されます</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。Linuxでは、クローンシステムコール</font><font style="vertical-align: inherit;">を使用して</font><font style="vertical-align: inherit;">1つのプロセスが別のプロセスを生成すると、クローン作成時にビットマスクが親からコピーされます。</font><font style="vertical-align: inherit;">これは、initプロセス（この場合はsystemd）のこのマスクを変更した場合、systemdを介して新しいプロセスを開始すると、この新しいプロセスは新しいマスクですでに起動されることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じコマンドを使用してプロセスのマスクを変更し、プロセスに使用したままにするCPUコアの数をリストできます。</font><font style="vertical-align: inherit;">プロセスにカーネル0.2.3を残し、systemdプロセスにカーネル1を無効にするとします。</font><font style="vertical-align: inherit;">これを行うには、次のコマンドを実行する必要があります。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]#  taskset -pc 0,2,3 1<font></font>
pid 1's current affinity list: 0-3<font></font>
pid 1's new affinity list: 0,2,3<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはチェックします：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -p 1<font></font>
pid 1's current affinity mask: d<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マスクは16進表記で「D」に変更されました。これは、10進数で13、2進数で1101（8 + 4 + 0 + 1）です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点から、systemdプロセスによって複製されるプロセスはすべて、自動的にCPU使用率マスク1101を持ちます。つまり、カーネル番号1は使用されません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのプロセスでのカーネルの使用を禁止します</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインのLinuxプロセスが単一のカーネルを使用できないようにすると、このプロセスによって作成された新しいプロセスにのみ影響します。</font><font style="vertical-align: inherit;">しかし、私のシステムにはすでに1つのプロセスはありませんが、crond、sshd、bashなどの多数のプロセスがあります。</font><font style="vertical-align: inherit;">すべてのプロセスが1つのコアを使用することを禁止する必要がある場合は、実行中のプロセスごとにtasksetコマンドを実行する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのプロセスのリストを取得するには、カーネルが提供するAPI、つまり/ procファイルシステムを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらにループでは、実行中の各プロセスのPIDを調べ、そのプロセスとすべてのスレッドのマスクを変更します。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# cd /proc; for i in `ls -d [0-9]*`; do taskset -a -pc 0,2,3 $i; done<font></font>
pid 1's current affinity list: 0,2,3<font></font>
pid 1's new affinity list: 0,2,3<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムの実行中、一部のプロセスは他のプロセスを生成する時間がある可能性があるため、このコマンドを数回実行することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
topコマンドで作業の結果を確認します。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# top<font></font>
top - 14:20:46 up 2 days, 3 min,  7 users,  load average: 0.19, 0.27, 0.57<font></font>
Tasks: 324 total,   4 running, 320 sleeping,   0 stopped,   0 zombie<font></font>
%Cpu0  :  8.9 us,  7.7 sy,  0.0 ni, 83.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  9.5 us,  6.0 sy,  0.0 ni, 84.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  :  8.4 us,  6.6 sy,  0.0 ni, 85.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
KiB Mem : 16210820 total,   285724 free, 10142548 used,  5782548 buff/cache<font></font>
KiB Swap: 16777212 total, 16777212 free,        0 used.  5399648 avail Mem<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、状況は少し変わっています。カーネル0.2.3の平均パラメータus、sy、idは同じです。カーネル1の場合、ユーザー空間とsysのコア消費量は0で、カーネルは100％（アイドル100 ）</font><font style="vertical-align: inherit;">カーネル1は私たちのアプリケーションで使用されなくなり、ごくわずかな割合が現在カーネルで使用されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、パフォーマンスをテストするタスクは、フリーコアでプロセスを開始することに減りました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記憶</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセスに割り当てられた物理メモリは、どのプロセスからでも簡単に取得できます。</font><font style="vertical-align: inherit;">このメカニズムはスワップと呼ばれます。</font><font style="vertical-align: inherit;">Linuxにスワップの場所があれば、とにかくそれを行います。</font><font style="vertical-align: inherit;">他のプロセスと同様に、OSがプロセスからメモリを取得しないようにする唯一の方法は、スワップセクションを完全に無効にすることです。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo swapoff -a<font></font>
[user@localhost]$ free -m<font></font>
              total        used        free      shared  buff/cache   available<font></font>
Mem:          15830        7294        1894         360        6641        7746<font></font>
Swap:             0           0           0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用されていない1つのプロセッサコアを割り当て、Linuxカーネルからメモリをスワップする機能も削除しました。 </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディスク</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセスの起動に対するディスクの影響を軽減するために、メモリ内にディスクを作成し、必要なすべてのファイルをこのディスクにコピーします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディレクトリを作成し、ファイルシステムをマウントします。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo mkdir /mnt/ramdisk;<font></font>
[user@localhost]$ mount -t tmpfs -o size=512m tmpfs /mnt/ramdisk<font></font>
[user@localhost]$ chown user: /mnt/ramdisk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、何をどのように起動するかを把握する必要があります。</font><font style="vertical-align: inherit;">プログラムを実行するには、まずコードをコンパイルする必要があります。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ javac OddEvenViaMod.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、それを実行する必要があります。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私たちのケースでは、他のプロセスで使用されていないプロセッサコアでプロセスを実行する必要があります。</font><font style="vertical-align: inherit;">したがって、タスクセットを介して実行します。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -c 1 time java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストでは時間を測定する必要があるため、起動ラインは次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">taskset -c 1 time java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linux OSは実行可能ファイルのいくつかのフォーマットをサポートしており、それらの最も一般的なものはELFフォーマットです。このファイル形式を使用すると、ファイルを実行せずに別のファイルを実行するようにOSに指示できます。一見、それは非常に論理的で理解できるようには聞こえません。マインスイーパゲームを起動すると、マリオゲームが起動します。ウイルスのように見えます。しかし、これは論理です。私のプログラムがlibcなどの動的ライブラリを必要とする場合、これはOSが最初にこのライブラリをメモリにロードし、その後、プログラムをロードして実行する必要があることを意味します。そして、オペレーティングシステム自体にそのような機能を配置することは理にかなっていますが、オペレーティングシステムはメモリの保護された領域で動作し、可能な限り必要最小限の機能を含む必要があります。したがって、ELF形式は、他のプログラムをダウンロードすることをOSに伝える機会を提供します。この「他の」プログラムは、必要なすべてのライブラリとプログラムをダウンロードし、すべてを開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、3つのファイルを実行する必要があります。これはタスクセット、時間、Javaです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらの最初を確認してください：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ whereis taskset<font></font>
taskset: /usr/bin/taskset /usr/share/man/man1/taskset.1.gz<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bashはファイル/ usr / bin / tasksetを実行し、中身を確認します。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ file /usr/bin/taskset<font></font>
/usr/bin/taskset: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=7a2fd0779f64aa9047faa00f498042f0f0c5dc60, stripped<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、私が上で書いたELFファイルです。</font><font style="vertical-align: inherit;">ELFファイルには、プログラム自体に加えて、さまざまなヘッダーがあります。</font><font style="vertical-align: inherit;">このファイルを起動することにより、OSはそのヘッダーをチェックし、「要求プログラムインタープリター」というヘッダーがファイルに存在する場合、OSはこのヘッダーからファイルを起動し、最初に起動したファイルを引数として渡します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このヘッダーがELFファイルに存在するかどうかを確認します。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ readelf -a /usr/bin/taskset  | grep -i interpreter<font></font>
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヘッダーが存在します。つまり、/ usr / bin / tasksetファイルを起動することで、実際に/lib64/ld-linux-x86-64.so.2を実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このファイルが何であるかを確認してください：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ ls -lah /lib64/ld-linux-x86-64.so.2<font></font>
lrwxrwxrwx 1 root root 10 May 21  2019 /lib64/ld-linux-x86-64.so.2 -&gt; ld-2.17.so<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは/lib64/ld-2.17.soファイルへのsimリンクです。</font><font style="vertical-align: inherit;">見てみな：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ file /lib64/ld-2.17.so<font></font>
/lib64/ld-2.17.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=a527fe72908703c5972ae384e78d1850d1881ee7, not stripped<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、これはOSが実行する別のELFファイルです。</font><font style="vertical-align: inherit;">ヘッダーを確認します。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ readelf -a /lib64/ld-2.17.so  | grep -i interpreter<font></font>
[user@localhost]$<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このELFファイルにはそのようなヘッダーがないため、OSがこのファイルを実行し、制御をそれに転送します。</font><font style="vertical-align: inherit;">そしてすでにこのファイルは私たちのファイル/ usr / bin / tasksetを開き、そこから必要なすべてのライブラリに関する情報を読み取ります。</font><font style="vertical-align: inherit;">必要なライブラリのリストは、ELFファイルのヘッダーにもあります。</font><font style="vertical-align: inherit;">同じリストであるlddまたはreadelfコマンドでこのリストを見ることができます。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ ldd /usr/bin/taskset<font></font>
	linux-vdso.so.1 =&gt;  (0x00007ffc4c1df000)<font></font>
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f4a24c4e000)<font></font>
	/lib64/ld-linux-x86-64.so.2 (0x00007f4a2501b000)<font></font>
<font></font>
[user@localhost]$ readelf -a /usr/bin/taskset  | grep NEEDED<font></font>
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VDSOは、ライブラリに関連しないリンクされたメモリの一部であるため、必要なライブラリとしてELFファイルから欠落しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これから、プログラム/lib64/ld-2.17.soがそれを必要とするすべてのプログラムを実行する責任があることは明らかであり、これらはすべて動的にリンクされたライブラリーを持つプログラムです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
/ usr / bin / tasksetを実行する場合、これは/ usr / bin / taskset引数を指定して/lib64/ld-2.17.soを実行する場合とまったく同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストに対するディスクの影響の問題に戻ります。</font><font style="vertical-align: inherit;">これで、プログラムをメモリからロードする場合、1つのファイルではなく複数のファイルをコピーする必要があることがわかりました。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp /lib64/libc-2.17.so /mnt/ramdisk/<font></font>
[user@localhost]$ cp /lib64/ld-2.17.so /mnt/ramdisk/<font></font>
[user@localhost]$ cp /usr/bin/taskset /mnt/ramdisk/<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間についても同じですが、ライブラリの要件はまったく同じです（すでにldとlibcをコピーしています）。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp /usr/bin/time /mnt/ramdisk/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaの場合、Javaは長時間コピーできるさまざまなライブラリを必要とするため、少し複雑です。</font><font style="vertical-align: inherit;">私の人生を少し簡略化するために、java openjdkからメモリ内のディスクにディレクトリ全体をコピーし、simリンクを作成します。</font><font style="vertical-align: inherit;">もちろん、この場合ディスクアクセスは残りますが、それより少なくなります。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp -R /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64 /mnt/ramdisk/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古いディレクトリの名前を変更し、末尾に.defaultを追加します</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo mv /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64{,.default}
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてシンボリックリンクを作成します：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo ln -s /mnt/ramdisk/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64 /usr/lib/jvm/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際に起動する/lib64/ld-2.17.soファイルへの引数を介してバイナリファイルを実行する方法はすでに知っています。</font><font style="vertical-align: inherit;">しかし、プログラム/lib64/ld-2.17.soに、指定したディレクトリからロードされたライブラリをロードする方法を教えてください。</font><font style="vertical-align: inherit;">man ldを使用すると、環境変数LD_LIBRARY_PATHを宣言すると、ldプログラムが指定したディレクトリからライブラリをロードすることがわかります。</font><font style="vertical-align: inherit;">これで、Javaアプリケーションの起動ラインを準備するためのすべてのデータが揃いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数回続けて開始し、以下をチェックします。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.66user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20344maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.65user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.66user 0.01system 0:10.68elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.65user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+96outputs (0major+5234minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムの実行中にtopを実行して、プログラムが正しいCPUコアで実行されることを確認できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ top<font></font>
...<font></font>
%Cpu0  : 19.7 us, 11.7 sy,  0.0 ni, 68.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  9.8 us,  9.1 sy,  0.0 ni, 81.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  : 14.0 us,  9.0 sy,  0.0 ni, 77.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 s<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、ほとんどの場合の結果は似ています。</font><font style="vertical-align: inherit;">残念ながら、CPUコア上のOSの影響を完全に取り除くことはできないため、結果は起動時のLinuxカーネル内の特定のタスクに依存します。</font><font style="vertical-align: inherit;">したがって、数回の開始の値の中央値を使用することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのケースでは、1つのCPUコアで10.65秒以内に、残りの除算を通じてJavaプログラムがパリティ付きで9,000,000,000を処理していることがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のプログラムで同じテストを実行してみましょう。2番目のプログラムは、バイナリANDを介して同じことを行います。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.02user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5197minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.01user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20228maxresident)k<font></font>
0inputs+64outputs (0major+5199minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.01user 0.01system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5198minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.02user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5198minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、バイナリANDによるパリティの比較に4.02秒かかることを確信を持って言えます。つまり、残りの除算によるチェックと比較して、少なくともopenjdkバージョン1.8.0では2.6倍速く動作します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oracle JavaとOpenjdk</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OracleのWebサイトから/mnt/ramdisk/jdk-13.0.2ディレクトリにjava jdkをダウンロードして解凍しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイル：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ /mnt/ramdisk/jdk-13.0.2/bin/javac OddEvenViaAnd.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ローンチ：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.39user 0.01system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 24260maxresident)k<font></font>
0inputs+64outputs (0major+6979minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.40user 0.01system 0:10.42elapsed 99%CPU (0avgtext+0avgdata 24268maxresident)k<font></font>
0inputs+64outputs (0major+6985minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つ目のプログラムをコンパイルします。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ /mnt/ramdisk/jdk-13.0.2/bin/javac OddEvenViaMod.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ローンチ：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.39user 0.01system 0:10.40elapsed 99%CPU (0avgtext+0avgdata 24324maxresident)k<font></font>
0inputs+96outputs (0major+7003minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.40user 0.00system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 24316maxresident)k<font></font>
0inputs+64outputs (0major+6992minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
oracle jdkの同じソースの実行時間は、残りの除算とバイナリANDで同じですが、これは正常に見えますが、この時間も同様に悪く、openjdkで除算の残りの部分に示されています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パイソン</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じことをPythonで比較してみましょう。</font><font style="vertical-align: inherit;">最初に、残りの部分を2で除算するオプション。</font></font><br>
<br>
<pre><code class="python hljs">odd=<span class="hljs-number">0</span>
even=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
	<span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<font></font>
		even += <span class="hljs-number">1</span>
	<span class="hljs-keyword">else</span>:<font></font>
		odd += <span class="hljs-number">1</span>
<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ローンチ：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.69user 0.00system 0:11.69elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.67user 0.00system 0:11.67elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.66user 0.00system 0:11.66elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイナリANDでも同じです：</font></font><br>
<br>
<pre><code class="python hljs">odd=<span class="hljs-number">0</span>
even=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
	<span class="hljs-keyword">if</span> i &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span>:<font></font>
		even += <span class="hljs-number">1</span>
	<span class="hljs-keyword">else</span>:<font></font>
		odd += <span class="hljs-number">1</span>
<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ローンチ：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.41user 0.00system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 4588maxresident)k<font></font>
0inputs+0outputs (0major+1221minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.43user 0.00system 0:10.43elapsed 99%CPU (0avgtext+0avgdata 4588maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.43user 0.00system 0:10.43elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果は、ANDの方が高速であることを示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターネットでは、Pythonのグローバル変数の方が遅いと何度も書かれています。</font><font style="vertical-align: inherit;">私は最後のプログラムの実行時間をANDと比較することにしましたが、まったく同じですが、関数にラップされています。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
	odd=<span class="hljs-number">0</span>
	even=<span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
		<span class="hljs-keyword">if</span> i &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span>:<font></font>
			even += <span class="hljs-number">1</span>
		<span class="hljs-keyword">else</span>:<font></font>
			odd += <span class="hljs-number">1</span>
	<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
	<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd<font></font>
<font></font>
main()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数で実行：</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and_func.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
5.08user 0.00system 0:05.08elapsed 99%CPU (0avgtext+0avgdata 4592maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and_func.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
5.08user 0.00system 0:05.09elapsed 99%CPU (0avgtext+0avgdata 4592maxresident)k<font></font>
0inputs+0outputs (0major+1223minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のように、Pythonでのバイナリと関数の同じパリティ比較は、単一のCPUコアで100000000の数値を約5秒で処理し、関数なしのANDを介した同じ比較では約10秒かかり、残りの除算による関数なしの比較では〜かかります11秒 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数内のPythonプログラムが、それがない場合よりも速く機能する理由は、すでに何度も説明されており、変数のスコープに関連しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonには、プログラムを解釈するときにPythonが使用する内部関数にプログラムを分解する機能があります。</font><font style="vertical-align: inherit;">Pythonがodd_and_func.py関数を使用してバリアントに使用する関数を見てみましょう。</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]# python<font></font>
Python 2.7.5 (default, Jun 20 2019, 20:27:34)<font></font>
[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux2<font></font>
Type "help", "copyright", "credits" or "license" for more information.<font></font>
&gt;&gt;&gt; def main():<font></font>
...     odd=0<font></font>
...     even=0<font></font>
...     for i in xrange(100000000):<font></font>
...             if i &amp; 1 == 0:<font></font>
...                     even += 1<font></font>
...             else:<font></font>
...                     odd += 1<font></font>
...     print "even", even<font></font>
...     print "odd", odd<font></font>
...<font></font>
&gt;&gt;&gt; import dis<font></font>
&gt;&gt;&gt; dis.dis(main)<font></font>
  2           0 LOAD_CONST               1 (0)<font></font>
              3 STORE_FAST               0 (odd)<font></font>
<font></font>
  3           6 LOAD_CONST               1 (0)<font></font>
              9 STORE_FAST               1 (even)<font></font>
<font></font>
  4          12 SETUP_LOOP              59 (to 74)<font></font>
             15 LOAD_GLOBAL              0 (xrange)<font></font>
             18 LOAD_CONST               2 (100000000)<font></font>
             21 CALL_FUNCTION            1<font></font>
             24 GET_ITER<font></font>
        &gt;&gt;   25 FOR_ITER                45 (to 73)<font></font>
             28 STORE_FAST               2 (i)<font></font>
<font></font>
  5          31 LOAD_FAST                2 (i)<font></font>
             34 LOAD_CONST               3 (1)<font></font>
             37 BINARY_AND<font></font>
             38 LOAD_CONST               1 (0)<font></font>
             41 COMPARE_OP               2 (==)<font></font>
             44 POP_JUMP_IF_FALSE       60<font></font>
<font></font>
  6          47 LOAD_FAST                1 (even)<font></font>
             50 LOAD_CONST               3 (1)<font></font>
             53 INPLACE_ADD<font></font>
             54 STORE_FAST               1 (even)<font></font>
             57 JUMP_ABSOLUTE           25<font></font>
<font></font>
  8     &gt;&gt;   60 LOAD_FAST                0 (odd)<font></font>
             63 LOAD_CONST               3 (1)<font></font>
             66 INPLACE_ADD<font></font>
             67 STORE_FAST               0 (odd)<font></font>
             70 JUMP_ABSOLUTE           25<font></font>
        &gt;&gt;   73 POP_BLOCK<font></font>
<font></font>
  9     &gt;&gt;   74 LOAD_CONST               4 ('even')<font></font>
             77 PRINT_ITEM<font></font>
             78 LOAD_FAST                1 (even)<font></font>
             81 PRINT_ITEM<font></font>
             82 PRINT_NEWLINE<font></font>
<font></font>
 10          83 LOAD_CONST               5 ('odd')<font></font>
             86 PRINT_ITEM<font></font>
             87 LOAD_FAST                0 (odd)<font></font>
             90 PRINT_ITEM<font></font>
             91 PRINT_NEWLINE<font></font>
             92 LOAD_CONST               0 (None)<font></font>
             95 RETURN_VALUE<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードで関数を使用せずに同じことを確認します。</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt;&gt;&gt; f=open("odd_and.py","r")<font></font>
&gt;&gt;&gt; l=f.read()<font></font>
&gt;&gt;&gt;<font></font>
&gt;&gt;&gt; l<font></font>
'odd=0\neven=0\nfor i in xrange(100000000):\n\tif i &amp; 1 == 0:\n\t\teven += 1\n\telse:\n\t\todd += 1\nprint "even", even\nprint "odd", odd\n'<font></font>
&gt;&gt;&gt; k=compile(l,'l','exec')<font></font>
&gt;&gt;&gt; k<font></font>
&lt;code object &lt;module&gt; at 0x7f2bdf39ecb0, file "l", line 1&gt;<font></font>
&gt;&gt;&gt; dis.dis(k)<font></font>
  1           0 LOAD_CONST               0 (0)<font></font>
              3 STORE_NAME               0 (odd)<font></font>
<font></font>
  2           6 LOAD_CONST               0 (0)<font></font>
              9 STORE_NAME               1 (even)<font></font>
<font></font>
  3          12 SETUP_LOOP              59 (to 74)<font></font>
             15 LOAD_NAME                2 (xrange)<font></font>
             18 LOAD_CONST               1 (100000000)<font></font>
             21 CALL_FUNCTION            1<font></font>
             24 GET_ITER<font></font>
        &gt;&gt;   25 FOR_ITER                45 (to 73)<font></font>
             28 STORE_NAME               3 (i)<font></font>
<font></font>
  4          31 LOAD_NAME                3 (i)<font></font>
             34 LOAD_CONST               2 (1)<font></font>
             37 BINARY_AND<font></font>
             38 LOAD_CONST               0 (0)<font></font>
             41 COMPARE_OP               2 (==)<font></font>
             44 POP_JUMP_IF_FALSE       60<font></font>
<font></font>
  5          47 LOAD_NAME                1 (even)<font></font>
             50 LOAD_CONST               2 (1)<font></font>
             53 INPLACE_ADD<font></font>
             54 STORE_NAME               1 (even)<font></font>
             57 JUMP_ABSOLUTE           25<font></font>
<font></font>
  7     &gt;&gt;   60 LOAD_NAME                0 (odd)<font></font>
             63 LOAD_CONST               2 (1)<font></font>
             66 INPLACE_ADD<font></font>
             67 STORE_NAME               0 (odd)<font></font>
             70 JUMP_ABSOLUTE           25<font></font>
        &gt;&gt;   73 POP_BLOCK<font></font>
<font></font>
  8     &gt;&gt;   74 LOAD_CONST               3 ('even')<font></font>
             77 PRINT_ITEM<font></font>
             78 LOAD_NAME                1 (even)<font></font>
             81 PRINT_ITEM<font></font>
             82 PRINT_NEWLINE<font></font>
<font></font>
  9          83 LOAD_CONST               4 ('odd')<font></font>
             86 PRINT_ITEM<font></font>
             87 LOAD_NAME                0 (odd)<font></font>
             90 PRINT_ITEM<font></font>
             91 PRINT_NEWLINE<font></font>
             92 LOAD_CONST               5 (None)<font></font>
             95 RETURN_VALUE<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のように、関数が宣言されたバリアントでは、PythonはFAST_接尾辞が付いた内部関数（STORE_FAST、LOAD_FASTなど）を使用し、関数の宣言がないバリアントでは、Pythonは内部関数STORE_NAMEおよびLOAD_NAMEを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は実用的な意味はほとんどなく、Linuxとコンパイラーのいくつかの機能を理解することを目的としています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてに良い！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja489198/index.html">Liquibaseを使って足を撃たない方法</a></li>
<li><a href="../ja489200/index.html">2020年にY Combinatorを探しているスタートアップ</a></li>
<li><a href="../ja489204/index.html">Facebookサービスの信頼性の内部</a></li>
<li><a href="../ja489206/index.html">Patroniによるクラッシュストーリー、またはPostgreSQLクラスターを削除する方法</a></li>
<li><a href="../ja489208/index.html">オンライン取引のための仮想サーバー</a></li>
<li><a href="../ja489212/index.html">1C-Bitrixは、個人データの送信を要求することにより、ニュースレターの配信停止を防ぎます</a></li>
<li><a href="../ja489214/index.html">iOSでローカリゼーションをテストするための最新のアプローチ</a></li>
<li><a href="../ja489218/index.html">初心者です。スーパー：シンプルなゲームのコードとアーキテクチャ</a></li>
<li><a href="../ja489226/index.html">C＃.NETでLINQクエリを最適化する方法</a></li>
<li><a href="../ja489228/index.html">銀行のスピーチボット-史上最悪のUX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>