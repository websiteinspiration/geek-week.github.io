<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏿 🦋 🎙️ 您在图形处理单元（GPU）上的第一个神经网络。初学者指南 💂🏼 🧜🏼 💖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我将告诉您如何在30分钟内设置机器学习环境，创建用于图像识别的神经网络，然后在图形处理单元（GPU）上运行相同的网络。
 
 首先，让我们定义什么是神经网络。
 
 在我们的案例中，这是一个数学模型及其软件或硬件实现，建立在生物神经网络（活生物体神经细胞网络）的组织和功能原理之上。这个概念...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>您在图形处理单元（GPU）上的第一个神经网络。初学者指南</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488564/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/wg/sv/g2/wgsvg24lytktztdczee_4rteb28.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我将告诉您如何在30分钟内设置机器学习环境，创建用于图像识别的神经网络，然后在图形处理单元（GPU）上运行相同的网络。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，让我们定义什么是神经网络。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的案例中，这是一个数学模型及其软件或硬件实现，建立在生物神经网络（活生物体神经细胞网络）的组织和功能原理之上。这个概念产生于研究大脑中发生的过程，并试图模拟这些过程。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
神经网络不是按照通常的含义编程的，而是经过训练的。</font><font style="vertical-align: inherit;">与传统算法相比，学习能力是神经网络的主要优势之一。</font><font style="vertical-align: inherit;">从技术上讲，训练在于找到神经元之间的连接系数。</font><font style="vertical-align: inherit;">在学习过程中，神经网络能够识别输入和输出之间的复杂关系，并进行概括。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从机器学习的角度来看，神经网络是模式识别方法，判别分析，聚类方法和其他方法的特例。</font></font><br>
 <br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设备</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，让我们处理设备。我们需要一台装有Linux操作系统的服务器。用于机器学习系统的操作的设备需要足够强大并且因此很昂贵。对于那些没有好的汽车的人，我建议您注意云提供商的服务。可以快速租用必要的服务器，并且只需为使用时间付费。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在需要创建神经网络的项目中，我使用俄罗斯一家云提供商的服务器。</font><font style="vertical-align: inherit;">该公司通过NVIDIA提供的强大的Tesla V100图形处理单元（GPU）提供专门用于机器学习的租赁云服务器。</font><font style="vertical-align: inherit;">简而言之：与具有类似成本并且使用CPU（众所周知的中央处理器）的服务器相比，将具有GPU的服务器使用起来效率（速度）提高数十倍。</font><font style="vertical-align: inherit;">这是由于GPU架构的细节而实现的，它可以更快地处理计算。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了执行以下示例，我们花了几天时间购买了以下服务器：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">150 GB固态硬盘</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内存32 GB</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有4核的Tesla V100 16 Gb处理器</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ubuntu 18.04已安装在计算机上。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置环境</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，在服务器上安装您需要工作的所有内容。</font><font style="vertical-align: inherit;">由于我们的文章主要是针对初学者的，因此我将在其中讨论一些对他们有用的观点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
设置环境时，许多工作都是通过命令行完成的。</font><font style="vertical-align: inherit;">大多数用户将Windows用作工作操作系统。</font><font style="vertical-align: inherit;">这个操作系统中的标准控制台还有很多不足之处。</font><font style="vertical-align: inherit;">因此，我们将使用方便的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cmder /</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工具</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">下载迷你版本并运行Cmder.exe。</font><font style="vertical-align: inherit;">接下来，您需要通过SSH连接到服务器：</font></font><br>
<br>
<pre><code class="bash hljs">ssh root@server-ip-or-hostname</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指定服务器的IP地址或DNS名称而不是server-ip-or-hostname。</font><font style="vertical-align: inherit;">接下来，输入密码，成功连接后，我们应该会得到类似的信息。</font></font><br>
<br>
<pre><code class="bash hljs">Welcome to Ubuntu 18.04.3 LTS (GNU/Linux 4.15.0-74-generic x86_64)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
开发ML模型的主要语言是Python。</font><font style="vertical-align: inherit;">在Linux上使用它的最受欢迎的平台是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anaconda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将其安装在我们的服务器上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们首先更新本地软件包管理器：</font></font><br>
<br>
<pre><code class="bash hljs">sudo apt-get update</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
安装curl（命令行实用程序）：</font></font><br>
<br>
<pre><code class="bash hljs">sudo apt-get install curl</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下载最新版本的Anaconda发行版：</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-built_in">cd</span> /tmp<font></font>
curl –O https://repo.anaconda.com/archive/Anaconda3-2019.10-Linux-x86_64.sh</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们开始安装：</font></font><br>
<br>
<pre><code class="bash hljs">bash Anaconda3-2019.10-Linux-x86_64.sh</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在安装过程中，您需要确认许可协议。</font><font style="vertical-align: inherit;">成功安装后，您应该会看到以下内容：</font></font><br>
<br>
<pre><code class="bash hljs">Thank you <span class="hljs-keyword">for</span> installing Anaconda3!</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了开发ML模型，现在创建了许多框架，我们使用最受欢迎的框架：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PyTorch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tensorflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用该框架可以提高开发速度，并可以将现成的工具用于标准任务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此示例中，我们将使用PyTorch。</font><font style="vertical-align: inherit;">安装它：</font></font><br>
<br>
<pre><code class="bash hljs">conda install pytorch torchvision cudatoolkit=10.1 -c pytorch</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们需要启动Jupyter Notebook-ML专家中流行的开发工具。</font><font style="vertical-align: inherit;">它允许您编写代码并立即查看其执行结果。</font><font style="vertical-align: inherit;">Jupyter Notebook是Anaconda的一部分，已经安装在我们的服务器上。</font><font style="vertical-align: inherit;">您需要从我们的桌面系统连接到它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，我们首先通过指定端口8080在服务器上运行Jupyter：</font></font><br>
<br>
<pre><code class="bash hljs">jupyter notebook --no-browser --port=8080 --allow-root</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，在我们的Cmder控制台中打开另一个选项卡（顶部菜单是“新建”控制台对话框），通过SSH将端口8080连接到服务器：</font></font><br>
<br>
<pre><code class="plaintext hljs">ssh -L 8080:localhost:8080 root@server-ip-or-hostname</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当您输入第一个命令时，将为我们提供在浏览器中打开Jupyter的链接：</font></font><br>
<br>
<pre><code class="bash hljs">To access the notebook, open this file <span class="hljs-keyword">in</span> a browser:<font></font>
        file:///root/.<span class="hljs-built_in">local</span>/share/jupyter/runtime/nbserver-18788-open.html<font></font>
    Or copy and paste one of these URLs:<font></font>
        http://localhost:8080/?token=cca0bd0b30857821194b9018a5394a4ed2322236f116d311<font></font>
     or http://127.0.0.1:8080/?token=cca0bd0b30857821194b9018a5394a4ed2322236f116d311<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用本地主机的链接：8080。</font><font style="vertical-align: inherit;">复制完整路径，然后粘贴到PC本地浏览器的地址栏中。</font><font style="vertical-align: inherit;">Jupyter笔记本打开。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们创建一个新的笔记本电脑：新建-笔记本电脑-Python 3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
检查我们安装的所有组件的正确操作。</font><font style="vertical-align: inherit;">我们在Jupyter中引入了一个PyTorch代码示例，并开始执行（运行按钮）：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function
<span class="hljs-keyword">import</span> torch<font></font>
x = torch.rand(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)<font></font>
print(x)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果应该是这样的：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ps/o8/su/pso8sugii4txi_beqrbx13nsry8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您有类似的结果，那么我们所有人都正确设置了，就可以开始开发神经网络了！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建一个神经网络</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将创建一个用于图像识别的神经网络。</font><font style="vertical-align: inherit;">我们以本</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指南为</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基础</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了训练网络，我们将使用公共可用的CIFAR10数据集。</font><font style="vertical-align: inherit;">他上过课：“飞机”，“汽车”，“鸟”，“猫”，“鹿”，“狗”，“青蛙”，“马”，“船”，“卡车”。</font><font style="vertical-align: inherit;">CIFAR10中的图像尺寸为3x32x32，即32x32像素的3通道彩色图像。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/wg/sv/g2/wgsvg24lytktztdczee_4rteb28.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于工作，我们将使用创建的PyTorch软件包来处理图像-torchvision。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将按以下步骤进行操作：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载并标准化培训和测试数据集</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">神经网络定义</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">培训数据网络培训</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用测试数据测试网络</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重复进行GPU培训和测试</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下面的所有代码我们都将在Jupyter Notebook中执行。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载并标准化CIFAR10</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Jupyter中复制并执行以下代码：</font></font><br>
<br>
<pre><code class="python hljs">
<span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">import</span> torchvision
<span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms<font></font>
<font></font>
transform = transforms.Compose(<font></font>
    [transforms.ToTensor(),<font></font>
     transforms.Normalize((<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>), (<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>))])<font></font>
<font></font>
trainset = torchvision.datasets.CIFAR10(root=<span class="hljs-string">'./data'</span>, train=<span class="hljs-literal">True</span>,<font></font>
                                        download=<span class="hljs-literal">True</span>, transform=transform)<font></font>
trainloader = torch.utils.data.DataLoader(trainset, batch_size=<span class="hljs-number">4</span>,<font></font>
                                          shuffle=<span class="hljs-literal">True</span>, num_workers=<span class="hljs-number">2</span>)<font></font>
<font></font>
testset = torchvision.datasets.CIFAR10(root=<span class="hljs-string">'./data'</span>, train=<span class="hljs-literal">False</span>,<font></font>
                                       download=<span class="hljs-literal">True</span>, transform=transform)<font></font>
testloader = torch.utils.data.DataLoader(testset, batch_size=<span class="hljs-number">4</span>,<font></font>
                                         shuffle=<span class="hljs-literal">False</span>, num_workers=<span class="hljs-number">2</span>)<font></font>
<font></font>
classes = (<span class="hljs-string">'plane'</span>, <span class="hljs-string">'car'</span>, <span class="hljs-string">'bird'</span>, <span class="hljs-string">'cat'</span>,
           <span class="hljs-string">'deer'</span>, <span class="hljs-string">'dog'</span>, <span class="hljs-string">'frog'</span>, <span class="hljs-string">'horse'</span>, <span class="hljs-string">'ship'</span>, <span class="hljs-string">'truck'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
答案应该是这样的：</font></font><br>
<br>
<pre><code class="python hljs">Downloading https://www.cs.toronto.edu/~kriz/cifar<span class="hljs-number">-10</span>-python.tar.gz to ./data/cifar<span class="hljs-number">-10</span>-python.tar.gz<font></font>
Extracting ./data/cifar<span class="hljs-number">-10</span>-python.tar.gz to ./data<font></font>
Files already downloaded <span class="hljs-keyword">and</span> verified</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将导出几个训练图像进行检查：</font></font><br>
<br>
<pre><code class="python hljs">
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<font></font>
<font></font>
<span class="hljs-comment"># functions to show an image</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">imshow</span>(<span class="hljs-params">img</span>):</span>
    img = img / <span class="hljs-number">2</span> + <span class="hljs-number">0.5</span>     <span class="hljs-comment"># unnormalize</span><font></font>
    npimg = img.numpy()<font></font>
    plt.imshow(np.transpose(npimg, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)))<font></font>
    plt.show()<font></font>
<font></font>
<span class="hljs-comment"># get some random training images</span><font></font>
dataiter = iter(trainloader)<font></font>
images, labels = dataiter.next()<font></font>
<font></font>
<span class="hljs-comment"># show images</span><font></font>
imshow(torchvision.utils.make_grid(images))<font></font>
<span class="hljs-comment"># print labels</span>
print(<span class="hljs-string">' '</span>.join(<span class="hljs-string">'%5s'</span> % classes[labels[j]] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>)))
</code></pre><br>
<img src="https://habrastorage.org/webt/yy/w4/xw/yyw4xwjhaa6kfy41fvnylvz6qdy.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">神经网络定义</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们首先检查一下用于图像识别的神经网络如何工作。</font><font style="vertical-align: inherit;">这是一个简单的直接连接网络。</font><font style="vertical-align: inherit;">它获取输入，将其一层一层地传递给多层，然后最终给出输出。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t8/4m/yg/t84mygi1sjuzssoezguistupmeo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们在环境中创建一个类似的网络：</font></font><br>
<br>
<pre><code class="python hljs">
<span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn
<span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Net</span>(<span class="hljs-params">nn.Module</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><font></font>
        super(Net, self).__init__()<font></font>
        self.conv1 = nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)<font></font>
        self.pool = nn.MaxPool2d(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<font></font>
        self.conv2 = nn.Conv2d(<span class="hljs-number">6</span>, <span class="hljs-number">16</span>, <span class="hljs-number">5</span>)<font></font>
        self.fc1 = nn.Linear(<span class="hljs-number">16</span> * <span class="hljs-number">5</span> * <span class="hljs-number">5</span>, <span class="hljs-number">120</span>)<font></font>
        self.fc2 = nn.Linear(<span class="hljs-number">120</span>, <span class="hljs-number">84</span>)<font></font>
        self.fc3 = nn.Linear(<span class="hljs-number">84</span>, <span class="hljs-number">10</span>)<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><font></font>
        x = self.pool(F.relu(self.conv1(x)))<font></font>
        x = self.pool(F.relu(self.conv2(x)))<font></font>
        x = x.view(<span class="hljs-number">-1</span>, <span class="hljs-number">16</span> * <span class="hljs-number">5</span> * <span class="hljs-number">5</span>)<font></font>
        x = F.relu(self.fc1(x))<font></font>
        x = F.relu(self.fc2(x))<font></font>
        x = self.fc3(x)<font></font>
        <span class="hljs-keyword">return</span> x<font></font>
<font></font>
net = Net()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们还定义了损失函数和优化器 </font></font><br>
<br>
<pre><code class="python hljs">
<span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<font></font>
<font></font>
criterion = nn.CrossEntropyLoss()<font></font>
optimizer = optim.SGD(net.parameters(), lr=<span class="hljs-number">0.001</span>, momentum=<span class="hljs-number">0.9</span>)</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">培训数据网络培训</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们开始训练我们的神经网络。</font><font style="vertical-align: inherit;">我提请您注意，在此之后，在运行此代码时，您将需要等待一段时间才能完成工作。</font><font style="vertical-align: inherit;">我花了5分钟。</font><font style="vertical-align: inherit;">联网需要时间。</font></font><br>
<br>
<pre><code class="python hljs"> <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):  <span class="hljs-comment"># loop over the dataset multiple times</span><font></font>
<font></font>
    running_loss = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> enumerate(trainloader, <span class="hljs-number">0</span>):
        <span class="hljs-comment"># get the inputs; data is a list of [inputs, labels]</span><font></font>
        inputs, labels = data<font></font>
<font></font>
        <span class="hljs-comment"># zero the parameter gradients</span><font></font>
        optimizer.zero_grad()<font></font>
<font></font>
        <span class="hljs-comment"># forward + backward + optimize</span><font></font>
        outputs = net(inputs)<font></font>
        loss = criterion(outputs, labels)<font></font>
        loss.backward()<font></font>
        optimizer.step()<font></font>
<font></font>
        <span class="hljs-comment"># print statistics</span><font></font>
        running_loss += loss.item()<font></font>
        <span class="hljs-keyword">if</span> i % <span class="hljs-number">2000</span> == <span class="hljs-number">1999</span>:    <span class="hljs-comment"># print every 2000 mini-batches</span>
            print(<span class="hljs-string">'[%d, %5d] loss: %.3f'</span> %<font></font>
                  (epoch + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, running_loss / <span class="hljs-number">2000</span>))<font></font>
            running_loss = <span class="hljs-number">0.0</span><font></font>
<font></font>
print(<span class="hljs-string">'Finished Training'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们得到以下结果：我们</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sw/05/k2/sw05k2ewk-gu9fiyrv3xncxjaki.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
保存训练有素的模型：</font></font><br>
<br>
<pre><code class="python hljs">PATH = <span class="hljs-string">'./cifar_net.pth'</span>
torch.save(net.state_dict(), PATH)</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用测试数据测试网络</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们使用了一组训练数据来训练网络。</font><font style="vertical-align: inherit;">但是我们需要检查网络是否学到了什么。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将通过预测神经网络输出的类别标签并检查真相来验证这一点。</font><font style="vertical-align: inherit;">如果预测正确，则将样本添加到正确预测列表中。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们显示测试套件中的图像：</font></font><br>
<br>
<pre><code class="python hljs">dataiter = iter(testloader)<font></font>
images, labels = dataiter.next()<font></font>
<font></font>
<span class="hljs-comment"># print images</span><font></font>
imshow(torchvision.utils.make_grid(images))<font></font>
print(<span class="hljs-string">'GroundTruth: '</span>, <span class="hljs-string">' '</span>.join(<span class="hljs-string">'%5s'</span> % classes[labels[j]] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>)))</code></pre><br>
<img src="https://habrastorage.org/webt/hp/ph/zm/hpphzma6rus04gw-edxsowf1ifu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在让神经网络告诉我们这些图片是什么：</font></font><br>
<br>
<pre><code class="python hljs"><font></font>
net = Net()<font></font>
net.load_state_dict(torch.load(PATH))<font></font>
<font></font>
outputs = net(images)<font></font>
<font></font>
_, predicted = torch.max(outputs, <span class="hljs-number">1</span>)<font></font>
<font></font>
print(<span class="hljs-string">'Predicted: '</span>, <span class="hljs-string">' '</span>.join(<span class="hljs-string">'%5s'</span> % classes[predicted[j]]
                              <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>)))
</code></pre><br>
<img src="https://habrastorage.org/webt/j2/vp/uc/j2vpucdaps0fuci2yg38ip2fbdo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果似乎还不错：网络正确识别了四张图片中的三张。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看看网络如何在整个数据集中工作。</font></font><br>
<br>
<pre><code class="python hljs">
correct = <span class="hljs-number">0</span>
total = <span class="hljs-number">0</span>
<span class="hljs-keyword">with</span> torch.no_grad():
    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> testloader:<font></font>
        images, labels = data<font></font>
        outputs = net(images)<font></font>
        _, predicted = torch.max(outputs.data, <span class="hljs-number">1</span>)<font></font>
        total += labels.size(<span class="hljs-number">0</span>)<font></font>
        correct += (predicted == labels).sum().item()<font></font>
<font></font>
print(<span class="hljs-string">'Accuracy of the network on the 10000 test images: %d %%'</span> % (
    <span class="hljs-number">100</span> * correct / total))</code></pre><br>
<img src="https://habrastorage.org/webt/fy/i4/cn/fyi4cnkjgimshkhhbsva4udixhw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看起来网络知道并且可以正常工作。</font><font style="vertical-align: inherit;">如果他随机定义班级，那么准确性将是10％。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们看看网络定义的更好的类：</font></font><br>
<br>
<pre><code class="python hljs">class_correct = list(<span class="hljs-number">0.</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>))<font></font>
class_total = list(<span class="hljs-number">0.</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>))
<span class="hljs-keyword">with</span> torch.no_grad():
    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> testloader:<font></font>
        images, labels = data<font></font>
        outputs = net(images)<font></font>
        _, predicted = torch.max(outputs, <span class="hljs-number">1</span>)<font></font>
        c = (predicted == labels).squeeze()<font></font>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):<font></font>
            label = labels[i]<font></font>
            class_correct[label] += c[i].item()<font></font>
            class_total[label] += <span class="hljs-number">1</span><font></font>
<font></font>
<font></font>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<font></font>
    print(<span class="hljs-string">'Accuracy of %5s : %2d %%'</span> % (<font></font>
        classes[i], <span class="hljs-number">100</span> * class_correct[i] / class_total[i]))</code></pre><br>
<img src="https://habrastorage.org/webt/l9/s9/qu/l9s9quxd-lzx2kh7wphxe9-2qzs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该网络似乎确定了汽车和船舶的最佳状态：准确性为71％。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此网络正在运行。</font><font style="vertical-align: inherit;">现在，让我们尝试将其工作转移到图形处理器（GPU），看看有什么变化。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU神经网络训练</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我将简要说明什么是CUDA。</font><font style="vertical-align: inherit;">CUDA（计算统一设备体系结构）是NVIDIA开发的一种并行计算平台，用于GPU上的常规计算。</font><font style="vertical-align: inherit;">借助CUDA，开发人员可以使用GPU的功能极大地加速计算应用程序。</font><font style="vertical-align: inherit;">在我们购买的服务器上，已经安装了该平台。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先让我们将GPU定义为第一个可见的cuda设备。</font></font><br>
<br>
<pre><code class="python hljs">device = torch . device ( <span class="hljs-string">"cuda:0"</span> <span class="hljs-keyword">if</span> torch . cuda . is_available () <span class="hljs-keyword">else</span> <span class="hljs-string">"cpu"</span> )
<span class="hljs-comment"># Assuming that we are on a CUDA machine, this should print a CUDA device:</span>
<span class="hljs-keyword">print</span> ( device )</code></pre><br>
<img src="https://habrastorage.org/webt/n2/2k/bf/n22kbfvilr6kn30eel6dfhaose4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将网络发送到GPU：</font></font><br>
 <br>
<pre><code class="python hljs">net.to(device)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们还必须在每一步将输入和目标发送到GPU：</font></font><br>
<br>
<pre><code class="python hljs">inputs, labels = data[<span class="hljs-number">0</span>].to(device), data[<span class="hljs-number">1</span>].to(device)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在GPU上运行网络重新训练： </font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<font></font>
<font></font>
criterion = nn.CrossEntropyLoss()<font></font>
optimizer = optim.SGD(net.parameters(), lr=<span class="hljs-number">0.001</span>, momentum=<span class="hljs-number">0.9</span>)
<span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):  <span class="hljs-comment"># loop over the dataset multiple times</span><font></font>
<font></font>
    running_loss = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> enumerate(trainloader, <span class="hljs-number">0</span>):
        <span class="hljs-comment"># get the inputs; data is a list of [inputs, labels]</span>
    inputs, labels = data[<span class="hljs-number">0</span>].to(device), data[<span class="hljs-number">1</span>].to(device)<font></font>
<font></font>
        <span class="hljs-comment"># zero the parameter gradients</span><font></font>
        optimizer.zero_grad()<font></font>
<font></font>
        <span class="hljs-comment"># forward + backward + optimize</span><font></font>
        outputs = net(inputs)<font></font>
        loss = criterion(outputs, labels)<font></font>
        loss.backward()<font></font>
        optimizer.step()<font></font>
<font></font>
        <span class="hljs-comment"># print statistics</span><font></font>
        running_loss += loss.item()<font></font>
        <span class="hljs-keyword">if</span> i % <span class="hljs-number">2000</span> == <span class="hljs-number">1999</span>:    <span class="hljs-comment"># print every 2000 mini-batches</span>
            print(<span class="hljs-string">'[%d, %5d] loss: %.3f'</span> %<font></font>
                  (epoch + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, running_loss / <span class="hljs-number">2000</span>))<font></font>
            running_loss = <span class="hljs-number">0.0</span><font></font>
<font></font>
print(<span class="hljs-string">'Finished Training'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这次，网络培训持续了大约3分钟。</font><font style="vertical-align: inherit;">回想一下，在常规处理器上的同一阶段持续了5分钟。</font><font style="vertical-align: inherit;">差异不大，这是因为我们的网络不是很大。</font><font style="vertical-align: inherit;">当使用大型阵列进行训练时，GPU和传统处理器之间的速度差异将增大。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好像就这些了。</font><font style="vertical-align: inherit;">我们设法做到的：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们检查了GPU是什么，并选择了安装GPU的服务器；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们建立了一个用于创建神经网络的软件环境；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们创建了一个用于图像识别的神经网络并对其进行了训练。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用GPU重复了网络训练，并提高了速度。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我很高兴在评论中回答问题。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN488548/index.html">实验：如何学习创建流行的英语文本（以及为什么说英语的哈伯族人读得这么少）</a></li>
<li><a href="../zh-CN488550/index.html">谁想要使合作伙伴脱离IT巨头</a></li>
<li><a href="../zh-CN488552/index.html">Apple FAS和家长控制开发人员</a></li>
<li><a href="../zh-CN488558/index.html">使用Kafka Streams确保应用程序的高可用性</a></li>
<li><a href="../zh-CN488560/index.html">在Google Cloud Platform上托管的免费Telegram机器人</a></li>
<li><a href="../zh-CN488566/index.html">质量检查工程师如何通过链接Visual Studio中的自动测试和测试IT来节省一整天</a></li>
<li><a href="../zh-CN488568/index.html">神经网络是否梦想着用电钱？</a></li>
<li><a href="../zh-CN488570/index.html">美国特勤局如何将网络朋克RPG与黑客教科书混淆</a></li>
<li><a href="../zh-CN488572/index.html">Unity分析仪现已开源</a></li>
<li><a href="../zh-CN488574/index.html">学生为STM32F411写Uart驱动程序</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>