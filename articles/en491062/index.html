<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏽 🧑🏿‍🤝‍🧑🏿 🐅 Angular: creating a custom form element and passing form state to it 🤸🏽 📡 🕥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The various forms in our web applications are often built from the same brick elements. Component frameworks help us get rid of repeatable code, and n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Angular: creating a custom form element and passing form state to it</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491062/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The various forms in our web applications are often built from the same brick elements. </font><font style="vertical-align: inherit;">Component frameworks help us get rid of repeatable code, and now I want to consider one of these approaches. </font><font style="vertical-align: inherit;">So, as is customary in Angular.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Technical task:</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you need to create the component "form element for entering SNILS";</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The component should format the entered values ​​by mask;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The component must validate the input.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the component should work as part of the reactive form;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an incomplete form must maintain its state between reboots;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> when loading the page, once the edited form should immediately show errors;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> used by Angular Material.</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creating a project and installing dependencies</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create a test project</font></font></h4><br>
<pre><code class="plaintext hljs">ng new input-snils</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Install third-party libraries</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First of all, Angular Material itself</font></font><br>
<br>
<pre><code class="plaintext hljs">ng add @angular/material</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then we need to mask and check the SNILS themselves according to the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rules for calculating the checksum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Install the libraries:</font></font><br>
<br>
<pre><code class="plaintext hljs">npm install ngx-mask ru-validation-codes</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saving form data</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preparing a service for working with localStorage</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Form data will be stored in localStorage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can immediately take the browser methods for working with LS, but in Angular it is customary to try to write universal code, and keep all external dependencies under control. It also simplifies testing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, it will be correct when the class gets all its dependencies from the DI container. Remembering the cat Matroskin - in order to buy something unnecessary from the injector, you must first sell something unnecessary to the injector. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Create a </font><b><font style="vertical-align: inherit;">window.provider.ts</font></b><font style="vertical-align: inherit;"> provider</font></font><br>
<br>
<b><font style="vertical-align: inherit;"></font></b><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { InjectionToken } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWindow</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> WINDOW = <span class="hljs-keyword">new</span> InjectionToken(<span class="hljs-string">'Window'</span>, {
  <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span>,
  <span class="hljs-attr">factory</span>: getWindow,<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What's going on here? </font><font style="vertical-align: inherit;">Angular's DI Injector remembers tokens and gives away entities that are associated with them. </font><font style="vertical-align: inherit;">Token - it can be an InjectionToken object, a string or a class. </font><font style="vertical-align: inherit;">This creates a new root-level InjectionToken and communicates with the factory, which returns the browser </font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now that we have a window, let's create a simple service for working with LocalStorage </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">storage.service.ts</font></font></b><br>
<br>
<pre><code class="javascript hljs">@Injectable({
  <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StorageService</span> </span>{<font></font>
  readonly prefix = <span class="hljs-string">'snils-input__'</span>;<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(<font></font>
    @Inject(WINDOW) private window: Window,<font></font>
  ) {}<font></font>
<font></font>
  public set&lt;T&gt;(key: string, <span class="hljs-attr">data</span>: T): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.window.localStorage.setItem(<span class="hljs-keyword">this</span>.prefix + key, <span class="hljs-built_in">JSON</span>.stringify(data));<font></font>
  }<font></font>
<font></font>
  public get&lt;T&gt;(key: string): T {<font></font>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-keyword">this</span>.window.localStorage.getItem(<span class="hljs-keyword">this</span>.prefix + key));<font></font>
    } <span class="hljs-keyword">catch</span> (e) { }<font></font>
  }<font></font>
<font></font>
  public remove(key: string): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.window.localStorage.removeItem(<span class="hljs-keyword">this</span>.prefix + key);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
StorageService takes a window from an injector and provides its own wrappers for saving and reading data. </font><font style="vertical-align: inherit;">I did not make the prefix configurable so as not to overload the article with a description of how to create modules with a configuration.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FormPersistModule</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We create a simple service for saving form data. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">form-persist.service.ts</font></font></b><br>
<br>
<pre><code class="javascript hljs">@Injectable({
  <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FormPersistService</span> </span>{<font></font>
  private subscriptions: Record&lt;string, Subscription&gt; = {};<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(<font></font>
    private storageService: StorageService,<font></font>
  ) { }<font></font>
<font></font>
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@returns </span>restored data if exists
   */</span>
  public registerForm&lt;T&gt;(formName: string, <span class="hljs-attr">form</span>: AbstractControl): T {
    <span class="hljs-keyword">this</span>.subscriptions[formName]?.unsubscribe();
    <span class="hljs-keyword">this</span>.subscriptions[formName] = <span class="hljs-keyword">this</span>.createFormSubscription(formName, form);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.restoreData(formName, form);<font></font>
  }<font></font>
<font></font>
  public unregisterForm(formName: string): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.storageService.remove(formName);<font></font>
<font></font>
    <span class="hljs-keyword">this</span>.subscriptions[formName]?.unsubscribe();
    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.subscriptions[formName];<font></font>
  }<font></font>
<font></font>
  public restoreData&lt;T&gt;(formName: string, <span class="hljs-attr">form</span>: AbstractControl): T {
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">this</span>.storageService.get(formName) <span class="hljs-keyword">as</span> T;
    <span class="hljs-keyword">if</span> (data) {<font></font>
      form.patchValue(data, { <span class="hljs-attr">emitEvent</span>: <span class="hljs-literal">false</span> });<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> data;<font></font>
  }<font></font>
<font></font>
  private createFormSubscription(formName: string, <span class="hljs-attr">form</span>: AbstractControl): Subscription {
    <span class="hljs-keyword">return</span> form.valueChanges.pipe(<font></font>
      debounceTime(<span class="hljs-number">500</span>),<font></font>
    )<font></font>
      .subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
        <span class="hljs-keyword">this</span>.storageService.set(formName, value);<font></font>
      });<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FormPersistService is able to register forms with the passed string key. Registration means that the form data will be saved in LS with every change. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When registering, the value extracted from LS is also returned so that it is possible to understand that the form has already been saved earlier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unregister ( </font></font><code>unregisterForm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) terminates the save process and deletes the entry in LS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I would like to describe the storage functionality declaratively, and not do it every time in the component code. Angular lets you do miracles with the help of directives, and right now that is the case. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Create the </font><b><font style="vertical-align: inherit;">form-persist.directive.ts</font></b><font style="vertical-align: inherit;"> directive</font></font><br>
<b><font style="vertical-align: inherit;"></font></b><br>
<br>
<pre><code class="javascript hljs">@Directive({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'form[formPersist]'</span>, <span class="hljs-comment">// tslint:disable-line: directive-selector</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FormPersistDirective</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span> </span>{<font></font>
  @Input() formPersist: string;<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(<font></font>
    private formPersistService: FormPersistService,<font></font>
    @Self() private formGroup: FormGroupDirective,<font></font>
  ) { }<font></font>
<font></font>
  @HostListener(<span class="hljs-string">'submit'</span>)<font></font>
  onSubmit() {<font></font>
    <span class="hljs-keyword">this</span>.formPersistService.unregisterForm(<span class="hljs-keyword">this</span>.formPersist);<font></font>
  }<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">const</span> savedValue = <span class="hljs-keyword">this</span>.formPersistService.registerForm(<span class="hljs-keyword">this</span>.formPersist, <span class="hljs-keyword">this</span>.formGroup.control);
    <span class="hljs-keyword">if</span> (savedValue) {
      <span class="hljs-keyword">this</span>.formGroup.control.markAllAsTouched();<font></font>
    }<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When superimposed on the form, FormPersistDirective pulls out another directive from the local injector - FormGroupDirective and takes the reactive form object from there to register with FormPersistService. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The registration key must be taken from the template, the form itself does not have any unique identifier inherent in it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When submitting a form, registration should be canceled. </font><font style="vertical-align: inherit;">To do this, listen for the submit event using HostListener. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The directive also needs to be delivered to components where it can be used. </font><font style="vertical-align: inherit;">It is good practice to create separate small modules for each reused entity. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">form-persist.module.ts</font></font></b><br>
<br>
<pre><code class="javascript hljs">@NgModule({
  <span class="hljs-attr">declarations</span>: [FormPersistDirective],
  <span class="hljs-attr">exports</span>: [FormPersistDirective]<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FormPersistModule</span> </span>{ }</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Element of the SNILS form</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What tasks are assigned to it? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First of all, it must validate the data.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">snilsValidator</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angular allows you to attach your validators to form controls, and it's time to make your own. </font><font style="vertical-align: inherit;">To check the SNILS, I use the external ru-validation-codes library and the validator will be quite simple. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">snils.validator.ts</font></font></b><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { checkSnils } <span class="hljs-keyword">from</span> <span class="hljs-string">'ru-validation-codes'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">snilsValidator</span>(<span class="hljs-params">control: AbstractControl</span>): <span class="hljs-title">ValidationErrors</span> | <span class="hljs-title">null</span> </span>{
  <span class="hljs-keyword">if</span> (control.value === <span class="hljs-string">''</span>  || control.value === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> checkSnils(control.value)<font></font>
    ? <span class="hljs-literal">null</span>
    : { <span class="hljs-attr">snils</span>: <span class="hljs-string">'error'</span> };<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Component InputSnilsComponent</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The component template consists of a wrapped input field, a classic version from the Angular Material library. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With one small addition, an input mask will be superimposed on the input using the external library ngx-mask, from it here the input parameters mask - sets the mask and dropSpecialCharacters - turns off the removal of special mask characters from the value. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
See the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx-mask documentation for</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> more details. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is the </font><b><font style="vertical-align: inherit;">input-snils.component.html</font></b><font style="vertical-align: inherit;"> component template</font></font><br>
<b><font style="vertical-align: inherit;"></font></b><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">mat-form-field</span> <span class="hljs-attr">appearance</span>=<span class="hljs-string">"outline"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
    <span class="hljs-attr">matInput</span>
    <span class="hljs-attr">autocomplete</span>=<span class="hljs-string">"snils"</span>
    [<span class="hljs-attr">formControl</span>]=<span class="hljs-string">"formControl"</span>
    [<span class="hljs-attr">mask</span>]=<span class="hljs-string">"mask"</span>
    [<span class="hljs-attr">dropSpecialCharacters</span>]=<span class="hljs-string">"false"</span>
    [<span class="hljs-attr">placeholder</span>]=<span class="hljs-string">"placeholder"</span>
    [<span class="hljs-attr">readonly</span>]=<span class="hljs-string">"readonly"</span>
    [<span class="hljs-attr">required</span>]=<span class="hljs-string">"required"</span>
    [<span class="hljs-attr">tabIndex</span>]=<span class="hljs-string">"tabIndex"</span>
  &gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-error</span> [<span class="hljs-attr">hidden</span>]=<span class="hljs-string">"formControl | snilsErrors: 'required'"</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">mat-error</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-error</span> [<span class="hljs-attr">hidden</span>]=<span class="hljs-string">"formControl | snilsErrors: 'format'"</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">mat-error</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-error</span> [<span class="hljs-attr">hidden</span>]=<span class="hljs-string">"formControl | snilsErrors: 'snils'"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">mat-error</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-form-field</span>&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The question is, what is this formControl | </font><font style="vertical-align: inherit;">snilsErrors? </font><font style="vertical-align: inherit;">This is a custom pipe for displaying errors, now we will create it. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">snils-errors.pipe.ts</font></font></b><br>
<br>
<pre><code class="javascript hljs">type ErrorType = <span class="hljs-string">'required'</span> | <span class="hljs-string">'format'</span> | <span class="hljs-string">'snils'</span>;<font></font>
<font></font>
@Pipe({<font></font>
  <span class="hljs-attr">name</span>: <span class="hljs-string">'snilsErrors'</span>,
  <span class="hljs-attr">pure</span>: <span class="hljs-literal">false</span>,<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SnilsErrorsPipe</span> <span class="hljs-title">implements</span> <span class="hljs-title">PipeTransform</span> </span>{<font></font>
<font></font>
  transform(control: AbstractControl, <span class="hljs-attr">errorrType</span>: ErrorType): boolean {
    <span class="hljs-keyword">switch</span> (errorrType) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'required'</span>: <span class="hljs-keyword">return</span> !control.hasError(<span class="hljs-string">'required'</span>);
      <span class="hljs-keyword">case</span> <span class="hljs-string">'format'</span>: <span class="hljs-keyword">return</span> !control.hasError(<span class="hljs-string">'Mask error'</span>);
      <span class="hljs-keyword">case</span> <span class="hljs-string">'snils'</span>: <span class="hljs-keyword">return</span> control.hasError(<span class="hljs-string">'Mask error'</span>) || !control.hasError(<span class="hljs-string">'snils'</span>);
      <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The pipe is not clean, which means it will be executed every time changes are detected. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pipe accepts an error type parameter and detects errors of three types:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “Required” - this error is from the Angular directive RequiredValidator built-in</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Snils" - this error is from our validator snilsValidator</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Mask error" - this error from the MaskDirective directive from the ngx-mask library</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And it returns a boolean value - is there such an error or not. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, let's look at the </font><b><font style="vertical-align: inherit;">input-snils.component.ts</font></b><font style="vertical-align: inherit;"> component code </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itself</font></font></b><br>
<br>
<pre><code class="javascript hljs">@Component({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-input-snils'</span>,
  <span class="hljs-attr">templateUrl</span>: <span class="hljs-string">'./input-snils.component.html'</span>,
  <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">'./input-snils.component.css'</span>],
  <span class="hljs-attr">encapsulation</span>: ViewEncapsulation.None,
  <span class="hljs-attr">providers</span>: [<font></font>
    {<font></font>
      <span class="hljs-attr">provide</span>: NG_VALUE_ACCESSOR,
      <span class="hljs-attr">useExisting</span>: forwardRef(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> InputSnilsComponent),
      <span class="hljs-attr">multi</span>: <span class="hljs-literal">true</span><font></font>
    },<font></font>
    {<font></font>
      <span class="hljs-attr">provide</span>: NG_VALIDATORS,
      <span class="hljs-attr">useExisting</span>: forwardRef(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> InputSnilsComponent),
      <span class="hljs-attr">multi</span>: <span class="hljs-literal">true</span>,<font></font>
    },<font></font>
    {<font></font>
      <span class="hljs-attr">provide</span>: STATE_VALUE_ACCESSOR,
      <span class="hljs-attr">useExisting</span>: forwardRef(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> InputSnilsComponent),<font></font>
    },<font></font>
  ]<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputSnilsComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span>, <span class="hljs-title">ControlValueAccessor</span>, <span class="hljs-title">StateValueAccessor</span>, <span class="hljs-title">OnDestroy</span> </span>{<font></font>
  public mask = <span class="hljs-string">'000-000-000 00'</span>;<font></font>
  public formControl = <span class="hljs-keyword">new</span> FormControl(<span class="hljs-string">''</span>, [snilsValidator]);<font></font>
  private sub = <span class="hljs-keyword">new</span> Subscription();<font></font>
<font></font>
  @Input() readonly: boolean;<font></font>
  @Input() placeholder = <span class="hljs-string">''</span>;<font></font>
  @Input() tabIndex = <span class="hljs-number">0</span>;<font></font>
  @Input() required: boolean;<font></font>
<font></font>
  private onChange = <span class="hljs-function">(<span class="hljs-params">value: any</span>) =&gt;</span> { };<font></font>
  private onTouched = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { };<font></font>
  registerOnChange = <span class="hljs-function">(<span class="hljs-params">fn: (value: any</span>) =&gt;</span> {}) =&gt; <span class="hljs-keyword">this</span>.onChange = fn;<font></font>
  registerOnTouched = <span class="hljs-function">(<span class="hljs-params">fn: (</span>) =&gt;</span> {}) =&gt; <span class="hljs-keyword">this</span>.onTouched = fn;<font></font>
<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">this</span>.sub = <span class="hljs-keyword">this</span>.linkForm();<font></font>
  }<font></font>
<font></font>
  ngOnDestroy() {<font></font>
    <span class="hljs-keyword">this</span>.sub.unsubscribe();<font></font>
  }<font></font>
<font></font>
  private linkForm(): Subscription {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.formControl.valueChanges.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
      <span class="hljs-keyword">this</span>.onTouched();
      <span class="hljs-keyword">this</span>.onChange(value);<font></font>
    });<font></font>
  }<font></font>
<font></font>
  writeValue(outsideValue: string): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">if</span> (outsideValue) {
      <span class="hljs-keyword">this</span>.onTouched();<font></font>
    }<font></font>
    <span class="hljs-keyword">this</span>.formControl.setValue(outsideValue, { <span class="hljs-attr">emitEvent</span>: <span class="hljs-literal">false</span> });<font></font>
  }<font></font>
<font></font>
  setDisabledState(disabled: boolean) {<font></font>
    disabled<font></font>
      ? <span class="hljs-keyword">this</span>.formControl.disable()<font></font>
      : <span class="hljs-keyword">this</span>.formControl.enable();<font></font>
  }<font></font>
<font></font>
  validate(): ValidationErrors | <span class="hljs-literal">null</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.formControl.errors;<font></font>
  }<font></font>
<font></font>
  setPristineState(pristine: boolean) {<font></font>
    pristine<font></font>
      ? <span class="hljs-keyword">this</span>.formControl.markAsPristine()<font></font>
      : <span class="hljs-keyword">this</span>.formControl.markAsDirty();<font></font>
<font></font>
    <span class="hljs-keyword">this</span>.formControl.updateValueAndValidity({ <span class="hljs-attr">emitEvent</span>: <span class="hljs-literal">false</span> });<font></font>
  }<font></font>
<font></font>
  setTouchedState(touched: boolean) {<font></font>
    touched<font></font>
      ? <span class="hljs-keyword">this</span>.formControl.markAsTouched()<font></font>
      : <span class="hljs-keyword">this</span>.formControl.markAsUntouched();<font></font>
<font></font>
    <span class="hljs-keyword">this</span>.formControl.updateValueAndValidity({ <span class="hljs-attr">emitEvent</span>: <span class="hljs-literal">false</span> });<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are a lot of things and I will not describe how to work with ControlValueAccessor, you can read about this in the Angular documentation, or for example here </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tyapk.ru/blog/post/angular-custom-form-field-control</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
What needs explanation here? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, we use the internal control of the form formControl, we attach to its changes to send the value change to the top, via the onChange and onTouched methods. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And vice versa, changes to the external form come to us through the writeValue and setDisabledState methods and are reflected in formControl. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secondly, there is an unknown STATE_VALUE_ACCESSOR token, an unknown StateValueAccessor interface and a couple of extra setPristineState and setTouchedState methods. They will be explained later. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the meantime, create a personal module for the component</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">input-snils.module.ts</font></font></b><br>
<br>
<pre><code class="javascript hljs">@NgModule({
  <span class="hljs-attr">declarations</span>: [InputSnilsComponent, SnilsErrorsPipe],
  <span class="hljs-attr">imports</span>: [<font></font>
    CommonModule,<font></font>
    MatFormFieldModule,<font></font>
    MatInputModule,<font></font>
    NgxMaskModule.forChild(),<font></font>
    ReactiveFormsModule,<font></font>
  ],<font></font>
  <span class="hljs-attr">exports</span>: [InputSnilsComponent],<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputSnilsModule</span> </span>{ }</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passing statuses to an item</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When using ControlValueAccessor, there is the following nuance: The </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
reactive form has touched and pristine states (hereinafter simply “states”).</font></font><br>
 <br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pristine is initially true and changes to false when the control value is changed from the template</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> touched initially false and changes to true when control lost focus</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
They can also be set forcibly, but this will not affect the control inside the ControlValueAccessor, for our component it is formControl. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And mat-error errors are rendered only when the current control is touched. We have a requirement that the restored form immediately display validation errors, so FormPersistDirective executes markAllAsTouched if the form value has been read from localStorage. But mat-errors will not be displayed, since they are inside our ControlValueAccessor component, they depend on the formControl control, and on this independent control the touched state is still false. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We need a mechanism for throwing these states. To do this, you can make your own analogue of ControlValueAccessor, let's call it StateValueAccessor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First you need to create a token and interface.</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">state-value-accessor.token.ts</font></font></b><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> STATE_VALUE_ACCESSOR = <span class="hljs-keyword">new</span> InjectionToken&lt;StateValueAccessor&gt;(<span class="hljs-string">'STATE_VALUE_ACCESSOR'</span>);</code></pre><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">state-value-accessor.interface.ts</font></font></b><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> interface StateValueAccessor {<font></font>
  setTouchedState?(touched: boolean): <span class="hljs-keyword">void</span>;<font></font>
  setPristineState?(pristine: boolean): <span class="hljs-keyword">void</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The interface describes the requirements for the class implementing it to have (optionally) two specified methods. </font><font style="vertical-align: inherit;">These methods are implemented in InputSnilsComponent and force these states on the internal control formControl. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then you need a directive to bind NgControl and our component that implements StateValueAccessor. </font><font style="vertical-align: inherit;">It’s impossible to pinpoint the moment when the state of a form changes, but we know that whenever a form changes, Angular marks the component as waiting for a change detection cycle. </font><font style="vertical-align: inherit;">The tested component and its descendants execute the ngDoCheck lifecycle hook, which our directive will use.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FormStatusesDirective</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Create the directive </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">form-statuses.directive.ts</font></font></b><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> noop: <span class="hljs-function">(<span class="hljs-params">v?: boolean</span>) =&gt;</span> <span class="hljs-keyword">void</span> = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { };<font></font>
<font></font>
@Directive({<font></font>
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'[formControlName],[ngModel],[formControl]'</span> <span class="hljs-comment">// tslint:disable-line: directive-selector</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FormStatusesDirective</span> <span class="hljs-title">implements</span> <span class="hljs-title">DoCheck</span>, <span class="hljs-title">OnInit</span> </span>{<font></font>
  private setSVATouched = noop;<font></font>
  private setSVAPristine = noop;<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(<font></font>
    @Self() private control: NgControl,<font></font>
    @Self() @Optional()  @Inject(STATE_VALUE_ACCESSOR) private stateValueAccessor: StateValueAccessor,<font></font>
  ) { }<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stateValueAccessor?.setTouchedState) {
      <span class="hljs-keyword">this</span>.setSVATouched = wrapIfChanges(<span class="hljs-function"><span class="hljs-params">touched</span> =&gt;</span> <span class="hljs-keyword">this</span>.stateValueAccessor.setTouchedState(touched));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stateValueAccessor?.setPristineState) {
      <span class="hljs-keyword">this</span>.setSVAPristine = wrapIfChanges(<span class="hljs-function"><span class="hljs-params">pristine</span> =&gt;</span> <span class="hljs-keyword">this</span>.stateValueAccessor.setPristineState(pristine));<font></font>
    }<font></font>
  }<font></font>
<font></font>
  ngDoCheck() {<font></font>
    <span class="hljs-keyword">this</span>.setSVAPristine(<span class="hljs-keyword">this</span>.control.pristine);
    <span class="hljs-keyword">this</span>.setSVATouched(<span class="hljs-keyword">this</span>.control.touched);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FormStatusesDirective is superimposed on all possible controls and checks for the presence of StateValueAccessor. </font><font style="vertical-align: inherit;">To do this, an optional dependency on the STATE_VALUE_ACCESSOR token is requested from the injector, which the component implementing StateValueAccessor should have checked. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If nothing is found by the token, then nothing happens, the setSVATouched and setSVAPristine methods will be just empty functions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If StateValueAccessor is found, then its setTouchedState and setPristineState methods will be called for every detected state change. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It remains to provide the directive with a module for exporting </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">form-statuses.module.ts</font></font></b><br>
<br>
<pre><code class="javascript hljs">@NgModule({
  <span class="hljs-attr">declarations</span>: [FormStatusesDirective],
  <span class="hljs-attr">exports</span>: [FormStatusesDirective]<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FormStatusesModule</span> </span>{ }</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Main page</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now you need to create the form itself. </font><font style="vertical-align: inherit;">In order not to make a fuss, put it on the main page of the AppComponent. </font><font style="vertical-align: inherit;">Of course, in a real application, it is better to make a separate component for the form. </font><b><font style="vertical-align: inherit;">App.component.html</font></b></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
template</font></font><br>
<b><font style="vertical-align: inherit;"></font></b><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-wrapper"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">form</span>
    <span class="hljs-attr">class</span>=<span class="hljs-string">"form"</span>
    [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"form"</span>
    <span class="hljs-attr">formPersist</span>=<span class="hljs-string">"inputSnils"</span>
  &gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">app-input-snils</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"input-snils"</span>
      <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"snils"</span>
      [<span class="hljs-attr">required</span>]=<span class="hljs-string">"true"</span>
    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-input-snils</span>&gt;</span><font></font>
<font></font>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"ready-button"</span>
      <span class="hljs-attr">mat-raised-button</span>
      [<span class="hljs-attr">disabled</span>]=<span class="hljs-string">"form.invalid"</span>
      <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>
    &gt;</span><font></font>
      Submit<font></font>
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The FormPersistDirective directive hangs on the form, Angular learns about it through the form [formPersist] selector. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The template needs to be provided with variables, </font><b><font style="vertical-align: inherit;">let's</font></b><font style="vertical-align: inherit;"> do it </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">app.component.ts</font></font></b><br>
<br>
<pre><code class="javascript hljs">@Component({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
  <span class="hljs-attr">templateUrl</span>: <span class="hljs-string">'./app.component.html'</span>,
  <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">'./app.component.css'</span>]<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppComponent</span> </span>{<font></font>
  public form = <span class="hljs-keyword">new</span> FormGroup({
    <span class="hljs-attr">snils</span>: <span class="hljs-keyword">new</span> FormControl(<span class="hljs-string">''</span>, [Validators.required])<font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The component code with the form came out extremely simple and does not contain anything superfluous. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It looks like this: </font></font><br>
<img src="https://habrastorage.org/webt/qb/qa/ko/qbqakozek8aqxafpbojkbn3b65y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The source code can be taken on </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
The demo on </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stackblitz</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
The code on stackblitz is slightly different, due to the fact that the typescript version there does not yet support the elvis operator. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, there are still nuances that are not reflected in the article, if someone needs it, I will supplement it.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en491050/index.html">Registration for NeoQUEST-2020: Post-Apocalyptic World Open</a></li>
<li><a href="../en491052/index.html">How and why curators at the St. Petersburg HSE help freshmen programmers</a></li>
<li><a href="../en491054/index.html">How to sign email correspondence with a GPG key using PKCS # 11 tokens</a></li>
<li><a href="../en491056/index.html">Ampere Altra - the world's first 80-core ARM processor</a></li>
<li><a href="../en491058/index.html">Mortality, mortality, coronavirus and matan</a></li>
<li><a href="../en491076/index.html">Clever work with RabbitMQ in NestJS</a></li>
<li><a href="../en491084/index.html">saneex.c: try / catch / finally based on setjmp / longjmp (C99) faster than standard C ++ exceptions ¹</a></li>
<li><a href="../en491086/index.html">Webix JavaScript library through the eyes of a beginner. Part 6. Server interaction</a></li>
<li><a href="../en491088/index.html">GitHub: New Open Source Library for OSINT</a></li>
<li><a href="../en491090/index.html">Convert text documents to xml in C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>