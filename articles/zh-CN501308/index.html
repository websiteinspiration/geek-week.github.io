<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧐 👂🏾 🐱 我们尝试了解StateFlow ⚠️ 👨🏿‍🏭 👩🏿‍🤝‍👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好。
 
 几天前，JetBrains发布了新版本的Corutin-1.3.6，其中一项创新是Flow的新亚种-StateFlow，它取代了ConflatedBroadcastChannel。我决定尝试使用StateFlow并研究其内部结构。
 
 我认为许多为Android或MPP开发时使用K...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>我们尝试了解StateFlow</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501308/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大家好。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
几天前，JetBrains发布了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新版本的Corutin-1.3.6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中一项创新是Flow的新亚种-StateFlow，它取代了ConflatedBroadcastChannel。</font><font style="vertical-align: inherit;">我决定尝试使用StateFlow并研究其内部结构。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为许多为Android或MPP开发时使用Kotlin的人都熟悉这些术语，而并非如此-这些实体与RxJava的BehaviorProcessor / BehaviorSubject和Jetpack的LiveData / MutableLiveData相似。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
StateFlow本身是Flow接口的简单扩展，有两种形式：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StateFlow</span>&lt;<span class="hljs-type">out T</span>&gt; : <span class="hljs-type">Flow</span>&lt;<span class="hljs-type">T</span>&gt; </span>{
    <span class="hljs-comment">/**
     * The current value of this state flow.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> value: T<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MutableStateFlow</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">StateFlow</span>&lt;<span class="hljs-type">T</span>&gt; </span>{
    <span class="hljs-comment">/**
     * The current value of this state flow.
     *
     * Setting a value that is [equal][Any.equals] to the previous one does nothing.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> value: T<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个想法与LiveData / MutableLiveData中的想法相同-通过一个接口它只能读取当前状态，而通过另一个接口也可以安装。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与ConflatedBroadcastChannel相比，StateFlow为我们提供了什么：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 一个更简单且无垃圾的内部实现。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要默认项。</font><font style="vertical-align: inherit;">空也是可能的。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 分为只读和读写接口。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 通过相等性比较元素，而不是比较链接。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们尝试实现StateFlow的简单用法。</font><font style="vertical-align: inherit;">为此，我制作了一个基本包装器，该包装器能够默认设置具有null元素的任何类型：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateFlowRepository</span>&lt;<span class="hljs-type">T</span>&gt;</span>(initialValue: T? = <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> stateFlow = MutableStateFlow(initialValue)<font></font>
<font></font>
    <span class="hljs-keyword">var</span> value: T?
        <span class="hljs-keyword">get</span>() = stateFlow.value
        <span class="hljs-keyword">set</span>(value) {<font></font>
            stateFlow.value = value<font></font>
        }<font></font>
<font></font>
    <span class="hljs-keyword">val</span> stream: Flow&lt;T?&gt; = stateFlow<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们得到数据：</font></font><br>
<br>
<pre><code class="kotlin hljs">lifecycleScope.launch {<font></font>
            simpleRepo.stream.collect {<font></font>
                addData(it.toString())<font></font>
            }<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并且我们在屏幕上显示了用于测试的最简单界面，它不会引起任何问题，并且一切都像时钟一样工作：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pn/cv/_c/pncv_c41cwncgwkfc3hd3wxzfh0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们看一下内部，看看它是如何实现的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
令我惊讶的是，该实现实际上非常简单，目前仅占用316行，其中25％是javadoki。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，主要的实现类是StateFlowImpl类：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateFlowImpl</span>&lt;<span class="hljs-type">T</span>&gt;</span>(initialValue: Any) : SynchronizedObject(), MutableStateFlow&lt;T&gt;, FusibleFlow&lt;T&gt; {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _state = atomic(initialValue) <span class="hljs-comment">// T | NULL</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> sequence = <span class="hljs-number">0</span> <span class="hljs-comment">// serializes updates, value update is in process when sequence is odd</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> slots = arrayOfNulls&lt;StateFlowSlot?&gt;(INITIAL_SIZE)
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> nSlots = <span class="hljs-number">0</span> <span class="hljs-comment">// number of allocated (!free) slots</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> nextIndex = <span class="hljs-number">0</span> <span class="hljs-comment">// oracle for the next free slot index</span><font></font>
<font></font>
. . .<font></font>
}<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_state-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储我们状态的原子链接。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序列</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -辅助指示符，根据奇偶校验/奇数，报告有关更新状态</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时隙</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的当前过程</font><font style="vertical-align: inherit;">-数组/池StateFlowSlot。 StateFlowSlot-与StateFlow的每个“连接”的辅助抽象。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nSlots，nextIndex-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于可扩展数组插槽的辅助变量</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们提前考虑StateFlowSlot。他仅代表：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _state = atomic&lt;Any?&gt;(<span class="hljs-literal">null</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
加上更改插槽状态的方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个插槽可以处于以下状态之一：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已创建，但未使用</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NONE-已</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用的收集器</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PENDING状态</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -预期将新值发送到收集器</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellableContinuationImpl-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">挂起状态接近目标PENDING状态，正在挂起收集器直到状态流中的新状态才会出现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑设置新值时会发生什么：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> value: T
        <span class="hljs-keyword">get</span>() = NULL.unbox(_state.value)
        <span class="hljs-keyword">set</span>(value) {
            <span class="hljs-keyword">var</span> curSequence = <span class="hljs-number">0</span>
            <span class="hljs-keyword">var</span> curSlots: Array&lt;StateFlowSlot?&gt; = <span class="hljs-keyword">this</span>.slots <span class="hljs-comment">// benign race, we will not use it</span>
            <span class="hljs-keyword">val</span> newState = value ?: NULL<font></font>
            synchronized(<span class="hljs-keyword">this</span>) {
                <span class="hljs-keyword">val</span> oldState = _state.value
                <span class="hljs-keyword">if</span> (oldState == newState) <span class="hljs-keyword">return</span> <span class="hljs-comment">// Don't do anything if value is not changing</span><font></font>
                _state.value = newState<font></font>
                curSequence = sequence<font></font>
                <span class="hljs-keyword">if</span> (curSequence and <span class="hljs-number">1</span> == <span class="hljs-number">0</span>) { <span class="hljs-comment">// even sequence means quiescent state flow (no ongoing update)</span>
                    curSequence++ <span class="hljs-comment">// make it odd</span><font></font>
                    sequence = curSequence<font></font>
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// update is already in process, notify it, and return</span>
                    sequence = curSequence + <span class="hljs-number">2</span> <span class="hljs-comment">// change sequence to notify, keep it odd</span>
                    <span class="hljs-keyword">return</span><font></font>
                }<font></font>
                curSlots = slots <span class="hljs-comment">// read current reference to collectors under lock</span><font></font>
            }<font></font>
            <span class="hljs-comment">/*
               Fire value updates outside of the lock to avoid deadlocks with unconfined coroutines
               Loop until we're done firing all the changes. This is sort of simple flat combining that
               ensures sequential firing of concurrent updates and avoids the storm of collector resumes
               when updates happen concurrently from many threads.
             */</span>
            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
                <span class="hljs-comment">// Benign race on element read from array</span>
                <span class="hljs-keyword">for</span> (col <span class="hljs-keyword">in</span> curSlots) {<font></font>
                    col?.makePending()<font></font>
                }<font></font>
                <span class="hljs-comment">// check if the value was updated again while we were updating the old one</span>
                synchronized(<span class="hljs-keyword">this</span>) {
                    <span class="hljs-keyword">if</span> (sequence == curSequence) { <span class="hljs-comment">// nothing changed, we are done</span>
                        sequence = curSequence + <span class="hljs-number">1</span> <span class="hljs-comment">// make sequence even again</span>
                        <span class="hljs-keyword">return</span> <span class="hljs-comment">// done</span><font></font>
                    }<font></font>
                    <span class="hljs-comment">// reread everything for the next loop under the lock</span><font></font>
                    curSequence = sequence<font></font>
                    curSlots = slots<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里的主要任务是修复来自Flowflow的连续调用的不同流的StateFlow状态更改。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以区分几个步骤：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置一个新值。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将序列标记设置为奇数值意味着我们已经在进行更新。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">makePending（）-将所有插槽状态（即所有连接）设置为PENDING-我们将很快发送一个新值。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">循环检查序列== curSequence所有任务均已完成，并将序列设置为偶数。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">collect</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法中会发生什么</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collect</span><span class="hljs-params">(collector: <span class="hljs-type">FlowCollector</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> {
        <span class="hljs-keyword">val</span> slot = allocateSlot()
        <span class="hljs-keyword">var</span> prevState: Any? = <span class="hljs-literal">null</span> <span class="hljs-comment">// previously emitted T!! | NULL (null -- nothing emitted yet)</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// The loop is arranged so that it starts delivering current value without waiting first</span>
            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
                <span class="hljs-comment">// Here the coroutine could have waited for a while to be dispatched,</span>
                <span class="hljs-comment">// so we use the most recent state here to ensure the best possible conflation of stale values</span>
                <span class="hljs-keyword">val</span> newState = _state.value
                <span class="hljs-comment">// Conflate value emissions using equality</span>
                <span class="hljs-keyword">if</span> (prevState == <span class="hljs-literal">null</span> || newState != prevState) {<font></font>
                    collector.emit(NULL.unbox(newState))<font></font>
                    prevState = newState<font></font>
                }<font></font>
                <span class="hljs-comment">// Note: if awaitPending is cancelled, then it bails out of this loop and calls freeSlot</span>
                <span class="hljs-keyword">if</span> (!slot.takePending()) { <span class="hljs-comment">// try fast-path without suspending first</span>
                    slot.awaitPending() <span class="hljs-comment">// only suspend for new values when needed</span><font></font>
                }<font></font>
            }<font></font>
        } <span class="hljs-keyword">finally</span> {<font></font>
            freeSlot(slot)<font></font>
        }<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主要任务是发送初始默认值并等待新值： </font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们创建或将插槽重新用于新连接。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们检查状态是否为空或状态是否更改。</font><font style="vertical-align: inherit;">Emittim是一个新的含义。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们检查是否有准备更新的插槽（PENDING状态），如果没有，我们会在等待新值的情况下暂停该插槽。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般来说，仅此而已。</font><font style="vertical-align: inherit;">我们没有考虑插槽的分配及其状态的更改是如何发生的，但是我认为这对于StateFlow的总体情况并不重要。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
谢谢。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN501292/index.html">估算商船成本。算术和常识</a></li>
<li><a href="../zh-CN501296/index.html">如何在不解决业务问题的情况下从事程序员职业</a></li>
<li><a href="../zh-CN501298/index.html">创建自己的QGIS插件存储库</a></li>
<li><a href="../zh-CN501302/index.html">请不要发出声音</a></li>
<li><a href="../zh-CN501306/index.html">建立管道以将Graal本机映像交付给最终用户</a></li>
<li><a href="../zh-CN501310/index.html">关于过氧化氢和火箭虫</a></li>
<li><a href="../zh-CN501312/index.html">Alpine.js-具有便捷语法的轻量级框架</a></li>
<li><a href="../zh-CN501316/index.html">微软研究：员工培训是在企业中引入人工智能的关键因素之一</a></li>
<li><a href="../zh-CN501318/index.html">如何使用JS和Google表格成为比尔·盖茨的高尔夫俱乐部邻居</a></li>
<li><a href="../zh-CN501320/index.html">BOM成本低于1美元的LED驱动器。可能吗？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>