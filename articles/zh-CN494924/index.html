<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌇 ▶️ 🖖🏽 游戏中水彩效果的实现 👋🏿 🛌🏻 🕺🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="介绍
 当我们在2019年1月开始讨论新的色彩游戏时。，我们立即决定水彩效果将是最重要的元素。受到宝格丽（Bulgari）广告的启发，我们意识到水彩画的实现应与我们计划创造的剩余资源的高质量保持一致。我们从Adobe的研究人员那里找到了一篇有趣的文章（1）。其中描述的水彩画技术看起来很棒，并且由于其...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>游戏中水彩效果的实现</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/494924/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9b/8bc/7c5/f9b8bc7c53c4d97ed983c428ce53926b.gif" alt="图片"></div><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介绍</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我们在2019年1月开始讨论新的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">色彩</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏时</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;">。</font></em></a><font style="vertical-align: inherit;">，我们立即决定水彩效果将是最重要的元素。受到</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;">宝格丽（Bulgari）</font></em></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">广告的</font></font><em><font style="vertical-align: inherit;"></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启发</font><font style="vertical-align: inherit;">，我们意识到水彩画的实现应与我们计划创造的剩余资源的高质量保持一致。我们从Adobe的研究人员那里找到了一篇有趣的文章</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。其中描述的水彩画技术看起来很棒，并且由于其矢量（而非像素）性质，即使在较弱的移动设备上也可以使用。我们的实施基于此研究，我们更改和/或简化了部分内容，因为我们的性能要求不同。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">色彩</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是一款游戏，因此，除了图形本身之外，我们还需要渲染整个3D环境并在一帧中执行游戏逻辑。</font><font style="vertical-align: inherit;">我们还试图确保模拟是实时执行的，并且玩家可以立即看到绘制的内容。</font></font><br>
<a name="habracut"></a><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e8/277/d95/2e8277d95ed5a29796176e375ecf59c5.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">色彩中的水彩模拟。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我们将分享在Unity游戏引擎中实施此技术的各个细节，并讨论如何使它适应于低端移动设备上的无缝运行。</font><font style="vertical-align: inherit;">我们将更多地讨论该算法的主要阶段，但不演示代码。</font><font style="vertical-align: inherit;">该实现是在Unity 2018.4.2中创建的，后来又更新为版本2018.4.7。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么是色调？</font></font></h1><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">色调</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是一款益智游戏，可让玩家完成各个级别，混合水彩的颜色，使其与折纸的颜色匹配。</font><font style="vertical-align: inherit;">该游戏于2019年秋季在Apple Arcade发行，适用于iOS，macOS和tvOS。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/630/d46/bb0630d469679d86535ec46fd97c8f0a.png" width="2224" height="1668"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">屏幕截图色调。</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要求</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我的文章中描述的技术可以分为在每个框架中执行的三个主要阶段：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据玩家的输入生成新的景点并将其添加到景点列表中</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绘制列表上所有点的模拟</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">点渲染</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下面我们将详细讨论如何实现每个阶段。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的目标是达到60 FPS，也就是说，这些阶段以及下面描述的所有逻辑每秒执行60次。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获取输入</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在每一帧中，我们将玩家的输入（取决于平台，可以是触摸，鼠标或虚拟光标的位置）转换成</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">结构</font><font style="vertical-align: inherit;">包含位置，运动矢量，颜色和压力（2）。首先，我们在屏幕上检查玩家的划动长度，并将其与给定的阈值进行比较。轻扫一下，我们在输入位置每帧生成一个点。在相反的情况下，我们用预定密度创建的新点填充玩家滑动的起点和终点之间的距离（这确保了恒定的绘画密度，而与滑动速度无关）。颜色表示当前使用的绘画，移动的坡度是滑动的方向。创建的新点将添加到名为</font><em><font style="vertical-align: inherit;">splatList</font></em><font style="vertical-align: inherit;">的集合中</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中还包含所有先前创建的位置。</font><font style="vertical-align: inherit;">在以下步骤中，它用于模拟和渲染涂料。</font><font style="vertical-align: inherit;">每个单独的点都表示需要渲染的一滴油漆-水彩画的主要构成部分。</font><font style="vertical-align: inherit;">完成的水彩画将是渲染数十个/数百个相交点的结果。</font><font style="vertical-align: inherit;">此外，将生命周期值（以帧为单位）分配给新创建的斑点，该斑点确定可以模拟斑点多长时间。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ccb/e15/628/ccbe15628a553ba6ceb25af2fd2e2e36.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">长滑动点插值的示例。</font><font style="vertical-align: inherit;">空心圆圈表示以固定间隔创建的斑点。</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">帆布</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
像真正的油漆一样，我们需要一块画布。</font><font style="vertical-align: inherit;">为了实现它，我们在3D空间中创建了一个看起来像一张纸的有限区域。</font><font style="vertical-align: inherit;">玩家的输入坐标和所有其他操作（例如渲染网格）都记录在画布空间中。</font><font style="vertical-align: inherit;">同样，用于模拟绘图的任何缓冲区的像素大小取决于画布的大小。</font><font style="vertical-align: inherit;">本文中使用的术语“画布”与Unity UI中的Canvas类没有任何关系。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/648/367/1cc/6483671ccaa809a93bcf2a276cdd2471.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绿色矩形显示游戏中的画布区域</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">点</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在视觉上，该点由圆形网格表示，该网格的边缘包含25个顶点。如果您在很短的时间内触摸它，您可以将其看作是湿画笔在纸上留下的“滴”。我们向每个顶点的位置添加一个小的随机偏移量，以确保油漆斑点边缘的不均匀性。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/baa/daa/9bbbaadaaf2b6d0fc1b295f5739ff083.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网格物体的例子。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
对于每个顶点，我们还存储向外的速度矢量，然后将其用于仿真阶段。我们生成了几个这样的网格，它们之间的形式略有不同，并将它们的数据存储在skriptuemy对象（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可编写脚本的对象</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）中。每次玩家实时绘制一个点时，我们都会为其分配一个从该组中随机选择的网格。值得一提的是，在不同的屏幕分辨率下，画布的像素大小也不同。因此，在所有设备上，斑点的大小系数都是相同的，因此当您开始游戏时，我们会根据画布的大小来更改比例。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1af/f92/8de/1aff928de51a35f64351fe72f5c10d80.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储有新斑点数据的斑点向量的示例。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
当生成斑点网格时，我们还保存了其“润湿区域”，该区域定义了原始斑点边界内的一组像素。润湿区域用于模拟</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对流</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在创建每个新点时，在应用程序执行期间，我们将其下面的画布标记为湿的。模拟油漆的运动时，我们允许其“散布”在已经变湿的画布区域上。我们将画布的水分含量存储在全局</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">湿图</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缓冲区中</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">缓冲区</font><font style="vertical-align: inherit;">在添加每个新点时进行更新。除参与两种颜色的混合外，平流在油漆笔划本身的最终外观中也起着重要作用。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/843/67e/31d84367e786d15bd7fe0f59cbe2e3a5.jpg"></div><br>
<i><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">湿图</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">填充</font><font style="vertical-align: inherit;">（斑点形状（绿色圆圈）内的像素</font><font style="vertical-align: inherit;">）将湿</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缓冲区</font><font style="vertical-align: inherit;">（网格）</font><font style="vertical-align: inherit;">标记</font><font style="vertical-align: inherit;">为湿（绿色）。</font><font style="vertical-align: inherit;">Wetmap缓冲区本身具有更高的分辨率。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，每个斑点还包含一个</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不透明度</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">是其面积的函数；</font><font style="vertical-align: inherit;">它代表储存颜料的效果（斑点中一定数量的颜料）。</font><font style="vertical-align: inherit;">当在仿真过程中增加斑点的大小时，其不透明度会降低，反之亦然。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a88/870/a5b/a88870a5b213286e20815f3b87ecca5d.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个不带有平流的涂料的示例（左），一个带有平流的涂料（右）。</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/341/069/348/341069348c265951c765843ca792b2c8.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">油漆平流的例子。</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仿真周期</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
收到玩家在当前帧中输入的内容并将其转换为新的斑点后，下一步是模拟斑点以模拟水彩的散布。在此模拟的开始，我们有一个需要更新的点列表和一个更新的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetmap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在每一帧中，我们遍历斑点列表并使用以下公式更改斑点所有顶点的位置：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6fe/91a/4b86fe91ae4f677697b43e99a3299ecc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其中：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是新的运动矢量，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是常数校正参数（0.33），</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是运动斜率矢量=玩家</font><font style="vertical-align: inherit;">挥杆的</font><font style="vertical-align: inherit;">标准化方向乘以0.3，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是画布粗糙度的标量值= Random.Range（1,1 + r），</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是全局粗糙度参数，对于标准涂料，我们将其设置为0.4，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是预先通过点网格创建的速度矢量，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是速度因数，在某些情况下我们在局部用于加速对流的标量值</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x（t + 1）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -潜在的新顶点位置，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x（t）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -当前顶点位置，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">br</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是分支粗糙度向量=（Random.Range（-r，r），Random.Range（-r，r）），</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w（x）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是湿图缓冲区中的润湿值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样的方程式的结果称为</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有偏随机游动</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它模仿了真实水彩颜料中粒子的行为。我们试图将光斑的每个顶点从其中心（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">向外移动</font><font style="vertical-align: inherit;">，以增加随机性。然后，运动方向随冲程方向（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">略有变化，</font><font style="vertical-align: inherit;">并再次由另一个粗糙度分量（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">br</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">随机化</font><font style="vertical-align: inherit;">。然后将此新的顶点位置与一个</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">湿贴图</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行比较</font><font style="vertical-align: inherit;">。如果新位置的画布已经湿透了（湿</font><em><font style="vertical-align: inherit;">贴图</font></em><font style="vertical-align: inherit;">缓冲区中的值</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大于0），则为顶点赋予新位置</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x（t + 1）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，否则不更改其位置。</font><font style="vertical-align: inherit;">结果，油漆将仅在已经湿透的画布区域中扩散。</font><font style="vertical-align: inherit;">在最后阶段，我们重新计算斑点区域，该斑点区域在渲染周期中用于更改其不透明度。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a69/742/ae4/a69742ae4ee6d91b27bac6397bd317ff.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">油漆两个有效点之间对流模拟的微型示例。</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染周期-湿缓冲区</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重新计算斑点后，即可开始渲染它们。在仿真阶段之后的出口处，斑点的网格经常被证明是变形的（例如，发生相交），因此，为了正确渲染而无需重复三角剖分的额外费用，我们使用了带有两遍模板缓冲区的解决方案。 Unity </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphics</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绘图界面用于渲染斑点</font><font style="vertical-align: inherit;">，并且渲染周期在Unity </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnPostRender</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法内部执行</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用单独的相机</font><font style="vertical-align: inherit;">渲染点网格以渲染纹理（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。在周期的开始，</font><font style="vertical-align: inherit;">使用</font><em><font style="vertical-align: inherit;">Graphics.SetRenderTarget（wetBuffer）</font></em><font style="vertical-align: inherit;">清除</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将其设置为渲染目标</font><font style="vertical-align: inherit;">。</font><em><font style="vertical-align: inherit;">splatList中</font></em><font style="vertical-align: inherit;">每个活动点的下</font><em><font style="vertical-align: inherit;">一个</font></em></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们执行下图所示的序列：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e7/a09/328/1e7a0932807463744d7fd50a40fddedc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染周期图。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们首先在每个斑点之前清洗模板缓冲区，以使先前斑点的模板缓冲区的状态不会影响新斑点。</font><font style="vertical-align: inherit;">然后，我们选择用于绘制斑点的材料。</font><font style="vertical-align: inherit;">该材料负责点的颜色，</font><font style="vertical-align: inherit;">当玩家</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绘制</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">点时</font><font style="vertical-align: inherit;">，我们根据</font><em><font style="vertical-align: inherit;">splatData中</font></em><font style="vertical-align: inherit;">存储的颜色索引选择它</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后我们根据上一步中计算的点网格的面积来更改颜色不透明度（alpha通道）。</font><font style="vertical-align: inherit;">渲染本身是使用两遍模板缓冲区着色器执行的。</font><font style="vertical-align: inherit;">在第一遍（Material.SetPass（0））中，我们传递原始点网格以记录填充网格的坐标。</font><font style="vertical-align: inherit;">通过此通行证</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ColorMask</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的值为0，因此不会渲染网格物体。</font><font style="vertical-align: inherit;">在第二遍（Material.SetPass（1））中，我们使用围绕点网格描述的四边形。</font><font style="vertical-align: inherit;">我们检查模板缓冲区中四边形每个像素的值；</font><font style="vertical-align: inherit;">如果值为1，则渲染像素，否则跳过该像素。</font><font style="vertical-align: inherit;">作为此操作的结果，我们渲染了与点网格相同的形状，但是它肯定不会包含不需要的伪像，例如自相交。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a9/06b/beb/1a906bbeb3f003d057430f6fb28e9257.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行双重模板缓冲技术的过程（从左到右）。</font><font style="vertical-align: inherit;">请注意，此模板缓冲区的分辨率比显示的分辨率高得多，因此可以高精度地保持其原始形状。</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/15d/3ae/ed515d3aec23cd4eb9041761913afd2c.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以传统方式绘制的三个相交斑点的示例，这导致了伪像的出现（左），并使用了两遍模板缓冲技术消除了所有伪像（右）。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer中</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染了所有斑点</font><em><font style="vertical-align: inherit;">之后，</font></em><font style="vertical-align: inherit;">它将显示在游戏场景中。我们的画布使用临时着色器，将</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，漫反射纸质贴图和纸质法线贴图</font><font style="vertical-align: inherit;">结合在一起</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/968/db5/55a/968db555a2a477134013c355e3898e90.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画布着色器：仅wetBuffer（左），添加的纸张纹理（中），法线贴图（右）。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该游戏为有色盲的人提供了一种模式，其中将单独的图案叠加在颜料上。</font><font style="vertical-align: inherit;">为此，我们通过添加带有平铺图案的纹理来更改污渍的材质。</font><font style="vertical-align: inherit;">模式遵循混合游戏颜色的规则，例如，蓝色（长条）+黄色（圆）在交叉点处给出绿色（长条中的圆圈）。</font><font style="vertical-align: inherit;">若要无缝混合图案，必须在相同的UV空间中渲染它们。</font><font style="vertical-align: inherit;">我们调整模板缓冲区第二遍中使用的四边形的UV坐标，将x和y位置（在画布空间中指定）除以画布的宽度和高度。</font><font style="vertical-align: inherit;">结果，我们在0到1的空间中获得了u，v的正确值。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b5/057/211/7b50572119f116fae451dd321275a920.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">色盲图案的示例。</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优化-干斑缓冲</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如上所述，我们的任务之一是支持低功耗移动设备。</font><font style="vertical-align: inherit;">现场渲染成为我们游戏的瓶颈。</font><font style="vertical-align: inherit;">每个斑点需要三个绘制调用（调用两次通过+清除模板缓冲区），并且由于绘画行包含数十个或数百个斑点，绘制调用的数量迅速增加并导致帧速率下降。</font><font style="vertical-align: inherit;">为了解决这个问题，我们应用了两种优化技术：首先，同时绘制</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中所有“干燥”的斑点</font><font style="vertical-align: inherit;">，其次，达到一定数量的活性斑点后，局部加速了斑点的干燥。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是添加到渲染周期的附加渲染纹理。如前所述，每个光斑都有一个寿命（以帧为单位），该寿命随每个帧而减少。寿命达到0后，污渍被认为是“干燥”的。不再模拟干点，它们的形状不会改变，因此不需要在每个帧中再次渲染它们。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/afe/714/b44afe714c3be2aed6d853d031e2379a.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DryBuffer起作用；灰色斑点表示复制到dryBuffer的斑点。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
寿命达到0的每个点都将从</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatList中</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移除，</font><font style="vertical-align: inherit;">并“复制”到</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在复制过程中，渲染周期被重用，这次将</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置为目标渲染纹理</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">仅通过重叠画布着色器中的缓冲区就无法实现</font><em><font style="vertical-align: inherit;">wetBuffer</font></em><font style="vertical-align: inherit;">和</font><em><font style="vertical-align: inherit;">dryBuffer</font></em></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
之间的正确混合</font><font style="vertical-align: inherit;">，因为</font><em><font style="vertical-align: inherit;">wetBuffer</font></em><font style="vertical-align: inherit;">缓冲区的渲染纹理</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含已经用alpha值渲染的斑点（相当于预乘alpha）。</font><font style="vertical-align: inherit;">通过在渲染遍历斑点之前在渲染周期的开始增加一个步骤，我们避免了此问题。</font><font style="vertical-align: inherit;">此时，我们渲染显示出</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的照相机修剪金字塔的四边形</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer中</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呈现的任何污渍</font><font style="vertical-align: inherit;">将已经与干燥的，先前涂过的污渍混合。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24e/afe/417/24eafe41762bcd3e7b2363e78c8bb9c0.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">干点和湿点的混合物。</font></font></i><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">dryBuffer</font></em></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
缓冲区会</font><font style="vertical-align: inherit;">累积所有“干燥”的斑点，并且不会在帧之间清除。</font><font style="vertical-align: inherit;">因此，与过期污渍相关的所有内存都可以在将它们“复制”到缓冲区后清除。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/aa0/5bd/00eaa05bd29ca5c46eb8a845accc0b75.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多亏了</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的优化</font><font style="vertical-align: inherit;">，我们不再限制玩家可以应用到画布上的绘画数量。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单独</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">可以使玩家绘画几乎无限量的绘画，但不能保证始终如一的性能。如上所述，绘画笔划具有恒定的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">厚度</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这是通过在滑动的起点和终点之间使用许多点的插值进行绘制来实现的。在多次快速和长时间滑动的情况下，玩家可以生成大量活动点。这些斑点将在其寿命指定的帧数上进行仿真和渲染，最终导致更低的帧速率。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了确保稳定的帧速率，我们更改了算法，以使活动点的数量受到</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxActiveSplats</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">恒定值的</font><em><font style="vertical-align: inherit;">限制</font></em><font style="vertical-align: inherit;">。所有超过该值的斑点都会立即“变干”。这是通过将最旧的活动斑点的寿命减少到0来实现的，这就是为什么将它们较早复制到干燥斑点缓冲区的原因。因为当我们缩短寿命时，我们会在模拟的不完整状态中找到一个位置（这看起来会很有趣），与此同时，我们提高了涂料的扩散速度。由于速度的增加，光斑的大小几乎达到了正常速度下的正常寿命。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/907/c68/4c9/907c684c9c3642f6a109b4cadcf8718c.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d79/fe2/72b/d79fe272b648131541bfbf423384fc29.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演示最多40个（顶部）和80个（底部）活动点。</font><font style="vertical-align: inherit;">在dryBuffer中复制的干斑显示为灰色。</font><font style="vertical-align: inherit;">该值表示可以同时模拟的涂料“量”。</font></font></i><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">maxActiveSplats</font></em></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
的值</font><font style="vertical-align: inherit;">是最重要的性能参数，它使我们能够精确控制可分配给水彩渲染的绘画调用的数量。</font><font style="vertical-align: inherit;">我们根据平台和设备功能在启动时进行设置。</font><font style="vertical-align: inherit;">如果检测到帧速率降低，也可以在应用程序执行期间更改此值。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该算法的实现已成为一项有趣且具有挑战性的任务。</font><font style="vertical-align: inherit;">我们希望读者喜欢这篇文章。</font><font style="vertical-align: inherit;">您可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原始</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">评论中提问</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果您想欣赏我们的水彩作品，请尝试使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">淡色。</font><font style="vertical-align: inherit;">在Apple Arcade上</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/959/89e/fda/95989efda4d27809e1ce3923b341ac46.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Apple TV上运行的游戏的屏幕截图</font></font></i><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1）S. DiVerdi，A。Krishnaswamy，R。Mach和D. Ito，“用多边形绘画：程序水彩引擎”，在IEEE Transactions on Visualization and Computer Graphics，vol。1中。</font><font style="vertical-align: inherit;">19号 </font><font style="vertical-align: inherit;">5页。</font><font style="vertical-align: inherit;">723–735，2013年5月。doi：10.1109 / TVCG.2012.295 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（2）仅在用iPad绘制Apple Pencil时才考虑压力。</font></font></blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN494912/index.html">我对防范Covid-19的贡献</a></li>
<li><a href="../zh-CN494916/index.html">如何出售商家帐户并引起对在线业务的兴趣</a></li>
<li><a href="../zh-CN494918/index.html">遥控器的第三周-正常飞行。IT QIWI专家对在家中全职工作的评论</a></li>
<li><a href="../zh-CN494920/index.html">给开发人员的坏建议：如何“请”管理人员</a></li>
<li><a href="../zh-CN494922/index.html">Nizhny Novgorod面向IT专家：工作前景和生活机会</a></li>
<li><a href="../zh-CN494930/index.html">Unity3D：自动脚本管理器聚合器</a></li>
<li><a href="../zh-CN494932/index.html">操作大型分布式系统：我学到的知识</a></li>
<li><a href="../zh-CN494934/index.html">英语单词中的6个令人发指的错误</a></li>
<li><a href="../zh-CN494938/index.html">备份日快乐！别忘了他</a></li>
<li><a href="../zh-CN494940/index.html">DevOps-它是什么，为什么，需求量是多少？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>