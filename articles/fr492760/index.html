<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍💻 👩‍❤️‍👩 🧠 Grille CSS: saisie d'une mise en page de magazine réactive de 20 lignes 👦🏽 👵🏻 🎴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Récemment, j'ai travaillé sur une implémentation moderne d'un blog roll (une liste de blogs externes utiles / intéressants). L'idée était de fournir a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Grille CSS: saisie d'une mise en page de magazine réactive de 20 lignes</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/492760/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/in/vy/fm/invyfmr9wggf_x3z20znmwfyn8y.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Récemment, j'ai travaillé sur une implémentation moderne d'un blog roll (une liste de blogs externes utiles / intéressants). L'idée était de fournir aux lecteurs une sélection des derniers articles de ces blogs, regroupés dans une présentation de magazine, plutôt qu'une liste sèche de liens dans la barre latérale. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La partie la plus simple de la tâche consiste à obtenir une liste des articles et de leurs extraits (extrait - texte d'introduction avant le kat) à partir de nos flux RSS préférés. Pour ce faire, nous avons utilisé le plugin WordPress </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feedzy lite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui peut regrouper plusieurs flux en une seule liste, triés par heure - la solution idéale dans notre cas. La partie difficile est de tout rendre beau.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'interface de liste standard du plugin est probablement insipide, donc je voulais le styliser comme un site Web de journal ou de magazine avec un mélange de grands et de petits blocs «sélectionnés». </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela semble être l'occasion idéale d'utiliser CSS Grid! Créez une disposition de grille pour différentes dispositions, disons, une à cinq colonnes et une à trois colonnes, puis basculez entre elles à l'aide de requêtes multimédias sur différentes tailles d'écran. Droite? Mais avons-nous vraiment besoin de ces requêtes multimédias, et de tous ces problèmes avec la définition des points de contrôle, si vous pouvez simplement utiliser le paramètre Grid </font></font><code>auto-fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui fera la grille adaptative pour nous? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette idée m'a semblé tentante, mais quand j'ai commencé à ajouter des éléments couvrant plusieurs colonnes de la grille ( </font></font><em><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">travées</font></font></b></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), la grille a commencé à sortir de la page sur des écrans étroits. </font><font style="vertical-align: inherit;">Les requêtes des médias semblaient être la seule solution. </font><font style="vertical-align: inherit;">Mais j'ai trouvé quelque chose de mieux! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir étudié un certain nombre d'articles sur CSS Grid, j'ai constaté qu'ils sont principalement divisés en deux types:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment créer une mise en page intéressante avec des étendues, mais avec un nombre donné de colonnes.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment créer une </font><font style="vertical-align: inherit;">mise en page </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adaptative</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur une grille, mais avec des colonnes de même largeur (c'est-à-dire sans travées).</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je veux que la grille implémente ceci et cela: une mise en page entièrement adaptative utilisant des éléments multi-colonnes de redimensionnement adaptatif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La beauté est que dès que vous commencez à comprendre les limites des grilles adaptatives et pourquoi et quand les portées cassent l'adaptabilité, il est facile de créer une mise </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> page de magazine </font><b><font style="vertical-align: inherit;">avec des dizaines de lignes de code</font></b><font style="vertical-align: inherit;"> et une requête multimédia (ou même sans elles si vous souhaitez limiter la variété des portées). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici une comparaison claire du plugin RSS de la boîte et du résultat de notre travail (cliquable):</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/webt/in/vy/fm/invyfmr9wggf_x3z20znmwfyn8y.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit d'une mise en page de magazine entièrement adaptative avec des blocs «sélectionnés» colorés qui s'adaptent dynamiquement à la mise en page en fonction du nombre de colonnes. La page affiche environ 50 articles, mais le code de mise en page ne dépend pas du nombre d'éléments. Vous pouvez facilement augmenter le nombre de messages à 100 dans les paramètres du plugin, et la mise en page restera intéressante tout en bas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout cela est réalisé exclusivement via CSS et en utilisant une seule requête multimédia pour afficher le contenu dans une colonne sur les écrans les plus étroits (moins de 460 pixels). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce qui est le plus incroyable, la mise en page entière n'a pris que 21 lignes de CSS (sans compter les styles généraux du site). Cependant, afin d'obtenir une telle flexibilité en utilisant si peu de code, j'ai dû plonger profondément dans les profondeurs les plus sombres de la grille CSS et apprendre à contourner certaines de ses limites.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code sur lequel repose toute la mise en page est incroyablement court, et tout cela grâce à la splendeur de la grille CSS:</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.archive</span> {
  <span class="hljs-attribute">display</span>: grid;
  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fit, minmax(<span class="hljs-number">210px</span>, <span class="hljs-number">1</span>fr));
  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">32px</span>;
  <span class="hljs-attribute">grid-auto-flow</span>: dense;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/*    */</span>
<span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(31n</span> + 1) {
  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / -<span class="hljs-number">1</span>;<font></font>
}<font></font>
<span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(16n</span> + 2) {
  <span class="hljs-attribute">grid-column</span>: -<span class="hljs-number">3</span> / -<span class="hljs-number">1</span>;<font></font>
}<font></font>
<span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(16n</span> + 10) {
  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / -<span class="hljs-number">2</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/*     */</span>
<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width:</span> <span class="hljs-number">459px</span>) {
  <span class="hljs-selector-class">.archive</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">flex-direction</span>: column;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La technique décrite dans cet article peut être utilisée en toute sécurité pour styliser tout contenu généré dynamiquement, que ce soit la sortie du widget de publications récentes, de pages d'archives ou de résultats de recherche.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créer un maillage adaptatif</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai créé 17 éléments pour mettre en valeur la diversité du contenu futur - titres, images et extraits, et enveloppé dans </font></font><code>&lt;div&gt;&lt;/div&gt;</code><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"archive"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"article"</span>&gt;</span>
    <span class="hljs-comment">&lt;!--  --&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><font></font>
<font></font>
  <span class="hljs-comment">&lt;!--  16  --&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code pour transformer ces éléments en une grille adaptative est particulièrement compact:</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.archive</span> {
  <span class="hljs-comment">/*     - */</span>
  <span class="hljs-attribute">display</span>: grid;
  <span class="hljs-comment">/*        ,       180 . */</span>
  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fit, minmax(<span class="hljs-number">180px</span>, <span class="hljs-number">1</span>fr));
  <span class="hljs-comment">/*     */</span>
  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">1em</span>;<font></font>
}<font></font>
</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→ Démo sur CodePen</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Notez comment la hauteur de la ligne s'ajuste automatiquement au bloc de contenu le plus élevé de la ligne. </font><font style="vertical-align: inherit;">Si vous modifiez la largeur dans la démo à partir du lien ci-dessus, vous verrez que les éléments augmentent et diminuent automatiquement et le nombre de colonnes passe de 1 à 5, respectivement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, en action, nous voyons la magie de la grille CSS appelée</font></font><code>auto-fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ce mot-clé fonctionne conjointement avec la fonction</font></font><code>minmax()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appliquée à</font></font><code>grid-template-columns</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment ça fonctionne</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La disposition à cinq colonnes elle-même peut être obtenue comme ceci:</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.archive</span> {
  <span class="hljs-attribute">display</span>: grid;
  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>fr);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, cela crée une disposition à cinq colonnes qui s'étire et se contracte à différentes largeurs d'écran, mais reste toujours à cinq colonnes, ce qui conduit à des colonnes terriblement étroites sur les petits écrans. La première chose qui me vient à l'esprit est d'écrire un tas de requêtes multimédias et de redéfinir une grille avec un nombre différent de colonnes. Cela fonctionnerait, mais le mot </font></font><code>auto-fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">clé </font><font style="vertical-align: inherit;">fait tout automatiquement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour </font></font><code>auto-fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliser la fonction dont nous avons besoin </font></font><code>minmax()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ainsi, nous indiquons en quelque sorte au navigateur combien vous pouvez compresser les colonnes et combien vous pouvez étirer. Lorsque l'une des limites est atteinte, le nombre de colonnes augmente ou diminue, respectivement.</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.archive</span> {
  <span class="hljs-attribute">grid-template-columns</span>: repeat (auto-fit, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">180px</span>, <span class="hljs-number">1</span>fr));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet exemple, le navigateur tentera de prendre en charge autant de colonnes que 180 pixels de large. </font><font style="vertical-align: inherit;">S'il y a un excès d'espace, toutes les colonnes se développeront, le répartissant également entre elles. </font><font style="vertical-align: inherit;">C'est ce qui dicte le sens </font></font><code>1fr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: rendre les tailles de colonnes égales aux fractions ( </font><font style="vertical-align: inherit;">actions </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) de la largeur disponible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous étirez la fenêtre du navigateur, toutes les colonnes augmenteront de manière égale avec l'augmentation de l'espace libre. </font><font style="vertical-align: inherit;">Dès que le nouvel espace atteint 180 pixels, une nouvelle colonne apparaît à sa place. </font><font style="vertical-align: inherit;">Et si vous réduisez la fenêtre du navigateur, tout se passe dans l'autre sens, ajustant parfaitement la grille jusqu'à ce qu'elle se transforme en une disposition à une seule colonne. </font><font style="vertical-align: inherit;">La magie! </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→ Démo vidéo</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Et toute cette adaptabilité grâce à une seule ligne de code. </font><font style="vertical-align: inherit;">Eh bien cool?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Création de portées avec «autoflow: dense»</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, pour le moment, nous avons déjà une grille adaptative, c'est juste tous ses éléments - la même largeur. </font><font style="vertical-align: inherit;">La mise en page d'un journal ou d'un magazine implique la présence de blocs sélectionnés, dans ce contexte, ceux qui couvriraient deux, trois, voire toutes les colonnes disponibles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour créer des étendues à plusieurs colonnes, nous pouvons utiliser la propriété </font></font><code>grid-column: span</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans les éléments qui devraient occuper plus d'espace. </font><font style="vertical-align: inherit;">Supposons que nous voulons que le troisième élément de la liste ait deux colonnes de large:</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(3)</span> {
  <span class="hljs-attribute">grid-column</span>: span <span class="hljs-number">2</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, après l'ajout de portées, de nombreux problèmes peuvent apparaître. </font><font style="vertical-align: inherit;">Premièrement, des trous peuvent se former dans la grille dans les cas où l'élément large ne tient pas sur sa ligne et le </font></font><code>auto-fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transfère comme suit:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tg/xl/8i/tgxl8iziz5_tm6pnng4wpnbbghm.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci est facilement résolu en ajoutant une propriété </font></font><code>grid-auto-flow: dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à la grille. </font><font style="vertical-align: inherit;">En raison de cette propriété, le navigateur comprend que les trous doivent être remplis avec d'autres éléments. </font><font style="vertical-align: inherit;">Cela crée un flux autour des éléments plus larges et plus étroits:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tt/j9/hn/ttj9hndgzfsxehzxw1iqdxz4fa4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Attention: l'ordre des éléments est cassé, maintenant le quatrième élément est devant le troisième. </font><font style="vertical-align: inherit;">Pour autant que je sache, cela ne peut pas être contourné, c'est l'une des limitations de CSS Grid qui doit être acceptée.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Façons d'identifier les travées</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe plusieurs façons de spécifier le nombre de colonnes qu'un élément doit occuper. </font><font style="vertical-align: inherit;">Il est plus facile de l'appliquer </font></font><code>grid-columns: span [n]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à l'un des éléments, où </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est le nombre de colonnes que l'élément occupera. </font><font style="vertical-align: inherit;">Le troisième élément de notre mise en page a une propriété enregistrée </font></font><code>grid-column: span 2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui explique pourquoi sa largeur est deux fois plus grande que les autres éléments. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour utiliser d'autres méthodes, vous devez </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spécifier les lignes de la grille</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Les lignes de la grille sont numérotées comme suit:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/xg/za/yn/xgzaynnxcflkzedtleek72epqcs.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les lignes de la grille peuvent être indiquées de gauche à droite avec des nombres positifs (par exemple, 1, 2, 3) ou de droite à gauche avec des nombres négatifs (-1, -2, -3). </font><font style="vertical-align: inherit;">Ils peuvent être utilisés pour placer des éléments dans la grille à l'aide d'une propriété </font></font><code>grid-column</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comme ceci:</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.grid-item</span> {
  <span class="hljs-attribute">grid-column</span>: ( ) / ( );<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, les lignes de la grille élargissent notre capacité à définir des portées. </font><font style="vertical-align: inherit;">La flexibilité est ajoutée par la possibilité de remplacer la valeur initiale ou finale par un mot-clé </font></font><code>span</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Par exemple, le bloc bleu à trois colonnes dans l'exemple ci-dessus peut être créé en appliquant l'une de ces propriétés au huitième élément de grille:</font></font><br>
<br>
<ul>
<li><code>grid-column: 3 / 6</code></li>
<li><code>grid-column: -4 / -1</code></li>
<li><code>grid-column: 3 / span 3</code></li>
<li><code>grid-column: -4 / span 3</code></li>
<li><code>grid-column: span 3 / -1</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etc.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans une grille non adaptative (c'est-à-dire avec un nombre fixe de colonnes), chacune de ces propriétés donne le même résultat (comme dans l'exemple avec le bloc bleu ci-dessus). </font><font style="vertical-align: inherit;">Mais si la grille est adaptative et que le nombre de colonnes change, la différence devient très sensible. </font><font style="vertical-align: inherit;">Certaines plages cassent la mise en page avec le retour automatique activé, ce qui donne à penser que ces deux solutions sont incompatibles. </font><font style="vertical-align: inherit;">Heureusement, certaines astuces nous permettront de les combiner en toute sécurité. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais d'abord, nous devons comprendre le problème.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problèmes de défilement horizontal</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici quelques «éléments en vedette» créés à l'aide de la méthode de la ligne de grille (cliquable):</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/webt/nz/9m/uq/nz9muqk1spn-eujmvhwutl9rblm.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur toute la largeur (cinq colonnes), tout semble bien, mais si vous réduisez l'écran à une taille à laquelle il devrait y avoir deux colonnes, la disposition se rompt de cette façon:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/bb/oh/uu/bbohuutkvjhpbtv4ocjhmx0uodu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, notre grille a perdu son adaptabilité et, bien que le conteneur ait rétréci, la grille essaie de prendre en charge les cinq colonnes. Pour ce faire, elle continue d'essayer la même largeur de colonne et dépasse éventuellement les limites de son conteneur à droite. De là, un défilement horizontal apparaît. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi ça arrive? Le problème est que le navigateur essaie de se conformer à nos directions exactes pour les lignes de la grille. À cette largeur, la </font></font><code>auto-fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grille ne devrait afficher que deux colonnes, mais notre système de numérotation des lignes de pile contredit cela, se référant spécifiquement à la cinquième ligne. Cette contradiction mène au désordre. Pour afficher correctement notre grille implicite à deux colonnes, seuls les nombres 1, 2, 3 et -3, -2, -1 peuvent être utilisés, comme ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/s3/7t/1q/s37t1qfemvneeuufd7jvsantkz4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais si l'un des éléments de notre grille contient des instructions en </font></font><code>grid-column</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dehors de ces limites, disons 4, 5 ou -6, le navigateur reçoit des instructions ambiguës. D'une part, nous vous demandons de créer automatiquement des colonnes flexibles (qui devraient - implicitement - rester deux à cette largeur d'écran). D'autre part, nous avons explicitement fait référence aux lignes de grille, qui ne peuvent pas exister dans un format à deux colonnes. En cas de contradiction entre les colonnes implicites (automatiques) et leur nombre explicitement défini, la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grille préfère toujours une définition explicite</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . C'est ainsi que les colonnes indésirables et le débordement horizontal apparaissent (ce qu'ils appellent </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la perte de données CSS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Les étendues, comme les numéros de ligne de grille, peuvent créer des définitions de colonnes explicites. </font><font style="vertical-align: inherit;">grid-column: span 3 (le huitième élément de la grille dans la démo) force la grille à avoir explicitement au moins trois colonnes, malgré le fait que nous voulons deux implicites. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il peut sembler que la seule option consiste à utiliser des requêtes multimédias pour modifier les valeurs </font></font><code>grid-column</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à la largeur souhaitée ... mais ne vous précipitez pas! </font><font style="vertical-align: inherit;">Je le pensais aussi au début. </font><font style="vertical-align: inherit;">Mais, après un peu de réflexion et de jouer avec différents paramètres, j'ai trouvé qu'il existe quelques façons de contourner ce problème, grâce auxquelles nous n'avons toujours qu'une seule demande de support pour les appareils les plus étroits.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solutions</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'est avéré que l'astuce consiste à déterminer les étendues en utilisant uniquement les numéros de ligne disponibles pour la grille la plus étroite de celles planifiées pour l'affichage. </font><font style="vertical-align: inherit;">Dans ce cas, nous parlons d'une grille à deux colonnes (rappel, nous utilisons une requête média pour l'affichage sur une seule colonne). </font><font style="vertical-align: inherit;">Ainsi, vous pouvez utiliser en toute sécurité les nombres 1, 2, 3 et leurs paires négatives sans casser la grille. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au début, je pensais que je me limiterais à la largeur de la travée en deux colonnes en utilisant ces combinaisons de nombres:</font></font><br>
<br>
<ul>
<li><code>grid column: span 2</code></li>
<li><code>grid-column: 1 /3</code></li>
<li><code>grid-column: -3 / -1</code></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/m5/q5/q8/m5q5q8beij-uiipgfasj_cndegy.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qui restent parfaitement adaptables jusqu'à deux enceintes:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/m0/ln/xb/m0lnxbx2i2axufbbyde7nusr-v4.png"></div><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que cela fonctionne</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , du point de vue de la conception, c'est une limitation sérieuse et pas trop brillante. Je voulais faire des portées de trois, quatre ou même cinq colonnes sur des écrans larges. Mais comment? Ma première pensée a été de revenir aux questions des médias (omg, il est difficile de se débarrasser des anciennes habitudes), mais j'ai quand même essayé d'éviter cette approche et de regarder le design réactif sous un angle différent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En regardant à nouveau la liste des nombres disponibles, je me suis soudain rendu compte que les nombres positifs et négatifs dans les valeurs initiales et finales </font></font><code>grid-column</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peuvent être combinés, par exemple </font></font><code>1/-3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font><code>2/-2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cela ne semble rien d'intéressant. Mais cela ne semble plus comme ça lorsque vous comprenez la position des lignes après avoir changé la taille de la grille: les portées changent la largeur en fonction de la largeur de l'écran. Un tas de nouvelles opportunités pour les étendues adaptatives ouvrent, en particulier, des éléments qui s'étendent sur un nombre différent de colonnes avec un changement de la largeur de l'écran, sans aucune interrogation multimédia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier exemple que j'ai découvert est </font></font><code>grid-column: 1/-1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cette propriété transforme l'élément en bannière en pleine largeur, remplissant toutes les colonnes de la première à la dernière, même lorsqu'il n'y a qu'une seule colonne! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En utilisant</font></font><code>grid-column: 1/-2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous pouvez créer une plage "presque pleine largeur", qui remplit toutes les colonnes de gauche à droite, sauf la dernière. Dans une disposition à deux colonnes, une telle étendue se transforme de manière adaptative en un élément ordinaire dans une colonne. Étonnamment, cela fonctionne même lors de la compression de la mise en page sur une colonne. (Il semble que la raison soit que la grille ne réduira pas l'élément à une largeur nulle et qu'il reste donc la largeur d'une colonne, comme dans le cas avec </font></font><code>grid-column: 1/1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.) J'ai supposé que cela </font></font><code>grid-column: 2/-1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devrait fonctionner de la même manière, ne laisser qu'une colonne intacte à gauche, et non à droite . Il s'est avéré être presque à droite, lors de la compression de la mise en page sur une colonne, un débordement se produit toujours. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai ensuite essayé une combinaison</font></font><code>1/-3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cela a bien fonctionné sur des écrans larges - remplissant au moins trois colonnes - et sur des écrans étroits - n'en remplissant qu'une seule. Je pensais qu'avec une grille à deux colonnes, quelque chose d'étrange se produirait, car puisque la première ligne de la grille est la même que la ligne sous le numéro </font></font><code>-3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. À ma grande surprise, l'article s'affiche correctement dans une colonne. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après de nombreuses expériences, j'ai découvert qu'il existe 11 valeurs appropriées </font></font><code>grid-column</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parmi celles disponibles dans une grille à deux colonnes. Trois d'entre eux fonctionnent même dans une disposition à une seule colonne. Sept autres fonctionnent correctement jusqu'à deux colonnes, et pour un affichage correct dans une colonne, ils n'auront besoin que d'une seule requête média. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici la liste complète:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/_t/dv/bd/_tdvbd8_atfcs8y8us61wq3xzws.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Démonstration de valeurs adaptatives grille-colonne sur différentes tailles d'écran dans une grille à ajustement automatique. </font><font style="vertical-align: inherit;">( </font></font><em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Démo</font></font></a></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, malgré un sous-ensemble plutôt limité de plages adaptatives, il existe de nombreuses opportunités.</font></font><br>
<br>
<ul>
<li><code>2/-2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Une combinaison intéressante, crée une portée centrée qui fonctionne jusqu'à la grille à une seule colonne!</font></font></li>
<li><code>3/-1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - moins utile car elle conduit à un débordement même sur deux colonnes.</font></font></li>
<li><code>3/-3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - une agréable surprise.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En raison de la variété des valeurs </font></font><code>grid-column</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de cette liste, il est possible de créer une mise en page intéressante et entièrement réactive. </font><font style="vertical-align: inherit;">En utilisant une seule requête multimédia pour l'affichage sur une seule colonne le plus étroit, nous pouvons gérer dix modèles différents </font></font><code>grid-column</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette même requête média est assez simple, même disons simple. </font><font style="vertical-align: inherit;">Dans notre exemple, il est responsable de la commutation de l'affichage de la grille sur flexbox:</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width:</span> <span class="hljs-number">680px</span>) {
  <span class="hljs-selector-class">.archive</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">flex-direction</span>: column;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-selector-class">.article</span> {
    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">2em</span>;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici la grille finale qui, comme vous l'avez peut-être remarqué, est entièrement réactive - d'une à cinq colonnes (cliquable):</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/939/9aa/ad0/9399aaad0e89f01d46745aae0efaa928.gif"></div></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation: nth-child () pour répéter la largeur dynamique</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour réduire mon code à deux douzaines de lignes, j'ai appliqué une autre astuce. Le sélecteur </font></font><code>:nth-child(n)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m'a permis de styliser un grand nombre d'éléments à la fois. Toute mon idée avec les étendues devait être appliquée à de nombreux messages dans le flux afin que les blocs sélectionnés apparaissent régulièrement sur la page. Tout d'abord, j'ai écrit une liste de sélecteurs séparés par des virgules avec un numéro d'élément clairement défini:</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(2)</span>,
<span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(18)</span>,
<span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(34)</span>,
<span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(50)</span>  {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">64</span>,<span class="hljs-number">0.8</span>);
  <span class="hljs-attribute">grid-column</span>: -<span class="hljs-number">3</span> / -<span class="hljs-number">1</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En vitesse, j'ai réalisé que c'est un processus très long, surtout quand vous devez copier toute cette liste de conditions pour chaque élément enfant qui doit être modifié dans l'article - en-tête, liens, etc. Pendant le prototypage, j'ai été forcé de changer manuellement les numéros dans chacune de ces listes chaque fois que je voulais jouer avec la position des travées. Un processus ennuyeux et sujet aux erreurs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est alors que j'ai réalisé que vous pouvez profiter de la fonctionnalité intéressante du pseudo-sélecteur </font></font><code>:nth-child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: au lieu d'une valeur entière, entrez une expression, par exemple </font></font><code>:nth-child(2n+ 2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui signifie chaque deuxième élément enfant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici comment j'ai utilisé </font></font><code>:nth-child([])</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour créer un bloc bleu pleine largeur dans ma grille qui apparaît en haut de la page, puis à mi-chemin dans la liste:</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(31n</span> + 1) {
  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / -<span class="hljs-number">1</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">11</span>, <span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-number">0.5</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un morceau de code entre parenthèses ( </font></font><code>31n + 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) est responsable du choix du 1er, 32e, 63e, etc. élément enfant. Le navigateur démarre la boucle en commençant par n = 0 ( </font></font><code>31 * 0 + 1 = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), puis </font></font><code>n=1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><code>31 * 1 + 1 = 32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) et enfin </font></font><code>n=2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><code>31 * 2 + 1 = 63</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Dans ce dernier cas, le navigateur comprend qu'il n'y a pas de 63e élément enfant, ignore la règle, arrête le cycle et applique la règle aux 1er et 32e éléments. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je fais quelque chose de similaire pour les blocs violets qui apparaissent à gauche ou à droite sur toute la page:</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(16n</span> + 2) {
  <span class="hljs-attribute">grid-column</span>: -<span class="hljs-number">3</span> / -<span class="hljs-number">1</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">64</span>, <span class="hljs-number">0.8</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(16n</span> + 10) {
  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / -<span class="hljs-number">2</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">64</span>, <span class="hljs-number">0.8</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier sélecteur est pour les blocs violets de gauche. L'expression </font></font><code>16n + 2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est responsable de l'application de styles à chaque 16e élément de grille, en commençant par le second. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxième sélecteur est pour les blocs violets de droite. L'intervalle est le même ( </font></font><code>16n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), mais le décalage est différent ( </font></font><code>10</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). En conséquence, ces blocs se retrouvent régulièrement sur le côté droit de la grille, dans les éléments numérotés 10, 26, 42, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour les styles visuels de ces éléments, j'ai utilisé une autre astuce pour éviter la répétition du code. Pour les styles courants de blocs violets (pour évidents </font></font><code>background-color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, par exemple), vous pouvez utiliser un sélecteur:</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(8n</span> + 2) {
  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">64</span>, <span class="hljs-number">0.8</span>);
  <span class="hljs-comment">/* Other shared syling */</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce sélecteur sélectionne les éléments 2, 10, 18, 26, 34, 42, 50 et plus. </font><font style="vertical-align: inherit;">En d'autres termes, il sélectionne les blocs gauche et droit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela fonctionne parce que </font></font><code>8n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- c'est exactement la moitié </font></font><code>16n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et la différence de décalage dans les deux sélecteurs est également de 8.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le dernier mot</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSS Grid peut désormais être utilisé pour créer des maillages flexibles et réactifs avec un minimum de code. Cependant, si vous évitez d'utiliser des requêtes de médias rétrogrades, il existe des restrictions importantes sur le positionnement des éléments dans la grille. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce serait très cool de pouvoir créer des portées qui n'entraîneraient pas de défilement horizontal et de débordement sur de petits écrans. Maintenant, nous pouvons dire au navigateur: «Faites une grille adaptative, s'il vous plaît», et il le fait très bien. Mais il vous suffit d'ajouter: "Oh, et cet élément de la grille est étiré en quatre colonnes, s'il vous plaît", et il agite la poignée vers des écrans étroits, donnant la préférence à la demande d'une étendue de quatre colonnes, plutôt qu'à une grille adaptative. Il serait possible de faire faire le contraire à la grille, par exemple comme ceci:</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.article</span> {
  <span class="hljs-attribute">grid-column</span>: span <span class="hljs-number">3</span>, autofit;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre problème avec les grilles réactives est la dernière ligne. </font><font style="vertical-align: inherit;">La modification de la largeur de l'écran peut souvent la rendre vierge. </font><font style="vertical-align: inherit;">J'ai essayé pendant longtemps de trouver un moyen d'étirer le dernier élément de la grille aux colonnes restantes (respectivement, remplir la ligne), mais cela semble impossible. </font><font style="vertical-align: inherit;">Au moins pour l'instant. </font><font style="vertical-align: inherit;">Ce serait bien d'avoir la possibilité de définir la position initiale de l'élément avec un mot-clé, comme </font></font><code>auto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pour ainsi dire, dire "Remplissez la ligne jusqu'à la fin, en commençant par le bord gauche". </font><font style="vertical-align: inherit;">Quelque chose comme ça:</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.article</span> {
  <span class="hljs-attribute">grid-column</span>: auto, -<span class="hljs-number">1</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... qui étirerait la portée sur le bord gauche de la grille jusqu'à la fin de la ligne.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr492744/index.html">Quel système sera le plus bruyant et qui donnera le silence «absolu»: deux projets scientifiques intéressants</a></li>
<li><a href="../fr492746/index.html">Comment éviter l'indignation de la programmation? Conseils d'intégration</a></li>
<li><a href="../fr492748/index.html">Profession DevOps-engineer: une vue de l'administrateur système</a></li>
<li><a href="../fr492754/index.html">Pourquoi JavaScript dévore le HTML: exemples de code</a></li>
<li><a href="../fr492758/index.html">Podcasts pour les développeurs</a></li>
<li><a href="../fr492762/index.html">Alphabet des investisseurs: qu'est-ce qu'un appel de marge et comment l'éviter</a></li>
<li><a href="../fr492766/index.html">Nous pompons le travail avec des événements dans Angular</a></li>
<li><a href="../fr492768/index.html">Greybox Fuzzing par l'exemple d'AFLSmart</a></li>
<li><a href="../fr492770/index.html">Apprendre, négocier, consulter à distance - Partie 1: Mind Server et sa version gratuite</a></li>
<li><a href="../fr492772/index.html">Comment Amazon tente de poursuivre les produits les plus risqués du site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>