<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏽 🧑🏿 🏇🏿 Redux vs MobX sin confusión 👨‍❤️‍👨 🧚🏽 ♈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En los últimos años, a menudo he usado Redux , pero recientemente he estado usando MobX como alternativa a la administración del estado. Las alternati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Redux vs MobX sin confusión</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489854/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/dt/7e/na/dt7enamgfkxspaajcdst26auxj8.jpeg" alt="imagen"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los últimos años, a menudo he usado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero recientemente he estado usando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MobX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como alternativa a la administración del estado. Las alternativas de Redux parecen convertirse naturalmente en un desastre. La gente no está segura de qué solución elegir. El problema no es necesariamente Redux vs MobX. Siempre que hay una alternativa, las personas sienten curiosidad por saber cómo resolver mejor su problema. Estoy escribiendo estas líneas para eliminar la confusión sobre las soluciones de administración de estado de Redux y MobX.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿De qué se tratará este artículo? </font><font style="vertical-align: inherit;">Primero, quiero volver brevemente al problema que resuelve la biblioteca de administración de estado. </font><font style="vertical-align: inherit;">Al final, todo estará bien si solo usa this.setState () y this.state en React o su variación en otra biblioteca de nivel de presentación o en un entorno SPA. </font><font style="vertical-align: inherit;">En segundo lugar, continuaré ofreciéndole una visión general de ambas soluciones, mostrando coherencia y diferencias. </font><font style="vertical-align: inherit;">Por último, pero no menos importante, si ya tiene una aplicación que funciona con MobX o Redux, quiero informarle sobre la refactorización de una biblioteca de estado a otra.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenido:</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué problema resolvemos?</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cuál es la diferencia entre REDUX y MOBX?</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curva de aprendizaje del estado de reacción</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pensamientos recientes sobre el tema</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Más recursos</font></font></a></li>
</ol><br>
<a name="WhatProblem"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué problema resolvemos?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos quieren tener administración de estado en la aplicación. </font><font style="vertical-align: inherit;">Pero, ¿qué problema nos resuelve esto? </font><font style="vertical-align: inherit;">La mayoría de las personas comienzan con una pequeña aplicación y ya implementan una biblioteca de administración de estado. </font><font style="vertical-align: inherit;">Todos hablan de eso, ¿verdad? </font><font style="vertical-align: inherit;">Redux! </font><font style="vertical-align: inherit;">MobX! </font><font style="vertical-align: inherit;">Pero la mayoría de las aplicaciones no necesitan una gestión estatal ambiciosa desde el principio. </font><font style="vertical-align: inherit;">Esto es aún más peligroso porque la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mayoría de las personas nunca se enfrentarán a problemas como bibliotecas como Redux o MobX</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El status quo actualmente está creando una aplicación front-end con componentes. </font><font style="vertical-align: inherit;">Los componentes tienen un estado interno. </font><font style="vertical-align: inherit;">En una aplicación en crecimiento, la administración del estado puede volverse caótica con un estado local porque:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un componente debe compartir el estado con otro componente</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un componente debe modificar el estado de otro componente</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En algún momento, se vuelve cada vez más difícil hablar sobre el estado de la aplicación. Esto se convierte en una red sucia de objetos de estado y mutaciones de estado en su jerarquía de componentes. En la mayoría de los casos, los objetos de estado y las mutaciones de estado no están necesariamente asociados con un componente. Están vinculados a través de su árbol de componentes, y debe subir y bajar el estado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La solución, por lo tanto, es introducir una biblioteca de administración de estado como MobX o Redux. Le brinda herramientas para guardar su estado, cambiar el estado y recibir actualizaciones de estado. Tiene un lugar para buscar, un lugar para cambiar y un lugar para recibir actualizaciones de estado. Sigue el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">principio de una sola fuente de verdad.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto facilita razonar sobre los cambios en su estado y condiciones, ya que se separan de sus componentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las bibliotecas de administración de estado como Redux y MobX a menudo tienen complementos para utilidades, por ejemplo, para Angular tienen angular-redux y mobx-angular para dar acceso a sus componentes al estado. </font><font style="vertical-align: inherit;">A menudo, estos componentes se denominan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">componentes en contenedores</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o, para ser más precisos, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">componentes relacionados</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Desde cualquier lugar de su jerarquía de componentes, puede acceder al estado y cambiarlo actualizando su componente a uno relacionado.</font></font><br>
<br>
<a name="whats-the-difference-between-redux-and-mobx"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cuál es la diferencia entre REDUX y MOBX?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de sumergirnos en la diferencia, quiero contarles sobre las similitudes entre MobX y Redux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ambas bibliotecas se utilizan para controlar el estado en aplicaciones JavaScript. No están necesariamente asociados con una biblioteca como Angular. También se usan en otras bibliotecas, como ReactJs y VueJs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si elige una de las soluciones de administración del estado, no se encontrará con un bloqueo de proveedor. Puede cambiar a otra solución de administración de estado en cualquier momento. Puede actualizar de MobX a Redux o de Redux a MobX. Más tarde te mostraré cómo sucede esto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redux diseñado por </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan Abramov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andrew Clark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un derivado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de la arquitectura Flux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A diferencia de Flux, utiliza un repositorio sobre varios para mantener el estado. Además, en lugar de un despachador, utiliza funciones puras para cambiar el estado. Si no está familiarizado con el flujo y es nuevo en la administración del estado, no se preocupe por el último párrafo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redux está influenciado por los </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">principios de la programación funcional</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (FP). La FP se puede hacer en JavaScript, pero muchas personas provienen de un entorno orientado a objetos, como Java, y tienen dificultades para aceptar los principios de la programación funcional en primer lugar. Esto explica más adelante por qué MobX puede ser más fácil de aprender como principiante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como Redux incluye programación funcional, utiliza </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funciones puras</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una función pura es una función que recibe entrada, devuelve salida y no tiene otras dependencias que no sean las mismas funciones. </font><font style="vertical-align: inherit;">Dicha función siempre produce la misma salida con la misma entrada y no tiene efectos secundarios. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Más detalles</font></font></a></blockquote><br>
<pre><code class="javascript hljs">(state, action) =&gt; newState</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Su estado de Redux </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no ha cambiado</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En lugar de mutar, siempre devuelve un nuevo estado. </font><font style="vertical-align: inherit;">No realiza mutaciones de estado y no depende de referencias de objetos.</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-comment">//     Redux,     </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAuthor</span>(<span class="hljs-params">state, action</span>) </span>{
  <span class="hljs-keyword">return</span> state.authors.push(action.author);<font></font>
}<font></font>
<span class="hljs-comment">//       </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAuthor</span>(<span class="hljs-params">state, action</span>) </span>{
  <span class="hljs-keyword">return</span> [ ...state.authors, action.author ];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y por último, pero no menos importante, en Redux idiomático, su </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado está normalizado</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , como en una base de datos. Las entidades se </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">refieren entre sí solo por id</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esta es la mejor práctica. Aunque no todos lo hacen, puede usar una biblioteca como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normalizr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para lograr un estado tan normalizado. El estado normalizado le permite mantener un estado plano y entidades como una </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sola fuente de verdad</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="json hljs">{<font></font>
  post: {<font></font>
    id: 'a',<font></font>
    authorId: 'b',<font></font>
    ...<font></font>
  },<font></font>
  author: {<font></font>
    id: 'b',<font></font>
    postIds: ['a', ...],<font></font>
    ...<font></font>
  }<font></font>
}</code></pre><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En comparación, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MobX de Michel Weststratt está</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> influenciado no solo por la programación orientada a objetos, sino también por la programación reactiva. </font><font style="vertical-align: inherit;">Envuelve su estado en objetos observables. </font><font style="vertical-align: inherit;">Por lo tanto, tiene todas las características de " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " en su estado. </font><font style="vertical-align: inherit;">Los datos pueden tener configuradores y captadores simples, pero observables le permiten recibir actualizaciones después de los cambios de datos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Mobx, tu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado es volátil</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">De esta manera cambia el estado directamente:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAuthor</span>(<span class="hljs-params">author</span>) </span>{
  <span class="hljs-keyword">this</span>.authors.push(author);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, las organizaciones permanecen en una estructura de datos (profundamente) anidadas entre sí. </font><font style="vertical-align: inherit;">No normalizas tu condición. </font><font style="vertical-align: inherit;">La condición </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permanece </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desnormalizada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e incrustada.</font></font></b><br>
<br>
<pre><code class="json hljs">{<font></font>
  post: {<font></font>
    id: 'a',<font></font>
    ...<font></font>
    author: {<font></font>
      id: 'b',<font></font>
      ...<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un repositorio versus varios</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Redux, almacena todo su estado en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un repositorio global</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un estado global</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Un único objeto de estado es su única fuente de verdad. Numerosas cajas de cambios, por otro lado, le permiten cambiar un estado inmutable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En comparación, MobX usa varios repositorios. Al igual que los reductores Redux, puede aplicar separación y conquista por nivel técnico, dominio, etc. Puede almacenar sus objetos de dominio en repositorios separados, pero también puede controlar el estado de visualización en sus repositorios. Al final, coloca el estado más apropiado para su aplicación.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Técnicamente, también puede tener múltiples repositorios en Redux. </font><font style="vertical-align: inherit;">Nadie te obliga a usar solo uno. </font><font style="vertical-align: inherit;">Pero este no es un caso de uso anunciado de Redux. </font><font style="vertical-align: inherit;">El uso de múltiples repositorios va en contra de las mejores prácticas. </font><font style="vertical-align: inherit;">En Redux, desea tener un repositorio que responda a través de sus reductores a eventos globales.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cómo se ve la implementación?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Redux, agregar la configuración de una aplicación a un estado global requiere las siguientes líneas de código. </font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> initialState = {
  <span class="hljs-attr">users</span>: [<font></font>
    {<font></font>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Alex'</span><font></font>
    },<font></font>
    {<font></font>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Nik'</span><font></font>
    }<font></font>
  ]<font></font>
};<font></font>
<span class="hljs-comment">// reducer</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">users</span>(<span class="hljs-params">state = initialState, action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">'USER_ADD'</span>:
    <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">users</span>: [ ...state.users, action.user ] };
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">return</span> state;<font></font>
  }<font></font>
}<font></font>
<span class="hljs-comment">// action</span>
{ <span class="hljs-attr">type</span>: <span class="hljs-string">'USER_ADD'</span>, <span class="hljs-attr">user</span>: user };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En MobX, el almacenamiento solo administrará el subestado (ya que el reductor en Redux controla el subestado), pero puede cambiar directamente el estado. </font><font style="vertical-align: inherit;">La anotación @observable le permite observar cambios de estado.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">userStore</span></span>{<font></font>
@observable users = [<font></font>
    {<font></font>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Nikita'</span><font></font>
    }<font></font>
  ];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora puede llamar a userStore.users.push (usuario); </font><font style="vertical-align: inherit;">en la copia de la tienda. </font><font style="vertical-align: inherit;">Sin embargo, se recomienda que las mutaciones estatales sean más explícitas a través de la acción.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">userStore</span></span>{<font></font>
@observable users = [<font></font>
    {<font></font>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Nikita'</span><font></font>
    }<font></font>
  ];<font></font>
}<font></font>
@action addUser = <span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> {
    <span class="hljs-keyword">this</span>.users.push(user);<font></font>
  }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede aplicarlo estrictamente configurando MobX con configure ({empceActions: true}) ;. </font><font style="vertical-align: inherit;">Ahora puede cambiar su estado llamando a userStore.addUser (usuario); </font><font style="vertical-align: inherit;">en la copia de la tienda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Has visto cómo actualizar el estado en Redux y MobX. </font><font style="vertical-align: inherit;">En Redux, su estado es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de solo lectura</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Solo puede cambiar el estado con </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acciones explícitas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En contraste, en MobX, el estado incluye lectura y escritura. </font><font style="vertical-align: inherit;">Puede mutar el estado directamente sin usar acciones, pero puede seleccionar acciones explícitas usando la configuración de enforceActions.</font></font><br>
<br>
<a name="the-learning-curve-in-react-state-management"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curva de aprendizaje del estado de reacción</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tanto Redux como MobX se utilizan principalmente en aplicaciones React. Pero estas son bibliotecas de administración de estado independientes que se pueden usar en todas partes sin React. Sus bibliotecas de interacción facilitan su combinación con componentes angulares. Estos son </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">react-redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React + Redux</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mobx-react</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React + MobX</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Más adelante explicaré cómo usar ambos en el árbol de componentes Angular.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En discusiones recientes, ha sucedido que la gente discutió sobre la curva de aprendizaje en Redux. Esto sucedió a menudo en el contexto de React: las personas comenzaron a aprender React y ya querían usar la administración de estado con Redux. La mayoría de las personas afirman que React y Redux tienen una buena curva de aprendizaje, pero ambos pueden ser abrumadores. Por lo tanto, MobX será una alternativa, porque es más adecuado para principiantes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, sugeriría un enfoque diferente para que los nuevos usuarios de React aprendan sobre la gestión del estado en el ecosistema de React. </font><font style="vertical-align: inherit;">Comience a aprender Reaccione con sus propias funciones locales de administración de estado en componentes. </font><font style="vertical-align: inherit;">En una aplicación React, primero aprende sobre los métodos del ciclo de vida de React y comprende cómo administrar los estados locales con setState () y this.state. </font><font style="vertical-align: inherit;">Recomiendo esta ruta de aprendizaje. </font><font style="vertical-align: inherit;">De lo contrario, se verá rápidamente abrumado por el ecosistema React. </font><font style="vertical-align: inherit;">Al final, en el camino te darás cuenta de que administrar el estado (interno) de los componentes se vuelve complicado.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Redux o MobX para principiantes?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al familiarizarse con los componentes angulares y la administración de estado interna, puede elegir una biblioteca de administración de estado para resolver su problema. Después de usar ambas bibliotecas, diría que MobX puede ser muy conveniente para principiantes. Ya hemos visto que MobX necesita menos código, aunque usa algunas notas mágicas que aún no necesitamos saber. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con MobX, no necesita estar familiarizado con la programación funcional. Los términos como inmutabilidad aún pueden ser extranjeros.</font></font><blockquote>  —   ,       JavaScript.     ,          ,   - , ,     MobX.</blockquote><br>
<br>
<h3>  Redux</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A medida que su aplicación crece y varios desarrolladores trabajan en ella, debería considerar usar Redux. Por naturaleza, se compromete a utilizar acciones explícitas para cambiar de estado. La acción tiene un tipo y una carga útil que la caja de cambios puede usar para cambiar de estado. Es muy fácil para el equipo de desarrollo hablar sobre los cambios de estado de esta manera. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redux le proporciona una arquitectura completa para administrar el estado con claras limitaciones. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Historia de éxito de Redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra ventaja de Redux es su uso en el lado del servidor. Como estamos trabajando con JavaScript simple, puede enviar estado a través de la red. La serialización y deserialización de un objeto de estado funciona de forma inmediata. Sin embargo, esto también es posible con MobX.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MobX es menos seguro de sí mismo, pero con configure ({empceActions: true}) puede aplicar restricciones más precisas, como en Redux. Es por eso que no diría que no puede usar MobX para escalar aplicaciones, pero Redux tiene una forma clara de hacer algo. La documentación de MobX incluso dice: " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[MobX] no le dice cómo estructurar su código, dónde almacenar el estado o cómo manejar los eventos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". El equipo de desarrollo primero tendría que crear una arquitectura de gestión de estado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de todo, la curva de aprendizaje de gestión estatal no es tan empinada. Cuando repetimos las recomendaciones, un novato en React </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aprenderá primero a usar setState () y this.state correctamente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Después de un tiempo, comprenderá los </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">problemas de usar solo setState ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para mantener el estado en la aplicación React. </font><font style="vertical-align: inherit;">Cuando busca una solución, se encuentra con bibliotecas de administración de estado como MobX o Redux. </font><font style="vertical-align: inherit;">Pero ¿cuál escoger? </font><font style="vertical-align: inherit;">Dado que MobX es menos seguro de sí mismo, tiene una plantilla más pequeña y se puede usar de la misma manera que setState (), recomendaría darle una oportunidad a MobX en proyectos pequeños. </font><font style="vertical-align: inherit;">Tan pronto como la aplicación crezca en tamaño y aumente el número de participantes, debería considerar aplicar restricciones adicionales en MobX o darle una oportunidad a Redux. </font><font style="vertical-align: inherit;">Me gustó usar ambas bibliotecas. </font><font style="vertical-align: inherit;">Incluso si no usa uno de ellos al final, tiene sentido ver una forma alternativa de administrar el estado.</font></font><br>
<br>
<a name="last-thoughts"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Últimos pensamientos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada vez que leo los comentarios en la discusión de Redux vs MobX, siempre hay un comentario: “ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux tiene demasiado estándar, en su lugar deberías usar MobX. Pude eliminar XXX líneas de código</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". El comentario puede ser cierto, pero nadie considera un compromiso. Redux viene con muchas plantillas como MobX porque se ha agregado para restricciones de diseño específicas. Esto le permite razonar sobre el estado de su aplicación, incluso si es a mayor escala. Toda la ceremonia asociada con el tratamiento del estado, no es justa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La biblioteca de Redux es bastante pequeña. La mayoría de las veces </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo se trata de simples objetos y matrices de JavaScript.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esto está más cerca de JavaScript vainilla que MobX. En MobX, los objetos y las matrices están envueltos en objetos observables que ocultan la mayor parte de la plantilla estándar. Se basa en abstracciones ocultas en las que ocurre la magia, pero es más difícil entender los mecanismos básicos. Redux facilita hablar sobre esto con JavaScript simple. Esto facilita probar y depurar la aplicación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, debe volver a pensar de dónde venimos en el SPA. Un conjunto de marcos de una página y bibliotecas de aplicaciones tenían los mismos problemas de administración de estado que finalmente se resolvieron utilizando un modelo de flujo integral. Redux es el sucesor de este enfoque.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En MobX, nuevamente se mueve en la dirección opuesta. Nuevamente comenzamos a mutar el estado directamente, sin aprovechar la programación funcional. Para algunas personas, esto se acerca nuevamente al enlace de datos bidireccional. Después de un tiempo, las personas pueden volver a encontrar los mismos problemas antes de que aparezca una biblioteca de administración de estado como Redux. La gestión del estado está dispersa entre los componentes y termina en desorden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mientras que en Redux tienes una ceremonia establecida para configurar las cosas, MobX es menos seguro de sí mismo. Pero sería prudente aceptar la mejor experiencia MobX. La gente necesita saber cómo organizar la gestión estatal para mejorar sus argumentos al respecto. De lo contrario, las personas tienden a cambiar de estado directamente en los componentes.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambas bibliotecas son geniales. </font><font style="vertical-align: inherit;">Aunque Redux ya está bien establecido, MobX se está convirtiendo en una alternativa viable a la gestión estatal.</font></font></blockquote><br>
<a name="more-resurces"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Más recursos</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comparación de Michel Weststratt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - creador de </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MobX</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es489840/index.html">Drive Anatomy: Discos duros</a></li>
<li><a href="../es489844/index.html">Análisis comparativo de algunos descompiladores de Java.</a></li>
<li><a href="../es489848/index.html">¿Por qué mis colegas / empleados se comportan como @% §?</a></li>
<li><a href="../es489850/index.html">Semana de la seguridad 09: ¿quién es responsable de la seguridad de Android?</a></li>
<li><a href="../es489852/index.html">Autenticación transparente en ASP.Net Core en Linux</a></li>
<li><a href="../es489856/index.html">La paradoja inversa de Banach-Tarski o cómo reducir el volumen de datos almacenados cinco veces</a></li>
<li><a href="../es489858/index.html">Internacionalización: hacer que la web sea accesible para todos</a></li>
<li><a href="../es489860/index.html">La historia de Telefunken: el fénix de la electrónica alemana desde Wilhelm II y Goebbels hasta los Beatles y hoy</a></li>
<li><a href="../es489862/index.html">Planificación en Go: Parte II - El programador de Go</a></li>
<li><a href="../es489868/index.html">Congelar cosas web de Mozilla</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>