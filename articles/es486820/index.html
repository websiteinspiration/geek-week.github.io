<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ€„ï¸ ğŸ›ï¸ ğŸ¤¶ğŸ½ 70 preguntas de la entrevista de Javascript ğŸ‘¨â€âš–ï¸ ğŸ‘©ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ¾ ğŸ¥™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Â¡Buen dia amigos! 
 
 Espero que este artÃ­culo sea Ãºtil tanto para desarrolladores novatos como para experimentados. 
 
 En preguntas que me pareciero...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>70 preguntas de la entrevista de Javascript</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486820/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Â¡Buen dia amigos! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que este artÃ­culo sea Ãºtil tanto para desarrolladores novatos como para experimentados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En preguntas que me parecieron mÃ¡s difÃ­ciles que otras, se dan referencias a literatura adicional. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AgradecerÃ­a los comentarios detallados. </font><font style="vertical-align: inherit;">Todos los comentarios se tendrÃ¡n en cuenta al editar el artÃ­culo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces vamos.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70 preguntas de la entrevista de Javascript</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Preguntas: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Â¿CuÃ¡l es la diferencia entre nulo e indefinido? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Â¿Para quÃ© se utiliza el operador &amp;&amp;? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Â¿Para quÃ© se utiliza el operador "||"? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Â¿Usar el unario mÃ¡s (operador +) es la forma mÃ¡s rÃ¡pida de convertir una cadena en un nÃºmero? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Â¿QuÃ© es un DOM? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Â¿QuÃ© es la propagaciÃ³n de eventos? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Â¿QuÃ© es el burbujeo de eventos? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Â¿QuÃ© es la captura de eventos? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. Â¿CuÃ¡l es la diferencia entre los mÃ©todos event.preventDefault () y event.stopPropagation ()? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. Â¿CÃ³mo aprender a usar el mÃ©todo event.preventDefault ()? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. Â¿Por quÃ© obj.someprop.x produce un error? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12. Â¿QuÃ© es un objetivo de evento o elemento de destino (event.target)?</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">13.      (event.currentTarget)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">14.      "=="  "==="?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">15.        false?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">16.     "!!"?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">17.       ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">18.    (Hoisting)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">19.     (Scope)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">20.    (Closures)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">21.    JS  ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">22.  ,    ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">23.     Â«use strictÂ»?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">24.    this?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">25.    ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">26.   IIFE?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">27.     Function.prototype.apply?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">28.     Function.prototype.call?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">29.      call  apply?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">30.     Function.prototype.bind?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">31.        JS         ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">32.      (Higher Order Functions)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">33.    JS     (First-class Objects)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">34.      Array.prototype.map?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">35.      Array.prototype.filter?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">36.      Array.prototype.reduce?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">37.    arguments?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">38.   ,   ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">39.      b     ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">40.   ECMAScript?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">41.     JS  ES6  ECMAScript2015?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">42.       Â«varÂ», Â«letÂ»  Â«constÂ»?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">43.     (Arrow Functions)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">44.    (Classes)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">45.     (Template Literals)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">46.     (Object Destructuring)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">47.    (Modules)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">48.    Set?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">49.      (Callback Function)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">50.    (Promises)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">51.   async/await?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">52.     spread-  rest-?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">53.      (Default Parameters)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">54.     (Wrapper Objects)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">55.             (Implicit and Explicit Coercion)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">56.   NaN?  ,    NaN?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">57.  ,    ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">58.  ,    ,          ( "%")?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">59.      ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">60.   AJAX?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">61.   JS  ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">62.      Object.freeze  Object.seal?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">63.      Â«inÂ»   hasOwnProperty?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64. Â¿QuÃ© tÃ©cnicas de trabajo con cÃ³digo asincrÃ³nico en JS conoces? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65. Â¿CuÃ¡l es la diferencia entre una funciÃ³n normal y una expresiÃ³n funcional? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">66. Â¿CÃ³mo llamar a una funciÃ³n en JS? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">67. Â¿QuÃ© es memorizaciÃ³n o memorizaciÃ³n? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68. Â¿CÃ³mo implementarÃ­a la funciÃ³n auxiliar de memorizaciÃ³n? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69. Â¿Por quÃ© typeof null devuelve objeto? </font><font style="vertical-align: inherit;">Â¿CÃ³mo verificar si un valor es nulo? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70. Â¿Para quÃ© se utiliza la palabra clave "nueva"?</font></font></a><br>
<br>
<a name="1"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Â¿CuÃ¡l es la diferencia entre nulo e indefinido?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comenzar, hablemos de lo que tienen en comÃºn. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, pertenecen a 7 "primitivas" JS (tipos primitivos):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> primitiveTypes = [<span class="hljs-string">'string'</span>, <span class="hljs-string">'number'</span>, <span class="hljs-string">'null'</span>, <span class="hljs-string">'undefined'</span>, <span class="hljs-string">'boolean'</span>, <span class="hljs-string">'symbol'</span>, <span class="hljs-string">'bigint'</span>]
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En segundo lugar, son valores falsos, es decir. </font><font style="vertical-align: inherit;">el resultado de convertirlos a booleanos usando Boolean () o el operador "!!" </font><font style="vertical-align: inherit;">Es falso:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien, ahora sobre las diferencias. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
undefined es el valor predeterminado:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una variable a la que no se le ha asignado ningÃºn valor, es decir </font><font style="vertical-align: inherit;">una variable declarada pero no inicializada;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una funciÃ³n que no devuelve nada explÃ­citamente, por ejemplo, console.log (1);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propiedad inexistente del objeto.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En estos casos, el motor JS establece el valor en indefinido.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> _thisIsUndefined
<span class="hljs-keyword">const</span> doNothing = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}
<span class="hljs-keyword">const</span> someObj = {
    <span class="hljs-attr">a</span>: <span class="hljs-string">'ay'</span>,
    <span class="hljs-attr">b</span>: <span class="hljs-string">'bee'</span>,
    <span class="hljs-attr">c</span>: <span class="hljs-string">'si'</span><font></font>
}<font></font>
<span class="hljs-built_in">console</span>.log(_thisIsUndefined) <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(doNothing()) <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(someObj[<span class="hljs-string">'d'</span>]) <span class="hljs-comment">// undefined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nulo es el "valor sin valor". </font><font style="vertical-align: inherit;">nulo es el valor que se asigna a la variable explÃ­citamente. </font><font style="vertical-align: inherit;">En el siguiente ejemplo, obtenemos nulo cuando el mÃ©todo fs.readFile funciona sin errores:</font></font><br>
<br>
<pre><code class="javascript hljs">fs.readFile(<span class="hljs-string">'path/to/file'</span>, (e, data) =&gt; {
    <span class="hljs-built_in">console</span>.log(e) <span class="hljs-comment">//    null</span>
<span class="hljs-keyword">if</span>(e) {
    <span class="hljs-built_in">console</span>.log(e)<font></font>
}<font></font>
    <span class="hljs-built_in">console</span>.log(data)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al comparar nulo e indefinido, obtenemos verdadero cuando se usa el operador "==", y falso cuando se usa el operador "===". </font><font style="vertical-align: inherit;">Sobre por quÃ© sucede esto, ver mÃ¡s abajo.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span>
</code></pre><br>
<a name="2"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Â¿Para quÃ© se utiliza el operador &amp;&amp;?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El operador &amp;&amp; (lÃ³gico y) encuentra y devuelve el primer valor falso o el Ãºltimo operando cuando todos los valores son verdaderos. </font><font style="vertical-align: inherit;">Utiliza un cortocircuito para evitar costos innecesarios:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-number">1</span> &amp;&amp; []) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">' '</span> &amp;&amp; <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-number">5</span>) <span class="hljs-comment">// 5</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con la declaraciÃ³n if:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> router: Router = Router()<font></font>
<font></font>
router.get(<span class="hljs-string">'/endpoint'</span>, (req: Request, <span class="hljs-attr">res</span>: Response) =&gt; {
    <span class="hljs-keyword">let</span> conMobile: PoolConnection
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">//    </span>
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">if</span> (conMobile) {<font></font>
            conMobile.release()<font></font>
        }<font></font>
    }<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo mismo con el operador &amp;&amp;:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> router: Router = Router()<font></font>
<font></font>
router.get(<span class="hljs-string">'/endpoint'</span>, (req: Request, <span class="hljs-attr">res</span>: Response) =&gt; {
    <span class="hljs-keyword">let</span> conMobile: PoolConnection
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">//    </span>
    } <span class="hljs-keyword">catch</span> (e) {<font></font>
        conMobile &amp;&amp; conMobile.release()<font></font>
    }<font></font>
})<font></font>
</code></pre><br>
<a name="3"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Â¿Para quÃ© se utiliza el operador "||"?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El operador "||" </font><font style="vertical-align: inherit;">(boolean o) encuentra y devuelve el primer valor verdadero. </font><font style="vertical-align: inherit;">TambiÃ©n usa un cortocircuito. </font><font style="vertical-align: inherit;">Este operador se usÃ³ para asignar parÃ¡metros predeterminados en funciones antes de que los parÃ¡metros predeterminados se estandarizaran en ES6.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> || <span class="hljs-number">1</span> || <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// 1</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logName</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">let</span> n = name || Mark
    <span class="hljs-built_in">console</span>.log(n)<font></font>
}<font></font>
<font></font>
logName() <span class="hljs-comment">// Mark</span>
</code></pre><br>
<a name="4"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Â¿Usar el unario mÃ¡s (operador +) es la forma mÃ¡s rÃ¡pida de convertir una cadena en un nÃºmero?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SegÃºn </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , el operador + es de hecho la forma mÃ¡s rÃ¡pida de convertir una cadena en un nÃºmero, ya que no realiza ninguna operaciÃ³n en un valor que es un nÃºmero.</font></font><br>
<br>
<a name="5"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Â¿QuÃ© es un DOM?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El DOM o Document Object Model es una interfaz de programaciÃ³n de aplicaciones (API) para trabajar con documentos HTML y XML. </font><font style="vertical-align: inherit;">Cuando el navegador lee por primera vez ("analiza") el documento HTML, forma un objeto grande, un objeto realmente grande basado en el documento: el DOM. </font><font style="vertical-align: inherit;">El DOM es una estructura de Ã¡rbol (Ã¡rbol de documentos). </font><font style="vertical-align: inherit;">El DOM se usa para interactuar y cambiar la estructura del propio DOM o de sus elementos y nodos individuales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que tenemos este HTML:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"ie=edge"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document Object Model<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El DOM de este HTML tiene este aspecto: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ax/cg/id/axcgidsa8fghreeuyvbhfpga6yo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
en JS, el DOM estÃ¡ representado por un objeto Document. </font><font style="vertical-align: inherit;">El objeto Documento tiene una gran cantidad de mÃ©todos para trabajar con elementos, su creaciÃ³n, modificaciÃ³n, eliminaciÃ³n, etc.</font></font><br>
<br>
<a name="6"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Â¿QuÃ© es la propagaciÃ³n de eventos?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando ocurre un evento en un elemento DOM, en realidad ocurre no solo en Ã©l. </font><font style="vertical-align: inherit;">El evento "se propaga" desde el objeto Window al elemento que lo llamÃ³ (event.target). </font><font style="vertical-align: inherit;">En este caso, el evento impregna (afecta) secuencialmente a todos los antepasados â€‹â€‹del elemento objetivo. </font><font style="vertical-align: inherit;">La propagaciÃ³n de un evento tiene tres etapas o fases:</font></font><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fase de inmersiÃ³n (captura, intercepciÃ³n): se produce un evento en el objeto Ventana y desciende al objetivo del evento a travÃ©s de todos sus antepasados.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fase objetivo es cuando el evento alcanza el elemento objetivo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fase ascendente: un evento se eleva desde event.target, pasa secuencialmente a travÃ©s de todos sus antepasados â€‹â€‹y llega al objeto Window.</font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/a3/9x/67/a39x67wkxdmcyzj-it5m2jmfxgg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lea mÃ¡s sobre la distribuciÃ³n de eventos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquÃ­</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquÃ­</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="7"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Â¿QuÃ© es una ventana emergente de evento?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando ocurre un evento en un elemento DOM, afecta no solo a este elemento. </font><font style="vertical-align: inherit;">Un evento "emerge" (como una burbuja de aire en el agua), pasa del elemento que causÃ³ el evento (event.target) a su padre, luego se eleva aÃºn mÃ¡s, al padre del padre del elemento, hasta que alcanza el objeto Window. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que tenemos este marcado:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grandparent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y tal JS:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEvent</span>(<span class="hljs-params">el, event, callback, isCapture = false</span>) </span>{
    <span class="hljs-keyword">if</span> (!el || !event || !callback || <span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">return</span><font></font>
<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> el === <span class="hljs-string">'string'</span>) {<font></font>
        el = <span class="hljs-built_in">document</span>.querySelector(el)<font></font>
    }<font></font>
    el.addEventListener(event, callback, isCapture)<font></font>
}<font></font>
<font></font>
addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'DOMContentLoaded'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.child'</span>)
    <span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.parent'</span>)
    <span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.grandparent'</span>)<font></font>
<font></font>
    addEvent(child, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(parent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(grandparent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'grandparent'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(<span class="hljs-string">'html'</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'html'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'document'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">window</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'window'</span>)<font></font>
    })<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mÃ©todo addEventListener tiene un tercer parÃ¡metro opcional: useCapture. </font><font style="vertical-align: inherit;">Cuando su valor es falso (el valor predeterminado), el evento comienza con la fase de ascenso. </font><font style="vertical-align: inherit;">Cuando su valor es verdadero, el evento comienza con la fase de inmersiÃ³n (para los "oyentes" de los eventos adjuntos al objetivo del evento, el evento estÃ¡ en la fase objetivo, y no en las fases de inmersiÃ³n o ascenso. Los eventos en la fase objetivo son activados por todos los oyentes en el elemento en el en el que se registraron independientemente del parÃ¡metro useCapture - aprox. </font><font style="vertical-align: inherit;">Si hacemos clic en el elemento hijo, la consola mostrarÃ¡: hijo, padre, abuelo, html, documento, ventana. </font><font style="vertical-align: inherit;">Esto es lo que es una ventana emergente de evento.</font></font><br>
<br>
<a name="8"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Â¿QuÃ© es un evento de inmersiÃ³n?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando un evento ocurre en un elemento DOM, ocurre no solo en Ã©l. </font><font style="vertical-align: inherit;">En la fase de inmersiÃ³n, el evento desciende del objeto Ventana al objetivo del evento a travÃ©s de todos sus antepasados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Margen:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grandparent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JS:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEvent</span>(<span class="hljs-params">el, event, callback, isCapture = false</span>) </span>{
    <span class="hljs-keyword">if</span> (!el || !event || !callback || <span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">return</span><font></font>
<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> el === <span class="hljs-string">'string'</span>) {<font></font>
        el = <span class="hljs-built_in">document</span>.querySelector(el);<font></font>
    }<font></font>
    el.addEventListener(event, callback, isCapture)<font></font>
}<font></font>
<font></font>
addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'DOMContentLoaded'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.child'</span>)
    <span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.parent'</span>)
    <span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.grandparent'</span>)<font></font>
<font></font>
    addEvent(child, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child'</span>);<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(parent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(grandparent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'grandparent'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(<span class="hljs-string">'html'</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'html'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'document'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">window</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'window'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mÃ©todo addEventListener tiene un tercer parÃ¡metro opcional: useCapture. </font><font style="vertical-align: inherit;">Cuando su valor es falso (el valor predeterminado), el evento comienza con la fase de ascenso. </font><font style="vertical-align: inherit;">Cuando su valor es verdadero, el evento comienza con la fase de inmersiÃ³n. </font><font style="vertical-align: inherit;">Si hacemos clic en el elemento hijo, veremos lo siguiente en la consola: ventana, documento, html, abuelo, padre, hijo. </font><font style="vertical-align: inherit;">Esta es la inmersiÃ³n del evento.</font></font><br>
<br>
<a name="9"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. Â¿CuÃ¡l es la diferencia entre los mÃ©todos event.preventDefault () y event.stopPropagation ()?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mÃ©todo event.preventDefault () deshabilita el comportamiento predeterminado de un elemento. </font><font style="vertical-align: inherit;">Si usa este mÃ©todo en el elemento de formulario, evitarÃ¡ que el formulario se envÃ­e. </font><font style="vertical-align: inherit;">Si lo usa en el menÃº contextual, el menÃº contextual se deshabilitarÃ¡ (este mÃ©todo se usa a menudo en el teclado para redefinir el teclado, por ejemplo, al crear un reproductor de mÃºsica / video o editor de texto - aprox. </font><font style="vertical-align: inherit;">El mÃ©todo event.stopPropagation () deshabilita la propagaciÃ³n del evento (su ascenso o inmersiÃ³n).</font></font><br>
<br>
<a name="10"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. Â¿CÃ³mo aprender a usar el mÃ©todo event.preventDefault ()?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para hacer esto, podemos usar la propiedad event.defaulPrevented, que devuelve un valor booleano que sirve como indicador de aplicaciÃ³n al elemento del mÃ©todo event.preventDefault.</font></font><br>
<br>
<a name="11"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. Â¿Por quÃ© obj.someprop.x produce un error?</font></font></h4><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj = {}
<span class="hljs-built_in">console</span>.log(obj.someprop.x)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La respuesta es obvia: estamos intentando acceder a la propiedad x de la propiedad someprop, que no estÃ¡ definida. </font><font style="vertical-align: inherit;">obj .__ proto __.__ proto = nulo, por lo que se devuelve undefined y undefined no tiene la propiedad x.</font></font><br>
<br>
<a name="12"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12. Â¿QuÃ© es un objetivo de evento o elemento de destino (event.target)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En palabras simples, event.target es el elemento en el que ocurre el evento, o el elemento que provocÃ³ el evento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos el siguiente marcado:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"clickFunc(event)"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align: center; margin: 15px;
border: 1px solid red; border-radius: 3px;"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 25px; border: 1px solid royalblue; border-radius: 3px;"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 25px; border: 1px solid skyblue; border-radius: 3px;"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 10px"</span>&gt;</span><font></font>
                Button<font></font>
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y un JS tan simple:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickFunc</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-built_in">console</span>.log(event.target)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adjuntamos un "oyente" al div externo. </font><font style="vertical-align: inherit;">Sin embargo, si hacemos clic en el botÃ³n, obtenemos el diseÃ±o de este botÃ³n en la consola. </font><font style="vertical-align: inherit;">Esto nos permite concluir que el elemento que causÃ³ el evento es el botÃ³n en sÃ­, y no los divs internos o externos.</font></font><br>
<br>
<a name="13"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13. Â¿CuÃ¡l es el propÃ³sito actual del evento (event.currentTarget)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Event.currentTarget es el elemento al que estÃ¡ conectado el detector de eventos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Marcado similar:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"clickFunc(event)"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align: center;margin:15px;
border:1px solid red;border-radius:3px;"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 25px; border:1px solid royalblue;border-radius:3px;"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin:25px;border:1px solid skyblue;border-radius:3px;"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin:10px"</span>&gt;</span><font></font>
                Button<font></font>
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y un JS ligeramente modificado:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickFunc</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-built_in">console</span>.log(event.currentTarget)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adjuntamos al oyente al div externo. </font><font style="vertical-align: inherit;">Dondequiera que hagamos clic, ya sea un botÃ³n o uno de los div internos, en la consola siempre obtenemos el diseÃ±o del div externo. </font><font style="vertical-align: inherit;">Esto nos permite concluir que event.currentTarget es el elemento al que estÃ¡ conectado el detector de eventos.</font></font><br>
<br>
<a name="14"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14. Â¿CuÃ¡l es la diferencia entre los operadores "==" y "==="?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diferencia entre el operador == (igualdad abstracta o no estricta) y el operador === (igualdad estricta) es que el primero compara los valores despuÃ©s de que se convierten o se convierten a un tipo (Coersion), y el segundo, sin dicha conversiÃ³n . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos a cavar mÃ¡s profundo. </font><font style="vertical-align: inherit;">Y primero, hablemos de la transformaciÃ³n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una conversiÃ³n es un proceso de convertir un valor a otro tipo, o mÃ¡s bien, un proceso de convertir los valores comparados a un tipo. </font><font style="vertical-align: inherit;">Al comparar, el operador "==" produce la llamada comparaciÃ³n implÃ­cita. </font><font style="vertical-align: inherit;">El operador "==" realiza algunas operaciones antes de comparar dos valores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que comparamos x e y. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El algoritmo es como sigue:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si x e y son del mismo tipo, la comparaciÃ³n se realiza utilizando el operador "===".</font></font></li>
<li> x = null  y = undefined  true.</li>
<li> x = undefined  y = null  true.</li>
<li> x = ,  y = ,  x == toNumber(y) ( y   ).</li>
<li> x = ,  y = ,  toNumber(x) == y ( x   ).</li>
<li> x =  ,  toNumber(x) == y.</li>
<li> y =  ,  x == toNumber(y).</li>
<li> x = ,   ,  y = ,  x == toPrimitive(y) ( y   ).</li>
<li> x = ,  y = ,   ,  toPrimitive(x) == y.</li>
<li> false.</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recuerde: para convertir un objeto en un "primitivo", el mÃ©todo toPrimitive primero usa el mÃ©todo valueOf, luego el mÃ©todo toString. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ejemplos: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yd/xe/tn/ydxetnfghjtfuex_p-em8v4emck.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
todos los ejemplos devuelven verdadero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primer ejemplo es la primera condiciÃ³n del algoritmo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo ejemplo es la cuarta condiciÃ³n. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tercero es el segundo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El cuarto es el sÃ©ptimo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quinto - octavo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y el Ãºltimo es el dÃ©cimo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t-/4k/ys/t-4kyszb4grfafbi7lazyyvq6dy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si utilizamos el operador "===", todos los ejemplos, excepto el primero, devolverÃ¡n falso, ya que los valores en estos ejemplos son de diferentes tipos.</font></font><br>
<br>
<a name="15"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15. Â¿Por quÃ© el resultado de comparar dos objetos similares es falso?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> a = {
    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><font></font>
}<font></font>
<span class="hljs-keyword">let</span> b = {
    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><font></font>
}<font></font>
<span class="hljs-keyword">let</span> c = a<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(a === b) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(a === c) <span class="hljs-comment">// true ...</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En JS, los objetos y las primitivas se comparan de manera diferente. </font><font style="vertical-align: inherit;">Las primitivas se comparan por valor. </font><font style="vertical-align: inherit;">Objetos: por referencia o direcciÃ³n en la memoria donde se almacena la variable. </font><font style="vertical-align: inherit;">Es por eso que el primer console.log devuelve falso y el segundo devuelve verdadero. </font><font style="vertical-align: inherit;">Las variables "a" y "c" se refieren al mismo objeto, mientras que las variables "a" y "b" se refieren a diferentes objetos con las mismas propiedades y valores.</font></font><br>
<br>
<a name="16"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16. Â¿Para quÃ© se usa el operador "!!"?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El operador "!!" </font><font style="vertical-align: inherit;">(doble negaciÃ³n) lleva el valor a su derecho a un valor lÃ³gico.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-string">''</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-number">0</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-string">' '</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!!{}) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!![]) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!![].length) <span class="hljs-comment">// false</span>
</code></pre><br>
<a name="17"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17. Â¿CÃ³mo escribir mÃºltiples expresiones en una lÃ­nea?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para esto podemos usar el operador "," (coma). </font><font style="vertical-align: inherit;">Este operador "se mueve" de izquierda a derecha y devuelve el valor de la Ãºltima expresiÃ³n u operando.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span><font></font>
<font></font>
x = (x++, x = addFive(x), x *= <span class="hljs-number">2</span>, x -= <span class="hljs-number">5</span>, x += <span class="hljs-number">10</span>)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addFive</span>(<span class="hljs-params">num</span>) </span>{
    <span class="hljs-keyword">return</span> num + <span class="hljs-number">5</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si imprimimos el valor de x en la consola, obtenemos 27. Primero, aumentamos el valor de x en uno (x = 6). </font><font style="vertical-align: inherit;">Luego llamamos a la funciÃ³n addFive () con el parÃ¡metro 6, al que agregamos 5 (x = 11). </font><font style="vertical-align: inherit;">DespuÃ©s de eso, multiplicamos el valor de x por 2 (x = 22). </font><font style="vertical-align: inherit;">Luego reste 5 (x = 17). </font><font style="vertical-align: inherit;">Y finalmente, suma 10 (x = 27).</font></font><br>
<br>
<a name="18"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18. Â¿QuÃ© es izar?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ElevaciÃ³n es un tÃ©rmino que describe el surgimiento de una variable o funciÃ³n en un Ã¡mbito global o funcional. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comprender quÃ© es la elevaciÃ³n, debe comprender cuÃ¡l es el contexto de ejecuciÃ³n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El contexto de ejecuciÃ³n es el entorno en el que se ejecuta el cÃ³digo. El contexto de ejecuciÃ³n tiene dos fases: compilaciÃ³n y ejecuciÃ³n en sÃ­. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compilacion. En esta fase, las expresiones funcionales y las variables declaradas usando la palabra clave "var" con el valor indefinido se elevan a la parte superior del alcance global (o funcional) (como si se moviera al comienzo de nuestro cÃ³digo. Esto explica por quÃ© podemos llamar a las funciones antes de que anuncios - aprox.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ActuaciÃ³n. </font><font style="vertical-align: inherit;">En esta fase, las variables son valores asignados, y las funciones (o mÃ©todos de objetos) se llaman o ejecutan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recuerde: solo se generan expresiones funcionales y variables declaradas con la palabra clave "var". </font><font style="vertical-align: inherit;">Las funciones ordinarias y las funciones de flecha, asÃ­ como las variables declaradas con las palabras clave "let" y "const", no se muestran. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que tenemos un cÃ³digo como este:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(y)<font></font>
y = <span class="hljs-number">1</span>
<span class="hljs-built_in">console</span>.log(y)
<span class="hljs-built_in">console</span>.log(greet(<span class="hljs-string">'Mark'</span>))<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> y
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos quedan indefinidos, 1 y 'Â¡Hola Mark!'. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AsÃ­ es como se ve la fase de compilaciÃ³n:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> y <span class="hljs-comment">//  undefined</span><font></font>
<font></font>
<span class="hljs-comment">//    </span><font></font>
<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-comment">/*
console.log(y)
y = 1
console.log(y)
console.log(greet('Mark'))
*/</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una vez completada la fase de compilaciÃ³n, la fase de ejecuciÃ³n comienza cuando se asignan valores a las variables y se llaman funciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede encontrar mÃ¡s informaciÃ³n sobre la elevaciÃ³n </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquÃ­</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="19"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19. Â¿QuÃ© es un alcance?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un Ã¡mbito es un lugar donde (o desde donde) tenemos acceso a variables o funciones. </font><font style="vertical-align: inherit;">JS tenemos tres tipos de Ã¡mbitos: global, funcional y de bloque (ES6). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alcance global: las variables y funciones declaradas en el espacio de nombres global tienen un alcance global y son accesibles desde cualquier parte del cÃ³digo.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> g = <span class="hljs-string">'global'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">globalFunc</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFunc</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(g) <span class="hljs-comment">//     g,    </span><font></font>
    }<font></font>
    innerFunc()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alcance funcional (alcance de una funciÃ³n): las variables, funciones y parÃ¡metros declarados dentro de una funciÃ³n solo estÃ¡n disponibles dentro de esta funciÃ³n.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFavouriteFunc</span>(<span class="hljs-params">a</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">var</span> b = <span class="hljs-string">'Hello '</span> + a<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> b<font></font>
}<font></font>
myFavouriteFunc(<span class="hljs-string">'World'</span>)<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// Uncaught ReferenceError: a is not defined</span>
<span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">//  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alcance del bloque: las variables (declaradas con las palabras clave "let" y "const") dentro del bloque ({}) solo estÃ¡n disponibles dentro de Ã©l.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testBlock</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">let</span> z = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> z<font></font>
}<font></font>
<font></font>
testBlock() <span class="hljs-comment">// Uncaught ReferenceError: z is not defined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un Ã¡mbito tambiÃ©n es un conjunto de reglas mediante el cual se busca una variable. </font><font style="vertical-align: inherit;">Si la variable no existe en el alcance actual, su bÃºsqueda se realiza mÃ¡s arriba en la visibilidad externa del alcance actual. </font><font style="vertical-align: inherit;">Si no hay una variable en el alcance externo, su bÃºsqueda continÃºa hasta el alcance global. </font><font style="vertical-align: inherit;">Si se encuentra una variable en el Ã¡mbito global, la bÃºsqueda se detiene; de â€‹â€‹lo contrario, se genera una excepciÃ³n. </font><font style="vertical-align: inherit;">La bÃºsqueda se lleva a cabo por las Ã¡reas de visibilidad mÃ¡s cercanas a las actuales y se detiene al encontrar la variable. </font><font style="vertical-align: inherit;">Esto se llama la cadena de alcance.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-comment">//    -&gt;    -&gt;   </span><font></font>
<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> variable1 = <span class="hljs-string">'Comrades'</span>
<span class="hljs-keyword">var</span> variable2 = <span class="hljs-string">'Sayonara'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">var</span> variable1 = <span class="hljs-string">'World'</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">//   </span>
        <span class="hljs-keyword">var</span> variable2 = <span class="hljs-string">'Hello'</span>
        <span class="hljs-built_in">console</span>.log(variable2 + <span class="hljs-string">' '</span> + variable1)<font></font>
    }<font></font>
    inner()<font></font>
}<font></font>
outer()<font></font>
<span class="hljs-comment">//    'Hello World',</span>
<span class="hljs-comment">//   variable2 = 'Hello'  variable1 = 'World'  </span>
<span class="hljs-comment">//     </span>
</code></pre><br>
<img src="https://habrastorage.org/webt/r6/07/q7/r607q7hehfjmuicf0_icntddk2s.png"><br>
<br>
<a name="20"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20. Â¿QuÃ© es un cierre (cierres)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es probablemente la pregunta mÃ¡s difÃ­cil de la lista. TratarÃ© de explicar cÃ³mo entiendo el cierre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, el cierre es la capacidad de una funciÃ³n para crear enlaces a variables y parÃ¡metros que estÃ¡n en el Ã¡mbito actual, en el Ã¡mbito de la funciÃ³n principal, en el Ã¡mbito del principal de la funciÃ³n principal, y asÃ­ sucesivamente en el Ã¡mbito global utilizando la cadena de Ã¡mbitos en el momento de la creaciÃ³n. Normalmente, el alcance se determina cuando se crea una funciÃ³n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los ejemplos son una excelente manera de explicar el cierre:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">'abc'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-built_in">console</span>.log(globalVar)<font></font>
}<font></font>
<font></font>
a() <span class="hljs-comment">// 'abc'</span>
<span class="hljs-comment">//   </span>
<span class="hljs-comment">//    a -&gt;   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, cuando declaramos una funciÃ³n, el alcance global es parte del cierre. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/10/ke/qa/10keqaosrww0rntbyei1gx9f_k0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La variable "globalVar" no importa en la imagen, porque su valor puede cambiar dependiendo de dÃ³nde y cuÃ¡ndo se llamarÃ¡ a la funciÃ³n. Pero en el ejemplo anterior, globalVar tendrÃ¡ el valor "abc". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora el ejemplo es mÃ¡s complicado:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">'global'</span>
<span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">'outer'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outerFunc</span>(<span class="hljs-params">outerParam</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFunc</span>(<span class="hljs-params">innerParam</span>) </span>{
        <span class="hljs-built_in">console</span>.log(globalVar, outerParam, innerParam)<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> innerFunc<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> x = outerFunc(outerVar)<font></font>
outerVar = <span class="hljs-string">'outer-2'</span>
globalVar = <span class="hljs-string">'guess'</span>
x(<span class="hljs-string">'inner'</span>)
</code></pre><br>
<img src="https://habrastorage.org/webt/ms/dv/wx/msdvwxdxp5s3l4cquxnqgkdtyr0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado es "adivinar exterior interior". La explicaciÃ³n es esta: cuando llamamos a la funciÃ³n externalFunc y establecemos la variable "x" en el valor devuelto por la funciÃ³n innerFunc, el parÃ¡metro "externalParam" es igual a "exterior". A pesar del hecho de que asignamos la variable "externalVar" a "external-2", esto sucediÃ³ despuÃ©s de llamar a la funciÃ³n externalFunc, que "logrÃ³" encontrar el valor de la variable "outsideVar" en la cadena de alcance, este valor fue "externo". Cuando llamamos a "x", que se refiere a innerFunc, el valor de "innerParam" es "interno", porque pasamos este valor como parÃ¡metro cuando llamamos a "x". globalVar tiene un valor de "adivinar" porque le asignamos ese valor antes de llamar a "x". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un ejemplo de un malentendido de un circuito.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> arrFunc = []
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {<font></font>
    arrFunc.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> i<font></font>
    })<font></font>
}<font></font>
<span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">// 5</span><font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arrFunc.length; i++) {
    <span class="hljs-built_in">console</span>.log(arrFunc[i]()) <span class="hljs-comment">//  5</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este cÃ³digo no funciona como se esperaba. </font><font style="vertical-align: inherit;">Declarar una variable usando la palabra clave var hace que esta variable sea global. </font><font style="vertical-align: inherit;">DespuÃ©s de agregar funciones a la matriz arrFunc, el valor de la variable global "i" se convierte en "5". </font><font style="vertical-align: inherit;">Por lo tanto, cuando llamamos a la funciÃ³n, devuelve el valor de la variable global "i". </font><font style="vertical-align: inherit;">Un cierre almacena una referencia a una variable, no su valor en el momento de la creaciÃ³n. </font><font style="vertical-align: inherit;">Este problema puede resolverse usando IIFE o declarando una variable usando la palabra clave "let". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lea mÃ¡s sobre el cierre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquÃ­</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquÃ­</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="21"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21. Â¿QuÃ© valores en JS son falsos?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> falsyValues = [<span class="hljs-string">''</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-literal">false</span>]
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Falso son valores cuya conversiÃ³n a un valor booleano es falsa.</font></font><br>
<br>
<a name="22"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22. Â¿CÃ³mo verificar si un valor es falso?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilice la funciÃ³n booleana o el operador "!!" </font><font style="vertical-align: inherit;">(dos veces no).</font></font><br>
<br>
<a name="23"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">23. Â¿Para quÃ© se usa la directiva estricta de uso?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Usar estricto" es una directiva ES5 que obliga a ejecutar todo nuestro cÃ³digo o el cÃ³digo de una funciÃ³n individual en modo estricto. </font><font style="vertical-align: inherit;">El modo estricto introduce algunas restricciones en la escritura de cÃ³digo, evitando asÃ­ errores en las primeras etapas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AquÃ­ estÃ¡n las limitaciones del modo estricto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No puede asignar valores ni acceder a variables no declaradas:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnY</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-string">'use strict'</span>
    y = <span class="hljs-number">123</span>
    <span class="hljs-keyword">return</span> y<font></font>
}<font></font>
returnY() <span class="hljs-comment">// Uncaught ReferenceError: y is not defined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EstÃ¡ prohibido asignar valores globales a variables de solo lectura o de solo escritura:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span>
<span class="hljs-keyword">var</span> <span class="hljs-literal">NaN</span> = <span class="hljs-literal">NaN</span> <span class="hljs-comment">// Uncaught TypeError: Cannot assign to read only property 'NaN' of object '#&lt;Window&gt;'</span>
<span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-keyword">var</span> <span class="hljs-literal">Infinity</span> = <span class="hljs-string">'and beyond'</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No puede eliminar la propiedad "indeleble" de un objeto:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span>
<span class="hljs-keyword">const</span> obj = {}<font></font>
<font></font>
<span class="hljs-built_in">Object</span>.defineProperties(obj, <span class="hljs-string">'x'</span>, {
    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><font></font>
})<font></font>
<font></font>
<span class="hljs-keyword">delete</span> obj.x <span class="hljs-comment">// Uncaught TypeError: Property description must be an object: x</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La duplicaciÃ³n de parÃ¡metros estÃ¡ prohibida:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someFunc</span>(<span class="hljs-params">a, b, b, c</span>) </span>{} <span class="hljs-comment">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No puede crear funciones con la funciÃ³n eval:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span><font></font>
<font></font>
<span class="hljs-built_in">eval</span>(<span class="hljs-string">'var x = 1'</span>)<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(x) <span class="hljs-comment">// Uncaught ReferenceError: x is not defined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El valor predeterminado para esto no estÃ¡ definido:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMeThis</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><font></font>
}<font></font>
<font></font>
showMeThis() <span class="hljs-comment">// undefined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... etc.</font></font><br>
<br>
<a name="24"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24. Â¿QuÃ© significa esto?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto generalmente se refiere al valor del objeto que actualmente estÃ¡ ejecutando o llamando a la funciÃ³n. </font><font style="vertical-align: inherit;">"En este momento" significa que el valor de esto varÃ­a segÃºn el contexto de ejecuciÃ³n, donde usamos esto.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> carDetails = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Ford Mustang'</span>,
    <span class="hljs-attr">yearBought</span>: <span class="hljs-number">2005</span>,<font></font>
    getName() {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name<font></font>
    }<font></font>
    <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">true</span><font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(carDetails.getName()) <span class="hljs-comment">// Ford Mustang</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, el mÃ©todo getName devuelve this.name, y esto se refiere a carDetails, el objeto en el que se ejecuta getName, que es su "propietario". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregue tres lÃ­neas despuÃ©s de console.log:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'Ford Ranger'</span>
<span class="hljs-keyword">var</span> getCarName = carDetails.getName<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(getCarName()) <span class="hljs-comment">// Ford Ranger</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo console.log produce un Ford Ranger, y esto es extraÃ±o. </font><font style="vertical-align: inherit;">La razÃ³n de este comportamiento es que el "propietario" de getCarName es el objeto de la ventana. </font><font style="vertical-align: inherit;">Las variables declaradas con la palabra clave var en el Ã¡mbito global se escriben en las propiedades del objeto de ventana. </font><font style="vertical-align: inherit;">esto en el Ã¡mbito global se refiere al objeto de la ventana (a menos que sea un modo estricto).</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(getCarName === <span class="hljs-built_in">window</span>.getCarName) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(getCarName === <span class="hljs-keyword">this</span>.getCarName) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, this y window se refieren al mismo objeto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una forma de resolver este problema es usar la llamada o aplicar mÃ©todos:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(getCarName.apply(carDetails)) <span class="hljs-comment">// Ford Mustang</span>
<span class="hljs-built_in">console</span>.log(getCarName.call(carDetails)) <span class="hljs-comment">// Ford Mustang</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Llame y aplique tomar como primer argumento un objeto que serÃ¡ el valor de esto dentro de la funciÃ³n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En IIFE, funciones que se crean en el Ã¡mbito global, funciones anÃ³nimas y funciones internas de los mÃ©todos de un objeto, el valor predeterminado para esto es el objeto de ventana.</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)<font></font>
})() <span class="hljs-comment">// window</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iHateThis</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)<font></font>
}<font></font>
iHateThis() <span class="hljs-comment">// window</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> myFavouriteObj = {<font></font>
    guessThis() {<font></font>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<font></font>
        }<font></font>
        getName()<font></font>
    },<font></font>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span>,<font></font>
    thisIsAnnoying(callback) {<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
<font></font>
myFavouriteObj.guessThis() <span class="hljs-comment">// window</span>
myFavouriteObj.thisIsAnnoying(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// window</span><font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay dos formas de obtener Marko Polo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, podemos almacenar el valor de esto en una variable:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myFavoriteObj = {<font></font>
    guessThis() {<font></font>
        <span class="hljs-keyword">const</span> self = <span class="hljs-keyword">this</span> <span class="hljs-comment">//   this   self</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(self.name)<font></font>
        }<font></font>
        getName()<font></font>
    },<font></font>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span>,<font></font>
    thisIsAnnoying(callback) {<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En segundo lugar, podemos usar la funciÃ³n de flecha:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myFavoriteObj = {<font></font>
    guessThis() {<font></font>
        <span class="hljs-keyword">const</span> getName = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            <span class="hljs-comment">//   this   </span>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<font></font>
        }<font></font>
        getName()<font></font>
    },<font></font>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span>,<font></font>
    thisIsAnnoying(callback) {<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las funciones de flecha no tienen este valor propio. </font><font style="vertical-align: inherit;">Copian el significado de esto del entorno lÃ©xico externo.</font></font><br>
<br>
<a name="25"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25. Â¿QuÃ© es un prototipo de un objeto?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En pocas palabras, un prototipo es un plan (diagrama o proyecto) de un objeto. </font><font style="vertical-align: inherit;">Se utiliza como reserva para las propiedades y mÃ©todos existentes en este objeto. </font><font style="vertical-align: inherit;">TambiÃ©n es una de las formas de intercambiar propiedades y funcionalidades entre objetos. </font><font style="vertical-align: inherit;">Este es el concepto bÃ¡sico de herencia prototipo en JS.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o = {}
<span class="hljs-built_in">console</span>.log(o.toString()) <span class="hljs-comment">// [object Object]</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aunque el objeto "o" no tiene la propiedad toString, acceder a esta propiedad no causa un error. </font><font style="vertical-align: inherit;">Si una propiedad especÃ­fica no estÃ¡ en el objeto, su bÃºsqueda se lleva a cabo primero en el prototipo del objeto, luego en el prototipo del prototipo del objeto, y asÃ­ sucesivamente hasta que se encuentre la propiedad. </font><font style="vertical-align: inherit;">Esto se llama la cadena prototipo. </font><font style="vertical-align: inherit;">En la parte superior de la cadena de prototipos se encuentra Object.prototype.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(o.toString === <span class="hljs-built_in">Object</span>.prototype.toString) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lea mÃ¡s sobre prototipos y herencia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquÃ­</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquÃ­</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="26"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26. Â¿QuÃ© es el IIFE?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IIFE o ExpresiÃ³n de funciÃ³n invocada inmediatamente es una funciÃ³n que se llama o ejecuta inmediatamente despuÃ©s de la creaciÃ³n o declaraciÃ³n. </font><font style="vertical-align: inherit;">Para crear IIFE, debe ajustar la funciÃ³n entre parÃ©ntesis (el operador de agrupaciÃ³n), convertirla en una expresiÃ³n y luego llamarla usando otros parÃ©ntesis. </font><font style="vertical-align: inherit;">Se ve asÃ­: (function () {}) ().</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> </span>) </span>{ }( ))<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> </span>) </span>{ })( )<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">named</span>(<span class="hljs-params">params</span>) </span>{ })( )<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-params">( )</span> =&gt;</span> { })<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">global</span>) </span>{ })(<span class="hljs-built_in">window</span>)<font></font>
<font></font>
<span class="hljs-keyword">const</span> utility = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> </span>) </span>{
    <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">// </span><font></font>
    }<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos estos ejemplos son vÃ¡lidos. </font><font style="vertical-align: inherit;">El penÃºltimo ejemplo muestra que podemos pasar parÃ¡metros a IIFE. </font><font style="vertical-align: inherit;">El Ãºltimo ejemplo muestra que podemos almacenar el resultado de IIFE en una variable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mejor uso de IIFE es realizar funciones de configuraciÃ³n de inicializaciÃ³n y evitar conflictos de nombres con otras variables en el Ã¡mbito global (contaminaciÃ³n del espacio de nombres global). </font><font style="vertical-align: inherit;">Damos un ejemplo.</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script src=<span class="hljs-string">"https://cdnurl.com/somelibrary.js"</span>&gt;&lt;/script&gt;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos un enlace a la biblioteca somelibrary.js que proporciona algunas funciones globales que podemos usar en nuestro cÃ³digo, pero hay dos mÃ©todos en esta biblioteca, createGraph y drawGraph, que no usamos porque contienen errores. </font><font style="vertical-align: inherit;">Y queremos implementar estas funciones por nuestra cuenta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una forma de resolver este problema es cambiar la estructura de nuestros scripts:</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script src=<span class="hljs-string">"https://cdnurl.com/somelibrary.js"</span>&gt;&lt;/script&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, redefinimos los mÃ©todos proporcionados por la biblioteca. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La segunda forma es cambiar los nombres de nuestras funciones:</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script src=<span class="hljs-string">"https://cdnurl.com/somelibrary.js"</span>&gt;&lt;/script&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCreateGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myDrawGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tercera forma es usar IIFE:</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script&gt;
    <span class="hljs-keyword">const</span> graphUtility = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createGraph</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">// </span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawGraph</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">// </span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> {<font></font>
            createGraph,<font></font>
            drawGraph<font></font>
        }<font></font>
    })<font></font>
&lt;/script&gt;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, creamos una variable de utilidad que contiene el resultado IIFE, que devuelve un objeto que contiene los mÃ©todos createGraph y drawGraph. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AquÃ­ hay otro problema que se puede resolver con IIFE:</font></font><br>
<br>
<pre><code class="javascript hljs">val li = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.list-group &gt; li'</span>)
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i - <span class="hljs-number">0</span>, len = li.length; i &lt; len; i++) {<font></font>
    li[i].addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(i)<font></font>
    })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que tenemos un elemento ul con una clase de grupo de lista que contiene 5 elementos secundarios li. </font><font style="vertical-align: inherit;">Y queremos mostrar el valor "i" en la consola al hacer clic en un "li" separado. </font><font style="vertical-align: inherit;">Sin embargo, en cambio, la consola siempre muestra 5. La falla es toda la culpa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una soluciÃ³n es IIFE:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.list-group &gt; li'</span>)
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = li.length; i &lt; len; i++) {<font></font>
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentIndex</span>) </span>{<font></font>
        li[currentIndex].addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
            <span class="hljs-built_in">console</span>.log(currentIndex)<font></font>
        })<font></font>
    })(i)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La razÃ³n por la que este cÃ³digo funciona segÃºn lo previsto es porque IIFE crea un nuevo alcance en cada iteraciÃ³n, y escribimos el valor "i" en currentIndex.</font></font><br>
<br>
<a name="27"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">27. Â¿Para quÃ© se utiliza el mÃ©todo Function.prototype.apply?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aplicar se utiliza para vincular un objeto especÃ­fico al valor de este de la funciÃ³n llamada.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> details = {
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello World!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMessage</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.message<font></font>
}<font></font>
<font></font>
getMessage.apply(details) <span class="hljs-comment">// Hello World!</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este mÃ©todo es similar a Function.prototype.call. </font><font style="vertical-align: inherit;">La Ãºnica diferencia es que en apply, los argumentos se pasan como una matriz.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> person = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeting</span>(<span class="hljs-params">greetingMessage</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${greetingMessage}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
}<font></font>
<font></font>
greeting.apply(person, [<span class="hljs-string">'Hello'</span>]) <span class="hljs-comment">// Hello Marko Polo</span>
</code></pre><br>
<a name="28"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28. Â¿Para quÃ© se utiliza el mÃ©todo function.prototype.call?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La llamada se utiliza para vincular un objeto especÃ­fico al valor de esta funciÃ³n que se llama.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> details = {
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello World!'</span><font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMessage</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.message;<font></font>
}<font></font>
<font></font>
getMessage.call(details); <span class="hljs-comment">// Hello World!</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este mÃ©todo es similar a Function.prototype.apply. </font><font style="vertical-align: inherit;">La diferencia es que en la llamada los argumentos se pasan separados por comas.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> person = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span><font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeting</span>(<span class="hljs-params">greetingMessage</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${greetingMessage}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span>;<font></font>
}<font></font>
<font></font>
greeting.call(person, <span class="hljs-string">'Hello'</span>); <span class="hljs-comment">// Hello Marko Polo</span>
</code></pre><br>
<a name="29"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">29. Â¿CuÃ¡l es la diferencia entre llamar y aplicar mÃ©todos?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diferencia entre llamar y aplicar es cÃ³mo pasamos argumentos en la funciÃ³n llamada. </font><font style="vertical-align: inherit;">En apply, los argumentos se pasan como una matriz, en llamada, separados por comas.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj1 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> obj2 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduceAdd</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) {<font></font>
        result += <span class="hljs-built_in">arguments</span>[i]<font></font>
    }<font></font>
    <span class="hljs-keyword">this</span>.result = result<font></font>
}<font></font>
<font></font>
reduceAdd.apply(obj1, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]) <span class="hljs-comment">// 15</span>
reduceAdd.call(obj2, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 15</span>
</code></pre><br>
<a name="30"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30. Â¿Para quÃ© se utiliza el mÃ©todo function.prototype.bind?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bind devuelve una nueva funciÃ³n cuyo valor es el objeto especificado como primer parÃ¡metro. </font><font style="vertical-align: inherit;">A diferencia de bind, call y apply llama inmediatamente a la funciÃ³n.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props)
        <span class="hljs-keyword">this</span>.state = {
            <span class="hljs-attr">value</span>: <span class="hljs-string">''</span><font></font>
        }<font></font>
        <span class="hljs-keyword">this</span>.handleChange = <span class="hljs-keyword">this</span>.handleChange.bind(<span class="hljs-keyword">this</span>)
        <span class="hljs-comment">//   handleChange   MyComponent</span><font></font>
    }<font></font>
<font></font>
    handleChange(e) {<font></font>
        <span class="hljs-comment">// </span><font></font>
    }<font></font>
<font></font>
    render() {<font></font>
        <span class="hljs-keyword">return</span> ( &lt; &gt;<font></font>
            &lt;<font></font>
            input type = {<font></font>
                <span class="hljs-keyword">this</span>.props.type<font></font>
            }<font></font>
            value = {<font></font>
                <span class="hljs-keyword">this</span>.state.value<font></font>
            }<font></font>
            onChange = {<font></font>
                <span class="hljs-keyword">this</span>.handleChange<font></font>
            }<font></font>
            /&gt; &lt;/ &gt;<font></font>
        )<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<a name="31"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">31. Â¿QuÃ© es la programaciÃ³n funcional y quÃ© caracterÃ­sticas de JS nos permiten hablar de ella como lenguaje de programaciÃ³n funcional?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La programaciÃ³n funcional es un concepto de programaciÃ³n declarativa o un ejemplo (patrÃ³n) de cÃ³mo se crean las aplicaciones, cÃ³mo se utilizan las funciones que contienen expresiones que calculan valores sin cambiar los argumentos que se les pasan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El objeto Array contiene los mÃ©todos de mapa, filtro y reducciÃ³n, que son las funciones mÃ¡s famosas en el mundo de la programaciÃ³n funcional debido a su utilidad y tambiÃ©n porque no modifican la matriz, lo que hace que estas funciones sean "limpias". </font><font style="vertical-align: inherit;">JS tambiÃ©n tiene un cierre y funciones de orden superior que son caracterÃ­sticas de un lenguaje de programaciÃ³n funcional. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mÃ©todo map devuelve una nueva matriz con resultados de devoluciÃ³n de llamada para cada elemento de la matriz:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> words = [<span class="hljs-string">'Functional'</span>, <span class="hljs-string">'Procedural'</span>, <span class="hljs-string">'Object-Oriented'</span>]<font></font>
<font></font>
<span class="hljs-keyword">const</span> wordsLength = words.map(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word.length)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mÃ©todo de filtro crea una nueva matriz con todos los elementos que satisfacen la condiciÃ³n especificada en la devoluciÃ³n de llamada:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> data = {<font></font>
    {<font></font>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Mark'</span>,
        <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">true</span><font></font>
    } {<font></font>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Mary'</span>,
        <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">false</span><font></font>
    } {<font></font>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Mae'</span>,
        <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">true</span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> registeredUsers = data.filter(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.isRegistered)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mÃ©todo reduce realiza una devoluciÃ³n de llamada una vez para cada elemento de la matriz, con la excepciÃ³n de los vacÃ­os, tomando cuatro argumentos: el valor inicial (o el valor de la devoluciÃ³n de llamada anterior), el valor del elemento actual, el Ã­ndice actual y la matriz iterada:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> strs = [<span class="hljs-string">'I'</span>, <span class="hljs-string">' '</span>, <span class="hljs-string">'am'</span>, <span class="hljs-string">' '</span>, <span class="hljs-string">'Iron'</span>, <span class="hljs-string">' '</span>, <span class="hljs-string">'Man'</span>]<font></font>
<font></font>
<span class="hljs-keyword">const</span> result = strs.reduce(<span class="hljs-function">(<span class="hljs-params">acc, currentStr</span>) =&gt;</span> acc + str, <span class="hljs-string">''</span>)
</code></pre><br>
<a name="32"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32. Â¿QuÃ© son las funciones de orden superior?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una funciÃ³n de orden superior es una funciÃ³n que devuelve otra funciÃ³n o acepta otra funciÃ³n como argumento.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">higherOrderFunction</span>(<span class="hljs-params">param, callback</span>) </span>{
    <span class="hljs-keyword">return</span> callback(param)<font></font>
}<font></font>
</code></pre><br>
<a name="33"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">33. Â¿Por quÃ© las funciones en JS se denominan objetos de primera clase?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las funciones se denominan objetos de primera clase porque se procesan como cualquier otro valor en JS. </font><font style="vertical-align: inherit;">Se pueden asignar a variables, ser una propiedad de un objeto (mÃ©todo), un elemento de una matriz, un argumento para otra funciÃ³n, el valor devuelto por la funciÃ³n. </font><font style="vertical-align: inherit;">La Ãºnica diferencia entre una funciÃ³n y cualquier otro valor en JS es que la funciÃ³n se puede ejecutar o invocar.</font></font><br>
<br>
<a name="34"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">34. Â¿CÃ³mo implementarÃ­a el mÃ©todo Array.prototype.map?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">arr, mapCallback</span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr) || !arr.length || <span class="hljs-keyword">typeof</span> mapCallback !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> []<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">let</span> result = []
        <span class="hljs-comment">//         </span>
        <span class="hljs-comment">//       </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) {<font></font>
            result.push(mapCallback(arr[i], i, arr))<font></font>
            <span class="hljs-comment">//   mapCallback  result</span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mÃ©todo map crea una nueva matriz con el resultado de llamar a la funciÃ³n especificada para cada elemento de la matriz.</font></font><br>
<br>
<a name="35"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">35. Â¿CÃ³mo implementarÃ­a el mÃ©todo Array.prototype.filter?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span>(<span class="hljs-params">arr, filterCallback</span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr) || !arr.length || <span class="hljs-keyword">typeof</span> filterCallback !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> []<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">let</span> result = []
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) {
            <span class="hljs-comment">//      </span>
            <span class="hljs-keyword">if</span> (filterCallback(arr[i], i, arr)) {
                <span class="hljs-comment">//  ,  ,  result</span><font></font>
                result.push(arr[i])<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mÃ©todo de filtro crea una nueva matriz con todos los elementos que pasaron la prueba especificada en la funciÃ³n que se pasa.</font></font><br>
<br>
<a name="36"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">36. Â¿CÃ³mo implementarÃ­a el mÃ©todo Array.prototype.reduce?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduce</span>(<span class="hljs-params">arr, reduceCallbak, initialValue</span>) </span>{
    <span class="hljs-comment">// ..</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr) || !arr.length || <span class="hljs-keyword">typeof</span> filterCallback !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> []<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//        initialValue, </span>
        <span class="hljs-keyword">let</span> hasInitialValue = initialValue !== <span class="hljs-literal">undefined</span>
        <span class="hljs-keyword">let</span> value = hasInitialValue ? initialValue : arr[<span class="hljs-number">0</span>]
        <span class="hljs-comment">//      initialValue</span><font></font>
<font></font>
        <span class="hljs-comment">//    ,   1,       initialValue,   0,    </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = hasInitialValue ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>, len = arr.length; i &lt; len; i++) {
            <span class="hljs-comment">//         reduceCallback </span><font></font>
            value = reduceCallback(value, arr[i], i, arr)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> value<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mÃ©todo reduce aplica la funciÃ³n reductora a cada elemento de la matriz (de izquierda a derecha), devolviendo un valor resultante.</font></font><br>
<br>
<a name="37"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">37. Â¿QuÃ© es un objeto de argumentos?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Argumentos es una colecciÃ³n de argumentos pasados â€‹â€‹a una funciÃ³n. </font><font style="vertical-align: inherit;">Este es un objeto tipo matriz, tiene la propiedad de longitud, podemos acceder a un valor especÃ­fico usando argumentos [i], pero no tiene los mÃ©todos forEach, reduce, filter y map. </font><font style="vertical-align: inherit;">Le permite averiguar el nÃºmero de parÃ¡metros de funciÃ³n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede convertir argumentos en una matriz usando Array.prototype.slice:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recuerde: en las funciones de flecha, el objeto de argumentos no funciona.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">one</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span><font></font>
}<font></font>
<span class="hljs-keyword">const</span> two = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span><font></font>
}<font></font>
<span class="hljs-keyword">const</span> three = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">three</span>(<span class="hljs-params">{
    return arguments
}</span>)
<span class="hljs-title">const</span> <span class="hljs-title">four</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title">arguments</span>

<span class="hljs-title">four</span>(<span class="hljs-params"></span>) // <span class="hljs-title">arguments</span> <span class="hljs-title">is</span> <span class="hljs-title">not</span> <span class="hljs-title">defined</span>
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Llamar a las cuatro funciones da como resultado un Error de referencia: los argumentos no son un error definido. </font><font style="vertical-align: inherit;">Este problema se puede resolver utilizando la declaraciÃ³n rest:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> four = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> args
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto colocarÃ¡ automÃ¡ticamente todos los parÃ¡metros en una matriz.</font></font><br>
<br>
<a name="38"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">38. Â¿CÃ³mo crear un objeto que no tiene un prototipo?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto se puede hacer usando Object.create:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o1 = {}
<span class="hljs-built_in">console</span>.log(o1.toString) <span class="hljs-comment">// [object Object]</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> o2 = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>) <span class="hljs-comment">//      Object-create  -</span>
<span class="hljs-comment">//    -,   null</span>
<span class="hljs-built_in">console</span>.log(o2.toString) <span class="hljs-comment">// o2.toString is not a function</span>
</code></pre><br>
<a name="39"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">39. Â¿Por quÃ© en el cÃ³digo presentado la variable b se vuelve global cuando se llama a la funciÃ³n?</font></font></h4><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> a = b = <span class="hljs-number">0</span><font></font>
}<font></font>
myFunc()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto sucede porque el operador de asignaciÃ³n ("=") tiene asociatividad diestra, es decir </font><font style="vertical-align: inherit;">asigna valores de derecha a izquierda. </font><font style="vertical-align: inherit;">Por lo tanto, el cÃ³digo toma la siguiente forma:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> a = (b = <span class="hljs-number">0</span>)<font></font>
}<font></font>
myFunc()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, el valor 0 se asigna a la variable "b", que no se declara. </font><font style="vertical-align: inherit;">El motor JS lo hace global. </font><font style="vertical-align: inherit;">El valor (0) devuelto por b = 0 se asigna a la variable local "a". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este problema se puede resolver declarando primero las variables locales y luego asignÃ¡ndoles valores:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> a, b<font></font>
    a = b = <span class="hljs-number">0</span><font></font>
}<font></font>
myFunc()<font></font>
</code></pre><br>
<a name="40"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">40. Â¿QuÃ© es ECMAScript?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ECMAScript es una especificaciÃ³n, un lenguaje de programaciÃ³n de secuencias de comandos estÃ¡ndar, es la base de JS, por lo que cualquier cambio en ECMAScript se refleja en JS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La Ãºltima versiÃ³n de la especificaciÃ³n ECMA-262 se puede ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquÃ­</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="41"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">41. Â¿QuÃ© cosas nuevas trajo ES6 o ECMAScript2015 a JS?</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funciones de flecha</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clases</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cadenas de plantilla.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literales de objetos mejorados</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DesestructuraciÃ³n (DesestructuraciÃ³n de objetos).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promesas promesas).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generadores</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MÃ³dulos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SÃ­mbolo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proxies</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conjuntos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las opciones por defecto.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descansar y extender operadores.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alcance del bloque (palabras clave "let" y "const").</font></font></li>
</ul><br>
<a name="42"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">42. Â¿CuÃ¡l es la diferencia entre las palabras clave "var", "let" y "const"?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las variables declaradas con la palabra clave var son globales. </font><font style="vertical-align: inherit;">Esto significa que son accesibles desde cualquier parte del cÃ³digo:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeX</span>(<span class="hljs-params">showX</span>)</span>{
    <span class="hljs-keyword">if</span>(showX){
        <span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> x<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(giveMeX(<span class="hljs-literal">false</span>))
<span class="hljs-built_in">console</span>.log(giveMeX(<span class="hljs-literal">true</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado del primer console.log serÃ¡ indefinido, el segundo - 5. Tenemos acceso a la variable "x" debido a su apariciÃ³n en el Ã¡mbito global. </font><font style="vertical-align: inherit;">El cÃ³digo del ejemplo anterior se interpreta de la siguiente manera:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeX</span>(<span class="hljs-params">showX</span>)</span>{
    <span class="hljs-keyword">var</span> x <span class="hljs-comment">//   undefined</span>
    <span class="hljs-keyword">if</span>(showX){<font></font>
        x = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> x<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado del primer console.log no estÃ¡ definido, porque las variables declaradas a las que no se les asigna un valor no estÃ¡n definidas de manera predeterminada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las variables declaradas usando las palabras clave "let" y "const" tienen un alcance de bloque. </font><font style="vertical-align: inherit;">Esto significa que solo estÃ¡n disponibles dentro del bloque ({}):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeX</span>(<span class="hljs-params">showX</span>)</span>{
    <span class="hljs-keyword">if</span>(showX){
        <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> x<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeY</span>(<span class="hljs-params">showY</span>)</span>{
    <span class="hljs-keyword">if</span>(showY){
        <span class="hljs-keyword">let</span> y = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> y<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Llamar a estas funciones con el parÃ¡metro falso darÃ¡ como resultado un error de Error de referencia, porque las variables "x" e "y" no son accesibles fuera del bloque y sus valores no se devuelven (no aparece). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diferencia entre "let" y "const" es que en el primer caso podemos cambiar el valor de la variable, y en el segundo - no (constante). </font><font style="vertical-align: inherit;">Al mismo tiempo, podemos cambiar el valor de la propiedad de un objeto declarado usando const, pero no la propiedad en sÃ­ (variable).</font></font><br>
<br>
<a name="43"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">43. Â¿QuÃ© son las funciones de flecha (Funciones de flecha)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La funciÃ³n de flecha es una forma relativamente nueva de crear funciones en JS. </font><font style="vertical-align: inherit;">Las funciones de flecha son mÃ¡s rÃ¡pidas y tienen una sintaxis mÃ¡s legible que las expresiones funcionales. </font><font style="vertical-align: inherit;">En las funciones de flecha, se omite la palabra "funciÃ³n":</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> getCurrentDate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> getCurrentDate = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En una expresiÃ³n funcional, usamos la palabra clave return para devolver un valor. </font><font style="vertical-align: inherit;">En la funciÃ³n de flecha, no hacemos esto, ya que las funciones de flecha devuelven valores implÃ­citamente, siempre que devolvamos una sola expresiÃ³n o valor:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span> <font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> greet = <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>
<span class="hljs-keyword">const</span> greet2 = name = &gt; <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TambiÃ©n podemos pasar parÃ¡metros a las funciones de flecha. </font><font style="vertical-align: inherit;">Si pasamos un parÃ¡metro, no tenemos que ponerlo entre parÃ©ntesis:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> getArgs = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">arguments</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> getArgs2 = <span class="hljs-function">(<span class="hljs-params">...rest</span>) =&gt;</span> rest
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las funciones de flecha no tienen acceso al objeto de argumentos. </font><font style="vertical-align: inherit;">Por lo tanto, llamar a la primera funciÃ³n darÃ¡ como resultado un error. </font><font style="vertical-align: inherit;">Para que los parÃ¡metros pasen a la funciÃ³n, podemos usar el operador rest.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> data = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span>
    <span class="hljs-attr">nums</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<font></font>
    computeResult(){<font></font>
        <span class="hljs-comment">// this    data</span>
        <span class="hljs-keyword">const</span> addAll = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-comment">//     this   </span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nums.reduce(<span class="hljs-function">(<span class="hljs-params">total, cur</span>) =&gt;</span> total + cur, <span class="hljs-number">0</span>)<font></font>
        }<font></font>
    <span class="hljs-keyword">this</span>.result = addAll()<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<a name="44"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">44. Â¿QuÃ© son las clases?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las clases son una forma relativamente nueva de escribir funciones de constructor en JS. </font><font style="vertical-align: inherit;">Este es el azÃºcar sintÃ¡ctico para las funciones de constructor. </font><font style="vertical-align: inherit;">Las clases se basan en los mismos prototipos y herencia del prototipo:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">firstName, lastName, age, address</span>)</span>{
    <span class="hljs-keyword">this</span>.firstName = firstName
    <span class="hljs-keyword">this</span>.lastName = lastName
    <span class="hljs-keyword">this</span>.age = age
    <span class="hljs-keyword">this</span>.address = address<font></font>
}<font></font>
<font></font>
Person.self = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><font></font>
}<font></font>
<font></font>
Person.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Person]'</span><font></font>
}<font></font>
<font></font>
Person.prototype.getFullName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.lastName<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>{
    <span class="hljs-keyword">constructor</span>(firstName, lastName, age, address){
        <span class="hljs-keyword">this</span>.firstName = firstName
        <span class="hljs-keyword">this</span>.lastName = lastName
        <span class="hljs-keyword">this</span>.age = age
        <span class="hljs-keyword">this</span>.address = address<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> self(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><font></font>
    }<font></font>
<font></font>
    toString(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Person]'</span><font></font>
    }<font></font>
<font></font>
    getFullName(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.firstName}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.lastName}</span>`</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mÃ©todo reemplaza y hereda de otra clase:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
Employee.prototype = <span class="hljs-built_in">Object</span>.create(Person.prototype)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">firstName, lastName, age, address, jobTitle, yearStarted</span>)</span>{<font></font>
    Person.call(<span class="hljs-keyword">this</span>, firstName, lastName, age, address)
    <span class="hljs-keyword">this</span>.jobTitle = jobTitle
    <span class="hljs-keyword">this</span>.yearStarted = yearStarted<font></font>
}<font></font>
<font></font>
Employee.prototype.describe = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`I am <span class="hljs-subst">${<span class="hljs-keyword">this</span>.getFullName()}</span> and I have a position of #{this.jobTitle} and I started at <span class="hljs-subst">${<span class="hljs-keyword">this</span>.yearStarted}</span>}`</span><font></font>
}<font></font>
<font></font>
Employee.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Employee]'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>{ <span class="hljs-comment">//   Person</span>
    <span class="hljs-keyword">constructor</span>(firstName, lastName, age, address, jobTitle, yearStarted){
        <span class="hljs-keyword">super</span>(firstName, lastName, age, address)
        <span class="hljs-keyword">this</span>.jobTitle = jobTitle
        <span class="hljs-keyword">this</span>.yearStarted = yearStarted<font></font>
    }<font></font>
<font></font>
    describe(){<font></font>
       <span class="hljs-keyword">return</span> <span class="hljs-string">`I am <span class="hljs-subst">${<span class="hljs-keyword">this</span>.getFullName()}</span> and I have a position of #{this.jobTitle} and I started at <span class="hljs-subst">${<span class="hljs-keyword">this</span>.yearStarted}</span>}`</span> <font></font>
    }<font></font>
<font></font>
    toString(){ <span class="hljs-comment">//   toString  Person</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Employee]'</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Â¿CÃ³mo aprender sobre el uso de prototipos?</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Something</span></span>{ }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AnotherSomething</span>(<span class="hljs-params"></span>)</span>{ }<font></font>
<font></font>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">as</span> = <span class="hljs-keyword">new</span> AnotherSomething()
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Something()<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> Something) <span class="hljs-comment">// function</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> AnotherSomething) <span class="hljs-comment">// function</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">as</span>.toString()) <span class="hljs-comment">// [object Object]</span>
<span class="hljs-built_in">console</span>.log(a.toString()) <span class="hljs-comment">// [object Object]</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">as</span>.toString === <span class="hljs-built_in">Object</span>.prototype.toString)
<span class="hljs-built_in">console</span>.log(a.toString === <span class="hljs-built_in">Object</span>.prototype.toString)
<span class="hljs-comment">//     true</span>
<span class="hljs-comment">// Object.prototype     </span>
<span class="hljs-comment">// Something  AnotherSomething   Object.prototype</span>
</code></pre><br>
<a name="45"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">45. Â¿QuÃ© son las plantillas literales?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los literales de plantilla son una forma relativamente nueva de crear cadenas en JS. </font><font style="vertical-align: inherit;">Los literales de plantilla se crean utilizando dobles comillas (``):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> greet = <span class="hljs-string">'Hi I\'m Mark'</span><font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">let</span> greet = <span class="hljs-string">`Hi I'm Mark`</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los literales de plantilla, no necesitamos escapar de comillas simples.</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> lastWords = <span class="hljs-string">'\n'</span>
    + <span class="hljs-string">' I \n'</span>
    + <span class="hljs-string">' am \n'</span>
    + <span class="hljs-string">'Iron Man \n'</span><font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">let</span> lastWords = <span class="hljs-string">`
    I
    am
    Iron Man
`</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En ES6, no necesitamos usar la secuencia de escape "\ n" para alimentar la lÃ­nea.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>!`</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En ES6, no necesitamos usar la concatenaciÃ³n de cadenas para combinar texto con una variable: podemos usar la expresiÃ³n $ {expr} para obtener el valor de la variable.</font></font><br>
<br>
<a name="46"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">46. â€‹â€‹Â¿QuÃ© es la desestructuraciÃ³n de objetos?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La desestructuraciÃ³n es una forma relativamente nueva de obtener (recuperar) los valores de un objeto o matriz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que tenemos un objeto como este:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> employee = {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Marko'</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Polo'</span>,
    <span class="hljs-attr">position</span>: <span class="hljs-string">'Software Developer'</span>,
    <span class="hljs-attr">yearHired</span>: <span class="hljs-number">2017</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anteriormente, para crear las propiedades de un objeto, creamos variables para cada propiedad. </font><font style="vertical-align: inherit;">Fue muy aburrido y muy molesto:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> firstName = employee.firstName
<span class="hljs-keyword">var</span> lastName = employee.lastName
<span class="hljs-keyword">var</span> position = employee.position
<span class="hljs-keyword">var</span> yearHired = employee.yearHired
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usar la desestructuraciÃ³n hace que el cÃ³digo sea mÃ¡s limpio y lleva menos tiempo. </font><font style="vertical-align: inherit;">La sintaxis de desestructuraciÃ³n es la siguiente: encerramos las propiedades del objeto que queremos recibir entre llaves ({}), y si estamos hablando de una matriz, entre corchetes ([]):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> { firstName, lastName, position, yearHired } = employee
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para cambiar el nombre de la variable, use "propertyName: newName":</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> { <span class="hljs-attr">firstName</span>: fName, <span class="hljs-attr">lastName</span>: lName, position, yearHired } = employee
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para asignar valores predeterminados a las variables, use "propertyName = 'defaultValue'":</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> { firstName = <span class="hljs-string">'Mark'</span>, <span class="hljs-attr">lastName</span>: lName, position, yearHired } = employee
</code></pre><br>
<a name="47"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">47. Â¿QuÃ© son los mÃ³dulos?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los mÃ³dulos le permiten combinar (usar) el cÃ³digo de diferentes archivos y evitar que tengamos que guardar todo el cÃ³digo en un archivo grande. </font><font style="vertical-align: inherit;">Antes de que los mÃ³dulos aparecieran en JS, habÃ­a dos sistemas de mÃ³dulos populares para soportar cÃ³digo:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CommonJS - Nodejs</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMD (AsyncronousModuleDefinition) - Navegadores</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La sintaxis de los mÃ³dulos es muy simple: utilizamos importar para importar funcionalidades o valores de otro archivo o archivos, y exportar para exportar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funcionalidad de exportaciÃ³n a otro archivo (denominado exportaciÃ³n):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - helpers.js</span>
exports.isNull = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span><font></font>
}<font></font>
<font></font>
exports.isUndefined = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span><font></font>
}<font></font>
<font></font>
exports.isNullOrUndefined = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> exports.isNull(val) || exports.isUndefined(val)<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNull</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUndefined</span>(<span class="hljs-params">val</span>) </span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNullOrUndefined</span>(<span class="hljs-params">val</span>) </span>{
    <span class="hljs-keyword">return</span> isNull(val) || isUndefined(val);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Importar funcionalidad a otro archivo:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - index.js</span>
<span class="hljs-keyword">const</span> helpers = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>)
<span class="hljs-keyword">const</span> isNull = helpers.isNull
<span class="hljs-keyword">const</span> isUndefined = helpers.isUndefined
<span class="hljs-keyword">const</span> isNullOrUndefined = helpers.isNullOrUndefined<font></font>
<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> { isNull, isUndefined, isNullOrUndefined } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>)<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> helpers <span class="hljs-keyword">from</span> <span class="hljs-string">'./helpers.js'</span> <span class="hljs-comment">// helpers -  </span><font></font>
<font></font>
<span class="hljs-comment">// </span>
<span class="hljs-keyword">import</span> { isNull, isUndefined, isNullOrUndefined <span class="hljs-keyword">as</span> isValid} <span class="hljs-keyword">from</span> <span class="hljs-string">'./helpers.js'</span> <span class="hljs-comment">//  "as"  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ExportaciÃ³n predeterminada:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - index.js</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Helpers</span> </span>{
    <span class="hljs-keyword">static</span> isNull(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isUndefined(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isNullOrUndefined(val){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNull(val) || <span class="hljs-keyword">this</span>.isUndefined(val)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">module</span>.exports = Helpers<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Helpers</span> </span>{
    <span class="hljs-keyword">static</span> isNull(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isUndefined(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isNullOrUndefined(val){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNull(val) || <span class="hljs-keyword">this</span>.isUndefined(val)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Helpers
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Importar:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - index.js</span>
<span class="hljs-keyword">const</span> Helpers = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>)
<span class="hljs-built_in">console</span>.log(Helpers.isNull(<span class="hljs-literal">null</span>))<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-keyword">import</span> Helpers <span class="hljs-keyword">from</span> <span class="hljs-string">'./helpers.js'</span>
<span class="hljs-built_in">console</span>.log(Helpers.isNull(<span class="hljs-literal">null</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es el uso bÃ¡sico de los mÃ³dulos. </font><font style="vertical-align: inherit;">No entrÃ© en detalles porque mi publicaciÃ³n ya es demasiado grande.</font></font><br>
<br>
<a name="48"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">48. Â¿QuÃ© es un objeto Set?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El objeto Set le permite almacenar valores Ãºnicos, primitivas y referencias de objetos. </font><font style="vertical-align: inherit;">Una vez mÃ¡s: solo se pueden agregar valores Ãºnicos a Set. </font><font style="vertical-align: inherit;">Comprueba los valores almacenados en Ã©l utilizando el algoritmo SameZeroValue. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se crea una instancia de Set utilizando el constructor Set. </font><font style="vertical-align: inherit;">TambiÃ©n podemos pasarle algunos valores al crear:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()
<span class="hljs-keyword">const</span> set2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>]) <span class="hljs-comment">//  "d"  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos agregar valores a Set usando el mÃ©todo add. </font><font style="vertical-align: inherit;">Como el mÃ©todo add es retornable, podemos usar una cadena de llamadas:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.add(<span class="hljs-string">'f'</span>)<font></font>
set2.add(<span class="hljs-string">'g'</span>).add(<span class="hljs-string">'h'</span>).add(<span class="hljs-string">'i'</span>).add(<span class="hljs-string">'j'</span>).add(<span class="hljs-string">'k'</span>).add(<span class="hljs-string">'k'</span>) <span class="hljs-comment">//  "k"  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos eliminar valores de Set usando el mÃ©todo delete:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.delete(<span class="hljs-string">'k'</span>) <span class="hljs-comment">// true</span>
set2.delete(<span class="hljs-string">'z'</span>) <span class="hljs-comment">// false,    set2   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos verificar una propiedad en Set usando el mÃ©todo has:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.has(<span class="hljs-string">'a'</span>) <span class="hljs-comment">// true</span>
set2.has(<span class="hljs-string">'z'</span>) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para obtener la longitud de Set, use el mÃ©todo de tamaÃ±o:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.size <span class="hljs-comment">// 10</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mÃ©todo claro borra Set:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.clear() <span class="hljs-comment">// </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos usar Set para eliminar valores duplicados en una matriz:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>]
<span class="hljs-keyword">const</span> uniqNums = [...new <span class="hljs-built_in">Set</span>(nums)] <span class="hljs-comment">// [1,2,3,4,5,6,7,8]</span>
</code></pre><br>
<a name="49"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">49. Â¿QuÃ© es una funciÃ³n de devoluciÃ³n de llamada?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La funciÃ³n de devoluciÃ³n de llamada es una funciÃ³n cuya llamada se pospone para el futuro (ocurre bajo ciertas condiciones, por ejemplo, cuando ocurre un evento).</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> btnAdd = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btnAdd'</span>)<font></font>
<font></font>
btnAdd.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickCallback</span>(<span class="hljs-params">e</span>))</span>{
    <span class="hljs-comment">//   </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el ejemplo, estamos esperando un evento de "clic" en un elemento con el identificador "btnAdd". </font><font style="vertical-align: inherit;">Al hacer clic, se llama a la funciÃ³n clickCallback. </font><font style="vertical-align: inherit;">La funciÃ³n de devoluciÃ³n de llamada agrega alguna funcionalidad a los datos o eventos. </font><font style="vertical-align: inherit;">Los mÃ©todos reducir, filtrar y asignar pasan una funciÃ³n de devoluciÃ³n de llamada como segundo argumento. </font><font style="vertical-align: inherit;">Una buena analogÃ­a con la devoluciÃ³n de llamada es la siguiente situaciÃ³n: llama a alguien, Ã©l no responde, le deja un mensaje y espera a que vuelva a llamar. </font><font style="vertical-align: inherit;">Una llamada o mensaje es un evento o un dato, y una devoluciÃ³n de llamada es la expectativa (anticipaciÃ³n) de una devoluciÃ³n de llamada.</font></font><br>
<br>
<a name="50"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">50. Â¿QuÃ© son las promesas?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las promesas son una forma de trabajar con cÃ³digo asincrÃ³nico en JS. </font><font style="vertical-align: inherit;">Devuelven el resultado de una operaciÃ³n asincrÃ³nica. </font><font style="vertical-align: inherit;">Se inventaron promesas para resolver el problema de las llamadas funciones infernales de devoluciÃ³n de llamada.</font></font><br>
<br>
<pre><code class="javascript hljs">fs.readFile(<span class="hljs-string">'somefile.txt'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, data</span>)</span>{
    <span class="hljs-keyword">if</span>(e){
        <span class="hljs-built_in">console</span>.log(e)<font></font>
    }<font></font>
    <span class="hljs-built_in">console</span>.log(data)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los problemas con este enfoque comienzan cuando necesitamos agregar otra operaciÃ³n asincrÃ³nica a la primera (dentro de la primera), luego a otra, etc. </font><font style="vertical-align: inherit;">Como resultado, obtenemos un cÃ³digo desordenado e ilegible:</font></font><br>
<br>
<pre><code class="javascript hljs">fs.readFile(<span class="hljs-string">'somefile.txt'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e,data</span>)</span>{
    <span class="hljs-comment">// </span>
    fs.readFile(<span class="hljs-string">'directory'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, files</span>)</span>{
        <span class="hljs-comment">// </span>
        fs.mkdir(<span class="hljs-string">'directory'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{
            <span class="hljs-comment">// </span><font></font>
        })<font></font>
    })<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y asÃ­ es como se ve con las promesas:</font></font><br>
<br>
<pre><code class="javascript hljs">promReadFile(<span class="hljs-string">'file/path'</span>)<font></font>
.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> promReaddir(<span class="hljs-string">'directory'</span>)<font></font>
})<font></font>
.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> promMkdir(<span class="hljs-string">'directory'</span>)<font></font>
})<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.error(e)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Promise tiene cuatro condiciones:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esperar es el estado inicial de una promesa. </font><font style="vertical-align: inherit;">El resultado de la promesa es desconocido porque la operaciÃ³n no se ha completado.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hecho: operaciÃ³n asincrÃ³nica completada, hay un resultado.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rechazado: la operaciÃ³n asincrÃ³nica fallÃ³, hay una razÃ³n.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Completado: completado o rechazado.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El constructor Promise acepta resolver y rechazar como parÃ¡metros. </font><font style="vertical-align: inherit;">En resoluciÃ³n, el resultado de la operaciÃ³n se registra, en rechazo, la razÃ³n de la falla de la operaciÃ³n. </font><font style="vertical-align: inherit;">El resultado puede procesarse en el mÃ©todo .then, el error puede procesarse en el mÃ©todo .catch. </font><font style="vertical-align: inherit;">El mÃ©todo .then tambiÃ©n devuelve una promesa, por lo que podemos usar una cadena que consta de varios .then.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myPromiseAsync = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {<font></font>
        doSomeAsync(...args, (error, data) =&gt; {<font></font>
            <span class="hljs-keyword">if</span>(error){<font></font>
                reject(error)<font></font>
            } <span class="hljs-keyword">else</span>{<font></font>
                resolve(data)<font></font>
            }<font></font>
        })<font></font>
    })<font></font>
}<font></font>
<font></font>
myPromiseAsync()<font></font>
.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(result)<font></font>
})<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.error(reason)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos crear una funciÃ³n auxiliar para convertir una operaciÃ³n asincrÃ³nica de devoluciÃ³n de llamada a una promesa. </font><font style="vertical-align: inherit;">FuncionarÃ¡ como util de Node.js ("promisificaciÃ³n"):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> toPromise = <span class="hljs-function">(<span class="hljs-params">asyncFuncWithCallback</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> {<font></font>
            asyncFuncWithCallback(...args, (e, result) =&gt; {<font></font>
                <span class="hljs-keyword">return</span> e ? rej(e) : res(result)<font></font>
            })<font></font>
        })<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> promiseReadFile = toPromise(fs.readFile)<font></font>
<font></font>
promiseReadFile(<span class="hljs-string">'file/path'</span>)<font></font>
.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(data)<font></font>
})<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(e))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede leer mÃ¡s sobre las promesas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquÃ­</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquÃ­</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="51"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">51. Â¿QuÃ© es async / wait?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Async / await es una forma relativamente nueva de escribir cÃ³digo asincrÃ³nico (sin bloqueo) en JS. </font><font style="vertical-align: inherit;">EstÃ¡n envueltos en una promesa. </font><font style="vertical-align: inherit;">Hace que el cÃ³digo sea mÃ¡s legible y limpio que las promesas y las funciones de devoluciÃ³n de llamada. </font><font style="vertical-align: inherit;">Sin embargo, para usar async / await, debe conocer bien las promesas.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callApi</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">'url/to/api/endpoint'</span>)<font></font>
    .then(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> resp.json())<font></font>
    .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-comment">//   </span>
    }).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
        <span class="hljs-comment">//   </span><font></font>
    })<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// async/await</span>
<span class="hljs-comment">//     try/catch</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callApi</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">const</span> resp = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'url/to/api/endpoint'</span>)
        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.json()
        <span class="hljs-comment">//   </span>
    } <span class="hljs-keyword">catch</span>(e){
        <span class="hljs-comment">//   </span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recuerde: usar la palabra clave asÃ­ncrona antes de que una funciÃ³n la obligue a devolver una promesa:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> giveMeOne = <span class="hljs-keyword">async</span> () = <span class="hljs-number">1</span><font></font>
<font></font>
giveMeOne()<font></font>
.then(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(num) <span class="hljs-comment">// 1</span><font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La palabra clave await solo se puede usar dentro de una funciÃ³n asincrÃ³nica. </font><font style="vertical-align: inherit;">Usar wait dentro de otra funciÃ³n darÃ¡ como resultado un error. </font><font style="vertical-align: inherit;">Aguardar espera a que la expresiÃ³n termine a la derecha para devolver su valor antes de la siguiente lÃ­nea de cÃ³digo.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> giveMeOne = <span class="hljs-keyword">async</span>() =&gt; <span class="hljs-number">1</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOne</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">const</span> num = <span class="hljs-keyword">await</span> giveMeOne()
        <span class="hljs-built_in">console</span>.log(num)<font></font>
    } <span class="hljs-keyword">catch</span>(e){
        <span class="hljs-built_in">console</span>.log(e)<font></font>
    }<font></font>
}<font></font>
<span class="hljs-comment">// Uncaught SyntaxError: await is only valid in an async function</span><font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTwo</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">const</span> num1 = <span class="hljs-keyword">await</span> giveMeOne()
        <span class="hljs-keyword">const</span> nm2 = <span class="hljs-keyword">await</span> giveMeOne()
        <span class="hljs-keyword">return</span> num1 + num2<font></font>
    } <span class="hljs-keyword">catch</span>(e){
        <span class="hljs-built_in">console</span>.log(e)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">await</span> getTwo() <span class="hljs-comment">// 2</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lea mÃ¡s sobre async / wait </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquÃ­</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquÃ­</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="52"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">52. Â¿CuÃ¡l es la diferencia entre un operador de propagaciÃ³n y un operador de reposo?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las sentencias spread y rest tienen la misma sintaxis ("..."). </font><font style="vertical-align: inherit;">La diferencia radica en el hecho de que con la ayuda de propagaciÃ³n transferimos o distribuimos los datos de la matriz a otros datos, y con la ayuda del resto obtenemos todos los parÃ¡metros de la funciÃ³n y los colocamos en la matriz (o extraemos algunos de los parÃ¡metros).</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>)</span>{
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> nums = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
<span class="hljs-keyword">const</span> sum = add(...nums)
<span class="hljs-built_in">console</span>.log(sum) <span class="hljs-comment">// 11</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, usamos spread cuando llamamos a la funciÃ³n add con los datos de la matriz nums. </font><font style="vertical-align: inherit;">El valor de la variable "a" serÃ¡ 5, b = 6, suma = 11.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">...rest</span>)</span>{
    <span class="hljs-keyword">return</span> rest.reduce(<span class="hljs-function">(<span class="hljs-params">total, current</span>) =&gt;</span> total + current)<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// 3</span>
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment">// 15</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AquÃ­ llamamos a la funciÃ³n add con cualquier nÃºmero de argumentos. </font><font style="vertical-align: inherit;">Agregar devuelve la suma de estos argumentos.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> [first, ...others] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-built_in">console</span>.log(first) <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.log(others) <span class="hljs-comment">// [2, 3, 4, 5]</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, usamos rest para poner cualquier nÃºmero de parÃ¡metros, excepto el primero, en la matriz de otros.</font></font><br>
<br>
<a name="53"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">53. Â¿CuÃ¡les son los parÃ¡metros predeterminados?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es una forma relativamente nueva de definir los valores de las variables predeterminadas.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>)</span>{<font></font>
    a = a || <span class="hljs-number">0</span>
    b = b || <span class="hljs-number">0</span>
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span></span>)</span>{
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<span class="hljs-comment">//      "a"  "b" - ,    0</span>
add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puedes usar la desestructuraciÃ³n:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFirst</span>(<span class="hljs-params">[first, ...rest] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</span>)</span>{
    <span class="hljs-keyword">return</span> first<font></font>
}<font></font>
<font></font>
getFirst() <span class="hljs-comment">// 0</span>
getFirst([<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]) <span class="hljs-comment">// 10</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArr</span>(<span class="hljs-params">{ nums } = { nums: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] }</span>)</span>{
    <span class="hljs-keyword">return</span> nums<font></font>
}<font></font>
<font></font>
getArr <span class="hljs-comment">// [1,2,3,4]</span>
getArr({<span class="hljs-attr">nums</span>:[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]}) <span class="hljs-comment">// [5,4,3,2,1]</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incluso podemos usar los parÃ¡metros predeterminados declarados en el mismo lugar:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomethingWithValue</span>(<span class="hljs-params">value = <span class="hljs-string">'Hello World'</span>, callback = (</span>) =&gt; </span>{ <span class="hljs-built_in">console</span>.log(value) }){<font></font>
    callback()<font></font>
}<font></font>
doSomethingWithValue() <span class="hljs-comment">// Hello World</span>
</code></pre><br>
<a name="54"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">54. Â¿QuÃ© es un contenedor de objetos (objetos de envoltura)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las primitivas cadena, nÃºmero y booleano tienen propiedades y mÃ©todos, a pesar de que no son objetos:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> name = <span class="hljs-string">'marko'</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> name) <span class="hljs-comment">// string</span>
<span class="hljs-built_in">console</span>.log(name.toUpperCase()) <span class="hljs-comment">// MARKO</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nombre es una cadena (tipo primitivo) que no tiene propiedades ni mÃ©todos, pero cuando llamamos al mÃ©todo toUpperCase (), esto no conduce a un error, sino a "MARKO". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La razÃ³n de este comportamiento es que el nombre se convierte temporalmente en un objeto. </font><font style="vertical-align: inherit;">Cada primitivo, excepto nulo e indefinido, tiene un objeto contenedor. </font><font style="vertical-align: inherit;">Tales objetos son String, Number, Boolean, Symbol y BigInt. </font><font style="vertical-align: inherit;">En nuestro caso, el cÃ³digo toma la siguiente forma:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(name).toUpperCase()) <span class="hljs-comment">// MARKO</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un objeto temporal se descarta al finalizar el trabajo con una propiedad o mÃ©todo.</font></font><br>
<br>
<a name="55"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">55. Â¿CuÃ¡l es la diferencia entre la coerciÃ³n implÃ­cita y explÃ­cita?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La conversiÃ³n implÃ­cita es una forma de transmitir un valor a otro tipo sin nuestro conocimiento (participaciÃ³n). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que tenemos lo siguiente:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-string">'6'</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> + <span class="hljs-literal">true</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span> * <span class="hljs-string">'2'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado del primer console.log serÃ¡ 16. En otros idiomas, esto conducirÃ­a a un error, pero en JS 1 se convierte en una cadena y se concatena (adjunta) desde 6. No hicimos nada, la conversiÃ³n se produjo automÃ¡ticamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado del segundo console.log serÃ¡ 1. False se convirtiÃ³ a 0, verdadero a 1. 0 + 1 = 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado del tercer console.log serÃ¡ 12. La lÃ­nea 2 se convirtiÃ³ a un nÃºmero antes de multiplicar por 6. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La conversiÃ³n explÃ­cita implica nuestra participaciÃ³n en convertir el valor a otro tipo:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'6'</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, usamos parseInt para convertir la cadena 6 en un nÃºmero, luego sumamos los dos nÃºmeros y obtenemos 7.</font></font><br>
<br>
<a name="56"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">56. Â¿QuÃ© es NaN? </font><font style="vertical-align: inherit;">Â¿CÃ³mo verificar si el valor es NaN?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NaN o no un nÃºmero (no un nÃºmero) es el valor obtenido como resultado de realizar una operaciÃ³n numÃ©rica en un valor no numÃ©rico:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> a<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'abc'</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-literal">null</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-literal">undefined</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(++a))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>({} * <span class="hljs-number">10</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'abc'</span> - <span class="hljs-number">2</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0</span> / <span class="hljs-number">0</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'10a'</span> * <span class="hljs-number">10</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JS tiene un mÃ©todo isNaN incorporado que le permite verificar si el valor es NaN, pero se comporta de manera bastante extraÃ±a:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>()) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>({})) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">String</span>(<span class="hljs-string">'a'</span>))) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { })) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado de todo console.log es verdadero, a pesar del hecho de que ninguno de los valores es NaN. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ES6 recomienda usar el mÃ©todo Number.isNaN para verificar si el valor es NaN. </font><font style="vertical-align: inherit;">TambiÃ©n podemos escribir una funciÃ³n auxiliar para resolver el problema de la "desigualdad de NaN por sÃ­ misma":</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkIsNan</span>(<span class="hljs-params">value</span>)</span>{
    <span class="hljs-keyword">return</span> value !== value<font></font>
}<font></font>
</code></pre><br>
<a name="57"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">57. Â¿CÃ³mo verificar si un valor es una matriz?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para hacer esto, use el mÃ©todo Array.isArray:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-number">5</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-string">''</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray()) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray( {<span class="hljs-attr">length</span>: <span class="hljs-number">5</span> })) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray([])) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si el entorno en el que trabaja no es compatible con este mÃ©todo, puede usar el siguiente archivo polivinÃ­lico:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">value</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(value) === <span class="hljs-string">'[object Array]'</span><font></font>
}<font></font>
</code></pre><br>
<a name="58"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">58. Â¿CÃ³mo verificar que un nÃºmero sea par, sin usar la divisiÃ³n de mÃ³dulo o la divisiÃ³n con el resto (operador "%")?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para resolver este problema, puede usar el operador "&amp;" (binario y). </font><font style="vertical-align: inherit;">El operador &amp; compara operandos como valores binarios.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEven</span>(<span class="hljs-params">num</span>)</span>{
    <span class="hljs-keyword">if</span>(num &amp; <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    } <span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 en la notaciÃ³n binaria es 000 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 - esto es 001 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 - 010 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3 - 011 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4 - 100 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5 - 101 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 - 110 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7 - 111 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
, etc. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y8/zo/m2/y8zom220osynreetfh8fp-dkuog.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Console.log (5 y 1) devolverÃ¡ 1. Primero, el operador &amp; convierte ambos nÃºmeros a valores binarios, 5 se convierte en 101, 1 se convierte en 001. Luego se realiza una comparaciÃ³n a nivel de bits: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vy/4k/em/vy4kemefvzxgjlwdp3dmsh64ae8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compare 1 y 0, obtenemos 0. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compare 0 y 0 , obtenemos 0. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compara 1 y 1, obtenemos 1. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Convierte el valor binario en un entero, obtenemos 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si esta informaciÃ³n te parece demasiado complicada, podemos resolver el problema usando la funciÃ³n recursiva:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEven</span>(<span class="hljs-params">num</span>)</span>{
    <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span> || num === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    <span class="hljs-keyword">return</span> isEven(num - <span class="hljs-number">2</span>)<font></font>
}<font></font>
</code></pre><br>
<a name="59"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">59. Â¿CÃ³mo determinar la presencia de una propiedad en un objeto?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
hay tres maneras de hacer esto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La primera forma es usar el operador in:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o = {
    <span class="hljs-string">'prop'</span>: <span class="hljs-string">'bwahahah'</span>,
    <span class="hljs-string">'prop2'</span>: <span class="hljs-string">'hweasa'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'prop'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'prop1'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo es usar el mÃ©todo hasOwnProperty:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'prop2'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'prop1'</span>)) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tercero es la notaciÃ³n de Ã­ndice de la matriz:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(o[<span class="hljs-string">'prop'</span>]) <span class="hljs-comment">// bwahahah</span>
<span class="hljs-built_in">console</span>.log(o[<span class="hljs-string">'prop1'</span>]) <span class="hljs-comment">// undefined</span>
</code></pre><br>
<a name="60"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">60. Â¿QuÃ© es AJAX?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AJAX o JavaScript asÃ­ncrono y XML es un conjunto de tecnologÃ­as interconectadas que le permiten trabajar con datos en modo asÃ­ncrono. </font><font style="vertical-align: inherit;">Esto significa que podemos enviar datos al servidor y recibir datos del mismo sin volver a cargar la pÃ¡gina web. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AJAX utiliza las siguientes tecnologÃ­as: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTML: estructura de la pÃ¡gina web. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSS - estilos de pÃ¡gina web. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript: comportamiento de la pÃ¡gina y trabajo con el DOM. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
API XMLHttpRequest: envÃ­o y recepciÃ³n de datos desde el servidor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHP, Python, Nodejs: algÃºn tipo de lenguaje de servidor.</font></font><br>
<br>
<a name="61"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">61. Â¿CÃ³mo crear un objeto en JS?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Literal del objeto:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Mark'</span>,<font></font>
    greeting(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
    }<font></font>
}<font></font>
<font></font>
o.greeting <span class="hljs-comment">// Hi, I'm Mark</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FunciÃ³n del constructor:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">this</span>.name = name<font></font>
}<font></font>
<font></font>
Person.prototype.greeting = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> mark = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Mark'</span>)<font></font>
<font></font>
mark.greeting() <span class="hljs-comment">// Hi, I'm Mark</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MÃ©todo Object.create:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> n = {<font></font>
    greeting(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> o = <span class="hljs-built_in">Object</span>.create(n)<font></font>
<font></font>
o.name = <span class="hljs-string">'Mark'</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(o.greeting) <span class="hljs-comment">// Hi, I'm Mark</span>
</code></pre><br>
<a name="62"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">62. Â¿CuÃ¡l es la diferencia entre los mÃ©todos Object.freeze y Object.seal?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diferencia es que cuando usamos el mÃ©todo Object.freeze, no podemos cambiar o editar las propiedades del objeto, y cuando usamos Object.seal tenemos esa oportunidad.</font></font><br>
<br>
<a name="63"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63. Â¿CuÃ¡l es la diferencia entre el operador in y el mÃ©todo hasOwnProperty?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diferencia es que el operador "in" comprueba la presencia de una propiedad no solo en el objeto en sÃ­, sino tambiÃ©n en sus prototipos, y el mÃ©todo hasOwnProperty, solo en el objeto.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'prop'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'toString'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// true</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'prop'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'toString'</span>)) <span class="hljs-comment">// false</span>
</code></pre><br>
<a name="64"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64. Â¿QuÃ© tÃ©cnicas de trabajo con cÃ³digo asincrÃ³nico en JS conoces?</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Devoluciones de llamada</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promesas promesas).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AsÃ­ncrono / espera.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliotecas como async.js, blueprint, q, co.</font></font></li>
</ul><br>
<a name="65"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65. Â¿CuÃ¡l es la diferencia entre una funciÃ³n normal y una expresiÃ³n funcional?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que tenemos lo siguiente:</font></font><br>
<br>
<pre><code class="javascript hljs">hoistedFunc()<font></font>
notHoistedFunc()<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hoistedFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I am hoisted'</span>)<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> notHoistedFunc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I will not be hoisted!'</span>)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una llamada a notHoistedFunc darÃ¡ como resultado un error, pero una llamada a hoistedFunc no, porque hoistedFunc "aparece", se eleva al alcance global, pero notHoistedFunc no.</font></font><br>
<br>
<a name="66"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">66. Â¿CÃ³mo llamar a una funciÃ³n en JS?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En JS, hay 4 formas de llamar a una funciÃ³n. </font><font style="vertical-align: inherit;">La llamada define el valor de esto o el "propietario" de la funciÃ³n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Llamada como una funciÃ³n. </font><font style="vertical-align: inherit;">Si se llama a una funciÃ³n como mÃ©todo, constructor, o usando los mÃ©todos apply o call, entonces se llama como una funciÃ³n. </font><font style="vertical-align: inherit;">El propietario de dicha funciÃ³n es el objeto de ventana:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<font></font>
add(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">// window, 6</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> o = {<font></font>
    method(callback){<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
<font></font>
o.method(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// window</span><font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Llamar como mÃ©todo. </font><font style="vertical-align: inherit;">Cuando una funciÃ³n es una propiedad de un objeto, lo llamamos mÃ©todo. </font><font style="vertical-align: inherit;">Cuando se llama a un mÃ©todo, este objeto se convierte en el objeto de este mÃ©todo:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> details = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko'</span>,<font></font>
    getName(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name<font></font>
    }<font></font>
}<font></font>
<font></font>
details.getName() <span class="hljs-comment">// Marko,  this   details</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Llamada como constructor. </font><font style="vertical-align: inherit;">Cuando se llama a una funciÃ³n usando la palabra clave "nueva", llamamos a esa funciÃ³n constructor. </font><font style="vertical-align: inherit;">Esto crea un objeto vacÃ­o, que es el valor de esto:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">name, position, yearHired</span>)</span>{
    <span class="hljs-comment">//   ,   this</span>
    <span class="hljs-comment">// this = {}</span>
    <span class="hljs-keyword">this</span>.name = name
    <span class="hljs-keyword">this</span>.position = position
    <span class="hljs-keyword">this</span>.yearHired = yearHired
    <span class="hljs-comment">//   Employee.prototype   this,    </span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> emp = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">'Marko Polo'</span>, <span class="hljs-string">'Software Development'</span>, <span class="hljs-number">2017</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una llamada usando los mÃ©todos de solicitud o llamada. </font><font style="vertical-align: inherit;">Usamos estos mÃ©todos cuando queremos determinar explÃ­citamente el valor de esto o el propietario de una funciÃ³n:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj1 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> obj2 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduceAdd</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++){<font></font>
        result += <span class="hljs-built_in">arguments</span>[i]<font></font>
    }<font></font>
    <span class="hljs-keyword">this</span>.result = result<font></font>
}<font></font>
<font></font>
reduceAdd.apply(obj1, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]) <span class="hljs-comment">//  this  obj1</span>
reduceAdd.call(obj2, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">//  this  obj2</span>
</code></pre><br>
<a name="67"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">67. Â¿QuÃ© es memorizaciÃ³n o memorizaciÃ³n?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La memorizaciÃ³n es la tÃ©cnica de crear una funciÃ³n que puede recordar resultados o valores calculados previamente. </font><font style="vertical-align: inherit;">La ventaja de la memorizaciÃ³n es que evitamos volver a ejecutar una funciÃ³n con los mismos argumentos. </font><font style="vertical-align: inherit;">La desventaja es que nos vemos obligados a asignar memoria adicional para guardar los resultados.</font></font><br>
<br>
<a name="68"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68. Â¿CÃ³mo implementarÃ­a la funciÃ³n auxiliar de memorizaciÃ³n?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span>(<span class="hljs-params">fn</span>)</span>{
    <span class="hljs-keyword">const</span> cache = {}
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">param</span>)</span>{
        <span class="hljs-keyword">if</span>(cache[param]){
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'cached'</span>)
            <span class="hljs-keyword">return</span> cache[param]<font></font>
        } <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">let</span> result = fn(param)<font></font>
            cache[param] = result<font></font>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'not cached'</span>)
            <span class="hljs-keyword">return</span> result<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> toUpper = <span class="hljs-function">(<span class="hljs-params">str = <span class="hljs-string">''</span></span>) =&gt;</span> str.toUpperCase()<font></font>
<font></font>
<span class="hljs-keyword">const</span> toUpperMemoized = memoize(toUpper)<font></font>
<font></font>
toUpperMemoized(<span class="hljs-string">'abcdef'</span>)<font></font>
toUpperMemoized(<span class="hljs-string">'abcdef'</span>) <span class="hljs-comment">//  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implementamos la funciÃ³n de memorizaciÃ³n con un argumento. </font><font style="vertical-align: inherit;">HagÃ¡moslo "multi-argumento":</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> slice = <span class="hljs-built_in">Array</span>.prototype.slice
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span>(<span class="hljs-params">fn</span>)</span>{
    <span class="hljs-keyword">const</span> cache = {}
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> params = slice.call(args)
        <span class="hljs-built_in">console</span>.log(params)
        <span class="hljs-keyword">if</span>(cache[params]){
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'cached'</span>)
            <span class="hljs-keyword">return</span> cache[params]<font></font>
        } <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">let</span> result = fn(...args)<font></font>
            cache[params] = result<font></font>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'not cached'</span>)
            <span class="hljs-keyword">return</span> result<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<span class="hljs-keyword">const</span> makeFullName = <span class="hljs-function">(<span class="hljs-params">fName, lName</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${fName}</span> <span class="hljs-subst">${lName}</span>`</span>
<span class="hljs-keyword">const</span> reduceAdd = <span class="hljs-function">(<span class="hljs-params">numbers, startValue = <span class="hljs-number">0</span></span>) =&gt;</span> numbers.reduce(<span class="hljs-function">(<span class="hljs-params">total, cur</span>) =&gt;</span> total + cur, startValue)<font></font>
<font></font>
<span class="hljs-keyword">const</span> memoizedFullName = memoize(makeFullName)
<span class="hljs-keyword">const</span> memoizeReduceAdd = memoize(reduceAdd)<font></font>
<font></font>
memoizedFullName(<span class="hljs-string">'Marko'</span>, <span class="hljs-string">'Polo'</span>)<font></font>
memoizedFullName(<span class="hljs-string">'Marko'</span>, <span class="hljs-string">'Polo'</span>) <span class="hljs-comment">//  </span><font></font>
<font></font>
memoizeReduceAdd([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<span class="hljs-number">5</span>)<font></font>
memoizeReduceAdd([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<span class="hljs-number">5</span>) <span class="hljs-comment">//  </span>
</code></pre><br>
<a name="69"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69. Â¿Por quÃ© typeof null devuelve objeto? </font><font style="vertical-align: inherit;">Â¿CÃ³mo verificar si un valor es nulo?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
typeof null == 'objeto' siempre devolverÃ¡ verdadero por razones histÃ³ricas. </font><font style="vertical-align: inherit;">Hubo una propuesta para corregir este error cambiando typeof null = 'object' a typeof null = 'null', pero fue rechazado en aras de mantener la compatibilidad con versiones anteriores (dicho cambio implicarÃ­a una gran cantidad de errores). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para verificar si el valor es nulo, puede usar el operador de igualdad estricta (===):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNull</span>(<span class="hljs-params">value</span>)</span>{
    <span class="hljs-keyword">return</span> value === <span class="hljs-literal">null</span><font></font>
}<font></font>
</code></pre><br>
<a name="70"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70. Â¿Para quÃ© se utiliza la palabra clave "nueva"?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La palabra clave "nuevo" se utiliza en las funciones de constructor para crear un nuevo objeto (una nueva instancia de la clase). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que tenemos un cÃ³digo como este:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">name, position, yearHired</span>)</span>{
    <span class="hljs-keyword">this</span>.name = name
    <span class="hljs-keyword">this</span>.position = position
    <span class="hljs-keyword">this</span>.yearHired = yearHired<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> emp = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">'Marko Polo'</span>, <span class="hljs-string">'Software Development'</span>, <span class="hljs-number">2017</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La palabra clave "nuevo" hace 4 cosas:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crea un objeto vacÃ­o.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vincula el valor de este a Ã©l.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una funciÃ³n hereda de functionName.prototype.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Devuelve esto a menos que se especifique lo contrario.</font></font></li>
</ol></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es486820/">https://habr.com/ru/post/es486820/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es486804/index.html">InformÃ¡tica sanitaria mundial: tecnologÃ­as en la nube</a></li>
<li><a href="../es486808/index.html">Prueba de embarazo electrÃ³nica de una farmacia: cÃ³mo funciona</a></li>
<li><a href="../es486810/index.html">Nueva interfaz de Odnoklassniki: lanzamiento de React en Java. Parte II</a></li>
<li><a href="../es486814/index.html">Zabbix: la topologÃ­a de red es clara y automÃ¡tica</a></li>
<li><a href="../es486818/index.html">Portar Quake a iPod Classic</a></li>
<li><a href="../es486822/index.html">[Por los muelles] Aleteo. Parte 4. Para desarrolladores web</a></li>
<li><a href="../es486824/index.html">Mal consejo al trabajar con ANTLR</a></li>
<li><a href="../es486826/index.html">CreaciÃ³n de un Viberbot completo en Django 2 y la API REST de Viber. Primera parte - Webhook</a></li>
<li><a href="../es486828/index.html">Food Design Digest, enero de 2020</a></li>
<li><a href="../es486832/index.html">Â¿CuÃ¡ntos aÃ±os pasa Taiga? No, no.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>