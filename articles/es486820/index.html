<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍✈️ 🤔 ✔️ 70 preguntas de la entrevista de Javascript 🖖🏾 🎥 👩‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¡Buen dia amigos! 
 
 Espero que este artículo sea útil tanto para desarrolladores novatos como para experimentados. 
 
 En preguntas que me pareciero...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>70 preguntas de la entrevista de Javascript</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486820/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Buen dia amigos! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que este artículo sea útil tanto para desarrolladores novatos como para experimentados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En preguntas que me parecieron más difíciles que otras, se dan referencias a literatura adicional. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agradecería los comentarios detallados. </font><font style="vertical-align: inherit;">Todos los comentarios se tendrán en cuenta al editar el artículo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces vamos.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70 preguntas de la entrevista de Javascript</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Preguntas: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. ¿Cuál es la diferencia entre nulo e indefinido? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. ¿Para qué se utiliza el operador &amp;&amp;? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. ¿Para qué se utiliza el operador "||"? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. ¿Usar el unario más (operador +) es la forma más rápida de convertir una cadena en un número? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. ¿Qué es un DOM? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. ¿Qué es la propagación de eventos? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. ¿Qué es el burbujeo de eventos? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. ¿Qué es la captura de eventos? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. ¿Cuál es la diferencia entre los métodos event.preventDefault () y event.stopPropagation ()? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. ¿Cómo aprender a usar el método event.preventDefault ()? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. ¿Por qué obj.someprop.x produce un error? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12. ¿Qué es un objetivo de evento o elemento de destino (event.target)?</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">13.      (event.currentTarget)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">14.      "=="  "==="?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">15.        false?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">16.     "!!"?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">17.       ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">18.    (Hoisting)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">19.     (Scope)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">20.    (Closures)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">21.    JS  ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">22.  ,    ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">23.     «use strict»?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">24.    this?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">25.    ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">26.   IIFE?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">27.     Function.prototype.apply?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">28.     Function.prototype.call?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">29.      call  apply?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">30.     Function.prototype.bind?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">31.        JS         ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">32.      (Higher Order Functions)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">33.    JS     (First-class Objects)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">34.      Array.prototype.map?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">35.      Array.prototype.filter?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">36.      Array.prototype.reduce?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">37.    arguments?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">38.   ,   ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">39.      b     ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">40.   ECMAScript?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">41.     JS  ES6  ECMAScript2015?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">42.       «var», «let»  «const»?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">43.     (Arrow Functions)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">44.    (Classes)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">45.     (Template Literals)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">46.     (Object Destructuring)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">47.    (Modules)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">48.    Set?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">49.      (Callback Function)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">50.    (Promises)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">51.   async/await?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">52.     spread-  rest-?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">53.      (Default Parameters)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">54.     (Wrapper Objects)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">55.             (Implicit and Explicit Coercion)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">56.   NaN?  ,    NaN?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">57.  ,    ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">58.  ,    ,          ( "%")?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">59.      ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">60.   AJAX?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">61.   JS  ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">62.      Object.freeze  Object.seal?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">63.      «in»   hasOwnProperty?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64. ¿Qué técnicas de trabajo con código asincrónico en JS conoces? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65. ¿Cuál es la diferencia entre una función normal y una expresión funcional? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">66. ¿Cómo llamar a una función en JS? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">67. ¿Qué es memorización o memorización? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68. ¿Cómo implementaría la función auxiliar de memorización? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69. ¿Por qué typeof null devuelve objeto? </font><font style="vertical-align: inherit;">¿Cómo verificar si un valor es nulo? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70. ¿Para qué se utiliza la palabra clave "nueva"?</font></font></a><br>
<br>
<a name="1"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. ¿Cuál es la diferencia entre nulo e indefinido?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comenzar, hablemos de lo que tienen en común. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, pertenecen a 7 "primitivas" JS (tipos primitivos):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> primitiveTypes = [<span class="hljs-string">'string'</span>, <span class="hljs-string">'number'</span>, <span class="hljs-string">'null'</span>, <span class="hljs-string">'undefined'</span>, <span class="hljs-string">'boolean'</span>, <span class="hljs-string">'symbol'</span>, <span class="hljs-string">'bigint'</span>]
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En segundo lugar, son valores falsos, es decir. </font><font style="vertical-align: inherit;">el resultado de convertirlos a booleanos usando Boolean () o el operador "!!" </font><font style="vertical-align: inherit;">Es falso:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien, ahora sobre las diferencias. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
undefined es el valor predeterminado:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una variable a la que no se le ha asignado ningún valor, es decir </font><font style="vertical-align: inherit;">una variable declarada pero no inicializada;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una función que no devuelve nada explícitamente, por ejemplo, console.log (1);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propiedad inexistente del objeto.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En estos casos, el motor JS establece el valor en indefinido.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> _thisIsUndefined
<span class="hljs-keyword">const</span> doNothing = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}
<span class="hljs-keyword">const</span> someObj = {
    <span class="hljs-attr">a</span>: <span class="hljs-string">'ay'</span>,
    <span class="hljs-attr">b</span>: <span class="hljs-string">'bee'</span>,
    <span class="hljs-attr">c</span>: <span class="hljs-string">'si'</span><font></font>
}<font></font>
<span class="hljs-built_in">console</span>.log(_thisIsUndefined) <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(doNothing()) <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(someObj[<span class="hljs-string">'d'</span>]) <span class="hljs-comment">// undefined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nulo es el "valor sin valor". </font><font style="vertical-align: inherit;">nulo es el valor que se asigna a la variable explícitamente. </font><font style="vertical-align: inherit;">En el siguiente ejemplo, obtenemos nulo cuando el método fs.readFile funciona sin errores:</font></font><br>
<br>
<pre><code class="javascript hljs">fs.readFile(<span class="hljs-string">'path/to/file'</span>, (e, data) =&gt; {
    <span class="hljs-built_in">console</span>.log(e) <span class="hljs-comment">//    null</span>
<span class="hljs-keyword">if</span>(e) {
    <span class="hljs-built_in">console</span>.log(e)<font></font>
}<font></font>
    <span class="hljs-built_in">console</span>.log(data)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al comparar nulo e indefinido, obtenemos verdadero cuando se usa el operador "==", y falso cuando se usa el operador "===". </font><font style="vertical-align: inherit;">Sobre por qué sucede esto, ver más abajo.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span>
</code></pre><br>
<a name="2"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. ¿Para qué se utiliza el operador &amp;&amp;?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El operador &amp;&amp; (lógico y) encuentra y devuelve el primer valor falso o el último operando cuando todos los valores son verdaderos. </font><font style="vertical-align: inherit;">Utiliza un cortocircuito para evitar costos innecesarios:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-number">1</span> &amp;&amp; []) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">' '</span> &amp;&amp; <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-number">5</span>) <span class="hljs-comment">// 5</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con la declaración if:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> router: Router = Router()<font></font>
<font></font>
router.get(<span class="hljs-string">'/endpoint'</span>, (req: Request, <span class="hljs-attr">res</span>: Response) =&gt; {
    <span class="hljs-keyword">let</span> conMobile: PoolConnection
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">//    </span>
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">if</span> (conMobile) {<font></font>
            conMobile.release()<font></font>
        }<font></font>
    }<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo mismo con el operador &amp;&amp;:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> router: Router = Router()<font></font>
<font></font>
router.get(<span class="hljs-string">'/endpoint'</span>, (req: Request, <span class="hljs-attr">res</span>: Response) =&gt; {
    <span class="hljs-keyword">let</span> conMobile: PoolConnection
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">//    </span>
    } <span class="hljs-keyword">catch</span> (e) {<font></font>
        conMobile &amp;&amp; conMobile.release()<font></font>
    }<font></font>
})<font></font>
</code></pre><br>
<a name="3"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. ¿Para qué se utiliza el operador "||"?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El operador "||" </font><font style="vertical-align: inherit;">(boolean o) encuentra y devuelve el primer valor verdadero. </font><font style="vertical-align: inherit;">También usa un cortocircuito. </font><font style="vertical-align: inherit;">Este operador se usó para asignar parámetros predeterminados en funciones antes de que los parámetros predeterminados se estandarizaran en ES6.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> || <span class="hljs-number">1</span> || <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// 1</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logName</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">let</span> n = name || Mark
    <span class="hljs-built_in">console</span>.log(n)<font></font>
}<font></font>
<font></font>
logName() <span class="hljs-comment">// Mark</span>
</code></pre><br>
<a name="4"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. ¿Usar el unario más (operador +) es la forma más rápida de convertir una cadena en un número?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Según </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , el operador + es de hecho la forma más rápida de convertir una cadena en un número, ya que no realiza ninguna operación en un valor que es un número.</font></font><br>
<br>
<a name="5"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. ¿Qué es un DOM?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El DOM o Document Object Model es una interfaz de programación de aplicaciones (API) para trabajar con documentos HTML y XML. </font><font style="vertical-align: inherit;">Cuando el navegador lee por primera vez ("analiza") el documento HTML, forma un objeto grande, un objeto realmente grande basado en el documento: el DOM. </font><font style="vertical-align: inherit;">El DOM es una estructura de árbol (árbol de documentos). </font><font style="vertical-align: inherit;">El DOM se usa para interactuar y cambiar la estructura del propio DOM o de sus elementos y nodos individuales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que tenemos este HTML:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"ie=edge"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document Object Model<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El DOM de este HTML tiene este aspecto: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ax/cg/id/axcgidsa8fghreeuyvbhfpga6yo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
en JS, el DOM está representado por un objeto Document. </font><font style="vertical-align: inherit;">El objeto Documento tiene una gran cantidad de métodos para trabajar con elementos, su creación, modificación, eliminación, etc.</font></font><br>
<br>
<a name="6"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. ¿Qué es la propagación de eventos?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando ocurre un evento en un elemento DOM, en realidad ocurre no solo en él. </font><font style="vertical-align: inherit;">El evento "se propaga" desde el objeto Window al elemento que lo llamó (event.target). </font><font style="vertical-align: inherit;">En este caso, el evento impregna (afecta) secuencialmente a todos los antepasados ​​del elemento objetivo. </font><font style="vertical-align: inherit;">La propagación de un evento tiene tres etapas o fases:</font></font><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fase de inmersión (captura, intercepción): se produce un evento en el objeto Ventana y desciende al objetivo del evento a través de todos sus antepasados.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fase objetivo es cuando el evento alcanza el elemento objetivo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fase ascendente: un evento se eleva desde event.target, pasa secuencialmente a través de todos sus antepasados ​​y llega al objeto Window.</font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/a3/9x/67/a39x67wkxdmcyzj-it5m2jmfxgg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lea más sobre la distribución de eventos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="7"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. ¿Qué es una ventana emergente de evento?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando ocurre un evento en un elemento DOM, afecta no solo a este elemento. </font><font style="vertical-align: inherit;">Un evento "emerge" (como una burbuja de aire en el agua), pasa del elemento que causó el evento (event.target) a su padre, luego se eleva aún más, al padre del padre del elemento, hasta que alcanza el objeto Window. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que tenemos este marcado:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grandparent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y tal JS:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEvent</span>(<span class="hljs-params">el, event, callback, isCapture = false</span>) </span>{
    <span class="hljs-keyword">if</span> (!el || !event || !callback || <span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">return</span><font></font>
<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> el === <span class="hljs-string">'string'</span>) {<font></font>
        el = <span class="hljs-built_in">document</span>.querySelector(el)<font></font>
    }<font></font>
    el.addEventListener(event, callback, isCapture)<font></font>
}<font></font>
<font></font>
addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'DOMContentLoaded'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.child'</span>)
    <span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.parent'</span>)
    <span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.grandparent'</span>)<font></font>
<font></font>
    addEvent(child, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(parent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(grandparent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'grandparent'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(<span class="hljs-string">'html'</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'html'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'document'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">window</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'window'</span>)<font></font>
    })<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método addEventListener tiene un tercer parámetro opcional: useCapture. </font><font style="vertical-align: inherit;">Cuando su valor es falso (el valor predeterminado), el evento comienza con la fase de ascenso. </font><font style="vertical-align: inherit;">Cuando su valor es verdadero, el evento comienza con la fase de inmersión (para los "oyentes" de los eventos adjuntos al objetivo del evento, el evento está en la fase objetivo, y no en las fases de inmersión o ascenso. Los eventos en la fase objetivo son activados por todos los oyentes en el elemento en el en el que se registraron independientemente del parámetro useCapture - aprox. </font><font style="vertical-align: inherit;">Si hacemos clic en el elemento hijo, la consola mostrará: hijo, padre, abuelo, html, documento, ventana. </font><font style="vertical-align: inherit;">Esto es lo que es una ventana emergente de evento.</font></font><br>
<br>
<a name="8"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. ¿Qué es un evento de inmersión?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando un evento ocurre en un elemento DOM, ocurre no solo en él. </font><font style="vertical-align: inherit;">En la fase de inmersión, el evento desciende del objeto Ventana al objetivo del evento a través de todos sus antepasados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Margen:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grandparent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JS:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEvent</span>(<span class="hljs-params">el, event, callback, isCapture = false</span>) </span>{
    <span class="hljs-keyword">if</span> (!el || !event || !callback || <span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">return</span><font></font>
<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> el === <span class="hljs-string">'string'</span>) {<font></font>
        el = <span class="hljs-built_in">document</span>.querySelector(el);<font></font>
    }<font></font>
    el.addEventListener(event, callback, isCapture)<font></font>
}<font></font>
<font></font>
addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'DOMContentLoaded'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.child'</span>)
    <span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.parent'</span>)
    <span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.grandparent'</span>)<font></font>
<font></font>
    addEvent(child, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child'</span>);<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(parent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(grandparent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'grandparent'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(<span class="hljs-string">'html'</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'html'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'document'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">window</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'window'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método addEventListener tiene un tercer parámetro opcional: useCapture. </font><font style="vertical-align: inherit;">Cuando su valor es falso (el valor predeterminado), el evento comienza con la fase de ascenso. </font><font style="vertical-align: inherit;">Cuando su valor es verdadero, el evento comienza con la fase de inmersión. </font><font style="vertical-align: inherit;">Si hacemos clic en el elemento hijo, veremos lo siguiente en la consola: ventana, documento, html, abuelo, padre, hijo. </font><font style="vertical-align: inherit;">Esta es la inmersión del evento.</font></font><br>
<br>
<a name="9"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. ¿Cuál es la diferencia entre los métodos event.preventDefault () y event.stopPropagation ()?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método event.preventDefault () deshabilita el comportamiento predeterminado de un elemento. </font><font style="vertical-align: inherit;">Si usa este método en el elemento de formulario, evitará que el formulario se envíe. </font><font style="vertical-align: inherit;">Si lo usa en el menú contextual, el menú contextual se deshabilitará (este método se usa a menudo en el teclado para redefinir el teclado, por ejemplo, al crear un reproductor de música / video o editor de texto - aprox. </font><font style="vertical-align: inherit;">El método event.stopPropagation () deshabilita la propagación del evento (su ascenso o inmersión).</font></font><br>
<br>
<a name="10"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. ¿Cómo aprender a usar el método event.preventDefault ()?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para hacer esto, podemos usar la propiedad event.defaulPrevented, que devuelve un valor booleano que sirve como indicador de aplicación al elemento del método event.preventDefault.</font></font><br>
<br>
<a name="11"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. ¿Por qué obj.someprop.x produce un error?</font></font></h4><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj = {}
<span class="hljs-built_in">console</span>.log(obj.someprop.x)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La respuesta es obvia: estamos intentando acceder a la propiedad x de la propiedad someprop, que no está definida. </font><font style="vertical-align: inherit;">obj .__ proto __.__ proto = nulo, por lo que se devuelve undefined y undefined no tiene la propiedad x.</font></font><br>
<br>
<a name="12"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12. ¿Qué es un objetivo de evento o elemento de destino (event.target)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En palabras simples, event.target es el elemento en el que ocurre el evento, o el elemento que provocó el evento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos el siguiente marcado:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"clickFunc(event)"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align: center; margin: 15px;
border: 1px solid red; border-radius: 3px;"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 25px; border: 1px solid royalblue; border-radius: 3px;"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 25px; border: 1px solid skyblue; border-radius: 3px;"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 10px"</span>&gt;</span><font></font>
                Button<font></font>
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y un JS tan simple:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickFunc</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-built_in">console</span>.log(event.target)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adjuntamos un "oyente" al div externo. </font><font style="vertical-align: inherit;">Sin embargo, si hacemos clic en el botón, obtenemos el diseño de este botón en la consola. </font><font style="vertical-align: inherit;">Esto nos permite concluir que el elemento que causó el evento es el botón en sí, y no los divs internos o externos.</font></font><br>
<br>
<a name="13"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13. ¿Cuál es el propósito actual del evento (event.currentTarget)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Event.currentTarget es el elemento al que está conectado el detector de eventos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Marcado similar:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"clickFunc(event)"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align: center;margin:15px;
border:1px solid red;border-radius:3px;"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 25px; border:1px solid royalblue;border-radius:3px;"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin:25px;border:1px solid skyblue;border-radius:3px;"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin:10px"</span>&gt;</span><font></font>
                Button<font></font>
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y un JS ligeramente modificado:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickFunc</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-built_in">console</span>.log(event.currentTarget)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adjuntamos al oyente al div externo. </font><font style="vertical-align: inherit;">Dondequiera que hagamos clic, ya sea un botón o uno de los div internos, en la consola siempre obtenemos el diseño del div externo. </font><font style="vertical-align: inherit;">Esto nos permite concluir que event.currentTarget es el elemento al que está conectado el detector de eventos.</font></font><br>
<br>
<a name="14"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14. ¿Cuál es la diferencia entre los operadores "==" y "==="?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diferencia entre el operador == (igualdad abstracta o no estricta) y el operador === (igualdad estricta) es que el primero compara los valores después de que se convierten o se convierten a un tipo (Coersion), y el segundo, sin dicha conversión . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos a cavar más profundo. </font><font style="vertical-align: inherit;">Y primero, hablemos de la transformación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una conversión es un proceso de convertir un valor a otro tipo, o más bien, un proceso de convertir los valores comparados a un tipo. </font><font style="vertical-align: inherit;">Al comparar, el operador "==" produce la llamada comparación implícita. </font><font style="vertical-align: inherit;">El operador "==" realiza algunas operaciones antes de comparar dos valores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que comparamos x e y. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El algoritmo es como sigue:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si x e y son del mismo tipo, la comparación se realiza utilizando el operador "===".</font></font></li>
<li> x = null  y = undefined  true.</li>
<li> x = undefined  y = null  true.</li>
<li> x = ,  y = ,  x == toNumber(y) ( y   ).</li>
<li> x = ,  y = ,  toNumber(x) == y ( x   ).</li>
<li> x =  ,  toNumber(x) == y.</li>
<li> y =  ,  x == toNumber(y).</li>
<li> x = ,   ,  y = ,  x == toPrimitive(y) ( y   ).</li>
<li> x = ,  y = ,   ,  toPrimitive(x) == y.</li>
<li> false.</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recuerde: para convertir un objeto en un "primitivo", el método toPrimitive primero usa el método valueOf, luego el método toString. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ejemplos: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yd/xe/tn/ydxetnfghjtfuex_p-em8v4emck.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
todos los ejemplos devuelven verdadero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primer ejemplo es la primera condición del algoritmo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo ejemplo es la cuarta condición. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tercero es el segundo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El cuarto es el séptimo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quinto - octavo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y el último es el décimo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t-/4k/ys/t-4kyszb4grfafbi7lazyyvq6dy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si utilizamos el operador "===", todos los ejemplos, excepto el primero, devolverán falso, ya que los valores en estos ejemplos son de diferentes tipos.</font></font><br>
<br>
<a name="15"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15. ¿Por qué el resultado de comparar dos objetos similares es falso?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> a = {
    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><font></font>
}<font></font>
<span class="hljs-keyword">let</span> b = {
    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><font></font>
}<font></font>
<span class="hljs-keyword">let</span> c = a<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(a === b) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(a === c) <span class="hljs-comment">// true ...</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En JS, los objetos y las primitivas se comparan de manera diferente. </font><font style="vertical-align: inherit;">Las primitivas se comparan por valor. </font><font style="vertical-align: inherit;">Objetos: por referencia o dirección en la memoria donde se almacena la variable. </font><font style="vertical-align: inherit;">Es por eso que el primer console.log devuelve falso y el segundo devuelve verdadero. </font><font style="vertical-align: inherit;">Las variables "a" y "c" se refieren al mismo objeto, mientras que las variables "a" y "b" se refieren a diferentes objetos con las mismas propiedades y valores.</font></font><br>
<br>
<a name="16"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16. ¿Para qué se usa el operador "!!"?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El operador "!!" </font><font style="vertical-align: inherit;">(doble negación) lleva el valor a su derecho a un valor lógico.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-string">''</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-number">0</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-string">' '</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!!{}) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!![]) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!![].length) <span class="hljs-comment">// false</span>
</code></pre><br>
<a name="17"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17. ¿Cómo escribir múltiples expresiones en una línea?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para esto podemos usar el operador "," (coma). </font><font style="vertical-align: inherit;">Este operador "se mueve" de izquierda a derecha y devuelve el valor de la última expresión u operando.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span><font></font>
<font></font>
x = (x++, x = addFive(x), x *= <span class="hljs-number">2</span>, x -= <span class="hljs-number">5</span>, x += <span class="hljs-number">10</span>)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addFive</span>(<span class="hljs-params">num</span>) </span>{
    <span class="hljs-keyword">return</span> num + <span class="hljs-number">5</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si imprimimos el valor de x en la consola, obtenemos 27. Primero, aumentamos el valor de x en uno (x = 6). </font><font style="vertical-align: inherit;">Luego llamamos a la función addFive () con el parámetro 6, al que agregamos 5 (x = 11). </font><font style="vertical-align: inherit;">Después de eso, multiplicamos el valor de x por 2 (x = 22). </font><font style="vertical-align: inherit;">Luego reste 5 (x = 17). </font><font style="vertical-align: inherit;">Y finalmente, suma 10 (x = 27).</font></font><br>
<br>
<a name="18"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18. ¿Qué es izar?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elevación es un término que describe el surgimiento de una variable o función en un ámbito global o funcional. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comprender qué es la elevación, debe comprender cuál es el contexto de ejecución. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El contexto de ejecución es el entorno en el que se ejecuta el código. El contexto de ejecución tiene dos fases: compilación y ejecución en sí. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compilacion. En esta fase, las expresiones funcionales y las variables declaradas usando la palabra clave "var" con el valor indefinido se elevan a la parte superior del alcance global (o funcional) (como si se moviera al comienzo de nuestro código. Esto explica por qué podemos llamar a las funciones antes de que anuncios - aprox.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Actuación. </font><font style="vertical-align: inherit;">En esta fase, las variables son valores asignados, y las funciones (o métodos de objetos) se llaman o ejecutan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recuerde: solo se generan expresiones funcionales y variables declaradas con la palabra clave "var". </font><font style="vertical-align: inherit;">Las funciones ordinarias y las funciones de flecha, así como las variables declaradas con las palabras clave "let" y "const", no se muestran. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que tenemos un código como este:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(y)<font></font>
y = <span class="hljs-number">1</span>
<span class="hljs-built_in">console</span>.log(y)
<span class="hljs-built_in">console</span>.log(greet(<span class="hljs-string">'Mark'</span>))<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> y
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos quedan indefinidos, 1 y '¡Hola Mark!'. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Así es como se ve la fase de compilación:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> y <span class="hljs-comment">//  undefined</span><font></font>
<font></font>
<span class="hljs-comment">//    </span><font></font>
<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-comment">/*
console.log(y)
y = 1
console.log(y)
console.log(greet('Mark'))
*/</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una vez completada la fase de compilación, la fase de ejecución comienza cuando se asignan valores a las variables y se llaman funciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede encontrar más información sobre la elevación </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="19"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19. ¿Qué es un alcance?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un ámbito es un lugar donde (o desde donde) tenemos acceso a variables o funciones. </font><font style="vertical-align: inherit;">JS tenemos tres tipos de ámbitos: global, funcional y de bloque (ES6). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alcance global: las variables y funciones declaradas en el espacio de nombres global tienen un alcance global y son accesibles desde cualquier parte del código.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> g = <span class="hljs-string">'global'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">globalFunc</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFunc</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(g) <span class="hljs-comment">//     g,    </span><font></font>
    }<font></font>
    innerFunc()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alcance funcional (alcance de una función): las variables, funciones y parámetros declarados dentro de una función solo están disponibles dentro de esta función.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFavouriteFunc</span>(<span class="hljs-params">a</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">var</span> b = <span class="hljs-string">'Hello '</span> + a<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> b<font></font>
}<font></font>
myFavouriteFunc(<span class="hljs-string">'World'</span>)<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// Uncaught ReferenceError: a is not defined</span>
<span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">//  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alcance del bloque: las variables (declaradas con las palabras clave "let" y "const") dentro del bloque ({}) solo están disponibles dentro de él.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testBlock</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">let</span> z = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> z<font></font>
}<font></font>
<font></font>
testBlock() <span class="hljs-comment">// Uncaught ReferenceError: z is not defined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un ámbito también es un conjunto de reglas mediante el cual se busca una variable. </font><font style="vertical-align: inherit;">Si la variable no existe en el alcance actual, su búsqueda se realiza más arriba en la visibilidad externa del alcance actual. </font><font style="vertical-align: inherit;">Si no hay una variable en el alcance externo, su búsqueda continúa hasta el alcance global. </font><font style="vertical-align: inherit;">Si se encuentra una variable en el ámbito global, la búsqueda se detiene; de ​​lo contrario, se genera una excepción. </font><font style="vertical-align: inherit;">La búsqueda se lleva a cabo por las áreas de visibilidad más cercanas a las actuales y se detiene al encontrar la variable. </font><font style="vertical-align: inherit;">Esto se llama la cadena de alcance.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-comment">//    -&gt;    -&gt;   </span><font></font>
<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> variable1 = <span class="hljs-string">'Comrades'</span>
<span class="hljs-keyword">var</span> variable2 = <span class="hljs-string">'Sayonara'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">var</span> variable1 = <span class="hljs-string">'World'</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">//   </span>
        <span class="hljs-keyword">var</span> variable2 = <span class="hljs-string">'Hello'</span>
        <span class="hljs-built_in">console</span>.log(variable2 + <span class="hljs-string">' '</span> + variable1)<font></font>
    }<font></font>
    inner()<font></font>
}<font></font>
outer()<font></font>
<span class="hljs-comment">//    'Hello World',</span>
<span class="hljs-comment">//   variable2 = 'Hello'  variable1 = 'World'  </span>
<span class="hljs-comment">//     </span>
</code></pre><br>
<img src="https://habrastorage.org/webt/r6/07/q7/r607q7hehfjmuicf0_icntddk2s.png"><br>
<br>
<a name="20"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20. ¿Qué es un cierre (cierres)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es probablemente la pregunta más difícil de la lista. Trataré de explicar cómo entiendo el cierre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, el cierre es la capacidad de una función para crear enlaces a variables y parámetros que están en el ámbito actual, en el ámbito de la función principal, en el ámbito del principal de la función principal, y así sucesivamente en el ámbito global utilizando la cadena de ámbitos en el momento de la creación. Normalmente, el alcance se determina cuando se crea una función. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los ejemplos son una excelente manera de explicar el cierre:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">'abc'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-built_in">console</span>.log(globalVar)<font></font>
}<font></font>
<font></font>
a() <span class="hljs-comment">// 'abc'</span>
<span class="hljs-comment">//   </span>
<span class="hljs-comment">//    a -&gt;   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, cuando declaramos una función, el alcance global es parte del cierre. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/10/ke/qa/10keqaosrww0rntbyei1gx9f_k0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La variable "globalVar" no importa en la imagen, porque su valor puede cambiar dependiendo de dónde y cuándo se llamará a la función. Pero en el ejemplo anterior, globalVar tendrá el valor "abc". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora el ejemplo es más complicado:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">'global'</span>
<span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">'outer'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outerFunc</span>(<span class="hljs-params">outerParam</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFunc</span>(<span class="hljs-params">innerParam</span>) </span>{
        <span class="hljs-built_in">console</span>.log(globalVar, outerParam, innerParam)<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> innerFunc<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> x = outerFunc(outerVar)<font></font>
outerVar = <span class="hljs-string">'outer-2'</span>
globalVar = <span class="hljs-string">'guess'</span>
x(<span class="hljs-string">'inner'</span>)
</code></pre><br>
<img src="https://habrastorage.org/webt/ms/dv/wx/msdvwxdxp5s3l4cquxnqgkdtyr0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado es "adivinar exterior interior". La explicación es esta: cuando llamamos a la función externalFunc y establecemos la variable "x" en el valor devuelto por la función innerFunc, el parámetro "externalParam" es igual a "exterior". A pesar del hecho de que asignamos la variable "externalVar" a "external-2", esto sucedió después de llamar a la función externalFunc, que "logró" encontrar el valor de la variable "outsideVar" en la cadena de alcance, este valor fue "externo". Cuando llamamos a "x", que se refiere a innerFunc, el valor de "innerParam" es "interno", porque pasamos este valor como parámetro cuando llamamos a "x". globalVar tiene un valor de "adivinar" porque le asignamos ese valor antes de llamar a "x". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un ejemplo de un malentendido de un circuito.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> arrFunc = []
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {<font></font>
    arrFunc.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> i<font></font>
    })<font></font>
}<font></font>
<span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">// 5</span><font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arrFunc.length; i++) {
    <span class="hljs-built_in">console</span>.log(arrFunc[i]()) <span class="hljs-comment">//  5</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este código no funciona como se esperaba. </font><font style="vertical-align: inherit;">Declarar una variable usando la palabra clave var hace que esta variable sea global. </font><font style="vertical-align: inherit;">Después de agregar funciones a la matriz arrFunc, el valor de la variable global "i" se convierte en "5". </font><font style="vertical-align: inherit;">Por lo tanto, cuando llamamos a la función, devuelve el valor de la variable global "i". </font><font style="vertical-align: inherit;">Un cierre almacena una referencia a una variable, no su valor en el momento de la creación. </font><font style="vertical-align: inherit;">Este problema puede resolverse usando IIFE o declarando una variable usando la palabra clave "let". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lea más sobre el cierre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="21"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21. ¿Qué valores en JS son falsos?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> falsyValues = [<span class="hljs-string">''</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-literal">false</span>]
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Falso son valores cuya conversión a un valor booleano es falsa.</font></font><br>
<br>
<a name="22"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22. ¿Cómo verificar si un valor es falso?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilice la función booleana o el operador "!!" </font><font style="vertical-align: inherit;">(dos veces no).</font></font><br>
<br>
<a name="23"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">23. ¿Para qué se usa la directiva estricta de uso?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Usar estricto" es una directiva ES5 que obliga a ejecutar todo nuestro código o el código de una función individual en modo estricto. </font><font style="vertical-align: inherit;">El modo estricto introduce algunas restricciones en la escritura de código, evitando así errores en las primeras etapas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí están las limitaciones del modo estricto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No puede asignar valores ni acceder a variables no declaradas:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnY</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-string">'use strict'</span>
    y = <span class="hljs-number">123</span>
    <span class="hljs-keyword">return</span> y<font></font>
}<font></font>
returnY() <span class="hljs-comment">// Uncaught ReferenceError: y is not defined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Está prohibido asignar valores globales a variables de solo lectura o de solo escritura:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span>
<span class="hljs-keyword">var</span> <span class="hljs-literal">NaN</span> = <span class="hljs-literal">NaN</span> <span class="hljs-comment">// Uncaught TypeError: Cannot assign to read only property 'NaN' of object '#&lt;Window&gt;'</span>
<span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-keyword">var</span> <span class="hljs-literal">Infinity</span> = <span class="hljs-string">'and beyond'</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No puede eliminar la propiedad "indeleble" de un objeto:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span>
<span class="hljs-keyword">const</span> obj = {}<font></font>
<font></font>
<span class="hljs-built_in">Object</span>.defineProperties(obj, <span class="hljs-string">'x'</span>, {
    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><font></font>
})<font></font>
<font></font>
<span class="hljs-keyword">delete</span> obj.x <span class="hljs-comment">// Uncaught TypeError: Property description must be an object: x</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La duplicación de parámetros está prohibida:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someFunc</span>(<span class="hljs-params">a, b, b, c</span>) </span>{} <span class="hljs-comment">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No puede crear funciones con la función eval:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span><font></font>
<font></font>
<span class="hljs-built_in">eval</span>(<span class="hljs-string">'var x = 1'</span>)<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(x) <span class="hljs-comment">// Uncaught ReferenceError: x is not defined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El valor predeterminado para esto no está definido:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMeThis</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><font></font>
}<font></font>
<font></font>
showMeThis() <span class="hljs-comment">// undefined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... etc.</font></font><br>
<br>
<a name="24"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24. ¿Qué significa esto?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto generalmente se refiere al valor del objeto que actualmente está ejecutando o llamando a la función. </font><font style="vertical-align: inherit;">"En este momento" significa que el valor de esto varía según el contexto de ejecución, donde usamos esto.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> carDetails = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Ford Mustang'</span>,
    <span class="hljs-attr">yearBought</span>: <span class="hljs-number">2005</span>,<font></font>
    getName() {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name<font></font>
    }<font></font>
    <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">true</span><font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(carDetails.getName()) <span class="hljs-comment">// Ford Mustang</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, el método getName devuelve this.name, y esto se refiere a carDetails, el objeto en el que se ejecuta getName, que es su "propietario". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregue tres líneas después de console.log:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'Ford Ranger'</span>
<span class="hljs-keyword">var</span> getCarName = carDetails.getName<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(getCarName()) <span class="hljs-comment">// Ford Ranger</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo console.log produce un Ford Ranger, y esto es extraño. </font><font style="vertical-align: inherit;">La razón de este comportamiento es que el "propietario" de getCarName es el objeto de la ventana. </font><font style="vertical-align: inherit;">Las variables declaradas con la palabra clave var en el ámbito global se escriben en las propiedades del objeto de ventana. </font><font style="vertical-align: inherit;">esto en el ámbito global se refiere al objeto de la ventana (a menos que sea un modo estricto).</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(getCarName === <span class="hljs-built_in">window</span>.getCarName) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(getCarName === <span class="hljs-keyword">this</span>.getCarName) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, this y window se refieren al mismo objeto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una forma de resolver este problema es usar la llamada o aplicar métodos:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(getCarName.apply(carDetails)) <span class="hljs-comment">// Ford Mustang</span>
<span class="hljs-built_in">console</span>.log(getCarName.call(carDetails)) <span class="hljs-comment">// Ford Mustang</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Llame y aplique tomar como primer argumento un objeto que será el valor de esto dentro de la función. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En IIFE, funciones que se crean en el ámbito global, funciones anónimas y funciones internas de los métodos de un objeto, el valor predeterminado para esto es el objeto de ventana.</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)<font></font>
})() <span class="hljs-comment">// window</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iHateThis</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)<font></font>
}<font></font>
iHateThis() <span class="hljs-comment">// window</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> myFavouriteObj = {<font></font>
    guessThis() {<font></font>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<font></font>
        }<font></font>
        getName()<font></font>
    },<font></font>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span>,<font></font>
    thisIsAnnoying(callback) {<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
<font></font>
myFavouriteObj.guessThis() <span class="hljs-comment">// window</span>
myFavouriteObj.thisIsAnnoying(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// window</span><font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay dos formas de obtener Marko Polo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, podemos almacenar el valor de esto en una variable:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myFavoriteObj = {<font></font>
    guessThis() {<font></font>
        <span class="hljs-keyword">const</span> self = <span class="hljs-keyword">this</span> <span class="hljs-comment">//   this   self</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(self.name)<font></font>
        }<font></font>
        getName()<font></font>
    },<font></font>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span>,<font></font>
    thisIsAnnoying(callback) {<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En segundo lugar, podemos usar la función de flecha:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myFavoriteObj = {<font></font>
    guessThis() {<font></font>
        <span class="hljs-keyword">const</span> getName = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            <span class="hljs-comment">//   this   </span>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<font></font>
        }<font></font>
        getName()<font></font>
    },<font></font>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span>,<font></font>
    thisIsAnnoying(callback) {<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las funciones de flecha no tienen este valor propio. </font><font style="vertical-align: inherit;">Copian el significado de esto del entorno léxico externo.</font></font><br>
<br>
<a name="25"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25. ¿Qué es un prototipo de un objeto?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En pocas palabras, un prototipo es un plan (diagrama o proyecto) de un objeto. </font><font style="vertical-align: inherit;">Se utiliza como reserva para las propiedades y métodos existentes en este objeto. </font><font style="vertical-align: inherit;">También es una de las formas de intercambiar propiedades y funcionalidades entre objetos. </font><font style="vertical-align: inherit;">Este es el concepto básico de herencia prototipo en JS.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o = {}
<span class="hljs-built_in">console</span>.log(o.toString()) <span class="hljs-comment">// [object Object]</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aunque el objeto "o" no tiene la propiedad toString, acceder a esta propiedad no causa un error. </font><font style="vertical-align: inherit;">Si una propiedad específica no está en el objeto, su búsqueda se lleva a cabo primero en el prototipo del objeto, luego en el prototipo del prototipo del objeto, y así sucesivamente hasta que se encuentre la propiedad. </font><font style="vertical-align: inherit;">Esto se llama la cadena prototipo. </font><font style="vertical-align: inherit;">En la parte superior de la cadena de prototipos se encuentra Object.prototype.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(o.toString === <span class="hljs-built_in">Object</span>.prototype.toString) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lea más sobre prototipos y herencia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="26"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26. ¿Qué es el IIFE?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IIFE o Expresión de función invocada inmediatamente es una función que se llama o ejecuta inmediatamente después de la creación o declaración. </font><font style="vertical-align: inherit;">Para crear IIFE, debe ajustar la función entre paréntesis (el operador de agrupación), convertirla en una expresión y luego llamarla usando otros paréntesis. </font><font style="vertical-align: inherit;">Se ve así: (function () {}) ().</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> </span>) </span>{ }( ))<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> </span>) </span>{ })( )<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">named</span>(<span class="hljs-params">params</span>) </span>{ })( )<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-params">( )</span> =&gt;</span> { })<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">global</span>) </span>{ })(<span class="hljs-built_in">window</span>)<font></font>
<font></font>
<span class="hljs-keyword">const</span> utility = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> </span>) </span>{
    <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">// </span><font></font>
    }<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos estos ejemplos son válidos. </font><font style="vertical-align: inherit;">El penúltimo ejemplo muestra que podemos pasar parámetros a IIFE. </font><font style="vertical-align: inherit;">El último ejemplo muestra que podemos almacenar el resultado de IIFE en una variable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mejor uso de IIFE es realizar funciones de configuración de inicialización y evitar conflictos de nombres con otras variables en el ámbito global (contaminación del espacio de nombres global). </font><font style="vertical-align: inherit;">Damos un ejemplo.</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script src=<span class="hljs-string">"https://cdnurl.com/somelibrary.js"</span>&gt;&lt;/script&gt;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos un enlace a la biblioteca somelibrary.js que proporciona algunas funciones globales que podemos usar en nuestro código, pero hay dos métodos en esta biblioteca, createGraph y drawGraph, que no usamos porque contienen errores. </font><font style="vertical-align: inherit;">Y queremos implementar estas funciones por nuestra cuenta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una forma de resolver este problema es cambiar la estructura de nuestros scripts:</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script src=<span class="hljs-string">"https://cdnurl.com/somelibrary.js"</span>&gt;&lt;/script&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, redefinimos los métodos proporcionados por la biblioteca. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La segunda forma es cambiar los nombres de nuestras funciones:</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script src=<span class="hljs-string">"https://cdnurl.com/somelibrary.js"</span>&gt;&lt;/script&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCreateGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myDrawGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tercera forma es usar IIFE:</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script&gt;
    <span class="hljs-keyword">const</span> graphUtility = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createGraph</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">// </span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawGraph</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">// </span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> {<font></font>
            createGraph,<font></font>
            drawGraph<font></font>
        }<font></font>
    })<font></font>
&lt;/script&gt;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, creamos una variable de utilidad que contiene el resultado IIFE, que devuelve un objeto que contiene los métodos createGraph y drawGraph. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí hay otro problema que se puede resolver con IIFE:</font></font><br>
<br>
<pre><code class="javascript hljs">val li = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.list-group &gt; li'</span>)
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i - <span class="hljs-number">0</span>, len = li.length; i &lt; len; i++) {<font></font>
    li[i].addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(i)<font></font>
    })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que tenemos un elemento ul con una clase de grupo de lista que contiene 5 elementos secundarios li. </font><font style="vertical-align: inherit;">Y queremos mostrar el valor "i" en la consola al hacer clic en un "li" separado. </font><font style="vertical-align: inherit;">Sin embargo, en cambio, la consola siempre muestra 5. La falla es toda la culpa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una solución es IIFE:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.list-group &gt; li'</span>)
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = li.length; i &lt; len; i++) {<font></font>
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentIndex</span>) </span>{<font></font>
        li[currentIndex].addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
            <span class="hljs-built_in">console</span>.log(currentIndex)<font></font>
        })<font></font>
    })(i)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La razón por la que este código funciona según lo previsto es porque IIFE crea un nuevo alcance en cada iteración, y escribimos el valor "i" en currentIndex.</font></font><br>
<br>
<a name="27"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">27. ¿Para qué se utiliza el método Function.prototype.apply?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aplicar se utiliza para vincular un objeto específico al valor de este de la función llamada.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> details = {
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello World!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMessage</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.message<font></font>
}<font></font>
<font></font>
getMessage.apply(details) <span class="hljs-comment">// Hello World!</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este método es similar a Function.prototype.call. </font><font style="vertical-align: inherit;">La única diferencia es que en apply, los argumentos se pasan como una matriz.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> person = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeting</span>(<span class="hljs-params">greetingMessage</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${greetingMessage}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
}<font></font>
<font></font>
greeting.apply(person, [<span class="hljs-string">'Hello'</span>]) <span class="hljs-comment">// Hello Marko Polo</span>
</code></pre><br>
<a name="28"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28. ¿Para qué se utiliza el método function.prototype.call?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La llamada se utiliza para vincular un objeto específico al valor de esta función que se llama.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> details = {
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello World!'</span><font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMessage</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.message;<font></font>
}<font></font>
<font></font>
getMessage.call(details); <span class="hljs-comment">// Hello World!</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este método es similar a Function.prototype.apply. </font><font style="vertical-align: inherit;">La diferencia es que en la llamada los argumentos se pasan separados por comas.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> person = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span><font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeting</span>(<span class="hljs-params">greetingMessage</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${greetingMessage}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span>;<font></font>
}<font></font>
<font></font>
greeting.call(person, <span class="hljs-string">'Hello'</span>); <span class="hljs-comment">// Hello Marko Polo</span>
</code></pre><br>
<a name="29"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">29. ¿Cuál es la diferencia entre llamar y aplicar métodos?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diferencia entre llamar y aplicar es cómo pasamos argumentos en la función llamada. </font><font style="vertical-align: inherit;">En apply, los argumentos se pasan como una matriz, en llamada, separados por comas.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj1 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> obj2 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduceAdd</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) {<font></font>
        result += <span class="hljs-built_in">arguments</span>[i]<font></font>
    }<font></font>
    <span class="hljs-keyword">this</span>.result = result<font></font>
}<font></font>
<font></font>
reduceAdd.apply(obj1, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]) <span class="hljs-comment">// 15</span>
reduceAdd.call(obj2, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 15</span>
</code></pre><br>
<a name="30"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30. ¿Para qué se utiliza el método function.prototype.bind?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bind devuelve una nueva función cuyo valor es el objeto especificado como primer parámetro. </font><font style="vertical-align: inherit;">A diferencia de bind, call y apply llama inmediatamente a la función.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props)
        <span class="hljs-keyword">this</span>.state = {
            <span class="hljs-attr">value</span>: <span class="hljs-string">''</span><font></font>
        }<font></font>
        <span class="hljs-keyword">this</span>.handleChange = <span class="hljs-keyword">this</span>.handleChange.bind(<span class="hljs-keyword">this</span>)
        <span class="hljs-comment">//   handleChange   MyComponent</span><font></font>
    }<font></font>
<font></font>
    handleChange(e) {<font></font>
        <span class="hljs-comment">// </span><font></font>
    }<font></font>
<font></font>
    render() {<font></font>
        <span class="hljs-keyword">return</span> ( &lt; &gt;<font></font>
            &lt;<font></font>
            input type = {<font></font>
                <span class="hljs-keyword">this</span>.props.type<font></font>
            }<font></font>
            value = {<font></font>
                <span class="hljs-keyword">this</span>.state.value<font></font>
            }<font></font>
            onChange = {<font></font>
                <span class="hljs-keyword">this</span>.handleChange<font></font>
            }<font></font>
            /&gt; &lt;/ &gt;<font></font>
        )<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<a name="31"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">31. ¿Qué es la programación funcional y qué características de JS nos permiten hablar de ella como lenguaje de programación funcional?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La programación funcional es un concepto de programación declarativa o un ejemplo (patrón) de cómo se crean las aplicaciones, cómo se utilizan las funciones que contienen expresiones que calculan valores sin cambiar los argumentos que se les pasan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El objeto Array contiene los métodos de mapa, filtro y reducción, que son las funciones más famosas en el mundo de la programación funcional debido a su utilidad y también porque no modifican la matriz, lo que hace que estas funciones sean "limpias". </font><font style="vertical-align: inherit;">JS también tiene un cierre y funciones de orden superior que son características de un lenguaje de programación funcional. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método map devuelve una nueva matriz con resultados de devolución de llamada para cada elemento de la matriz:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> words = [<span class="hljs-string">'Functional'</span>, <span class="hljs-string">'Procedural'</span>, <span class="hljs-string">'Object-Oriented'</span>]<font></font>
<font></font>
<span class="hljs-keyword">const</span> wordsLength = words.map(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word.length)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método de filtro crea una nueva matriz con todos los elementos que satisfacen la condición especificada en la devolución de llamada:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> data = {<font></font>
    {<font></font>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Mark'</span>,
        <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">true</span><font></font>
    } {<font></font>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Mary'</span>,
        <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">false</span><font></font>
    } {<font></font>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Mae'</span>,
        <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">true</span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> registeredUsers = data.filter(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.isRegistered)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método reduce realiza una devolución de llamada una vez para cada elemento de la matriz, con la excepción de los vacíos, tomando cuatro argumentos: el valor inicial (o el valor de la devolución de llamada anterior), el valor del elemento actual, el índice actual y la matriz iterada:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> strs = [<span class="hljs-string">'I'</span>, <span class="hljs-string">' '</span>, <span class="hljs-string">'am'</span>, <span class="hljs-string">' '</span>, <span class="hljs-string">'Iron'</span>, <span class="hljs-string">' '</span>, <span class="hljs-string">'Man'</span>]<font></font>
<font></font>
<span class="hljs-keyword">const</span> result = strs.reduce(<span class="hljs-function">(<span class="hljs-params">acc, currentStr</span>) =&gt;</span> acc + str, <span class="hljs-string">''</span>)
</code></pre><br>
<a name="32"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32. ¿Qué son las funciones de orden superior?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una función de orden superior es una función que devuelve otra función o acepta otra función como argumento.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">higherOrderFunction</span>(<span class="hljs-params">param, callback</span>) </span>{
    <span class="hljs-keyword">return</span> callback(param)<font></font>
}<font></font>
</code></pre><br>
<a name="33"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">33. ¿Por qué las funciones en JS se denominan objetos de primera clase?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las funciones se denominan objetos de primera clase porque se procesan como cualquier otro valor en JS. </font><font style="vertical-align: inherit;">Se pueden asignar a variables, ser una propiedad de un objeto (método), un elemento de una matriz, un argumento para otra función, el valor devuelto por la función. </font><font style="vertical-align: inherit;">La única diferencia entre una función y cualquier otro valor en JS es que la función se puede ejecutar o invocar.</font></font><br>
<br>
<a name="34"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">34. ¿Cómo implementaría el método Array.prototype.map?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">arr, mapCallback</span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr) || !arr.length || <span class="hljs-keyword">typeof</span> mapCallback !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> []<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">let</span> result = []
        <span class="hljs-comment">//         </span>
        <span class="hljs-comment">//       </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) {<font></font>
            result.push(mapCallback(arr[i], i, arr))<font></font>
            <span class="hljs-comment">//   mapCallback  result</span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método map crea una nueva matriz con el resultado de llamar a la función especificada para cada elemento de la matriz.</font></font><br>
<br>
<a name="35"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">35. ¿Cómo implementaría el método Array.prototype.filter?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span>(<span class="hljs-params">arr, filterCallback</span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr) || !arr.length || <span class="hljs-keyword">typeof</span> filterCallback !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> []<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">let</span> result = []
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) {
            <span class="hljs-comment">//      </span>
            <span class="hljs-keyword">if</span> (filterCallback(arr[i], i, arr)) {
                <span class="hljs-comment">//  ,  ,  result</span><font></font>
                result.push(arr[i])<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método de filtro crea una nueva matriz con todos los elementos que pasaron la prueba especificada en la función que se pasa.</font></font><br>
<br>
<a name="36"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">36. ¿Cómo implementaría el método Array.prototype.reduce?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduce</span>(<span class="hljs-params">arr, reduceCallbak, initialValue</span>) </span>{
    <span class="hljs-comment">// ..</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr) || !arr.length || <span class="hljs-keyword">typeof</span> filterCallback !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> []<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//        initialValue, </span>
        <span class="hljs-keyword">let</span> hasInitialValue = initialValue !== <span class="hljs-literal">undefined</span>
        <span class="hljs-keyword">let</span> value = hasInitialValue ? initialValue : arr[<span class="hljs-number">0</span>]
        <span class="hljs-comment">//      initialValue</span><font></font>
<font></font>
        <span class="hljs-comment">//    ,   1,       initialValue,   0,    </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = hasInitialValue ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>, len = arr.length; i &lt; len; i++) {
            <span class="hljs-comment">//         reduceCallback </span><font></font>
            value = reduceCallback(value, arr[i], i, arr)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> value<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método reduce aplica la función reductora a cada elemento de la matriz (de izquierda a derecha), devolviendo un valor resultante.</font></font><br>
<br>
<a name="37"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">37. ¿Qué es un objeto de argumentos?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Argumentos es una colección de argumentos pasados ​​a una función. </font><font style="vertical-align: inherit;">Este es un objeto tipo matriz, tiene la propiedad de longitud, podemos acceder a un valor específico usando argumentos [i], pero no tiene los métodos forEach, reduce, filter y map. </font><font style="vertical-align: inherit;">Le permite averiguar el número de parámetros de función. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede convertir argumentos en una matriz usando Array.prototype.slice:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recuerde: en las funciones de flecha, el objeto de argumentos no funciona.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">one</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span><font></font>
}<font></font>
<span class="hljs-keyword">const</span> two = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span><font></font>
}<font></font>
<span class="hljs-keyword">const</span> three = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">three</span>(<span class="hljs-params">{
    return arguments
}</span>)
<span class="hljs-title">const</span> <span class="hljs-title">four</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title">arguments</span>

<span class="hljs-title">four</span>(<span class="hljs-params"></span>) // <span class="hljs-title">arguments</span> <span class="hljs-title">is</span> <span class="hljs-title">not</span> <span class="hljs-title">defined</span>
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Llamar a las cuatro funciones da como resultado un Error de referencia: los argumentos no son un error definido. </font><font style="vertical-align: inherit;">Este problema se puede resolver utilizando la declaración rest:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> four = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> args
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto colocará automáticamente todos los parámetros en una matriz.</font></font><br>
<br>
<a name="38"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">38. ¿Cómo crear un objeto que no tiene un prototipo?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto se puede hacer usando Object.create:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o1 = {}
<span class="hljs-built_in">console</span>.log(o1.toString) <span class="hljs-comment">// [object Object]</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> o2 = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>) <span class="hljs-comment">//      Object-create  -</span>
<span class="hljs-comment">//    -,   null</span>
<span class="hljs-built_in">console</span>.log(o2.toString) <span class="hljs-comment">// o2.toString is not a function</span>
</code></pre><br>
<a name="39"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">39. ¿Por qué en el código presentado la variable b se vuelve global cuando se llama a la función?</font></font></h4><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> a = b = <span class="hljs-number">0</span><font></font>
}<font></font>
myFunc()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto sucede porque el operador de asignación ("=") tiene asociatividad diestra, es decir </font><font style="vertical-align: inherit;">asigna valores de derecha a izquierda. </font><font style="vertical-align: inherit;">Por lo tanto, el código toma la siguiente forma:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> a = (b = <span class="hljs-number">0</span>)<font></font>
}<font></font>
myFunc()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, el valor 0 se asigna a la variable "b", que no se declara. </font><font style="vertical-align: inherit;">El motor JS lo hace global. </font><font style="vertical-align: inherit;">El valor (0) devuelto por b = 0 se asigna a la variable local "a". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este problema se puede resolver declarando primero las variables locales y luego asignándoles valores:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> a, b<font></font>
    a = b = <span class="hljs-number">0</span><font></font>
}<font></font>
myFunc()<font></font>
</code></pre><br>
<a name="40"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">40. ¿Qué es ECMAScript?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ECMAScript es una especificación, un lenguaje de programación de secuencias de comandos estándar, es la base de JS, por lo que cualquier cambio en ECMAScript se refleja en JS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La última versión de la especificación ECMA-262 se puede ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="41"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">41. ¿Qué cosas nuevas trajo ES6 o ECMAScript2015 a JS?</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funciones de flecha</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clases</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cadenas de plantilla.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literales de objetos mejorados</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desestructuración (Desestructuración de objetos).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promesas promesas).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generadores</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Módulos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Símbolo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proxies</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conjuntos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las opciones por defecto.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descansar y extender operadores.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alcance del bloque (palabras clave "let" y "const").</font></font></li>
</ul><br>
<a name="42"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">42. ¿Cuál es la diferencia entre las palabras clave "var", "let" y "const"?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las variables declaradas con la palabra clave var son globales. </font><font style="vertical-align: inherit;">Esto significa que son accesibles desde cualquier parte del código:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeX</span>(<span class="hljs-params">showX</span>)</span>{
    <span class="hljs-keyword">if</span>(showX){
        <span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> x<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(giveMeX(<span class="hljs-literal">false</span>))
<span class="hljs-built_in">console</span>.log(giveMeX(<span class="hljs-literal">true</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado del primer console.log será indefinido, el segundo - 5. Tenemos acceso a la variable "x" debido a su aparición en el ámbito global. </font><font style="vertical-align: inherit;">El código del ejemplo anterior se interpreta de la siguiente manera:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeX</span>(<span class="hljs-params">showX</span>)</span>{
    <span class="hljs-keyword">var</span> x <span class="hljs-comment">//   undefined</span>
    <span class="hljs-keyword">if</span>(showX){<font></font>
        x = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> x<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado del primer console.log no está definido, porque las variables declaradas a las que no se les asigna un valor no están definidas de manera predeterminada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las variables declaradas usando las palabras clave "let" y "const" tienen un alcance de bloque. </font><font style="vertical-align: inherit;">Esto significa que solo están disponibles dentro del bloque ({}):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeX</span>(<span class="hljs-params">showX</span>)</span>{
    <span class="hljs-keyword">if</span>(showX){
        <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> x<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeY</span>(<span class="hljs-params">showY</span>)</span>{
    <span class="hljs-keyword">if</span>(showY){
        <span class="hljs-keyword">let</span> y = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> y<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Llamar a estas funciones con el parámetro falso dará como resultado un error de Error de referencia, porque las variables "x" e "y" no son accesibles fuera del bloque y sus valores no se devuelven (no aparece). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diferencia entre "let" y "const" es que en el primer caso podemos cambiar el valor de la variable, y en el segundo - no (constante). </font><font style="vertical-align: inherit;">Al mismo tiempo, podemos cambiar el valor de la propiedad de un objeto declarado usando const, pero no la propiedad en sí (variable).</font></font><br>
<br>
<a name="43"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">43. ¿Qué son las funciones de flecha (Funciones de flecha)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La función de flecha es una forma relativamente nueva de crear funciones en JS. </font><font style="vertical-align: inherit;">Las funciones de flecha son más rápidas y tienen una sintaxis más legible que las expresiones funcionales. </font><font style="vertical-align: inherit;">En las funciones de flecha, se omite la palabra "función":</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> getCurrentDate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> getCurrentDate = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En una expresión funcional, usamos la palabra clave return para devolver un valor. </font><font style="vertical-align: inherit;">En la función de flecha, no hacemos esto, ya que las funciones de flecha devuelven valores implícitamente, siempre que devolvamos una sola expresión o valor:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span> <font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> greet = <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>
<span class="hljs-keyword">const</span> greet2 = name = &gt; <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También podemos pasar parámetros a las funciones de flecha. </font><font style="vertical-align: inherit;">Si pasamos un parámetro, no tenemos que ponerlo entre paréntesis:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> getArgs = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">arguments</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> getArgs2 = <span class="hljs-function">(<span class="hljs-params">...rest</span>) =&gt;</span> rest
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las funciones de flecha no tienen acceso al objeto de argumentos. </font><font style="vertical-align: inherit;">Por lo tanto, llamar a la primera función dará como resultado un error. </font><font style="vertical-align: inherit;">Para que los parámetros pasen a la función, podemos usar el operador rest.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> data = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span>
    <span class="hljs-attr">nums</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<font></font>
    computeResult(){<font></font>
        <span class="hljs-comment">// this    data</span>
        <span class="hljs-keyword">const</span> addAll = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-comment">//     this   </span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nums.reduce(<span class="hljs-function">(<span class="hljs-params">total, cur</span>) =&gt;</span> total + cur, <span class="hljs-number">0</span>)<font></font>
        }<font></font>
    <span class="hljs-keyword">this</span>.result = addAll()<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<a name="44"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">44. ¿Qué son las clases?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las clases son una forma relativamente nueva de escribir funciones de constructor en JS. </font><font style="vertical-align: inherit;">Este es el azúcar sintáctico para las funciones de constructor. </font><font style="vertical-align: inherit;">Las clases se basan en los mismos prototipos y herencia del prototipo:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">firstName, lastName, age, address</span>)</span>{
    <span class="hljs-keyword">this</span>.firstName = firstName
    <span class="hljs-keyword">this</span>.lastName = lastName
    <span class="hljs-keyword">this</span>.age = age
    <span class="hljs-keyword">this</span>.address = address<font></font>
}<font></font>
<font></font>
Person.self = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><font></font>
}<font></font>
<font></font>
Person.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Person]'</span><font></font>
}<font></font>
<font></font>
Person.prototype.getFullName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.lastName<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>{
    <span class="hljs-keyword">constructor</span>(firstName, lastName, age, address){
        <span class="hljs-keyword">this</span>.firstName = firstName
        <span class="hljs-keyword">this</span>.lastName = lastName
        <span class="hljs-keyword">this</span>.age = age
        <span class="hljs-keyword">this</span>.address = address<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> self(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><font></font>
    }<font></font>
<font></font>
    toString(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Person]'</span><font></font>
    }<font></font>
<font></font>
    getFullName(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.firstName}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.lastName}</span>`</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método reemplaza y hereda de otra clase:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
Employee.prototype = <span class="hljs-built_in">Object</span>.create(Person.prototype)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">firstName, lastName, age, address, jobTitle, yearStarted</span>)</span>{<font></font>
    Person.call(<span class="hljs-keyword">this</span>, firstName, lastName, age, address)
    <span class="hljs-keyword">this</span>.jobTitle = jobTitle
    <span class="hljs-keyword">this</span>.yearStarted = yearStarted<font></font>
}<font></font>
<font></font>
Employee.prototype.describe = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`I am <span class="hljs-subst">${<span class="hljs-keyword">this</span>.getFullName()}</span> and I have a position of #{this.jobTitle} and I started at <span class="hljs-subst">${<span class="hljs-keyword">this</span>.yearStarted}</span>}`</span><font></font>
}<font></font>
<font></font>
Employee.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Employee]'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>{ <span class="hljs-comment">//   Person</span>
    <span class="hljs-keyword">constructor</span>(firstName, lastName, age, address, jobTitle, yearStarted){
        <span class="hljs-keyword">super</span>(firstName, lastName, age, address)
        <span class="hljs-keyword">this</span>.jobTitle = jobTitle
        <span class="hljs-keyword">this</span>.yearStarted = yearStarted<font></font>
    }<font></font>
<font></font>
    describe(){<font></font>
       <span class="hljs-keyword">return</span> <span class="hljs-string">`I am <span class="hljs-subst">${<span class="hljs-keyword">this</span>.getFullName()}</span> and I have a position of #{this.jobTitle} and I started at <span class="hljs-subst">${<span class="hljs-keyword">this</span>.yearStarted}</span>}`</span> <font></font>
    }<font></font>
<font></font>
    toString(){ <span class="hljs-comment">//   toString  Person</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Employee]'</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cómo aprender sobre el uso de prototipos?</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Something</span></span>{ }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AnotherSomething</span>(<span class="hljs-params"></span>)</span>{ }<font></font>
<font></font>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">as</span> = <span class="hljs-keyword">new</span> AnotherSomething()
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Something()<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> Something) <span class="hljs-comment">// function</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> AnotherSomething) <span class="hljs-comment">// function</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">as</span>.toString()) <span class="hljs-comment">// [object Object]</span>
<span class="hljs-built_in">console</span>.log(a.toString()) <span class="hljs-comment">// [object Object]</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">as</span>.toString === <span class="hljs-built_in">Object</span>.prototype.toString)
<span class="hljs-built_in">console</span>.log(a.toString === <span class="hljs-built_in">Object</span>.prototype.toString)
<span class="hljs-comment">//     true</span>
<span class="hljs-comment">// Object.prototype     </span>
<span class="hljs-comment">// Something  AnotherSomething   Object.prototype</span>
</code></pre><br>
<a name="45"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">45. ¿Qué son las plantillas literales?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los literales de plantilla son una forma relativamente nueva de crear cadenas en JS. </font><font style="vertical-align: inherit;">Los literales de plantilla se crean utilizando dobles comillas (``):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> greet = <span class="hljs-string">'Hi I\'m Mark'</span><font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">let</span> greet = <span class="hljs-string">`Hi I'm Mark`</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los literales de plantilla, no necesitamos escapar de comillas simples.</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> lastWords = <span class="hljs-string">'\n'</span>
    + <span class="hljs-string">' I \n'</span>
    + <span class="hljs-string">' am \n'</span>
    + <span class="hljs-string">'Iron Man \n'</span><font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">let</span> lastWords = <span class="hljs-string">`
    I
    am
    Iron Man
`</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En ES6, no necesitamos usar la secuencia de escape "\ n" para alimentar la línea.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>!`</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En ES6, no necesitamos usar la concatenación de cadenas para combinar texto con una variable: podemos usar la expresión $ {expr} para obtener el valor de la variable.</font></font><br>
<br>
<a name="46"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">46. ​​¿Qué es la desestructuración de objetos?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La desestructuración es una forma relativamente nueva de obtener (recuperar) los valores de un objeto o matriz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que tenemos un objeto como este:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> employee = {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Marko'</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Polo'</span>,
    <span class="hljs-attr">position</span>: <span class="hljs-string">'Software Developer'</span>,
    <span class="hljs-attr">yearHired</span>: <span class="hljs-number">2017</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anteriormente, para crear las propiedades de un objeto, creamos variables para cada propiedad. </font><font style="vertical-align: inherit;">Fue muy aburrido y muy molesto:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> firstName = employee.firstName
<span class="hljs-keyword">var</span> lastName = employee.lastName
<span class="hljs-keyword">var</span> position = employee.position
<span class="hljs-keyword">var</span> yearHired = employee.yearHired
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usar la desestructuración hace que el código sea más limpio y lleva menos tiempo. </font><font style="vertical-align: inherit;">La sintaxis de desestructuración es la siguiente: encerramos las propiedades del objeto que queremos recibir entre llaves ({}), y si estamos hablando de una matriz, entre corchetes ([]):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> { firstName, lastName, position, yearHired } = employee
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para cambiar el nombre de la variable, use "propertyName: newName":</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> { <span class="hljs-attr">firstName</span>: fName, <span class="hljs-attr">lastName</span>: lName, position, yearHired } = employee
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para asignar valores predeterminados a las variables, use "propertyName = 'defaultValue'":</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> { firstName = <span class="hljs-string">'Mark'</span>, <span class="hljs-attr">lastName</span>: lName, position, yearHired } = employee
</code></pre><br>
<a name="47"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">47. ¿Qué son los módulos?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los módulos le permiten combinar (usar) el código de diferentes archivos y evitar que tengamos que guardar todo el código en un archivo grande. </font><font style="vertical-align: inherit;">Antes de que los módulos aparecieran en JS, había dos sistemas de módulos populares para soportar código:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CommonJS - Nodejs</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMD (AsyncronousModuleDefinition) - Navegadores</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La sintaxis de los módulos es muy simple: utilizamos importar para importar funcionalidades o valores de otro archivo o archivos, y exportar para exportar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funcionalidad de exportación a otro archivo (denominado exportación):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - helpers.js</span>
exports.isNull = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span><font></font>
}<font></font>
<font></font>
exports.isUndefined = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span><font></font>
}<font></font>
<font></font>
exports.isNullOrUndefined = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> exports.isNull(val) || exports.isUndefined(val)<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNull</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUndefined</span>(<span class="hljs-params">val</span>) </span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNullOrUndefined</span>(<span class="hljs-params">val</span>) </span>{
    <span class="hljs-keyword">return</span> isNull(val) || isUndefined(val);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Importar funcionalidad a otro archivo:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - index.js</span>
<span class="hljs-keyword">const</span> helpers = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>)
<span class="hljs-keyword">const</span> isNull = helpers.isNull
<span class="hljs-keyword">const</span> isUndefined = helpers.isUndefined
<span class="hljs-keyword">const</span> isNullOrUndefined = helpers.isNullOrUndefined<font></font>
<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> { isNull, isUndefined, isNullOrUndefined } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>)<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> helpers <span class="hljs-keyword">from</span> <span class="hljs-string">'./helpers.js'</span> <span class="hljs-comment">// helpers -  </span><font></font>
<font></font>
<span class="hljs-comment">// </span>
<span class="hljs-keyword">import</span> { isNull, isUndefined, isNullOrUndefined <span class="hljs-keyword">as</span> isValid} <span class="hljs-keyword">from</span> <span class="hljs-string">'./helpers.js'</span> <span class="hljs-comment">//  "as"  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exportación predeterminada:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - index.js</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Helpers</span> </span>{
    <span class="hljs-keyword">static</span> isNull(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isUndefined(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isNullOrUndefined(val){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNull(val) || <span class="hljs-keyword">this</span>.isUndefined(val)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">module</span>.exports = Helpers<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Helpers</span> </span>{
    <span class="hljs-keyword">static</span> isNull(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isUndefined(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isNullOrUndefined(val){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNull(val) || <span class="hljs-keyword">this</span>.isUndefined(val)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Helpers
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Importar:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - index.js</span>
<span class="hljs-keyword">const</span> Helpers = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>)
<span class="hljs-built_in">console</span>.log(Helpers.isNull(<span class="hljs-literal">null</span>))<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-keyword">import</span> Helpers <span class="hljs-keyword">from</span> <span class="hljs-string">'./helpers.js'</span>
<span class="hljs-built_in">console</span>.log(Helpers.isNull(<span class="hljs-literal">null</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es el uso básico de los módulos. </font><font style="vertical-align: inherit;">No entré en detalles porque mi publicación ya es demasiado grande.</font></font><br>
<br>
<a name="48"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">48. ¿Qué es un objeto Set?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El objeto Set le permite almacenar valores únicos, primitivas y referencias de objetos. </font><font style="vertical-align: inherit;">Una vez más: solo se pueden agregar valores únicos a Set. </font><font style="vertical-align: inherit;">Comprueba los valores almacenados en él utilizando el algoritmo SameZeroValue. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se crea una instancia de Set utilizando el constructor Set. </font><font style="vertical-align: inherit;">También podemos pasarle algunos valores al crear:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()
<span class="hljs-keyword">const</span> set2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>]) <span class="hljs-comment">//  "d"  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos agregar valores a Set usando el método add. </font><font style="vertical-align: inherit;">Como el método add es retornable, podemos usar una cadena de llamadas:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.add(<span class="hljs-string">'f'</span>)<font></font>
set2.add(<span class="hljs-string">'g'</span>).add(<span class="hljs-string">'h'</span>).add(<span class="hljs-string">'i'</span>).add(<span class="hljs-string">'j'</span>).add(<span class="hljs-string">'k'</span>).add(<span class="hljs-string">'k'</span>) <span class="hljs-comment">//  "k"  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos eliminar valores de Set usando el método delete:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.delete(<span class="hljs-string">'k'</span>) <span class="hljs-comment">// true</span>
set2.delete(<span class="hljs-string">'z'</span>) <span class="hljs-comment">// false,    set2   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos verificar una propiedad en Set usando el método has:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.has(<span class="hljs-string">'a'</span>) <span class="hljs-comment">// true</span>
set2.has(<span class="hljs-string">'z'</span>) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para obtener la longitud de Set, use el método de tamaño:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.size <span class="hljs-comment">// 10</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método claro borra Set:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.clear() <span class="hljs-comment">// </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos usar Set para eliminar valores duplicados en una matriz:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>]
<span class="hljs-keyword">const</span> uniqNums = [...new <span class="hljs-built_in">Set</span>(nums)] <span class="hljs-comment">// [1,2,3,4,5,6,7,8]</span>
</code></pre><br>
<a name="49"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">49. ¿Qué es una función de devolución de llamada?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La función de devolución de llamada es una función cuya llamada se pospone para el futuro (ocurre bajo ciertas condiciones, por ejemplo, cuando ocurre un evento).</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> btnAdd = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btnAdd'</span>)<font></font>
<font></font>
btnAdd.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickCallback</span>(<span class="hljs-params">e</span>))</span>{
    <span class="hljs-comment">//   </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el ejemplo, estamos esperando un evento de "clic" en un elemento con el identificador "btnAdd". </font><font style="vertical-align: inherit;">Al hacer clic, se llama a la función clickCallback. </font><font style="vertical-align: inherit;">La función de devolución de llamada agrega alguna funcionalidad a los datos o eventos. </font><font style="vertical-align: inherit;">Los métodos reducir, filtrar y asignar pasan una función de devolución de llamada como segundo argumento. </font><font style="vertical-align: inherit;">Una buena analogía con la devolución de llamada es la siguiente situación: llama a alguien, él no responde, le deja un mensaje y espera a que vuelva a llamar. </font><font style="vertical-align: inherit;">Una llamada o mensaje es un evento o un dato, y una devolución de llamada es la expectativa (anticipación) de una devolución de llamada.</font></font><br>
<br>
<a name="50"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">50. ¿Qué son las promesas?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las promesas son una forma de trabajar con código asincrónico en JS. </font><font style="vertical-align: inherit;">Devuelven el resultado de una operación asincrónica. </font><font style="vertical-align: inherit;">Se inventaron promesas para resolver el problema de las llamadas funciones infernales de devolución de llamada.</font></font><br>
<br>
<pre><code class="javascript hljs">fs.readFile(<span class="hljs-string">'somefile.txt'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, data</span>)</span>{
    <span class="hljs-keyword">if</span>(e){
        <span class="hljs-built_in">console</span>.log(e)<font></font>
    }<font></font>
    <span class="hljs-built_in">console</span>.log(data)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los problemas con este enfoque comienzan cuando necesitamos agregar otra operación asincrónica a la primera (dentro de la primera), luego a otra, etc. </font><font style="vertical-align: inherit;">Como resultado, obtenemos un código desordenado e ilegible:</font></font><br>
<br>
<pre><code class="javascript hljs">fs.readFile(<span class="hljs-string">'somefile.txt'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e,data</span>)</span>{
    <span class="hljs-comment">// </span>
    fs.readFile(<span class="hljs-string">'directory'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, files</span>)</span>{
        <span class="hljs-comment">// </span>
        fs.mkdir(<span class="hljs-string">'directory'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{
            <span class="hljs-comment">// </span><font></font>
        })<font></font>
    })<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y así es como se ve con las promesas:</font></font><br>
<br>
<pre><code class="javascript hljs">promReadFile(<span class="hljs-string">'file/path'</span>)<font></font>
.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> promReaddir(<span class="hljs-string">'directory'</span>)<font></font>
})<font></font>
.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> promMkdir(<span class="hljs-string">'directory'</span>)<font></font>
})<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.error(e)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Promise tiene cuatro condiciones:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esperar es el estado inicial de una promesa. </font><font style="vertical-align: inherit;">El resultado de la promesa es desconocido porque la operación no se ha completado.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hecho: operación asincrónica completada, hay un resultado.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rechazado: la operación asincrónica falló, hay una razón.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Completado: completado o rechazado.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El constructor Promise acepta resolver y rechazar como parámetros. </font><font style="vertical-align: inherit;">En resolución, el resultado de la operación se registra, en rechazo, la razón de la falla de la operación. </font><font style="vertical-align: inherit;">El resultado puede procesarse en el método .then, el error puede procesarse en el método .catch. </font><font style="vertical-align: inherit;">El método .then también devuelve una promesa, por lo que podemos usar una cadena que consta de varios .then.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myPromiseAsync = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {<font></font>
        doSomeAsync(...args, (error, data) =&gt; {<font></font>
            <span class="hljs-keyword">if</span>(error){<font></font>
                reject(error)<font></font>
            } <span class="hljs-keyword">else</span>{<font></font>
                resolve(data)<font></font>
            }<font></font>
        })<font></font>
    })<font></font>
}<font></font>
<font></font>
myPromiseAsync()<font></font>
.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(result)<font></font>
})<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.error(reason)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos crear una función auxiliar para convertir una operación asincrónica de devolución de llamada a una promesa. </font><font style="vertical-align: inherit;">Funcionará como util de Node.js ("promisificación"):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> toPromise = <span class="hljs-function">(<span class="hljs-params">asyncFuncWithCallback</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> {<font></font>
            asyncFuncWithCallback(...args, (e, result) =&gt; {<font></font>
                <span class="hljs-keyword">return</span> e ? rej(e) : res(result)<font></font>
            })<font></font>
        })<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> promiseReadFile = toPromise(fs.readFile)<font></font>
<font></font>
promiseReadFile(<span class="hljs-string">'file/path'</span>)<font></font>
.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(data)<font></font>
})<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(e))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede leer más sobre las promesas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="51"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">51. ¿Qué es async / wait?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Async / await es una forma relativamente nueva de escribir código asincrónico (sin bloqueo) en JS. </font><font style="vertical-align: inherit;">Están envueltos en una promesa. </font><font style="vertical-align: inherit;">Hace que el código sea más legible y limpio que las promesas y las funciones de devolución de llamada. </font><font style="vertical-align: inherit;">Sin embargo, para usar async / await, debe conocer bien las promesas.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callApi</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">'url/to/api/endpoint'</span>)<font></font>
    .then(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> resp.json())<font></font>
    .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-comment">//   </span>
    }).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
        <span class="hljs-comment">//   </span><font></font>
    })<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// async/await</span>
<span class="hljs-comment">//     try/catch</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callApi</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">const</span> resp = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'url/to/api/endpoint'</span>)
        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.json()
        <span class="hljs-comment">//   </span>
    } <span class="hljs-keyword">catch</span>(e){
        <span class="hljs-comment">//   </span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recuerde: usar la palabra clave asíncrona antes de que una función la obligue a devolver una promesa:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> giveMeOne = <span class="hljs-keyword">async</span> () = <span class="hljs-number">1</span><font></font>
<font></font>
giveMeOne()<font></font>
.then(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(num) <span class="hljs-comment">// 1</span><font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La palabra clave await solo se puede usar dentro de una función asincrónica. </font><font style="vertical-align: inherit;">Usar wait dentro de otra función dará como resultado un error. </font><font style="vertical-align: inherit;">Aguardar espera a que la expresión termine a la derecha para devolver su valor antes de la siguiente línea de código.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> giveMeOne = <span class="hljs-keyword">async</span>() =&gt; <span class="hljs-number">1</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOne</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">const</span> num = <span class="hljs-keyword">await</span> giveMeOne()
        <span class="hljs-built_in">console</span>.log(num)<font></font>
    } <span class="hljs-keyword">catch</span>(e){
        <span class="hljs-built_in">console</span>.log(e)<font></font>
    }<font></font>
}<font></font>
<span class="hljs-comment">// Uncaught SyntaxError: await is only valid in an async function</span><font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTwo</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">const</span> num1 = <span class="hljs-keyword">await</span> giveMeOne()
        <span class="hljs-keyword">const</span> nm2 = <span class="hljs-keyword">await</span> giveMeOne()
        <span class="hljs-keyword">return</span> num1 + num2<font></font>
    } <span class="hljs-keyword">catch</span>(e){
        <span class="hljs-built_in">console</span>.log(e)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">await</span> getTwo() <span class="hljs-comment">// 2</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lea más sobre async / wait </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="52"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">52. ¿Cuál es la diferencia entre un operador de propagación y un operador de reposo?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las sentencias spread y rest tienen la misma sintaxis ("..."). </font><font style="vertical-align: inherit;">La diferencia radica en el hecho de que con la ayuda de propagación transferimos o distribuimos los datos de la matriz a otros datos, y con la ayuda del resto obtenemos todos los parámetros de la función y los colocamos en la matriz (o extraemos algunos de los parámetros).</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>)</span>{
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> nums = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
<span class="hljs-keyword">const</span> sum = add(...nums)
<span class="hljs-built_in">console</span>.log(sum) <span class="hljs-comment">// 11</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, usamos spread cuando llamamos a la función add con los datos de la matriz nums. </font><font style="vertical-align: inherit;">El valor de la variable "a" será 5, b = 6, suma = 11.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">...rest</span>)</span>{
    <span class="hljs-keyword">return</span> rest.reduce(<span class="hljs-function">(<span class="hljs-params">total, current</span>) =&gt;</span> total + current)<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// 3</span>
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment">// 15</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí llamamos a la función add con cualquier número de argumentos. </font><font style="vertical-align: inherit;">Agregar devuelve la suma de estos argumentos.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> [first, ...others] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-built_in">console</span>.log(first) <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.log(others) <span class="hljs-comment">// [2, 3, 4, 5]</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, usamos rest para poner cualquier número de parámetros, excepto el primero, en la matriz de otros.</font></font><br>
<br>
<a name="53"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">53. ¿Cuáles son los parámetros predeterminados?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es una forma relativamente nueva de definir los valores de las variables predeterminadas.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>)</span>{<font></font>
    a = a || <span class="hljs-number">0</span>
    b = b || <span class="hljs-number">0</span>
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span></span>)</span>{
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<span class="hljs-comment">//      "a"  "b" - ,    0</span>
add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puedes usar la desestructuración:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFirst</span>(<span class="hljs-params">[first, ...rest] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</span>)</span>{
    <span class="hljs-keyword">return</span> first<font></font>
}<font></font>
<font></font>
getFirst() <span class="hljs-comment">// 0</span>
getFirst([<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]) <span class="hljs-comment">// 10</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArr</span>(<span class="hljs-params">{ nums } = { nums: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] }</span>)</span>{
    <span class="hljs-keyword">return</span> nums<font></font>
}<font></font>
<font></font>
getArr <span class="hljs-comment">// [1,2,3,4]</span>
getArr({<span class="hljs-attr">nums</span>:[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]}) <span class="hljs-comment">// [5,4,3,2,1]</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incluso podemos usar los parámetros predeterminados declarados en el mismo lugar:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomethingWithValue</span>(<span class="hljs-params">value = <span class="hljs-string">'Hello World'</span>, callback = (</span>) =&gt; </span>{ <span class="hljs-built_in">console</span>.log(value) }){<font></font>
    callback()<font></font>
}<font></font>
doSomethingWithValue() <span class="hljs-comment">// Hello World</span>
</code></pre><br>
<a name="54"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">54. ¿Qué es un contenedor de objetos (objetos de envoltura)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las primitivas cadena, número y booleano tienen propiedades y métodos, a pesar de que no son objetos:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> name = <span class="hljs-string">'marko'</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> name) <span class="hljs-comment">// string</span>
<span class="hljs-built_in">console</span>.log(name.toUpperCase()) <span class="hljs-comment">// MARKO</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nombre es una cadena (tipo primitivo) que no tiene propiedades ni métodos, pero cuando llamamos al método toUpperCase (), esto no conduce a un error, sino a "MARKO". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La razón de este comportamiento es que el nombre se convierte temporalmente en un objeto. </font><font style="vertical-align: inherit;">Cada primitivo, excepto nulo e indefinido, tiene un objeto contenedor. </font><font style="vertical-align: inherit;">Tales objetos son String, Number, Boolean, Symbol y BigInt. </font><font style="vertical-align: inherit;">En nuestro caso, el código toma la siguiente forma:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(name).toUpperCase()) <span class="hljs-comment">// MARKO</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un objeto temporal se descarta al finalizar el trabajo con una propiedad o método.</font></font><br>
<br>
<a name="55"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">55. ¿Cuál es la diferencia entre la coerción implícita y explícita?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La conversión implícita es una forma de transmitir un valor a otro tipo sin nuestro conocimiento (participación). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que tenemos lo siguiente:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-string">'6'</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> + <span class="hljs-literal">true</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span> * <span class="hljs-string">'2'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado del primer console.log será 16. En otros idiomas, esto conduciría a un error, pero en JS 1 se convierte en una cadena y se concatena (adjunta) desde 6. No hicimos nada, la conversión se produjo automáticamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado del segundo console.log será 1. False se convirtió a 0, verdadero a 1. 0 + 1 = 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado del tercer console.log será 12. La línea 2 se convirtió a un número antes de multiplicar por 6. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La conversión explícita implica nuestra participación en convertir el valor a otro tipo:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'6'</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, usamos parseInt para convertir la cadena 6 en un número, luego sumamos los dos números y obtenemos 7.</font></font><br>
<br>
<a name="56"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">56. ¿Qué es NaN? </font><font style="vertical-align: inherit;">¿Cómo verificar si el valor es NaN?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NaN o no un número (no un número) es el valor obtenido como resultado de realizar una operación numérica en un valor no numérico:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> a<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'abc'</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-literal">null</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-literal">undefined</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(++a))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>({} * <span class="hljs-number">10</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'abc'</span> - <span class="hljs-number">2</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0</span> / <span class="hljs-number">0</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'10a'</span> * <span class="hljs-number">10</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JS tiene un método isNaN incorporado que le permite verificar si el valor es NaN, pero se comporta de manera bastante extraña:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>()) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>({})) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">String</span>(<span class="hljs-string">'a'</span>))) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { })) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado de todo console.log es verdadero, a pesar del hecho de que ninguno de los valores es NaN. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ES6 recomienda usar el método Number.isNaN para verificar si el valor es NaN. </font><font style="vertical-align: inherit;">También podemos escribir una función auxiliar para resolver el problema de la "desigualdad de NaN por sí misma":</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkIsNan</span>(<span class="hljs-params">value</span>)</span>{
    <span class="hljs-keyword">return</span> value !== value<font></font>
}<font></font>
</code></pre><br>
<a name="57"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">57. ¿Cómo verificar si un valor es una matriz?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para hacer esto, use el método Array.isArray:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-number">5</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-string">''</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray()) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray( {<span class="hljs-attr">length</span>: <span class="hljs-number">5</span> })) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray([])) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si el entorno en el que trabaja no es compatible con este método, puede usar el siguiente archivo polivinílico:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">value</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(value) === <span class="hljs-string">'[object Array]'</span><font></font>
}<font></font>
</code></pre><br>
<a name="58"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">58. ¿Cómo verificar que un número sea par, sin usar la división de módulo o la división con el resto (operador "%")?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para resolver este problema, puede usar el operador "&amp;" (binario y). </font><font style="vertical-align: inherit;">El operador &amp; compara operandos como valores binarios.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEven</span>(<span class="hljs-params">num</span>)</span>{
    <span class="hljs-keyword">if</span>(num &amp; <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    } <span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 en la notación binaria es 000 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 - esto es 001 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 - 010 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3 - 011 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4 - 100 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5 - 101 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 - 110 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7 - 111 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
, etc. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y8/zo/m2/y8zom220osynreetfh8fp-dkuog.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Console.log (5 y 1) devolverá 1. Primero, el operador &amp; convierte ambos números a valores binarios, 5 se convierte en 101, 1 se convierte en 001. Luego se realiza una comparación a nivel de bits: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vy/4k/em/vy4kemefvzxgjlwdp3dmsh64ae8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compare 1 y 0, obtenemos 0. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compare 0 y 0 , obtenemos 0. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compara 1 y 1, obtenemos 1. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Convierte el valor binario en un entero, obtenemos 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si esta información te parece demasiado complicada, podemos resolver el problema usando la función recursiva:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEven</span>(<span class="hljs-params">num</span>)</span>{
    <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span> || num === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    <span class="hljs-keyword">return</span> isEven(num - <span class="hljs-number">2</span>)<font></font>
}<font></font>
</code></pre><br>
<a name="59"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">59. ¿Cómo determinar la presencia de una propiedad en un objeto?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
hay tres maneras de hacer esto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La primera forma es usar el operador in:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o = {
    <span class="hljs-string">'prop'</span>: <span class="hljs-string">'bwahahah'</span>,
    <span class="hljs-string">'prop2'</span>: <span class="hljs-string">'hweasa'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'prop'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'prop1'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo es usar el método hasOwnProperty:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'prop2'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'prop1'</span>)) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tercero es la notación de índice de la matriz:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(o[<span class="hljs-string">'prop'</span>]) <span class="hljs-comment">// bwahahah</span>
<span class="hljs-built_in">console</span>.log(o[<span class="hljs-string">'prop1'</span>]) <span class="hljs-comment">// undefined</span>
</code></pre><br>
<a name="60"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">60. ¿Qué es AJAX?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AJAX o JavaScript asíncrono y XML es un conjunto de tecnologías interconectadas que le permiten trabajar con datos en modo asíncrono. </font><font style="vertical-align: inherit;">Esto significa que podemos enviar datos al servidor y recibir datos del mismo sin volver a cargar la página web. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AJAX utiliza las siguientes tecnologías: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTML: estructura de la página web. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSS - estilos de página web. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript: comportamiento de la página y trabajo con el DOM. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
API XMLHttpRequest: envío y recepción de datos desde el servidor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHP, Python, Nodejs: algún tipo de lenguaje de servidor.</font></font><br>
<br>
<a name="61"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">61. ¿Cómo crear un objeto en JS?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Literal del objeto:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Mark'</span>,<font></font>
    greeting(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
    }<font></font>
}<font></font>
<font></font>
o.greeting <span class="hljs-comment">// Hi, I'm Mark</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Función del constructor:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">this</span>.name = name<font></font>
}<font></font>
<font></font>
Person.prototype.greeting = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> mark = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Mark'</span>)<font></font>
<font></font>
mark.greeting() <span class="hljs-comment">// Hi, I'm Mark</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Método Object.create:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> n = {<font></font>
    greeting(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> o = <span class="hljs-built_in">Object</span>.create(n)<font></font>
<font></font>
o.name = <span class="hljs-string">'Mark'</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(o.greeting) <span class="hljs-comment">// Hi, I'm Mark</span>
</code></pre><br>
<a name="62"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">62. ¿Cuál es la diferencia entre los métodos Object.freeze y Object.seal?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diferencia es que cuando usamos el método Object.freeze, no podemos cambiar o editar las propiedades del objeto, y cuando usamos Object.seal tenemos esa oportunidad.</font></font><br>
<br>
<a name="63"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63. ¿Cuál es la diferencia entre el operador in y el método hasOwnProperty?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diferencia es que el operador "in" comprueba la presencia de una propiedad no solo en el objeto en sí, sino también en sus prototipos, y el método hasOwnProperty, solo en el objeto.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'prop'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'toString'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// true</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'prop'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'toString'</span>)) <span class="hljs-comment">// false</span>
</code></pre><br>
<a name="64"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64. ¿Qué técnicas de trabajo con código asincrónico en JS conoces?</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Devoluciones de llamada</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promesas promesas).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asíncrono / espera.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliotecas como async.js, blueprint, q, co.</font></font></li>
</ul><br>
<a name="65"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65. ¿Cuál es la diferencia entre una función normal y una expresión funcional?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que tenemos lo siguiente:</font></font><br>
<br>
<pre><code class="javascript hljs">hoistedFunc()<font></font>
notHoistedFunc()<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hoistedFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I am hoisted'</span>)<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> notHoistedFunc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I will not be hoisted!'</span>)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una llamada a notHoistedFunc dará como resultado un error, pero una llamada a hoistedFunc no, porque hoistedFunc "aparece", se eleva al alcance global, pero notHoistedFunc no.</font></font><br>
<br>
<a name="66"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">66. ¿Cómo llamar a una función en JS?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En JS, hay 4 formas de llamar a una función. </font><font style="vertical-align: inherit;">La llamada define el valor de esto o el "propietario" de la función. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Llamada como una función. </font><font style="vertical-align: inherit;">Si se llama a una función como método, constructor, o usando los métodos apply o call, entonces se llama como una función. </font><font style="vertical-align: inherit;">El propietario de dicha función es el objeto de ventana:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<font></font>
add(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">// window, 6</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> o = {<font></font>
    method(callback){<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
<font></font>
o.method(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// window</span><font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Llamar como método. </font><font style="vertical-align: inherit;">Cuando una función es una propiedad de un objeto, lo llamamos método. </font><font style="vertical-align: inherit;">Cuando se llama a un método, este objeto se convierte en el objeto de este método:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> details = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko'</span>,<font></font>
    getName(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name<font></font>
    }<font></font>
}<font></font>
<font></font>
details.getName() <span class="hljs-comment">// Marko,  this   details</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Llamada como constructor. </font><font style="vertical-align: inherit;">Cuando se llama a una función usando la palabra clave "nueva", llamamos a esa función constructor. </font><font style="vertical-align: inherit;">Esto crea un objeto vacío, que es el valor de esto:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">name, position, yearHired</span>)</span>{
    <span class="hljs-comment">//   ,   this</span>
    <span class="hljs-comment">// this = {}</span>
    <span class="hljs-keyword">this</span>.name = name
    <span class="hljs-keyword">this</span>.position = position
    <span class="hljs-keyword">this</span>.yearHired = yearHired
    <span class="hljs-comment">//   Employee.prototype   this,    </span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> emp = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">'Marko Polo'</span>, <span class="hljs-string">'Software Development'</span>, <span class="hljs-number">2017</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una llamada usando los métodos de solicitud o llamada. </font><font style="vertical-align: inherit;">Usamos estos métodos cuando queremos determinar explícitamente el valor de esto o el propietario de una función:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj1 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> obj2 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduceAdd</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++){<font></font>
        result += <span class="hljs-built_in">arguments</span>[i]<font></font>
    }<font></font>
    <span class="hljs-keyword">this</span>.result = result<font></font>
}<font></font>
<font></font>
reduceAdd.apply(obj1, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]) <span class="hljs-comment">//  this  obj1</span>
reduceAdd.call(obj2, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">//  this  obj2</span>
</code></pre><br>
<a name="67"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">67. ¿Qué es memorización o memorización?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La memorización es la técnica de crear una función que puede recordar resultados o valores calculados previamente. </font><font style="vertical-align: inherit;">La ventaja de la memorización es que evitamos volver a ejecutar una función con los mismos argumentos. </font><font style="vertical-align: inherit;">La desventaja es que nos vemos obligados a asignar memoria adicional para guardar los resultados.</font></font><br>
<br>
<a name="68"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68. ¿Cómo implementaría la función auxiliar de memorización?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span>(<span class="hljs-params">fn</span>)</span>{
    <span class="hljs-keyword">const</span> cache = {}
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">param</span>)</span>{
        <span class="hljs-keyword">if</span>(cache[param]){
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'cached'</span>)
            <span class="hljs-keyword">return</span> cache[param]<font></font>
        } <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">let</span> result = fn(param)<font></font>
            cache[param] = result<font></font>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'not cached'</span>)
            <span class="hljs-keyword">return</span> result<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> toUpper = <span class="hljs-function">(<span class="hljs-params">str = <span class="hljs-string">''</span></span>) =&gt;</span> str.toUpperCase()<font></font>
<font></font>
<span class="hljs-keyword">const</span> toUpperMemoized = memoize(toUpper)<font></font>
<font></font>
toUpperMemoized(<span class="hljs-string">'abcdef'</span>)<font></font>
toUpperMemoized(<span class="hljs-string">'abcdef'</span>) <span class="hljs-comment">//  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implementamos la función de memorización con un argumento. </font><font style="vertical-align: inherit;">Hagámoslo "multi-argumento":</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> slice = <span class="hljs-built_in">Array</span>.prototype.slice
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span>(<span class="hljs-params">fn</span>)</span>{
    <span class="hljs-keyword">const</span> cache = {}
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> params = slice.call(args)
        <span class="hljs-built_in">console</span>.log(params)
        <span class="hljs-keyword">if</span>(cache[params]){
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'cached'</span>)
            <span class="hljs-keyword">return</span> cache[params]<font></font>
        } <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">let</span> result = fn(...args)<font></font>
            cache[params] = result<font></font>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'not cached'</span>)
            <span class="hljs-keyword">return</span> result<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<span class="hljs-keyword">const</span> makeFullName = <span class="hljs-function">(<span class="hljs-params">fName, lName</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${fName}</span> <span class="hljs-subst">${lName}</span>`</span>
<span class="hljs-keyword">const</span> reduceAdd = <span class="hljs-function">(<span class="hljs-params">numbers, startValue = <span class="hljs-number">0</span></span>) =&gt;</span> numbers.reduce(<span class="hljs-function">(<span class="hljs-params">total, cur</span>) =&gt;</span> total + cur, startValue)<font></font>
<font></font>
<span class="hljs-keyword">const</span> memoizedFullName = memoize(makeFullName)
<span class="hljs-keyword">const</span> memoizeReduceAdd = memoize(reduceAdd)<font></font>
<font></font>
memoizedFullName(<span class="hljs-string">'Marko'</span>, <span class="hljs-string">'Polo'</span>)<font></font>
memoizedFullName(<span class="hljs-string">'Marko'</span>, <span class="hljs-string">'Polo'</span>) <span class="hljs-comment">//  </span><font></font>
<font></font>
memoizeReduceAdd([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<span class="hljs-number">5</span>)<font></font>
memoizeReduceAdd([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<span class="hljs-number">5</span>) <span class="hljs-comment">//  </span>
</code></pre><br>
<a name="69"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69. ¿Por qué typeof null devuelve objeto? </font><font style="vertical-align: inherit;">¿Cómo verificar si un valor es nulo?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
typeof null == 'objeto' siempre devolverá verdadero por razones históricas. </font><font style="vertical-align: inherit;">Hubo una propuesta para corregir este error cambiando typeof null = 'object' a typeof null = 'null', pero fue rechazado en aras de mantener la compatibilidad con versiones anteriores (dicho cambio implicaría una gran cantidad de errores). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para verificar si el valor es nulo, puede usar el operador de igualdad estricta (===):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNull</span>(<span class="hljs-params">value</span>)</span>{
    <span class="hljs-keyword">return</span> value === <span class="hljs-literal">null</span><font></font>
}<font></font>
</code></pre><br>
<a name="70"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70. ¿Para qué se utiliza la palabra clave "nueva"?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La palabra clave "nuevo" se utiliza en las funciones de constructor para crear un nuevo objeto (una nueva instancia de la clase). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que tenemos un código como este:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">name, position, yearHired</span>)</span>{
    <span class="hljs-keyword">this</span>.name = name
    <span class="hljs-keyword">this</span>.position = position
    <span class="hljs-keyword">this</span>.yearHired = yearHired<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> emp = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">'Marko Polo'</span>, <span class="hljs-string">'Software Development'</span>, <span class="hljs-number">2017</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La palabra clave "nuevo" hace 4 cosas:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crea un objeto vacío.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vincula el valor de este a él.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una función hereda de functionName.prototype.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Devuelve esto a menos que se especifique lo contrario.</font></font></li>
</ol></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es486804/index.html">Informática sanitaria mundial: tecnologías en la nube</a></li>
<li><a href="../es486808/index.html">Prueba de embarazo electrónica de una farmacia: cómo funciona</a></li>
<li><a href="../es486810/index.html">Nueva interfaz de Odnoklassniki: lanzamiento de React en Java. Parte II</a></li>
<li><a href="../es486814/index.html">Zabbix: la topología de red es clara y automática</a></li>
<li><a href="../es486818/index.html">Portar Quake a iPod Classic</a></li>
<li><a href="../es486822/index.html">[Por los muelles] Aleteo. Parte 4. Para desarrolladores web</a></li>
<li><a href="../es486824/index.html">Mal consejo al trabajar con ANTLR</a></li>
<li><a href="../es486826/index.html">Creación de un Viberbot completo en Django 2 y la API REST de Viber. Primera parte - Webhook</a></li>
<li><a href="../es486828/index.html">Food Design Digest, enero de 2020</a></li>
<li><a href="../es486832/index.html">¿Cuántos años pasa Taiga? No, no.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>