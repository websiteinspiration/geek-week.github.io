<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🎓 👶🏾 👩‍👧‍👧 Otimização de renderização para celular 📓 👵🏿 👨🏼‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá queridos leitores, amantes e profissionais de programação gráfica! Chamamos a atenção para uma série de artigos dedicados à otimização da renderiz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Otimização de renderização para celular</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/492874/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Olá queridos leitores, amantes e profissionais de programação gráfica! Chamamos a atenção para uma série de artigos dedicados à otimização da renderização para dispositivos móveis: telefones e tablets baseados em iOS e Android. O ciclo consistirá em três partes. Na primeira parte, examinaremos os recursos da popular </font><font style="vertical-align: inherit;">arquitetura de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blocos de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GPU </font><font style="vertical-align: inherit;">no celular </font><font style="vertical-align: inherit;">. No segundo, abordaremos as principais famílias de GPUs apresentadas em dispositivos modernos e consideraremos seus pontos fortes e fracos. Na terceira parte, vamos nos familiarizar com os recursos da otimização de shader. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então, vamos à primeira parte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O desenvolvimento de placas de vídeo em desktops e consoles ocorreu na ausência de restrições significativas ao consumo de energia. Com o advento das placas de vídeo para dispositivos móveis, os engenheiros enfrentaram a tarefa de garantir um desempenho aceitável em resoluções de desktop comparáveis, enquanto o consumo de energia dessas placas de vídeo deveria ser 2 ordens de magnitude menor.&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51e/4fa/969/51e4fa969a3e5ede3b31064499c33226.png"></div><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A solução foi encontrada em uma arquitetura especial chamada </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tile Based Rendering (TBR)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Para um programador gráfico com experiência em desenvolvimento de PC, quando ele se familiariza com o desenvolvimento móvel, tudo parece familiar: uma API OpenGL ES semelhante é usada, a mesma estrutura do pipeline gráfico. No entanto, a arquitetura de blocos de GPUs móveis é significativamente diferente daquela usada nos consoles PC / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modo Imediato</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Conhecer os pontos fortes e fracos da </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TBR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ajudará você a tomar as decisões corretas e obter um ótimo desempenho com o Mobile. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abaixo está um diagrama simplificado de um pipeline gráfico clássico usado em PCs e consoles pela terceira década.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/281/67b/5e2/28167b5e2eaa4746ebd1ed45f8aa2dfb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No estágio de processamento da geometria, os atributos do vértice são lidos na memória de vídeo da GPU. Após várias transformações </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Vertex Shader), as</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> primitivas prontas para renderizar na ordem original (FIFO) são passadas para o rasterizador, que divide as primitivas em pixels. Depois disso, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> realizado o estágio de processamento do fragmento de cada pixel </font><b><font style="vertical-align: inherit;">(Fragment Shader)</font></b><font style="vertical-align: inherit;"> e os valores de cores obtidos são gravados no buffer da tela, que também está localizado na memória de vídeo. Um recurso da arquitetura tradicional do </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“Modo Imediato”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é a gravação do resultado do Fragment Shader em seções arbitrárias do buffer de tela ao processar uma única </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chamada de empate.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Assim, para cada chamada de empate, pode ser necessário acesso a todo o buffer da tela. Trabalhar com uma grande variedade de memória requer uma </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">largura de banda de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> barramento apropriada ( </font><b><font style="vertical-align: inherit;">largura de banda</font></b><font style="vertical-align: inherit;"> ) e está associado ao alto consumo de energia. Portanto, as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> móveis </font><font style="vertical-align: inherit;">começaram a adotar uma abordagem diferente. Na arquitetura de blocos típica das placas de vídeo móveis, a renderização é feita em um pequeno pedaço de memória correspondente à parte da tela - o bloco. O tamanho pequeno do bloco (por exemplo, 16x16 pixels para placas de vídeo do Mali, 32x32 para PowerVR) permite colocá-lo diretamente no chip da placa de vídeo, o que torna a velocidade de acesso comparável à velocidade de acesso aos registros principais do shader, ou seja, muito rápido.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86d/7bf/c65/86d7bfc65e53739ab9be0d5ea1242c0e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, como as primitivas podem cair em seções arbitrárias do buffer de tela e um bloco cobre apenas uma pequena parte dele, foi necessária uma etapa adicional no pipeline de gráficos. </font><font style="vertical-align: inherit;">A seguir, é apresentado um diagrama simplificado de como o pipeline funciona com a arquitetura de blocos.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/531/ea5/00c/531ea500c507eb47558676582e20c94c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de processar os vértices e construir as primitivas, as últimas, em vez de serem enviadas para o pipeline de fragmentos, caem no chamado </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Aqui, as primitivas são distribuídas por blocos, nos pixels dos quais caem. </font><font style="vertical-align: inherit;">Após essa distribuição, que, em regra, cobre todas as chamadas de desenho direcionadas a um </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objeto de buffer de quadro</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (também conhecido como </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">destino de renderização</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), os blocos são renderizados seqüencialmente. </font><font style="vertical-align: inherit;">Para cada bloco, a seguinte sequência de ações é executada:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carregando conteúdo antigo do </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> da memória do sistema ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderizar primitivos que caem nesse bloco</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Upload de novo conteúdo do </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na memória do sistema ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Store</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ea/20b/74b/9ea20b74b9fb716af30d5e0fa4ee1b34.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deve-se observar que a </font><font style="vertical-align: inherit;">operação de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">carregamento</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode ser considerada como uma superposição adicional da "textura de tela cheia" sem compactação. </font><font style="vertical-align: inherit;">Se possível, evite esta operação, ou seja, </font><font style="vertical-align: inherit;">Não permita que o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alterne </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se </font><font style="vertical-align: inherit;">todo o seu conteúdo for limpo </font><font style="vertical-align: inherit;">antes da renderização no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a </font><font style="vertical-align: inherit;">operação </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não será executada. </font><font style="vertical-align: inherit;">No entanto, para enviar o sinal correto ao motorista, os parâmetros dessa limpeza devem atender a certos critérios:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deve ser desativado </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scissor Rect</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A gravação em todos os canais de cores e alfa deve ser permitida.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para impedir a </font><font style="vertical-align: inherit;">operação de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">carregamento</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do buffer de profundidade e do estêncil, eles também precisam ser limpos antes do início da renderização. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Também é possível evitar a operação de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">armazenamento</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para o buffer de profundidade / estêncil. </font><font style="vertical-align: inherit;">Afinal, o conteúdo desses buffers não é exibido de forma alguma na tela. </font><font style="vertical-align: inherit;">Antes da operação </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glSwapBuffers</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><b><font style="vertical-align: inherit;">você</font></b><font style="vertical-align: inherit;"> pode chamar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glDiscardFramebufferEXT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glInvalidateFramebuffer</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> GLenum attachments[] = {GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT};<font></font>
glDiscardFramebufferEXT (GL_FRAMEBUFFER, <span class="hljs-number">2</span>, attachments);</code></pre><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> GLenum attachments[] = {GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT};<font></font>
glInvalidateFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">2</span>, attachments);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem cenários de renderização nos quais </font><font style="vertical-align: inherit;">não é necessária </font><font style="vertical-align: inherit;">a colocação de buffers de profundidade / estêncil, bem como de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na memória do sistema. Por exemplo, se a renderização no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com o buffer de profundidade for contínua e as informações de profundidade do quadro anterior não forem usadas, o buffer de profundidade não precisará ser carregado na memória do bloco antes do início da renderização ou descarregado após a conclusão da renderização. Portanto, a memória do sistema não pode ser alocada no buffer de profundidade. APIs gráficas modernas, como </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vulkan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metal,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permitem definir explicitamente o modo de memória para suas contrapartes </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">  &nbsp;( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MTLStorageModeMemoryless</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metal, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT +</font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vulkan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Destaca-se a implementação do </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em arquiteturas de </font><font style="vertical-align: inherit;">blocos </font><font style="vertical-align: inherit;">. O buffer de alta resolução para o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não deixa a memória do bloco dividindo o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em mais blocos. Por exemplo, para o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA 2x2, os</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> blocos de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16x16</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> serão resolvidos como </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8x8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> durante a </font><font style="vertical-align: inherit;">operação de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Armazenamento</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ou seja, No total, será necessário processar 4 vezes mais peças. Porém, a memória adicional para o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não </font><b><font style="vertical-align: inherit;">é</font></b><font style="vertical-align: inherit;"> necessária e, devido à renderização na memória rápida do bloco, não haverá restrições significativas de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">largura de banda.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No entanto, use</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O MSAA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na arquitetura de </font><b><font style="vertical-align: inherit;">blocos</font></b><font style="vertical-align: inherit;"> aumenta a carga no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiler, o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que pode afetar negativamente o desempenho da renderização de cenas com muita geometria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resumindo o exposto, apresentamos o esquema desejado para trabalhar com o FBO na arquitetura de blocos:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// 1.   ,    auxFBO</span><font></font>
glBindFramebuffer(GL_FRAMEBUFFER, auxFBO);<font></font>
glDisable(GL_SCISSOR);<font></font>
glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);<font></font>
glDepthMask(GL_TRUE);<font></font>
<span class="hljs-comment">// glClear,     </span><font></font>
glClear(GL_COLOR_BUFFER_BIT |&nbsp;GL_DEPTH_BUFFER_BIT |&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GL_STENCIL_BUFFER_BIT);<font></font>
<font></font>
renderAuxFBO();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
<font></font>
<span class="hljs-comment">//   /      </span>
glInvalidateFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">2</span>, depth_and_stencil);
<span class="hljs-comment">// 2.   mainFBO</span><font></font>
glBindFramebuffer(GL_FRAMEBUFFER, mainFBO);<font></font>
glDisable(GL_SCISSOR);<font></font>
<font></font>
glClear(...);<font></font>
<span class="hljs-comment">//   mainFBO    auxFBO</span><font></font>
renderMainFBO(auxFBO);<font></font>
<font></font>
glInvalidateFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">2</span>, depth_and_stencil);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você alternar para a renderização </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auxFBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no meio da formação </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mainFBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , poderá obter </font><font style="vertical-align: inherit;">operações </font><font style="vertical-align: inherit;">desnecessárias de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">carregamento e armazenamento</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o que pode aumentar significativamente o tempo de formação de quadros. </font><font style="vertical-align: inherit;">Em nossa prática, encontramos uma desaceleração na renderização, mesmo no caso de configurações ociosas da FBO, ou seja, </font><font style="vertical-align: inherit;">sem a renderização real neles. </font><font style="vertical-align: inherit;">Devido à arquitetura do mecanismo, nosso circuito antigo era assim:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   mainFBO</span><font></font>
glBindFramebuffer(GL_FRAMEBUFFER, mainFBO);<font></font>
<span class="hljs-comment">//   </span><font></font>
glBindFramebuffer(GL_FRAMEBUFFER, auxFBO);<font></font>
<span class="hljs-comment">//  auxFBO</span><font></font>
renderAuxFBO();<font></font>
<font></font>
glBindFramebuffer(GL_FRAMEBUFFER, mainFBO);<font></font>
<span class="hljs-comment">//   mainFBO</span><font></font>
renderMainFBO(auxFBO);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apesar da falta de chamadas gl após a primeira instalação do </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mainFBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , em alguns dispositivos obtivemos </font><font style="vertical-align: inherit;">operações </font><font style="vertical-align: inherit;">extras de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load &amp; Store</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e pior desempenho. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para melhorar nossa compreensão das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">despesas indiretas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do uso de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBOs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> intermediários </font><font style="vertical-align: inherit;">, medimos a perda de tempo para alternar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBOs de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tela cheia </font><font style="vertical-align: inherit;">usando um teste sintético. A tabela mostra o tempo gasto na </font><font style="vertical-align: inherit;">operação </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Store</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao alternar o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> várias vezes </font><font style="vertical-align: inherit;">em um quadro (o tempo de uma dessas operações é fornecido). </font><font style="vertical-align: inherit;">Operação de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">carga</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausente devido ao </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glClear</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ou seja, </font><font style="vertical-align: inherit;">um cenário mais favorável foi medido. </font><font style="vertical-align: inherit;">A permissão usada no dispositivo contribuiu. </font><font style="vertical-align: inherit;">Pode corresponder mais ou menos ao poder da GPU instalada. </font><font style="vertical-align: inherit;">Portanto, esses números dão apenas uma idéia geral de quanto custa a troca de alvos em placas de vídeo móveis de várias gerações.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">milissegundos</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">milissegundos</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 320</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2.</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 512</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,74</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR G6200</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 615</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,7</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-400</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 530</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,4</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-t720</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-g51</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,32</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR SXG 544</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-t830</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,15</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com base nos dados obtidos, podemos chegar à recomendação de não usar mais de um ou dois comutadores FBO por quadro, pelo menos para placas de vídeo antigas. Se o jogo tiver uma passagem de código separada para dispositivos low-end, é aconselhável não usar a alteração FBO lá. No entanto, no low-end, a questão da redução da resolução geralmente se torna relevante. No Android, você pode diminuir a resolução de renderização sem recorrer ao uso de um FBO intermediário chamando </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SurfaceHolder.setFixedSize ():</font></font></b><br>
<br>
<pre><code class="java hljs">surfaceView.getHolder().setFixedSize(...)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este método não funcionará se o jogo for renderizado através do </font><font style="vertical-align: inherit;">aplicativo </font><font style="vertical-align: inherit;">principal do </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surface</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (um esquema típico para trabalhar com o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NativeActivity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Se você usar o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surface</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> principal </font><b><font style="vertical-align: inherit;">,</font></b><font style="vertical-align: inherit;"> poderá definir uma resolução mais baixa chamando a função nativa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANativeWindow_setBuffersGeometry.</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">JNIEXPORT <span class="hljs-keyword">void</span> JNICALL <span class="hljs-title">Java_com_organization_app_AppNativeActivity_setBufferGeometry</span><span class="hljs-params">(JNIEnv *env, jobject thiz, jobject surface, jint width, jint height)</span>
</span>{<font></font>
ANativeWindow* window = ANativeWindow_fromSurface(env, surface);&nbsp;<font></font>
ANativeWindow_setBuffersGeometry(window, width, height, AHARDWAREBUFFER_FORMAT_R8G8B8X8_UNORM);&nbsp;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em Java:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBufferGeometry</span><span class="hljs-params">(Surface surface, <span class="hljs-keyword">int</span> width , <span class="hljs-keyword">int</span> height )</span></span>;&nbsp;<font></font>
...<font></font>
<span class="hljs-comment">//   SurfaceHolder.Callback</span>
<span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">surfaceChanged</span><span class="hljs-params">(SurfaceHolder holder, <span class="hljs-keyword">int</span> format, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span>
</span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setBufferGeometry(holder.getSurface(), <span class="hljs-number">768</span>, <span class="hljs-number">1366</span>); <span class="hljs-comment">/* ... */</span>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por fim, mencionamos o conveniente comando ADB para controlar os buffers de superfície selecionados no Android:</font></font><br>
<br>
<pre><code class="plaintext hljs">adb shell dumpsys surfaceflinger
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode obter uma conclusão semelhante que permite estimar o consumo de memória para buffers de superfície:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/524/2fe/ea6/5242feea615abe186c6c3538c9d60565.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A captura de tela mostra o sistema destacando 3 buffers para o buffer triplo do </font><font style="vertical-align: inherit;">jogo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GLSurfaceView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (destacado em amarelo), bem como 2 buffers para a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">superfície</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> principal </font><font style="vertical-align: inherit;">(destacada em vermelho). </font><font style="vertical-align: inherit;">No caso de renderização através do Surface principal, que é o esquema padrão ao usar o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NativeActivity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a alocação de buffers adicionais pode ser evitada.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É tudo por agora. </font><font style="vertical-align: inherit;">Nos artigos a seguir, classificaremos as GPUs móveis, bem como analisaremos os métodos para otimizar shaders para elas.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt492862/index.html">15 melhores dicas de ajuste de desempenho do Oracle APEX para desenvolvedores</a></li>
<li><a href="../pt492864/index.html">Posso invadir um navio?</a></li>
<li><a href="../pt492866/index.html">O livro "Machine Learning sem palavras"</a></li>
<li><a href="../pt492868/index.html">Otimização de string no ClickHouse. Relatório Yandex</a></li>
<li><a href="../pt492872/index.html">Como organizar o acesso remoto e não sofrer hackers</a></li>
<li><a href="../pt492878/index.html">Chinelos geek: procurando resultados positivos em fechamentos temporários de escritórios</a></li>
<li><a href="../pt492880/index.html">O que devemos construir uma casa inteligente?</a></li>
<li><a href="../pt492884/index.html">Recebendo mensagens de transmissões do youtube + autorização do google em PHP</a></li>
<li><a href="../pt492886/index.html">Receita de testadores de recrutamento em massa</a></li>
<li><a href="../pt492888/index.html">Por que você não deve usar o WireGuard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>