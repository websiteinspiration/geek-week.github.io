<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🤝‍👨🏻 🙏🏽 😸 Widgets sur Android. Une caractéristique rare à comprendre 💇🏻 🤹🏿 🎚️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je m'appelle Alexander Khakimov, je suis développeur Android chez FINCH. 
 
 Est-il arrivé que votre conception soit pour iOS et que vo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Widgets sur Android. Une caractéristique rare à comprendre</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492166/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, Habr! </font><font style="vertical-align: inherit;">Je m'appelle Alexander Khakimov, je suis développeur Android chez FINCH. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Est-il arrivé que votre conception soit pour iOS et que vous deviez l'adapter pour Android? </font><font style="vertical-align: inherit;">Si oui, vos concepteurs utilisent-ils souvent des widgets? </font><font style="vertical-align: inherit;">Malheureusement, un widget est un cas rare pour de nombreux développeurs, car il est rare que quelqu'un travaille avec lui. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, je vais vous expliquer en détail comment créer un widget, qui mérite une attention particulière et partagera mon cas.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Création de widgets</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour créer un widget, vous devez savoir:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caractéristiques des composants de widget.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caractéristiques d'affichage du widget dans la grille d'écran.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mises à jour des widgets.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous analyserons chaque élément séparément.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caractéristiques des composants de widget</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout développeur qui a travaillé avec RemoteViews au moins une fois connaît cet élément. </font><font style="vertical-align: inherit;">Si vous en faites partie, n'hésitez pas à passer au point suivant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RemoteViews est conçu pour décrire et gérer les hiérarchies de vues qui appartiennent à un processus dans une autre application. </font><font style="vertical-align: inherit;">À l'aide de la gestion de la hiérarchie, vous pouvez modifier les propriétés ou les méthodes d'appel qui appartiennent à la vue, qui fait partie d'une autre application. </font><font style="vertical-align: inherit;">RemoteViews comprend un ensemble limité de composants de la bibliothèque de composants standard android.widget. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La vue à l'intérieur des widgets fonctionne dans un processus séparé (il s'agit généralement de l'écran d'accueil), par conséquent, pour modifier l'interface utilisateur du widget, utilisez l'extension BroadcastReceiver - AppWidgetProvider, qui fonctionne dans notre application.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caractéristiques d'affichage du widget dans la "grille" de l'écran</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, ce point n'est pas si compliqué, si vous regardez les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">directives officielles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
 <blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque widget doit définir un minWidth et minHeight, indiquant la quantité minimale d'espace qu'il doit consommer par défaut. </font><font style="vertical-align: inherit;">Lorsque les utilisateurs ajoutent un widget à leur écran d'accueil, il occupera généralement plus que la largeur et la hauteur minimales que vous spécifiez. </font><font style="vertical-align: inherit;">Les écrans d'accueil Android offrent aux utilisateurs une grille d'espaces disponibles dans lesquels ils peuvent placer des widgets et des icônes. </font><font style="vertical-align: inherit;">Cette grille peut varier selon un appareil; </font><font style="vertical-align: inherit;">par exemple, de nombreux combinés offrent une grille 4x4, et les tablettes peuvent offrir une grille 8x7 plus grande.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Traduction en russe: chaque widget doit définir sa largeur et sa hauteur minimales pour indiquer l'espace minimum qu'il occupera par défaut. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6r/p-/ux/6rp-uxyfekjzwlpantqmxkdfaio.png" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple de paramètres de widget lors de la création dans Android Studio Un</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
widget qui a été ajouté à l'écran d'accueil prendra généralement plus d'espace que la largeur et la hauteur minimales de l'écran que vous définissez. Les écrans d'accueil d'Android fournissent aux utilisateurs une grille d'espaces disponibles dans lesquels se trouvent des widgets et des icônes. Cette grille peut varier selon l'appareil; par exemple, de nombreux téléphones proposent des grilles 4x4 et les tablettes peuvent proposer de grandes grilles 8x4.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De cela, il devient clair que la grille de l'appareil peut être n'importe quoi, et la taille des cellules peut varier, selon la taille de la grille. </font><font style="vertical-align: inherit;">Par conséquent, le contenu du widget doit être conçu en tenant compte de ces fonctionnalités. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La largeur et la hauteur minimales du widget pour un nombre donné de colonnes et de lignes peuvent être calculées à l'aide de la formule: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
minSideSizeDp = 70 × n - 30, où n est le nombre de lignes ou de colonnes. Pour </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
le moment, la grille minimale maximale que vous pouvez définir est 4x4. </font><font style="vertical-align: inherit;">Cela garantit que votre widget sera affiché sur tous les appareils.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mises à jour des widgets</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que AppWidgetProvider est essentiellement une extension de BroadcastReceiver, vous pouvez faire la même chose qu'avec un BroadcastReceiver standard. AppWidgetProvider analyse simplement les champs correspondants de l'intention reçue dans onReceive et appelle les méthodes d'interception avec les extras reçus. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La difficulté est apparue avec la fréquence de mise à jour du contenu - tout l'intérêt est la différence dans le fonctionnement interne des widgets sur iOS et Android. Le fait est que les données sur les widgets iOS sont mises à jour lorsque le widget devient visible pour l'utilisateur. Sous Android, un tel événement n'existe pas. Nous ne pouvons pas savoir quand l'utilisateur voit le widget.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour les widgets sur Android, la méthode de mise à jour recommandée est une mise à jour par minuterie. </font><font style="vertical-align: inherit;">Les paramètres du minuteur sont définis par le paramètre de widget updatePeriodMillis. </font><font style="vertical-align: inherit;">Malheureusement, ce paramètre ne permet pas de mettre à jour le widget plus d'une fois toutes les 30 minutes. </font><font style="vertical-align: inherit;">Ci-dessous, je vais en parler plus en détail.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cas de widget</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus loin, nous parlerons du cas que nous avons eu à FINCH dans une grande application de loterie avec l'application Stoloto pour participer à des loteries d'État. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tâche de l'application est de simplifier et de rendre transparent pour l'utilisateur le choix d'une loterie et l'achat d'un billet. </font><font style="vertical-align: inherit;">Par conséquent, la fonctionnalité requise du widget est assez simple: montrez les jeux recommandés par l'utilisateur à l'achat et appuyez sur pour aller à celui correspondant. </font><font style="vertical-align: inherit;">La liste des jeux est déterminée sur le serveur et mise à jour régulièrement. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre cas, la conception du widget comprenait deux états:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour utilisateur autorisé</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour un utilisateur non autorisé</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un utilisateur autorisé doit montrer ses données de profil: l'état du portefeuille interne, le nombre de billets en attente du tirage et le nombre de gains perdus. </font><font style="vertical-align: inherit;">Pour chacun de ces éléments, une transition vers l'écran à l'intérieur de l'application est prévue, différente des autres. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rp/d2/6i/rpd26ixtdxfjopibvmgaaczfkco.png" alt="image"><br>
<br>
<img src="https://habrastorage.org/webt/dk/yy/qx/dkyyqxqcnopxezwhknrmqbuedgu.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous l'avez peut-être remarqué, une autre fonctionnalité pour un utilisateur autorisé est le bouton «rafraîchir», mais plus à ce sujet plus tard. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour implémenter l'affichage de deux états, en tenant compte de la conception, j'ai utilisé RemoteAdapter comme implémentation de RemoteViewsService pour générer des cartes de contenu. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant un peu de code et comment tout fonctionne à l'intérieur. </font><font style="vertical-align: inherit;">Si vous avez déjà eu de l'expérience avec le widget, vous savez que toute mise à jour des données du widget commence par la méthode onUpdate:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onUpdate</span><span class="hljs-params">(
        context: <span class="hljs-type">Context</span>,
        appWidgetManager: <span class="hljs-type">AppWidgetManager</span>,
        appWidgetIds: <span class="hljs-type">IntArray</span>
    )</span></span> {<font></font>
        injector.openScope(<span class="hljs-keyword">this</span>, *arrayOf(<span class="hljs-keyword">this</span>))
        <span class="hljs-comment">// update each of the widgets with the remote adapter</span><font></font>
        appWidgetIds<font></font>
            .forEach {<font></font>
                updateWidget(context, appWidgetManager, it)<font></font>
          }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous écrivons une mise à jour pour chaque instance de notre widget.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateWidget</span><span class="hljs-params">(
        context: <span class="hljs-type">Context</span>,
        appWidgetManager: <span class="hljs-type">AppWidgetManager</span>,
        appWidgetId: <span class="hljs-type">Int</span>
    )</span></span> {
<span class="hljs-comment">// remoteViews   widgetId</span>
        <span class="hljs-keyword">val</span> remoteViews = RemoteViews(<font></font>
            context.packageName,<font></font>
            R.layout.app_widget_layout<font></font>
...<font></font>
<span class="hljs-comment">//        </span><font></font>
...<font></font>
<span class="hljs-comment">//    remoteViews</span><font></font>
updateRemoteAdapter(context, remoteViews, appWidgetId)<font></font>
 <font></font>
<span class="hljs-comment">//   remoteViews </span><font></font>
appWidgetManager.updateAppWidget(appWidgetId, remoteViews)<font></font>
<span class="hljs-comment">// collection view  </span><font></font>
appWidgetManager.notifyAppWidgetViewDataChanged(<font></font>
            appWidgetId,<font></font>
            R.id.lvWidgetItems<font></font>
        )<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mise à jour de l'adaptateur.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateRemoteAdapter</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, remoteViews: <span class="hljs-type">RemoteViews</span>, appWidgetId: <span class="hljs-type">Int</span>)</span></span> {
<span class="hljs-comment">//   RemoteViewsService   RemoteAdapter   </span>
        <span class="hljs-keyword">val</span> adapterIntent = Intent(context, StolotoAppWidgetRemoteViewsService::<span class="hljs-keyword">class</span>.java).apply {<font></font>
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)<font></font>
        }<font></font>
        remoteViews.setRemoteAdapter(R.id.lvWidgetItems, adapterIntent)<font></font>
// actionIntent  pendingIntent      <font></font>
        <span class="hljs-keyword">val</span> actionIntent = Intent(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java).apply {<font></font>
            action = WIDGET_CLICK_ACTION<font></font>
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)<font></font>
        }<font></font>
        <span class="hljs-keyword">val</span> pendingIntent = PendingIntent.getBroadcast(<font></font>
            context, <span class="hljs-number">0</span>, actionIntent,<font></font>
            PendingIntent.FLAG_UPDATE_CURRENT<font></font>
        )<font></font>
<span class="hljs-comment">// pendingIntent      </span><font></font>
        remoteViews.setPendingIntentTemplate(R.id.lvWidgetItems, pendingIntent)<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous écrivons la mise en œuvre de notre service. </font><font style="vertical-align: inherit;">Dans ce document, il est important pour nous d'indiquer quelle implémentation de l'interface RemoteViewsService.RemoteViewsFactory utiliser pour générer du contenu.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StolotoAppWidgetRemoteViewsService</span> : <span class="hljs-type">RemoteViewsService</span></span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onGetViewFactory</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>)</span></span>: RemoteViewsFactory =<font></font>
        StolotoAppWidgetRemoteViewsFactory(<font></font>
            <span class="hljs-keyword">this</span>.applicationContext,<font></font>
            intent<font></font>
        )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit en fait d'une mince enveloppe sur l'adaptateur. </font><font style="vertical-align: inherit;">Grâce à lui, nous pouvons associer nos données à une vue de collecte à distance. </font><font style="vertical-align: inherit;">RemoteViewsFactory fournit des méthodes pour générer des RemoteViews pour chaque élément du jeu de données. </font><font style="vertical-align: inherit;">Le constructeur n'a pas d'exigences - tout ce que je fais, c'est y passer le contexte. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, quelques mots sur les principales méthodes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onCreate - création d'un adaptateur.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getLoadingView - la méthode suggère de retourner la vue, que le système affichera au lieu des éléments de la liste lors de leur création. </font><font style="vertical-align: inherit;">Si vous ne créez rien ici, le système utilise une vue par défaut.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getViewAt - la méthode suggère de créer des éléments de liste. </font><font style="vertical-align: inherit;">Voici l'utilisation standard de RemoteViews.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onDataSetChanged est appelé lorsqu'une demande de mise à jour des données de la liste est reçue. </font><font style="vertical-align: inherit;">Ceux. </font><font style="vertical-align: inherit;">Dans cette méthode, nous préparons les données pour la liste. </font><font style="vertical-align: inherit;">La méthode est affinée par l'exécution de code long et lourd.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onDestroy est appelé lorsque la dernière liste que l'adaptateur utilisé est supprimée (un adaptateur peut être utilisé par plusieurs listes).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RemoteViewsFactory vit tant que toutes les instances de la liste sont vivantes, nous pouvons donc y stocker des données actuelles, par exemple une liste d'éléments en cours.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Définissez une liste de données que nous afficherons:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> widgetItems = ArrayList&lt;WidgetItem&gt;()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la création de l'adaptateur, nous commençons à charger les données. </font><font style="vertical-align: inherit;">Ici, vous pouvez effectuer en toute sécurité toutes les tâches difficiles, y compris marcher tranquillement dans le réseau en bloquant le flux.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
        updateDataSync()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de l'appel de la commande pour mettre à jour les données, nous appelons également updateDataSync ()</font></font><br>
<br>
<pre><code class="kotlin hljs">   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDataSetChanged</span><span class="hljs-params">()</span></span> {<font></font>
        updateDataSync()<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans updateDataSync, tout est aussi simple. </font><font style="vertical-align: inherit;">Nous effaçons la liste actuelle des éléments. </font><font style="vertical-align: inherit;">Téléchargez le profil et les données du jeu.</font></font><br>
<br>
<pre><code class="kotlin hljs"> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateDataSync</span><span class="hljs-params">()</span></span> {<font></font>
        widgetItems.clear()<font></font>
        updateProfileSync()<font></font>
        updateGamesSync()<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est plus intéressant ici</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateProfileSync</span><span class="hljs-params">()</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisqu'il est important pour nous d'afficher le profil uniquement à un utilisateur autorisé, nous devons télécharger les informations de profil uniquement dans ce cas:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> isUserFullAuth = isUserFullAuthInteractor<font></font>
            .execute()<font></font>
            .blockingGet()<font></font>
        <span class="hljs-keyword">if</span> (isUserFullAuth) {
            <span class="hljs-keyword">val</span> profile = getWidgetProfileInteractor<font></font>
                .execute()<font></font>
                .onErrorReturn {<font></font>
                    WidgetProfile()<font></font>
<span class="hljs-comment">//           </span><font></font>
                }<font></font>
                .blockingGet()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le modèle WidgetProfile est assemblé à partir de différentes sources, de sorte que la logique de leur réception et ses valeurs par défaut sont organisées de telle sorte qu'une valeur de portefeuille négative indique des données incorrectes ou des problèmes avec leur réception. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour la logique métier, le manque de données de portefeuille est critique, par conséquent, dans le cas d'un portefeuille incorrect, un modèle de profil ne sera pas créé et ajouté à la liste des éléments.</font></font><br>
<br>
<pre><code class="kotlin hljs">  <span class="hljs-keyword">if</span> (profile.walletAmount &gt;= <span class="hljs-number">0L</span>) {<font></font>
                widgetItems.add(<font></font>
                    WidgetItem.Profile(<font></font>
                        wallet = profile.walletAmount.toMoneyFormat(),<font></font>
                        waitingTickets = <span class="hljs-keyword">if</span> (profile.waitingTicketsCount &gt;= <span class="hljs-number">0</span>) profile.waitingTicketsCount.toString() <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>,<font></font>
                        unpaidPrizeAmount = <span class="hljs-keyword">if</span> (profile.unpaidPrizeAmount &gt;= <span class="hljs-number">0</span>) profile.unpaidPrizeAmoount.toMoneyFormat() <span class="hljs-keyword">else</span> <span class="hljs-string">""</span><font></font>
                    )<font></font>
                )<font></font>
            }<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La méthode updateGamesSync () utilise getWidgetGamesInteractor et ajoute un ensemble de jeux pertinents pour le widget à la liste widgetItems. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de passer à la génération de cartes, considérez le modèle WidgetItem plus en détail. </font><font style="vertical-align: inherit;">Il est implémenté via la classe scellée kotlin, ce qui rend le modèle plus flexible et il est plus pratique de travailler avec.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetItem</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Profile</span></span>(
        <span class="hljs-keyword">val</span> wallet: String,
        <span class="hljs-keyword">val</span> waitingTickets: String,
        <span class="hljs-keyword">val</span> unpaidPrizeAmount: String<font></font>
    ) : WidgetItem()<font></font>
 <font></font>
    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span></span>(
        <span class="hljs-keyword">val</span> id: String,
        <span class="hljs-keyword">val</span> iconId: <span class="hljs-built_in">Int</span>,
        <span class="hljs-keyword">val</span> prizeValue: String,
        <span class="hljs-keyword">val</span> date: String<font></font>
    ) : WidgetItem()<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créez des vues à distance et déterminez leur réponse via FillInIntent</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getViewAt</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span>: RemoteViews {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> item = widgetItems[position]) {
            <span class="hljs-keyword">is</span> WidgetItem.Profile -&gt; {<font></font>
              RemoteViews(<font></font>
                        context.packageName,<font></font>
                        R.layout.item_widget_user_profile<font></font>
                    ).apply {<font></font>
                        setTextViewText(R.id.tvWidgetWalletMoney, item.wallet)<font></font>
                        setTextViewText(R.id.tvWidgetUnpaidCount, item.unpaidPrizeAmount)<font></font>
                        setTextViewText(R.id.tvWidgetWaitingCount, item.waitingTickets)<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileWallet, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_USER_WALLET<font></font>
                            )<font></font>
                        )<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileUnpaid, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_UNPAID_PRIZE<font></font>
                            )<font></font>
                        )<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileWaiting, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_WAITING_TICKETS<font></font>
                            )<font></font>
                        )<font></font>
                    }<font></font>
 <font></font>
            <span class="hljs-keyword">is</span> WidgetItem.Game -&gt; {<font></font>
                RemoteViews(<font></font>
                    context.packageName,<font></font>
                    R.layout.item_widget_game<font></font>
                ).apply {<font></font>
                    setImageViewResource(R.id.ivWidgetGame, item.iconId)<font></font>
                    setTextViewText(R.id.tvWidgetGamePrize, item.prizeValue)<font></font>
                    setTextViewText(R.id.tvWidgetGameDate, item.date)<font></font>
                    setOnClickFillInIntent(<font></font>
                        R.id.llWidgetGame, Intent().putExtra(<font></font>
                            StolotoAppWidgetProvider.KEY_GAME_CLICK, item.id<font></font>
                        )<font></font>
                    )<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La méthode setOnClickFillInIntent attribue l'intention viewId spécifiée, qui sera combinée avec le parent PendingIntent pour déterminer le comportement lorsque vous cliquez sur la vue avec cet viewId. </font><font style="vertical-align: inherit;">De cette façon, nous pouvons répondre aux clics des utilisateurs dans notre WidgetProvider.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mise à jour manuelle du widget</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une heure de mise à jour d'une demi-heure a été fixée pour notre widget. Vous pouvez le mettre à jour plus souvent, par exemple, en dansant avec WorkManager, mais pourquoi charger votre réseau et votre batterie? Un tel comportement aux premiers stades de développement semblait adéquat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout a changé lorsque «l'entreprise» a remarqué que lorsque l'utilisateur regarde le widget, les données non pertinentes y sont affichées: «Ici, sur mon iPhone, j'ouvre le widget et il y a les données LES PLUS fraîches de mon profil.» </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La situation est courante: iOS génère de nouvelles cartes pour CHAQUE affichage de widget, car pour cela, ils ont un écran spécial, et Android n'a pas de tels événements pour le widget en principe. J'ai dû tenir compte du fait que certaines loteries ont lieu une fois toutes les 15 minutes, donc le widget devrait donner des informations à jour - vous voulez participer à une sorte de tirage, mais c'est déjà passé.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin de sortir de cette situation désagréable et de résoudre le problème de la mise à jour des données, j'ai proposé et implémenté une solution éprouvée - le bouton «mise à jour». </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ajoutez ce bouton à la mise en page avec la liste et initialisez son comportement lorsque updateWidget est appelé.</font></font><br>
<br>
<pre><code class="kotlin hljs">...
<span class="hljs-comment">// Intent   AppWidgetManager.ACTION_APPWIDGET_UPDATE</span>
<span class="hljs-keyword">val</span> intentUpdate = Intent(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java)<font></font>
intentUpdate.action = AppWidgetManager.ACTION_APPWIDGET_UPDATE<font></font>
<font></font>
//    <font></font>
<span class="hljs-keyword">val</span> ids = AppWidgetManager.getInstance(context)<font></font>
   .getAppWidgetIds(ComponentName(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java))<font></font>
intentUpdate.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, ids)<font></font>
<font></font>
//  intent  PendingIntent,  PendingIntent.getBroadcast()<font></font>
<span class="hljs-keyword">val</span> pendingUpdate = PendingIntent.getBroadcast(<font></font>
   context,<font></font>
   appWidgetId,<font></font>
   intentUpdate,<font></font>
   PendingIntent.FLAG_UPDATE_CURRENT<font></font>
)<font></font>
//  pendingIntent      ‘’<font></font>
remoteViews.setOnClickPendingIntent(R.id.ivWidgetRefresh, pendingUpdate)<font></font>
…</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les premiers développements ont montré une triste image: de l’appui sur le bouton «mise à jour» à la mise à jour proprement dite, plusieurs secondes pouvaient s'écouler. </font><font style="vertical-align: inherit;">Bien que le widget soit généré par notre application, il est en réalité sous le contrôle du système et communique avec notre application via des diffusions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceux. </font><font style="vertical-align: inherit;">lorsque vous cliquez sur le bouton "mettre à jour" de notre widget, la chaîne démarre:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenez l'intention dans l'action du fournisseur onReceive.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppWidgetManager.ACTION_APPWIDGET_UPDATE. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appelez onUpdate pour tous les widgetsIds spécifiés dans intent-e.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allez en ligne pour de nouvelles données.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actualisez les données locales et affichez de nouvelles cartes de liste.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conséquence, la mise à jour du widget n'était pas très agréable, car en cliquant sur le bouton, nous avons regardé le même widget pendant quelques secondes. </font><font style="vertical-align: inherit;">Il n'était pas clair si les données étaient mises à jour. </font><font style="vertical-align: inherit;">Comment résoudre le problème de la réponse visuelle? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, j'ai ajouté le drapeau isWidgetLoading avec un accès global via l'interacteur. </font><font style="vertical-align: inherit;">Le rôle de ce paramètre est assez simple - n'affichez pas le bouton d'actualisation pendant le chargement des données du widget. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deuxièmement, j'ai divisé le processus de chargement des données dans l'usine en trois étapes:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadingStep</span> </span>{<font></font>
   START,<font></font>
   MIDDLE,<font></font>
   END<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
START - début du téléchargement. </font><font style="vertical-align: inherit;">À ce stade, l'état de toutes les vues de l'adaptateur et l'indicateur de téléchargement global deviennent «chargement». </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MIDDLE - l'étape du chargement des données principales. </font><font style="vertical-align: inherit;">Une fois téléchargés, l'indicateur de téléchargement global est mis à l'état «chargé» et les données téléchargées sont affichées dans l'adaptateur. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
END - fin du téléchargement. </font><font style="vertical-align: inherit;">L'adaptateur n'a pas besoin de modifier les données de l'adaptateur à cette étape. </font><font style="vertical-align: inherit;">Cette étape est nécessaire pour traiter correctement l'étape de mise à jour des vues dans WidgetProvider. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons plus en détail à quoi ressemble la mise à jour des boutons dans le fournisseur:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">if</span> (isFullAuthorized &amp;&amp; !widgetLoadingStateInteractor.isWidgetLoading) {<font></font>
   remoteViews.setViewVisibility(R.id.ivWidgetRefresh, View.VISIBLE)<font></font>
...<font></font>
<span class="hljs-comment">//     ,    </span><font></font>
...   <font></font>
} <span class="hljs-keyword">else</span> {<font></font>
   remoteViews.setViewVisibility(<font></font>
       R.id.ivWidgetRefresh,<font></font>
       <span class="hljs-keyword">if</span> (isFullAuthorized) View.INVISIBLE <span class="hljs-keyword">else</span> View.GONE <span class="hljs-comment">//       .</span><font></font>
   )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant ce qui se passe dans l'adaptateur:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateDataSync</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">when</span> (loadingStep) {<font></font>
       START -&gt; {<font></font>
           widgetItems.forEach { it.isLoading = <span class="hljs-literal">true</span> }<font></font>
           widgetLoadingStateInteractor.isWidgetLoading = <span class="hljs-literal">true</span><font></font>
           loadingStep = MIDDLE<font></font>
           widgetManager.updateWidgets()<font></font>
       }<font></font>
       MIDDLE -&gt; {<font></font>
           widgetItems.clear()<font></font>
           updateProfileSync()<font></font>
           updateGamesSync()<font></font>
           widgetLoadingStateInteractor.isWidgetLoading = <span class="hljs-literal">false</span><font></font>
           loadingStep = END<font></font>
           widgetManager.updateWidgets()<font></font>
       }<font></font>
       END -&gt; {<font></font>
           loadingStep = START<font></font>
       }<font></font>
   }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/bq/ah/hg/bqahhgnwugy10345-bcegnupxo8.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Logique de travail: </font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À la fin des étapes START et MIDDLE, j'appelle la méthode updateWidgets pour mettre à jour l'état d'affichage géré par le fournisseur.</font></font></li>
<li>   START     «»   ,    MIDDLE.</li>
<li>         MIDDLE,    «».</li>
<li>   MIDDLE,          END. </li>
<li>      ,   END,    «».        ,    END   loadingStep  START.</li>
</ol><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec l'aide d'une telle implémentation, je suis parvenu à un compromis entre l'exigence de "l'entreprise" de voir les données réelles sur le widget et la nécessité de "tirer" la mise à jour trop souvent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'espère que l'article vous a été utile. </font><font style="vertical-align: inherit;">Si vous aviez de l'expérience dans la création de widgets pour Android, dites-le nous dans les commentaires. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bonne chance</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr492150/index.html">Implémentez-le complètement. Di-in-js</a></li>
<li><a href="../fr492154/index.html">Le lancement d'ExoMars reporté à la prochaine fenêtre de lancement en 2022</a></li>
<li><a href="../fr492156/index.html">Soustrait. Vouloir. Faire</a></li>
<li><a href="../fr492162/index.html">Interfaces oculaires. Signaler dans Yandex</a></li>
<li><a href="../fr492164/index.html">Passerelle vers le ciel ou la ville du futur</a></li>
<li><a href="../fr492168/index.html">Travail de front sur le développement back-end des plus grands portails sur les logiciels open source: partage d'expérience</a></li>
<li><a href="../fr492172/index.html">Sauvegarde fine des systèmes de fichiers Linux. Comment créer des copies de travail d'un SGBD MySQL de trois téraoctets en 20 secondes</a></li>
<li><a href="../fr492174/index.html">Moniteur sans fil d'humidité du sol</a></li>
<li><a href="../fr492178/index.html">Un chemin de sept mille pixels: évolution des résolutions d'écran et de nos exigences</a></li>
<li><a href="../fr492182/index.html">Fondements de la sécurité de l'information chez Microsoft Teams</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>