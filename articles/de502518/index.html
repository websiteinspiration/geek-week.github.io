<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèΩ üìº üòí Wie man auf einen Baum klettert üõÉ üëèüèø üë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Genauer gesagt, wie man davon runterkommt. Aber das Wichtigste zuerst. Dieser Artikel ist etwas au√üerhalb des √ºblichen Artikelformats von PVS-Studio. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wie man auf einen Baum klettert</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/502518/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/qf/qz/ys/qfqzys_fndtbks6hb68atbrnyrq.png" alt="Bild 2"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Genauer gesagt, wie man davon runterkommt. </font><font style="vertical-align: inherit;">Aber das Wichtigste zuerst. </font><font style="vertical-align: inherit;">Dieser Artikel ist etwas au√üerhalb des √ºblichen Artikelformats von PVS-Studio. </font><font style="vertical-align: inherit;">Wir schreiben oft √ºber die √úberpr√ºfung anderer Projekte, √∂ffnen aber fast nie die T√ºr zu unserer inneren K√ºche. </font><font style="vertical-align: inherit;">Es ist Zeit, das Problem zu beheben und dar√ºber zu sprechen, wie der Analysator von innen aufgebaut ist. </font><font style="vertical-align: inherit;">Genauer gesagt √ºber den wichtigsten seiner Teile - den Syntaxbaum. </font><font style="vertical-align: inherit;">Der Artikel konzentriert sich auf den Teil von PVS-Studio, der sich auf die Sprachen C und C ++ bezieht.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das wichtigste zuerst</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Syntaxbaum ist der zentrale Teil eines jeden Compilers. Auf die eine oder andere Weise muss der Code in einer f√ºr die Programmverarbeitung geeigneten Form dargestellt werden, und es kommt einfach so vor, dass die Baumstruktur daf√ºr am besten geeignet ist. Ich werde hier nicht auf die Theorie eingehen - es gen√ºgt zu sagen, dass der Baum die Hierarchie der Ausdr√ºcke und Bl√∂cke im Code sehr gut widerspiegelt und gleichzeitig nur die f√ºr die Arbeit erforderlichen Daten enth√§lt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was hat der Compiler mit dem statischen Analysator zu tun? Tatsache ist, dass diese beiden Tools viel gemeinsam haben. In der Anfangsphase des Parsens des Codes erledigen sie den gleichen Job. Zun√§chst wird der Code in einen Token-Stream unterteilt, der dem Parser zugef√ºhrt wird. W√§hrend der syntaktischen und semantischen Analyse werden Token dann in einem Baum organisiert, der weiter entlang der Pipeline gesendet wird. In dieser Phase k√∂nnen Compiler Zwischenoptimierungen durchf√ºhren, bevor sie Bin√§rcode generieren. Statische Analysatoren beginnen, Knoten zu umgehen und verschiedene √úberpr√ºfungen zu starten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im PVS-Studio-Analyseger√§t mit einem erstellten Baum passieren verschiedene Dinge:</font></font><br>
<br>
<ul>
<li>    .    , , ,     <i>using </i>  <i>typedef</i>,   . ,  .         ;</li>
<li>     .  ,          ;</li>
<li>   ,      ,    ,      ;</li>
<li>  .        (      ).          . ,         <i>nullptr</i>    ,    ,         .       ;</li>
<li>  .      ,      .        ,    .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich f√ºr Details zur Funktionsweise der Analyse interessieren, empfehlen wir Ihnen, den Artikel ‚Äû </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im PVS-Studio Code Analyzer verwendete Technologien zum Auffinden von Fehlern und potenziellen Sicherheitsl√ºcken</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äú zu </font><font style="vertical-align: inherit;">lesen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Einige Punkte aus der Liste werden dort ausf√ºhrlich untersucht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden genauer untersuchen, was mit dem Baum im Analysator passiert und wie er √ºberhaupt aussieht. </font><font style="vertical-align: inherit;">Nach einer kurzen Einf√ºhrung ist es an der Zeit, der Sache auf den Grund zu gehen.</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/si/xk/o4/sixko4j1_uucanebxzup6slqpf8.png" alt="Bild 1"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie es funktioniert</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Vergangenheit verwendet PVS-Studio einen Bin√§rbaum zur Darstellung von Code. Diese klassische Datenstruktur ist jedem bekannt - wir haben einen Knoten, der sich im Allgemeinen auf zwei Kinder bezieht. Knoten, die keine Nachkommen haben sollen, werde ich Terminals nennen, alle anderen - Nicht-Terminals. Ein Nichtterminal kann in einigen F√§llen keine untergeordneten Knoten haben, aber sein Hauptunterschied zum Terminal besteht darin, dass Nachkommen grunds√§tzlich daf√ºr zugelassen sind. Endknoten (oder Bl√§tter) k√∂nnen nicht auf etwas anderes als das √ºbergeordnete Knoten verweisen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die in PVS-Studio verwendete Struktur unterscheidet sich geringf√ºgig vom klassischen Bin√§rbaum - dies ist aus praktischen Gr√ºnden erforderlich. </font><font style="vertical-align: inherit;">Endknoten entsprechen normalerweise Schl√ºsselw√∂rtern, Variablennamen, Literalen usw. </font><font style="vertical-align: inherit;">Nichtterminale - verschiedene Arten von Ausdr√ºcken, Codebl√∂cken, Listen und dergleichen, die Bestandteile des Baums. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus Sicht der Compiler ist hier alles ziemlich normal, ich rate jedem, der sich f√ºr die Klassiker des Genres interessiert - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Dragon Book</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gehen weiter. </font><font style="vertical-align: inherit;">Schauen wir uns ein einfaches Codebeispiel an und wie der Analysator es sieht. </font><font style="vertical-align: inherit;">Au√üerdem werden viele Bilder von unserem internen Dienstprogramm zur Baumvisualisierung angezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eigentlich ein Beispiel:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span>
</span>{
  <span class="hljs-keyword">return</span> a + b;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese einfache Funktion sieht nach der Verarbeitung durch den Parser folgenderma√üen aus (nicht terminale Knoten werden gelb hervorgehoben):</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/eo/nj/od/eonjodrufyrv6p3w2riiysnfnpo.png" alt="Bild 6"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Ansicht hat ihre Vor- und Nachteile, und letztere meiner Meinung nach etwas mehr. Aber schauen wir uns den Baum an. Machen Sie sofort einen Vorbehalt, dass es etwas √ºberfl√ºssig ist, zum Beispiel weil es Interpunktion und Klammern enth√§lt. Unter dem Gesichtspunkt der Kompilierung ist dies √ºberfl√ºssiger M√ºll, aber solche Informationen werden manchmal vom Analysator f√ºr einige Diagnoseregeln ben√∂tigt. Mit anderen Worten, der Analysator arbeitet nicht mit dem abstrakten Syntaxbaum (AST), sondern mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Analysebaum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (DT). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Baum w√§chst von links nach rechts und von oben nach unten. Linke untergeordnete Knoten enthalten immer etwas Sinnvolles, z. B. Deklaratoren. Wenn Sie nach rechts schauen, sehen Sie Zwischen-Nicht-Terminals, die mit dem Wort </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NonLeaf gekennzeichnet sind</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie werden nur ben√∂tigt, damit der Baum seine Struktur beh√§lt. </font><font style="vertical-align: inherit;">F√ºr die Anforderungen der Analyse tragen solche Knoten keine Informationslast. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend wir uns f√ºr den linken Teil des Baumes interessieren werden. </font><font style="vertical-align: inherit;">Hier ist es in einer gr√∂√üeren Nahaufnahme:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/vf/gm/ku/vfgmku_i7oq4oakzu_2gnowmfk8.png" alt="Bild 10"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Anzeige bietet. </font><font style="vertical-align: inherit;">Der √ºbergeordnete </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeDeclarator-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Knoten </font><font style="vertical-align: inherit;">ist ein Objekt, √ºber das Sie auf Knoten mit dem Namen der Funktion und ihren Parametern zugreifen k√∂nnen. </font><font style="vertical-align: inherit;">Es speichert auch die codierte Signatur f√ºr das Typsystem. </font><font style="vertical-align: inherit;">Es scheint mir, dass dieses Bild ziemlich visuell ist und es ziemlich einfach ist, die Elemente des Baums mit dem Code zu vergleichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sieht einfach aus, oder? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir zur Verdeutlichung ein einfacheres Beispiel. </font><font style="vertical-align: inherit;">Stellen Sie sich vor, wir haben Code, der unsere Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufruft </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs">f(<span class="hljs-number">42</span>, <span class="hljs-number">23</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Funktionsaufruf im Baum sieht folgenderma√üen aus:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/mf/jx/r2/mfjxr27uqexjmd3olssajdys7lw.png" alt="Bild 12"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Struktur ist sehr √§hnlich, nur hier sehen wir einen Funktionsaufruf anstelle seiner Deklaration. Nehmen wir nun an, wir wollten alle Argumente durchgehen und mit jedem etwas anfangen. Dies ist eine echte Aufgabe, die h√§ufig im Analysatorcode enthalten ist. Es ist klar, dass nicht alles auf Argumente beschr√§nkt ist und verschiedene Knotentypen sortiert werden m√ºssen, aber jetzt werden wir dieses spezielle Beispiel betrachten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben nur einen Zeiger auf den √ºbergeordneten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FUNCALL-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Knoten </font><font style="vertical-align: inherit;">. Von jedem Nicht-Terminal k√∂nnen wir den linken und rechten untergeordneten Knoten erhalten. Der Typ von jedem von ihnen ist bekannt. Wir kennen die Struktur des Baums, so dass wir sofort den Knoten erreichen k√∂nnen, unter dem die Liste der Argumente liegt - dies ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NonLeaf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , von dem aus das Terminal im Bild </font><i><font style="vertical-align: inherit;">42</font></i><font style="vertical-align: inherit;"> w√§chst</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir kennen die Anzahl der Argumente nicht im Voraus und es gibt Kommas in der Liste, die in diesem Fall f√ºr uns absolut nicht von Interesse sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie machen wir das? </font><font style="vertical-align: inherit;">Weiter lesen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fahrradfabrik</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass das Durchlaufen eines Baumes recht einfach ist. Sie m√ºssen nur eine Funktion schreiben, die dies erledigt, und sie √ºberall verwenden. Es ist m√∂glich, ein Lambda als Argument f√ºr jedes Element zu √ºbergeben. Es w√§re wirklich so, wenn nicht ein paar Nuancen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens muss es etwas anders sein, jedes Mal um einen Baum herumzugehen. Die Logik der Verarbeitung jedes Knotens ist unterschiedlich, ebenso wie die Logik der Arbeit mit der gesamten Liste. Angenommen, in einem Fall m√∂chten wir die Listenargumente durchgehen und jedes von ihnen zur Verarbeitung an eine bestimmte Funktion √ºbergeben. In einem anderen Fall m√∂chten wir ein Argument ausw√§hlen und zur√ºckgeben, das einige Anforderungen erf√ºllt. Oder filtern Sie die Liste und verwerfen Sie alle uninteressanten Elemente daraus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens m√ºssen Sie manchmal den Index des aktuellen Elements kennen. </font><font style="vertical-align: inherit;">Zum Beispiel wollen wir nur die ersten beiden Argumente verarbeiten und aufh√∂ren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Drittens schweifen wir vom Funktionsbeispiel ab. </font><font style="vertical-align: inherit;">Angenommen, wir haben folgenden Code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span>
</span>{
  <span class="hljs-keyword">int</span> c = a + b;<font></font>
  c *= <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">42</span>) <span class="hljs-keyword">return</span> c;
  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wei√ü, dieser Code ist dumm, aber konzentrieren wir uns jetzt darauf, wie der Baum aussieht. </font><font style="vertical-align: inherit;">Wir haben bereits eine Funktionsdeklaration gesehen, hier brauchen wir ihren K√∂rper:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/f0/q6/hs/f0q6hsldd42blwuenxmv2t6vl7o.png" alt="Bild 4"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Fall √§hnelt einer Liste von Argumenten, aber Sie k√∂nnen einen Unterschied feststellen. </font><font style="vertical-align: inherit;">Schauen Sie sich das Bild aus dem vorherigen Abschnitt noch einmal an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hast du bemerkt? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Richtig, diese Liste enth√§lt keine Kommas. Das bedeutet, dass Sie sie hintereinander verarbeiten k√∂nnen und sich keine Gedanken √ºber das √úberspringen von Trennzeichen machen m√ºssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Insgesamt haben wir mindestens zwei F√§lle:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getrennte Liste.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die vollst√§ndige Liste.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun sehen, wie dies alles im Analysatorcode geschieht. Hier ist ein Beispiel f√ºr das Durchlaufen einer Liste von Argumenten. Dies ist eine vereinfachte Version einer der Funktionen im √úbersetzer.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessArguments</span><span class="hljs-params">(Ptree* arglist)</span>
</span>{
  <span class="hljs-keyword">if</span> (!arglist) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  Ptree* args = Second(arglist);<font></font>
  <span class="hljs-keyword">while</span> (args)<font></font>
  {<font></font>
    Ptree* p = args-&gt;Car();<font></font>
    <span class="hljs-keyword">if</span> (!Eq(p, <span class="hljs-string">','</span>))<font></font>
    {<font></font>
      ProcessArg(p);<font></font>
    }<font></font>
<font></font>
    args = args-&gt;Cdr();<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ich jedes Mal einen Dollar bekommen w√ºrde, wenn ich einen √§hnlichen Code sehe, w√ºrde ich bereits reich werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, was hier passiert. Ich muss sofort sagen, dass dies sehr alter Code ist, der lange vor C ++ 11 geschrieben wurde, ganz zu schweigen von moderneren Standards. Wir k√∂nnen sagen, dass ich speziell nach einem Fragment der Zeit der alten Zivilisationen gesucht habe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktion akzeptiert also zun√§chst eine Liste von Argumenten in Klammern als Eingabe. Etwa so: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(42, 23) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zweite</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">wird hier aufgerufen, um den Inhalt der Klammern abzurufen. Sie bewegt sich nur einmal nach rechts und dann einmal nach links durch den Bin√§rbaum. Als n√§chstes erh√§lt die Schleife nacheinander die Elemente: 42, dann ein Komma, dann 23 und im n√§chsten Schritt den </font><i><font style="vertical-align: inherit;">Args-</font></i><font style="vertical-align: inherit;"> Zeiger</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird Null, weil wir am Ende des Zweigs angelangt sind. Die Schleife √ºberspringt nat√ºrlich uninteressante Kommas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ñhnliche Funktionen mit leicht ver√§nderter Logik finden sich an vielen Stellen, insbesondere im alten Code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein anderes Beispiel. Woher wei√ü ich, ob eine bestimmte Funktion in einem bestimmten Codeblock aufgerufen wird? Ungef√§hr so:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsFunctionCalled</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* body, <span class="hljs-built_in">std</span>::string_view name)</span>
</span>{
  <span class="hljs-keyword">if</span> (!arglist) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  <span class="hljs-keyword">const</span> Ptree* statements = body;
  <span class="hljs-keyword">while</span> (statements)<font></font>
  {<font></font>
    <span class="hljs-keyword">const</span> Ptree* cur = statements-&gt;Car();
    <span class="hljs-keyword">if</span> (IsA(cur, ntExprStatement) &amp;&amp; IsA(cur-&gt;Car(), ntFuncallExpr))<font></font>
    {<font></font>
      <span class="hljs-keyword">const</span> Ptree* funcName = First(cur-&gt;Car());
      <span class="hljs-keyword">if</span> (Eq(funcName, name))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
<font></font>
    statements = statements-&gt;Cdr();<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis. </font><font style="vertical-align: inherit;">Ein aufmerksamer Leser kann es bemerken. </font><font style="vertical-align: inherit;">Wie alt ist er? </font><font style="vertical-align: inherit;">Dort </font><font style="vertical-align: inherit;">ragt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: string_view</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> heraus. </font><font style="vertical-align: inherit;">Alles ist einfach, selbst der √§lteste Code wird nach und nach √ºberarbeitet und nach und nach bleibt nichts dergleichen √ºbrig. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es w√§re sch√∂n, hier etwas eleganteres zu verwenden, oder? </font><font style="vertical-align: inherit;">Nun, zum Beispiel der Standardalgorithmus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_if</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Was ist der Algorithmus dort, selbst ein normaler bereichsbasierter Algorithmus w√ºrde die Lesbarkeit erheblich verbessern und die Unterst√ºtzung eines solchen Codes erleichtern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir dies zu erreichen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legen Sie den Baum in die Box</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Ziel ist es, dass sich der Baum wie ein STL-Container verh√§lt. </font><font style="vertical-align: inherit;">Dar√ºber hinaus sollten wir uns nicht um die interne Struktur der Listen k√ºmmern, sondern einheitlich √ºber die Knoten iterieren, zum Beispiel wie folgt:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoSomethingWithTree</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* tree)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cur : someTreeContainer)<font></font>
  {<font></font>
    ....<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, haben wir hier eine bestimmte Entit√§t namens </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">someTreeContainer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , von der wir noch nichts wissen. </font><font style="vertical-align: inherit;">Ein solcher Beh√§lter sollte zumindest </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beginnen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ende</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methoden </font><font style="vertical-align: inherit;">die R√ºckkehr Iteratoren. </font><font style="vertical-align: inherit;">Apropos Iteratoren, sie sollten sich auch wie Standard-Iteratoren verhalten. </font><font style="vertical-align: inherit;">Beginnen wir mit ihnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im einfachsten Fall sieht der Iterator folgenderma√üen aus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t,
          <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt;&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeIterator</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> value_type = Node_t;
  <span class="hljs-keyword">using</span> dereference_type = value_type;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer   = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
    <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  ....<font></font>
<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    m_node = Rest(m_node);<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;dereference_type&gt;(First(m_node));<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Code nicht zu √ºberladen, habe ich einige Details entfernt. </font><font style="vertical-align: inherit;">Die wichtigsten Punkte hier sind Dereferenzierung und Inkrementierung. </font><font style="vertical-align: inherit;">Die Vorlage wird ben√∂tigt, damit der Iterator sowohl mit konstanten als auch mit nicht konstanten Daten arbeiten kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt schreiben wir den Container, in dem wir den Baumknoten platzieren. </font><font style="vertical-align: inherit;">Hier ist die einfachste Option:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeContainer</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = PtreeIterator&lt;Node_t&gt;;
  <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> Iterator::dereference_type;
  <span class="hljs-keyword">using</span> size_type  = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">typename</span> Iterator::difference_type;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeContainer(Node_t* nodes) :<font></font>
    m_nodes{ nodes }<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (IsLeaf(m_nodes))<font></font>
    {<font></font>
      m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  ....<font></font>
<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> begin() == end();<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sind fertig, wir k√∂nnen uns zerstreuen, danke f√ºr Ihre Aufmerksamkeit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nein, warte einen Moment. </font><font style="vertical-align: inherit;">So einfach kann es doch nicht sein, oder? </font><font style="vertical-align: inherit;">Kehren wir zu unseren beiden Listenoptionen zur√ºck - mit und ohne Trennzeichen. </font><font style="vertical-align: inherit;">Hier nehmen wir beim Inkrementieren einfach den rechten Knoten des Baums, damit das Problem nicht gel√∂st wird. </font><font style="vertical-align: inherit;">Wir m√ºssen immer noch Kommas √ºberspringen, wenn wir nur mit Daten arbeiten m√∂chten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kein Problem, wir f√ºgen dem Iterator lediglich einen zus√§tzlichen Vorlagenparameter hinzu. </font><font style="vertical-align: inherit;">Sagen wir so:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeIteratorTag</span> :</span> <span class="hljs-keyword">uint8_t</span><font></font>
{<font></font>
  Statement,<font></font>
  List<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, PtreeIteratorTag tag,
  <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt; = <span class="hljs-number">0</span>&gt;<font></font>
class PtreeIterator { .... };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie wird uns das helfen? </font><font style="vertical-align: inherit;">Grundstufe. </font><font style="vertical-align: inherit;">Wir werden diesen Parameter schrittweise √ºberpr√ºfen und uns entsprechend verhalten. </font><font style="vertical-align: inherit;">Gl√ºcklicherweise k√∂nnen wir dies in C ++ 17 in der Kompilierungsphase mit dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstrukt if constexpr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> l√∂sen </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs">PtreeIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
{<font></font>
  <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
  </span>{<font></font>
    m_node = Rest(m_node);<font></font>
  }<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
    m_node = RestRest(m_node);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist besser, jetzt k√∂nnen wir einen Iterator ausw√§hlen, der unseren Anforderungen entspricht. </font><font style="vertical-align: inherit;">Was tun mit Containern? </font><font style="vertical-align: inherit;">Sie k√∂nnen zum Beispiel so aussehen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, PtreeIteratorTag tag&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeContainer</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = PtreeIterator&lt;Node_t, tag&gt;;<font></font>
  ....<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sind wir jetzt definitiv fertig? </font><font style="vertical-align: inherit;">In der Tat nicht wirklich.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber das ist nicht alles</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns diesen Code an:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(Ptree* argList, Ptree* enumPtree)</span>
</span>{
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">ptrdiff_t</span> argListLen = Length(argList);
  <span class="hljs-keyword">if</span> (argListLen &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">ptrdiff_t</span> i = <span class="hljs-number">0</span>; i &lt; argListLen; ++i)<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<font></font>
    Ptree* elem;<font></font>
<font></font>
    <span class="hljs-keyword">const</span> EGetEnumElement r = GetEnumElementInfo(enumPtree, i, elem, name);<font></font>
    ....<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich mag diesen Code wirklich nicht sehr, angefangen von der Schleife mit dem Z√§hler bis hin zur Tatsache, dass die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetEnumElementInfo-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">sehr verd√§chtig aussieht. </font><font style="vertical-align: inherit;">Jetzt bleibt es eine Black Box f√ºr uns, aber wir k√∂nnen davon ausgehen, dass es das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enum-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Element </font><font style="vertical-align: inherit;">nach Index </font><i><font style="vertical-align: inherit;">herausnimmt</font></i><font style="vertical-align: inherit;"> und seinen Namen und Knoten im Baum √ºber die Ausgabeparameter zur√ºckgibt. </font><font style="vertical-align: inherit;">Der R√ºckgabewert ist auch etwas seltsam. </font><font style="vertical-align: inherit;">Lassen Sie es uns ganz loswerden - ein idealer Job f√ºr unseren Listeniterator:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem : PtreeContainer&lt;<span class="hljs-keyword">const</span> Ptree, PtreeIteratorTag::List&gt;(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nicht schlecht. </font><font style="vertical-align: inherit;">Nur dieser Code wird nicht kompiliert. </font><font style="vertical-align: inherit;">Warum? </font><font style="vertical-align: inherit;">Weil der Index, den wir entfernt haben, im Hauptteil der Schleife unterhalb des Aufrufs von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetEnumElementInfo verwendet wurde</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich werde hier nicht genau sagen, wie es verwendet wurde, weil es jetzt nicht wichtig ist. </font><font style="vertical-align: inherit;">Es gen√ºgt zu sagen, dass ein Index ben√∂tigt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, lassen Sie uns eine Variable hinzuf√ºgen und unseren sch√∂nen Code durcheinander bringen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem : PtreeContainer&lt;<span class="hljs-keyword">const</span> Ptree, PtreeIteratorTag::List&gt;(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
    UseIndexSomehow(i++);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Immer noch eine funktionierende Option, aber ich pers√∂nlich reagiere auf so etwas:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ov/11/ie/ov11ieyylfaa2qjppdyjjo-yljy.png" alt="Bild 7"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir, dieses Problem zu l√∂sen. </font><font style="vertical-align: inherit;">Wir brauchen etwas, das Elemente automatisch z√§hlen kann. </font><font style="vertical-align: inherit;">F√ºgen Sie einen Iterator mit einem Z√§hler hinzu. </font><font style="vertical-align: inherit;">Der K√ºrze halber habe ich die zus√§tzlichen Details noch einmal √ºbersprungen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, PtreeIteratorTag tag,
  <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt;&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeCountingIterator</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> value_type = Node_t;
  <span class="hljs-keyword">using</span> dereference_type = <span class="hljs-built_in">std</span>::pair&lt;value_type, size_type&gt;;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeCountingIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  ....<font></font>
<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
    </span>{<font></font>
      m_node = Rest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
      m_node = RestRest(m_node);<font></font>
    }<font></font>
<font></font>
    ++m_counter;<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> { <span class="hljs-keyword">static_cast</span>&lt;value_type&gt;(First(m_node)), counter() };<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
  size_type m_counter = <span class="hljs-number">0</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt k√∂nnen wir solchen Code schreiben, oder?</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [elem, i] :<font></font>
            PtreeCountedContainer&lt;<span class="hljs-keyword">const</span> Ptree, PtreeIteratorTag::List&gt;(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
    UseIndexSomehow(i);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen k√∂nnen wir das wirklich, aber es gibt ein Problem. </font><font style="vertical-align: inherit;">Wenn Sie sich diesen Code ansehen, werden Sie m√∂glicherweise feststellen, dass wir eine andere Entit√§t eingef√ºhrt haben - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeCountedContainer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es scheint, dass die Situation kompliziert wird. </font><font style="vertical-align: inherit;">Ich m√∂chte wirklich nicht mit verschiedenen Arten von Beh√§ltern jonglieren, und da sie innen gleich sind, greift die Hand selbst nach Occams Rasiermesser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir m√ºssen einen Iterator als Vorlagenparameter f√ºr den Container verwenden, aber dazu sp√§ter mehr.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zootypen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lenken Sie f√ºr eine Minute von Z√§hlern und verschiedenen Iteratoren ab. </font><font style="vertical-align: inherit;">Bei der Verfolgung einer universellen Umgehung von Knoten haben wir das Wichtigste vergessen - den Baum selbst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich diesen Code an:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> a, b, c = <span class="hljs-number">0</span>, d;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was wir im Baum sehen:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/mi/cq/sh/micqshmftdnb7xstjo71sng02s4.png" alt="Bild 13"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun die Liste der Deklaratoren durchlaufen, aber zuerst werde ich Ihnen noch etwas √ºber den Baum erz√§hlen. </font><font style="vertical-align: inherit;">Die ganze Zeit zuvor hatten wir es mit einem Zeiger auf die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ptree-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse zu </font><i><font style="vertical-align: inherit;">tun</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies ist die Basisklasse, von der alle anderen Knotentypen geerbt werden. </font><font style="vertical-align: inherit;">√úber ihre Schnittstellen k√∂nnen wir zus√§tzliche Informationen erhalten. </font><font style="vertical-align: inherit;">Insbesondere kann der oberste Knoten im Bild die Liste der Deklaratoren an uns zur√ºckgeben, ohne Dienstprogrammfunktionen wie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Second zu verwenden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Au√üerdem brauchen wir keine Low-Level-Methoden wie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Car</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cdr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Hallo an Fans der Lisp-Sprache). </font><font style="vertical-align: inherit;">Dies ist sehr gut, da wir in der Diagnose die Implementierung des Baums ignorieren k√∂nnen. </font><font style="vertical-align: inherit;">Ich denke, alle sind sich einig, dass aktuelle Abstraktionen sehr schlecht sind.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht die Umgehung aller Deklaratoren aus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDecl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclarator* decl)</span> </span>{ .... }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDeclarators</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclaration* declaration)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> decl : declaration-&gt;GetDeclarators())<font></font>
  {<font></font>
    ProcessDecl(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> PtreeDeclarator*&gt;(decl));<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetDeclarators-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">gibt einen </font><i><font style="vertical-align: inherit;">iterierbaren</font></i><font style="vertical-align: inherit;"> Container zur√ºck. </font><font style="vertical-align: inherit;">Sein Typ ist in diesem Fall </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeContainer &lt;const Ptree, PtreeIteratorTag :: List&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit diesem Code w√§re alles in Ordnung, wenn nicht f√ºr die Besetzung. </font><font style="vertical-align: inherit;">Tatsache ist, dass die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessDecl-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">einen Zeiger auf eine von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ptree</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abgeleitete Klasse haben </font><i><font style="vertical-align: inherit;">m√∂chte</font></i><font style="vertical-align: inherit;"> , aber unsere Iteratoren wissen nichts dar√ºber. </font><font style="vertical-align: inherit;">Ich m√∂chte die Notwendigkeit der manuellen Konvertierung von Typen beseitigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint an der Zeit zu sein, den Iterator erneut zu √§ndern und die F√§higkeit zum Wirken hinzuzuf√ºgen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t, PtreeIteratorTag tag,
  <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt;&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeIterator</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> value_type = Deref_t;
  <span class="hljs-keyword">using</span> dereference_type = value_type;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um nicht alle diese Vorlagenargumente jedes Mal manuell zu schreiben, f√ºgen wir f√ºr alle Gelegenheiten einige Aliase hinzu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So ist es besser. </font><font style="vertical-align: inherit;">Wenn wir jetzt keine Castes ben√∂tigen, k√∂nnen wir nur das erste Template-Argument angeben und unsere K√∂pfe nicht mit dem Wert des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tag-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parameters verstopfen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber was tun mit Containern? </font><font style="vertical-align: inherit;">Ich m√∂chte Sie daran erinnern, dass wir nur eine universelle Klasse haben m√∂chten, die f√ºr jeden Iterator geeignet ist. </font><font style="vertical-align: inherit;">Jetzt gibt es unanst√§ndig viele verschiedene Kombinationen, und wir brauchen Einfachheit. </font><font style="vertical-align: inherit;">Etwas wie das:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/xc/nv/ik/xcnvik7rkulnyybu6jngdpcrv4w.png" alt="Bild 39"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das hei√üt, wir m√∂chten, dass eine einzelne Containerklasse alle Typen unserer Iteratoren unterst√ºtzt und ihnen mitteilt, welcher Typ bei der Dereferenzierung zur√ºckgegeben werden soll. </font><font style="vertical-align: inherit;">Dann erstellen wir im Code einfach den Container, den wir ben√∂tigen, und beginnen damit zu arbeiten, ohne dar√ºber nachzudenken, welche Iteratoren wir ben√∂tigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden diese Frage im n√§chsten Abschnitt untersuchen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mustermagie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also hier ist was wir brauchen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Container, der universell mit jedem Iterator arbeiten kann.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Iterator, der abh√§ngig von der Liste der Knoten sowohl mit jedem Element als auch √ºber eines arbeiten kann.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der gleiche Iterator, aber mit einem Z√§hler.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beide Iteratoren sollten beim Dereferenzieren umwandeln k√∂nnen, wenn der Typ zus√§tzlich angegeben wird.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst m√ºssen wir den Containertyp √ºber Vorlagenparameter irgendwie an den Iteratortyp binden. </font><font style="vertical-align: inherit;">Folgendes ist passiert:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">typename</span> FwdIt,
          <span class="hljs-keyword">typename</span> Node_t,
          <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;<font></font>
class PtreeContainer<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = FwdIt&lt;Node_t, Deref_t&gt;;
  <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> Iterator::dereference_type;
  <span class="hljs-keyword">using</span> size_type  = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> difference_type = <span class="hljs-keyword">typename</span> Iterator::difference_type;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeContainer(Node_t* nodes) :<font></font>
    m_nodes{ nodes }<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (IsLeaf(m_nodes))<font></font>
    {<font></font>
      m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  ....<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> begin() == end();<font></font>
  }<font></font>
  ....<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen dem Container auch weitere Methoden hinzuf√ºgen. </font><font style="vertical-align: inherit;">So k√∂nnen wir beispielsweise die Anzahl der Elemente ermitteln:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">difference_type <span class="hljs-title">count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::distance(begin(), end());<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oder hier ist der Indexierungsoperator:</font></font><br>
<br>
<pre><code class="cpp hljs">value_type <span class="hljs-keyword">operator</span>[](size_type index) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
{<font></font>
  size_type i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin(); it != end(); ++it)<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (i++ == index)<font></font>
    {<font></font>
      <span class="hljs-keyword">return</span> *it;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> value_type{};<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist klar, dass Sie solche Methoden aufgrund ihrer linearen Komplexit√§t sorgf√§ltig behandeln m√ºssen, aber manchmal sind sie n√ºtzlich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºgen Sie zur Vereinfachung der Verwendung Aliase hinzu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementList =<font></font>
PtreeContainer&lt;PtreeStatementIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeItemList =<font></font>
PtreeContainer&lt;PtreeListIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedStatementList =<font></font>
PtreeContainer&lt;PtreeStatementCountingIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedItemList =<font></font>
PtreeContainer&lt;PtreeListCountingIterator, Node_t, Deref_t&gt;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt k√∂nnen wir einfach Container erstellen. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in der bereits erw√§hnten </font><i><font style="vertical-align: inherit;">PtreeDeclaration-</font></i><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">m√∂chten wir einen </font><font style="vertical-align: inherit;">Container </font><font style="vertical-align: inherit;">aus der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetDeclarators-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><i><font style="vertical-align: inherit;">abrufen</font></i><font style="vertical-align: inherit;"> , deren Iterator Trennzeichen √ºberspringt, obwohl kein Z√§hler darin enthalten ist. Wenn dereferenziert wird, wird ein Wert vom Typ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeDeclarator zur√ºckgegeben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Hier ist die Erkl√§rung eines solchen Containers:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> DeclList =<font></font>
      Iterators::PtreeItemList&lt;Ptree, PtreeDeclarator*&gt;;<font></font>
<span class="hljs-keyword">using</span> ConstDeclList =<font></font>
      Iterators::PtreeItemList&lt;<span class="hljs-keyword">const</span> Ptree, <span class="hljs-keyword">const</span> PtreeDeclarator*&gt;;<font></font>
             :<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDecl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclarator* decl)</span> </span>{ .... }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDeclarators</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclaration* declaration)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> decl : declaration-&gt;GetDeclarators())<font></font>
  {<font></font>
    ProcessDecl(decl);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und schlie√ülich haben wir folgende Funktionen hinzugef√ºgt, da Typinferenz f√ºr Aliase nur in C ++ 20 angezeigt wird, um Container im Code bequemer zu erstellen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeStatementList&lt;Node_t&gt; <span class="hljs-title">MakeStatementList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeItemList&lt;Node_t&gt; <span class="hljs-title">MakeItemList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeCountedStatementList&lt;Node_t&gt; <span class="hljs-title">MakeCountedStatementList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeCountedItemList&lt;Node_t&gt; <span class="hljs-title">MakeCountedItemList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erinnern Sie sich an die Funktion, die mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funktioniert hat </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jetzt k√∂nnen wir es so schreiben:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [elem, i] : MakeCountedItemList(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
    UseIndexSomehow(i);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergleichen Sie mit der Originalversion, es scheint mir, es ist besser geworden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(Ptree* argList, Ptree* enumPtree)</span>
</span>{
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">ptrdiff_t</span> argListLen = Length(argList);
  <span class="hljs-keyword">if</span> (argListLen &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">ptrdiff_t</span> i = <span class="hljs-number">0</span>; i &lt; argListLen; ++i)<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<font></font>
    Ptree* elem;<font></font>
<font></font>
    <span class="hljs-keyword">const</span> EGetEnumElement r = GetEnumElementInfo(enumPtree, i, elem, name);<font></font>
    ....<font></font>
    UseIndexSomehow(i);<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das war's Leute</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles f√ºr mich, danke f√ºr Ihre Aufmerksamkeit. </font><font style="vertical-align: inherit;">Ich hoffe, Sie haben etwas Interessantes oder N√ºtzliches herausgefunden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Inhalt des Artikels scheint es, dass ich den Code unseres Analysators schimpfe und sagen m√∂chte, dass dort alles schlecht ist. </font><font style="vertical-align: inherit;">Das ist nicht so. </font><font style="vertical-align: inherit;">Wie jedes Projekt mit einer Geschichte ist unser Analyseger√§t voller geologischer Ablagerungen, die aus vergangenen Epochen stammen. </font><font style="vertical-align: inherit;">Bedenken Sie, dass wir gerade Artefakte aus der alten Zivilisation ausgegraben, unter der Erde entfernt und die Restaurierung durchgef√ºhrt haben, damit sie im Regal gut aussehen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P.S.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier wird es viel Code geben. </font><font style="vertical-align: inherit;">Ich bezweifelte, ob ich hier die Implementierung von Iteratoren einbeziehen sollte oder nicht, und am Ende entschied ich mich, diese einzubeziehen, um nichts hinter den Kulissen zu lassen. </font><font style="vertical-align: inherit;">Wenn Sie nicht daran interessiert sind, den Code zu lesen, werde ich mich hier von Ihnen verabschieden. </font><font style="vertical-align: inherit;">Den Rest w√ºnsche ich Ihnen eine angenehme Zeit mit Vorlagen.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Code</font></font></b>
                        <div class="spoiler_text"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regelm√§√üiger Iterator</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t, PtreeIteratorTag tag,
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt; = <span class="hljs-number">0</span>&gt;<font></font>
class PtreeIterator<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> value_type = Deref_t;
  <span class="hljs-keyword">using</span> dereference_type = value_type;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  PtreeIterator() = <span class="hljs-keyword">delete</span>;<font></font>
  PtreeIterator(<span class="hljs-keyword">const</span> PtreeIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> PtreeIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeIterator(PtreeIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>=(PtreeIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> PtreeIterator &amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> m_node == other.m_node;<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> PtreeIterator &amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<font></font>
  }<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
    </span>{<font></font>
      m_node = Rest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
      m_node = RestRest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
  PtreeIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> tmp = *<span class="hljs-keyword">this</span>;<font></font>
    ++(*<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> tmp;<font></font>
  }<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;dereference_type&gt;(First(m_node));<font></font>
  }<font></font>
  pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> &amp;(**<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">Node_t* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_node;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator mit Z√§hler</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t, PtreeIteratorTag tag,
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt; = <span class="hljs-number">0</span>&gt;<font></font>
class PtreeCountingIterator<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> value_type = Deref_t;
  <span class="hljs-keyword">using</span> dereference_type = <span class="hljs-built_in">std</span>::pair&lt;value_type, size_type&gt;;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
 <span class="hljs-keyword">public</span>:<font></font>
  PtreeCountingIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  PtreeCountingIterator() = <span class="hljs-keyword">delete</span>;<font></font>
  PtreeCountingIterator(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeCountingIterator(PtreeCountingIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>=(PtreeCountingIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> m_node == other.m_node;<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<font></font>
  }<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
    </span>{<font></font>
      m_node = Rest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
      m_node = RestRest(m_node);<font></font>
    }<font></font>
<font></font>
    ++m_counter;<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
  PtreeCountingIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> tmp = *<span class="hljs-keyword">this</span>;<font></font>
    ++(*<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> tmp;<font></font>
  }<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> { <span class="hljs-keyword">static_cast</span>&lt;value_type&gt;(First(m_node)), counter() };<font></font>
  }<font></font>
  value_type <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> (**<span class="hljs-keyword">this</span>).first;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">size_type <span class="hljs-title">counter</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_counter;<font></font>
  }<font></font>
  <span class="hljs-function">Node_t* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_node;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
  size_type m_counter = <span class="hljs-number">0</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generischer Container</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">typename</span> FwdIt,
          <span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;<font></font>
class PtreeContainer<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = FwdIt&lt;Node_t, Deref_t&gt;;
  <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> Iterator::dereference_type;
  <span class="hljs-keyword">using</span> size_type  = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> difference_type = <span class="hljs-keyword">typename</span> Iterator::difference_type;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeContainer(Node_t* nodes) :<font></font>
    m_nodes{ nodes }<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (IsLeaf(m_nodes))<font></font>
    {<font></font>
      m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  PtreeContainer() = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer(<span class="hljs-keyword">const</span> PtreeContainer&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> PtreeContainer&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer(PtreeContainer&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer&amp; <span class="hljs-keyword">operator</span>=(PtreeContainer&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">nullptr_t</span>) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> empty();<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">nullptr_t</span>) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == <span class="hljs-literal">nullptr</span>);<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(Node_t* node) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> get() == node;<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(Node_t* node) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == node);<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(PtreeContainer other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> get() == other.get();<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(PtreeContainer other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<font></font>
  }<font></font>
  value_type <span class="hljs-keyword">operator</span>[](size_type index) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    size_type i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin(); it != end(); ++it)<font></font>
    {<font></font>
      <span class="hljs-keyword">if</span> (i++ == index)<font></font>
      {<font></font>
        <span class="hljs-keyword">return</span> *it;<font></font>
      }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> value_type{};<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> begin() == end();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">value_type <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>)[<span class="hljs-number">0</span>];<font></font>
  }<font></font>
  <span class="hljs-function">value_type <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{<font></font>
    value_type last{};<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cur : *<span class="hljs-keyword">this</span>)<font></font>
    {<font></font>
      last = cur;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> last;<font></font>
  }<font></font>
  <span class="hljs-function">Node_t* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">difference_type <span class="hljs-title">count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::distance(begin(), end());<font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">has_at_least</span><span class="hljs-params">(size_type n)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{<font></font>
    size_type counter = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin(); it != end(); ++it)<font></font>
    {<font></font>
      <span class="hljs-keyword">if</span> (++counter == n)<font></font>
      {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementList =<font></font>
PtreeContainer&lt;PtreeStatementIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeItemList =<font></font>
PtreeContainer&lt;PtreeListIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedStatementList =<font></font>
PtreeContainer&lt;PtreeStatementCountingIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedItemList =<font></font>
PtreeContainer&lt;PtreeListCountingIterator, Node_t, Deref_t&gt;;</code></pre><br>
</div>
                    </div><br>
<p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a></p><div style="text-align:center;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png"></a></div><p></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie diesen Artikel einem englischsprachigen Publikum zug√§nglich machen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Yuri Minaev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie man auf einen Baum klettert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de502500/index.html">Die Entwicklung eines Passscanners: vom Sperrholzhandwerk zum echten Gesch√§ft</a></li>
<li><a href="../de502504/index.html">Umgeben Sie die Benutzerziffer</a></li>
<li><a href="../de502508/index.html">Trolley Robot 2.0. Teil 2. Management in rviz und ohne. Elemente der Sch√∂nheit in rviz</a></li>
<li><a href="../de502510/index.html">Was in der Cloud zu speichern</a></li>
<li><a href="../de502512/index.html">Ergebnisse des Wettbewerbs der Sofaexperten: die Regeln des wissenschaftlichen Stocherns</a></li>
<li><a href="../de502520/index.html">Videoberichte von Mitap-Berichten zur Produktanalyse</a></li>
<li><a href="../de502554/index.html">Mittlere Informationstechnologie als Ausweg aus der Krise</a></li>
<li><a href="../de502556/index.html">Microsoft Build 2020-Konferenz - heute vollst√§ndig online (direkt bei Habr√©)</a></li>
<li><a href="../de502558/index.html">Wie ich bei Unigine Radphysik gesammelt habe</a></li>
<li><a href="../de502560/index.html">Sagen Sie einfach Nein zu End-2-End-Tests</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>