<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏽 📼 😒 Wie man auf einen Baum klettert 🛃 👏🏿 👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Genauer gesagt, wie man davon runterkommt. Aber das Wichtigste zuerst. Dieser Artikel ist etwas außerhalb des üblichen Artikelformats von PVS-Studio. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wie man auf einen Baum klettert</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/502518/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/qf/qz/ys/qfqzys_fndtbks6hb68atbrnyrq.png" alt="Bild 2"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Genauer gesagt, wie man davon runterkommt. </font><font style="vertical-align: inherit;">Aber das Wichtigste zuerst. </font><font style="vertical-align: inherit;">Dieser Artikel ist etwas außerhalb des üblichen Artikelformats von PVS-Studio. </font><font style="vertical-align: inherit;">Wir schreiben oft über die Überprüfung anderer Projekte, öffnen aber fast nie die Tür zu unserer inneren Küche. </font><font style="vertical-align: inherit;">Es ist Zeit, das Problem zu beheben und darüber zu sprechen, wie der Analysator von innen aufgebaut ist. </font><font style="vertical-align: inherit;">Genauer gesagt über den wichtigsten seiner Teile - den Syntaxbaum. </font><font style="vertical-align: inherit;">Der Artikel konzentriert sich auf den Teil von PVS-Studio, der sich auf die Sprachen C und C ++ bezieht.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das wichtigste zuerst</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Syntaxbaum ist der zentrale Teil eines jeden Compilers. Auf die eine oder andere Weise muss der Code in einer für die Programmverarbeitung geeigneten Form dargestellt werden, und es kommt einfach so vor, dass die Baumstruktur dafür am besten geeignet ist. Ich werde hier nicht auf die Theorie eingehen - es genügt zu sagen, dass der Baum die Hierarchie der Ausdrücke und Blöcke im Code sehr gut widerspiegelt und gleichzeitig nur die für die Arbeit erforderlichen Daten enthält.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was hat der Compiler mit dem statischen Analysator zu tun? Tatsache ist, dass diese beiden Tools viel gemeinsam haben. In der Anfangsphase des Parsens des Codes erledigen sie den gleichen Job. Zunächst wird der Code in einen Token-Stream unterteilt, der dem Parser zugeführt wird. Während der syntaktischen und semantischen Analyse werden Token dann in einem Baum organisiert, der weiter entlang der Pipeline gesendet wird. In dieser Phase können Compiler Zwischenoptimierungen durchführen, bevor sie Binärcode generieren. Statische Analysatoren beginnen, Knoten zu umgehen und verschiedene Überprüfungen zu starten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im PVS-Studio-Analysegerät mit einem erstellten Baum passieren verschiedene Dinge:</font></font><br>
<br>
<ul>
<li>    .    , , ,     <i>using </i>  <i>typedef</i>,   . ,  .         ;</li>
<li>     .  ,          ;</li>
<li>   ,      ,    ,      ;</li>
<li>  .        (      ).          . ,         <i>nullptr</i>    ,    ,         .       ;</li>
<li>  .      ,      .        ,    .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich für Details zur Funktionsweise der Analyse interessieren, empfehlen wir Ihnen, den Artikel „ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im PVS-Studio Code Analyzer verwendete Technologien zum Auffinden von Fehlern und potenziellen Sicherheitslücken</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “ zu </font><font style="vertical-align: inherit;">lesen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Einige Punkte aus der Liste werden dort ausführlich untersucht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden genauer untersuchen, was mit dem Baum im Analysator passiert und wie er überhaupt aussieht. </font><font style="vertical-align: inherit;">Nach einer kurzen Einführung ist es an der Zeit, der Sache auf den Grund zu gehen.</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/si/xk/o4/sixko4j1_uucanebxzup6slqpf8.png" alt="Bild 1"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie es funktioniert</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Vergangenheit verwendet PVS-Studio einen Binärbaum zur Darstellung von Code. Diese klassische Datenstruktur ist jedem bekannt - wir haben einen Knoten, der sich im Allgemeinen auf zwei Kinder bezieht. Knoten, die keine Nachkommen haben sollen, werde ich Terminals nennen, alle anderen - Nicht-Terminals. Ein Nichtterminal kann in einigen Fällen keine untergeordneten Knoten haben, aber sein Hauptunterschied zum Terminal besteht darin, dass Nachkommen grundsätzlich dafür zugelassen sind. Endknoten (oder Blätter) können nicht auf etwas anderes als das übergeordnete Knoten verweisen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die in PVS-Studio verwendete Struktur unterscheidet sich geringfügig vom klassischen Binärbaum - dies ist aus praktischen Gründen erforderlich. </font><font style="vertical-align: inherit;">Endknoten entsprechen normalerweise Schlüsselwörtern, Variablennamen, Literalen usw. </font><font style="vertical-align: inherit;">Nichtterminale - verschiedene Arten von Ausdrücken, Codeblöcken, Listen und dergleichen, die Bestandteile des Baums. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus Sicht der Compiler ist hier alles ziemlich normal, ich rate jedem, der sich für die Klassiker des Genres interessiert - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Dragon Book</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gehen weiter. </font><font style="vertical-align: inherit;">Schauen wir uns ein einfaches Codebeispiel an und wie der Analysator es sieht. </font><font style="vertical-align: inherit;">Außerdem werden viele Bilder von unserem internen Dienstprogramm zur Baumvisualisierung angezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eigentlich ein Beispiel:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span>
</span>{
  <span class="hljs-keyword">return</span> a + b;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese einfache Funktion sieht nach der Verarbeitung durch den Parser folgendermaßen aus (nicht terminale Knoten werden gelb hervorgehoben):</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/eo/nj/od/eonjodrufyrv6p3w2riiysnfnpo.png" alt="Bild 6"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Ansicht hat ihre Vor- und Nachteile, und letztere meiner Meinung nach etwas mehr. Aber schauen wir uns den Baum an. Machen Sie sofort einen Vorbehalt, dass es etwas überflüssig ist, zum Beispiel weil es Interpunktion und Klammern enthält. Unter dem Gesichtspunkt der Kompilierung ist dies überflüssiger Müll, aber solche Informationen werden manchmal vom Analysator für einige Diagnoseregeln benötigt. Mit anderen Worten, der Analysator arbeitet nicht mit dem abstrakten Syntaxbaum (AST), sondern mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Analysebaum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (DT). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Baum wächst von links nach rechts und von oben nach unten. Linke untergeordnete Knoten enthalten immer etwas Sinnvolles, z. B. Deklaratoren. Wenn Sie nach rechts schauen, sehen Sie Zwischen-Nicht-Terminals, die mit dem Wort </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NonLeaf gekennzeichnet sind</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie werden nur benötigt, damit der Baum seine Struktur behält. </font><font style="vertical-align: inherit;">Für die Anforderungen der Analyse tragen solche Knoten keine Informationslast. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während wir uns für den linken Teil des Baumes interessieren werden. </font><font style="vertical-align: inherit;">Hier ist es in einer größeren Nahaufnahme:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/vf/gm/ku/vfgmku_i7oq4oakzu_2gnowmfk8.png" alt="Bild 10"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Anzeige bietet. </font><font style="vertical-align: inherit;">Der übergeordnete </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeDeclarator-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Knoten </font><font style="vertical-align: inherit;">ist ein Objekt, über das Sie auf Knoten mit dem Namen der Funktion und ihren Parametern zugreifen können. </font><font style="vertical-align: inherit;">Es speichert auch die codierte Signatur für das Typsystem. </font><font style="vertical-align: inherit;">Es scheint mir, dass dieses Bild ziemlich visuell ist und es ziemlich einfach ist, die Elemente des Baums mit dem Code zu vergleichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sieht einfach aus, oder? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir zur Verdeutlichung ein einfacheres Beispiel. </font><font style="vertical-align: inherit;">Stellen Sie sich vor, wir haben Code, der unsere Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufruft </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs">f(<span class="hljs-number">42</span>, <span class="hljs-number">23</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Funktionsaufruf im Baum sieht folgendermaßen aus:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/mf/jx/r2/mfjxr27uqexjmd3olssajdys7lw.png" alt="Bild 12"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Struktur ist sehr ähnlich, nur hier sehen wir einen Funktionsaufruf anstelle seiner Deklaration. Nehmen wir nun an, wir wollten alle Argumente durchgehen und mit jedem etwas anfangen. Dies ist eine echte Aufgabe, die häufig im Analysatorcode enthalten ist. Es ist klar, dass nicht alles auf Argumente beschränkt ist und verschiedene Knotentypen sortiert werden müssen, aber jetzt werden wir dieses spezielle Beispiel betrachten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben nur einen Zeiger auf den übergeordneten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FUNCALL-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Knoten </font><font style="vertical-align: inherit;">. Von jedem Nicht-Terminal können wir den linken und rechten untergeordneten Knoten erhalten. Der Typ von jedem von ihnen ist bekannt. Wir kennen die Struktur des Baums, so dass wir sofort den Knoten erreichen können, unter dem die Liste der Argumente liegt - dies ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NonLeaf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , von dem aus das Terminal im Bild </font><i><font style="vertical-align: inherit;">42</font></i><font style="vertical-align: inherit;"> wächst</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir kennen die Anzahl der Argumente nicht im Voraus und es gibt Kommas in der Liste, die in diesem Fall für uns absolut nicht von Interesse sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie machen wir das? </font><font style="vertical-align: inherit;">Weiter lesen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fahrradfabrik</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass das Durchlaufen eines Baumes recht einfach ist. Sie müssen nur eine Funktion schreiben, die dies erledigt, und sie überall verwenden. Es ist möglich, ein Lambda als Argument für jedes Element zu übergeben. Es wäre wirklich so, wenn nicht ein paar Nuancen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens muss es etwas anders sein, jedes Mal um einen Baum herumzugehen. Die Logik der Verarbeitung jedes Knotens ist unterschiedlich, ebenso wie die Logik der Arbeit mit der gesamten Liste. Angenommen, in einem Fall möchten wir die Listenargumente durchgehen und jedes von ihnen zur Verarbeitung an eine bestimmte Funktion übergeben. In einem anderen Fall möchten wir ein Argument auswählen und zurückgeben, das einige Anforderungen erfüllt. Oder filtern Sie die Liste und verwerfen Sie alle uninteressanten Elemente daraus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens müssen Sie manchmal den Index des aktuellen Elements kennen. </font><font style="vertical-align: inherit;">Zum Beispiel wollen wir nur die ersten beiden Argumente verarbeiten und aufhören. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Drittens schweifen wir vom Funktionsbeispiel ab. </font><font style="vertical-align: inherit;">Angenommen, wir haben folgenden Code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span>
</span>{
  <span class="hljs-keyword">int</span> c = a + b;<font></font>
  c *= <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">42</span>) <span class="hljs-keyword">return</span> c;
  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich weiß, dieser Code ist dumm, aber konzentrieren wir uns jetzt darauf, wie der Baum aussieht. </font><font style="vertical-align: inherit;">Wir haben bereits eine Funktionsdeklaration gesehen, hier brauchen wir ihren Körper:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/f0/q6/hs/f0q6hsldd42blwuenxmv2t6vl7o.png" alt="Bild 4"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Fall ähnelt einer Liste von Argumenten, aber Sie können einen Unterschied feststellen. </font><font style="vertical-align: inherit;">Schauen Sie sich das Bild aus dem vorherigen Abschnitt noch einmal an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hast du bemerkt? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Richtig, diese Liste enthält keine Kommas. Das bedeutet, dass Sie sie hintereinander verarbeiten können und sich keine Gedanken über das Überspringen von Trennzeichen machen müssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Insgesamt haben wir mindestens zwei Fälle:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getrennte Liste.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die vollständige Liste.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun sehen, wie dies alles im Analysatorcode geschieht. Hier ist ein Beispiel für das Durchlaufen einer Liste von Argumenten. Dies ist eine vereinfachte Version einer der Funktionen im Übersetzer.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessArguments</span><span class="hljs-params">(Ptree* arglist)</span>
</span>{
  <span class="hljs-keyword">if</span> (!arglist) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  Ptree* args = Second(arglist);<font></font>
  <span class="hljs-keyword">while</span> (args)<font></font>
  {<font></font>
    Ptree* p = args-&gt;Car();<font></font>
    <span class="hljs-keyword">if</span> (!Eq(p, <span class="hljs-string">','</span>))<font></font>
    {<font></font>
      ProcessArg(p);<font></font>
    }<font></font>
<font></font>
    args = args-&gt;Cdr();<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ich jedes Mal einen Dollar bekommen würde, wenn ich einen ähnlichen Code sehe, würde ich bereits reich werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, was hier passiert. Ich muss sofort sagen, dass dies sehr alter Code ist, der lange vor C ++ 11 geschrieben wurde, ganz zu schweigen von moderneren Standards. Wir können sagen, dass ich speziell nach einem Fragment der Zeit der alten Zivilisationen gesucht habe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktion akzeptiert also zunächst eine Liste von Argumenten in Klammern als Eingabe. Etwa so: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(42, 23) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zweite</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">wird hier aufgerufen, um den Inhalt der Klammern abzurufen. Sie bewegt sich nur einmal nach rechts und dann einmal nach links durch den Binärbaum. Als nächstes erhält die Schleife nacheinander die Elemente: 42, dann ein Komma, dann 23 und im nächsten Schritt den </font><i><font style="vertical-align: inherit;">Args-</font></i><font style="vertical-align: inherit;"> Zeiger</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird Null, weil wir am Ende des Zweigs angelangt sind. Die Schleife überspringt natürlich uninteressante Kommas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ähnliche Funktionen mit leicht veränderter Logik finden sich an vielen Stellen, insbesondere im alten Code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein anderes Beispiel. Woher weiß ich, ob eine bestimmte Funktion in einem bestimmten Codeblock aufgerufen wird? Ungefähr so:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsFunctionCalled</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* body, <span class="hljs-built_in">std</span>::string_view name)</span>
</span>{
  <span class="hljs-keyword">if</span> (!arglist) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  <span class="hljs-keyword">const</span> Ptree* statements = body;
  <span class="hljs-keyword">while</span> (statements)<font></font>
  {<font></font>
    <span class="hljs-keyword">const</span> Ptree* cur = statements-&gt;Car();
    <span class="hljs-keyword">if</span> (IsA(cur, ntExprStatement) &amp;&amp; IsA(cur-&gt;Car(), ntFuncallExpr))<font></font>
    {<font></font>
      <span class="hljs-keyword">const</span> Ptree* funcName = First(cur-&gt;Car());
      <span class="hljs-keyword">if</span> (Eq(funcName, name))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
<font></font>
    statements = statements-&gt;Cdr();<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis. </font><font style="vertical-align: inherit;">Ein aufmerksamer Leser kann es bemerken. </font><font style="vertical-align: inherit;">Wie alt ist er? </font><font style="vertical-align: inherit;">Dort </font><font style="vertical-align: inherit;">ragt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: string_view</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> heraus. </font><font style="vertical-align: inherit;">Alles ist einfach, selbst der älteste Code wird nach und nach überarbeitet und nach und nach bleibt nichts dergleichen übrig. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wäre schön, hier etwas eleganteres zu verwenden, oder? </font><font style="vertical-align: inherit;">Nun, zum Beispiel der Standardalgorithmus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_if</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Was ist der Algorithmus dort, selbst ein normaler bereichsbasierter Algorithmus würde die Lesbarkeit erheblich verbessern und die Unterstützung eines solchen Codes erleichtern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir dies zu erreichen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legen Sie den Baum in die Box</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Ziel ist es, dass sich der Baum wie ein STL-Container verhält. </font><font style="vertical-align: inherit;">Darüber hinaus sollten wir uns nicht um die interne Struktur der Listen kümmern, sondern einheitlich über die Knoten iterieren, zum Beispiel wie folgt:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoSomethingWithTree</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* tree)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cur : someTreeContainer)<font></font>
  {<font></font>
    ....<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, haben wir hier eine bestimmte Entität namens </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">someTreeContainer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , von der wir noch nichts wissen. </font><font style="vertical-align: inherit;">Ein solcher Behälter sollte zumindest </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beginnen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ende</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methoden </font><font style="vertical-align: inherit;">die Rückkehr Iteratoren. </font><font style="vertical-align: inherit;">Apropos Iteratoren, sie sollten sich auch wie Standard-Iteratoren verhalten. </font><font style="vertical-align: inherit;">Beginnen wir mit ihnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im einfachsten Fall sieht der Iterator folgendermaßen aus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t,
          <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt;&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeIterator</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> value_type = Node_t;
  <span class="hljs-keyword">using</span> dereference_type = value_type;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer   = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
    <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  ....<font></font>
<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    m_node = Rest(m_node);<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;dereference_type&gt;(First(m_node));<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Code nicht zu überladen, habe ich einige Details entfernt. </font><font style="vertical-align: inherit;">Die wichtigsten Punkte hier sind Dereferenzierung und Inkrementierung. </font><font style="vertical-align: inherit;">Die Vorlage wird benötigt, damit der Iterator sowohl mit konstanten als auch mit nicht konstanten Daten arbeiten kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt schreiben wir den Container, in dem wir den Baumknoten platzieren. </font><font style="vertical-align: inherit;">Hier ist die einfachste Option:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeContainer</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = PtreeIterator&lt;Node_t&gt;;
  <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> Iterator::dereference_type;
  <span class="hljs-keyword">using</span> size_type  = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">typename</span> Iterator::difference_type;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeContainer(Node_t* nodes) :<font></font>
    m_nodes{ nodes }<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (IsLeaf(m_nodes))<font></font>
    {<font></font>
      m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  ....<font></font>
<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> begin() == end();<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sind fertig, wir können uns zerstreuen, danke für Ihre Aufmerksamkeit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nein, warte einen Moment. </font><font style="vertical-align: inherit;">So einfach kann es doch nicht sein, oder? </font><font style="vertical-align: inherit;">Kehren wir zu unseren beiden Listenoptionen zurück - mit und ohne Trennzeichen. </font><font style="vertical-align: inherit;">Hier nehmen wir beim Inkrementieren einfach den rechten Knoten des Baums, damit das Problem nicht gelöst wird. </font><font style="vertical-align: inherit;">Wir müssen immer noch Kommas überspringen, wenn wir nur mit Daten arbeiten möchten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kein Problem, wir fügen dem Iterator lediglich einen zusätzlichen Vorlagenparameter hinzu. </font><font style="vertical-align: inherit;">Sagen wir so:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeIteratorTag</span> :</span> <span class="hljs-keyword">uint8_t</span><font></font>
{<font></font>
  Statement,<font></font>
  List<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, PtreeIteratorTag tag,
  <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt; = <span class="hljs-number">0</span>&gt;<font></font>
class PtreeIterator { .... };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie wird uns das helfen? </font><font style="vertical-align: inherit;">Grundstufe. </font><font style="vertical-align: inherit;">Wir werden diesen Parameter schrittweise überprüfen und uns entsprechend verhalten. </font><font style="vertical-align: inherit;">Glücklicherweise können wir dies in C ++ 17 in der Kompilierungsphase mit dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstrukt if constexpr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lösen </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs">PtreeIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
{<font></font>
  <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
  </span>{<font></font>
    m_node = Rest(m_node);<font></font>
  }<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
    m_node = RestRest(m_node);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist besser, jetzt können wir einen Iterator auswählen, der unseren Anforderungen entspricht. </font><font style="vertical-align: inherit;">Was tun mit Containern? </font><font style="vertical-align: inherit;">Sie können zum Beispiel so aussehen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, PtreeIteratorTag tag&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeContainer</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = PtreeIterator&lt;Node_t, tag&gt;;<font></font>
  ....<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sind wir jetzt definitiv fertig? </font><font style="vertical-align: inherit;">In der Tat nicht wirklich.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber das ist nicht alles</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns diesen Code an:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(Ptree* argList, Ptree* enumPtree)</span>
</span>{
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">ptrdiff_t</span> argListLen = Length(argList);
  <span class="hljs-keyword">if</span> (argListLen &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">ptrdiff_t</span> i = <span class="hljs-number">0</span>; i &lt; argListLen; ++i)<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<font></font>
    Ptree* elem;<font></font>
<font></font>
    <span class="hljs-keyword">const</span> EGetEnumElement r = GetEnumElementInfo(enumPtree, i, elem, name);<font></font>
    ....<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich mag diesen Code wirklich nicht sehr, angefangen von der Schleife mit dem Zähler bis hin zur Tatsache, dass die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetEnumElementInfo-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">sehr verdächtig aussieht. </font><font style="vertical-align: inherit;">Jetzt bleibt es eine Black Box für uns, aber wir können davon ausgehen, dass es das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enum-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Element </font><font style="vertical-align: inherit;">nach Index </font><i><font style="vertical-align: inherit;">herausnimmt</font></i><font style="vertical-align: inherit;"> und seinen Namen und Knoten im Baum über die Ausgabeparameter zurückgibt. </font><font style="vertical-align: inherit;">Der Rückgabewert ist auch etwas seltsam. </font><font style="vertical-align: inherit;">Lassen Sie es uns ganz loswerden - ein idealer Job für unseren Listeniterator:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem : PtreeContainer&lt;<span class="hljs-keyword">const</span> Ptree, PtreeIteratorTag::List&gt;(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nicht schlecht. </font><font style="vertical-align: inherit;">Nur dieser Code wird nicht kompiliert. </font><font style="vertical-align: inherit;">Warum? </font><font style="vertical-align: inherit;">Weil der Index, den wir entfernt haben, im Hauptteil der Schleife unterhalb des Aufrufs von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetEnumElementInfo verwendet wurde</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich werde hier nicht genau sagen, wie es verwendet wurde, weil es jetzt nicht wichtig ist. </font><font style="vertical-align: inherit;">Es genügt zu sagen, dass ein Index benötigt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, lassen Sie uns eine Variable hinzufügen und unseren schönen Code durcheinander bringen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem : PtreeContainer&lt;<span class="hljs-keyword">const</span> Ptree, PtreeIteratorTag::List&gt;(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
    UseIndexSomehow(i++);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Immer noch eine funktionierende Option, aber ich persönlich reagiere auf so etwas:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ov/11/ie/ov11ieyylfaa2qjppdyjjo-yljy.png" alt="Bild 7"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir, dieses Problem zu lösen. </font><font style="vertical-align: inherit;">Wir brauchen etwas, das Elemente automatisch zählen kann. </font><font style="vertical-align: inherit;">Fügen Sie einen Iterator mit einem Zähler hinzu. </font><font style="vertical-align: inherit;">Der Kürze halber habe ich die zusätzlichen Details noch einmal übersprungen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, PtreeIteratorTag tag,
  <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt;&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeCountingIterator</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> value_type = Node_t;
  <span class="hljs-keyword">using</span> dereference_type = <span class="hljs-built_in">std</span>::pair&lt;value_type, size_type&gt;;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeCountingIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  ....<font></font>
<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
    </span>{<font></font>
      m_node = Rest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
      m_node = RestRest(m_node);<font></font>
    }<font></font>
<font></font>
    ++m_counter;<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> { <span class="hljs-keyword">static_cast</span>&lt;value_type&gt;(First(m_node)), counter() };<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
  size_type m_counter = <span class="hljs-number">0</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können wir solchen Code schreiben, oder?</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [elem, i] :<font></font>
            PtreeCountedContainer&lt;<span class="hljs-keyword">const</span> Ptree, PtreeIteratorTag::List&gt;(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
    UseIndexSomehow(i);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen können wir das wirklich, aber es gibt ein Problem. </font><font style="vertical-align: inherit;">Wenn Sie sich diesen Code ansehen, werden Sie möglicherweise feststellen, dass wir eine andere Entität eingeführt haben - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeCountedContainer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es scheint, dass die Situation kompliziert wird. </font><font style="vertical-align: inherit;">Ich möchte wirklich nicht mit verschiedenen Arten von Behältern jonglieren, und da sie innen gleich sind, greift die Hand selbst nach Occams Rasiermesser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir müssen einen Iterator als Vorlagenparameter für den Container verwenden, aber dazu später mehr.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zootypen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lenken Sie für eine Minute von Zählern und verschiedenen Iteratoren ab. </font><font style="vertical-align: inherit;">Bei der Verfolgung einer universellen Umgehung von Knoten haben wir das Wichtigste vergessen - den Baum selbst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich diesen Code an:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> a, b, c = <span class="hljs-number">0</span>, d;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was wir im Baum sehen:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/mi/cq/sh/micqshmftdnb7xstjo71sng02s4.png" alt="Bild 13"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun die Liste der Deklaratoren durchlaufen, aber zuerst werde ich Ihnen noch etwas über den Baum erzählen. </font><font style="vertical-align: inherit;">Die ganze Zeit zuvor hatten wir es mit einem Zeiger auf die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ptree-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse zu </font><i><font style="vertical-align: inherit;">tun</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies ist die Basisklasse, von der alle anderen Knotentypen geerbt werden. </font><font style="vertical-align: inherit;">Über ihre Schnittstellen können wir zusätzliche Informationen erhalten. </font><font style="vertical-align: inherit;">Insbesondere kann der oberste Knoten im Bild die Liste der Deklaratoren an uns zurückgeben, ohne Dienstprogrammfunktionen wie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Second zu verwenden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Außerdem brauchen wir keine Low-Level-Methoden wie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Car</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cdr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Hallo an Fans der Lisp-Sprache). </font><font style="vertical-align: inherit;">Dies ist sehr gut, da wir in der Diagnose die Implementierung des Baums ignorieren können. </font><font style="vertical-align: inherit;">Ich denke, alle sind sich einig, dass aktuelle Abstraktionen sehr schlecht sind.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht die Umgehung aller Deklaratoren aus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDecl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclarator* decl)</span> </span>{ .... }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDeclarators</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclaration* declaration)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> decl : declaration-&gt;GetDeclarators())<font></font>
  {<font></font>
    ProcessDecl(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> PtreeDeclarator*&gt;(decl));<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetDeclarators-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">gibt einen </font><i><font style="vertical-align: inherit;">iterierbaren</font></i><font style="vertical-align: inherit;"> Container zurück. </font><font style="vertical-align: inherit;">Sein Typ ist in diesem Fall </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeContainer &lt;const Ptree, PtreeIteratorTag :: List&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit diesem Code wäre alles in Ordnung, wenn nicht für die Besetzung. </font><font style="vertical-align: inherit;">Tatsache ist, dass die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessDecl-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">einen Zeiger auf eine von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ptree</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abgeleitete Klasse haben </font><i><font style="vertical-align: inherit;">möchte</font></i><font style="vertical-align: inherit;"> , aber unsere Iteratoren wissen nichts darüber. </font><font style="vertical-align: inherit;">Ich möchte die Notwendigkeit der manuellen Konvertierung von Typen beseitigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint an der Zeit zu sein, den Iterator erneut zu ändern und die Fähigkeit zum Wirken hinzuzufügen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t, PtreeIteratorTag tag,
  <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt;&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeIterator</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> value_type = Deref_t;
  <span class="hljs-keyword">using</span> dereference_type = value_type;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um nicht alle diese Vorlagenargumente jedes Mal manuell zu schreiben, fügen wir für alle Gelegenheiten einige Aliase hinzu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So ist es besser. </font><font style="vertical-align: inherit;">Wenn wir jetzt keine Castes benötigen, können wir nur das erste Template-Argument angeben und unsere Köpfe nicht mit dem Wert des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tag-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parameters verstopfen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber was tun mit Containern? </font><font style="vertical-align: inherit;">Ich möchte Sie daran erinnern, dass wir nur eine universelle Klasse haben möchten, die für jeden Iterator geeignet ist. </font><font style="vertical-align: inherit;">Jetzt gibt es unanständig viele verschiedene Kombinationen, und wir brauchen Einfachheit. </font><font style="vertical-align: inherit;">Etwas wie das:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/xc/nv/ik/xcnvik7rkulnyybu6jngdpcrv4w.png" alt="Bild 39"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, wir möchten, dass eine einzelne Containerklasse alle Typen unserer Iteratoren unterstützt und ihnen mitteilt, welcher Typ bei der Dereferenzierung zurückgegeben werden soll. </font><font style="vertical-align: inherit;">Dann erstellen wir im Code einfach den Container, den wir benötigen, und beginnen damit zu arbeiten, ohne darüber nachzudenken, welche Iteratoren wir benötigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden diese Frage im nächsten Abschnitt untersuchen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mustermagie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also hier ist was wir brauchen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Container, der universell mit jedem Iterator arbeiten kann.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Iterator, der abhängig von der Liste der Knoten sowohl mit jedem Element als auch über eines arbeiten kann.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der gleiche Iterator, aber mit einem Zähler.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beide Iteratoren sollten beim Dereferenzieren umwandeln können, wenn der Typ zusätzlich angegeben wird.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst müssen wir den Containertyp über Vorlagenparameter irgendwie an den Iteratortyp binden. </font><font style="vertical-align: inherit;">Folgendes ist passiert:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">typename</span> FwdIt,
          <span class="hljs-keyword">typename</span> Node_t,
          <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;<font></font>
class PtreeContainer<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = FwdIt&lt;Node_t, Deref_t&gt;;
  <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> Iterator::dereference_type;
  <span class="hljs-keyword">using</span> size_type  = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> difference_type = <span class="hljs-keyword">typename</span> Iterator::difference_type;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeContainer(Node_t* nodes) :<font></font>
    m_nodes{ nodes }<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (IsLeaf(m_nodes))<font></font>
    {<font></font>
      m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  ....<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> begin() == end();<font></font>
  }<font></font>
  ....<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können dem Container auch weitere Methoden hinzufügen. </font><font style="vertical-align: inherit;">So können wir beispielsweise die Anzahl der Elemente ermitteln:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">difference_type <span class="hljs-title">count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::distance(begin(), end());<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oder hier ist der Indexierungsoperator:</font></font><br>
<br>
<pre><code class="cpp hljs">value_type <span class="hljs-keyword">operator</span>[](size_type index) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
{<font></font>
  size_type i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin(); it != end(); ++it)<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (i++ == index)<font></font>
    {<font></font>
      <span class="hljs-keyword">return</span> *it;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> value_type{};<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist klar, dass Sie solche Methoden aufgrund ihrer linearen Komplexität sorgfältig behandeln müssen, aber manchmal sind sie nützlich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen Sie zur Vereinfachung der Verwendung Aliase hinzu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementList =<font></font>
PtreeContainer&lt;PtreeStatementIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeItemList =<font></font>
PtreeContainer&lt;PtreeListIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedStatementList =<font></font>
PtreeContainer&lt;PtreeStatementCountingIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedItemList =<font></font>
PtreeContainer&lt;PtreeListCountingIterator, Node_t, Deref_t&gt;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können wir einfach Container erstellen. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in der bereits erwähnten </font><i><font style="vertical-align: inherit;">PtreeDeclaration-</font></i><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">möchten wir einen </font><font style="vertical-align: inherit;">Container </font><font style="vertical-align: inherit;">aus der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetDeclarators-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><i><font style="vertical-align: inherit;">abrufen</font></i><font style="vertical-align: inherit;"> , deren Iterator Trennzeichen überspringt, obwohl kein Zähler darin enthalten ist. Wenn dereferenziert wird, wird ein Wert vom Typ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeDeclarator zurückgegeben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Hier ist die Erklärung eines solchen Containers:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> DeclList =<font></font>
      Iterators::PtreeItemList&lt;Ptree, PtreeDeclarator*&gt;;<font></font>
<span class="hljs-keyword">using</span> ConstDeclList =<font></font>
      Iterators::PtreeItemList&lt;<span class="hljs-keyword">const</span> Ptree, <span class="hljs-keyword">const</span> PtreeDeclarator*&gt;;<font></font>
             :<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDecl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclarator* decl)</span> </span>{ .... }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDeclarators</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclaration* declaration)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> decl : declaration-&gt;GetDeclarators())<font></font>
  {<font></font>
    ProcessDecl(decl);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und schließlich haben wir folgende Funktionen hinzugefügt, da Typinferenz für Aliase nur in C ++ 20 angezeigt wird, um Container im Code bequemer zu erstellen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeStatementList&lt;Node_t&gt; <span class="hljs-title">MakeStatementList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeItemList&lt;Node_t&gt; <span class="hljs-title">MakeItemList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeCountedStatementList&lt;Node_t&gt; <span class="hljs-title">MakeCountedStatementList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeCountedItemList&lt;Node_t&gt; <span class="hljs-title">MakeCountedItemList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erinnern Sie sich an die Funktion, die mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funktioniert hat </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jetzt können wir es so schreiben:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [elem, i] : MakeCountedItemList(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
    UseIndexSomehow(i);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergleichen Sie mit der Originalversion, es scheint mir, es ist besser geworden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(Ptree* argList, Ptree* enumPtree)</span>
</span>{
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">ptrdiff_t</span> argListLen = Length(argList);
  <span class="hljs-keyword">if</span> (argListLen &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">ptrdiff_t</span> i = <span class="hljs-number">0</span>; i &lt; argListLen; ++i)<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<font></font>
    Ptree* elem;<font></font>
<font></font>
    <span class="hljs-keyword">const</span> EGetEnumElement r = GetEnumElementInfo(enumPtree, i, elem, name);<font></font>
    ....<font></font>
    UseIndexSomehow(i);<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das war's Leute</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles für mich, danke für Ihre Aufmerksamkeit. </font><font style="vertical-align: inherit;">Ich hoffe, Sie haben etwas Interessantes oder Nützliches herausgefunden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Inhalt des Artikels scheint es, dass ich den Code unseres Analysators schimpfe und sagen möchte, dass dort alles schlecht ist. </font><font style="vertical-align: inherit;">Das ist nicht so. </font><font style="vertical-align: inherit;">Wie jedes Projekt mit einer Geschichte ist unser Analysegerät voller geologischer Ablagerungen, die aus vergangenen Epochen stammen. </font><font style="vertical-align: inherit;">Bedenken Sie, dass wir gerade Artefakte aus der alten Zivilisation ausgegraben, unter der Erde entfernt und die Restaurierung durchgeführt haben, damit sie im Regal gut aussehen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P.S.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier wird es viel Code geben. </font><font style="vertical-align: inherit;">Ich bezweifelte, ob ich hier die Implementierung von Iteratoren einbeziehen sollte oder nicht, und am Ende entschied ich mich, diese einzubeziehen, um nichts hinter den Kulissen zu lassen. </font><font style="vertical-align: inherit;">Wenn Sie nicht daran interessiert sind, den Code zu lesen, werde ich mich hier von Ihnen verabschieden. </font><font style="vertical-align: inherit;">Den Rest wünsche ich Ihnen eine angenehme Zeit mit Vorlagen.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Code</font></font></b>
                        <div class="spoiler_text"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regelmäßiger Iterator</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t, PtreeIteratorTag tag,
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt; = <span class="hljs-number">0</span>&gt;<font></font>
class PtreeIterator<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> value_type = Deref_t;
  <span class="hljs-keyword">using</span> dereference_type = value_type;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  PtreeIterator() = <span class="hljs-keyword">delete</span>;<font></font>
  PtreeIterator(<span class="hljs-keyword">const</span> PtreeIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> PtreeIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeIterator(PtreeIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>=(PtreeIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> PtreeIterator &amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> m_node == other.m_node;<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> PtreeIterator &amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<font></font>
  }<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
    </span>{<font></font>
      m_node = Rest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
      m_node = RestRest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
  PtreeIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> tmp = *<span class="hljs-keyword">this</span>;<font></font>
    ++(*<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> tmp;<font></font>
  }<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;dereference_type&gt;(First(m_node));<font></font>
  }<font></font>
  pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> &amp;(**<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">Node_t* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_node;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator mit Zähler</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t, PtreeIteratorTag tag,
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt; = <span class="hljs-number">0</span>&gt;<font></font>
class PtreeCountingIterator<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> value_type = Deref_t;
  <span class="hljs-keyword">using</span> dereference_type = <span class="hljs-built_in">std</span>::pair&lt;value_type, size_type&gt;;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
 <span class="hljs-keyword">public</span>:<font></font>
  PtreeCountingIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  PtreeCountingIterator() = <span class="hljs-keyword">delete</span>;<font></font>
  PtreeCountingIterator(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeCountingIterator(PtreeCountingIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>=(PtreeCountingIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> m_node == other.m_node;<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<font></font>
  }<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
    </span>{<font></font>
      m_node = Rest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
      m_node = RestRest(m_node);<font></font>
    }<font></font>
<font></font>
    ++m_counter;<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
  PtreeCountingIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> tmp = *<span class="hljs-keyword">this</span>;<font></font>
    ++(*<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> tmp;<font></font>
  }<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> { <span class="hljs-keyword">static_cast</span>&lt;value_type&gt;(First(m_node)), counter() };<font></font>
  }<font></font>
  value_type <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> (**<span class="hljs-keyword">this</span>).first;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">size_type <span class="hljs-title">counter</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_counter;<font></font>
  }<font></font>
  <span class="hljs-function">Node_t* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_node;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
  size_type m_counter = <span class="hljs-number">0</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generischer Container</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">typename</span> FwdIt,
          <span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;<font></font>
class PtreeContainer<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = FwdIt&lt;Node_t, Deref_t&gt;;
  <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> Iterator::dereference_type;
  <span class="hljs-keyword">using</span> size_type  = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> difference_type = <span class="hljs-keyword">typename</span> Iterator::difference_type;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeContainer(Node_t* nodes) :<font></font>
    m_nodes{ nodes }<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (IsLeaf(m_nodes))<font></font>
    {<font></font>
      m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  PtreeContainer() = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer(<span class="hljs-keyword">const</span> PtreeContainer&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> PtreeContainer&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer(PtreeContainer&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer&amp; <span class="hljs-keyword">operator</span>=(PtreeContainer&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">nullptr_t</span>) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> empty();<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">nullptr_t</span>) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == <span class="hljs-literal">nullptr</span>);<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(Node_t* node) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> get() == node;<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(Node_t* node) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == node);<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(PtreeContainer other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> get() == other.get();<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(PtreeContainer other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<font></font>
  }<font></font>
  value_type <span class="hljs-keyword">operator</span>[](size_type index) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    size_type i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin(); it != end(); ++it)<font></font>
    {<font></font>
      <span class="hljs-keyword">if</span> (i++ == index)<font></font>
      {<font></font>
        <span class="hljs-keyword">return</span> *it;<font></font>
      }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> value_type{};<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> begin() == end();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">value_type <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>)[<span class="hljs-number">0</span>];<font></font>
  }<font></font>
  <span class="hljs-function">value_type <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{<font></font>
    value_type last{};<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cur : *<span class="hljs-keyword">this</span>)<font></font>
    {<font></font>
      last = cur;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> last;<font></font>
  }<font></font>
  <span class="hljs-function">Node_t* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">difference_type <span class="hljs-title">count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::distance(begin(), end());<font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">has_at_least</span><span class="hljs-params">(size_type n)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{<font></font>
    size_type counter = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin(); it != end(); ++it)<font></font>
    {<font></font>
      <span class="hljs-keyword">if</span> (++counter == n)<font></font>
      {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementList =<font></font>
PtreeContainer&lt;PtreeStatementIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeItemList =<font></font>
PtreeContainer&lt;PtreeListIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedStatementList =<font></font>
PtreeContainer&lt;PtreeStatementCountingIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedItemList =<font></font>
PtreeContainer&lt;PtreeListCountingIterator, Node_t, Deref_t&gt;;</code></pre><br>
</div>
                    </div><br>
<p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a></p><div style="text-align:center;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png"></a></div><p></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie diesen Artikel einem englischsprachigen Publikum zugänglich machen möchten, verwenden Sie bitte den Link zur Übersetzung: Yuri Minaev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie man auf einen Baum klettert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de502500/index.html">Die Entwicklung eines Passscanners: vom Sperrholzhandwerk zum echten Geschäft</a></li>
<li><a href="../de502504/index.html">Umgeben Sie die Benutzerziffer</a></li>
<li><a href="../de502508/index.html">Trolley Robot 2.0. Teil 2. Management in rviz und ohne. Elemente der Schönheit in rviz</a></li>
<li><a href="../de502510/index.html">Was in der Cloud zu speichern</a></li>
<li><a href="../de502512/index.html">Ergebnisse des Wettbewerbs der Sofaexperten: die Regeln des wissenschaftlichen Stocherns</a></li>
<li><a href="../de502520/index.html">Videoberichte von Mitap-Berichten zur Produktanalyse</a></li>
<li><a href="../de502554/index.html">Mittlere Informationstechnologie als Ausweg aus der Krise</a></li>
<li><a href="../de502556/index.html">Microsoft Build 2020-Konferenz - heute vollständig online (direkt bei Habré)</a></li>
<li><a href="../de502558/index.html">Wie ich bei Unigine Radphysik gesammelt habe</a></li>
<li><a href="../de502560/index.html">Sagen Sie einfach Nein zu End-2-End-Tests</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>