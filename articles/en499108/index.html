<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêº ü¶à üêÄ Rust. Borrow checker through iterators üéñÔ∏è üíø ‚ÑπÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! 
 
 I have been studying for about a year and, in my free time, I write on the rast. I like how its authors solved the problem of memory ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Rust. Borrow checker through iterators</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499108/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I have been studying for about a year and, in my free time, I write on the rast. </font><font style="vertical-align: inherit;">I like how its authors solved the problem of memory management and dispensed with the garbage collector - through the concept of borrowing. </font><font style="vertical-align: inherit;">In this article I will approach this idea through iterators. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lately, scala is my main language, so there will be comparisons with it, but there are not many of them and everything is intuitive, without magic :) The </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
article is designed for those who heard something about rust, but did not go into details. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lu/ju/o1/lujuo1lkziqqcu6fpfxiuuuaquy.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
photos taken </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from here</font></font></a><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foreword</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In jvm languages, it‚Äôs customary to hide work with links, that is, there we almost always work with reference data types, so we decided to hide the ampersand (&amp;). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The rasta has explicit links, for example to integer - `&amp; i32`, the link can be dereferenced via` * `, there can also be a link to the link and then it will need to be dereferenced twice **.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When writing code, very often you need to filter the collection by a condition (predicate). </font><font style="vertical-align: inherit;">In the rock to take even elements would look something like this:</font></font><br>
<br>
<pre><code class="scala hljs">    <span class="hljs-keyword">val</span> vec = <span class="hljs-type">Vector</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
    <span class="hljs-keyword">val</span> result = vec.filter(e =&gt; e % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at the sorts:</font></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-keyword">private</span>[scala] <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filterImpl</span></span>(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>, isFlipped: <span class="hljs-type">Boolean</span>): <span class="hljs-type">Repr</span> = {
    <span class="hljs-keyword">val</span> b = newBuilder
    <span class="hljs-keyword">for</span> (x &lt;- <span class="hljs-keyword">this</span>)
      <span class="hljs-keyword">if</span> (p(x) != isFlipped) b += x<font></font>
<font></font>
    b.result<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Without going into the details of `newBuilder`, it is clear that a new collection is being created, we iterate over the old one and if the predicate returns true, then add an element. </font><font style="vertical-align: inherit;">Despite the fact that the collection is new, its elements are actually links to elements from the first collection, and if, suddenly, these elements are mutable, then changing them will be common to both collections. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's try to do the same in the rast. </font><font style="vertical-align: inherit;">I will immediately give a working example, and then I will consider the differences.</font></font><br>
<br>
<pre><code class="rust hljs">    <span class="hljs-keyword">let</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
    <span class="hljs-keyword">let</span> result: <span class="hljs-built_in">Vec</span>&lt;&amp;<span class="hljs-built_in">i32</span>&gt; = v.iter().filter(|e| **e % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).collect();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wow, wow what? </font><font style="vertical-align: inherit;">Double pointer dereferencing? </font><font style="vertical-align: inherit;">Just to filter the vector? </font><font style="vertical-align: inherit;">Hard :( But there are reasons for this. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let us single out how this code differs from the rock:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> explicitly get the iterator on the vector (`iter ()`) </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the predicate function, for some reason, we dereference the pointer twice </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> call `collect ()` </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> it also resulted in a vector of reference types Vec &lt;&amp; i32&gt;, and not ordinary ints </font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Borrow checker</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why explicitly call `iter ()` on the collection? </font><font style="vertical-align: inherit;">It is clear to any rockman that if you call `.filter (...)` then you need to iterate over the collection. </font><font style="vertical-align: inherit;">Why in a rast explicitly write what can be done implicitly? </font><font style="vertical-align: inherit;">Because there are </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">three</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> different iterators! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6t/vw/-m/6tvw-mzsdc6ce1caxkzl-custrw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To figure out why three? </font><font style="vertical-align: inherit;">need to touch on </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Borrow </font></font></b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(borrow, borrow) </font></font></i> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">checker</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 'a. </font><font style="vertical-align: inherit;">The very thing due to which the rast works without a GC and without explicit memory allocation / deallocation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why is it needed?</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To avoid situations when several pointers point to the same memory area, allowing you to change it. </font><font style="vertical-align: inherit;">That is a race condition.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order not to deallocate the same memory several times.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How is this achieved? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Due to the concept of ownership. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, the concept of ownership is simple - only one can own something (even intuition). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The owner may change, but he is always alone. When we write `let x: i32 = 25`, this means that there was a memory allocation for 32bit int and a certain` x` owns it. The idea of ‚Äã‚Äãownership exists only in the compiler‚Äôs mind, in borrow checker. When the owner, in this case, `x` leaves the scope (goes out of scope), the memory of which he owns will be cleared. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is a code that borrow checker will not miss:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span></span>; <span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span> </span>() -&gt; X {
    <span class="hljs-keyword">let</span> first = X; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second = first; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> third = first; <span class="hljs-comment">//   ,   first   </span>
<span class="hljs-comment">//    value used here after move</span><font></font>
<font></font>
    <span class="hljs-keyword">return</span> third;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
`struct X` is something like` case class X () `- a borderless structure. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This behavior is super counterintuitive, I think, for everyone. </font><font style="vertical-align: inherit;">I don‚Äôt know other languages ‚Äã‚Äãin which it would be impossible to ‚Äúuse‚Äù the same ‚Äúvariable‚Äù twice. </font><font style="vertical-align: inherit;">It is important to feel this moment. </font><font style="vertical-align: inherit;">first is not at all a reference to X, it is its </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">owner</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Changing the owner, we kind of kill the previous one, borrow checker will not allow its use.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why did you need to create your own structure, why not use a regular integer?</font></font></b>
                        <div class="spoiler_text">    ‚Äî       (`struct X`),  , ,   integer.   ,     ,     :<br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span> </span>() -&gt; <span class="hljs-built_in">i32</span> {
    <span class="hljs-keyword">let</span> first = <span class="hljs-number">32</span>;
    <span class="hljs-keyword">let</span> second = first; 
    <span class="hljs-keyword">let</span> third = first; <font></font>
<font></font>
    <span class="hljs-keyword">return</span> third;<font></font>
}<font></font>
</code></pre><br>
  ,   borrow checker,            ,   .     Copy,      .      `i32` second     ,   (   ), -  third   .   X     Copy,      .<br>
<br>
     .   ,              ,      ¬´¬ª            .        Clone,    ,     .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow">copy</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow">clone</a>.<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Back to the iterators. </font><font style="vertical-align: inherit;">The concept of "capture" among them is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntoIter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">He ‚Äúswallows‚Äù the collection, giving possession of its elements. </font><font style="vertical-align: inherit;">In the code, this idea will be reflected like this:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-keyword">let</span> coll_1 = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> coll_2: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = coll_1.into_iter().collect();
<span class="hljs-comment">//coll_1 doesn't exists anymore</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By calling `into_iter ()` at coll_1 we "turned" it into an iterator, absorbed all its elements, as in the previous example, `second` absorbed` first`. </font><font style="vertical-align: inherit;">After that, any calls to coll_1 will be punished by borrow checker during compilation. </font><font style="vertical-align: inherit;">Then we collected these elements with the `collect` function, creating a new vector. </font><font style="vertical-align: inherit;">The `collect` function is needed to collect a collection from an iterator, for this you have to explicitly specify the type of what we want to collect. </font><font style="vertical-align: inherit;">Therefore, coll_2 clearly indicates the type. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Okay, in general, the above described is enough for a programming language, but it will not be very efficient to copy / clone data structures every time we want to transfer them, and you also need to be able to change something. </font><font style="vertical-align: inherit;">So we go to the pointers.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pointers</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The owner, as we have found out, can be only one. </font><font style="vertical-align: inherit;">But you can have any number of links.</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Y</span></span>; <span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span></span>() -&gt; Y {
    <span class="hljs-keyword">let</span> first = Y; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second: &amp;Y = &amp;first; <span class="hljs-comment">//   ,     </span>
    <span class="hljs-keyword">let</span> third = &amp;first; <span class="hljs-comment">//    </span><font></font>
<font></font>
<span class="hljs-comment">// </span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, second);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, third);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> first;<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This code is already valid, because the owner is still one. All ownership logic is checked only at the compilation stage, without affecting memory allocation / moving. Moreover, you can see that the type of second has changed to `&amp; Y`! That is, the semantics of ownership and links are reflected in types, which allows you to check during compilation, for example, the absence of a race condition. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How can I protect against race condition at compile time? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By setting a limit on the number of mutable links! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A mutable link at one moment in time can be one and only one (without immutable). That is, either one / several immutable, or one mutable. The code looks like this:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-comment">// </span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span></span> {<font></font>
    x: <span class="hljs-built_in">i32</span>,<font></font>
} <font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span></span>() -&gt; X {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> first = X { x: <span class="hljs-number">20</span> }; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second: &amp;<span class="hljs-keyword">mut</span> X = &amp;<span class="hljs-keyword">mut</span> first; <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">let</span> third: &amp;<span class="hljs-keyword">mut</span> X = &amp;<span class="hljs-keyword">mut</span> first; <span class="hljs-comment">//    .        `second`        - .</span>
<span class="hljs-comment">//    second.x = 33;  //    ,             ,    </span>
    third.x = <span class="hljs-number">33</span>;<font></font>
<font></font>
    <span class="hljs-keyword">return</span> first;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's go over the changes in the relative previous example. First, we added one field to the structure so that there was something to change, because we need mutability. Secondly, `mut` appeared in the declaration of the variable` let mut first = ... `, this is a marker to the compiler about mutability, like` val` &amp; `var` in the rock. Thirdly, all links have changed their type from `&amp; X` to` &amp; mut X` (it looks, of course, monstrous. And this is without life time ...), now we can change the value stored by the link.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But I said that we cannot create several mutable links, they say borrow checker will not give this, but I created two myself! Yes, but the checks there are very tricky, which is why it is sometimes not obvious why the compiler swears. He is trying hard to make sure that your program compiles and if there are absolutely no options to meet the rules, then a mistake, and maybe not the one you are waiting for, but the one that violates his last attempt, the most desperate and not obvious for a beginner: ) For example, you are informed that the structure does not implement the Copy trait, although you did not call any copies anywhere. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, the existence of two mutable links is allowed at the same time because we use only one, that is, the second can be thrown away and nothing will change. Also `second` can be used </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">up to</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">create a `third` and then everything will be okay. </font><font style="vertical-align: inherit;">But, if you uncomment `second.x = 33;`, it turns out that two mutable links exist simultaneously and you can‚Äôt get out of here anyway - compile time error.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterators</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we have three types of transmission:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Absorption, borrowing, moving</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mutable link</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each type needs its own iterator.</font></font><br>
<br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntoIter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> absorbs objects from the original collection</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> runs on object links</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IterMut</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> runs on mutable object references</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The question arises - when to use which. </font><font style="vertical-align: inherit;">There is no silver bullet - you need practice, reading someone else's code, articles. </font><font style="vertical-align: inherit;">I will give an example demonstrating the idea. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose there is a school, there is a class in it, and students in the class.</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-meta">#[derive(PartialEq, Eq)]</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Sex</span></span> {<font></font>
    Male,<font></font>
    Female<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Scholar</span></span> {<font></font>
    name: <span class="hljs-built_in">String</span>,<font></font>
    age: <span class="hljs-built_in">i32</span>,<font></font>
    sex: Sex<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = ...;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We took the vector of schoolchildren by querying the database, for example. </font><font style="vertical-align: inherit;">Next, I needed to count the number of girls in the class. </font><font style="vertical-align: inherit;">If we ‚Äúswallow‚Äù the vector through `into_iter ()`, then after counting we can no longer use this collection to count the boys:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bad_idea</span></span>() {
    <span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();
    <span class="hljs-keyword">let</span> girls_c = scholars<font></font>
        .into_iter()<font></font>
        .filter(|s| (*s).sex == Sex::Female)<font></font>
        .count();<font></font>
<font></font>
    <span class="hljs-keyword">let</span> boys_c = scholars <font></font>
        .into_iter()<font></font>
        .filter(|s| (*s).sex == Sex::Male)<font></font>
        .count();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There will be an error ‚Äúvalue used here after move‚Äù on the line for counting boys. </font><font style="vertical-align: inherit;">It is also obvious that the mutable iterator is of no use to us. </font><font style="vertical-align: inherit;">That's why it is just `iter ()` and working with a double link:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">good_idea</span></span>() {
    <span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();
    <span class="hljs-keyword">let</span> girls_c = scholars.iter().filter(|s| (**s).sex == Sex::Female).count();
    <span class="hljs-keyword">let</span> boys_c = scholars.iter().filter(|s| (**s).sex == Sex::Male).count();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here, to increase the number of potential recruits in the country, a mutable iterator is already required:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">very_good_idea</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();<font></font>
    scholars.iter_mut().for_each(|s| (*s).sex = Sex::Male);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Developing the idea, we can make soldiers out of the ‚Äúguys‚Äù and demonstrate the ‚Äúabsorbing‚Äù iterator:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-keyword">impl</span> Scholar {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">to_soldier</span></span>(<span class="hljs-keyword">self</span>) -&gt; Soldier {<font></font>
        Soldier { forgotten_name: <span class="hljs-keyword">self</span>.name, number: some_random_number_generator() }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Soldier</span></span> {<font></font>
    forgotten_name: <span class="hljs-built_in">String</span>,<font></font>
    number: <span class="hljs-built_in">i32</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">good_bright_future</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();<font></font>
    scholars.iter_mut().for_each(|s| (*s).sex = Sex::Male);<font></font>
    <span class="hljs-keyword">let</span> soldiers: <span class="hljs-built_in">Vec</span>&lt;Soldier&gt; = scholars.into_iter().map(|s| s.to_soldier()).collect();
    <span class="hljs-comment">//   scholars,    </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On this wonderful note, perhaps that's all. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The last question remains - where did the double dereferencing of the links in `filter` come from. </font><font style="vertical-align: inherit;">The fact is that a predicate is a function that takes a reference to an argument (so as not to capture it):</font></font><br>
<br>
<pre><code class="rust hljs">
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">filter</span></span>&lt;P&gt;(<span class="hljs-keyword">self</span>, predicate: P) -&gt; Filter&lt;<span class="hljs-keyword">Self</span>, P&gt; <span class="hljs-keyword">where</span>
        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>, P: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item) -&gt; <span class="hljs-built_in">bool</span>,
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
the predicate is FnMut (roughly speaking a function), which takes a reference to its (self) item and returns bool. </font><font style="vertical-align: inherit;">Since we already had a link from the iterator `.iter ()`, the second appeared in the filter. </font><font style="vertical-align: inherit;">When absorbed by an iterator (`into_iter`), double dereferencing of the link turned into a regular one.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I do not have much experience in writing articles, so I will be glad to criticize. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If interested, I can continue. </font><font style="vertical-align: inherit;">Options for topics:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> how and when memory deallocation occurs </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> link lifetime </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> asynchronous programming </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> writing a small web service, you can even offer api </font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links</font></font></h3><br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rust book</font></font></a> </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Due to the concept of ownership, the implementation of such basic things as, for example, a linked list is no longer trivial. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here are</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> several ways how to implement them.</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en499092/index.html">Reference model BIAN. What new and useful for the corporate architecture of the bank does it offer?</a></li>
<li><a href="../en499096/index.html">Fuzzy logic in beautiful pictures. Response surfaces for different membership functions</a></li>
<li><a href="../en499102/index.html">Kubernetes, Microservices, CI / CDs and Dockers for Retrogrades: Learning Tips</a></li>
<li><a href="../en499104/index.html">IoT to your wounds: why the Internet of things is most welcome in the era of coronavirus</a></li>
<li><a href="../en499106/index.html">Advanced HTML</a></li>
<li><a href="../en499110/index.html">The Big Brother is trying to serve the good. How data collectors and program companies are involved in the fight against coronavirus</a></li>
<li><a href="../en499112/index.html">Advanced resource authorization system in Laravel. Part 3. Reading / writing attributes, own models</a></li>
<li><a href="../en499114/index.html">Exporting the Federal Communications Agency Numbering Plan to a Relational Database</a></li>
<li><a href="../en499118/index.html">How to create a viral video</a></li>
<li><a href="../en499120/index.html">[Bookmark] CSS: Using Indentation and Indentation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>