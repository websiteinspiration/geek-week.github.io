<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐻 ✋🏻 🕴🏾 Em poucas palavras: Async / Await Best Practices in .NET 🙋🏾 🧙🏼 🙋🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Antecipando o início do curso, "C # Developer" preparou uma tradução de material interessante.
 
 
 
 Async / Await - Introdução
 A construção da ling...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Em poucas palavras: Async / Await Best Practices in .NET</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/488082/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antecipando o início do curso, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"C # Developer"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> preparou uma tradução de material interessante.</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/6f/io/l8/6fiol8vwkg-r8ja-3zurutnz-ci.png"><br>
<hr><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async / Await - Introdução</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A construção da linguagem Async / Await existe desde o C # versão 5.0 (2012) e rapidamente se tornou um dos pilares da moderna programação .NET - qualquer desenvolvedor de C # que se preze deveria usá-lo para melhorar o desempenho do aplicativo, a capacidade de resposta geral e a legibilidade do código. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Async / Await simplifica a introdução de códigos assíncronos e elimina a necessidade de o programador entender os detalhes de seu processamento, mas quantos de nós realmente sabemos como ele funciona e quais são as vantagens e desvantagens desse método? </font><font style="vertical-align: inherit;">Há muitas informações úteis, mas são fragmentadas, então decidi escrever este artigo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, então, vamos nos aprofundar no tópico.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Máquina de estado (IAsyncStateMachine)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira coisa que você precisa saber é que sempre que você tem um método ou função com o Async / Await, o compilador realmente transforma seu método em uma classe gerada que implementa a interface IAsyncStateMachine. Essa classe é responsável por manter o estado do seu método durante o ciclo de vida de uma operação assíncrona - encapsula todas as variáveis ​​do seu método na forma de campos e divide seu código em seções que são executadas durante transições de máquina de estado entre estados, para que o thread possa sair do método e quando retornará, o estado não mudará. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como exemplo, aqui está uma definição de classe muito simples com dois métodos assíncronos: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
using System.Threading.Tasks;</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Diagnostics;<font></font>
<font></font>
<span class="hljs-keyword">namespace</span> <span class="hljs-title">AsyncAwait</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AsyncAwait</span><font></font>
    {<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncAwaitExample</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">int</span> myVariable = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">await</span> DummyAsyncMethod();<font></font>
            Debug.WriteLine(<span class="hljs-string">"Continuation - After First Await"</span>);<font></font>
            myVariable = <span class="hljs-number">1</span>;<font></font>
<font></font>
            <span class="hljs-keyword">await</span> DummyAsyncMethod();<font></font>
            Debug.WriteLine(<span class="hljs-string">"Continuation - After Second Await"</span>);<font></font>
            myVariable = <span class="hljs-number">2</span>;<font></font>
<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">DummyAsyncMethod</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-comment">// </span><font></font>
        }<font></font>
<font></font>
    }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma classe com dois métodos assíncronos</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Se observarmos o código gerado durante a montagem, veremos algo assim: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qo/xe/63/qoxe63foidhmllsdwfi78tdhrsm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que temos 2 novas classes internas geradas para nós, uma para cada método assíncrono. Essas classes contêm uma máquina de estado para cada um dos nossos métodos assíncronos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, tendo estudado o código descompilado para </font></font><code><code>&lt;AsyncAwaitExample&gt;</code></code><code> d__0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, notamos que nossa variável interna </font></font><code>«myVariable»</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agora </font><font style="vertical-align: inherit;">é </font><font style="vertical-align: inherit;">um campo de classe: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/_m/qj/gd_mqjxvsjfw9-_zfd7740n42ua.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
também podemos ver outros campos de classe usados ​​internamente para manter o estado </font></font><code>IAsyncStateMachine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A máquina de estados passa por estados usando o método</font></font><code>MoveNext()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, de fato, um interruptor grande. </font><font style="vertical-align: inherit;">Observe como o método continua em seções diferentes após cada uma das chamadas assíncronas (com o rótulo de continuação anterior). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/km/li/ea/kmlieahswg0ebqn3db5nctfzsti.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso significa que a elegância assíncrona / aguardada tem um preço. </font><font style="vertical-align: inherit;">O uso de async / waitit realmente adiciona alguma complexidade (da qual você talvez não esteja ciente). </font><font style="vertical-align: inherit;">Na lógica do servidor, isso pode não ser crítico, mas, em particular, ao programar aplicativos móveis que levam em consideração cada ciclo de CPU e de memória KB, lembre-se disso, pois a quantidade de sobrecarga pode aumentar rapidamente. </font><font style="vertical-align: inherit;">Posteriormente neste artigo, discutiremos as práticas recomendadas para usar o Async / Await somente quando necessário. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para uma explicação bastante instrutiva da máquina de estado, assista a este </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vídeo no YouTube</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando usar o Async / Await</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Geralmente, existem dois cenários em que o Async / Await é a solução certa.</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabalho relacionado à E / S</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : seu código espera algo, como dados de um banco de dados, leitura de um arquivo, chamada de um serviço da web. </font><font style="vertical-align: inherit;">Nesse caso, você deve usar Async / Await, não a Biblioteca Paralela de Tarefas.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabalho relacionado à CPU</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : seu código executará cálculos complexos. </font><font style="vertical-align: inherit;">Nesse caso, você deve usar Async / Await, mas precisa iniciar o trabalho em outro thread usando o Task.Run. </font><font style="vertical-align: inherit;">Você também pode considerar usar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a Biblioteca Paralela de Tarefas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
</ul><br>
<hr><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assíncrono todo o caminho</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao começar a trabalhar com métodos assíncronos, você notará rapidamente que a natureza assíncrona do código começa a se espalhar pela hierarquia de chamadas - isso significa que você também deve tornar o código de chamada assíncrono e assim por diante. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode ficar tentado a "parar" isso bloqueando o código usando Task.Result ou Task.Wait, convertendo uma pequena parte do aplicativo e envolvendo-o em uma API síncrona para que o restante do aplicativo fique isolado das alterações. Infelizmente, esta é uma receita para criar impasses difíceis de rastrear.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A melhor solução para esse problema é permitir que o código assíncrono cresça naturalmente na base de código. </font><font style="vertical-align: inherit;">Se você seguir esta decisão, verá a extensão do código assíncrono em seu ponto de entrada, geralmente um manipulador de eventos ou uma ação do controlador. </font><font style="vertical-align: inherit;">Renda-se à assincronia sem deixar rastro! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais informações </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neste artigo do</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MSDN.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o método for declarado como assíncrono, certifique-se de que esteja aguardando!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como discutimos, quando o compilador encontra um método assíncrono, ele transforma esse método em uma máquina de estado. </font><font style="vertical-align: inherit;">Se o seu código não esperar no corpo, o compilador gerará um aviso, mas a máquina de estado será criada, adicionando sobrecarga desnecessária para uma operação que nunca será concluída.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evitar vazio assíncrono</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O vácuo assíncrono é algo que realmente deve ser evitado. </font><font style="vertical-align: inherit;">Torne uma regra usar a tarefa assíncrona em vez do vazio assíncrono.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AsyncVoidMethod</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">//!</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncTaskMethod</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">//!</span>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os métodos async void e async Task</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Existem vários motivos para isso, incluindo:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exceções lançadas no método assíncrono nulo não podem ser capturadas fora deste método</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font></li>
</ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando uma exceção é lançada do </font><font style="vertical-align: inherit;">método </font><font style="vertical-align: inherit;">Tarefa assíncrona ou Tarefa assíncrona </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, essa exceção é capturada e colocada no objeto Tarefa. </font><font style="vertical-align: inherit;">Ao usar métodos async void, o objeto Task está ausente; portanto, quaisquer exceções lançadas no método async void serão chamadas diretamente no SynchronizationContext, que estava ativo quando o método async void foi iniciado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere o exemplo abaixo. </font><font style="vertical-align: inherit;">O bloco de captura nunca será alcançado.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AsyncVoidMethodThrowsException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"Hmmm, something went wrong!"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ThisWillNotCatchTheException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">try</span><font></font>
    {<font></font>
        AsyncVoidMethodThrowsException();<font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span>(Exception ex)<font></font>
    {<font></font>
        <span class="hljs-comment">//     </span><font></font>
        Debug.WriteLine(ex.Message);<font></font>
    }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exceções lançadas no método async void não podem ser capturadas fora deste</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
método.Compare com este código, onde, em vez de async void, temos a tarefa assíncrona. </font><font style="vertical-align: inherit;">Nesse caso, a captura será alcançável.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncTaskMethodThrowsException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"Hmmm, something went wrong!"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">ThisWillCatchTheException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">try</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> AsyncTaskMethodThrowsException();<font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span> (Exception ex)<font></font>
    {<font></font>
        <span class="hljs-comment">//    </span><font></font>
        Debug.WriteLine(ex.Message);<font></font>
    }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A exceção é capturada e colocada no objeto Tarefa.</font></font></i><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os métodos assíncronos nulos podem causar efeitos colaterais indesejados se o chamador não esperar que eles sejam assíncronos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : se o método assíncrono não retornar nada, use a tarefa assíncrona (sem um " </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" para a tarefa) como tipo de retorno.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os métodos assíncronos nulos são muito difíceis de testar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : devido a diferenças no tratamento e layout de erros, é difícil escrever testes de unidade que chamam métodos assíncronos nulos. </font><font style="vertical-align: inherit;">Teste Asynchronous MSTest só funciona para métodos assíncronos que retornam um Task ou Task </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma exceção a essa prática são manipuladores de eventos assíncronos. </font><font style="vertical-align: inherit;">Mas mesmo neste caso, é recomendável minimizar o código escrito no próprio manipulador - espere um método de tarefa assíncrona que contenha lógica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais informações </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neste artigo do</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MSDN.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preferir tarefa de retorno em vez de retorno aguardar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como já discutido, toda vez que você declara um método como assíncrono, o compilador cria uma classe de máquina de estado que realmente envolve a lógica do seu método. Isso adiciona certas despesas gerais que podem se acumular, especialmente para dispositivos móveis, onde temos limites de recursos mais rigorosos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Às vezes, um método não precisa ser assíncrono, mas retorna a Tarefa </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e permite que o outro lado o manipule adequadamente. Se a última frase do seu código for um retorno aguardado, considere refatorá-lo para que o tipo de retorno do método seja Tarefa </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(em vez de assíncrono T). </font><font style="vertical-align: inherit;">Por isso, você evita gerar uma máquina de estado, o que torna seu código mais flexível. </font><font style="vertical-align: inherit;">O único caso que realmente queremos esperar é quando fazemos algo com o resultado da tarefa assíncrona na continuação do método.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">AsyncTask</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">//  !</span>
   <span class="hljs-comment">//...  -  </span>
   <span class="hljs-comment">//await -   ,  await  </span><font></font>
<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> GetData();<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">JustTask</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">//!</span>
   <span class="hljs-comment">//...  -  </span>
   <span class="hljs-comment">// Task</span><font></font>
<font></font>
   <span class="hljs-keyword">return</span> GetData();<font></font>
<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preferir retornar tarefa em vez de retornar aguardar</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Observe que se não tivermos aguardado e retornar a tarefa </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o retorno ocorrerá imediatamente; portanto, se o código estiver dentro de um bloco try / catch, a exceção não será capturada. </font><font style="vertical-align: inherit;">Da mesma forma, se o código estiver dentro do bloco using, ele excluirá imediatamente o objeto. </font><font style="vertical-align: inherit;">Veja a próxima dica.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não coloque a tarefa de retorno dentro de try..catch {} ou usando {} blocos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A Tarefa de Retorno pode causar comportamento indefinido quando usada dentro de um bloco try..catch (uma exceção lançada pelo método assíncrono nunca será capturada) ou dentro de um bloco using, porque a tarefa será retornada imediatamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você precisar agrupar seu código assíncrono em uma tentativa .. captura ou usando o bloco, use return wait aguardar.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">ReturnTaskExceptionNotCaught</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-keyword">try</span><font></font>
   {<font></font>
       <span class="hljs-comment">// ...</span><font></font>
<font></font>
       <span class="hljs-keyword">return</span> GetData();<font></font>
<font></font>
   }<font></font>
   <span class="hljs-keyword">catch</span> (Exception ex)<font></font>
<font></font>
   {<font></font>
       <span class="hljs-comment">//     </span><font></font>
<font></font>
       Debug.WriteLine(ex.Message);<font></font>
       <span class="hljs-keyword">throw</span>;<font></font>
   }<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">ReturnTaskUsingProblem</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> resource = GetResource())<font></font>
   {<font></font>
<font></font>
       <span class="hljs-comment">// ...  ,     , ,    </span><font></font>
<font></font>
       <span class="hljs-keyword">return</span> GetData(resource);<font></font>
   }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não envolva a tarefa de retorno dentro de blocos </font></font><code>try..catch{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou</font></font><code>using{}</code></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais informações </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neste</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tópico sobre estouro de pilha.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evite usar </font></font><code>.Wait()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>.Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- use em vez disso</font></font><code>GetAwaiter().GetResult()</code></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">precisar bloquear a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> espera pela conclusão da tarefa assíncrona, use </font></font><code>GetAwaiter().GetResult().</code> <code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lance quaisquer exceções </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o que complica o tratamento de erros. </font><font style="vertical-align: inherit;">A vantagem </font></font><code>GetAwaiter().GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é que ele retorna a exceção usual </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetAwaiterGetResultExample</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">// ,    ,     AggregateException  </span><font></font>
<font></font>
   <span class="hljs-keyword">string</span> data = GetData().Result;<font></font>
<font></font>
   <span class="hljs-comment">// ,   ,      </span><font></font>
<font></font>
   data = GetData().GetAwaiter().GetResult();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você precisar bloquear a espera pela conclusão da tarefa assíncrona, use as </font></font><code>GetAwaiter().GetResult().</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
informações adicionais neste </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o método for assíncrono, adicione o sufixo Async ao seu nome</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa é a convenção usada no .NET para distinguir mais facilmente métodos síncronos e assíncronos (com exceção dos manipuladores de eventos ou métodos do controlador da web, mas eles ainda não devem ser explicitamente chamados pelo seu código).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os métodos de biblioteca assíncrona devem usar Task.ConfigureAwait (false) para melhorar o desempenho</font></font></h3><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O .NET Framework tem o conceito de um "contexto de sincronização", que é uma maneira de "voltar para onde você estava antes". Sempre que uma tarefa está aguardando, ela captura o contexto de sincronização atual antes de aguardar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Após a conclusão da tarefa </font></font><code>.Post()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o </font><font style="vertical-align: inherit;">método de </font><font style="vertical-align: inherit;">contexto de sincronização </font><font style="vertical-align: inherit;">é chamado </font><font style="vertical-align: inherit;">, que retoma o trabalho de onde estava antes. Isso é útil para retornar ao thread da interface do usuário ou para o mesmo contexto do ASP.NET etc.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao escrever o código da biblioteca, você raramente precisa voltar ao contexto em que estava antes. Quando Task.ConfigureAwait (false) é usado, o código não tenta mais continuar de onde estava antes; em vez disso, se possível, o código sai no encadeamento que concluiu a tarefa, o que evita a alternância de contexto. Isso melhora um pouco o desempenho e pode ajudar a evitar conflitos.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">ConfigureAwaitExample</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">//   ConfigureAwait(false)   .</span><font></font>
<font></font>
   <span class="hljs-keyword">var</span> data = <span class="hljs-keyword">await</span> GetData().ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Normalmente, use ConfigureAwait (false) para processos do servidor e código da biblioteca. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é especialmente importante quando o método da biblioteca é chamado um grande número de vezes, para uma melhor capacidade de resposta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Normalmente, use ConfigureAwait (false) para processos do servidor em geral. Não nos importamos com qual thread é usado para continuar, ao contrário dos aplicativos em que precisamos retornar ao thread da interface do usuário. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora ... No ASP.NET Core, a Microsoft acabou com o SynchronizationContext, portanto, teoricamente, você não precisa disso. Mas se você escrever um código de biblioteca que possa ser reutilizado em outros aplicativos (por exemplo, aplicativo de interface do usuário, ASP.NET herdado, Xamarin Forms), isso </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuará sendo uma prática recomendada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para uma boa explicação desse conceito, assista a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este vídeo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relatório de andamento da tarefa assíncrona</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um caso de uso bastante comum para métodos assíncronos é trabalhar em segundo plano, liberar o thread da interface do usuário para outras tarefas e manter a capacidade de resposta. Nesse cenário, convém relatar o progresso de volta à interface com o usuário para que ele possa monitorar o progresso do processo e interagir com a operação. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para resolver esse problema comum, o .NET fornece a interface IProgress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que fornece o método Report </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, invocado por uma tarefa assíncrona para relatar o progresso ao chamador. Essa interface é aceita como um parâmetro do método assíncrono - o chamador deve fornecer um objeto que implemente essa interface.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O .NET fornece o Progress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a implementação padrão do IProgress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que é realmente recomendada, pois lida com toda a lógica de baixo nível associada ao salvamento e restauração do contexto de sincronização. O Progress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">também fornece um evento da Ação </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font><font style="vertical-align: inherit;">e um retorno de chamada </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ambos chamados quando uma tarefa relata o progresso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juntos, o IProgress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e o Progress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornecem uma maneira fácil de transferir informações de progresso de uma tarefa em segundo plano para um thread da interface do usuário. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por favor, note que </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode ser um valor simples, como um int, ou um objeto que forneça informações contextuais sobre o progresso, como a porcentagem de conclusão, uma descrição de cadeia de caracteres da operação atual, ETA e assim por diante. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere com que frequência você relata o progresso. </font><font style="vertical-align: inherit;">Dependendo da operação que você está executando, você pode descobrir que seus relatórios de código progridem várias vezes por segundo, o que pode resultar na interface do usuário se tornar menos responsiva. </font><font style="vertical-align: inherit;">Nesse cenário, recomenda-se que o progresso seja relatado em intervalos maiores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais informações </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neste artigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no blog oficial do Microsoft .NET.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancelar tarefas assíncronas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro caso de uso comum para tarefas em segundo plano é a capacidade de cancelar a execução. </font><font style="vertical-align: inherit;">O .NET fornece a classe CancellationToken. </font><font style="vertical-align: inherit;">O método assíncrono recebe o objeto CancellationToken, que é então compartilhado pelo código da parte que chama e pelo método assíncrono, fornecendo um mecanismo para sinalizar o cancelamento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No caso mais comum, o cancelamento ocorre da seguinte maneira:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O chamador cria um objeto CancellationTokenSource.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O chamador chama a API assíncrona cancelada e passa o CancellationToken do CancellationTokenSource (CancellationTokenSource.Token).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O chamador solicita um cancelamento usando o objeto CancellationTokenSource (CancellationTokenSource.Cancel ()).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A tarefa confirma o cancelamento e cancela a si mesma, geralmente usando o método CancellationToken.ThrowIfCancellationRequested.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que, para que esse mecanismo funcione, você precisará escrever um código para verificar os cancelamentos solicitados em intervalos regulares (ou seja, a cada iteração do seu código ou em um ponto de interrupção natural na lógica). </font><font style="vertical-align: inherit;">Idealmente, após uma solicitação de cancelamento, a tarefa assíncrona deve ser cancelada o mais rápido possível. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você deve considerar desfazer todos os métodos que podem levar muito tempo para serem concluídos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais informações </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neste artigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no blog oficial do Microsoft .NET.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relatório de andamento e cancelamento - exemplo</font></font></h4><br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Threading.Tasks;
<span class="hljs-keyword">using</span> System.Windows.Forms;
<span class="hljs-keyword">using</span> System.Threading;
<span class="hljs-keyword">namespace</span> <span class="hljs-title">TestAsyncAwait</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AsyncProgressCancelExampleForm</span> : <span class="hljs-title">Form</span><font></font>
   {<font></font>
       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AsyncProgressCancelExampleForm</span>(<span class="hljs-params"></span>)</span><font></font>
       {<font></font>
           InitializeComponent();<font></font>
       }<font></font>
<font></font>
       CancellationTokenSource _cts = <span class="hljs-keyword">new</span> CancellationTokenSource();<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnRunAsync_Click</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> sender, EventArgs e</span>)</span><font></font>
<font></font>
       {<font></font>
<font></font>
           <span class="hljs-comment">//   .</span><font></font>
<font></font>
            &lt;<span class="hljs-keyword">int</span>&gt;   ,          ,   ,    , ETA  . .<font></font>
<font></font>
           <span class="hljs-keyword">var</span> progressIndicator = <span class="hljs-keyword">new</span> Progress&lt;<span class="hljs-keyword">int</span>&gt;(ReportProgress);<font></font>
<font></font>
           <span class="hljs-keyword">try</span><font></font>
<font></font>
           {<font></font>
               <span class="hljs-comment">//   ,         </span><font></font>
<font></font>
               <span class="hljs-keyword">await</span> AsyncMethod(progressIndicator, _cts.Token);<font></font>
<font></font>
           }<font></font>
<font></font>
           <span class="hljs-keyword">catch</span> (OperationCanceledException ex)<font></font>
<font></font>
           {<font></font>
               <span class="hljs-comment">// </span><font></font>
<font></font>
               lblProgress.Text = <span class="hljs-string">"Cancelled"</span>;<font></font>
           }<font></font>
       }<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnCancel_Click</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> sender, EventArgs e</span>)</span><font></font>
<font></font>
       {<font></font>
          <span class="hljs-comment">// </span><font></font>
           _cts.Cancel();<font></font>
<font></font>
       }<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReportProgress</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span></span>)</span><font></font>
<font></font>
       {<font></font>
           <span class="hljs-comment">//    </span><font></font>
<font></font>
           lblProgress.Text = <span class="hljs-keyword">value</span>.ToString();<font></font>
<font></font>
       }<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncMethod</span>(<span class="hljs-params">IProgress&lt;<span class="hljs-keyword">int</span>&gt; progress, CancellationToken ct</span>)</span><font></font>
<font></font>
       {<font></font>
<font></font>
           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<font></font>
<font></font>
           {<font></font>
              <span class="hljs-comment">//   ,     </span><font></font>
<font></font>
               <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);<font></font>
<font></font>
               <span class="hljs-comment">//   </span><font></font>
<font></font>
               <span class="hljs-keyword">if</span> (ct != <span class="hljs-literal">null</span>)<font></font>
<font></font>
               {<font></font>
<font></font>
                   ct.ThrowIfCancellationRequested();<font></font>
<font></font>
               }<font></font>
<font></font>
               <span class="hljs-comment">//   </span><font></font>
<font></font>
               <span class="hljs-keyword">if</span> (progress != <span class="hljs-literal">null</span>)<font></font>
<font></font>
               {<font></font>
<font></font>
                   progress.Report(i);<font></font>
               }<font></font>
           }<font></font>
       }<font></font>
   }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aguardando um período de tempo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você precisar esperar um pouco (por exemplo, tente novamente verificar a disponibilidade do recurso), use Task.Delay - nunca use Thread.Sleep nesse cenário.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aguardando a conclusão de várias tarefas assíncronas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Use Task.WaitAny para aguardar a conclusão de qualquer tarefa. </font><font style="vertical-align: inherit;">Use Task.WaitAll para aguardar a conclusão de todas as tarefas. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preciso me apressar para mudar para C # 7 ou 8? </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inscreva-se em um seminário on</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">line gratuito</font></a><font style="vertical-align: inherit;"> para discutir este tópico.</font></font></b></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt488060/index.html">Backblaze - estatísticas do disco rígido de 2019</a></li>
<li><a href="../pt488062/index.html">Meetup sobre Dynamics 365 & Power Platform em Lamoda - Relatório</a></li>
<li><a href="../pt488064/index.html">Sete razões pelas quais o Linux</a></li>
<li><a href="../pt488072/index.html">A injeção de dependência de Koin ou o localizador de serviço?</a></li>
<li><a href="../pt488078/index.html">Meu bot para a Copa AI AI 2019</a></li>
<li><a href="../pt488088/index.html">Como Habr interage com órgãos estaduais e outros candidatos. Relatório de transparência para todos os anos</a></li>
<li><a href="../pt488092/index.html">Hackathons. Como tirar o máximo proveito e sobreviver</a></li>
<li><a href="../pt488096/index.html">400g. Vista do lado da transmissão. ZR / ZR +</a></li>
<li><a href="../pt488098/index.html">Como criar um projeto Django a partir de um modelo</a></li>
<li><a href="../pt488102/index.html">O relacionamento entre C # e C #: REST, gRPC e tudo mais</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>