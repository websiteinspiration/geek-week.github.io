<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕹️ ✋🏿 🌊 FTDIブリッジ上のReddタイヤへのアクセス 🏂🏼 🚀 🏇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Reddコンプレックス用のFPGAサブシステムを構築する方法を示す大規模な理論ブロックを完了しました。 FPGAとコンプレックスの中央プロセッサ間の通信を整理する方法。高速データストリームをFPGAに直接接続されているRAMに保存して、その後中央プロセッサにゆったりと転送する（またはその逆の場合、デ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>FTDIブリッジ上のReddタイヤへのアクセス</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477662/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reddコンプレックス用のFPGAサブシステムを構築する方法を示す大規模な理論ブロックを完了しました。 FPGAとコンプレックスの中央プロセッサ間の通信を整理する方法。高速データストリームをFPGAに直接接続されているRAMに保存して、その後中央プロセッサにゆったりと転送する（またはその逆の場合、データをこのRAMに入れて、後でチャネルにすばやく出力する）のはどれほど簡単か。 Nios IIプロセッサのトレース手法を確認しました。 Nios IIベースのプロセッサシステムのパフォーマンスを最適化して、作業を可能な限り効率的に進めることができます。一般に、必要最小限の理論をすべて調査しましたが、それほど複雑ではないが実用的なデバイスを設計して実践に移すときがきました...しかし、1つだけあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事のコメントから、一部の読者がReddとFPGAはレーニンと党のようであると信じていることに気づきました。</font><font style="vertical-align: inherit;">それらが密接にリンクされていること。</font><font style="vertical-align: inherit;">実際、これはまったくそうではありません。</font><font style="vertical-align: inherit;">Redd Complexについて興味深い話を始めたかったのですが、FPGAよりも興味深いものは何ですか？</font><font style="vertical-align: inherit;">さて、そして会話を始めると、一目で中断することは愚かです。</font><font style="vertical-align: inherit;">そして最後に、大きな論理ブロックが完成しました。</font><font style="vertical-align: inherit;">また、FPGAがRedd全体とはかけ離れていることを示すために、FPGAに関連しないものについて約3つの記事を作成することを提案します。</font><font style="vertical-align: inherit;">さて、そしてこのブロックを完了したので、すでにFPGAの実習に行きます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nu/nw/7p/nunw7p7f7c5hcnmlsv7haliroz8.png"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も驚くべきことは、私が他のトピックについて余談をすることを決めたとたんに、優れた上司が、VHDL言語とザイリンクスFPGAで作業が進行中のプロジェクトで困難な戦いに突き当たったことです。第一に、私が長い間ペンを一般的に取り上げなかった理由であり、第二に、実用的な物品の準備には多くの実験が必要であることは明らかです。 VHDL / Verilogとザイリンクス/アルテラを同時に処理することは多少困難です。したがって、FPGAに関するストーリーの中断はとにかく行う必要があります。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そう。では</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シリーズの最初の記事、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我々はすでにReddの複合体の構造図を調べました。もう一度やってみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vf/hv/da/vfhvda1kmsax-zkxaue4xu_ysmk.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日の記事では、Linuxの専門家が多くの貴重な情報を見つけることはほとんどありませんが、写真を表面的に見てみる価値はあります。</font><font style="vertical-align: inherit;">私と同じように、Windows OSでの作業に慣れている人は、コンプレックスでの作業を可能にする既製のテクニックのリストを見つけるでしょう。</font><font style="vertical-align: inherit;">一般的に、この記事は、それらの読者や他のグループの読者のスキルを共通点にもたらします。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前のサイクル記事</font></font></b><div class="spoiler_text"><ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReddにインストールされたFPGAの最も単純な「ファームウェア」の開発、および例としてメモリテストを使用したデバッグ。</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  «»  ,   Redd.  2.  .</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">          .</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">     Redd     .</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">              Redd.</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> ,       .</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">    Redd.  1:  .</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">    Redd.  2:      .</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  :        .</a></li>
</ol><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UARTブロック（シリアルポート）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロック図では、4つのシリアルポート（UART）を実装するFT4232コントローラーを示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/75/bh/hy/75bhhyfnu_19uedfnkc7bzyrido.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、もう少しグローバルに話すと、Reddコンプレックスには4つではなく6つのシリアルポートがあります。前述の4つにはCMOSレベルがあり、さらに2つはマザーボードにはんだ付けされています。これは、複合体が通常のPCに基づいているためです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/14/vj/pl/14vjplsdplqalj4lcm-4g4nmnvg.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、RS232（プラスまたはマイナス12ボルト）のレベルがあります。 RS232ポート-すべてが明確で、2つの標準DB-9コネクタの形で表示されますが、</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xk/d0/h6/xkd0h6xvaxlz7gxl8v-r4t9n8de.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CMOSレベルのラインはどこにありますか？一般的に-共通コネクタ上。そのピン配列は電気回路図に示されています。とりわけ、UARTに対応する連絡先があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nm/pv/cr/nmpvcraxowuy0oea7wkin1aqulu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外部的には、このコネクタは次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mf/qa/8h/mfqa8hkbar6y7u8shn39eiend2a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使い方はタスクによって異なります。</font><font style="vertical-align: inherit;">各デバイスを接続するためのハーネスを作成できます。</font><font style="vertical-align: inherit;">このアプローチは、誰かがReddコンプレックスを使用して、同じ種類の定期的に製造されたデバイスをテストする場合に役立ちます。</font><font style="vertical-align: inherit;">しかし、コンプレックスの主な目的は、開発中の機器のデバッグです。</font><font style="vertical-align: inherit;">この場合、一時的に接続する方が簡単です。</font><font style="vertical-align: inherit;">この一時的なパターンは、すべての記事のスクリーンセーバーに表示されます。Aruinoワイヤーがコネクターに直接挿入されます。</font><font style="vertical-align: inherit;">もちろん、連絡先をカウントすることは依然として喜ばしいことであり、連絡先が誤って飛んでしまった場合、切り替えを元に戻すことは非常に難しく、最初からすべてを再接続する方が簡単です。</font><font style="vertical-align: inherit;">したがって、寿命を延ばすために、少なくとも2列のコネクタを使用して、少なくとも同じArduino配線で接続できるライザボードがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rb/we/66/rbwe66z9f5eahs3efqpxq93di6e.png"> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UARTソフトウェアアクセス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シリアルポートは、十分に確立され、標準化された要素であるため、特定のFTDIライブラリではなく、標準的な方法で動作します。</font><font style="vertical-align: inherit;">Linuxでこれらのツールがどのように見えるかを見てみましょう。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポート名</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワーク上の多くの記事やフォーラムから、USB-シリアルアダプターによって提供されるポート名は、/ dev / ttyUSB0、/ dev / ttyUSB1などの形式になります。</font><font style="vertical-align: inherit;">Linuxでは、通常のディレクトリを表示する場合と同じコマンドを使用して、すべてのデバイスを表示できます（実際、デバイスは同じファイルです）。</font><font style="vertical-align: inherit;">私たちのシステムにどんな名前があるか見てみましょう。</font><font style="vertical-align: inherit;">次のコマンドを実行します：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ls / dev /</font></font></b><br>
 <br>
<img src="https://habrastorage.org/webt/dj/ho/4g/djho4ghfwyceuqy6fjzezh3gyo8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関心のある名前は赤で強調表示されます。それらの多く。どのポートが何に対応していますか？ Linuxに精通している人は、あらゆる場面で何千もの呪文を知っています。しかし、まだWindows 3.1で作業している人（まあ、当時はかなり元気のいい老婦人RT-11と並行して）にとっては、覚えるのはまだ難しく、年齢が上がると新しいものを覚えるのが難しくなります。したがって、簡単な方法を使用して、毎回すべてを見つけるのが簡単です。そして、このシンプルなパスへの入り口を緑の枠で強調しました。条件付きサブディレクトリシリアル。ここで、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev /</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前空間を調べています</font><font style="vertical-align: inherit;">。そして、letのは、スペースを参照</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の/ dev /シリアル</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kw/fc/31/kwfc3189zwxl3ut80xwehvplt70.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グレートを！階層を掘り下げ、スペース</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / serial / by-idを確認し</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。先を見ただけで、正しく表示するにはコマンドを使用する必要があると言います</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-l</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スイッチ付きの</font><b><font style="vertical-align: inherit;">ls</font></b><font style="vertical-align: inherit;">（説明のために上司に感謝します）。つまり、次のコマンドを実行します</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ls –l / dev / serial / by-id</font></font></b><br>
<br>
<img src="https://habrastorage.org/webt/qq/vl/vd/qqvlvdgcgak3c5cembrbmj4myue.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
一方では、すべてが問題ありません。これで、スペース</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / ttyUSBXのどの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前が</font><font style="vertical-align: inherit;">どのデバイスに対応するかが</font><b><font style="vertical-align: inherit;">わかり</font></b><font style="vertical-align: inherit;">ました。具体的には、FT4232（クワッド）ブリッジ主催ポートは、名前から持っ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ttyUSB3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ttyUSB6します</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。しかし、一方で、このサイトを検討したところ、パリのウェイトとメジャーの部屋には、混乱の基準が置かれている部屋が必ずあるはずだと気づきました。なんとかして、その値を測定できる必要があるからです。まあ、ポートの欠如</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / ttyUSB0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / ttyUSB1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明しやすいです。しかし、インストールされたFTDIブリッジの子孫に基づく「ネイティブ」ポートは上位3から番号が付けられ、特定のプロジェクト用に挿入されたサードパーティのProlificコントローラーはポート番号2をとったことをどのように説明しますか？このような環境でどのように作業できますか？明日、誰かが別のコントローラーをコンプレックスに接続し（コンプレックスにより、異なるグループの開発者が同時に異なる機器を操作できるようになるため）、ポートが再び移動します。稼働中のアプリケーションの構成ファイルで、どのポートを割り当てる必要がありますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてがそれほど悪くはないことがわかりました。最初に、黄色の名前</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / ttyUSB3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と青色の名前</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / serial / by-id / usb-FTDI_Quad_RS232-HS-if00-port0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じデバイスの2つのエイリアスです。また、2番目のオプションはポート名として提示することもできますが、最初のオプションよりも永続的です。確かに、この場合、すべてがやや悪い。 FT4232に基づく外部コントローラーをコンプレックスに接続することができ、それらの番号付けに対処する必要があります。そして、ここで「第二に」私たちの助けになります。つまり、別の代替命名規則です。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / serial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディレクトリには、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ by-id</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブディレクトリだけでなく、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ by-path</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブディレクトリも</font><font style="vertical-align: inherit;">含まれ</font><font style="vertical-align: inherit;">ていたことを覚えてい</font><font style="vertical-align: inherit;">ます。その内容を確認します（次の図の下部の赤い線の下にあります）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y1/mm/xa/y1mmxabnvjburuzedzirgzusjbm.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここにあるものはすべて物理アーキテクチャに関連付けられています。</font><font style="vertical-align: inherit;">また、コンプレックス内のすべてのコントローラーはボードにはんだ付けされているので、内部階層は変更されないと何度も言ってきました。</font><font style="vertical-align: inherit;">したがって、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / serial / by-path / pci-0000：00：15.0-usb-0：6.5：1.0-port0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という名前</font><font style="vertical-align: inherit;">が最も困難になります。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
合計すると、ポート名を検索するための次の方法があります（一度実行する必要があります。複合システムのインスタンスの結果をテーブルに出力し、常に使用できます）。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンド</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ls –l / dev / serial / by-idを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発行し</font><font style="vertical-align: inherit;">ます。</font></font></li>
<li><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ls –l / dev / serial / by-pathコマンドを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発行し</font><font style="vertical-align: inherit;">ます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポイント1の結果から、必要なブリッジの必要なポートに対応するポート名を見つけます。</font><font style="vertical-align: inherit;">段落2の結果で同じポート名を見つけます。この段落に対応する物理名を使用します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マザーボード上のコントローラーが提供するポートについては、すべてが少し複雑です。</font><font style="vertical-align: inherit;">ここでは、最も単純なコマンド「</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ls / dev</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」</font><font style="vertical-align: inherit;">からの道を開くことはできませんが、</font><font style="vertical-align: inherit;">何かを覚えておく必要があります（まあ、少なくともヘルプのためにここに連絡できることを覚えておいてください）。</font><font style="vertical-align: inherit;">どこでも、典型的なポート名は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ttyS0-ttyS3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であると書かれてい</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">システムの実際のポートはどのような名前ですか？</font><font style="vertical-align: inherit;">私はこの質問に答える次のスペルを見つけました：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ls / sys / class / tty / * / device / driver</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これに対するシステム応答は次のとおりです：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oc/gi/v7/ocgiv7g8ffmcmzr_bfypwrn__6g.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
名前</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / ttyS2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font><b><font style="vertical-align: inherit;">/ dev / ttyS3</font></b><font style="vertical-align: inherit;">を使用する必要があることが</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">わかりました</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">なぜ私は知りません。</font><font style="vertical-align: inherit;">ただし、喜ばしいことは1つあります。ここでは特別な変更は想定されていないため、これらの定数は変更されることを恐れずに記憶して使用できます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード開発</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発時には</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、POSIXオペレーティングシステム向けの優れたシリアルプログラミングガイドを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用する必要があります</font><font style="vertical-align: inherit;">（最初に</font><font style="vertical-align: inherit;">得られる</font><font style="vertical-align: inherit;">直接リンク</font><font style="vertical-align: inherit;">は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.cmrr.umn.edu/~strupp/serial.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です</font><font style="vertical-align: inherit;">が、どれくらいの期間存続するかは誰にもわかりません）。</font><font style="vertical-align: inherit;">コンプレックス内のポートは完全に実装されているため、信号の完全なセットを処理する方法を指示することが特に重要です。</font><font style="vertical-align: inherit;">確かに、今日はTxラインとRxラインのみを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、私はオシログラムの結果を提供しますが、今ではほぼ現実の状態になっていることがわかります。複合体は手が届かない場所にあるため、オシロスコーププローブを接続できません。少なくともいくつかの結果を確認するために、私のリクエストで、同僚は次の古典的なスキームに従って複合体にいくつかの投稿を追加しました：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4k/it/be/4kitbevmwnyxbllumfdz0qzr2a0.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あるポートから別のポートに転送してみましょう。この例では、ポート</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.2-port0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/dev/serial/by-path/pci-0000:00:15.0-が接続されていますusb-0：6.5：1.3-port0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中央処理装置Redd用のプログラムはどのように記述されていますか？</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">これまでの記事の</font></a><font style="vertical-align: inherit;"> 1つで既に検討しました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したがって、今日では</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、POSIXオペレーティングシステムのシリアルプログラミングガイドの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">印象の下で記述されたプログラムのテキストに限定します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">実際、主な興味深い点は、受信戦略をノンブロッキング読み取りに切り替えることです。それ以外は簡単です。</font><font style="vertical-align: inherit;">それでも、このトピックに関するネットワークの例の混乱を考慮して、手元にある簡単なサンプルを用意しておくことをお勧めします（この素晴らしいドキュメントに基づく例でも100％機能しなかったことが後で示されます。以下のコード1行で説明されているカノンとは異なりますが、その詳細については以下をご覧ください）。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じサンプルコード</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">#include &lt;cstdio&gt;<font></font>
#include &lt;unistd.h&gt;  /* UNIX standard function definitions */<font></font>
#include &lt;fcntl.h&gt;   /* File control definitions */<font></font>
#include &lt;errno.h&gt;   /* Error number definitions */<font></font>
#include &lt;termios.h&gt; /* POSIX terminal control definitions */<font></font>
<font></font>
<font></font>
int OpenUART(const char* portName, speed_t baudRate)<font></font>
{<font></font>
	//  <font></font>
	int fd = open(portName, O_RDWR | O_NOCTTY | O_NDELAY);<font></font>
	//    <font></font>
	if (fd == -1)<font></font>
	{<font></font>
		return fd;<font></font>
	}<font></font>
<font></font>
	//    <font></font>
	fcntl(fd, F_SETFL, FNDELAY);<font></font>
<font></font>
	//   <font></font>
	termios options;<font></font>
	tcgetattr(fd, &amp;options);<font></font>
	// ,      <font></font>
	// ,   .  ...<font></font>
	cfsetspeed(&amp;options, baudRate);<font></font>
<font></font>
	//    ...<font></font>
	// 1  ,   , 8   <font></font>
	options.c_cflag &amp;= ~PARENB;<font></font>
	options.c_cflag &amp;= ~CSTOPB;<font></font>
	options.c_cflag &amp;= ~CSIZE;<font></font>
	options.c_cflag |= CS8;<font></font>
<font></font>
	options.c_cflag |= (CLOCAL | CREAD);<font></font>
<font></font>
	// , ...<font></font>
	tcsetattr(fd, TCSANOW, &amp;options);<font></font>
<font></font>
	return fd;<font></font>
<font></font>
}<font></font>
int main()<font></font>
{<font></font>
	printf("hello from ReddUARTTest!\n");<font></font>
	int fd1 = OpenUART("/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.3-port0", 9600);<font></font>
	int fd2 = OpenUART("/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.2-port0", 9600);<font></font>
	if ((fd1 != -1) &amp;&amp; (fd2 != -1))<font></font>
	{<font></font>
		static const unsigned char dataForSend[] = {0xff,0xfe,0xfd,0xfb};<font></font>
		//     <font></font>
		write(fd1, dataForSend, sizeof(dataForSend));<font></font>
<font></font>
		unsigned char dataForReceive[128];<font></font>
		ssize_t cnt = 0;<font></font>
		//     ,  ,<font></font>
		//        <font></font>
		int readSteps = 0;<font></font>
		//      ,  <font></font>
		while (cnt &lt; (ssize_t)sizeof(dataForSend))<font></font>
		{<font></font>
			readSteps += 1;<font></font>
			ssize_t rd = read(fd2, dataForReceive + cnt, sizeof(dataForReceive) - cnt);<font></font>
			//   - ,    <font></font>
			if (rd &lt;= 0)<font></font>
			{<font></font>
				usleep(1000);<font></font>
			}<font></font>
			else<font></font>
			//  -  <font></font>
			{<font></font>
				cnt += rd;<font></font>
			}<font></font>
		}<font></font>
		//  <font></font>
		printf("%d read operations\n", readSteps);<font></font>
		printf("Read Data: ");<font></font>
		for (unsigned int i = 0; i &lt; cnt; i++)<font></font>
		{<font></font>
			printf("%X ", dataForReceive[i]);<font></font>
		}<font></font>
		printf("\n");<font></font>
	}<font></font>
	else<font></font>
	{<font></font>
		printf("Error with any port open!\n");<font></font>
	}<font></font>
	//  <font></font>
	if (fd1 != -1)<font></font>
	{<font></font>
		close(fd1);<font></font>
	}<font></font>
	if (fd2 != -1)<font></font>
	{<font></font>
		close(fd2);<font></font>
	}<font></font>
	return 0;<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行-予測結果を取得します。</font></font><br>
<br>
<pre><code class="plaintext hljs">hello from ReddUARTTest!<font></font>
14 read operations<font></font>
Read Data: FF FE FD FB<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4バイトで14回の試行が行われたことがわかります。つまり、読み取りがブロックされていませんでした。時々、システムは「新しいデータなし」状態を返し、プログラムは1ミリ秒間スリープしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、すべてが問題ありませんが、オシロスコープがなければ、同じチップに基づく2つのポートが実際に速度を設定していることを確信できません。私はすでに速度が同じであるという事実（彼には1つのコントローラーがあった）に飛びつきましたが、私が注文したものではありませんでした。少なくとも何らかの形で、それが少なくとも制御されていることを確認しましょう。これを行うには、受信ポートの速度を送信ポートの速度の2倍に設定します。また、データ転送プロセスの物理を理解しているため、受信中にこれらのデータがどのように歪むかを予測できます。グラフィック形式で0xffバイトの転送を見てみましょう。 S-スタートビット（常にゼロがあります）ビット、P-ストップビット（常に1つあります）、0-7-データビット（定数0xFFの場合-すべてのユニット）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kx/0p/cz/kx0pczh7nor5fcn1nhkor8nrwum.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、この図の上に、2倍の速度で動作するレシーバーによってすべてがどのように表示されるかを示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mp/n7/qn/mpn7qngefktxruxtyrex7ykrpwk.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完璧に。</font><font style="vertical-align: inherit;">値「1111 1110」は受け入れられるべきです（データは最下位ビットを転送します）、つまり0xFE。</font><font style="vertical-align: inherit;">単位はラインの無音に対応するため、送信された値の後半は受信に影響しません。</font><font style="vertical-align: inherit;">つまり、1バイト送信しましたが、1バイトも送信されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検証用に同じグラフを作成します。これは、送信された値0xFEに対応し</font></font><br>
<br>
<img src="https://habrastorage.org/webt/do/e6/x2/doe6x2t9aapieqiat4gtkp9j8_y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。値 "1111 1000"または0xF8を期待してください。</font><font style="vertical-align: inherit;">さて、材料を修正するために渡された値0xFDで何を期待するかをチェックしましょう：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c9/er/d0/c9erd0bsjla_b5bkwpmmzbqnrlm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値0xE6を取得します。</font><font style="vertical-align: inherit;">まあ、送信された値0xFBについては、受信した0x9Eを取得します（グラフをプロットして自分で確認できます）。</font><font style="vertical-align: inherit;">すごい！</font><font style="vertical-align: inherit;">テストアプリケーションの1行を変更し、9600の速度を19200に置き換えます。</font></font><br>
<br>
<pre><code class="plaintext hljs">	int fd2 = OpenUART("/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.2-port0", 19200);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この作業の結果を開始して取得します。</font></font><br>
<br>
<pre><code class="plaintext hljs">hello from ReddUARTTest!<font></font>
9 read operations<font></font>
Read Data: FE F8 E6 9E<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、このチェックは無駄ではありませんでした。</font><font style="vertical-align: inherit;">最初は他の速度設定関数（cfsetispeed / cfsetospeedのカップル）を使用しましたが、機能しませんでした。</font><font style="vertical-align: inherit;">このテストのおかげで、問題はタイムリーに特定され、解決されました。</font><font style="vertical-align: inherit;">機器を操作するとき、直感を信頼することはできません。</font><font style="vertical-align: inherit;">すべてをチェックする必要があります！</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電力線管理220ボルト</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、220ボルトの電力線は、記事のトピック（FTDIブリッジ）とは関係ありませんが、このセクション（シリアルポート）のトピックと関係があります。それらを簡単に見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fj/py/1f/fjpy1fqzjfykydgxo28fctebh1c.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポートをリストしたときに、次の名前が表示されました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rt/0g/k7/rt0gk7ammjno5n1hgfh5waz85ri.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは仮想シリアルポートです。これは非常に仮想的なため、設定されているパラメーター（ポート速度、ビット数、パリティ形式など）は関係ありません。彼が設定したパラメーターに関係なく、彼はコマンドを完全に処理することができます。そして、複合体の電源コンセントを制御するのはこれらのチームです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yc/ry/sk/ycryskkv2xpfkxnex41xbn5pooo.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コマンドシステムを開発するとき、複雑なコマンドインターフェイスを破棄することが決定されました。バイトはテキスト形式ですが（デバッグ時に端末から便利に転送できるようにするため）、文字列やその他のフリルをフレーミングすることなく、管理に1バイトを使用します。この簡潔さは簡単に説明できます。文字列インターフェイスを使用すると、安全でないUARTチャネルの干渉に対処できます。しかし、私たちの場合、物理的に作業はUSBチャネルを経由します。このチャネルは、循環制御コードによって保護されています。リターンストリームを処理するには、追加のコードを書くか、常にバッファをフラッシュする必要がありますが、これは必ずしも便利ではありません。そのため、文字列のベンチマークはなく、答えもありません。チャネルは安定していると考えられています。応答が必要な場合は、明示的に要求できます。つまり、コマンドの後に追加のバイトを送信することで、ブロックのパフォーマンスをいつでも簡単に確認できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
送信できるコマンドを検討してください。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チーム</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任命</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「A」</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のコンセントをオンにする</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「a」</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のコンセントをオフにする</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「B」</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目のコンセントをオンにする</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「b」</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目のコンセントをオフにする</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「C」</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3つ目のコンセントがある場合はオンにします</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「c」</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3番目のコンセントをオフにします（存在する場合）</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「？」</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンセントの状態を復元</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チーム「？」 （疑問符）が応答を返す唯一のものです。これに応答して、常に3バイトが来ます。各バイトは、いずれかのアウトレットの状態に対応しています。実際には、状態はコマンドに対応しています。たとえば、「abc」-3つすべてのコンセントがオフになり、「Abc」-最初のコンセントはオンになり、2番目と3番目のコンセントはオフになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このサブシステムでの実験では、特別なプログラムを作成しないことをお勧めします。ポートに送信されるものは異なります）、OSツールを使用して、ソケットをインタラクティブに操作します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
catコマンドを使用してポートを追跡し、echoプログラムを使用して並列ウィンドウでコマンドを送信する多くの実験の結果、何らかの理由で、パテベースのssh端末のペアで結果が得られないことに気付きました（彼は彼のプログラムで非常にうまく実験したことを）。そのため、標準のminicomプログラムをインストールする必要がありました。インストールコマンドを思い出させてください：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sudo apt-get minicom</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
次に、次のコマンドで実行します：</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minicom –D / dev / ttyACM0</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ポート名は短いので、手動で入力するのが最も簡単です。ソフトウェア作業では、いつものように、ハードウェア階層に関連付けられた名前を使用することをお勧めします。繰り返しますが、仮想であるため、他のポートパラメータは設定していません。どの設定でも機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ターミナルで疑問符を押すと、即座に（改行なしで）応答が返されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/41/my/-j/41my-jjk9cffmmflot_zk_ph0ck.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、すべてのソケットが現在オフになっていることを意味します。</font><font style="vertical-align: inherit;">2番目のコンセントをオンにしたいとします。</font><font style="vertical-align: inherit;">大文字の「B」を押します。</font><font style="vertical-align: inherit;">画面に反応はありません。</font><font style="vertical-align: inherit;">もう一度「？」を押すと、答えのある新しい行が表示されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5i/uz/-r/5iuz-rrjfbmier5bfmazwx1svb0.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが機能します。</font><font style="vertical-align: inherit;">220ボルトをオフにすることを忘れないでください（コマンド 'b'）。</font><font style="vertical-align: inherit;">端末を終了するには、Ctrl + A、Xの順に押します。実験は完了です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPIおよびI </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C </font><font style="vertical-align: inherit;">タイヤ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SPIバス（Quad-SPIモードでも動作可能）およびI </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cは、ユニバーサルブリッジと組み合わせて実装されます。つまり、一般的に、コンプレックスには2つのブリッジがあり、それぞれのブリッジはSPIモードまたはI </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C </font><font style="vertical-align: inherit;">モードのいずれかでオンにできます</font><font style="vertical-align: inherit;">。構造図では、対応するセクションは次のようになり</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uy/lp/6k/uylp6kc6vcqjrlwluk5nxzpcezc.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終バスの接続の本質は、電気回路図から見ることができます。 2つのコントローラーの1つのみを考慮します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ah/rj/ah/ahrjahvujglcs3uoxl-wsdxfcpy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、SPIバスとI </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C </font><font style="vertical-align: inherit;">バス</font><font style="vertical-align: inherit;">はまったく交差しません。それらの共有に関する制限は、FT4222HコントローラのFTDIによって規定された制限によってのみ決定されます。残念ながら、ドキュメントには、一度に1つのインターフェイスしかアクティブにできないと記載されています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zc/7d/dw/zc7ddwfm-tstpt9lumoydqexceu.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CFG1_0..CFG1_1およびCFG2_0..CFG2_1の行を制御する方法については、次の記事で説明します。今、私たちはそれらがすべて無効化されていると信じています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、コントローラでの作業はドキュメント</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FT4222H USB2.0 TO QUADSPI / I2C BRIDGE IC</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">非常によく説明されている</font><font style="vertical-align: inherit;">ため、コントローラの制御モードの機能については考慮しません。言及されたドキュメントからすべてが非常に明確です。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソフトウェアサポートに関しては、その説明は、注目に値するドキュメント</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AN_329 User Guide For LibFT4222にあり</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。すでにFTDIブリッジを2回使用しました。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">後半と</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">この</font></a><font style="vertical-align: inherit;">後半で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、このドキュメントをこれらの記事と比較すると、すぐにそれを理解して、独自のコードの作成を開始できます。</font><font style="vertical-align: inherit;">SPIバスにデータを送信する参照コードを示します。その実装の詳細については説明しませんが、すべてがFT2232で既に解析された作業のように痛々しく見えます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データをSPIバスに送信するコード。</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">#include "../ftd2xx/ftd2xx.h"<font></font>
#include "../LibFT4222/inc/LibFT4222.h"<font></font>
<font></font>
void SpiTest (int pos)<font></font>
{<font></font>
	FT_HANDLE ftHandle = NULL;<font></font>
	FT_STATUS ftStatus;<font></font>
	FT4222_STATUS ft4222Status;<font></font>
<font></font>
	//  <font></font>
	ftStatus = FT_Open(pos, &amp;ftHandle);<font></font>
	if (FT_OK != ftStatus)<font></font>
	{<font></font>
		// open failed<font></font>
		printf ("error: Cannot Open FTDI Device\n");<font></font>
		return;<font></font>
	}<font></font>
	ft4222Status = FT4222_SPIMaster_Init(ftHandle, SPI_IO_SINGLE, CLK_DIV_4, CLK_IDLE_LOW, CLK_LEADING, 0x01);<font></font>
	if (FT4222_OK != ft4222Status)<font></font>
	{<font></font>
		printf ("error: Cannot switch to SPI Master Mode\n");<font></font>
		// spi master init failed<font></font>
		return;<font></font>
	}<font></font>
<font></font>
	uint8 wrBuf [] = {0x9f,0xff,0xff,0xff,0xff,0xff,0xff};<font></font>
	uint8 rdBuf [sizeof (wrBuf)];<font></font>
<font></font>
	uint16 dwRead;<font></font>
	ft4222Status = FT4222_SPIMaster_SingleReadWrite (ftHandle,rdBuf,wrBuf,sizeof (wrBuf),&amp;dwRead,TRUE);<font></font>
	if (FT4222_OK != ft4222Status)<font></font>
	{<font></font>
		printf ("error: Error on ReadWrite\n");<font></font>
	} else<font></font>
	{<font></font>
		printf ("received: ");<font></font>
		for (int i=0;i&lt;6;i++)<font></font>
		{<font></font>
			printf ("0x%X ",rdBuf[i]);<font></font>
		}<font></font>
		printf ("\n");<font></font>
	}<font></font>
<font></font>
	FT4222_UnInitialize(ftHandle);<font></font>
	FT_Close(ftHandle);<font></font>
<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPIバスパーツ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マイクロコントローラのコード開発者は、多くの場合、SPIバスを所定の周波数のジェネレータとして使用します。実際、純粋にGPIOラインを介してプログラムで生成されたパルスは、多くの要因に依存します。まず、分岐、ループの回転にはCPUサイクルが必要です。次に、割り込み、DMA、その他の予期しない要因がプロセッサに干渉する可能性があります。 SPIは多かれ少なかれ安定しています。自分で何とかしてバッファにバイトを入れてください。このSPI自体に直接関係のないSPIブロックの一般的なアプリケーションは、RGB LEDの制御です。RGBLEDの制御には、パルス幅の設定の精度が非常に重要です。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、これはFTDIブリッジでは受け入れられません。上記のコードフラグメントは、バス上でこれらのパルスを生成します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dv/zx/pe/dvzxpe6cevog4qaklf2zy8tkdye.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、SPIルールは違反されていません。このバスの観点からは、すべてが正しく機能します。</font><font style="vertical-align: inherit;">コントローラーで慣習的なカスタムソリューションはここでは機能しないことに注意してください。</font><font style="vertical-align: inherit;">確かに、複合施設には無料のUSBコネクタがたくさんあります。</font><font style="vertical-align: inherit;">すべての非標準ブロックを個別に開発して、それらに接続できます。</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイヤパーツI </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
意味のある唯一のことは</font><font style="vertical-align: inherit;">、複素数側の</font><font style="vertical-align: inherit;">I </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C </font><font style="vertical-align: inherit;">バス</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">プルアップ抵抗がないことを示すこと</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">しかし、これは正常です：動作しているデバイスの側面には、まだリフトがあります。</font><font style="vertical-align: inherit;">現在、プルアップは任意の電圧にすることができるため、ターゲットデバイスに設定することは論理的です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日、私たちはFTDIブリッジによって実装されたタイヤを操作する実践的なスキルを身につけました。</font><font style="vertical-align: inherit;">一般に、それらを使用することは標準です。少しずつそれらを探すのを避けるために、すべての知識が単一の記事に統合されているだけです。</font><font style="vertical-align: inherit;">次回は、STM32コントローラーに基づいて実装された非標準デバイスを制御するモジュールについて検討します。</font><font style="vertical-align: inherit;">構造図では、このセクションはそれに対応しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ic/w4/9g/icw49gdqjdx26qahasd425ul-sm.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、実際には、すべてがもう少し興味深いです...</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja477646/index.html">数学者は方程式の一部を求めて数字を切り取る</a></li>
<li><a href="../ja477650/index.html">Stunnelを使用したGOST-2012アルゴリズムによるTLSトラフィックの暗号化</a></li>
<li><a href="../ja477654/index.html">Java 14で改善されたinstanceofオペレーターを試す</a></li>
<li><a href="../ja477656/index.html">それでも、なぜmakeが必要なのですか？</a></li>
<li><a href="../ja477658/index.html">アクティブリストア：災害復旧を高速化できますか？はるかに高速？</a></li>
<li><a href="../ja477668/index.html">11月29日午後6時-devleads-mitap</a></li>
<li><a href="../ja477670/index.html">テストを自動化するもの</a></li>
<li><a href="../ja477672/index.html">チームメンバーの権利と義務：法的および文化的側面</a></li>
<li><a href="../ja477674/index.html">AIは愛を意味しますか？</a></li>
<li><a href="../ja477678/index.html">ロシアのデジタルテレビの展望</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>