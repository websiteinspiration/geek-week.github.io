<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⌨️ 🚞 🧔🏿 アウトソーシングから開発まで（パート1） 💇 🎓 👨🏼‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="みなさん、こんにちは。私の名前はセルゲイ・エメリャンチクです。私はVeliamシステムの主な開発者であり作成者であるAudit-Telecomの責任者です。私は私の友人と私がどのようにアウトソーシング会社を作り、自分たちのためにソフトウェアを書いたかに関する記事を書くことに決め、その後、それをSaa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>アウトソーシングから開発まで（パート1）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/audit-telecom/blog/504376/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">みなさん、こんにちは。私の名前はセルゲイ・エメリャンチクです。</font><font style="vertical-align: inherit;">私はVeliamシステムの主な開発者であり作成者であるAudit-Telecomの責任者です。</font><font style="vertical-align: inherit;">私は私の友人と私がどのようにアウトソーシング会社を作り、自分たちのためにソフトウェアを書いたかに関する記事を書くことに決め、その後、それをSaaSシステム上のすべての人に配布し始めました。</font><font style="vertical-align: inherit;">私が断固としてこれが可能であると信じていなかった方法について。</font><font style="vertical-align: inherit;">記事にはストーリーだけでなく、Veliam製品がどのように作成されたかに関する技術的な詳細も含まれます。</font><font style="vertical-align: inherit;">ソースコードの一部を含みます。</font><font style="vertical-align: inherit;">どのような誤りがあったのか、どのようにして後で修正されたのかをお話しします。</font><font style="vertical-align: inherit;">そのような記事を公開するかどうか疑問がありました。</font><font style="vertical-align: inherit;">しかし、記事を公開せずにどうなるかを考えるよりも、これを実行してフィードバックを得て修正する方が良いと思いました...</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックグラウンド</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はIT企業で従業員として働いていました。同社は非常に大規模で、広範なネットワーク構造を備えていました。私の公務については詳しく説明しません。確かに、彼らには何の開発も含まれていなかったと言うだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはモニタリングをしましたが、純粋に学問的な関心から外れているので、私の最も単純なものを書きたいと思いました。アイデアは次のとおりです。クライアントにインストールすることなく、ログインしてWi-Fi経由のモバイルデバイスを含む任意のデバイスからネットワークに何が起きるかを簡単に確認できるように、Web上に配置したいと思っていました。部屋は、「処理された」機器にあります。そのような問題への応答時間には非常に厳しい要件がありました。その結果、jpegの背景がネットワークダイアグラムにある単純なWebページを作成し、この図のIPアドレスを使用してデバイス自体を切り取り、正しい座標に緑色または点滅する赤いIPアドレスの形式で既に動的なコンテンツを表示するという計画が頭の中で生まれました。タスクが設定されました。続行してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前は、Delphi、PHP、JS、および表面的にはC ++でプログラミングに従事していました。ネットワークの仕組みはよく知っています。 VLAN、ルーティング（OSPF、EIGRP、BGP）、NAT。これは、プリミティブモニタリングのプロトタイプを自分で作成するには十分でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHPで計画を書いた。 ApacheサーバーとPHPはWindows以降に現時点で私にとってのLinuxは、理解できず非常に複雑なものでした。後で判明したように、私は非常に誤解されており、多くの場所でLinuxはWindowsよりもはるかに単純ですが、これは別のトピックであり、このトピックのホリバーの数はすべてわかっています。 Windowsタスクスケジューラが少し間隔をおいて（正確には覚えていませんが、3秒に1回など）、平凡なpingですべてのオブジェクトをポーリングして状態をファイルに保存するPHPスクリプトです。</font></font><br>
<br>
<pre><code class="php hljs">system(“ping -n <span class="hljs-number">3</span> -w <span class="hljs-number">100</span> {$ip_address}“); 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、その時点でのデータベースの操作も私にとっては習熟していませんでした。プロセスを並列化できることを知りませんでした。すべてのネットワークノードを通過するのに長い時間がかかりました。これは1つのスレッドで発生しました。特に、いくつかのノードが利用できない場合に問題が発生しました。それぞれがスクリプトを300ミリ秒遅らせました。クライアント側には、単純なループ関数があり、更新された情報をAjaxサーバーから数秒の間隔でダウンロードし、インターフェースを更新しました。それで、pingが3回続けて失敗した後、コンピュータで監視用のWebページが開かれた場合、明るい構図が再生されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてがうまくいったとき、私はその結果に非常に刺激を受け、それでもそこにそれをねじ込むことができると思いました（私の知識と能力により）。しかし、私は常に100万グラフを備えたシステムが好きではありませんでした。それは、私が考えたように、今日でも考慮しているように、ほとんどの場合不要です。私の仕事で本当に役立つものだけをそこにねじ込みたかったのです。この原則は、ヴェリアムの開発において基本的に維持されています。さらに、監視を開いたままにして問題を認識させる必要がない場合は非常に便利であることがわかりました。問題が発生した場合は、ページを開いて、この問題のネットワークノードの場所と次に何をすべきかを確認してください。そのときはメールを読んでいなかったので、使用しなかっただけです。 GETまたはPOSTリクエストを送信できるSMSゲートウェイがあることをインターネットで知りました。そして彼らは私が私の携帯電話で書くテキストを含むSMSを私に送信します。私はこれが本当に欲しいとすぐに気づきました。そして彼はドキュメンテーションを研究し始めました。しばらくして私は成功し、今では携帯電話で「フォールドオブジェクト」という名前のネットワークの問題に関するSMSを受け取りました。システムは原始的でしたが、私が自分で作成したものであり、最も重要なのは、システムを開発する動機となったのは、自分の仕事で本当に役立つアプリケーションプログラムであることです。これは私の仕事を本当に助けてくれるアプリケーションプログラムです。これは私の仕事を本当に助けてくれるアプリケーションプログラムです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、インターネットチャネルの1つが機能しなくなった日が来ました。私の監視ではそれを知らされませんでした。 Google DNSはまだ完全にpingされているので。通信チャネルが生きていることを監視する方法について考える時が来ました。これを行う方法についてはさまざまなアイデアがありました。私がアクセスできたすべての機器とは限りません。どのチャネルが生きているかを理解する方法を理解する必要がありましたが、ネットワーク機器自体でそれを見ることができませんでした。次に、同僚が、インターネットが現在アクセスしている通信チャネルによっては、パブリックサーバーへのルートを追跡できる可能性があると考えました。チェックしたところ、判明しました。トレースするときに異なるルートがありました。</font></font><br>
<br>
<pre><code class="php hljs">system(“tracert -d -w <span class="hljs-number">500</span> <span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>”);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、別のスクリプトが表示されました。むしろ、ネットワーク上のすべてのデバイスにpingを実行した同じスクリプトの最後に、なんらかの理由でトレースが追加されました。結局のところ、これは同じスレッドで実行された別の長いプロセスであり、スクリプト全体の処理を遅くしました。しかし、それはそれほど明白ではありませんでした。しかし、何らかの方法で彼は仕事をしていました。コードでは、各チャネルのトレースを厳密に記述していました。したがって、システムは機能し始めました。これは、ネットワークデバイス（ルーター、スイッチ、wi-fiなど）および外部世界との通信チャネルを監視（大まかに言って、メトリックの収集がなく、pingのみだったため） 。 SMSは定期的に届き、図では、問題がどこにあるのかが常にはっきりとわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、日常の仕事では、相互リンクを扱わなければなりませんでした。また、毎回、Ciscoスイッチにアクセスして、どのインターフェイスを使用する必要があるかを確認します。オブジェクトの監視を突っ込んで、そのインターフェイスのリストと説明を表示するのは、どれほど素晴らしいことでしょう。そうすれば時間を節約できます。さらに、このスキームでは、アカウントとコマンドを入力するためにPuttyまたはSecureCRTを実行する必要はありません。私はモニタリングをつついて、何が必要かを見て、私の仕事に行きました。彼はスイッチとどのように相互作用するかを探し始めました。私はすぐに2つのオプションを得ました。SNMPかSSH経由でスイッチに行き、必要なコマンドを入力して結果を解析します。実装の複雑さのためにSNMPは却下され、私はその結果を知りたがっていました。 SNMPは、インターフェースに関するデータを形成するために、このデータに基づいて長期間にわたってMIBを掘り下げる必要があります。CISCOには素晴らしいチームがあります</font></font><br>
<br>
<pre><code class="javascript hljs">show interface status</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはちょうど私がクロスオーバーに必要なものを示しています。このコマンドの出力を見たいだけなのに、なぜSNMPに悩むのかと思った。しばらくして、この機会に気づきました。 Webページ上のオブジェクトをクリックしました。 AJAXクライアントがサーバーにアクセスすることによってイベントがトリガーされ、サーバーがSSHを介して必要なスイッチに接続しました（資格情報はコードに接続されていたため、調整したり、インターフェイスからアカウントを変更できる別のメニューを作成したりする必要はありませんでした） 、結果が必要で、すぐに）上記のコマンドをそこに入力して、ブラウザに返しました。だから、マウスのワンクリックでインターフェースの情報を見始めました。特に、さまざまなスイッチでこの情報を一度に見なければならない場合は、非常に便利でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果として、追跡に基づくチャネルの監視は最善のアイデアではないことが判明しました。時々、ネットワーク上で作業が行われ、トレースが変更される可能性があり、監視はチャネルに問題があることを私に怒鳴り始めました。しかし、分析に多くの時間を費やしていると、すべてのチャネルが機能していて、私の監視が私をだましていることに気付きました。その結果、チャネル形成スイッチを制御している同僚に、隣人の可視状態が変化したときにsyslogだけを送信するように依頼しました。したがって、トレースよりもはるかに単純、高速、かつ正確でした。ネイバーロストという形のイベントが届き、すぐにチャンネルが落ちたことを通知します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、いくつかのコマンドを追加してオブジェクトをクリックすると結論が出ました。SNMPがいくつかのメトリックを収集するために追加されました。まあ、それだけです。</font><font style="vertical-align: inherit;">システム以上のものは開発されていません。</font><font style="vertical-align: inherit;">彼女は私が必要とするすべてをしました、それは良いツールでした。</font><font style="vertical-align: inherit;">多くの読者はおそらくこれらの問題を解決するためにインターネット上にすでに多くのソフトウェアがあると私に言うでしょう。</font><font style="vertical-align: inherit;">しかし、実際には、そのような製品を当時グーグル化していなかったので、プログラミングスキルを開発したいと思っていました。これを実現するには、実際に適用するタスクよりも優れた方法があります。</font><font style="vertical-align: inherit;">これで、監視の最初のバージョンが完了し、変更されなくなりました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Audit-Telecomの設立</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間が経つにつれ、他の会社で並行して追加のお金を稼ぐようになりました。これは、仕事のスケジュールで可能になったためです。さまざまな企業で働くと、さまざまな分野でのスキルが非常に速く成長し、視野がうまく広がります。言うまでもないことですが、あなたは両方ともシュワイト、死神、そしてパイプの男です。一方、怠惰でない場合は難しいですが、広い分野の専門家になると、隣接する領域の仕組みを知っているため、問題をより迅速かつ効率的に解決できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
友人のPavel（これもITの専門家です）は、常に私を彼のビジネスに引き込もうとしました。彼らの仕事には様々なオプションがある無数のアイデアがありました。これは1年以上議論されてきました。そして、結局、私は懐疑的で、パベルは夢想家なので、それは何にもなるべきではありませんでした。彼がアイデアを提案するたびに、私はいつもそれを信じず、参加を拒否しました。しかし、私たちは本当に自分のビジネスを開きたいと思っていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、私たちは両方に合ったオプションを見つけ、私たちができることをすることができました。 2016年には、ITの問題を解決するビジネスを支援するIT企業を設立することを決定しました。これは、ITシステム（1C、ターミナルサーバー、メールサーバーなど）の展開、それらのサポート、ユーザーおよびネットワーク管理のための従来のヘルプデスクです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
率直に言って、会社の設立当時、私はそれを99.9％ほど信じていませんでした。しかし、どういうわけか、パウロは私に試させることができました、そして前を向いて、彼は正しかったです。 Pavelと私は300,000ルーブルを投げ、新しいAudit-Telecom LLCを登録し、小さなオフィスを借り、一般に、おそらく最も経験の浅い初心者ビジネスマンのように、かっこいい名刺を作り、顧客を探し始めました。顧客検索はまったく別の話です。おそらく、誰かが興味を持っているのであれば、企業ブログの一部として別の記事を書くでしょう。コールドコール、チラシなど。結果は得られませんでした。私が今読んでいるように、多くのビジネスストーリーから、いずれにせよ、多くは運に依存しています。私たちは幸運だった。会社が設立されてからわずか数週間後、弟のウラジミールが私たちに目を向けました。最初の顧客をもたらした人。私はクライアントとの連携の詳細を退屈させません。記事はそれについてではありません。私たちは監査に出かけ、重要な場所を特定し、これらの場所が壊れて、アウトソーシング業者として継続的に私たちと連携するかどうかが決定されたと断言できました。その後、すぐに前向きな決定が下されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、主に知人を通じたサンドレスを中心に、他のサービス会社も登場し始めた。ヘルプデスクは同じシステム上にありました。別の、または誰かのようなネットワーク機器やサーバーへの接続。誰かがショートカットを保持し、誰かがRDPアドレス帳を使用しました。モニタリングは別のシステムです。異種システムでのチームワークは非常に不便です。重要な情報を見失っています。たとえば、クライアントターミナルサーバーが利用できなくなりました。このクライアントのユーザーからのアプリケーションがすぐに届きます。サポートサービススペシャリストがアプリケーションを開始します（彼女は電話で受け取りました）。インシデントとリクエストが1つのシステムに記録された場合、サポートスペシャリストは、ユーザーが問題を抱えていることをすぐに確認し、そのことをユーザーに伝えます。誰もが戦術的な状況を認識しており、スムーズに作業しています。これらすべてを組み合わせたシステムは見つかりませんでした。あなたの製品を作る時が来たことが明らかになりました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">監視システムの継続的な作業</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 以前に作成されたシステムは、現在のタスクにはまったく不適切であることは明らかでした。</font><font style="vertical-align: inherit;">機能面でも品質面でも。</font><font style="vertical-align: inherit;">そして、システムを最初から作成することにしました。</font><font style="vertical-align: inherit;">視覚的には、完全に異なって見えるはずです。</font><font style="vertical-align: inherit;">適切なクライアントから目的のオブジェクトをすばやく便利に開くことができるように、階層システムである必要がありました。</font><font style="vertical-align: inherit;">最初のバージョンのようなスキームは、現在のケースでは絶対に正当化されませんでした。</font><font style="vertical-align: inherit;">クライアントは異なり、機器がどの部屋にあるかは問題ではありませんでした。</font><font style="vertical-align: inherit;">これはすでにドキュメントに転送されています。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したがって、タスク：</font></font></u> <br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">階層構造;</font></font></li>
<li>-  ,                   ,        ;</li>
<li>. ,   , ..       -      ;</li>
<li> .   ,          ,    ;</li>
<li>        ;</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクが設定され、書き込みを開始します。途中で、顧客からのアプリケーションを処理します。当時、すでに4人でした。私たちは、両方の部分と中央サーバー、およびクライアントへのインストール用サーバーを同時に作成し始めました。この時点で、Linuxはもはや見知らぬ人ではなく、クライアント上にある仮想マシンはDebian上にあることが決定されました。インストーラーはなく、1つの特定の仮想マシンでサーバー側プロジェクトを実行し、適切なクライアントに複製するだけです。これは別の間違いでした。後で、このようなスキームでは更新メカニズムが機能しないことが明らかになりました。それら。新しい機能をいくつか追加したところ、それをすべてのクライアントサーバーに配布するという全体的な問題がありましたが、後ですべてに順番に戻ってこれに戻ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らは最初のプロトタイプを作りました。彼は、必要なクライアントデバイスとサーバーをpingし、このデータを中央サーバーで送信する方法を知っていました。そして、中央サーバーでこのデータを一括で更新しました。ここでは、どのようにして何が可能であったかについての話だけでなく、アマチュア的な過ちが犯された経緯や、時間とともにどのようにそれを支払わなければならなかったかについても書きます。したがって、オブジェクトのツリー全体が、シリアル化されたオブジェクトの形式で1つのファイルに格納されました。いくつかのクライアントをシステムに接続しましたが、完全に理解できないアーティファクトが時々あったとしても、すべてが多かれ少なかれ正常でした。しかし、12台のサーバーをシステムに接続すると、奇跡が働き始めました。場合によっては、システム内のすべてのオブジェクトが単に消えた理由が明確ではありません。ここで、クライアントが持っていたサーバーがPOSTリクエストを通じて、数秒ごとに中央サーバーにデータを送信しました。注意深い読者と経験豊富なプログラマーは、異なるストリームからのシリアル化されたオブジェクトが同時に格納されている同じファイルへの複数のアクセスの問題があることをすでに認識しています。そして、これが起こったちょうどその時、奇跡は物体の消失とともに現れました。ファイルが空になっただけです。しかし、これはすぐに発見されたのではなく、複数のサーバーでの運用中にのみ発見されました。この間、ポートスキャン機能が追加されました（サーバーは、デバイスの可用性に関する情報だけでなく、デバイスで開いているポートに関する情報も中央サーバーに送信されます）。これは、次のコマンドを呼び出すことによって行われました。異なるストリームからのシリアル化されたオブジェクトが同時に格納されている同じファイルへの複数のアクセスの問題があったこと。そして、これが起こったちょうどその時、奇跡は物体の消失とともに現れました。ファイルが空になっただけです。しかし、これはすぐに発見されたのではなく、複数のサーバーでの運用中にのみ発見されました。この間、ポートスキャン機能が追加されました（サーバーは、デバイスの可用性に関する情報だけでなく、デバイスで開いているポートに関する情報も中央サーバーに送信されます）。これは、次のコマンドを呼び出すことによって行われました。異なるストリームからのシリアル化されたオブジェクトが同時に格納されている同じファイルへの複数のアクセスの問題があったこと。そして、これが起こったちょうどその時、奇跡は物体の消失とともに現れました。ファイルが空になっただけです。しかし、これはすぐに発見されたのではなく、複数のサーバーでの運用中にのみ発見されました。この間、ポートスキャン機能が追加されました（サーバーは、デバイスの可用性に関する情報だけでなく、デバイスで開いているポートに関する情報も中央サーバーに送信されます）。これは、次のコマンドを呼び出すことによって行われました。ただし、複数のサーバーでの操作中のみ。この間、ポートスキャン機能が追加されました（サーバーは中央のサーバーに送信され、デバイスの可用性に関する情報だけでなく、デバイス上で開いているポートについての情報も送信されます）。これは、次のコマンドを呼び出すことによって行われました。ただし、複数のサーバーでの操作中のみ。この間、ポートスキャン機能が追加されました（サーバーは、デバイスの可用性に関する情報だけでなく、デバイスで開いているポートに関する情報も中央サーバーに送信されます）。これは、次のコマンドを呼び出すことによって行われました。</font></font><br>
<br>
<pre><code class="php hljs">$connection = @fsockopen($ip, $port, $errno, $errstr, <span class="hljs-number">0.5</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果はしばしば不正確であり、スキャンには非常に長い時間がかかりました。私は完全にpingを忘れました、それはfpingによって行われました：</font></font><br>
<br>
<pre><code class="php hljs">system(<span class="hljs-string">"fping -r 3 -t 100 {$this-&gt;ip}"</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これもすべて並列化されなかったため、プロセスは非常に長くなりました。</font><font style="vertical-align: inherit;">その後、チェックに必要なIPアドレスのリスト全体がすでにfpingに転送され、応答した人のリストがすぐに返されました。</font><font style="vertical-align: inherit;">私たちとは異なり、fpingはプロセスを並列化できました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの頻繁な作業は、WEB経由でいくつかのサービスをセットアップすることでした。</font><font style="vertical-align: inherit;">たとえば、MS ExchangeのECPなどです。</font><font style="vertical-align: inherit;">概して、これは単なるリンクです。</font><font style="vertical-align: inherit;">そして、そのようなリンクをシステムに直接追加して、ECPで特定のクライアントを入力する方法をドキュメントやブックマークのどこかで見ないようにする必要があると判断しました。</font><font style="vertical-align: inherit;">したがって、システムのリソースリンクの概念が登場し、それらの機能は現在でも利用可能で、ほとんど変更されていません。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veliamの作業リソースリンク</font></font></b>
                        <div class="spoiler_text"><img src="https://habrastorage.org/webt/bk/ka/4m/bkka4mmzo_u_of3l1bokrep_sww.gif" alt="image"><br>
</div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リモート接続</font></font></h3><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のバージョンのVeliamは次のようになります</font></font></b>
                        <div class="spoiler_text"><img src="https://habrastorage.org/webt/cn/tl/mg/cntlmgkmcql9iqh2irggldiwdwu.gif" alt="image"><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクの1つは、サーバーにすばやく簡単に接続することでした。サーバーには既にたくさん（100以上）あり、以前に保存された何百万ものRDPショートカットを並べ替えることは非常に不便でした。ツールが必要でした。インターネット上には、このようなRDP接続用のアドレス帳のようなソフトウェアがありますが、それらは監視システムと統合されておらず、記録を保存できません。毎回、さまざまなクライアントにアカウントを入力するのは大変なことです。毎日、さまざまなサーバーに数十回以上接続する場合です。 SSHを使用すると、状況は少し改善されます。パパがこのような接続をレイアウトして、それらのレコードを記憶できる優れたソフトウェアがたくさんあります。しかし、2つの問題があります。まず、RDPおよびSSH接続用の単一のプログラムが見つかりませんでした。 2つ目-ある時点で自分のコンピューターがなく、すぐに接続する必要がある場合、または、システムを再インストールしただけです。このクライアントからのアカウンティングを確認するには、ドキュメントにアクセスする必要があります。それは不便で時間の無駄です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントサーバーに必要な階層構造は、既に社内製品に存在しています。必要な機器への高速接続をそこに固定する方法を理解することだけが必要でした。まず、少なくともネットワーク内で。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのシステムのクライアントは、コンピューターのローカルリソースにアクセスできないブラウザーであり、必要なアプリケーションをコマンドで実行するためだけに、「WindowsカスタムURLスキーム」を介してすべてを実行すると考えられていました。そのため、私たちのシステムには特定の「プラグイン」があり、これには、PuttyとRemote Desktop Plusが含まれ、インストール時にWindowsに単にURIスキームが登録されていました。これで、RDPまたはSSHを介してオブジェクトに接続するときに、システムでこのアクションをクリックすると、カスタムURIが機能しました。 Windowsまたはパテに組み込まれている標準のmstsc.exeが起動され、「プラグイン」が付属しています。プラグインという言葉は、古典的な意味でのブラウザプラグインではないため、引用符で囲みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはすでに少なくとも何かでした。便利なアドレス帳。さらに、Puttyの場合、すべては一般的に問題なく、入力パラメーターとしてIP接続とログインとパスワードを与えることができました。それら。パスワードを入力せずに、ワンクリックでネットワーク内のLinuxサーバーにすでに接続しています。しかし、RDPはそれほど単純ではありません。標準のmstscは、資格情報をパラメーターとして提供できません。 Remote Desktop Plusが助けになりました。彼はそれをやらせた。今では彼なしで済ますことができますが、長い間、彼は私たちのシステムの忠実なアシスタントでした。 HTTP（S）サイトでは、すべてがシンプルです。そのようなオブジェクトはブラウザで開かれるだけで、それだけです。便利で実用的です。しかし、それは内部ネットワークでのみ幸せでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
圧倒的多数の問題をオフィスからリモートで解決したため、クライアントへのVPNを作成するのが最も簡単でした。そして、私たちのシステムからそれらに接続することが可能でした。しかし、それでも多少不快でした。クライアントごとに、各コンピュータに格納された一連のVPN接続を維持する必要があり、いずれかに接続する前に、対応するVPNを有効にする必要がありました。このソリューションはかなり前から使用されています。しかし、クライアントの数、VPNの数も増加しており、これらすべてに負担がかかり始めており、何らかの対策を講じる必要がありました。特に、システムを再インストールした後、新しいWindowsプロファイルで数十のVPN接続を再び駆動する必要があったとき、彼の目に涙が出ました。それを我慢するのに十分だと私は言って、それについて何ができるか考え始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
偶然にも、すべてのクライアントが有名なMikrotik社のデバイスをルーターとして持っていました。それらは非常に機能的で、ほとんどすべてのタスクを実行するのに便利です。マイナスの-彼らは「盗まれた」。この問題は、外部からのアクセスをすべて閉じるだけで解決しました。しかし、クライアントのところに来ることなく、どういうわけかそれらにアクセスする必要がありました。久しぶり。そのようなMikrotikの前にトンネルを作成し、それらを別のプールに割り当てました。ルーティングがないため、ネットワークがクラ​​イアントのネットワークおよびクライアント間のネットワークと統合されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムで必要なオブジェクトをクリックすると、中央監視サーバーは、すべてのクライアントマイクロティックのSSHからのアカウントを認識し、適切なアカウントに接続し、適切なポートを持つ適切なホストへの転送ルールを作成することを確認するために生まれました。ここでいくつかのポイントがあります。ソリューションは普遍的ではありません-すべてのルーターのコマンドの構文が異なるため、Mikrotikでのみ機能します。また、このようなプローブは後でどういうわけか削除する必要があり、実際、システムのサーバー側では、RDPセッションが終了したかどうかをまったく追跡できませんでした。まあ、そのような転送はクライアントの穴です。そして私たちは普遍性を追求しませんでした。この製品は社内でのみ使用されており、公開するつもりはありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それぞれの問題は独自の方法で解決されました。ルールが作成されたとき、この転送は1つの特定の外部IPアドレス（接続の初期化元）に対してのみ使用可能でした。したがって、セキュリティホールは回避されました。しかし、そのような接続ごとに、NATページのマイクロティックにルールが追加され、クリアされませんでした。そして、ルールが多ければ多いほど、ルーターのプロセッサに多くの負荷がかかることを誰もが知っています。そして一般的に、私はいつかミクロティックに行くようなことを受け入れることができず、誰も必要としない何百もの死んだルールがあった。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 私たちのサーバーは接続のステータスを監視できないため、Mikrotikがそれら自体を監視するようにします。</font><font style="vertical-align: inherit;">また、特定の説明（説明）を使用してすべての転送ルールを常に監視し、TCP接続に適切なルールがあるかどうかを確認するスクリプトを作成しました。</font><font style="vertical-align: inherit;">しばらく存在しない場合は、おそらく接続がすでに完了しているため、この転送を削除できます。</font><font style="vertical-align: inherit;">すべてが判明し、スクリプトはうまくいきました。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ちなみに、彼はここにいます：</font></font></b>
                        <div class="spoiler_text"><pre><code class="bash hljs">global atmonrulecounter {<span class="hljs-string">"dontDelete"</span>=<span class="hljs-string">"dontDelete"</span>}<font></font>
:foreach i <span class="hljs-keyword">in</span>=[/ip firewall nat find comment~<span class="hljs-string">"atmon_script_main"</span>] <span class="hljs-keyword">do</span>={ 
	<span class="hljs-built_in">local</span> dstport [/ip firewall nat get value-name=<span class="hljs-string">"dst-port"</span> <span class="hljs-variable">$i</span>]
	<span class="hljs-built_in">local</span> dstaddress [/ip firewall nat get value-name=<span class="hljs-string">"dst-address"</span> <span class="hljs-variable">$i</span>]
	<span class="hljs-built_in">local</span> dstaddrport <span class="hljs-string">"<span class="hljs-variable">$dstaddress</span>:<span class="hljs-variable">$dstport</span>"</span>
	<span class="hljs-comment">#log warning message=$dstaddrport</span>
	<span class="hljs-built_in">local</span> thereIsCon [/ip firewall connection find dst-address~<span class="hljs-string">"<span class="hljs-variable">$dstaddrport</span>"</span>]
	<span class="hljs-keyword">if</span> (<span class="hljs-variable">$thereIsCon</span> = <span class="hljs-string">""</span>) <span class="hljs-keyword">do</span>={
		<span class="hljs-built_in">set</span> (<span class="hljs-variable">$atmonrulecounter</span>-&gt;<span class="hljs-variable">$dstport</span>) (<span class="hljs-variable">$atmonrulecounter</span>-&gt;<span class="hljs-variable">$dstport</span> + 1)
		<span class="hljs-comment">#:log warning message=($atmonrulecounter-&gt;$dstport)</span>
		<span class="hljs-keyword">if</span> ((<span class="hljs-variable">$atmonrulecounter</span>-&gt;<span class="hljs-variable">$dstport</span>) &gt; 5) <span class="hljs-keyword">do</span>={
			<span class="hljs-comment">#log warning message="Removing nat rules added automaticaly by atmon_script"</span>
			/ip firewall nat remove [/ip firewall nat find comment~<span class="hljs-string">"atmon_script_main_<span class="hljs-variable">$dstport</span>"</span>]<font></font>
			/ip firewall nat remove [/ip firewall nat find comment~<span class="hljs-string">"atmon_script_sub_<span class="hljs-variable">$dstport</span>"</span>]
			<span class="hljs-built_in">set</span> (<span class="hljs-variable">$atmonrulecounter</span>-&gt;<span class="hljs-variable">$dstport</span>) 0<font></font>
		}<font></font>
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-built_in">set</span> (<span class="hljs-variable">$atmonrulecounter</span>-&gt;<span class="hljs-variable">$dstport</span>) 0<font></font>
	}<font></font>
}<font></font>
<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確かに、より美しく、より速くすることができますが、それは機能し、mikrotikiをロードせず、優れた仕事をしました。</font><font style="vertical-align: inherit;">マウスをワンクリックするだけで、ようやくクライアントのサーバーやネットワーク機器に接続できるようになりました。</font><font style="vertical-align: inherit;">VPNを上げたり、パスワードを入力したりする必要はありません。</font><font style="vertical-align: inherit;">システムでの作業がとても便利になりました。</font><font style="vertical-align: inherit;">サービス時間を短縮し、適切な施設に接続するのではなく、全員が作業に時間を費やしました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックアップMikrotik</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのMikrotikをFTPにバックアップするように設定されています。</font><font style="vertical-align: inherit;">そして全体的に、すべてが順調でした。</font><font style="vertical-align: inherit;">しかし、バックアップを取得する必要があるが、このFTPを開いてそこを探す必要がある場合。</font><font style="vertical-align: inherit;">すべてのルーターが起動するシステムがあり、SSH経由でデバイスと通信できます。</font><font style="vertical-align: inherit;">システム自体がすべてのMikrotikから毎日バックアップを取ることを確認してはどうでしょうか。</font><font style="vertical-align: inherit;">そして実装を開始しました。</font><font style="vertical-align: inherit;">私たちは接続し、バックアップを作成して、それを店に持っていきました。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mikrotikからバックアップを削除するためのPHPスクリプトコード：</font></font></b>
                        <div class="spoiler_text"><pre><code class="php hljs"><span class="hljs-meta">&lt;?php</span><font></font>
<font></font>
	$IP = <span class="hljs-string">'0.0.0.0'</span>;<font></font>
	$LOGIN = <span class="hljs-string">'admin'</span>;<font></font>
	$PASSWORD = <span class="hljs-string">''</span>;<font></font>
	$BACKUP_NAME = <span class="hljs-string">'test'</span>;<font></font>
<font></font>
    $connection = ssh2_connect($IP, <span class="hljs-number">22</span>);<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (!ssh2_auth_password($connection, $LOGIN, $PASSWORD)) <span class="hljs-keyword">exit</span>;<font></font>
<font></font>
    ssh2_exec($connection, <span class="hljs-string">'/system backup save name="atmon" password="atmon"'</span>);<font></font>
    stream_get_contents($connection);<font></font>
    ssh2_exec($connection, <span class="hljs-string">'/export file="atmon.rsc"'</span>);<font></font>
    stream_get_contents($connection);<font></font>
    sleep(<span class="hljs-number">40</span>); <span class="hljs-comment">// Waiting bakup makes</span><font></font>
<font></font>
    $sftp = ssh2_sftp($connection);<font></font>
<font></font>
    <span class="hljs-comment">// Download backup file</span>
    $size = filesize(<span class="hljs-string">"ssh2.sftp://$sftp/atmon.backup"</span>);<font></font>
    $stream = fopen(<span class="hljs-string">"ssh2.sftp://$sftp/atmon.backup"</span>, <span class="hljs-string">'r'</span>);<font></font>
    $contents = <span class="hljs-string">''</span>;<font></font>
    $read = <span class="hljs-number">0</span>;<font></font>
    $len = $size;<font></font>
    <span class="hljs-keyword">while</span> ($read &lt; $len &amp;&amp; ($buf = fread($stream, $len - $read))) {<font></font>
        $read += strlen($buf);<font></font>
        $contents .= $buf;<font></font>
    }<font></font>
    file_put_contents ($BACKUP_NAME . ‘.backup’,$contents);<font></font>
    @fclose($stream);<font></font>
<font></font>
    sleep(<span class="hljs-number">3</span>);
    <span class="hljs-comment">// Download RSC file</span>
    $size = filesize(<span class="hljs-string">"ssh2.sftp://$sftp/atmon.rsc"</span>);<font></font>
    $stream = fopen(<span class="hljs-string">"ssh2.sftp://$sftp/atmon.rsc"</span>, <span class="hljs-string">'r'</span>);<font></font>
    $contents = <span class="hljs-string">''</span>;<font></font>
    $read = <span class="hljs-number">0</span>;<font></font>
    $len = $size;<font></font>
    <span class="hljs-keyword">while</span> ($read &lt; $len &amp;&amp; ($buf = fread($stream, $len - $read))) {<font></font>
        $read += strlen($buf);<font></font>
        $contents .= $buf;<font></font>
    }<font></font>
    file_put_contents ($BACKUP_NAME . ‘.rsc’,$contents);<font></font>
    @fclose($stream);<font></font>
<font></font>
    ssh2_exec($connection, <span class="hljs-string">'/file remove atmon.backup'</span>);<font></font>
    ssh2_exec($connection, <span class="hljs-string">'/file remove atmon.rsc'</span>);<font></font>
<font></font>
<span class="hljs-meta">?&gt;</span>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックアップは、バイナリとテキスト構成の2つの形式で削除されます。</font><font style="vertical-align: inherit;">バイナリは、目的の構成をすばやく復元するのに役立ちます。テキストの1つを使用すると、機器を交換してバイナリを流せない場合の対処方法を理解できます。</font><font style="vertical-align: inherit;">その結果、システムにもう1つの便利な機能が追加されました。</font><font style="vertical-align: inherit;">さらに、新しいMikrotikを追加する場合、何も設定する必要はなく、オブジェクトをシステムに追加して、SSHからそのアカウントを設定するだけです。</font><font style="vertical-align: inherit;">さらに、システム自体がバックアップの削除に従事していました。</font><font style="vertical-align: inherit;">SaaS Veliamの現在のバージョンでは、この機能はまだ利用できませんが、間もなく移植される予定です。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部システムでの外観のスクリーンショット</font></font></b>
                        <div class="spoiler_text"><img src="https://habrastorage.org/webt/-n/uo/8n/-nuo8nqu0ixwgrtcgfdzjsc3fry.jpeg" alt="image"></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースの通常のストレージへの移行</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上で、アーティファクトが出現することをすでに書いた。場合によっては、システム内のオブジェクトのリスト全体が単に消えてしまうことがあります。オブジェクトを編集するときに、情報が保存されず、オブジェクトの名前を3回変更する必要がありました。それはひどくイライラしました。オブジェクトの消失はまれであり、このファイル自体を復元することで簡単に復元できましたが、オブジェクトを編集するときのファイルは、多くの場合単純でした。おそらく、すべてのリンクを持つツリーをフラットテーブルに保持する方法が頭に合わなかったため、最初はデータベースを介してこれを実行しませんでした。それは平らで、ツリーは階層的です。しかし、複数のアクセス、および後で（システムの複雑化を伴い）トランザクション対応の優れたソリューションは、DBMSです。この問題に遭遇したのはおそらく私が最初ではありません。グーグルを助けた。すべてが私の前に発明され、いくつかのアルゴリズムがあることがわかりました、平らなテーブルから木を作っている人。それぞれを見て、そのうちの1つを実装しました。しかし、これはすでにシステムの新しいバージョンでした。実際、私はこれのために多くのことを書き直さなければなりませんでした。結果は論理的で、システムのランダムな動作の問題はなくなりました。ソフトウェア開発の分野では、エラーは非常に素人っぽい（シングルスレッドのスクリプト、異なるストリームからの複数の同時アクセスであった情報の保存など）と言う人もいるかもしれません。それはそうかもしれませんが、私の主な仕事は管理であり、プログラミングは魂のために並んでいました、そして私はプログラマーのチームで働いた経験がなかっただけで、そのような基本的なことは先輩の同志からすぐに私に言われました。したがって、私はこれらすべてのコーンを自分で詰めましたが、材料を非常によく学びました。それでも、彼らのビジネスはクライアントとのミーティングです。そして、会社を促進しようとすることを目的とした行動と、会社内の管理上の問題の束、そしてはるかに多くのこと。しかしとにかく、すでにあったものは-需要がありました。みんなと私は毎日の仕事で製品を使用しました。率直に言って失敗したアイデアと時間がかかる解決策がありましたが、最終的にはこれが機能しないツールであり、誰もそれを使用しておらず、Veliamに入らないことが明らかになりました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サポートサービス-HelpDesk</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 ヘルプデスクがどのように形成されたかに言及することは不必要ではありません。</font><font style="vertical-align: inherit;">これは一般に別の話です。</font><font style="vertical-align: inherit;">Veliamでは、これは3つ目の完全に新しいバージョンであり、以前のバージョンとは異なります。</font><font style="vertical-align: inherit;">これは、ドメインと統合する機能、およびレターからのリンク上のどこからでも同じユーザープロファイルにアクセスする機能を備えた、不要な波立たないちらつきのない直感的なシンプルなシステムです。</font><font style="vertical-align: inherit;">そして最も重要なのは、VPNやポート転送を使用せずに、どこからでも（自宅またはオフィス内から）アプリケーションからVNC経由で申請者に直接接続できることです。</font><font style="vertical-align: inherit;">私たちがこれに至った経緯、以前に何が起こったのか、どんな恐ろしい決定があったのかをお話しします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有名なTeamViewerを介してユーザーに接続しました。私たちが提供するユーザーがインストールしたテレビを備えたすべてのコンピューター。私たちが最初に間違ったこと、そしてその後にそれを取り除いたのは、各HDクライアントをハードウェアにバインドすることでした。リクエストを残すために、ユーザーはどのようにしてHDシステムに入りましたか？ TVに加えて、Lazarusで書かれたすべての人のためにコンピューターに特別なユーティリティがインストールされました（多くの人が目を丸くして、多分彼らはそれが何であるかさえググることができますが、Delphiがコンパイル言語を最もよく知っていて、Lazarusはほとんど同じもので、無料だけです）。一般に、ユーザーはこのユーティリティを起動する特別なバッチファイルを起動しました。このユーティリティは、システムのHWIDを読み取り、その後、ブラウザーが起動して認証が行われました。なぜこれが行われたのですか？一部の企業では、サーブされたユーザーのカウントはピースごとに行われ、月ごとのサービスの価格は人数に基づいて形成されます。これは理解できるとあなたは言うが、なぜハードウェアにバインドするのか。非常にシンプルで、何人かの人が家に帰って家のラップトップから「ここで私のためにすべてを美しくする」というスタイルで要求しました。ユーティリティは、システムのHWIDを読み取ることに加えて、レジストリから現在のTeamviewer IDを引き出し、それを私たちに渡しました。 Teamviewerには統合用のAPIがあります。そして、私たちはこの統合を行いました。しかし、問題が1つありました。これらのAPIを介して、ユーザーが明示的にこのセッションを開始していない場合はユーザーのコンピューターに接続できません。接続を試行した後も、ユーザーは「確認」をクリックする必要があります。その瞬間、ユーザーの要求なしに誰も接続するべきではないことは私たちにとって論理的であるように思われました。次に、セッションを開始し、リモート接続の要求に肯定応答します。すべてが間違っていることがわかりました。申請者はセッションの開始を押すのを忘れており、電話でこれを言わなければなりませんでした。これは時間の浪費であり、プロセスの両面で緊張をほぐしました。さらに、アプリケーションを離れるような瞬間はめったにありませんが、彼がランチに出かけるときだけ接続を許可します。問題は重大ではなく、ワークフローの中断を望まないためです。したがって、接続を許可するためにボタンを押すことはありません。そのため、ヘルプデスクの承認中に、TeamviwerのIDを読み取る機能が追加されました。 Teamviwerのインストール時に使用された永続的なパスワードを知っていました。より正確には、彼はインストーラーと私たちのシステムに縫い付けられたので、システムだけが彼を知っていました。したがって、アプリケーションから接続ボタンがあり、クリックすることで何も待つ必要はありませんでしたが、すぐにTeamviewerが開いて接続が発生しました。その結果、可能な接続には2つのタイプがありました。公式のTeamviewer APIと自社製。驚いたことに、最初はほとんどすぐに使用を中止しましたが、特別な場合にのみ使用の指示があり、ユーザー自身が許可したときに使用しました。それにもかかわらず、今セキュリティを与えます。しかし、申請者はこれを必要としないことがわかりました。彼らは皆、確認ボタンなしで接続されていることを絶対に気にしません。その場合、将来、APIを介して接続する機能は不要になるため廃止されました。公式のTeamviewer APIと自社製。驚いたことに、最初はほとんどすぐに使用を中止しましたが、特別な場合にのみ使用の指示があり、ユーザー自身が許可したときに使用しました。それにもかかわらず、今セキュリティを与えます。しかし、申請者はこれを必要としないことがわかりました。彼らは皆、確認ボタンなしで接続されていることを絶対に気にしません。その場合、将来、APIを介して接続する機能は不要になるため廃止されました。公式のTeamviewer APIと自社製。驚いたことに、最初はほとんどすぐに使用を中止しましたが、特別な場合にのみ使用の指示があり、ユーザー自身が許可したときに使用しました。それにもかかわらず、今セキュリティを提供します。しかし、申請者はこれを必要としないことがわかりました。彼らは皆、確認ボタンなしで接続されていることを絶対に気にしません。その場合、将来、APIを介して接続する機能は不要になるため廃止されました。その後、APIを介して接続する機能は、不要になったため削除されました。その後、APIを介して接続する機能は、不要になったため削除されました。</font></font><br>
<br>
<h3>    Linux</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 ポートの所定のリストの開放性とネットワークオブジェクトの単純なpingのためにネットワークスキャナーの通過を加速するという問題は、すでに問題になっています。ここで頭に浮かぶ最初のソリューションはマルチスレッドです。 pingに費やされる主な時間はパケットが戻るのを待つことであり、次のpingは前のパケットが戻るまで開始できないため、20台以上のサーバーとネットワーク機器さえある企業では、これはすでに非常にゆっくりと動作しました。つまり、1つのパッケージが消え、システム管理者にすぐに通知されない可能性があります。彼はそのようなスパムを非常に迅速に知覚するのをやめるだけです。したがって、使用できないと結論付ける前に、各オブジェクトに2回以上pingを実行する必要があります。詳細にあまり触れない場合は、並列化する必要があります。これを行わないと、ほとんどの場合、システム管理者は、監視システムからではなく、クライアントから問題について学習します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHP自体には、マルチスレッド機能はありません。</font><font style="vertical-align: inherit;">マルチプロセスが可能で、フォークできます。</font><font style="vertical-align: inherit;">しかし、実際には、調査メカニズムはすでに作成されており、データベースから必要なすべてのノードを一度に読み取り、すべてを一度にpingし、全員からの回答を待ち、その後すぐにデータを書き込むことができるようにしたかったのです。</font><font style="vertical-align: inherit;">これにより、読み取り要求の数が節約されます。</font><font style="vertical-align: inherit;">マルチスレッドはこのアイデアに完全に適合します。</font><font style="vertical-align: inherit;">PHPの場合、実際のマルチスレッド化を可能にするPThreadsモジュールがありますが、PHP 7.2で構成するために一生懸命作業する必要がありましたが、実際に行われました。</font><font style="vertical-align: inherit;">ポートスキャンとpingが高速になりました。</font><font style="vertical-align: inherit;">代わりに、たとえば、1サークルあたり15秒前に、このプロセスには2秒かかりました。</font><font style="vertical-align: inherit;">良い結果でした。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新会社の迅速な監査</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 鉄のさまざまなメトリックと特性を収集する機能はどのようにして生まれましたか？すべてが簡単です。時々、現在のITインフラストラクチャの監査のみを注文することがあります。まあ、同じことが新しいクライアントの監査を加速するために必要です。彼らは彼らが中規模または大規模の会社に来て、彼らが持っていたものをすぐに見つけることができる何かが必要でした。私の意見では、内部ネットワークのpingは、自分自身が自分の生活を複雑にしたいという人によってのみブロックされ、私たちの経験ではそれらの多くはありません。しかし、そのようなものが見つかりました。したがって、簡単なpingでデバイスのネットワークをすばやくスキャンできます。次に、それらを追加して、関心のある開いているポートをスキャンできます。実際、この機能はすでに存在しており、中央サーバーから下位サーバーにコマンドを追加するだけで、特定のネットワークをスキャンし、見つかったすべてをリストに追加できました。言及し忘れていましたが、監査中にクライアントからロールアウトしてクラウドにフックできる構成済みシステム（スレーブモニタリングサーバー）の既製のイメージがすでにあると想定されていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、監査結果には通常、さまざまな情報が含まれています。その1つは、ネットワーク上にあるデバイスの種類です。まず、ドメインの一部としてWindowsサーバーとWindowsワークステーションに関心がありました。中規模および大規模企業では、ドメインが存在しないことがおそらく例外です。私の意見では、同じ言語を話すには、平均して100人以上です。すべてのWindowsマシンとサーバーからデータを収集する方法を考え出す必要がありました。それらのIPとドメイン管理者アカウントは知っていますが、それぞれにソフトウェアをインストールする必要はありません。 WMIが助けになります。リテラル翻訳のWindows Management Instrumentation（WMI）は、Windows管理ツールキットです。WMIは、Windowsプラットフォームを実行しているコンピューターインフラストラクチャのさまざまな部分を集中管理および監視するためのコアテクノロジの1つです。 wikiから取得。次に、Debian用のwmic（これはWMIクライアントです）を構築するために、もう一度改造する必要がありました。すべての準備が整ったら、必要な情報を得るために必要なノードをwmic経由で問い合わせるだけでした。 WMIを使用すると、Windowsコンピューターからほとんどすべての情報を取得できます。さらに、WMIを使用してコンピューターを制御することもできます。たとえば、コンピューターを再起動に送信できます。したがって、システムにはWindowsステーションとサーバーに関する情報のコレクションがありました。これに対するプラスは、システム負荷の現在のインジケータに関する現在の情報でした。私たちはそれらをより頻繁に要求し、鉄に関する情報はそれほど頻繁ではありません。その後、監査は少し良くなりました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソフトウェア配布の決定</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 私たち自身も毎日システムを使用しており、すべての技術者がいつでも利用できます。</font><font style="vertical-align: inherit;">そして、私たちはすでに持っているものを他の人と共有することができると考えました。</font><font style="vertical-align: inherit;">システムはそれを配布する準備ができていませんでした。</font><font style="vertical-align: inherit;">ローカルバージョンがSaaSになるように、多くの作業をやり直す必要がありました。</font><font style="vertical-align: inherit;">これらは、システムのさまざまな技術的側面（リモート接続、サポートサービス）の変更、およびライセンス供与のためのモジュールの分析、顧客データベースのシャーディング、各サービスのスケーリング、およびすべてのパーツの自動更新システムの開発です。</font><font style="vertical-align: inherit;">しかし、これは記事の後半です。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja504360/index.html">3Dプリンティング、Lego、Arduino、Raspberry Piを使用して顕微鏡を作る </a></li>
<li><a href="../ja504362/index.html">Google Colabに大量のデータをすばやく読み込む</a></li>
<li><a href="../ja504364/index.html">コンピュータは徐々に常識に近づいています</a></li>
<li><a href="../ja504370/index.html">Office 365とMicrosoft Teams-コラボレーションの利便性とセキュリティへの影響</a></li>
<li><a href="../ja504374/index.html">トラバーサルのカウント：JavaScriptを例に使用した単純な単語のディープ検索と幅優先検索</a></li>
<li><a href="../ja504380/index.html">SSD。内部構造とその構築原理</a></li>
<li><a href="../ja504382/index.html">私（PhD Neurobiology）が6か月でデータサイエンティストになった経緯</a></li>
<li><a href="../ja504384/index.html">TypeScriptをReactプロジェクトに徐々に導入する</a></li>
<li><a href="../ja504386/index.html">Vassbotn H.クラス仮想変数</a></li>
<li><a href="../ja504390/index.html">werfを使用した分散CI / CDの編成</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>