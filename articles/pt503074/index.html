<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📭 👩🏾‍🌾 🙅🏻 Detalhes sobre o pacote Provider for Flutter 👀 🔔 🧑🏽‍🤝‍🧑🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! 
 
 Nossos planos de médio prazo incluem o lançamento do livro Flutter. Em relação à linguagem do Dart como tópico, ainda assumimos uma posi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Detalhes sobre o pacote Provider for Flutter</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/503074/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Olá Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nossos planos de médio prazo incluem o lançamento do livro Flutter. </font><font style="vertical-align: inherit;">Em relação à linguagem do Dart como tópico, ainda assumimos uma posição mais cautelosa, portanto, tentaremos avaliar sua relevância de acordo com os resultados deste artigo. </font><font style="vertical-align: inherit;">Ele se concentrará no pacote </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Provider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e, portanto, no gerenciamento de estado no Flutter.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Provider é um pacote de gerenciamento de estado escrito por </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remy Rusle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e adotado pelo Google e pela comunidade Flutter. </font><font style="vertical-align: inherit;">Mas o que é gerenciamento de estado? </font><font style="vertical-align: inherit;">Para iniciantes, o que é uma condição? </font><font style="vertical-align: inherit;">Deixe-me lembrá-lo de que o estado são apenas dados para representar a interface do usuário no seu aplicativo. </font><font style="vertical-align: inherit;">O gerenciamento de estado é uma abordagem para criar esses dados, acessando, manipulando e descartando-os. </font><font style="vertical-align: inherit;">Para entender melhor o pacote do provedor, descrevemos brevemente o histórico do gerenciamento de estado em Flutter.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. StatefulWidget</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StatelessWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é um componente simples da interface do usuário que é exibido apenas quando há dados. Não </font></font><code>StatelessWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">há "memória"; é criado e destruído conforme necessário. O Flutter também possui um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StatefulWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , no qual há uma memória, graças a ele um satélite de longa duração - o objeto </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">State</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Essa classe possui um método </font></font><code>setState()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, quando chamado, é lançado um widget que reconstrói o estado e o exibe em um novo formulário. Essa é a forma mais simples de gerenciamento de estado do Flutter, fornecida imediatamente. Aqui está um exemplo com um botão que sempre exibe a hora em que foi pressionado pela última vez:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyWidget</span>&gt; </span>{
  <span class="hljs-built_in">DateTime</span> _time = <span class="hljs-built_in">DateTime</span>.now();  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(_time.toString()),<font></font>
      onPressed: () {<font></font>
        setState(() =&gt; _time = <span class="hljs-built_in">DateTime</span>.now());<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então, qual é o problema dessa abordagem? </font><font style="vertical-align: inherit;">Suponha que seu aplicativo tenha algum estado global armazenado na raiz </font></font><code>StatefulWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ele contém dados destinados ao uso em várias partes da interface do usuário. </font><font style="vertical-align: inherit;">Esses dados são compartilhados e passados ​​para cada widget filho na forma de parâmetros. </font><font style="vertical-align: inherit;">Quaisquer eventos nos quais se planeja alterar esses dados serão exibidos na forma de retornos de chamada. </font><font style="vertical-align: inherit;">Assim, através de todos os widgets intermediários, muitos parâmetros e retornos de chamada são transmitidos, o que pode levar a confusão em breve. </font><font style="vertical-align: inherit;">Pior, quaisquer atualizações na raiz mencionada anteriormente levarão a uma reconstrução de toda a árvore de widgets, o que é ineficiente.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. InheritedWidget</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InheritedWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é um widget especial cujos descendentes podem acessá-lo sem um link direto. </font><font style="vertical-align: inherit;">Apenas ao voltar para </font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um widget consumidor pode se registrar para uma reconstrução automática, o que ocorrerá ao reconstruir um widget ancestral. </font><font style="vertical-align: inherit;">Essa técnica permite organizar com mais eficiência a atualização da interface do usuário. </font><font style="vertical-align: inherit;">Em vez de reconstruir grandes partes do aplicativo em resposta a uma pequena mudança de estado, você pode selecionar seletivamente apenas os widgets específicos que precisam ser reconstruídos. </font><font style="vertical-align: inherit;">Você já trabalhou </font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sempre que usou </font></font><code>MediaQuery.of(context)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>Theme.of(context)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">É verdade que é menos provável que você tenha implementado seu próprio InheritedWidget com preservação de estado. </font><font style="vertical-align: inherit;">O fato é que implementá-los corretamente não é fácil.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. ScopedModel</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScopedModel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é um pacote criado em 2017 por Brian Egan, que facilita o uso </font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para armazenar o estado do aplicativo. </font><font style="vertical-align: inherit;">Primeiro, você precisa criar um objeto de estado que herda de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e depois chamá- </font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lo quando suas propriedades mudarem. </font><font style="vertical-align: inherit;">A situação é remanescente da implementação da interface </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PropertyChangeListener</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em Java.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Model</span> </span>{<font></font>
  String _foo;  String get foo =&gt; _foo;<font></font>
  <font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> set <span class="hljs-title">foo</span><span class="hljs-params">(String value)</span> </span>{<font></font>
    _foo = value;<font></font>
    notifyListeners();  <font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para fornecer nosso objeto de estado, envolvemos esse objeto em um widget </font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na raiz do nosso aplicativo:</font></font><br>
<br>
<pre><code class="java hljs">ScopedModel&lt;MyModel&gt;(<font></font>
  model: MyModel(),<font></font>
  child: MyApp(...)<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, qualquer </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">widget </font><font style="vertical-align: inherit;">descendente poderá acessar </font><font style="vertical-align: inherit;">usando o widget </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScopedModelDescendant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">A instância do modelo é passada para o parâmetro </font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> ScopedModelDescendant&lt;MyModel&gt;(<font></font>
      builder: (context, child, model) =&gt; Text(model.foo),<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qualquer widget descendente também poderá atualizar o modelo, o que provocará automaticamente uma reconstrução de qualquer </font></font><code>ScopedModelDescendants</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(desde que nosso modelo chame corretamente </font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = ScopedModel.of&lt;MyModel&gt;(context);<font></font>
        model.foo = <span class="hljs-string">'bar'</span>;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br>
<code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ganhou popularidade no Flutter como uma ferramenta para gerenciamento de estado, mas seu uso é limitado ao fornecimento de objetos que herdam a classe </font></font><code>Model</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e usam esse padrão de notificação de alterações.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. BLoC</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na conferência do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google I / O '18</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o </font><font style="vertical-align: inherit;">padrão </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Business Logic Component</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (BLoC) </font><font style="vertical-align: inherit;">foi introduzido </font><font style="vertical-align: inherit;">, que serve como mais uma ferramenta para extrair o estado dos widgets. As classes BLoC são componentes de longa duração que não são da interface do usuário que preservam o estado e o expõem como fluxos e receptores. Levando a lógica de estado e de negócios além da interface do usuário, você pode implementar o widget como simples </font></font><code>StatelessWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e usar o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamBuilder</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para reconstrução automática. Como resultado, o widget "fica burro" e fica mais fácil testar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exemplo de classe BLoC:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBloc</span> </span>{
  <span class="hljs-keyword">final</span> _controller = StreamController&lt;MyType&gt;();  Stream&lt;MyType&gt; <span class="hljs-keyword">get</span> stream =&gt; _controller.stream;<font></font>
  StreamSink&lt;MyType&gt; <span class="hljs-keyword">get</span> sink =&gt; _controller.sink;<font></font>
  <font></font>
  myMethod() {<font></font>
    <span class="hljs-comment">//  </span><font></font>
    sink.add(foo);<font></font>
  }  dispose() {<font></font>
    _controller.close();<font></font>
  }<font></font>
}<font></font>
 ,   BLoC:<font></font>
<span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context) {<font></font>
 <span class="hljs-keyword">return</span> StreamBuilder&lt;MyType&gt;(<font></font>
  stream: myBloc.stream,<font></font>
  builder: (context, asyncSnapshot) {<font></font>
    <span class="hljs-comment">//  </span><font></font>
 });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O problema com o padrão BLoC é que não é óbvio como criar e destruir objetos BLoC. </font><font style="vertical-align: inherit;">Como a instância foi criada </font></font><code>myBloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no exemplo acima? </font><font style="vertical-align: inherit;">Como ligamos </font></font><code>dispose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para nos livrar dele? </font><font style="vertical-align: inherit;">Os fluxos requerem uso </font></font><code>StreamController</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que deve ser </font></font><code>closed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assim que se tornar desnecessário - isso é feito para evitar vazamentos de memória. </font><font style="vertical-align: inherit;">(Não existe tal coisa como um destruidor de classe no dardo; apenas uma classe </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no </font></font><code>StatefulWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tem um método </font></font><code>dispose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Além disso, não está claro como compartilhar esse BLoC entre vários widgets. </font><font style="vertical-align: inherit;">Geralmente, é difícil para os desenvolvedores dominar o BLoC. </font><font style="vertical-align: inherit;">Existem vários pacotes que tentam simplificar isso.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Fornecedor</font></font></h4><br>
<code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">É um pacote escrito em 2018 por Remy Rusle, semelhante a </font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas cujas funções não se limitam a, fornecendo uma subclasse de Model. Esse também é um wrapper que é concluído </font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas o provedor pode fornecer qualquer objeto de estado, incluindo BLoC, fluxos, futuros e outros. Como o provedor é tão simples e flexível, o Google anunciou na </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conferência Google I / O '19</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que no futuro </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">será o pacote preferido para gerenciar o estado. Claro, outros pacotes também são permitidos, mas se você tiver alguma dúvida, o Google recomenda parar </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">construído "com widgets, para widgets".</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permite colocar qualquer objeto com um estado na árvore de widgets e abrir acesso a ele para qualquer outro widget (filho). </font><font style="vertical-align: inherit;">Ele também </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajuda a gerenciar a vida útil dos objetos de estado, inicializando-os com dados e executando uma limpeza após a remoção da árvore de widgets. </font><font style="vertical-align: inherit;">Portanto, </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é adequado mesmo para a implementação de componentes BLoC ou pode servir de base para outras soluções de gerenciamento de estado! </font><font style="vertical-align: inherit;">Ou simplesmente usado para </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementar dependências</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - um termo sofisticado que significa transferir dados para widgets de uma maneira que permita que você afrouxe a conexão e melhore a testabilidade do código. </font><font style="vertical-align: inherit;">Finalmente,</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vem com um conjunto de aulas especializadas, graças às quais é ainda mais conveniente de usar. </font><font style="vertical-align: inherit;">A seguir, examinaremos mais de perto cada uma dessas classes.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fornecedor básico</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChangeNotifierProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Futureprovider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenableProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MultiProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proxyprovider</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instalação</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para usá-lo </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, primeiro adicione uma dependência ao nosso arquivo </font></font><code>pubspec.yaml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<code>provider: ^3.0.0</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois importamos o pacote </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onde for necessário: </font></font><br>
<br>
<code>import 'package:provider/provider.dart';</code><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Provedor de base</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Crie a base </font></font><code>Provide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r na raiz do nosso aplicativo; </font><font style="vertical-align: inherit;">isso conterá uma instância do nosso modelo:</font></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: MyApp(...),<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O parâmetro </font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cria uma instância </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se você deseja passar uma instância existente para ela, use o construtor aqui </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Provider.value</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, você pode consumir esta instância do modelo em qualquer lugar </font></font><code>MyApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, usando o widget </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> Consumer&lt;MyModel&gt;(<font></font>
      builder: (context, value, child) =&gt; Text(value.foo),<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No exemplo acima, a classe </font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obtém uma instância </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usando o widget </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consumidor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Este elemento nos dá </font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contendo nosso objeto no parâmetro </font></font><code>value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, o que devemos fazer se quisermos atualizar os dados em nosso modelo? Digamos que temos outro widget em que, quando um botão é clicado, a propriedade deve ser atualizada </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);<font></font>
        model.foo = <span class="hljs-string">'bar'</span>;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe a sintaxe específica usada para acessar a instância </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Funcionalmente, isso é equivalente a acessar o widget </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O widget </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é útil nos casos em que o código não pode obter facilmente o link </font></font><code>BuildContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que você acha que acontecerá com o widget original </font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que criamos anteriormente? Um novo significado será exibido nele </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente não</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Não é possível ouvir alterações em objetos antigos antigos do Dart (pelo menos sem reflexão, o que não é fornecido no Flutter). Portanto, </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não será possível "ver" que atualizamos corretamente a propriedade </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e solicitamos que o widget seja </font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atualizado em resposta. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChangeNotifierProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas há esperança! </font><font style="vertical-align: inherit;">Você pode fazer nossa classe </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementar uma impureza </font></font><code>ChangeNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Demorará um pouco para alterar a implementação do nosso modelo e chamar um método especial </font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sempre que uma de nossas propriedades for alterada. </font><font style="vertical-align: inherit;">Funciona aproximadamente da mesma maneira </font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas, nesse caso, é bom que você não precise herdar de uma classe de modelo específica. </font><font style="vertical-align: inherit;">É o suficiente para perceber a mistura </font></font><code>ChangeNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aqui está o que parece:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> <span class="hljs-title">with</span> <span class="hljs-title">ChangeNotifier</span> </span>{
  <span class="hljs-built_in">String</span> _foo;  <span class="hljs-built_in">String</span> <span class="hljs-keyword">get</span> foo =&gt; _foo;<font></font>
  <font></font>
  <span class="hljs-keyword">void</span> <span class="hljs-keyword">set</span> foo(<span class="hljs-built_in">String</span> value) {<font></font>
    _foo = value;<font></font>
    notifyListeners();  <font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você pode ver, substituímos nossa propriedade </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>getter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>setter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, apoiada pela variável privada _foo. </font><font style="vertical-align: inherit;">Dessa forma, podemos "interceptar" quaisquer alterações feitas na propriedade foo e informar nossos ouvintes que nosso objeto mudou. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, de fora </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, podemos mudar nossa implementação para que ela use uma classe diferente chamada </font></font><code> ChangeNotifierProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs">ChangeNotifierProvider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: MyApp(...),<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como isso! </font><font style="vertical-align: inherit;">Agora, quando nossas </font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atualizações da propriedade </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na instância </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, elas </font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serão atualizadas automaticamente para refletir essa alteração. </font><font style="vertical-align: inherit;">Legal certo? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A propósito. </font><font style="vertical-align: inherit;">Você provavelmente notou um manipulador de botão </font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com o qual usamos a seguinte sintaxe:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por padrão, essa sintaxe fará com que a instância seja reconstruída automaticamente </font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assim que o modelo for alterado </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Talvez não precisemos disso. </font><font style="vertical-align: inherit;">No final, ele </font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplesmente contém um botão que não muda quando o valor muda </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para evitar a reconstrução, você pode usar a seguinte sintaxe para acessar nosso modelo sem se registrar na reconstrução:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context, listen: <span class="hljs-keyword">false</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse é outro encanto fornecido no pacote </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exatamente assim. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
À primeira vista, não está claro por que é necessário </font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No final, você pode usar o habitual </font></font><code>StreamBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se precisar consumir um fluxo no Flutter. </font><font style="vertical-align: inherit;">Por exemplo, aqui ouvimos o fluxo </font></font><code>onAuthStateChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornecido por </font></font><code>FirebaseAuth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context {<font></font>
  <span class="hljs-keyword">return</span> StreamBuilder(<font></font>
   stream: FirebaseAuth.instance.onAuthStateChanged, <font></font>
   builder: (BuildContext context, AsyncSnapshot snapshot){ <font></font>
     ...<font></font>
   });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para fazer o mesmo com a ajuda </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, poderíamos fornecer nosso fluxo </font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na raiz do nosso aplicativo:</font></font><br>
<br>
<pre><code class="dart hljs">StreamProvider&lt;FirebaseUser&gt;.value(<font></font>
  stream: FirebaseAuth.instance.onAuthStateChanged,<font></font>
  child: MyApp(...),<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, consuma o widget filho, como geralmente é feito com </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context) {<font></font>
  <span class="hljs-keyword">return</span> Consumer&lt;FirebaseUser&gt;(<font></font>
    builder: (context, value, child) =&gt; Text(value.displayName),<font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nosso código de widget não apenas se tornou muito mais limpo, como também abstrai o fato de que os dados vieram do fluxo. Se algum dia decidirmos alterar a implementação base, por exemplo, para </font></font><code>FutureProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, então nenhuma alteração no código do widget será necessária. Como você verá, isso se aplica a todos os outros provedores mostrados abaixo. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FutureProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Semelhante ao exemplo acima, </font></font><code>FutureProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é uma alternativa ao padrão </font></font><code> FutureBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ao trabalhar com widgets. Aqui está um exemplo:</font></font><br>
<br>
<pre><code class="plaintext hljs">FutureProvider&lt;FirebaseUser&gt;.value(<font></font>
  value: FirebaseAuth.instance.currentUser(),<font></font>
  child: MyApp(...),<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para consumir esse valor no widget filho, usamos a mesma implementação </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que no exemplo </font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acima. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenableProvider </font></font></i><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é uma interface Dart implementada pela classe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueNotifier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que pega um valor e notifica os ouvintes quando muda para outro valor. </font><font style="vertical-align: inherit;">É possível, por exemplo, agrupar um contador inteiro em uma classe de modelo simples:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> </span>{
  <span class="hljs-keyword">final</span> ValueNotifier&lt;<span class="hljs-built_in">int</span>&gt; counter = ValueNotifier(<span class="hljs-number">0</span>);  <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao trabalhar com tipos complexos, ele </font></font><code>ValueNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usa o operador do </font></font><code>==</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objeto armazenado nele para determinar se o valor foi alterado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos criar o mais simples </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que conterá o nosso modelo principal, e será seguido por uma </font><font style="vertical-align: inherit;">propriedade de escuta </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aninhada </font><font style="vertical-align: inherit;">:</font></font><code>ValueListenableProvider</code><font style="vertical-align: inherit;"></font><code>counter</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: Consumer&lt;MyModel&gt;(builder: (context, value, child) {<font></font>
    <span class="hljs-keyword">return</span> ValueListenableProvider&lt;<span class="hljs-built_in">int</span>&gt;.value(<font></font>
      value: value.counter,<font></font>
      child: MyApp(...)<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que esse provedor aninhado é do tipo </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pode haver outros. </font><font style="vertical-align: inherit;">Se você tiver vários provedores do mesmo tipo registrados, o Provedor retornará o “mais próximo” (ancestral mais próximo). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veja como ouvir uma propriedade </font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de qualquer widget filho:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> Consumer&lt;<span class="hljs-built_in">int</span>&gt;(<font></font>
      builder: (context, value, child) {<font></font>
        <span class="hljs-keyword">return</span> Text(value.toString());<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas aqui está como atualizar uma propriedade </font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de outro widget. </font><font style="vertical-align: inherit;">Atenção: precisamos acessar a cópia original </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);<font></font>
        model.counter.value++;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MultiProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Se você usa muitos widgets</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, na raiz do aplicativo você obtém uma estrutura feia de muitos anexos:</font></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;Foo&gt;.value( <font></font>
  value: foo, <font></font>
  child: Provider&lt;Bar&gt;.value( <font></font>
    value: bar, <font></font>
    child: Provider&lt;Baz&gt;.value( <font></font>
      value: baz , <font></font>
      child: MyApp(...)<font></font>
    ) <font></font>
  ) <font></font>
)</code></pre><br>
<code>MultiProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permite declarar todos eles no mesmo nível. </font><font style="vertical-align: inherit;">É apenas açúcar sintático: no nível intra-sistema, todos permanecem aninhados de qualquer maneira.</font></font><br>
<br>
<pre><code class="dart hljs">MultiProvider( <font></font>
  providers: [ <font></font>
    Provider&lt;Foo&gt;.value(value: foo), <font></font>
    Provider&lt;Bar&gt;.value(value: bar), <font></font>
    Provider&lt;Baz&gt;.value(value: baz), <font></font>
  ], <font></font>
  child: MyApp(...), <font></font>
)<font></font>
</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProxyProvider</font></font></i></a><br>
<br>
<code>ProxyProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é uma classe interessante adicionada na terceira versão do pacote</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ele permite que você declare fornecedores que podem depender de outros fornecedores, até seis em um. </font><font style="vertical-align: inherit;">Neste exemplo, a classe Bar é específica da instância</font></font><code>Foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso é útil ao compilar um conjunto raiz de serviços que dependem um do outro.</font></font><br>
<br>
<pre><code class="dart hljs">MultiProvider ( <font></font>
  providers: [ <font></font>
    Provider&lt;Foo&gt; ( <font></font>
      builder: (context) =&gt; Foo(),<font></font>
    ), <font></font>
    ProxyProvider&lt;Foo, Bar&gt;(<font></font>
      builder: (context, value, previous) =&gt; Bar(value),<font></font>
    ), <font></font>
  ], <font></font>
  child: MyApp(...),<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O primeiro argumento de tipo genérico é o tipo do qual o seu depende </font></font><code>ProxyProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e o segundo é o tipo que ele retorna.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ouvir muitos provedores ao mesmo tempo</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E se quisermos que um único widget escute muitos provedores e reconstrua-os quando algum deles mudar? </font><font style="vertical-align: inherit;">Você pode ouvir até 6 fornecedores ao mesmo tempo usando as opções do widget </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Receberemos instâncias como parâmetros de método adicionais </font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="dart hljs">Consumer2&lt;MyModel, <span class="hljs-built_in">int</span>&gt;(<font></font>
  builder: (context, value, value2, child) {<font></font>
    <span class="hljs-comment">//value  MyModel</span>
    <span class="hljs-comment">//value2  int</span><font></font>
  },<font></font>
);</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusão</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando usado, </font></font><code>InheritedWidget</code> <code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permite gerenciar o estado como é habitual no Flutter. </font><font style="vertical-align: inherit;">Ele permite que os widgets acessem objetos de estado e os ouçam de maneira que o mecanismo de notificação subjacente seja abstraído. </font><font style="vertical-align: inherit;">É mais fácil gerenciar a vida útil dos objetos de estado criando pontos de ancoragem para criar esses objetos conforme necessário e se livrar deles quando necessário. </font><font style="vertical-align: inherit;">Esse mecanismo pode ser usado para implementar facilmente dependências e até como base para opções de gerenciamento de estado mais avançadas. </font><font style="vertical-align: inherit;">Com a bênção do Google e o crescente apoio da comunidade Flutter, </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tornou-se um pacote que vale a pena tentar sem demora!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt503062/index.html">Реальная стоимость жизни в Кремниевой Долине для разработчика</a></li>
<li><a href="../pt503064/index.html">IoT onde você não esperou (parte 3). Construindo um modelo de simulação</a></li>
<li><a href="../pt503068/index.html">Na encruzilhada entre tecnologia e negócios: líderes de TI abrem uma nova universidade na Suíça</a></li>
<li><a href="../pt503070/index.html">Caneca elétrica. Construindo uma scooter elétrica louca / bicicleta elétrica</a></li>
<li><a href="../pt503072/index.html">Apenas mais uma ferramenta: conhecer a configuração do serviço com a Configuração do estado desejado </a></li>
<li><a href="../pt503082/index.html">Telegrama como NAS / FTP</a></li>
<li><a href="../pt503084/index.html">Revisão do Curso Lightbend Academy - Arquitetura Reativa</a></li>
<li><a href="../pt503086/index.html">Os serviços de transcrição online são seguros e confidenciais?</a></li>
<li><a href="../pt503088/index.html">Como selecionamos carga para transportadoras</a></li>
<li><a href="../pt503096/index.html">Por que os gerentes querem que os trabalhadores reciclem?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>