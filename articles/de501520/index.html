<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👴🏿 📱 💨 C # 8 und Nullgültigkeit. Wie leben wir damit? 📰 🔻 🔋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Kollegen! Es ist Zeit zu erwähnen, dass wir Pläne haben, Ian Griffiths ' grundlegendes Buch über C # 8 zu veröffentlichen:
 
 
 In der Zwischenz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C # 8 und Nullgültigkeit. Wie leben wir damit?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/501520/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Kollegen! </font><font style="vertical-align: inherit;">Es ist Zeit zu erwähnen, dass wir Pläne haben, </font><font style="vertical-align: inherit;">Ian Griffiths ' </font><font style="vertical-align: inherit;">grundlegendes </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> über C # 8 zu veröffentlichen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/iw/to/l-/iwtol-20o3gyqy1ppgnewp68giw.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Zwischenzeit hat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Autor </font><font style="vertical-align: inherit;">in seinem </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Blog </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwandte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel veröffentlicht,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in denen er die Feinheiten neuer Phänomene wie Nullbarkeit, Null-Unwissenheit und Null-Bewusstsein betrachtet. </font><font style="vertical-align: inherit;">Wir haben beide Artikel unter einer Überschrift übersetzt und schlagen vor, sie zu diskutieren.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ehrgeizigste neue Funktion in C # 8.0 heißt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullbare Referenzen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Zweck dieser neuen Funktion ist es, den Schaden durch eine gefährliche Sache auszugleichen, die der Informatiker Tony Hoar einst als " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Milliarden-Dollar-Fehler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " bezeichnete. </font><font style="vertical-align: inherit;">C # hat ein Schlüsselwort</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(das Äquivalent davon findet sich in vielen anderen Sprachen), und die Wurzeln dieses Schlüsselworts lassen sich auf die Sprache Algol W zurückführen, an deren Entwicklung Hoar beteiligt war. In dieser alten Sprache (sie erschien 1966) könnten Variablen, die sich auf Instanzen eines bestimmten Typs beziehen, eine besondere Bedeutung erhalten, die darauf hinweist, dass diese Variable derzeit nirgends referenziert wird. Diese Gelegenheit wurde sehr häufig genutzt, und heute glauben viele Experten (einschließlich Hoar selbst), dass sie zur größten Quelle kostspieliger Softwarefehler aller Zeiten geworden ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist falsch daran, Null anzunehmen? In einer Welt, in der ein Link auf Null zeigen kann, müssen Sie dies überall dort berücksichtigen, wo Links in Ihrem Code verwendet werden. Andernfalls besteht die Gefahr, dass Sie zur Laufzeit abgelehnt werden. Manchmal ist es nicht zu lästig. Wenn Sie eine Variable mit einem Ausdruck </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an derselben Stelle </font><font style="vertical-align: inherit;">initialisieren, </font><font style="vertical-align: inherit;">an der Sie sie deklarieren, wissen Sie, dass diese Variable ungleich Null ist. Aber selbst ein so einfaches Beispiel ist mit einer gewissen kognitiven Belastung behaftet: Vor der Veröffentlichung von C # 8 konnte der Compiler Ihnen nicht sagen, ob Sie etwas tun, in das dieser Wert konvertiert werden kann </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sobald Sie jedoch verschiedene Codefragmente zusammenfügen, wird es viel schwieriger, solche Dinge mit Sicherheit zu beurteilen: Wie wahrscheinlich ist es, dass diese Eigenschaft, die ich gerade lese, zurückkehren kann </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Darf es senden?</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in diese Methode? In welchen Situationen kann ich sicher sein, dass die von mir aufgerufene Methode dieses Argument </font></font><code>out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht auf </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sondern auf einen anderen Wert setzt? Darüber hinaus beschränkt sich die Angelegenheit nicht einmal darauf, sich daran zu erinnern, solche Dinge zu überprüfen; Es ist nicht ganz klar, was Sie tun sollen, wenn Sie auf Null stoßen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei numerischen Typen in C # gibt es kein solches Problem: Wenn Sie eine Funktion schreiben, die einige Zahlen als Eingabe verwendet und als Ergebnis eine Zahl zurückgibt, müssen Sie sich nicht fragen, ob die übertragenen Werte wirklich Zahlen sind und ob irgendetwas unter ihnen verwechselt werden kann. Wenn Sie eine solche Funktion aufrufen, müssen Sie nicht darüber nachdenken, ob sie anstelle einer Zahl etwas zurückgeben kann. Es sei denn, eine solche Entwicklung von Ereignissen interessiert Sie als Option: In diesem Fall können Sie Parameter oder Ergebnisse des Typs deklarieren</font></font><code>int?</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies zeigt an, dass Sie in diesem speziellen Fall wirklich die Übertragung oder Rückgabe eines Nullwerts zulassen möchten. Für numerische Typen und allgemeiner für signifikante Typen war die Nulltoleranz immer eines der Dinge, die als Option freiwillig durchgeführt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei den Referenztypen wurde vor C # 8.0 die Zulässigkeit von Null nicht nur standardmäßig festgelegt, sondern konnte auch nicht deaktiviert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus Gründen der Abwärtskompatibilität wird die Gültigkeit von Null auch in C # 8.0 standardmäßig fortgesetzt, da neue Sprachfunktionen in diesem Bereich deaktiviert bleiben, bis Sie sie explizit anfordern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobald Sie diese neue Funktion aktivieren, ändert sich jedoch alles. Der einfachste Weg, es zu aktivieren, besteht darin, es </font></font><code>&lt;Nullablegt;enable&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">innerhalb des Elements </font><font style="vertical-align: inherit;">hinzuzufügen </font><font style="vertical-align: inherit;">.</font></font><code>&lt;PropertyGroup&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Ihrer Datei </font></font><code>.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. (Ich stelle fest, dass auch mehr filigrane Steuerung verfügbar ist. Wenn Sie sie wirklich wirklich benötigen, können Sie das Verhalten so konfigurieren, dass es </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in jeder Zeile separat </font><font style="vertical-align: inherit;">zulässig </font><font style="vertical-align: inherit;">ist. Als wir uns kürzlich entschieden haben, diese Funktion in alle unsere Projekte aufzunehmen, stellte sich heraus, dass sie in einem Maßstab aktiviert wird Ein Projekt zu einem Zeitpunkt ist eine machbare Aufgabe.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die zulässigen Links in C # 8.0 </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vollständig aktiviert sind, ändert sich die Situation: Standardmäßig wird jetzt angenommen, dass die Links nur dann keine Null zulassen, wenn Sie selbst nicht das Gegenteil angeben, genau wie bei signifikanten Typen ( Sogar die Syntax ist dieselbe: Sie könnten int? schreiben, wenn Sie wirklich wollten, dass der ganzzahlige Wert optional ist. Jetzt schreiben Sie Zeichenfolge?, wenn Sie meinen, dass Sie entweder eine Zeichenfolgenreferenz oder möchten</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist eine sehr bedeutende Änderung, und vor allem ist diese neue Funktion aufgrund ihrer Bedeutung standardmäßig deaktiviert. Microsoft hätte diese Sprachfunktion anders gestalten können: Sie könnten die Standardlinks auf Null setzen und eine neue Syntax einführen, mit der Sie angeben können, dass Sie sicherstellen möchten, dass dies nicht zulässig ist </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Vielleicht würde dies die Messlatte senken, wenn diese Möglichkeit untersucht wird, aber auf lange Sicht wäre eine solche Lösung falsch, da in der Praxis die meisten Links in der riesigen Masse an C # -Code nicht darauf ausgelegt sind, darauf hinzuweisen </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, Null ist eine Ausnahme, keine Regel. Wenn diese neue Sprachfunktion aktiviert ist, wird das Verhindern von Null zu einem neuen Standard. Dies spiegelt sich auch im ursprünglichen Funktionsnamen wider: "nullfähige Referenzen". Der Name ist merkwürdig, da Links </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf C # 1.0 </font><font style="vertical-align: inherit;">verweisen könnten </font><font style="vertical-align: inherit;">. Die Entwickler haben jedoch betont, dass die Nullannahme nun in die Kategorie der Dinge fällt, die explizit angefordert werden müssen. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C # 8.0 vereinfacht das Einführen zulässiger Links </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da Sie diese Funktion schrittweise einführen können. Man muss keine Ja- oder Nein-Wahl treffen. Dies unterscheidet sich erheblich von der </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in C # 5.0 hinzugefügten </font><font style="vertical-align: inherit;">Funktion </font><font style="vertical-align: inherit;">, die sich tendenziell ausbreitet: Tatsächlich verpflichten asynchrone Vorgänge den Anrufer dazu</font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher muss sich der Code, der diesen Aufrufer aufruft </font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, usw. ganz oben im Stapel befinden. Glücklicherweise sind Typen, die dies zulassen, </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unterschiedlich aufgebaut: Sie können selektiv und schrittweise implementiert werden. Sie können die Dateien einzeln oder bei Bedarf sogar zeilenweise durcharbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der wichtigste Aspekt der zulässigen Typen</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dank dessen der Übergang zu ihnen vereinfacht wird), ist, dass sie standardmäßig deaktiviert sind. Andernfalls würden die meisten Entwickler die Verwendung von C # 8.0 ablehnen, da ein solcher Übergang in fast jeder Codebasis Warnungen verursachen würde. Aus den gleichen Gründen ist der Einstiegsschwellenwert für die Verwendung dieser neuen Funktion jedoch ziemlich hoch: Wenn eine neue Funktion so dramatische Änderungen vornimmt, dass sie standardmäßig deaktiviert ist, möchten Sie sich wahrscheinlich nicht damit anlegen, aber es gibt Probleme beim Umschalten wird immer unnötig Ärger erscheinen. Aber das wäre eine Schande, denn die Funktion ist sehr wertvoll. Es ist hilfreich, Fehler im Code zu finden, bevor Benutzer dies für Sie tun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie also überlegen, Typen einzuführen, die dies zulassen</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie unbedingt, dass Sie diese Funktion Schritt für Schritt einführen können. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur Warnungen</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Die gröbste Kontrolle über das gesamte Projekt nach einem einfachen Ein- / Ausschalten ist die Möglichkeit, Warnungen unabhängig von Anmerkungen zu aktivieren. Wenn ich beispielsweise die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nullannahme</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Corvus.ContentHandling.Json</font></a><font style="vertical-align: inherit;"> in unserem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corvus.ContentHandling-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Repository </font><font style="vertical-align: inherit;">vollständig aktiviere </font><font style="vertical-align: inherit;">und </font></font><code>&lt;Nullablegt;enable&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Gruppe von Eigenschaften in der Projektdatei </font><font style="vertical-align: inherit;">hinzufüge </font><font style="vertical-align: inherit;">, werden in ihrem aktuellen Status sofort 20 Warnungen vom Compiler </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">angezeigt</font></a><font style="vertical-align: inherit;"> . Wenn ich es stattdessen verwende, </font></font><code>&lt;Nullablegt;warnings&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erhalte </font><font style="vertical-align: inherit;">ich </font><font style="vertical-align: inherit;">nur eine Warnung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber warte! Warum werden mir weniger Warnungen angezeigt? Am Ende habe ich hier nur um Warnungen gebeten. Die Antwort auf diese Frage ist nicht ganz offensichtlich: Tatsache ist, dass einige Variablen und Ausdrücke </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null-ahnungslos sein können. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nullneutralität</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
C # unterstützt zwei Interpretationen der Nullgültigkeit. Erstens kann jede Variable eines Referenztyps als zulassend oder nicht zulassend deklariert werden </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und zweitens wird der Compiler nach Möglichkeit logisch schließen, ob sich diese Variable </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an einem bestimmten Punkt im Code befinden </font><font style="vertical-align: inherit;">kann oder nicht </font><font style="vertical-align: inherit;">. Dieser Artikel befasst sich nur mit der ersten Art der Zulässigkeit</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dh über den statischen Typ einer Variablen (tatsächlich gilt dies nicht nur für Variablen und Parameter und Felder, die ihnen im Geiste nahe stehen; sowohl statische als auch logisch ableitbare Zulässigkeit werden </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für jeden Ausdruck in C # bestimmt.) Tatsächlich ist Zulässigkeit </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in ihrem ersten Sinne Das, was wir in Betracht ziehen, ist eine Erweiterung des Typsystems. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich jedoch heraus, dass die Situation nicht so kohärent ist, wie man annehmen könnte, wenn wir uns nur auf die Nullzulässigkeit für einen Typ konzentrieren. Dies ist nicht nur ein Kontrast zwischen "null Gültigkeit" und "ungültig"</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". In der Tat gibt es zwei weitere Möglichkeiten. Es gibt eine Kategorie von „unbekannt“, die aufgrund der Verfügbarkeit von Generika obligatorisch ist. Wenn Sie einen unbegrenzten Typparameter haben, können Sie nichts über die Gültigkeit herausfinden </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Code, der die entsprechende verallgemeinerte Methode oder den Typ verwendet, kann ein Argument in ihnen ersetzen, das entweder zulässt oder nicht zulässt </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie können Einschränkungen hinzufügen, aber häufig sind solche Einschränkungen unerwünscht, da sie den Umfang des verallgemeinerten Typs oder der verallgemeinerten Methode einschränken. Für Variablen oder Ausdrücke eines unbegrenzten Typparameters muss die </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Nicht-) Gültigkeit von Null unbekannt sein. vielleicht in jedem Fall die Frage der Zulässigkeit</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird separat für sie entschieden, aber wir wissen nicht, welche Option im generischen Code angezeigt wird, da dies vom Typargument abhängt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die letztere Kategorie wird als "neutral" bezeichnet. Nach dem Prinzip der "Neutralität" hat alles vor dem Aufkommen von C # 8.0 funktioniert, und dies funktioniert, wenn Sie die Fähigkeit zum Arbeiten mit nullbaren Links nicht aktivieren. (Grundsätzlich ist dies ein Beispiel für </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rückwirkung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Obwohl die Idee der Nullneutralität erstmals in C # 8.0 als natürlicher Codezustand eingeführt wurde, bevor die Nullgültigkeit für Referenzen aktiviert wurde, bestanden C # -Designer darauf, dass diese Eigenschaft C # nie wirklich fremd war.)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielleicht müssen Sie nicht erklären, was "Neutralität" in diesem Fall bedeutet, da C # in diesem Sinne immer funktioniert hat, sodass Sie selbst alles verstehen ... obwohl dies vielleicht etwas unehrlich ist. Hören Sie also zu: In einer Welt, in der es um Zulässigkeit geht </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ist das wichtigste Merkmal von </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutralen Ausdrücken, dass sie keine Warnungen vor Nullakzeptanz auslösen. Sie können einen nullneutralen Ausdruck als zulässige </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber nicht zulässige Variable </font><font style="vertical-align: inherit;">zuweisen </font><font style="vertical-align: inherit;">. </font></font><code>Null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-neutrale Variablen (sowie Eigenschaften, Felder usw.) können Sie Ausdrücke zuweisen, die der Compiler als "möglich </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" oder "nicht </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" angesehen hat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie nur Warnungen aktivieren, gibt es deshalb nicht so viele neue Warnungen. Der gesamte Code verbleibt im Kontext deaktivierter Gültigkeitsanmerkungen </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sodass alle Variablen, Parameter, Felder und Eigenschaften </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutral sind. Dies bedeutet, dass Sie keine Warnungen erhalten, wenn Sie versuchen, sie in Verbindung mit Entitäten zu verwenden, die dies berücksichtigen </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum bekomme ich dann überhaupt Warnungen? Ein häufiger Grund ist der Versuch, auf inakzeptable Weise Freunde zu finden, die zwei Codeteile berücksichtigen </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Angenommen, ich habe eine Bibliothek, in der zulässige Links vollständig enthalten sind </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und diese Bibliothek verfügt über die folgende tief erfundene Klasse:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NullableAwareClass</span><font></font>
	{<font></font>
	    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">string</span>? GetNullable() =&gt; DateTime.Now.Hour &gt; <span class="hljs-number">12</span> ? <span class="hljs-literal">null</span> : <span class="hljs-string">"morning"</span>;<font></font>
	<font></font>
<font></font>
	    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">RequireNonNull</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> s</span>)</span> =&gt; s.Length;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Außerdem kann ich in einem anderen Projekt diesen Code in dem Kontext schreiben, in dem Nullgültigkeitswarnungen aktiviert sind, die entsprechenden Anmerkungen jedoch deaktiviert sind: </font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">UseString</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> x</span>)</span> =&gt; NullableAwareClass.RequireNonNull(x);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da Anmerkungen zur Nullgültigkeit deaktiviert sind, ist der Parameter </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutral. </font><font style="vertical-align: inherit;">Dies bedeutet, dass der Compiler nicht feststellen kann, ob dieser Code wahr ist oder nicht. </font><font style="vertical-align: inherit;">Wenn der Compiler Warnungen in Fällen ausgibt, in denen </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutrale Ausdrücke mit denen gemischt werden, die dies berücksichtigen </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kann ein erheblicher Teil dieser Warnungen als zweifelhaft angesehen werden. Daher werden keine Warnungen ausgegeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit diesem Wrapper habe ich tatsächlich die Tatsache versteckt, dass der Code die Gültigkeit berücksichtigt </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das heißt, jetzt kann ich so schreiben:</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">int</span> x = UseString(NullableAwareClass.GetNullable());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Compiler weiß, was er zurückgeben </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber da ich die Methode mit einem nullneutralen Parameter aufgerufen habe, weiß das Programm nicht, ob dies richtig oder falsch ist. Mit dem </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-neutralen Wrapper habe ich den Compiler deaktiviert, der hier jetzt kein Problem mehr sieht. Wenn ich diese beiden Methoden jedoch direkt kombinieren würde, wäre alles anders:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">int</span> y = NullableAwareClass.RequireNonNull(NullableAwareClass.GetNullable());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier übergebe ich das Ergebnis </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direkt an </font></font><code>RequireNonNull</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn ich dies in einem Kontext versuchen würde, in dem Nullannahmen aktiviert sind, würde der Compiler eine Warnung generieren, unabhängig davon, ob ich den Kontext der entsprechenden Anmerkungen aktiviert oder deaktiviert habe. In diesem speziellen Fall spielt der Kontext von Anmerkungen keine Rolle, da es keine Deklarationen mit einem Referenztyp gibt. Wenn Sie Warnungen bezüglich der Annahme von Null aktivieren, aber die entsprechenden Anmerkungen deaktivieren, werden alle Deklarationen </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutral, was jedoch nicht bedeutet, dass alle Ausdrücke solche werden. Wir wissen also, dass das Ergebnis </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null ist. Daher erhalten wir eine Warnung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusammenfassend: da alle Deklarationen im Kontext von deaktivierten Annotationen, die dies zulassen, </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sind</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-neutral, wir werden nicht viele Warnungen erhalten, da die meisten Ausdrücke </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-neutral sind. Der Compiler kann jedoch weiterhin Fehler im Zusammenhang mit der Annahme </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in den Fällen </font><font style="vertical-align: inherit;">abfangen, </font><font style="vertical-align: inherit;">in denen die Ausdrücke keinen nullneutralen Intermediär durchlaufen. Darüber hinaus besteht der größte Vorteil in diesem Fall darin, Fehler zu erkennen, die mit Versuchen verbunden sind, potenzielle Nullwerte zu dereferenzieren, indem </font></font><code>.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beispielsweise verwendet wird:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">int</span> z = NullableAwareClass.GetNullable().Length;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihr Code gut gestaltet ist, sollte es keine große Anzahl solcher Fehler geben. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schrittweise Annotation des gesamten Projekts</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nachdem Sie den ersten Schritt ausgeführt haben, aktivieren Sie einfach die Warnungen und fahren Sie mit der schrittweisen Aktivierung der Annotationen Datei für Datei fort. Es ist praktisch, sie sofort in das gesamte Projekt aufzunehmen, zu sehen, in welchen Dateien Warnungen angezeigt werden, und dann eine Datei auszuwählen, in der relativ wenige Warnungen vorhanden sind. Deaktivieren Sie sie erneut auf der Ebene des gesamten Projekts und schreiben Sie oben in die ausgewählte Datei </font></font><code>#nullable enable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dadurch wird die Annahme </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(sowohl für Warnungen als auch für Anmerkungen) in der gesamten Datei </font><font style="vertical-align: inherit;">vollständig aktiviert </font><font style="vertical-align: inherit;">(es sei denn, Sie deaktivieren sie mithilfe einer anderen Anweisung erneut</font></font><code>#nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Anschließend können Sie die gesamte Datei durchgehen und sicherstellen, dass alle Entitäten, bei denen es wahrscheinlich ist, dass sie null sind, als zulässig </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(d. H. Hinzufügen </font></font><code>?</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) gekennzeichnet werden. Anschließend können Sie Warnungen in dieser Datei bearbeiten, falls noch vorhanden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es kann sich herausstellen, dass das Hinzufügen aller erforderlichen Anmerkungen alles ist, was erforderlich ist, um alle Warnungen zu beseitigen. Das Gegenteil ist auch möglich: Sie können feststellen, dass Sie eine Datei über die Gültigkeit ordentlich kommentieren</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, andere Warnungen sind in anderen Dateien aufgetaucht, die es verwenden. In der Regel gibt es nicht viele solcher Warnungen, und Sie haben Zeit, diese schnell zu beheben. Aber wenn Sie nach diesem Schritt aus irgendeinem Grund nur in Warnungen ertrinken, haben Sie immer noch ein paar Lösungen. Erstens können Sie einfach die Auswahl abbrechen, diese Datei verlassen und eine andere übernehmen. Zweitens können Sie Anmerkungen für die Mitglieder, von denen Sie glauben, dass sie die meisten Probleme verursachen, selektiv deaktivieren. ( </font></font><code>#nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können die </font><font style="vertical-align: inherit;">Direktive </font><font style="vertical-align: inherit;">so oft verwenden, wie Sie möchten, sodass Sie die Einstellungen für die Nullgültigkeit sogar zeilenweise steuern können, wenn Sie möchten.) Wenn Sie später zu dieser Datei zurückkehren, wenn Sie die Nullgültigkeit in den meisten Projekten bereits aktivieren, sehen Sie möglicherweise weniger Warnungen als beim ersten Mal.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt Zeiten, in denen Probleme nicht so einfach gelöst werden können. </font><font style="vertical-align: inherit;">In bestimmten Szenarien im Zusammenhang mit der Serialisierung (z. B. bei Verwendung von Json.NET oder Entity Framework) kann die Arbeit daher schwieriger sein. </font><font style="vertical-align: inherit;">Ich denke, dieses Problem verdient einen separaten Artikel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verknüpfungen mit der Annahme </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verbessern die Ausdruckskraft Ihres Codes und erhöhen die Wahrscheinlichkeit, dass der Compiler Ihre Fehler abfängt, bevor Benutzer auf sie stoßen. </font><font style="vertical-align: inherit;">Daher ist es besser, diese Funktion nach Möglichkeit einzuschließen. </font><font style="vertical-align: inherit;">Und wenn Sie es selektiv einbeziehen, werden sich die Vorteile schneller anfühlen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de501502/index.html">New Lab Digital Synthesis setzt Harris Book fort und hilft bei der Erstellung von FPGA-Videospielen</a></li>
<li><a href="../de501506/index.html">Über GDI-Lecks und die Bedeutung des Glücks</a></li>
<li><a href="../de501508/index.html">Verdammt altes CRM</a></li>
<li><a href="../de501510/index.html">Ein neuer Blick auf die Fullstack-Entwicklung mit dem Ruby on Rails-Framework</a></li>
<li><a href="../de501516/index.html">Lassen Sie uns das Vakuum ausschalten ?! Alexey Lesovsky</a></li>
<li><a href="../de501522/index.html">Kostenlose Skillbox-Webinare: Schreiben von Spielen in PHP, Unity und Unreal Engine</a></li>
<li><a href="../de501526/index.html">Warum wird kanadisches Englisch als "schmutzig" angesehen und was hat Keanu Reeves damit zu tun?</a></li>
<li><a href="../de501528/index.html">Das Buch "Bash and Cybersecurity: Angriff, Verteidigung und Analyse über die Linux-Befehlszeile"</a></li>
<li><a href="../de501534/index.html">Jetzt mit COVID-19 gibt es auch einen Ausschlag</a></li>
<li><a href="../de501536/index.html">Maßgeschneidert: Eine Geschichte darüber, wie aus einer Codezeile Kilotonnen Kohle wurden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>