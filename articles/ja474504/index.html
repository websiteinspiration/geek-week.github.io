<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔟 🤞🏽 👃🏽 オーソドックスなバックエンド 🔌 👨‍💼 🤦🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="現代のバックエンドは多様ですが、それでもいくつかの暗黙のルールに従います。サーバーアプリケーションを開発する私たちの多くは、クリーンアーキテクチャ、SOLID、永続性無視、依存性注入など、一般に受け入れられているアプローチに直面しています。サーバー開発の属性の多くは非常にハッキングされているため、問...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>オーソドックスなバックエンド</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474504/"><img src="https://habrastorage.org/webt/dj/q5/y-/djq5y-xjov_bqvrrnb08bfyqn4i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現代のバックエンドは多様ですが、それでもいくつかの暗黙のルールに従います。サーバーアプリケーションを開発する私たちの多くは、クリーンアーキテクチャ、SOLID、永続性無視、依存性注入など、一般に受け入れられているアプローチに直面しています。サーバー開発の属性の多くは非常にハッキングされているため、問題は発生せず、軽率に使用されています。彼らはいくつかについて多く話しますが、決してそれを使用しません。残りの意味は正しく解釈されていないか、歪んでいます。この記事では、有名なプログラミング理論家の教えを損なうことなく実行できるだけでなく、ある程度改善することもできる、シンプルで完全に典型的なバックエンドアーキテクチャを構築する方法について説明します。</font></font><br>
<a name="habracut"></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">美しさなしにプログラミングを考えず、不条理の真っ只中に美しさを受け入れないすべての人に捧げます。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドメインモデル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデリングは、理想的な世界でのソフトウェア開発が始まる場所です。</font><font style="vertical-align: inherit;">しかし、私たちは皆完璧ではありません。それについてたくさん話しますが、私たちはいつものようにすべてを行います。</font><font style="vertical-align: inherit;">多くの場合、その理由は既存のツールの不完全性です。</font><font style="vertical-align: inherit;">そして正直に言うと、「ベストプラクティス」から逃れるための責任を取ることへの私たちの怠惰と恐れ。</font><font style="vertical-align: inherit;">不完全な世界では、ソフトウェア開発はせいぜい足場から始まり、最悪の場合、パフォーマンスの最適化では何も行われません。</font><font style="vertical-align: inherit;">それでも、「優れた」建築家のハードな例を捨てて、もっと普通のことを推測したいと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、私たちには技術的なタスクがあり、ユーザーインターフェイスのデザインさえあります（UIが提供されていない場合はそうではありません）。次のステップは、要件をドメインモデルに反映することです。はじめに、わかりやすくするためにモデルオブジェクトの図をスケッチできます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4n/hp/m5/4nhpm5kbhwvomryj9xhyww1eep0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、原則として、プログラミング言語、オブジェクトリレーショナルコンバーター（オブジェクトリレーショナルマッパー、ORM）、またはASP.NET MVCやRuby on Railsなどのある種の複雑なフレームワーク、つまりその実装手段に基づいてモデルの投影を開始します。コードを書き始めます。この場合、フレームワークのパスをたどりますが、モデルに基づく開発のフレームワークでは、最初はどれほど便利に見えても、正しくないと思います。ここでは、巨大な仮定を行います。これにより、ドメインベースの開発の利点が失われます。どのツールの範囲にも限定されない、より自由なオプションとして、私は、サブジェクトエリアのオブジェクトモデルを構築するためにプログラミング言語の構文ツールのみを使用することに慣れることをお勧めします。私の仕事では、いくつかのプログラミング言語を使用しています-C＃、JavaScript、Ruby。 Fateは、JavaとC＃エコシステムが私のインスピレーションであり、JSが私の主な収入であり、Rubyが私の好きな言語であることを定めました。したがって、Rubyで簡単な例を引き続き示します。これにより、他の言語の開発者が理解しても問題が発生しないと確信しています。したがって、RubyのInvoiceクラスにモデルを移植します。</font></font><br>
<br>
<pre><code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoice</span></span>
  <span class="hljs-keyword">attr_reader</span> <span class="hljs-symbol">:amount</span>, <span class="hljs-symbol">:date</span>, <span class="hljs-symbol">:created_at</span>, <span class="hljs-symbol">:paid_at</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(attrs, payment_service)</span></span><font></font>
    @created_at = DateTime.now<font></font>
    @paid_at = <span class="hljs-literal">nil</span>
    @amount = attrs[<span class="hljs-symbol">:amount</span>]<font></font>
    @date = attrs[<span class="hljs-symbol">:date</span>]<font></font>
    @subscription = attrs[<span class="hljs-symbol">:subscription</span>]<font></font>
    @payment_service = payment_service<font></font>
  <span class="hljs-keyword">end</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pay</span></span><font></font>
    credit_card = @subscription.customer.credit_card<font></font>
    amount = @subscription.plan.price<font></font>
    @payment_service.charge(credit_card, amount)<font></font>
    @paid_at = DateTime.now<font></font>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それら。</font><font style="vertical-align: inherit;">コンストラクターが属性のハッシュ、オブジェクトの依存関係を受け取り、そのフィールドを初期化するクラスと、オブジェクトの状態を変更できるpayメソッドがあります。</font><font style="vertical-align: inherit;">すべてが非常に簡単です。</font><font style="vertical-align: inherit;">ここでは、このオブジェクトをどのように、どこに表示して格納するかについては考えていません。</font><font style="vertical-align: inherit;">それは単に、それを作成し、その状態を変更し、他のオブジェクトと対話することができるということです。</font><font style="vertical-align: inherit;">コードには、BaseEntityやモデルに関連しない他のガベージなどの外部のアーティファクトが含まれていないことに注意してください。</font><font style="vertical-align: inherit;">それは非常に重要です。</font><font style="vertical-align: inherit;">ちなみに、この段階では、payment_serviceのような依存関係の代わりにスタブオブジェクトを使用して、テスト（TDD）を通じて開発を既に開始できます。</font></font><br>
<br>
<pre><code class="ruby hljs">RSpec.describe Invoice <span class="hljs-keyword">do</span>
  before <span class="hljs-symbol">:each</span> <span class="hljs-keyword">do</span>
    @payment_service = double(<span class="hljs-symbol">:payment_service</span>)<font></font>
    allow(@payment_service).to receive(<span class="hljs-symbol">:charge</span>)<font></font>
<font></font>
    @amount = <span class="hljs-number">100</span><font></font>
    @credit_card = CreditCard.new({...})<font></font>
    @customer = Customer.new({<span class="hljs-symbol">credit_card:</span> @credit_card, ...})<font></font>
    @subscription = Subscription.new({<span class="hljs-symbol">customer:</span> customer, ...})<font></font>
    @invoice = Invoice.new({<span class="hljs-symbol">amount:</span> @amount, <span class="hljs-symbol">date:</span> DateTime.now, @subscription: subscription}, payment_service)
  <span class="hljs-keyword">end</span><font></font>
<font></font>
  describe <span class="hljs-string">'pay'</span> <span class="hljs-keyword">do</span>
    it <span class="hljs-string">"charges customer's credit card"</span> <span class="hljs-keyword">do</span>
      expect(@payment_service).to receive(<span class="hljs-symbol">:charge</span>).with(@credit_card, @amount)<font></font>
      @invoice.pay<font></font>
    <span class="hljs-keyword">end</span><font></font>
<font></font>
    it <span class="hljs-string">'makes the invoice paid'</span> <span class="hljs-keyword">do</span><font></font>
      expect(@invoice.paid_at).not_to be_nil<font></font>
      @invoice.pay<font></font>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、インタプリタ（Rubyの場合はirb）でモデルを操作することもできます。これは、あまり友好的ではありませんが、ユーザーインターフェイスである可能性があります。</font></font><br>
<br>
<pre><code class="bash hljs">irb &gt; invoice = Invoice.new({amount: @amount, date: DateTime.now, @subscription: subscription}, payment_service)<font></font>
irb &gt; invoice.pay<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階で「外来のアーティファクト」を回避することがなぜ重要なのですか？実際には、モデルには、それがどのように保存されるのか、またはまったく保存されるのかどうかについての考えはないはずです。最後に、一部のシステムでは、オブジェクトをメモリに直接格納するのが非常に適している場合があります。モデリング時には、この詳細から完全に抽象化する必要があります。このアプローチは永続性無知と呼ばれます。リレーショナルデータベースであれ、他のデータベースであれ、リポジトリの操作に関する問題は無視せず、モデリング段階でのリポジトリとのやり取りの詳細のみを無視することを強調しておく必要があります。持続性の無知は、モデル自体から、モデルの状態を操作するためのメカニズムと、このプロセスに関連するあらゆる種類のメタデータを意図的に排除することを意味します。例：</font></font><br>
<br>
<pre><code class="ruby hljs"><span class="hljs-comment"># </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> &lt; Entity <span class="hljs-comment">#    </span></span>
  table <span class="hljs-symbol">:users</span> <span class="hljs-comment">#    </span><font></font>
<font></font>
  <span class="hljs-comment"># mapping </span>
  field <span class="hljs-symbol">:name</span>, <span class="hljs-symbol">type:</span> <span class="hljs-string">'String'</span><font></font>
<font></font>
  <span class="hljs-comment">#  </span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save</span></span><font></font>
  ...<font></font>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
user = User.load(id) <span class="hljs-comment">#    </span>
user.save <span class="hljs-comment">#    </span>
</code></pre><br>
<pre><code class="ruby hljs"><span class="hljs-comment"># </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>
  <span class="hljs-comment">#   ,     </span>
  <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:name</span>, <span class="hljs-symbol">:lastname</span>
<span class="hljs-keyword">end</span>
user = repo.load(id) <span class="hljs-comment">#    </span>
repo.save(user) <span class="hljs-comment">#    </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは、基本的な理由、つまり単一責任の原則（単一責任原則、SOLIDのS）の遵守にも起因します。</font><font style="vertical-align: inherit;">モデルが、その機能コンポーネントに加えて、状態保存パラメーターを記述し、その保存と読み込みも処理する場合、明らかに、あまりにも多くの責任があります。</font><font style="vertical-align: inherit;">その結果、永続性無知の最後の利点ではなく、その利点は、開発プロセス中にストレージツールとストレージ自体のタイプを置き換える機能です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルビューコントローラー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MVCのコンセプトは、サーバーだけでなく、さまざまな言語やプラットフォームのさまざまなアプリケーションの開発環境で非常に人気があり、それが何であるか、なぜそれが必要なのかについてはもはや考えていません。私はこの「コントローラー」と呼ばれる略語から最も質問があります。コードの構造を整理するという観点からは、モデルのアクションをグループ化することは良いことです。ただし、コントローラはクラスではなく、モデルにアクセスするためのメソッドを含むモジュールである必要があります。それだけでなく、そこにすべての場所が必要ですか？ .NET-&gt; Ruby-&gt; Node.jsのパスをたどった開発者として、私は簡単に、express.jsのフレームワーク内で実装するJS（ES5）コントローラーに触れました。より機能的なスタイルでコントローラーに割り当てられたタスクを解決する機能を持っている、魔法使いのように、開発者は魔法の「コントローラー」を何度も書きます。典型的なコントローラーはなぜ悪いのですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
典型的なコントローラーは、互いに密接に関連していない一連のメソッドであり、1つ（モデルの特定のエッセンス）だけで結合されます。</font><font style="vertical-align: inherit;">時には1つだけでなく </font><font style="vertical-align: inherit;">個々のメソッドごとに異なる依存関係が必要になる場合があります。</font><font style="vertical-align: inherit;">少し前を見ると、私は依存関係の逆転（依存関係の逆転、SOLIDのD）の実践を支持していることに気づきました。</font><font style="vertical-align: inherit;">したがって、これらの依存関係を外部のどこかで初期化し、コントローラーコンストラクターに渡す必要があります。</font><font style="vertical-align: inherit;">たとえば、新しいアカウントを作成するとき、通知サービスを必要とする会計士に通知を送信する必要があり、他の方法ではそれを必要としません。</font></font><br>
<br>
<pre><code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InvoiceController</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(invoice_repository, notification_service)</span></span><font></font>
    @repository = invoice_repository<font></font>
    @notification_service = notification_service<font></font>
  <span class="hljs-keyword">end</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span></span><font></font>
    @repository.get_all<font></font>
  <span class="hljs-keyword">end</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(id)</span></span><font></font>
    @repository.get_by_id(id)<font></font>
  <span class="hljs-keyword">end</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create</span><span class="hljs-params">(data)</span></span><font></font>
    @repository.create(data)<font></font>
    @notification_service.notify_accountant<font></font>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでアイデアは、モデルを別々のクラスに操作するためのメソッドに分割するように頼みます、そしてなぜそうしないのですか？</font></font><br>
<br>
<pre><code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListInvoices</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(invoice_repository)</span></span><font></font>
    @repository = invoice_repository<font></font>
  <span class="hljs-keyword">end</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call</span></span><font></font>
    @repository.get_all<font></font>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateInvoice</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(invoice_repository, notification_service)</span></span><font></font>
    @repository = invoice_repository<font></font>
    @notification_service = notification_service<font></font>
  <span class="hljs-keyword">end</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call</span></span><font></font>
    @repository.create(data)<font></font>
    @notification_service.notify_accountant<font></font>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、コントローラーの代わりに、モデルにアクセスするための一連の「関数」が用意されました。これは、たとえば、ファイルシステムディレクトリを使用して構造化することもできます。</font><font style="vertical-align: inherit;">次に、これらのメソッドを外部に「開く」必要があります。</font><font style="vertical-align: inherit;">ルーターのようなものを整理します。</font><font style="vertical-align: inherit;">あらゆる種類のDSL（ドメイン固有言語）に誘惑される人として、ルートを指定するためのRubyまたは別の汎用言語のトリックよりも、Webアプリケーションの指示をより視覚的に説明したいと思います。</font></font><br>
<br>
<pre><code class="plaintext hljs">`HTTP GET /invoices -&gt;  return all invoices`<font></font>
`HTTP POST /invoices -&gt;  create new invoice`<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または少なくとも</font></font><br>
<br>
<pre><code class="plaintext hljs">`HTTP GET /invoices  -&gt;  ./invoices/list_invoices`<font></font>
`HTTP POST /invoices -&gt; ./invoices/create`<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは典型的なルーターと非常によく似ていますが、唯一の違いは、コントローラーではなくモデルのアクションと直接やり取りすることです。</font><font style="vertical-align: inherit;">JSONを送受信する場合は、オブジェクトのシリアル化と逆シリアル化などを処理する必要があることは明らかです。</font><font style="vertical-align: inherit;">いずれにせよ、コントローラーを取り除き、責任の一部をディレクトリ構造とより高度なルーターに移すことができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存性注入</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は意図的に「より高度なルーター」を作成しました。ルーターが実際に宣言レベルで、依存性注入メカニズムを使用してモデルのアクションのフローを管理できるようにするには、内部がかなり複雑になる必要があります。作業の一般的なスキームは次の</font></font><br>
<br>
<img src="https://habrastorage.org/webt/62/v1/ts/62v1tsjynvq067lnqxmpqefw0lg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ようになります。ご覧のとおり、私のルーター全体がIoCコンテナーを使用した依存関係の注入に悩まされています。なぜこれが必要なのですか？ 「依存性注入」の概念は、依存関係の初期化を使用範囲外に移動することによってオブジェクトの接続を削減するように設計された依存関係の逆変換手法に戻ります。例：</font></font><br>
<br>
<pre><code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Repository</span>;</span> <span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-comment">#  (   )</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span></span><font></font>
    @repo = Repository.new<font></font>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-comment">#  (   )</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(repo)</span></span><font></font>
    @repo = repo<font></font>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは、テスト駆動開発を使用する人を大いに助けます。与えられた例では、オブジェクトモデルを「ハッキング」することなく、そのインターフェイスに対応する実際のリポジトリオブジェクトの代わりにコンストラクタにスタブを簡単に配置できます。これが唯一のDIボーナスではありません。正しく適用されると、このアプローチは多くの楽しい魔法をアプリケーションにもたらしますが、まず最初に。依存関係の注入は、依存関係の逆転手法を完全なアーキテクチャソリューションに統合できるようにするアプローチです。実装ツールとして、通常はIoC（制御の反転）コンテナが使用されます。 Javaと.NETの世界には、本当にクールなIoCコンテナがたくさんあります。 JSとRubyでは、残念ながら私に適したオプションはありません。特に、私はドライコンテナ（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ドライ</font></a><font style="vertical-align: inherit;">コンテナ）を見ました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">これは私のクラスがそれを使用してどのように見えるかです：</font></font><br>
<br>
<pre><code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoice</span></span>
  <span class="hljs-keyword">include</span> Import[<span class="hljs-string">'payment_service'</span>]<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pay</span></span><font></font>
    credit_card = @subscription.customer.credit_card<font></font>
    amount = @subscription.plan.price<font></font>
    @payment_service.charge(credit_card, amount)<font></font>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンストラクターを細かく使用する代わりに、独自の依存関係を導入することでクラスに負担をかけます。これにより、最初の段階で、クリーンで独立したモデルから離れます。</font><font style="vertical-align: inherit;">まあ、何かとモデルはIoCについてまったく知らないはずです！</font><font style="vertical-align: inherit;">これは、CreateInvoiceなどのアクションに当てはまります。</font><font style="vertical-align: inherit;">与えられたケースについては、私のテストでは、IoCを譲ることのできないものとして使用する義務をすでに負っています。</font><font style="vertical-align: inherit;">これは完全に間違っています。</font><font style="vertical-align: inherit;">ほとんどの場合、アプリケーションオブジェクトはIoCの存在を認識してはなりません。</font><font style="vertical-align: inherit;">たくさん検索して考えた後、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は自分のIoCをスケッチしまし</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たが、</font><font style="vertical-align: inherit;">それほど邪魔にならないでしょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルの保存と読み込み</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Persistence Ignoranceには、控えめなオブジェクトコンバータが必要です。この記事では、リレーショナルデータベースでの作業を意味します。主なポイントは、他の種類のストレージにも当てはまります。オブジェクトリレーショナルコンバーター-ORM（オブジェクトリレーショナルマッパー）は、リレーショナルデータベースの同様のコンバーターとして使用されます。 .NETとJavaの世界には、本当に強力なORMツールが豊富にあります。それらのすべてには、目を閉じることができるいくつかまたは他のマイナーな欠陥があります。 JSとRubyには良い解決策はありません。それらのすべては、いずれにせよ、モデルをフレームワークに厳密にバインドし、永続的無知の適用不可は言うまでもなく、外部要素を宣言するように強制します。 IoCの場合と同様に、自分でORMを実装することを考えました。これがRubyの現状です。私はすべてを最初から行うのではなく、さまざまなリレーショナルDBMSを操作するための目立たないツールを提供する単純なORM Sequelを基本として使用しました。まず、出力で文字列の配列（ハッシュオブジェクト）を受け取り、通常のSQLの形式でクエリを実行する機能に興味がありました。マッパーを実装して永続性の無知を提供するだけでした。すでに述べたように、マッピングフィールドをドメインモデルに混在させたくないので、タイプ形式で個別の構成ファイルを使用するようにマッパーを実装します。マッパーを実装し、永続性を無視するだけです。すでに述べたように、マッピングフィールドをドメインモデルに混在させたくないので、タイプ形式で個別の構成ファイルを使用するようにマッパーを実装します。マッパーを実装して永続性の無知を提供するだけでした。すでに述べたように、マッピングフィールドをドメインモデルに混在させたくないので、タイプ形式で個別の構成ファイルを使用するようにマッパーを実装します。</font></font><br>
<br>
<pre><code class="ruby hljs">entity Invoice <span class="hljs-keyword">do</span>
  field <span class="hljs-symbol">:amount</span>
  field <span class="hljs-symbol">:date</span>
  field <span class="hljs-symbol">:start_date</span>
  field <span class="hljs-symbol">:end_date</span>
  field <span class="hljs-symbol">:created_at</span>
  field <span class="hljs-symbol">:updated_at</span>
  reference <span class="hljs-symbol">:user</span>, <span class="hljs-symbol">type:</span> User<font></font>
  reference <span class="hljs-symbol">:subscription</span>, <span class="hljs-symbol">type:</span> Subscription
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
永続性無視は、Repositoryタイプの外部オブジェクトを使用して実装するのは非常に簡単です。</font></font><br>
<br>
<pre><code class="ruby hljs">repository.save(user)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、さらに進んで、作業単位パターンを実装します。</font><font style="vertical-align: inherit;">これを行うには、セッションの概念を強調する必要があります。</font><font style="vertical-align: inherit;">セッションは、時間の経過とともに存在するオブジェクトであり、その間に一連のアクションがモデルに対して実行されます。これは単一の論理操作です。</font><font style="vertical-align: inherit;">セッション中に、モデルオブジェクトのロードと変更が発生する可能性があります。</font><font style="vertical-align: inherit;">セッションの最後に、モデルのトランザクション状態が保存されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業単位の例：</font></font><br>
<br>
<pre><code class="ruby hljs">user = session.load(User, <span class="hljs-symbol">id:</span> <span class="hljs-number">1</span>)<font></font>
plan = session.load(Plan, <span class="hljs-symbol">id:</span> <span class="hljs-number">1</span>)<font></font>
<font></font>
subscription = Subscription.new(user, plan)<font></font>
session.attach(subscription)<font></font>
<font></font>
invoice = Invoice.new(subscription)<font></font>
session.attach(invoice)<font></font>
<font></font>
<span class="hljs-comment"># ...</span>
<span class="hljs-comment"># -      </span>
<span class="hljs-keyword">if</span> Date.today.yday == <span class="hljs-number">1</span>
  subscription.comment = <span class="hljs-string">'New year offer'</span>
  invoice.amount /= <span class="hljs-number">2</span>
<span class="hljs-keyword">end</span><font></font>
<font></font>
session.flush<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、データベースでは4つの命令ではなく2つの命令が実行され、両方が同じトランザクション内で実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、突然リポジトリを思い出してください！ここには、コントローラーと同様に、デジャヴの感覚があります。リポジトリは同じ基本的なエンティティではありませんか？先を見て、答えます-はい、そうです。リポジトリの主な目的は、ビジネスロジックのレイヤーを実際のストレージとの相互作用から取り除くことです。たとえば、リレーショナルデータベースのコンテキストでは、SQLクエリをビジネスロジックコードに直接書き込むことを意味します。間違いなく、これは非常に合理的な決定です。しかし、コントローラーを取り除いた瞬間に戻ります。 OOPの観点から見ると、リポジトリは基本的に同じコントローラーです-リクエストを処理するためだけでなく、リポジトリを操作するための同じメソッドのセットです。リポジトリはアクションに分割することもできます。すべての兆候によって、これらのアクションは、コントローラーの代わりに提案したものと何ら変わりません。つまり、リポジトリとコントローラを放棄して、単一の統合アクションを優先できます。</font></font><br>
<br>
<pre><code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadPlan</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(session)</span></span><font></font>
    @session = session<font></font>
  <span class="hljs-keyword">end</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call</span></span>
    sql = <span class="hljs-string">&lt;&lt;~SQL
      SELECT
        p.* AS ENTITY plan
      FROM plans p
      WHERE p.id = 1
    SQL</span><font></font>
<font></font>
    @session.fetch(Plan, sql)<font></font>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、私が何らかのオブジェクト構文の代わりにSQLを使用していることに気づいたでしょう。それは好みの問題です。 SQLはクエリ言語であり、データを操作するためのDSLの一種であるため、私はSQLを好みます。対応するSQLよりもPlan.load（id）を記述する方が常に簡単であることは明らかですが、これは些細な場合のためのものです。少し複雑なことになると、SQLは非常に歓迎されるツールになります。純粋なSQLのように動作させるために、別のORMを呪うことがあります。疑問がある場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MongoDBのドキュメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を参照することをお勧めします。この</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ドキュメント</font></a><font style="vertical-align: inherit;">では、説明がSQLのような形式で提供されており、とてもおもしろそうです。したがって、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ORM JetSetの</font></a><font style="vertical-align: inherit;">クエリのインターフェイス</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私の目的のために書いたのは、「AS ENTITY」などの最小限の散在を伴うSQLです。</font><font style="vertical-align: inherit;">ちなみに、ほとんどの場合、表形式のデータを表示するためにモデルオブジェクトやさまざまなDTOなどを使用しません。SQLクエリを記述し、ハッシュオブジェクトの配列を取得してビューに表示するだけです。</font><font style="vertical-align: inherit;">何らかの方法で、関連するテーブルをモデルに投影してビッグデータを「スクロール」する人はほとんどいません。</font><font style="vertical-align: inherit;">実際には、フラットプロジェクション（ビュー）が使用される可能性が高く、CQRS（コマンドとクエリの責任分離）などのより複雑なソリューションが使用されるようになると、非常に成熟した製品が最適化段階に入ります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてを一緒に入れて</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だから私たちが持っているもの：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルの読み込みと保存の方法を理解し、モデルのWeb配信ツール、特定のルーターの大まかなアーキテクチャも設計しました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブジェクト領域の一部ではないすべてのロジックは、コントローラーとリポジトリーの代わりにアクション（アクション）に入れることができるという結論に達しました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アクションは依存性注入をサポートする必要があります</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まともなツールの依存性注入が実装されました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要なORMが実装されています。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残っているのは、同じ「ルーター」を実装することだけです。</font><font style="vertical-align: inherit;">アクションを優先してリポジトリとコントローラーを削除したので、1つのリクエストで複数のアクションを実行する必要があることは明らかです。</font><font style="vertical-align: inherit;">アクションは自律的であり、お互いに投資することはできません。</font><font style="vertical-align: inherit;">そこで、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dandyフレームワークの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部として、</font><font style="vertical-align: inherit;">アクションチェーンを作成できるルーターを実装しました。</font><font style="vertical-align: inherit;">構成例（注意/計画に注意）：</font></font><br>
<br>
<pre><code class="plaintext hljs">:receive<font></font>
    .-&gt;<font></font>
        :before -&gt; common/open_db_session<font></font>
        GET -&gt; welcome -&gt; :respond &lt;- show_welcome<font></font>
<font></font>
        /auth -&gt;<font></font>
            :before -&gt; current_user@users/load_current_user<font></font>
<font></font>
            /profile -&gt;<font></font>
                GET -&gt; plan@plans/load_plan \<font></font>
                    -&gt; :respond &lt;- users/show_user_profile<font></font>
<font></font>
                PATCH -&gt; users/update_profile<font></font>
            /plans -&gt;<font></font>
                GET -&gt; current_plan@plans/load_current_plan \<font></font>
                    -&gt; plans@plans/load_plans \<font></font>
                    -&gt; :respond &lt;- plans/list<font></font>
<font></font>
:catch -&gt; common/handle_errors<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「GET / auth / plan」は、利用可能なすべてのサブスクリプションプランを表示し、現在のプランを「ハイライト」します。</font><font style="vertical-align: inherit;">次のことが起こります。</font></font><br>
<br>
<ol>
<li>":before -&gt; common/open_db_session" —   JetSet</li>
<li>/auth ":before -&gt; current_user@users/load_current_user" —    ( ).    IoC-  current_user ( current_user@). </li>
<li>/auth/plans «current_plan@plans/load_current_plan» —   .       @current_user.    IoC-  current_plan ( current_plan@):<br>
<br>
<pre><code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadCurrentPlan</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(current_user, session)</span></span><font></font>
    @current_user = current_user<font></font>
    @session = session<font></font>
  <span class="hljs-keyword">end</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call</span></span>
    sql = <span class="hljs-string">&lt;&lt;~SQL
      SELECT
        p.* AS ENTITY plan
      FROM plans p
        INNER JOIN subscriptions s ON s.user_id = :user_id AND s.current = 't'
      WHERE p.id = :user_id
      LIMIT 1
    SQL</span><font></font>
<font></font>
    @session.execute(sql, <span class="hljs-symbol">user_id:</span> @current_user.id) <span class="hljs-keyword">do</span> <span class="hljs-params">|row|</span>
      map(Plan, row, <span class="hljs-string">'plan'</span>)
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre><br>
</li>
<li>«plans@plans/load_plans» —     .    IoC-  plans ( plans@).</li>
<li>":respond &lt; — plans/list" —  ViewBuilder,  JBuilder,  View 'plans/list' :<br>
<br>
<pre><code class="ruby hljs">json.plans @plans <span class="hljs-keyword">do</span> <span class="hljs-params">|plan|</span><font></font>
  json.id plan.id<font></font>
  json.name plan.name<font></font>
  json.price plan.price<font></font>
  json.active plan.id == @current_plan.id<font></font>
<span class="hljs-keyword">end</span>
</code></pre><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
@plansおよび@current_planとして、前の手順で登録されたコンテナーから値が取得されます。一般に、Actionコンストラクターでは、必要なものすべて、またはコンテナーに登録されているすべてのものを「順序付け」できます。注意深い読者はおそらく質問をするでしょう、「マルチユーザー」モードでそのような変数の分離はありますか？はい、そうです。実際には、Hypo IoCコンテナーにはオブジェクトの存続期間を設定し、さらにそれを他のオブジェクトの存続期間にバインドする機能があります。 Dandy内では、@ plans、@ current_plan、@ current_userなどの変数がリクエストオブジェクトにバインドされており、リクエストが完了するとすぐに破棄されます。ちなみに、JetSetセッションもリクエストに関連付けられています。Dandyリクエストが完了すると、そのステータスもリセットされます。それら。各リクエストには、独自の隔離されたコンテキストがあります。名前の文字通りの翻訳においてこのしゃれがどれほど楽しいものであっても、ハイポはダンディのライフサイクル全体を支配します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定のアーキテクチャのフレームワーク内で、オブジェクトモデルを使用してサブジェクトエリアを記述します。</font><font style="vertical-align: inherit;">私は、依存性注入のような適切な方法を使用しています。</font><font style="vertical-align: inherit;">継承も使用できます。</font><font style="vertical-align: inherit;">しかし同時に、これらすべてのアクションは本質的に通常の関数であり、宣言的なレベルで一緒にチェーンできます。</font><font style="vertical-align: inherit;">機能的なスタイルで目的のバックエンドを取得しましたが、抽象化やコードのテストで問題が発生しない場合は、オブジェクトアプローチのすべての利点があります。</font><font style="vertical-align: inherit;">DSLルーターDandyを例として使用して、ルートを記述するために必要な言語を自由に作成できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事の一部として、私が見ているように、バックエンドを作成する基本的な側面について一種のツアーを行いました。繰り返しますが、記事は表面的なものであり、パフォーマンスの最適化など、多くの重要なトピックには触れていません。空想から空へ、SOLID、TDDとは何か、MVCスキームはどのように見えるのかなど、コミュニティに本当に役立つものにのみ焦点を当てようとしました。好奇心旺盛な読者が使用するこれらの用語やその他の用語の厳密な定義は、これらの略語が日常のスピーチの一部である店内の同僚は言うまでもなく、広大なネットワークで簡単に見つけることができます。そして最後に、ツールに焦点を当てないようにすることを強調します。提起された問題を解決するために実装する必要がありました。これは、思考の本質を示すものではなく、思考の妥当性を示すものです。この記事に興味がある場合は、これらのライブラリーについて別の資料を作成します。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja474494/index.html">Zabbix Summit 2019はどうでしたか</a></li>
<li><a href="../ja474496/index.html">HighLoad ++ 2019上のデータベース</a></li>
<li><a href="../ja474498/index.html">JavaFXチュートリアル：Hello World</a></li>
<li><a href="../ja474500/index.html">Grafanaのプラグイン開発：ぬいぐるみの歴史</a></li>
<li><a href="../ja474502/index.html">Joker 2019でのOdnoklassniki解析</a></li>
<li><a href="../ja474508/index.html">皮膚移植片の3Dバイオプリンティングの成果</a></li>
<li><a href="../ja474514/index.html">中国のビットコインマイニングの大物はどのように生き残るのですか</a></li>
<li><a href="../ja474516/index.html">音声アプリケーション：ロシアが気付かない10億番目の市場</a></li>
<li><a href="../ja474518/index.html">FP vs OOP</a></li>
<li><a href="../ja474522/index.html">Muttストーリー</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>