<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Archivos Zip: historial, explicaci贸n e implementaci贸n   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace tiempo que me pregunto c贸mo se comprimen los datos, incluso en los archivos Zip. Una vez decid铆 satisfacer mi curiosidad: aprender c贸mo funciona ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Archivos Zip: historial, explicaci贸n e implementaci贸n</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/490790/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bo/tw/dr/botwdrbtegpbnpnwmy7id56fbaa.jpeg"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hace tiempo que me pregunto c贸mo se comprimen los datos, incluso en los archivos Zip. Una vez decid铆 satisfacer mi curiosidad: aprender c贸mo funciona la compresi贸n y escribir mi propio programa Zip. La implementaci贸n se ha convertido en un ejercicio emocionante en la programaci贸n. Obtiene un gran placer al crear una m谩quina depurada que toma datos, transfiere sus bits a una representaci贸n m谩s eficiente y luego los recupera. Espero que tambi茅n te interese leer sobre esto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El art铆culo explica con gran detalle c贸mo funcionan los archivos Zip y el esquema de compresi贸n: compresi贸n LZ77, algoritmo Huffman, algoritmo Deflate y m谩s. Aprender谩 la historia del desarrollo de la tecnolog铆a y ver谩 ejemplos de implementaci贸n bastante efectivos escritos desde cero en C. El c贸digo fuente est谩 aqu铆: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hwzip-1.0.zip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estoy muy agradecido con </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ange Albertini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gynvael Coldwind</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fabian Giesen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jonas Skeppstedt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">web</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primiano Tucci</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nico Weber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , quienes brindaron valiosos comentarios sobre los borradores de este art铆culo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenido</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Historia</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PKZip</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Info-zip y zlib</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winzip</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compresi贸n Lempel-Ziv (LZ77)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C贸digo Huffman</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritmo Huffman</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C贸digos can贸nicos de Huffman</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decodificaci贸n Huffman eficiente</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desinflar</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corrientes de bits</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desembalaje (inflaci贸n)</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloques de desinflado sin comprimir</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desinfle los bloques utilizando c贸digos fijos de Huffman</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desinfle los bloques usando c贸digos din谩micos de Huffman</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compresi贸n (deflaci贸n)</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formato de archivo zip</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visi贸n general</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estructuras de datos</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fin de la entrada del directorio central</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encabezado de archivo central</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encabezado de archivo local</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementaci贸n de Zip Read</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementaci贸n de registro postal</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hwzip</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instrucciones de montaje</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusi贸n</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejercicios</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Materiales utiles</font></font></a></li>
</ul><br>
<a name="1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Historia</font></font></h2><br>
<a name="2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PKZip</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los a帽os ochenta y principios de los noventa, antes de que Internet se generalizara, los entusiastas de las computadoras usaban m贸dems de acceso telef贸nico para conectarse a trav茅s de la red telef贸nica a la red de Sistemas de Tablero de Boletines (BBS). </font><font style="vertical-align: inherit;">BBS era un sistema inform谩tico interactivo que permit铆a a los usuarios enviar mensajes, jugar juegos y compartir archivos. </font><font style="vertical-align: inherit;">Para conectarse, fue suficiente tener una computadora, un m贸dem y un buen n煤mero de tel茅fono de BBS. </font><font style="vertical-align: inherit;">Los n煤meros </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se publicaron en revistas de inform谩tica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y en otros BBS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una herramienta importante para facilitar la distribuci贸n de archivos fue el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archivador</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Le permite guardar uno o m谩s archivos en un 煤nico </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archivo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para almacenar o transmitir informaci贸n de manera m谩s conveniente. E idealmente, el archivo tambi茅n comprimi贸 archivos para ahorrar espacio y tiempo para la transmisi贸n a trav茅s de la red. En los d铆as de BBS, el archivador Arc era popular, escrito por Tom Henderson de System Enhancement Associates (SEA), una peque帽a empresa que fund贸 con su cu帽ado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A fines de la d茅cada de 1980, el programador Phil Katz lanz贸 su propia versi贸n de Arc, PKArc. Era compatible con SEA Arc, pero funcionaba m谩s r谩pido gracias a las subrutinas escritas en lenguaje ensamblador y utilizaba un nuevo m茅todo de compresi贸n. El programa se hizo popular, Katz renunci贸 a su trabajo y cre贸 PKWare para enfocarse en un mayor desarrollo. Seg煤n la leyenda, la mayor parte del trabajo tuvo lugar en la cocina de su madre en Glendale, Wisconsin.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1e/50a/990/b1e50a990a86a05045dde9d2a819fbf0.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foto de Phil Katz </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de un art铆culo en el Milwaukee Sentinel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , 19 de septiembre de 1994.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sin embargo, la SEA no estaba contenta con la iniciativa de Katz. La compa帽铆a lo acus贸 de infracci贸n de marca registrada y derechos de autor. El litigio y la controversia en la red BBS y el mundo de las PC se ha conocido como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arc Wars</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Al final, la disputa se </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resolvi贸</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a favor de la SEA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abandonando Arc, Katz cre贸 un nuevo formato de archivo en 1989, que llam贸 Zip y puso a disposici贸n </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">del p煤blico</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote> ,   ,        ,      .  ,  ".ZIP",             ,      ,     ,          , , ,                  ,     ,      .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El programa de Katz para crear dichos archivos se llamaba PKZip y pronto se extendi贸 al mundo de BBS y PC. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uno de los aspectos que probablemente contribuy贸 al 茅xito del formato Zip es que la documentaci贸n vino con PKZip, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application Note</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que explica en detalle c贸mo funciona el formato. Esto permiti贸 a otros aprender el formato y crear programas que generan, extraen o interact煤an con archivos Zip. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zip: un formato de compresi贸n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sin p茅rdida</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : despu茅s de desempacar los datos ser谩n los mismos que antes de la compresi贸n. El algoritmo busca redundancia en los datos de origen y presenta informaci贸n de manera m谩s eficiente. Este enfoque es diferente de la </font><i><font style="vertical-align: inherit;">compresi贸n</font></i><font style="vertical-align: inherit;"> con </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p茅rdida.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que se usa en formatos como JPEG y MP3: cuando se comprime, se desecha parte de la informaci贸n que es menos notable para el ojo humano o el o铆do. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PKZip se distribuy贸 como Shareware: se pod铆a usar y copiar libremente, pero el autor sugiri贸 a los usuarios que "registraran" el programa. </font><font style="vertical-align: inherit;">Por $ 47, puede obtener instrucciones impresas, soporte premium y una versi贸n mejorada de la aplicaci贸n.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/031/509/4fc/0315094fc6917b61db8f78b2f776ce13.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una de las versiones clave de PKZip fue 2.04c, lanzada el 28 de diciembre de 1992 (la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versi贸n 2.04g</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fue lanzada poco despu茅s </font><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Us贸 el algoritmo de compresi贸n Deflate predeterminado. </font><font style="vertical-align: inherit;">La versi贸n determin贸 el desarrollo posterior de la compresi贸n en archivos Zip ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art铆culo dedicado al lanzamiento</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58e/bd3/69b/58ebd369bf36c272d0c8c7c9515fc670.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desde entonces, el formato zip se ha utilizado en muchos otros formatos de archivo. </font><font style="vertical-align: inherit;">Por ejemplo, los archivos Java (.jar), los paquetes de aplicaciones de Android (.apk) y los archivos .docx de Microsoft Office usan el formato Zip. </font><font style="vertical-align: inherit;">Muchos formatos y protocolos usan el mismo algoritmo de compresi贸n, Deflate. </font><font style="vertical-align: inherit;">Digamos que las p谩ginas web probablemente se transfieren a su navegador como un archivo gzip, cuyo formato utiliza la compresi贸n Deflate. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Phil Katz muri贸 en 2000. </font><font style="vertical-align: inherit;">PKWare todav铆a existe y es compatible con el formato Zip, aunque la compa帽铆a se centra principalmente en el software de protecci贸n de datos.</font></font><br>
<br>
<a name="3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Info-zip y zlib</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Poco despu茅s del lanzamiento de PKZip en 1989, comenzaron a aparecer otros programas para descomprimir archivos Zip. Por ejemplo, un programa de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descompresi贸n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que podr铆a descomprimir en sistemas Unix. En marzo de 1990, se cre贸 una lista de correo llamada Info-ZIP. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El grupo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Info-ZIP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ha lanzado programas gratuitos de c贸digo abierto para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descomprimir</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comprimir</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que se utilizaron para descomprimir y crear archivos zip. El c贸digo ha sido portado a muchos sistemas, y sigue siendo el est谩ndar para los programas Zip para sistemas Unix. Esto m谩s tarde ayud贸 a aumentar la popularidad de los archivos Zip. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una vez que el c贸digo ZIP de informaci贸n que desinfl贸 la compresi贸n y descompresi贸n se movi贸 a una biblioteca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zlib</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> separada </font><font style="vertical-align: inherit;">que escribieron</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jean-loup Gailly</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (compresi贸n) y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mark Adler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (desembalaje).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68b/216/d1d/68b216d1debaffdb2d890067e38bed47.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jean-loup Gailly (izquierda) y Mark Adler (derecha) en el </font><font style="vertical-align: inherit;">Premio </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USENIX STUG 2009</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Una de las razones para crear la biblioteca fue que proporcionaba la conveniencia de usar la compresi贸n Deflate en otras aplicaciones y formatos, por ejemplo, en los nuevos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gzip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PNG</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Estos nuevos formatos estaban destinados a reemplazar a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compress</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GIF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que utilizaban el algoritmo LZW protegido por patente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como parte de la creaci贸n de estos formatos, Peter Deutsch escribi贸 la especificaci贸n Deflate y la public贸 bajo el nombre de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internet RFC 1951</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en mayo de 1996. Result贸 ser una descripci贸n m谩s accesible en comparaci贸n con la Nota de aplicaci贸n PKZip original.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hoy zlib se usa en todas partes. </font><font style="vertical-align: inherit;">Quiz谩s ahora sea responsable de comprimir esta p谩gina en un servidor web y desempacarla en su navegador. </font><font style="vertical-align: inherit;">Hoy, la mayor铆a de los archivos zip se comprimen y descomprimen usando zlib.</font></font><br>
<br>
<a name="4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winzip</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muchos de los que no encontraron PKZip usaron WinZip. Los usuarios de PC cambiaron de DOS a Windows, y de PKZip a WinZip. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo comenz贸 con un proyecto del programador Nico Mac, que cre贸 software para OS / 2 en Mansfield Software Group en Storrs-Mansfield, Connecticut. Nico us贸 Presentation Manager, esta es una interfaz gr谩fica de usuario en OS / 2, y estaba molesto porque ten铆a que cambiar de un administrador de archivos a comandos de DOS cada vez que quer铆a crear archivos Zip. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mac escribi贸 un programa GUI simple que funcionaba con archivos Zip directamente en Presentation Manager, lo llam贸 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PMZip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y lo lanz贸 como shareware en la d茅cada de 1990.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OS / 2 no tuvo 茅xito, y el mundo de las PC se hizo cargo de Microsoft Windows. </font><font style="vertical-align: inherit;">En 1991, Mac decidi贸 aprender a escribir programas de Windows, y su primer proyecto fue portar su aplicaci贸n Zip a un nuevo sistema operativo. </font><font style="vertical-align: inherit;">En abril de 1991, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se lanz贸 WinZip 1.00</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Se distribuy贸 como shareware con un per铆odo de prueba de 21 d铆as y una tarifa de registro de $ 29. </font><font style="vertical-align: inherit;">Ella se ve铆a as铆:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b1/2f4/bcd/0b12f4bcd048691aa0487b9d3a445b39.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En las primeras versiones de WinZip, PKZip se utiliz贸 debajo del cap贸. </font><font style="vertical-align: inherit;">Pero a partir de la versi贸n 5.0 en 1993, el c贸digo de Info-ZIP comenz贸 a usarse para el procesamiento directo de archivos Zip. </font><font style="vertical-align: inherit;">La interfaz de usuario tambi茅n ha evolucionado gradualmente.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf4/273/962/bf427396212f63fba9c80db12fdd2132.png"></div><br>
<i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WinZip 6.3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en Windows 3.11 para grupos de trabajo. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WinZip fue uno de los programas shareware m谩s populares en la d茅cada de 1990. </font><font style="vertical-align: inherit;">Pero al final, perdi贸 relevancia debido a la incorporaci贸n de soporte para archivos Zip en los sistemas operativos. </font><font style="vertical-align: inherit;">Windows ha estado trabajando con ellos como "carpetas comprimidas" desde 2001 (Windows XP), la biblioteca</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DynaZip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se utiliza para esto</font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mac originalmente se llamaba Nico Mak Computing. </font><font style="vertical-align: inherit;">En 2000, pas贸 a llamarse WinZip Computing, y por esos a帽os Mack lo dej贸. </font><font style="vertical-align: inherit;">En 2005,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vector Capital vendi贸 la</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compa帽铆a</font><font style="vertical-align: inherit;">y, al final, se convirti贸 en propiedad de</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Corel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que a煤n lanza WinZip como producto.</font></font><br>
<br>
<a name="5"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compresi贸n Lempel-Ziv (LZ77)</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La compresi贸n Zip consta de dos ingredientes principales: compresi贸n Lempel-Ziv y c贸digo Huffman. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una forma de comprimir el texto es crear una lista de palabras o frases comunes con el reemplazo de variedades de estas palabras dentro del texto con enlaces al diccionario. Por ejemplo, la palabra larga "compresi贸n" en el texto fuente se puede representar como # 1234, donde 1234 se refiere a la posici贸n de la palabra en la lista. Esto se llama </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compresi贸n de diccionario</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero desde el punto de vista de la compresi贸n universal, este m茅todo tiene varios inconvenientes. Primero, 驴qu茅 deber铆a entrar exactamente en el diccionario? Los datos de origen pueden estar en diferentes idiomas, incluso puede no ser texto legible por humanos. Y si el diccionario no se acuerda de antemano entre la compresi贸n y la descompresi贸n, entonces deber谩 almacenarse y transferirse junto con los datos comprimidos, lo que reduce los beneficios de la compresi贸n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una soluci贸n elegante a este problema es utilizar los datos de origen como un diccionario. En </font><font style="vertical-align: inherit;">1977, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un algoritmo universal para la compresi贸n secuencial de datos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Jacob Ziv y Abraham Lempel (que trabajaban en Technion), propusieron un esquema de compresi贸n en el que los datos de origen se presentan como una secuencia de tripletes:</font></font><br>
<br>
<pre><code class="cpp hljs">(, , )
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
donde </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forman un v铆nculo de retroceso a la secuencia de caracteres que desea copiar desde la posici贸n anterior en el texto original, y </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este es el siguiente car谩cter de los datos generados.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e5/21e/fdb/5e521efdb5649015f685e26ab308d1b9.jpg"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ce/cfa/2e3/2cecfa2e39798ce3302ff4b48e1a62ef.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abraham Lempel y Jacob Ziv. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere las siguientes l铆neas:</font></font><br>
<br>
<pre><code class="cpp hljs">It was the best of times,<font></font>
it was the worst of times,<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la segunda l铆nea, la secuencia "t was the w" se puede representar como (26, 10, w), ya que se recrea copiando 10 caracteres de la posici贸n de 26 caracteres a la letra "w". Para los caracteres que a煤n no han aparecido, se utilizan v铆nculos de retroceso de longitud cero. Por ejemplo, la "I" inicial se puede representar como (0, 0, I). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este esquema se llama compresi贸n Lempel-Ziv o compresi贸n LZ77. Sin embargo, en implementaciones pr谩cticas del algoritmo, parte del triplete generalmente no se usa </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En cambio, los caracteres se generan individualmente y se usan pares ( </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">para los v铆nculos de retroceso </font><font style="vertical-align: inherit;">(esta opci贸n se denomina compresi贸n </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LZSS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). La forma en que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se codifican los</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> literales y los v铆nculos de retroceso es un tema separado, lo consideraremos a continuaci贸n cuando analicemos el algoritmo</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El desinflar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este texto:</font></font><br>
<br>
<pre><code class="cpp hljs">It was the best of times,<font></font>
it was the worst of times,<font></font>
it was the age of wisdom,<font></font>
it was the age of foolishness,<font></font>
it was the epoch of belief,<font></font>
it was the epoch of incredulity,<font></font>
it was the season of Light,<font></font>
it was the season of Darkness,<font></font>
it was the spring of hope,<font></font>
it was the winter of despair,<font></font>
we had everything before us,<font></font>
we had nothing before us,<font></font>
we were all going direct to Heaven,<font></font>
we were all going direct the other way<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puedes comprimir esto:</font></font><br>
<br>
<pre><code class="cpp hljs">It was the best of times,<font></font>
i(<span class="hljs-number">26</span>,<span class="hljs-number">10</span>)wor(<span class="hljs-number">27</span>,<span class="hljs-number">24</span>)age(<span class="hljs-number">25</span>,<span class="hljs-number">4</span>)wisdom(<span class="hljs-number">26</span>,<span class="hljs-number">20</span>)<font></font>
foolishnes(<span class="hljs-number">57</span>,<span class="hljs-number">14</span>)epoch(<span class="hljs-number">33</span>,<span class="hljs-number">4</span>)belief(<span class="hljs-number">28</span>,<span class="hljs-number">22</span>)incredulity<font></font>
(<span class="hljs-number">33</span>,<span class="hljs-number">13</span>)season(<span class="hljs-number">34</span>,<span class="hljs-number">4</span>)Light(<span class="hljs-number">28</span>,<span class="hljs-number">23</span>)Dark(<span class="hljs-number">120</span>,<span class="hljs-number">17</span>)<font></font>
spring(<span class="hljs-number">31</span>,<span class="hljs-number">4</span>)hope(<span class="hljs-number">231</span>,<span class="hljs-number">14</span>)inter(<span class="hljs-number">27</span>,<span class="hljs-number">4</span>)despair,
<span class="hljs-function">we had <span class="hljs-title">everyth</span><span class="hljs-params">(<span class="hljs-number">57</span>,<span class="hljs-number">4</span>)</span>before <span class="hljs-title">us</span><span class="hljs-params">(<span class="hljs-number">29</span>,<span class="hljs-number">9</span>)</span><span class="hljs-title">no</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">20</span>)</span>
<span class="hljs-title">we</span><span class="hljs-params">(<span class="hljs-number">12</span>,<span class="hljs-number">3</span>)</span>all <span class="hljs-title">go</span><span class="hljs-params">(<span class="hljs-number">29</span>,<span class="hljs-number">4</span>)</span>direct to <span class="hljs-title">Heaven</span>
<span class="hljs-params">(<span class="hljs-number">36</span>,<span class="hljs-number">28</span>)</span><span class="hljs-params">(<span class="hljs-number">139</span>,<span class="hljs-number">3</span>)</span><span class="hljs-params">(<span class="hljs-number">83</span>,<span class="hljs-number">3</span>)</span><span class="hljs-params">(<span class="hljs-number">138</span>,<span class="hljs-number">3</span>)</span>way
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una de las propiedades importantes de los v铆nculos de retroceso es que pueden superponerse. </font><font style="vertical-align: inherit;">Esto sucede cuando la longitud es mayor que la distancia. </font><font style="vertical-align: inherit;">Por ejemplo:</font></font><br>
<br>
<pre><code class="cpp hljs">Fa-la-la-la-la
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puedes comprimir a:</font></font><br>
<br>
<pre><code class="cpp hljs">Fa-la(<span class="hljs-number">3</span>,<span class="hljs-number">9</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede parecerle extra帽o, pero el m茅todo funciona: despu茅s de copiar los bytes de los primeros tres "-la", la copia contin煤a utilizando los bytes reci茅n generados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, este es un tipo de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codificaci贸n de longitudes de series</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en el que parte de los datos se copian repetidamente para obtener la longitud deseada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En un art铆culo de Colin Morris, se muestra un ejemplo interactivo del uso de la compresi贸n Lempel-Ziv para las letras de canciones </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente es un ejemplo de copia de v铆nculos de retroceso en C. Tenga en cuenta que debido a una posible superposici贸n, no podemos usar </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>memmove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Output the (dist,len) backref at dst_pos in dst. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lz77_output_backref</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_pos,
                                       <span class="hljs-keyword">size_t</span> dist, <span class="hljs-keyword">size_t</span> len)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;<font></font>
<font></font>
        assert(dist &lt;= dst_pos &amp;&amp; <span class="hljs-string">"cannot reference before beginning of dst"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {<font></font>
                dst[dst_pos] = dst[dst_pos - dist];<font></font>
                dst_pos++;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es f谩cil generar literales, pero para completar, utilizaremos una funci贸n auxiliar:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Output lit at dst_pos in dst. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lz77_output_lit</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_pos, <span class="hljs-keyword">uint8_t</span> lit)</span>
</span>{<font></font>
        dst[dst_pos] = lit;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que la persona que llama de esta funci贸n debe asegurarse de que haya </font></font><code>dst</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suficiente espacio para los datos generados y que el v铆nculo de retroceso no acceda a la posici贸n antes del inicio del b煤fer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es dif铆cil no generar datos utilizando v铆nculos de retroceso durante el desempaquetado, sino crearlos primero al comprimir los datos de origen. Esto se puede hacer de diferentes maneras, pero utilizaremos el m茅todo basado en tablas hash de zlib, que se propone en RFC 1951. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usaremos una tabla hash con las posiciones de los prefijos de tres caracteres que se encontraron previamente en la l铆nea (los v铆nculos de retroceso m谩s cortos no aportan ning煤n beneficio). Deflate permite v铆nculos de retroceso dentro de los 32.768 caracteres anteriores; esto se denomina </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ventana</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esto proporciona compresi贸n de transmisi贸n: los datos de entrada se procesan poco a poco, siempre que la ventana con los 煤ltimos bytes se almacene en la memoria. Sin embargo, nuestra implementaci贸n asume que todos los datos de entrada est谩n disponibles para nosotros y que podemos procesarlos completos a la vez. Esto le permite centrarse en la compresi贸n en lugar de la contabilidad, lo cual es necesario para el procesamiento de flujo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usaremos dos matrices: in </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contiene el valor hash del prefijo de tres caracteres para la posici贸n en la entrada, y in </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contiene la posici贸n de la posici贸n anterior con este valor hash. De hecho, </font></font><code>head[h]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este es el encabezado de una lista vinculada de posiciones de prefijo con un hash </font></font><code>h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y </font></font><code>prev[x]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recibe el elemento que precede a </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la lista.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LZ_WND_SIZE 32768</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LZ_MAX_LEN  258</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HASH_SIZE 15</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NO_POS    SIZE_MAX</span><font></font>
<font></font>
<span class="hljs-comment">/* Perform LZ77 compression on the len bytes in src. Returns false as soon as
   either of the callback functions returns false, otherwise returns true when
   all bytes have been processed. */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">lz77_compress</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> len,
                   <span class="hljs-keyword">bool</span> (*lit_callback)(<span class="hljs-keyword">uint8_t</span> lit, <span class="hljs-keyword">void</span> *aux),
                   <span class="hljs-keyword">bool</span> (*backref_callback)(<span class="hljs-keyword">size_t</span> dist, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">void</span> *aux),
                   <span class="hljs-keyword">void</span> *aux)</span>
</span>{
        <span class="hljs-keyword">size_t</span> head[<span class="hljs-number">1U</span> &lt;&lt; HASH_SIZE];
        <span class="hljs-keyword">size_t</span> prev[LZ_WND_SIZE];<font></font>
<font></font>
        <span class="hljs-keyword">uint16_t</span> h;
        <span class="hljs-keyword">size_t</span> i, j, dist;
        <span class="hljs-keyword">size_t</span> match_len, match_pos;
        <span class="hljs-keyword">size_t</span> prev_match_len, prev_match_pos;<font></font>
<font></font>
        <span class="hljs-comment">/* Initialize the hash table. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(head) / <span class="hljs-keyword">sizeof</span>(head[<span class="hljs-number">0</span>]); i++) {<font></font>
                head[i] = NO_POS;<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para insertar una nueva posici贸n de cadena en la tabla hash </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se actualiza para indicar la anterior </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y luego se actualiza a s铆 misma </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert_hash</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> hash, <span class="hljs-keyword">size_t</span> pos, <span class="hljs-keyword">size_t</span> *head, <span class="hljs-keyword">size_t</span> *prev)</span>
</span>{<font></font>
        prev[pos % LZ_WND_SIZE] = head[hash];<font></font>
        head[hash] = pos;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Preste atenci贸n a la operaci贸n de m贸dulo al indexar </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: solo nos interesan las posiciones que se encuentran en la ventana actual. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En lugar de calcular el valor hash para cada prefijo de tres caracteres desde cero, usaremos un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hash de anillo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y lo actualizaremos constantemente para que solo los 煤ltimos tres caracteres se reflejen en su valor:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint16_t</span> <span class="hljs-title">update_hash</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> hash, <span class="hljs-keyword">uint8_t</span> c)</span>
</span>{<font></font>
        hash &lt;&lt;= <span class="hljs-number">5</span>;                     <span class="hljs-comment">/* Shift out old bits. */</span>
        hash ^= c;                      <span class="hljs-comment">/* Include new bits. */</span>
        hash &amp;= (<span class="hljs-number">1U</span> &lt;&lt; HASH_SIZE) - <span class="hljs-number">1</span>;  <span class="hljs-comment">/* Mask off excess bits. */</span><font></font>
<font></font>
        <span class="hljs-keyword">return</span> hash;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mapa hash se puede usar para buscar eficientemente coincidencias anteriores con una secuencia, como se muestra a continuaci贸n. </font><font style="vertical-align: inherit;">La b煤squeda de coincidencias es la operaci贸n de compresi贸n que requiere m谩s recursos, por lo que limitaremos la profundidad de la b煤squeda en la lista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cambiar varios par谩metros, como la profundidad de b煤squeda en la lista de prefijos y realizar comparaciones perezosas, como se describe a continuaci贸n, es una forma de aumentar la velocidad al reducir la relaci贸n de compresi贸n. </font><font style="vertical-align: inherit;">La configuraci贸n de nuestro c贸digo se selecciona para que coincida con el nivel de compresi贸n m谩ximo en zlib.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Find the longest most recent string which matches the string starting
 * at src[pos]. The match must be strictly longer than prev_match_len and
 * shorter or equal to max_match_len. Returns the length of the match if found
 * and stores the match position in *match_pos, otherwise returns zero. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">find_match</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> pos, <span class="hljs-keyword">uint16_t</span> hash,
                         <span class="hljs-keyword">size_t</span> prev_match_len, <span class="hljs-keyword">size_t</span> max_match_len,
                         <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> *head, <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> *prev,
                         <span class="hljs-keyword">size_t</span> *match_pos)</span>
</span>{
        <span class="hljs-keyword">size_t</span> max_match_steps = <span class="hljs-number">4096</span>;
        <span class="hljs-keyword">size_t</span> i, l;
        <span class="hljs-keyword">bool</span> found;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (prev_match_len == <span class="hljs-number">0</span>) {
                <span class="hljs-comment">/* We want backrefs of length 3 or longer. */</span>
                prev_match_len = <span class="hljs-number">2</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (prev_match_len &gt;= max_match_len) {
                <span class="hljs-comment">/* A longer match would be too long. */</span>
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (prev_match_len &gt;= <span class="hljs-number">32</span>) {
                <span class="hljs-comment">/* Do not try too hard if there is already a good match. */</span>
                max_match_steps /= <span class="hljs-number">4</span>;<font></font>
        }<font></font>
<font></font>
        found = <span class="hljs-literal">false</span>;<font></font>
        i = head[hash];<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (max_match_steps != <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (i == NO_POS) {
                        <span class="hljs-comment">/* No match. */</span>
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
<font></font>
                assert(i &lt; pos &amp;&amp; <span class="hljs-string">"Matches should precede pos."</span>);
                <span class="hljs-keyword">if</span> (pos - i &gt; LZ_WND_SIZE) {
                        <span class="hljs-comment">/* The match is outside the window. */</span>
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
<font></font>
                l = cmp(src, i, pos, prev_match_len, max_match_len);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (l != <span class="hljs-number">0</span>) {<font></font>
                        assert(l &gt; prev_match_len);<font></font>
                        assert(l &lt;= max_match_len);<font></font>
<font></font>
                        found = <span class="hljs-literal">true</span>;<font></font>
                        *match_pos = i;<font></font>
                        prev_match_len = l;<font></font>
<font></font>
                        <span class="hljs-keyword">if</span> (l == max_match_len) {
                                <span class="hljs-comment">/* A longer match is not possible. */</span>
                                <span class="hljs-keyword">return</span> l;<font></font>
                        }<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Look further back in the prefix list. */</span><font></font>
                i = prev[i % LZ_WND_SIZE];<font></font>
                max_match_steps--;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!found) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> prev_match_len;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Compare the substrings starting at src[i] and src[j], and return the length
 * of the common prefix. The match must be strictly longer than prev_match_len
 * and shorter or equal to max_match_len. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> i, <span class="hljs-keyword">size_t</span> j,
                  <span class="hljs-keyword">size_t</span> prev_match_len, <span class="hljs-keyword">size_t</span> max_match_len)</span>
</span>{
        <span class="hljs-keyword">size_t</span> l;<font></font>
<font></font>
        assert(prev_match_len &lt; max_match_len);<font></font>
<font></font>
        <span class="hljs-comment">/* Check whether the first prev_match_len + 1 characters match. Do this
         * backwards for a higher chance of finding a mismatch quickly. */</span>
        <span class="hljs-keyword">for</span> (l = <span class="hljs-number">0</span>; l &lt; prev_match_len + <span class="hljs-number">1</span>; l++) {
                <span class="hljs-keyword">if</span> (src[i + prev_match_len - l] !=<font></font>
                    src[j + prev_match_len - l]) {<font></font>
                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        assert(l == prev_match_len + <span class="hljs-number">1</span>);<font></font>
<font></font>
        <span class="hljs-comment">/* Now check how long the full match is. */</span>
        <span class="hljs-keyword">for</span> (; l &lt; max_match_len; l++) {
                <span class="hljs-keyword">if</span> (src[i + l] != src[j + l]) {
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        assert(l &gt; prev_match_len);<font></font>
        assert(l &lt;= max_match_len);<font></font>
        assert(<span class="hljs-built_in">memcmp</span>(&amp;src[i], &amp;src[j], l) == <span class="hljs-number">0</span>);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> l;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede terminar la funci贸n con </font></font><code>lz77_compress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este c贸digo para buscar coincidencias anteriores:</font></font><br>
<br>
<pre><code class="cpp hljs">       <span class="hljs-comment">/* h is the hash of the three-byte prefix starting at position i. */</span>
        h = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (len &gt;= <span class="hljs-number">2</span>) {<font></font>
                h = update_hash(h, src[<span class="hljs-number">0</span>]);<font></font>
                h = update_hash(h, src[<span class="hljs-number">1</span>]);<font></font>
        }<font></font>
<font></font>
        prev_match_len = <span class="hljs-number">0</span>;<font></font>
        prev_match_pos = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i + <span class="hljs-number">2</span> &lt; len; i++) {<font></font>
                h = update_hash(h, src[i + <span class="hljs-number">2</span>]);<font></font>
<font></font>
                <span class="hljs-comment">/* Search for a match using the hash table. */</span><font></font>
                match_len = find_match(src, i, h, prev_match_len,<font></font>
                                       min(LZ_MAX_LEN, len - i), head, prev,<font></font>
                                       &amp;match_pos);<font></font>
<font></font>
                <span class="hljs-comment">/* Insert the current hash for future searches. */</span><font></font>
                insert_hash(h, i, head, prev);<font></font>
<font></font>
                <span class="hljs-comment">/* If the previous match is at least as good as the current. */</span>
                <span class="hljs-keyword">if</span> (prev_match_len != <span class="hljs-number">0</span> &amp;&amp; prev_match_len &gt;= match_len) {
                        <span class="hljs-comment">/* Output the previous match. */</span>
                        dist = (i - <span class="hljs-number">1</span>) - prev_match_pos;
                        <span class="hljs-keyword">if</span> (!backref_callback(dist, prev_match_len, aux)) {
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                        }<font></font>
                        <span class="hljs-comment">/* Move past the match. */</span>
                        <span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; min((i - <span class="hljs-number">1</span>) + prev_match_len,<font></font>
                                                len - <span class="hljs-number">2</span>); j++) {<font></font>
                                h = update_hash(h, src[j + <span class="hljs-number">2</span>]);<font></font>
                                insert_hash(h, j, head, prev);<font></font>
                        }<font></font>
                        i = (i - <span class="hljs-number">1</span>) + prev_match_len - <span class="hljs-number">1</span>;<font></font>
                        prev_match_len = <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* If no match (and no previous match), output literal. */</span>
                <span class="hljs-keyword">if</span> (match_len == <span class="hljs-number">0</span>) {<font></font>
                        assert(prev_match_len == <span class="hljs-number">0</span>);
                        <span class="hljs-keyword">if</span> (!lit_callback(src[i], aux)) {
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Otherwise the current match is better than the previous. */</span><font></font>
<font></font>
                <span class="hljs-keyword">if</span> (prev_match_len != <span class="hljs-number">0</span>) {
                        <span class="hljs-comment">/* Output a literal instead of the previous match. */</span>
                        <span class="hljs-keyword">if</span> (!lit_callback(src[i - <span class="hljs-number">1</span>], aux)) {
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                        }<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Defer this match and see if the next is even better. */</span><font></font>
                prev_match_len = match_len;<font></font>
                prev_match_pos = match_pos;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Output any previous match. */</span>
        <span class="hljs-keyword">if</span> (prev_match_len != <span class="hljs-number">0</span>) {<font></font>
                dist = (i - <span class="hljs-number">1</span>) - prev_match_pos;
                <span class="hljs-keyword">if</span> (!backref_callback(dist, prev_match_len, aux)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                i = (i - <span class="hljs-number">1</span>) + prev_match_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Output any remaining literals. */</span>
        <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
                <span class="hljs-keyword">if</span> (!lit_callback(src[i], aux)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este c贸digo busca el v铆nculo de retroceso m谩s largo que se puede generar en la posici贸n actual. Pero antes de emitirlo, el programa decide si es posible encontrar una coincidencia a煤n m谩s larga en la siguiente posici贸n. En zlib, esto se llama </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">evaluaci贸n de comparaci贸n perezosa</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto sigue siendo un </font><font style="vertical-align: inherit;">algoritmo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codicioso</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : selecciona la coincidencia m谩s larga, incluso si la actual m谩s corta le permite obtener una coincidencia a煤n m谩s larga y lograr una compresi贸n m谩s fuerte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La compresi贸n Lempel-Ziv puede funcionar tanto r谩pido como lento. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zopfli</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pas茅 mucho tiempo buscando v铆nculos de retroceso 贸ptimos para exprimir porcentajes de compresi贸n adicionales. Esto es 煤til para datos que se comprimen una vez y luego se reutilizan, por ejemplo, para informaci贸n est谩tica en un servidor web. En el otro lado de la escala hay compresores como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Snappy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LZ4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que se comparan solo con el 煤ltimo prefijo de 4 bytes y son muy r谩pidos. Este tipo de compresi贸n es 煤til en bases de datos y sistemas RPC en los que el tiempo dedicado a la compresi贸n vale la pena al ahorrar tiempo al enviar datos a trav茅s de una red o al disco. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea de utilizar datos de origen como diccionario es muy elegante, pero tambi茅n puede beneficiarse de un diccionario est谩tico. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brotli</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un algoritmo basado en LZ77, pero tambi茅n utiliza un gran</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diccionario est谩tico</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de cadena, que a menudo se encuentra en la red. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LZ77 c贸digo se puede ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en lz77.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lz77.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="6"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C贸digo Huffman</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo algoritmo de compresi贸n Zip es el c贸digo Huffman. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El t茅rmino </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c贸digo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en este contexto es una referencia a un sistema para presentar datos en alguna otra forma. </font><font style="vertical-align: inherit;">En este caso, estamos interesados en el c贸digo que se puede utilizar para representar de manera eficiente los literales y los v铆nculos de retroceso generados por el algoritmo Lempel-Ziv. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tradicionalmente, el texto en ingl茅s se presenta utilizando el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C贸digo Est谩ndar Americano para el Intercambio de Informaci贸n (ASCII)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este sistema asigna a cada car谩cter un n煤mero, que generalmente se almacena en una representaci贸n de 8 bits. </font><font style="vertical-align: inherit;">Aqu铆 est谩n los c贸digos ASCII para las letras may煤sculas del alfabeto ingl茅s:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNA</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">01000001</font></font></td>
<td><strong>N</strong></td>
<td>01001110</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>01000010</td>
<td><strong>O</strong></td>
<td>01001111</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>01000011</td>
<td><strong>P</strong></td>
<td>01010000</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>01000100</td>
<td><strong>Q</strong></td>
<td>01010001</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>01000101</td>
<td><strong>R</strong></td>
<td>01010010</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>01000110</td>
<td><strong>S</strong></td>
<td>01010011</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>01000111</td>
<td><strong>T</strong></td>
<td>01010100</td>
</tr>
<tr>
<td><strong>H</strong></td>
<td>01001000</td>
<td><strong>U</strong></td>
<td>01010101</td>
</tr>
<tr>
<td><strong>I</strong></td>
<td>01001001</td>
<td><strong>V</strong></td>
<td>01010110</td>
</tr>
<tr>
<td><strong>J</strong></td>
<td>01001010</td>
<td><strong>W</strong></td>
<td>01010111</td>
</tr>
<tr>
<td><strong>K</strong></td>
<td>01001011</td>
<td><strong>X</strong></td>
<td>01011000</td>
</tr>
<tr>
<td><strong>L</strong></td>
<td>01001100</td>
<td><strong>Y</strong></td>
<td>01011001</td>
</tr>
<tr>
<td><strong>M</strong></td>
<td>01001101</td>
<td><strong>Z</strong></td>
<td>01011010</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un byte por car谩cter es una forma conveniente de almacenar texto. Le permite acceder o modificar f谩cilmente partes del texto, y siempre est谩 claro cu谩ntos bytes se requieren para almacenar N caracteres, o cu谩ntos caracteres se almacenan en N bytes. Sin embargo, esta no es la forma m谩s efectiva en t茅rminos de espacio ocupado. Por ejemplo, en ingl茅s, la letra E se usa con mayor frecuencia y Z es la menos utilizada. Por lo tanto, en t茅rminos de volumen, es m谩s eficiente usar una representaci贸n de bits m谩s corta para E y una m谩s larga para Z, en lugar de asignar el mismo n煤mero de bits a cada car谩cter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un c贸digo que especifica codificaciones de diferentes longitudes a diferentes caracteres de origen se denomina </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c贸digo de longitud variable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El ejemplo m谩s famoso es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el c贸digo Morse.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en el que cada car谩cter est谩 codificado con puntos y guiones, originalmente transmitidos por tel茅grafo con pulsos cortos y largos:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNA</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">norte</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-   </font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- - -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-  - </font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PAGS</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - - </font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">re</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-  </font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- -  -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mi</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"></font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">  - </font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">  </font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- - </font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">   </font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">  -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yo</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> </font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">   -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - - -</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-  -</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-   -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -  </font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-  - -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">METRO</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- -</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- -  </font></font></strong></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uno de los inconvenientes del c贸digo Morse es que una palabra de c贸digo puede ser un prefijo de otra. Por ejemplo,   -  no tiene una decodificaci贸n 煤nica: puede ser F o ER. Esto se resuelve mediante pausas (tres puntos de longitud) entre las letras durante la transmisi贸n. Sin embargo, ser铆a mejor si las palabras de c贸digo no pudieran ser prefijos de otras palabras. Este c贸digo se llama sin </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corregir</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El c贸digo ASCII de una longitud fija no se fija porque las palabras de c贸digo siempre tienen la misma longitud. Pero los c贸digos de longitud variable tambi茅n pueden no repararse. Los n煤meros de tel茅fono a menudo no se corrigen. Antes de que se introdujera el n煤mero telef贸nico de emergencia 112 en Suecia, todos los n煤meros que comenzaban con el 112 tuvieron que cambiarse, y en los Estados Unidos no hay un solo n煤mero telef贸nico que comience con el 911.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para minimizar el tama帽o del mensaje codificado, es mejor usar un c贸digo no fijado en el que los caracteres frecuentes tienen palabras de c贸digo m谩s cortas. </font><font style="vertical-align: inherit;">El c贸digo 贸ptimo ser谩 el que genere el resultado m谩s corto posible: la suma de las longitudes de las palabras de c贸digo, multiplicadas por su frecuencia de aparici贸n, ser谩 la m铆nima posible. </font><font style="vertical-align: inherit;">Esto se llama un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c贸digo sin prefijo con redundancia m铆nima</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un c贸digo Huffman</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en honor del inventor de un algoritmo eficiente para generar dichos c贸digos.</font></font><br>
<br>
<a name="7"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritmo Huffman</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mientras estudiaba materiales para escribir su tesis doctoral sobre ingenier铆a electr贸nica en el MIT, David Huffman asisti贸 a un curso sobre teor铆a de la informaci贸n impartido por Robert Fano. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seg煤n la leyenda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Fano permiti贸 a sus alumnos elegir: escribir el examen o curso final. Huffman eligi贸 este 煤ltimo, y se le dio el tema de buscar c贸digos sin prefijo con una redundancia m铆nima. Se supone que no sab铆a que el propio Fano estaba trabajando en esta tarea en ese momento (el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmo de Shannon-Fano</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fue el m茅todo m谩s famoso en esos a帽os </font><font style="vertical-align: inherit;">). El trabajo de Huffman se public贸 en 1952 bajo el t铆tulo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un m茅todo para la construcci贸n de c贸digos de redundancia m铆nima</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en 1952. Y desde entonces su algoritmo ha sido ampliamente utilizado.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf0/4fe/003/cf04fe00303a663594eea8e8db063002.jpg"></div><br>
<i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comunicado de prensa de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> David Huffman </font><font style="vertical-align: inherit;">UC Santa Cruz. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El algoritmo de Huffman crea c贸digo no fijado con redundancia m铆nima para el conjunto de caracteres y su frecuencia de uso. </font><font style="vertical-align: inherit;">El algoritmo selecciona repetidamente dos caracteres que es menos probable que se encuentren en los datos de origen, por ejemplo, X e Y, y los reemplaza con un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">car谩cter compuesto que</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> significa "X o Y". </font><font style="vertical-align: inherit;">La frecuencia de aparici贸n de un s铆mbolo compuesto es la suma de las frecuencias de dos s铆mbolos fuente. </font><font style="vertical-align: inherit;">Las palabras de c贸digo para X e Y pueden ser cualquier palabra de c贸digo asignada al car谩cter compuesto "X o Y" seguido de 0 o 1 para distinguir los caracteres originales. </font><font style="vertical-align: inherit;">Cuando los datos de entrada se reducen a un car谩cter, el algoritmo deja de funcionar ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explicaci贸n en video</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu铆 hay un ejemplo del algoritmo que funciona en un peque帽o conjunto de caracteres:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S铆mbolo</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frecuencia</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6 6</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 4</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">re</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primera iteraci贸n de procesamiento:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e90/a8f/4e4/e90a8f4e47c49cd14ca3a55f884d55e3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los dos s铆mbolos m谩s raros, C y D, se eliminan del conjunto y se reemplazan por un s铆mbolo compuesto cuya frecuencia es la suma de las frecuencias C y D:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e9/b0b/aed/7e9b0baeda34fc4d368c933bed7e1d15.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora los s铆mbolos m谩s raros son B y un s铆mbolo compuesto con una frecuencia de 5. Se eliminan del conjunto y se reemplazan con un s铆mbolo compuesto con una frecuencia de 9:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bca/94b/ad6/bca94bad698775402e8bab2c6a20f664.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, A y un s铆mbolo compuesto con una frecuencia de 9 se combinan en un nuevo s铆mbolo con una frecuencia de 15:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/260/aa3/800/260aa38005cf701421881214915d859a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo el conjunto se redujo a un personaje, el procesamiento se ha completado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El algoritmo cre贸 una estructura llamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el 谩rbol Huffman</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Los caracteres de entrada son hojas, y cuanto mayor es la frecuencia de un car谩cter, mayor es su ubicaci贸n. </font><font style="vertical-align: inherit;">A partir de la ra铆z del 谩rbol, puede generar palabras de c贸digo para los caracteres agregando 0 o 1 al moverse hacia la izquierda o hacia la derecha, respectivamente. </font><font style="vertical-align: inherit;">Resulta as铆:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S铆mbolo</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La palabra clave</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">re</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ninguna palabra de c贸digo es un prefijo para ninguna otra. Cuanto m谩s a menudo aparece un s铆mbolo, m谩s corta es su palabra de c贸digo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El 谩rbol tambi茅n se puede usar para decodificar: comenzamos desde la ra铆z y vamos hacia la derecha o hacia la izquierda para el valor con 0 o 1 delante del car谩cter. Por ejemplo, la l铆nea 010100 se decodifica en ABBA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que la longitud de cada palabra de c贸digo es equivalente a la profundidad del nodo del 谩rbol correspondiente. Como veremos en la siguiente parte, no necesitamos un 谩rbol real para asignar palabras de c贸digo. Es suficiente saber la longitud de las palabras mismas. Por lo tanto, el resultado de nuestra implementaci贸n del algoritmo Huffman ser谩 la longitud de las palabras de c贸digo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para almacenar el conjunto de caracteres y encontrar eficientemente las frecuencias m谩s bajas, utilizaremos la estructura de datos de almacenamiento </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">din谩mico binario</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En particular, estamos interesados en</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min-heap</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ya que el valor m铆nimo debe estar en la parte superior.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Swap the 32-bit values pointed to by a and b. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap32</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> *a, <span class="hljs-keyword">uint32_t</span> *b)</span>
</span>{
        <span class="hljs-keyword">uint32_t</span> tmp;<font></font>
<font></font>
        tmp = *a;<font></font>
        *a = *b;<font></font>
        *b = tmp;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Move element i in the n-element heap down to restore the minheap property. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">minheap_down</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> *heap, <span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">size_t</span> i)</span>
</span>{
        <span class="hljs-keyword">size_t</span> left, right, min;<font></font>
<font></font>
        assert(i &gt;= <span class="hljs-number">1</span> &amp;&amp; i &lt;= n &amp;&amp; <span class="hljs-string">"i must be inside the heap"</span>);<font></font>
<font></font>
        <span class="hljs-comment">/* While the ith element has at least one child. */</span>
        <span class="hljs-keyword">while</span> (i * <span class="hljs-number">2</span> &lt;= n) {<font></font>
                left = i * <span class="hljs-number">2</span>;<font></font>
                right = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<font></font>
<font></font>
                <span class="hljs-comment">/* Find the child with lowest value. */</span><font></font>
                min = left;<font></font>
                <span class="hljs-keyword">if</span> (right &lt;= n &amp;&amp; heap[right] &lt; heap[left]) {<font></font>
                        min = right;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Move i down if it is larger. */</span>
                <span class="hljs-keyword">if</span> (heap[min] &lt; heap[i]) {<font></font>
                        swap32(&amp;heap[min], &amp;heap[i]);<font></font>
                        i = min;<font></font>
                } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Establish minheap property for heap[1..n]. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">minheap_heapify</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> *heap, <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;<font></font>
<font></font>
        <span class="hljs-comment">/* Floyd's algorithm. */</span>
        <span class="hljs-keyword">for</span> (i = n / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i--) {<font></font>
                minheap_down(heap, n, i);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para rastrear la frecuencia de los </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">caracteres, utilizaremos un mont贸n de </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elementos. </font><font style="vertical-align: inherit;">Adem谩s, cada vez que se crea un s铆mbolo compuesto, queremos "vincular" ambos s铆mbolos de origen. </font><font style="vertical-align: inherit;">Por lo tanto, cada s铆mbolo tendr谩 un "elemento de comunicaci贸n". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para almacenar el </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mont贸n de </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elementos </font><font style="vertical-align: inherit;">y </font><font style="vertical-align: inherit;">los elementos de comunicaci贸n, utilizaremos una matriz de </font></font><code>n * 2 + 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elementos. </font><font style="vertical-align: inherit;">Cuando dos caracteres en el mont贸n se reemplazan por uno, usaremos el segundo elemento para guardar el enlace al nuevo personaje. </font><font style="vertical-align: inherit;">Este enfoque se basa en la implementaci贸n de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesti贸n de Gigabytes de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Witten, Moffat y Bell.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cada nodo del mont贸n, utilizaremos los 16 bits m谩s significativos para almacenar la frecuencia del s铆mbolo, y los 16 bits menos significativos para almacenar el 铆ndice del elemento de comunicaci贸n del s铆mbolo. Debido al uso de bits altos, la diferencia de frecuencia estar谩 determinada por el resultado de una comparaci贸n de 32 bits entre dos elementos del mont贸n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debido a esta representaci贸n, debemos asegurarnos de que la frecuencia de los caracteres siempre se ajuste a 16 bits. Despu茅s de completar el algoritmo, el s铆mbolo compuesto final tendr谩 la frecuencia de todos los s铆mbolos combinados, es decir, esta suma debe colocarse en 16 bits. Nuestra implementaci贸n Deflate verificar谩 esto procesando simult谩neamente hasta 64,535 caracteres. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los s铆mbolos con frecuencia cero recibir谩n palabras de c贸digo de longitud cero y no participar谩n en la compilaci贸n de la codificaci贸n.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si la palabra de c贸digo alcanza la profundidad m谩xima especificada, "suavizaremos" la distribuci贸n de frecuencia imponiendo un l铆mite de frecuencia e intentaremos nuevamente (s铆, con la ayuda </font></font><code>goto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Existen formas m谩s sofisticadas de codificaci贸n Huffman con profundidad limitada, pero esta es simple y eficiente.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_HUFFMAN_SYMBOLS 288      <span class="hljs-comment">/* Deflate uses max 288 symbols. */</span></span><font></font>
<font></font>
<span class="hljs-comment">/* Construct a Huffman code for n symbols with the frequencies in freq, and
 * codeword length limited to max_len. The sum of the frequencies must be &lt;=
 * UINT16_MAX. max_len must be large enough that a code is always possible,
 * i.e. 2 ** max_len &gt;= n. Symbols with zero frequency are not part of the code
 * and get length zero. Outputs the codeword lengths in lengths[0..n-1]. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">compute_huffman_lengths</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> *freqs, <span class="hljs-keyword">size_t</span> n,
                                    <span class="hljs-keyword">uint8_t</span> max_len, <span class="hljs-keyword">uint8_t</span> *lengths)</span>
</span>{
        <span class="hljs-keyword">uint32_t</span> nodes[MAX_HUFFMAN_SYMBOLS * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>], p, q;
        <span class="hljs-keyword">uint16_t</span> freq;
        <span class="hljs-keyword">size_t</span> i, h, l;
        <span class="hljs-keyword">uint16_t</span> freq_cap = UINT16_MAX;<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span>
        <span class="hljs-keyword">uint32_t</span> freq_sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                freq_sum += freqs[i];<font></font>
        }<font></font>
        assert(freq_sum &lt;= UINT16_MAX &amp;&amp; <span class="hljs-string">"Frequency sum too large!"</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
        assert(n &lt;= MAX_HUFFMAN_SYMBOLS);<font></font>
        assert((<span class="hljs-number">1U</span> &lt;&lt; max_len) &gt;= n &amp;&amp; <span class="hljs-string">"max_len must be large enough"</span>);<font></font>
<font></font>
try_again:<font></font>
        <span class="hljs-comment">/* Initialize the heap. h is the heap size. */</span>
        h = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                freq = freqs[i];<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (freq == <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">/* Ignore zero-frequency symbols. */</span><font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (freq &gt; freq_cap) {<font></font>
                        freq = freq_cap; <span class="hljs-comment">/* Enforce the frequency cap. */</span><font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* High 16 bits: Symbol frequency.
                   Low 16 bits:  Symbol link element index. */</span><font></font>
                h++;<font></font>
                nodes[h] = ((<span class="hljs-keyword">uint32_t</span>)freq &lt;&lt; <span class="hljs-number">16</span>) | (<span class="hljs-keyword">uint32_t</span>)(n + h);<font></font>
        }<font></font>
        minheap_heapify(nodes, h);<font></font>
<font></font>
        <span class="hljs-comment">/* Special case for less than two non-zero symbols. */</span>
        <span class="hljs-keyword">if</span> (h &lt; <span class="hljs-number">2</span>) {
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                        lengths[i] = (freqs[i] == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Build the Huffman tree. */</span>
        <span class="hljs-keyword">while</span> (h &gt; <span class="hljs-number">1</span>) {
                <span class="hljs-comment">/* Remove the lowest frequency node p from the heap. */</span>
                p = nodes[<span class="hljs-number">1</span>];<font></font>
                nodes[<span class="hljs-number">1</span>] = nodes[h--];<font></font>
                minheap_down(nodes, h, <span class="hljs-number">1</span>);<font></font>
<font></font>
                <span class="hljs-comment">/* Get q, the next lowest frequency node. */</span>
                q = nodes[<span class="hljs-number">1</span>];<font></font>
<font></font>
                <span class="hljs-comment">/* Replace q with a new symbol with the combined frequencies of
                   p and q, and with the no longer used h+1'th node as the
                   link element. */</span>
                nodes[<span class="hljs-number">1</span>] = ((p &amp; <span class="hljs-number">0xffff0000</span>) + (q &amp; <span class="hljs-number">0xffff0000</span>))<font></font>
                           | (<span class="hljs-keyword">uint32_t</span>)(h + <span class="hljs-number">1</span>);<font></font>
<font></font>
                <span class="hljs-comment">/* Set the links of p and q to point to the link element of
                   the new node. */</span>
                nodes[p &amp; <span class="hljs-number">0xffff</span>] = nodes[q &amp; <span class="hljs-number">0xffff</span>] = (<span class="hljs-keyword">uint32_t</span>)(h + <span class="hljs-number">1</span>);<font></font>
<font></font>
                <span class="hljs-comment">/* Move the new symbol down to restore heap property. */</span>
                minheap_down(nodes, h, <span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Compute the codeword length for each symbol. */</span>
        h = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {
                <span class="hljs-keyword">if</span> (freqs[i] == <span class="hljs-number">0</span>) {<font></font>
                        lengths[i] = <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
                h++;<font></font>
<font></font>
                <span class="hljs-comment">/* Link element for the i'th symbol. */</span><font></font>
                p = nodes[n + h];<font></font>
<font></font>
                <span class="hljs-comment">/* Follow the links until we hit the root (link index 2). */</span>
                l = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">while</span> (p != <span class="hljs-number">2</span>) {<font></font>
                        l++;<font></font>
                        p = nodes[p];<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (l &gt; max_len) {
                        <span class="hljs-comment">/* Lower freq_cap to flatten the distribution. */</span>
                        assert(freq_cap != <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-string">"Cannot lower freq_cap!"</span>);<font></font>
                        freq_cap /= <span class="hljs-number">2</span>;
                        <span class="hljs-keyword">goto</span> try_again;<font></font>
                }<font></font>
<font></font>
                assert(l &lt;= UINT8_MAX);<font></font>
                lengths[i] = (<span class="hljs-keyword">uint8_t</span>)l;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una alternativa elegante a la opci贸n de almacenamiento din谩mico binario es almacenar caracteres en dos colas. </font><font style="vertical-align: inherit;">El primero contiene los caracteres de origen, ordenados por frecuencia. </font><font style="vertical-align: inherit;">Cuando se crea un s铆mbolo compuesto, se agrega de forma secundaria. </font><font style="vertical-align: inherit;">Por lo tanto, el s铆mbolo con la frecuencia m谩s baja siempre estar谩 en la primera posici贸n de una de las colas. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jan van Leeuwen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> describe este enfoque </font><font style="vertical-align: inherit;">en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre la construcci贸n de 谩rboles de Huffman</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (1976). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La codificaci贸n de Huffman es 贸ptima para c贸digos sin prefijo, pero en otros casos existen m茅todos m谩s eficientes: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codificaci贸n aritm茅tica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistemas de n煤meros asim茅tricos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="8"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C贸digos can贸nicos de Huffman</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el ejemplo anterior, construimos un 谩rbol Huffman:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/260/aa3/800/260aa38005cf701421881214915d859a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vamos desde la ra铆z y usamos 0 para la rama izquierda y 1 para la derecha, obtenemos los siguientes c贸digos:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S铆mbolo</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La palabra clave</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">re</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La decisi贸n de usar 0 para la rama izquierda y 1 para la derecha parece arbitraria. </font><font style="vertical-align: inherit;">Si hacemos lo contrario, obtenemos:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S铆mbolo</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La palabra clave</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">01</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">001</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">re</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos marcar arbitrariamente dos ramas que se originan en un nodo con cero y uno (lo principal es que las etiquetas son diferentes), y a煤n as铆 obtener el c贸digo equivalente:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29b/acb/499/29bacb4999e9a3f530f22634846a97b7.png"></div><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S铆mbolo</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La palabra clave</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">once</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">re</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">101</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aunque el algoritmo Huffman proporciona las longitudes de palabra de c贸digo requeridas para c贸digo no fijado con redundancia m铆nima, hay muchas formas de asignar palabras de c贸digo individuales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dada la longitud de la palabra de c贸digo calculada por el algoritmo de Huffman, el c贸digo can贸nico de Huffman asigna palabras de c贸digo a los caracteres de una manera espec铆fica. Esto es 煤til porque le permite almacenar y transmitir longitudes de palabras de c贸digo con datos comprimidos: el decodificador podr谩 recuperar palabras de c贸digo en funci贸n de sus longitudes. Por supuesto, puede almacenar y transmitir frecuencias de s铆mbolos y ejecutar el algoritmo Huffman en el decodificador, pero esto requerir谩 m谩s trabajo y m谩s almacenamiento desde el decodificador. Otra propiedad muy importante es que la estructura de los c贸digos can贸nicos utiliza una decodificaci贸n eficiente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea es asignar palabras de c贸digo a los caracteres secuencialmente, debajo de uno a la vez. La primera palabra de c贸digo es 0. La siguiente ser谩 la palabra con la longitud de la palabra anterior + 1. La primera palabra con una longitud de N se compone de la 煤ltima palabra de longitud N-1, agregando una (para obtener una nueva palabra de c贸digo) y un paso a la izquierda (para aumentar la longitud). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la terminolog铆a del 谩rbol de Hoffman, las palabras de c贸digo se asignan secuencialmente a las hojas en el orden de izquierda a derecha, un nivel a la vez, desplaz谩ndose hacia la izquierda cuando se pasa al siguiente nivel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestro ejemplo ABCD, el algoritmo Huffman asign贸 palabras de c贸digo con longitudes de 1, 2, 3 y 3. La primera palabra es 0. Esta es tambi茅n la 煤ltima palabra de longitud 1. Para la longitud 2, tomamos 0 y agregamos 1 para obtener el siguiente c贸digo, que se convertir谩 en el prefijo de los c贸digos de dos bits , cambie a la izquierda y obtenga 10. Esta es ahora la 煤ltima palabra de longitud 2. Para obtener la longitud 3, sumamos 1 y shift: 110. Para obtener la siguiente palabra de longitud 3, sumamos 1: 111.</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S铆mbolo</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La palabra clave</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">re</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La implementaci贸n del generador de c贸digo can贸nico se muestra a continuaci贸n. </font><font style="vertical-align: inherit;">Tenga en cuenta que el algoritmo Deflate espera que se generen palabras de c贸digo sobre la base del principio LSB-first (primero, el bit menos significativo). </font><font style="vertical-align: inherit;">Es decir, el primer bit de la palabra de c贸digo debe almacenarse en el bit menos significativo. </font><font style="vertical-align: inherit;">Esto significa que necesitamos cambiar el orden de los bits, por ejemplo, usando la tabla de b煤squeda.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_HUFFMAN_BITS 15          <span class="hljs-comment">/* Deflate uses max 15-bit codewords. */</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">compute_canonical_code</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> *codewords, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *lengths,
                                   <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;
        <span class="hljs-keyword">uint16_t</span> count[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>] = {<span class="hljs-number">0</span>};
        <span class="hljs-keyword">uint16_t</span> code[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">int</span> l;<font></font>
<font></font>
        <span class="hljs-comment">/* Count the number of codewords of each length. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                count[lengths[i]]++;<font></font>
        }<font></font>
        count[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* Ignore zero-length codes. */</span><font></font>
<font></font>
        <span class="hljs-comment">/* Compute the first codeword for each length. */</span>
        code[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (l = <span class="hljs-number">1</span>; l &lt;= MAX_HUFFMAN_BITS; l++) {<font></font>
                code[l] = (<span class="hljs-keyword">uint16_t</span>)((code[l - <span class="hljs-number">1</span>] + count[l - <span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Assign a codeword for each symbol. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                l = lengths[i];<font></font>
                <span class="hljs-keyword">if</span> (l == <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                codewords[i] = reverse16(code[l]++, l); <span class="hljs-comment">/* Make it LSB-first. */</span><font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Reverse the n least significant bits of x.
   The (16 - n) most significant bits of the result will be zero. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint16_t</span> <span class="hljs-title">reverse16</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> x, <span class="hljs-keyword">int</span> n)</span>
</span>{
        <span class="hljs-keyword">uint16_t</span> lo, hi;
        <span class="hljs-keyword">uint16_t</span> reversed;<font></font>
<font></font>
        assert(n &gt; <span class="hljs-number">0</span>);<font></font>
        assert(n &lt;= <span class="hljs-number">16</span>);<font></font>
<font></font>
        lo = x &amp; <span class="hljs-number">0xff</span>;<font></font>
        hi = x &gt;&gt; <span class="hljs-number">8</span>;<font></font>
<font></font>
        reversed = (<span class="hljs-keyword">uint16_t</span>)((reverse8_tbl[lo] &lt;&lt; <span class="hljs-number">8</span>) | reverse8_tbl[hi]);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> reversed &gt;&gt; (<span class="hljs-number">16</span> - n);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora p贸ngalo todo junto y escriba el c贸digo de inicializaci贸n del codificador:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">huffman_encoder_t</span> <span class="hljs-title">huffman_encoder_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">huffman_encoder_t</span> {</span>
        <span class="hljs-keyword">uint16_t</span> codewords[MAX_HUFFMAN_SYMBOLS]; <span class="hljs-comment">/* LSB-first codewords. */</span>
        <span class="hljs-keyword">uint8_t</span> lengths[MAX_HUFFMAN_SYMBOLS];    <span class="hljs-comment">/* Codeword lengths. */</span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Initialize a Huffman encoder based on the n symbol frequencies. */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">huffman_encoder_init</span><span class="hljs-params">(<span class="hljs-keyword">huffman_encoder_t</span> *e, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> *freqs, <span class="hljs-keyword">size_t</span> n,
                          <span class="hljs-keyword">uint8_t</span> max_codeword_len)</span>
</span>{<font></font>
        assert(n &lt;= MAX_HUFFMAN_SYMBOLS);<font></font>
        assert(max_codeword_len &lt;= MAX_HUFFMAN_BITS);<font></font>
<font></font>
        compute_huffman_lengths(freqs, n, max_codeword_len, e-&gt;lengths);<font></font>
        compute_canonical_code(e-&gt;codewords, e-&gt;lengths, n);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi茅n hacemos una funci贸n para configurar el codificador usando las longitudes de c贸digo ya calculadas:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Initialize a Huffman encoder based on the n codeword lengths. */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">huffman_encoder_init2</span><span class="hljs-params">(<span class="hljs-keyword">huffman_encoder_t</span> *e, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *lengths,
                           <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                e-&gt;lengths[i] = lengths[i];<font></font>
        }<font></font>
        compute_canonical_code(e-&gt;codewords, e-&gt;lengths, n);<font></font>
}<font></font>
</code></pre><br>
<a name="9"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decodificaci贸n Huffman eficiente</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La forma m谩s f谩cil de decodificar a Huffman es atravesar el 谩rbol comenzando desde la ra铆z, leyendo un bit de entrada a la vez y decidiendo qu茅 rama tomar a continuaci贸n, izquierda o derecha. </font><font style="vertical-align: inherit;">Cuando se alcanza un nodo hoja, es un car谩cter decodificado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este m茅todo a menudo se ense帽a en universidades y libros. </font><font style="vertical-align: inherit;">Es simple y elegante, pero el procesamiento de un bit a la vez es demasiado lento. </font><font style="vertical-align: inherit;">Es mucho m谩s r谩pido decodificar usando la tabla de b煤squeda. </font><font style="vertical-align: inherit;">Para el ejemplo anterior, en el que la longitud m谩xima de la palabra de c贸digo es de tres bits, puede usar la siguiente tabla:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pedacitos</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S铆mbolo</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Longitud de palabra de c贸digo</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 01</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">re</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aunque solo hay cuatro caracteres, necesitamos una tabla con ocho entradas para cubrir todas las combinaciones posibles de tres bits. </font><font style="vertical-align: inherit;">Los s铆mbolos con palabras de c贸digo de menos de tres bits tienen varias entradas en la tabla. </font><font style="vertical-align: inherit;">Por ejemplo, la palabra 10 se "complement贸" con </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 para cubrir todas las combinaciones de tres bits que comienzan con 10. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para decodificar de esta manera, debe indexar en la tabla con los siguientes tres bits de entrada e inmediatamente encontrar el car谩cter correspondiente y la longitud de su palabra de c贸digo. </font><font style="vertical-align: inherit;">La longitud es importante, porque a pesar de mirar los siguientes tres bits, necesitamos obtener el mismo n煤mero de bits de entrada que la longitud de la palabra de c贸digo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El m茅todo basado en la tabla de b煤squeda funciona muy r谩pidamente, pero tiene un inconveniente: el tama帽o de la tabla se duplica con cada bit adicional en la longitud de la palabra de c贸digo. Es decir, la construcci贸n de la tabla se ralentiza exponencialmente y, si deja de caber en la memoria cach茅 del procesador, el m茅todo comienza a funcionar lentamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debido a esto, la tabla de b煤squeda generalmente se usa solo para palabras de c贸digo que no tienen una longitud mayor. Y para palabras m谩s largas, tome un enfoque diferente. As铆 como la codificaci贸n de Huffman asigna palabras de c贸digo m谩s cortas a caracteres m谩s frecuentes, el uso de una tabla de b煤squeda para palabras de c贸digo cortas es en muchos casos una excelente optimizaci贸n. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En zlib</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se utilizan varios niveles de tablas de b煤squeda. </font><font style="vertical-align: inherit;">Si la palabra de c贸digo es demasiado larga para la primera tabla, la b煤squeda ir谩 a la tabla secundaria para indexar los bits restantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero hay otro m茅todo muy elegante, basado en las propiedades de los c贸digos can贸nicos de Huffman. </font><font style="vertical-align: inherit;">Se describe en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la Implementaci贸n de c贸digos de prefijo de redundancia m铆nima</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Moffat y Turpin, 1997), y tambi茅n se explica en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Lost Huffman Paper de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Charles Bloom. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tomemos las palabras de c贸digo de la versi贸n can贸nica: 0, 10, 110, 111. Realizaremos un seguimiento de las primeras palabras de c贸digo de cada longitud, as铆 como el n煤mero de cada palabra de c贸digo en la secuencia general - "铆ndice de s铆mbolo".</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Longitud de palabra de c贸digo</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primera palabra de c贸digo</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primer 铆ndice de caracteres</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 (A)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 (B)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 (C)</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que las palabras de c贸digo se asignan secuencialmente, si conocemos el n煤mero de bits, podemos encontrar en la tabla anterior el car谩cter que representan estos bits. </font><font style="vertical-align: inherit;">Por ejemplo, para el 111 de tres bits, vemos que este es un desplazamiento de uno de la primera palabra de c贸digo de esta longitud (110). </font><font style="vertical-align: inherit;">El primer 铆ndice de caracteres de esta longitud es 3, y un desplazamiento de uno nos da un 铆ndice de 4. Otra tabla compara el 铆ndice de caracteres con el car谩cter:</font></font><br>
<br>
<pre><code class="cpp hljs">sym_idx = d-&gt;first_symbol[len] + (bits - d-&gt;first_code[len]);<font></font>
sym = d-&gt;syms[sym_idx];<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una peque帽a optimizaci贸n: en lugar de almacenar por separado el primer 铆ndice de caracteres y la primera palabra de c贸digo, podemos almacenar el primer 铆ndice en la tabla menos la primera palabra de c贸digo:</font></font><br>
<br>
<pre><code class="cpp hljs">sym_idx = d-&gt;offset_first_sym_idx[len] + bits;<font></font>
sym = d-&gt;syms[sym_idx];<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comprender cu谩ntos bits deben estimarse, nuevamente utilizamos la propiedad de secuencia de c贸digo. </font><font style="vertical-align: inherit;">En nuestro ejemplo, todas las palabras de c贸digo v谩lidas de un bit son estrictamente menos de 1, dos bits, estrictamente menos de 11, tres bits, menos de 1000 (de hecho, es cierto para todos los valores de tres bits). </font><font style="vertical-align: inherit;">En otras palabras, la palabra de c贸digo de N bits v谩lida debe ser estrictamente menor que la primera palabra de c贸digo de N bits m谩s el n煤mero de palabras de c贸digo de N bits. </font><font style="vertical-align: inherit;">Adem谩s, podemos desplazar estos l铆mites a la izquierda para que sean de tres bits de ancho. </font><font style="vertical-align: inherit;">Llam茅moslo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bits restrictivos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para cada una de las longitudes de palabras de c贸digo:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Longitud de palabra de c贸digo</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bits l铆mite</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></td>
</tr>
</tbody></table></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El limitador para la longitud 3 se ha desbordado a 4 bits, pero esto solo significa que cualquier palabra de tres bits servir谩. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos buscar entre los datos de entrada de tres bits y compararlos con los bits restrictivos para comprender cu谩nto dura nuestra palabra de c贸digo. </font><font style="vertical-align: inherit;">Despu茅s de la finalizaci贸n, cambiamos los bits de entrada, solo para calcular su n煤mero correcto, y luego encontramos el 铆ndice de caracteres:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (len = <span class="hljs-number">1</span>; len &lt;= <span class="hljs-number">3</span>; len++) {
        <span class="hljs-keyword">if</span> (bits &lt; d-&gt;sentinel_bits[len]) {<font></font>
                bits &gt;&gt;= <span class="hljs-number">3</span> - len;  <span class="hljs-comment">/* Get the len most significant bits. */</span><font></font>
                sym_idx = d-&gt;offset_first_sym_idx[len] + bits;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La complejidad temporal del proceso es lineal con respecto al n煤mero de bits en las palabras de c贸digo, pero el lugar se gasta de manera eficiente, solo se requiere cargar y comparar en cada paso, y dado que las palabras de c贸digo m谩s cortas son m谩s comunes, el m茅todo permite optimizar la compresi贸n en muchas situaciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C贸digo de decodificador completo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HUFFMAN_LOOKUP_TABLE_BITS 8  <span class="hljs-comment">/* Seems a good trade-off. */</span></span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">huffman_decoder_t</span> <span class="hljs-title">huffman_decoder_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">huffman_decoder_t</span> {</span>
        <span class="hljs-comment">/* Lookup table for fast decoding of short codewords. */</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
                <span class="hljs-keyword">uint16_t</span> sym : <span class="hljs-number">9</span>;  <span class="hljs-comment">/* Wide enough to fit the max symbol nbr. */</span>
                <span class="hljs-keyword">uint16_t</span> len : <span class="hljs-number">7</span>;  <span class="hljs-comment">/* 0 means no symbol. */</span>
        } table[<span class="hljs-number">1U</span> &lt;&lt; HUFFMAN_LOOKUP_TABLE_BITS];<font></font>
<font></font>
        <span class="hljs-comment">/* "Sentinel bits" value for each codeword length. */</span>
        <span class="hljs-keyword">uint16_t</span> sentinel_bits[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];<font></font>
<font></font>
        <span class="hljs-comment">/* First symbol index minus first codeword mod 2**16 for each length. */</span>
        <span class="hljs-keyword">uint16_t</span> offset_first_sym_idx[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];<font></font>
<font></font>
        <span class="hljs-comment">/* Map from symbol index to symbol. */</span>
        <span class="hljs-keyword">uint16_t</span> syms[MAX_HUFFMAN_SYMBOLS];
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span>
        <span class="hljs-keyword">size_t</span> num_syms;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Get the n least significant bits of x. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">lsb</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> x, <span class="hljs-keyword">int</span> n)</span>
</span>{<font></font>
        assert(n &gt;= <span class="hljs-number">0</span> &amp;&amp; n &lt;= <span class="hljs-number">63</span>);
        <span class="hljs-keyword">return</span> x &amp; (((<span class="hljs-keyword">uint64_t</span>)<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Use the decoder d to decode a symbol from the LSB-first zero-padded bits.
 * Returns the decoded symbol number or -1 if no symbol could be decoded.
 * *num_used_bits will be set to the number of bits used to decode the symbol,
 * or zero if no symbol could be decoded. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">huffman_decode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_decoder_t</span> *d, <span class="hljs-keyword">uint16_t</span> bits,
                                 <span class="hljs-keyword">size_t</span> *num_used_bits)</span>
</span>{
        <span class="hljs-keyword">uint64_t</span> lookup_bits;
        <span class="hljs-keyword">size_t</span> l;
        <span class="hljs-keyword">size_t</span> sym_idx;<font></font>
<font></font>
        <span class="hljs-comment">/* First try the lookup table. */</span><font></font>
        lookup_bits = lsb(bits, HUFFMAN_LOOKUP_TABLE_BITS);<font></font>
        assert(lookup_bits &lt; <span class="hljs-keyword">sizeof</span>(d-&gt;table) / <span class="hljs-keyword">sizeof</span>(d-&gt;table[<span class="hljs-number">0</span>]));
        <span class="hljs-keyword">if</span> (d-&gt;table[lookup_bits].len != <span class="hljs-number">0</span>) {<font></font>
                assert(d-&gt;table[lookup_bits].len &lt;= HUFFMAN_LOOKUP_TABLE_BITS);<font></font>
                assert(d-&gt;table[lookup_bits].sym &lt; d-&gt;num_syms);<font></font>
<font></font>
                *num_used_bits = d-&gt;table[lookup_bits].len;<font></font>
                <span class="hljs-keyword">return</span> d-&gt;table[lookup_bits].sym;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Then do canonical decoding with the bits in MSB-first order. */</span><font></font>
        bits = reverse16(bits, MAX_HUFFMAN_BITS);<font></font>
        <span class="hljs-keyword">for</span> (l = HUFFMAN_LOOKUP_TABLE_BITS + <span class="hljs-number">1</span>; l &lt;= MAX_HUFFMAN_BITS; l++) {
                <span class="hljs-keyword">if</span> (bits &lt; d-&gt;sentinel_bits[l]) {<font></font>
                        bits &gt;&gt;= MAX_HUFFMAN_BITS - l;<font></font>
<font></font>
                        sym_idx = (<span class="hljs-keyword">uint16_t</span>)(d-&gt;offset_first_sym_idx[l] + bits);<font></font>
                        assert(sym_idx &lt; d-&gt;num_syms);<font></font>
<font></font>
                        *num_used_bits = l;<font></font>
                        <span class="hljs-keyword">return</span> d-&gt;syms[sym_idx];<font></font>
                }<font></font>
        }<font></font>
<font></font>
        *num_used_bits = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para configurar el decodificador, calcularemos previamente los c贸digos can贸nicos, como para </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">huffman_encoder_init</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y completaremos diferentes tablas:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Initialize huffman decoder d for a code defined by the n codeword lengths.
   Returns false if the codeword lengths do not correspond to a valid prefix
   code. */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">huffman_decoder_init</span><span class="hljs-params">(<span class="hljs-keyword">huffman_decoder_t</span> *d, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *lengths,
                          <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;
        <span class="hljs-keyword">uint16_t</span> count[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>] = {<span class="hljs-number">0</span>};
        <span class="hljs-keyword">uint16_t</span> code[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">uint32_t</span> s;
        <span class="hljs-keyword">uint16_t</span> sym_idx[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">int</span> l;<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span><font></font>
        assert(n &lt;= MAX_HUFFMAN_SYMBOLS);<font></font>
        d-&gt;num_syms = n;<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
        <span class="hljs-comment">/* Zero-initialize the lookup table. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(d-&gt;table) / <span class="hljs-keyword">sizeof</span>(d-&gt;table[<span class="hljs-number">0</span>]); i++) {<font></font>
                d-&gt;table[i].len = <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Count the number of codewords of each length. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                assert(lengths[i] &lt;= MAX_HUFFMAN_BITS);<font></font>
                count[lengths[i]]++;<font></font>
        }<font></font>
        count[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">/* Ignore zero-length codewords. */</span><font></font>
<font></font>
        <span class="hljs-comment">/* Compute sentinel_bits and offset_first_sym_idx for each length. */</span>
        code[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<font></font>
        sym_idx[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (l = <span class="hljs-number">1</span>; l &lt;= MAX_HUFFMAN_BITS; l++) {
                <span class="hljs-comment">/* First canonical codeword of this length. */</span>
                code[l] = (<span class="hljs-keyword">uint16_t</span>)((code[l - <span class="hljs-number">1</span>] + count[l - <span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">1</span>);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (count[l] != <span class="hljs-number">0</span> &amp;&amp; code[l] + count[l] - <span class="hljs-number">1</span> &gt; (<span class="hljs-number">1U</span> &lt;&lt; l) - <span class="hljs-number">1</span>) {
                        <span class="hljs-comment">/* The last codeword is longer than l bits. */</span>
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
<font></font>
                s = (<span class="hljs-keyword">uint32_t</span>)((code[l] + count[l]) &lt;&lt; (MAX_HUFFMAN_BITS - l));<font></font>
                d-&gt;sentinel_bits[l] = (<span class="hljs-keyword">uint16_t</span>)s;<font></font>
                assert(d-&gt;sentinel_bits[l] == s &amp;&amp; <span class="hljs-string">"No overflow."</span>);<font></font>
<font></font>
                sym_idx[l] = sym_idx[l - <span class="hljs-number">1</span>] + count[l - <span class="hljs-number">1</span>];<font></font>
                d-&gt;offset_first_sym_idx[l] = sym_idx[l] - code[l];<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Build mapping from index to symbol and populate the lookup table. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                l = lengths[i];<font></font>
                <span class="hljs-keyword">if</span> (l == <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                d-&gt;syms[sym_idx[l]] = (<span class="hljs-keyword">uint16_t</span>)i;<font></font>
                sym_idx[l]++;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (l &lt;= HUFFMAN_LOOKUP_TABLE_BITS) {<font></font>
                        table_insert(d, i, l, code[l]);<font></font>
                        code[l]++;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">table_insert</span><span class="hljs-params">(<span class="hljs-keyword">huffman_decoder_t</span> *d, <span class="hljs-keyword">size_t</span> sym, <span class="hljs-keyword">int</span> len,
                         <span class="hljs-keyword">uint16_t</span> codeword)</span>
</span>{
        <span class="hljs-keyword">int</span> pad_len;
        <span class="hljs-keyword">uint16_t</span> padding, index;<font></font>
<font></font>
        assert(len &lt;= HUFFMAN_LOOKUP_TABLE_BITS);<font></font>
<font></font>
        codeword = reverse16(codeword, len); <span class="hljs-comment">/* Make it LSB-first. */</span><font></font>
        pad_len = HUFFMAN_LOOKUP_TABLE_BITS - len;<font></font>
<font></font>
        <span class="hljs-comment">/* Pad the pad_len upper bits with all bit combinations. */</span>
        <span class="hljs-keyword">for</span> (padding = <span class="hljs-number">0</span>; padding &lt; (<span class="hljs-number">1U</span> &lt;&lt; pad_len); padding++) {<font></font>
                index = (<span class="hljs-keyword">uint16_t</span>)(codeword | (padding &lt;&lt; len));<font></font>
                d-&gt;table[index].sym = (<span class="hljs-keyword">uint16_t</span>)sym;<font></font>
                d-&gt;table[index].len = (<span class="hljs-keyword">uint16_t</span>)len;<font></font>
<font></font>
                assert(d-&gt;table[index].sym == sym &amp;&amp; <span class="hljs-string">"Fits in bitfield."</span>);<font></font>
                assert(d-&gt;table[index].len == len &amp;&amp; <span class="hljs-string">"Fits in bitfield."</span>);<font></font>
        }<font></font>
}<font></font>
</code></pre><br>
<a name="10"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desinflar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El algoritmo de desinflado, introducido en PKZip 2.04c en 1993, es un m茅todo de compresi贸n est谩ndar en archivos Zip modernos. </font><font style="vertical-align: inherit;">Tambi茅n se usa en gzip, PNG y muchos otros formatos. </font><font style="vertical-align: inherit;">Utiliza una combinaci贸n de compresi贸n LZ77 y codificaci贸n Huffman, que discutiremos e implementaremos en esta secci贸n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de Deflate, PKZip usaba m茅todos de compresi贸n Shrink, Reduce e Implode. </font><font style="vertical-align: inherit;">Hoy son raros, aunque despu茅s de Deflate todav铆a estuvieron en uso por alg煤n tiempo, porque consumieron menos memoria. </font><font style="vertical-align: inherit;">Pero no los consideraremos.</font></font><br>
<br>
<a name="11"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corrientes de bits</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deflate almacena las palabras de c贸digo de Huffman en un flujo de bits de acuerdo con el principio LSB-first. Esto significa que el primer bit de la secuencia se almacena en el bit menos significativo del primer byte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere un flujo de bits (leer de izquierda a derecha) 1-0-0-1-1. Cuando se almacena de acuerdo con el principio LSB-first, el valor del byte se convierte en 0b00011001 (binario) o 0x19 (hexadecimal). Puede parecer que el flujo simplemente se representa al rev茅s (en cierto sentido, lo es), pero la ventaja es que es m谩s f谩cil para nosotros obtener los primeros N bits de una palabra de computadora: simplemente ocultamos los N bits menos significativos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estos procedimientos est谩n tomados de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bitstream.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Input bitstream. */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">istream_t</span> <span class="hljs-title">istream_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">istream_t</span> {</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src;  <span class="hljs-comment">/* Source bytes. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *end;  <span class="hljs-comment">/* Past-the-end byte of src. */</span>
        <span class="hljs-keyword">size_t</span> bitpos;       <span class="hljs-comment">/* Position of the next bit to read. */</span>
        <span class="hljs-keyword">size_t</span> bitpos_end;   <span class="hljs-comment">/* Position of past-the-end bit. */</span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Initialize an input stream to present the n bytes from src as an LSB-first
 * bitstream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">istream_init</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> n)</span>
</span>{<font></font>
        is-&gt;src = src;<font></font>
        is-&gt;end = src + n;<font></font>
        is-&gt;bitpos = <span class="hljs-number">0</span>;<font></font>
        is-&gt;bitpos_end = n * <span class="hljs-number">8</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestro decodificador Huffman necesita mirar los siguientes bits en la secuencia (suficientes bits para la palabra de c贸digo m谩s larga posible), y luego continuar la secuencia por la cantidad de bits utilizados por el s铆mbolo decodificado:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ISTREAM_MIN_BITS (64 - 7)</span><font></font>
<font></font>
<span class="hljs-comment">/* Get the next bits from the input stream. The number of bits returned is
 * between ISTREAM_MIN_BITS and 64, depending on the position in the stream, or
 * fewer if the end of stream is reached. The upper bits are zero-padded. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">istream_bits</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">istream_t</span> *is)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *next;
        <span class="hljs-keyword">uint64_t</span> bits;
        <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
        next = is-&gt;src + (is-&gt;bitpos / <span class="hljs-number">8</span>);<font></font>
<font></font>
        assert(next &lt;= is-&gt;end &amp;&amp; <span class="hljs-string">"Cannot read past end of stream."</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (is-&gt;end - next &gt;= <span class="hljs-number">8</span>) {
                <span class="hljs-comment">/* Common case: read 8 bytes in one go. */</span><font></font>
                bits = read64le(next);<font></font>
        } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">/* Read the available bytes and zero-pad. */</span>
                bits = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; is-&gt;end - next; i++) {<font></font>
                        bits |= (<span class="hljs-keyword">uint64_t</span>)next[i] &lt;&lt; (i * <span class="hljs-number">8</span>);<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> bits &gt;&gt; (is-&gt;bitpos % <span class="hljs-number">8</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Advance n bits in the bitstream if possible. Returns false if that many bits
 * are not available in the stream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">istream_advance</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">size_t</span> n)</span> </span>{
        <span class="hljs-keyword">if</span> (is-&gt;bitpos + n &gt; is-&gt;bitpos_end) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        is-&gt;bitpos += n;<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La conclusi贸n es que en las m谩quinas de 64 bits </font></font><code>istream_bits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generalmente se puede ejecutar como una instrucci贸n de arranque 煤nico y algo de aritm茅tica, dado que los elementos de la estructura </font></font><code>istream_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est谩n en registros. </font><font style="vertical-align: inherit;">read64le se implementa en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bits.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (los compiladores modernos lo convierten en una sola descarga de 64 bits utilizando el principio little-endian):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Read a 64-bit value from p in little-endian byte order. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">read64le</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p)</span>
</span>{
        <span class="hljs-comment">/* The one true way, see
         * https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html */</span>
        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">0</span>)  |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>)  |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">16</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">24</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-number">32</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">5</span>] &lt;&lt; <span class="hljs-number">40</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">6</span>] &lt;&lt; <span class="hljs-number">48</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">7</span>] &lt;&lt; <span class="hljs-number">56</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi茅n necesitamos una funci贸n para continuar el flujo de bits hasta el borde del siguiente byte:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Round x up to the next multiple of m, which must be a power of 2. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">round_up</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> x, <span class="hljs-keyword">size_t</span> m)</span>
</span>{<font></font>
        assert((m &amp; (m - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-string">"m must be a power of two"</span>);
        <span class="hljs-keyword">return</span> (x + m - <span class="hljs-number">1</span>) &amp; (<span class="hljs-keyword">size_t</span>)(-m); <span class="hljs-comment">/* Hacker's Delight (2nd), 3-1. */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Align the input stream to the next 8-bit boundary and return a pointer to
 * that byte, which may be the past-the-end-of-stream byte. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-title">istream_byte_align</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *byte;<font></font>
<font></font>
        assert(is-&gt;bitpos &lt;= is-&gt;bitpos_end &amp;&amp; <span class="hljs-string">"Not past end of stream."</span>);<font></font>
<font></font>
        is-&gt;bitpos = round_up(is-&gt;bitpos, <span class="hljs-number">8</span>);<font></font>
        byte = is-&gt;src + is-&gt;bitpos / <span class="hljs-number">8</span>;<font></font>
        assert(byte &lt;= is-&gt;end);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> byte;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para un flujo de bits saliente, escribimos bits usando un proceso de lectura-modificaci贸n-escritura. </font><font style="vertical-align: inherit;">En el caso r谩pido, puede escribir un bit usando una lectura de 64 bits, alg煤n tipo de operaci贸n de bits y escritura de 64 bits.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Output bitstream. */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ostream_t</span> <span class="hljs-title">ostream_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ostream_t</span> {</span>
        <span class="hljs-keyword">uint8_t</span> *dst;
        <span class="hljs-keyword">uint8_t</span> *end;
        <span class="hljs-keyword">size_t</span> bitpos;
        <span class="hljs-keyword">size_t</span> bitpos_end;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Initialize an output stream to write LSB-first bits into dst[0..n-1]. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ostream_init</span><span class="hljs-params">(<span class="hljs-keyword">ostream_t</span> *os, <span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> n)</span>
</span>{<font></font>
        os-&gt;dst = dst;<font></font>
        os-&gt;end = dst + n;<font></font>
        os-&gt;bitpos = <span class="hljs-number">0</span>;<font></font>
        os-&gt;bitpos_end = n * <span class="hljs-number">8</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Get the current bit position in the stream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">ostream_bit_pos</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">ostream_t</span> *os)</span>
</span>{
        <span class="hljs-keyword">return</span> os-&gt;bitpos;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Return the number of bytes written to the output buffer. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">ostream_bytes_written</span><span class="hljs-params">(<span class="hljs-keyword">ostream_t</span> *os)</span>
</span>{
        <span class="hljs-keyword">return</span> round_up(os-&gt;bitpos, <span class="hljs-number">8</span>) / <span class="hljs-number">8</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Write n bits to the output stream. Returns false if there is not enough room
 * at the destination. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">ostream_write</span><span class="hljs-params">(<span class="hljs-keyword">ostream_t</span> *os, <span class="hljs-keyword">uint64_t</span> bits, <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint64_t</span> x;
        <span class="hljs-keyword">int</span> shift, i;<font></font>
<font></font>
        assert(n &lt;= <span class="hljs-number">57</span>);<font></font>
        assert(bits &lt;= ((<span class="hljs-keyword">uint64_t</span>)<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-string">"Must fit in n bits."</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (os-&gt;bitpos_end - os-&gt;bitpos &lt; n) {
                <span class="hljs-comment">/* Not enough room. */</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        p = &amp;os-&gt;dst[os-&gt;bitpos / <span class="hljs-number">8</span>];<font></font>
        shift = os-&gt;bitpos % <span class="hljs-number">8</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (os-&gt;end - p &gt;= <span class="hljs-number">8</span>) {
                <span class="hljs-comment">/* Common case: read and write 8 bytes in one go. */</span><font></font>
                x = read64le(p);<font></font>
                x = lsb(x, shift);<font></font>
                x |= bits &lt;&lt; shift;<font></font>
                write64le(p, x);<font></font>
        } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">/* Slow case: read/write as many bytes as are available. */</span>
                x = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; os-&gt;end - p; i++) {<font></font>
                        x |= (<span class="hljs-keyword">uint64_t</span>)p[i] &lt;&lt; (i * <span class="hljs-number">8</span>);<font></font>
                }<font></font>
                x = lsb(x, shift);<font></font>
                x |= bits &lt;&lt; shift;<font></font>
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; os-&gt;end - p; i++) {<font></font>
                        p[i] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; (i * <span class="hljs-number">8</span>));<font></font>
                }<font></font>
        }<font></font>
<font></font>
        os-&gt;bitpos += n;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Write a 64-bit value x to dst in little-endian byte order. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write64le</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">uint64_t</span> x)</span>
</span>{<font></font>
        dst[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">0</span>);<font></font>
        dst[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">8</span>);<font></font>
        dst[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">16</span>);<font></font>
        dst[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">24</span>);<font></font>
        dst[<span class="hljs-number">4</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">32</span>);<font></font>
        dst[<span class="hljs-number">5</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">40</span>);<font></font>
        dst[<span class="hljs-number">6</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">48</span>);<font></font>
        dst[<span class="hljs-number">7</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">56</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi茅n necesitamos escribir eficientemente bytes en la secuencia. </font><font style="vertical-align: inherit;">Por supuesto, puede ejecutar repetidamente grabaciones de 8 bits, pero ser谩 mucho m谩s r谩pido de usar </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Align the bitstream to the next byte boundary, then write the n bytes from
   src to it. Returns false if there is not enough room in the stream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">ostream_write_bytes_aligned</span><span class="hljs-params">(<span class="hljs-keyword">ostream_t</span> *os,
                                               <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src,
                                               <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">if</span> (os-&gt;bitpos_end - round_up(os-&gt;bitpos, <span class="hljs-number">8</span>) &lt; n * <span class="hljs-number">8</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        os-&gt;bitpos = round_up(os-&gt;bitpos, <span class="hljs-number">8</span>);
        <span class="hljs-built_in">memcpy</span>(&amp;os-&gt;dst[os-&gt;bitpos / <span class="hljs-number">8</span>], src, n);<font></font>
        os-&gt;bitpos += n * <span class="hljs-number">8</span>;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br>
<a name="12"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desembalaje (inflaci贸n)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que el algoritmo de compresi贸n se llama </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desinflar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (soplar, extraer aire de algo), el proceso de desembalaje a veces se llama </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inflaci贸n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si primero estudia este proceso, entenderemos c贸mo funciona el formato. </font><font style="vertical-align: inherit;">Puede ver el c贸digo en la primera parte de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deflate.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deflate.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bits.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tables.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tables.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (generado usando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generate_tables.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los datos comprimidos con Deflate se almacenan como una serie de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloques.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cada bloque comienza con un encabezado de 3 bits, en el que se establece el primer bit (menos significativo) si este es el bloque final de la serie, y los otros dos bits indican su tipo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/875/b36/1fd/875b361fd3414431d2a20d1ab0b6ef8b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay tres tipos de bloques: sin comprimir (0), comprimido mediante c贸digos fijos de Huffman (1) y comprimido mediante c贸digos "din谩micos" de Huffman (2). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este c贸digo realiza el desempaquetado utilizando funciones auxiliares para diferentes tipos de bloques, que implementaremos m谩s adelante:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> {<font></font>
        HWINF_OK,   <span class="hljs-comment">/* Inflation was successful. */</span>
        HWINF_FULL, <span class="hljs-comment">/* Not enough room in the output buffer. */</span>
        HWINF_ERR   <span class="hljs-comment">/* Error in the input data. */</span>
} <span class="hljs-keyword">inf_stat_t</span>;<font></font>
<font></font>
<span class="hljs-comment">/* Decompress (inflate) the Deflate stream in src. The number of input bytes
   used, at most src_len, is stored in *src_used on success. Output is written
   to dst. The number of bytes written, at most dst_cap, is stored in *dst_used
   on success. src[0..src_len-1] and dst[0..dst_cap-1] must not overlap.
   Returns a status value as defined above. */</span>
<span class="hljs-function"><span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">hwinflate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len, <span class="hljs-keyword">size_t</span> *src_used,
                     <span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_used)</span>
</span>{
        <span class="hljs-keyword">istream_t</span> is;
        <span class="hljs-keyword">size_t</span> dst_pos;
        <span class="hljs-keyword">uint64_t</span> bits;
        <span class="hljs-keyword">bool</span> bfinal;
        <span class="hljs-keyword">inf_stat_t</span> s;<font></font>
<font></font>
        istream_init(&amp;is, src, src_len);<font></font>
        dst_pos = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">do</span> {
                <span class="hljs-comment">/* Read the 3-bit block header. */</span><font></font>
                bits = istream_bits(&amp;is);<font></font>
                <span class="hljs-keyword">if</span> (!istream_advance(&amp;is, <span class="hljs-number">3</span>)) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
                bfinal = bits &amp; <span class="hljs-number">1</span>;<font></font>
                bits &gt;&gt;= <span class="hljs-number">1</span>;<font></font>
<font></font>
                <span class="hljs-keyword">switch</span> (lsb(bits, <span class="hljs-number">2</span>)) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">/* 00: No compression. */</span><font></font>
                        s = inf_noncomp_block(&amp;is, dst, dst_cap, &amp;dst_pos);<font></font>
                        <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">/* 01: Compressed with fixed Huffman codes. */</span><font></font>
                        s = inf_fixed_block(&amp;is, dst, dst_cap, &amp;dst_pos);<font></font>
                        <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">/* 10: Compressed with "dynamic" Huffman codes. */</span><font></font>
                        s = inf_dyn_block(&amp;is, dst, dst_cap, &amp;dst_pos);<font></font>
                        <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>: <span class="hljs-comment">/* Invalid block type. */</span>
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (s != HWINF_OK) {
                        <span class="hljs-keyword">return</span> s;<font></font>
                }<font></font>
        } <span class="hljs-keyword">while</span> (!bfinal);<font></font>
<font></font>
        *src_used = (<span class="hljs-keyword">size_t</span>)(istream_byte_align(&amp;is) - src);<font></font>
<font></font>
        assert(dst_pos &lt;= dst_cap);<font></font>
        *dst_used = dst_pos;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> HWINF_OK;<font></font>
}<font></font>
</code></pre><br>
<a name="13"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloques de desinflado sin comprimir</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estos son bloques "almacenados", el tipo m谩s simple. </font><font style="vertical-align: inherit;">Comienza con el siguiente l铆mite de 8 bits del flujo de bits con una palabra de 16 bits (len) que indica la longitud del bloque. </font><font style="vertical-align: inherit;">Esto es seguido por otra palabra de 16 bits (nlen), que complementa (se invierte el orden de los bits) de las palabras len. </font><font style="vertical-align: inherit;">Se supone que nlen act煤a como una simple suma de comprobaci贸n de len: si el archivo est谩 da帽ado, entonces los valores probablemente no ser谩n complementarios y el programa podr谩 detectar un error.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e1/eb8/15b/0e1eb815b2dfec1edb50eeafd1291cc5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu茅s de len y nlen son datos sin comprimir. </font><font style="vertical-align: inherit;">Dado que la longitud del bloque es un valor de 16 bits, el tama帽o de los datos est谩 limitado a 65.535 bytes.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">inf_noncomp_block</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">uint8_t</span> *dst,
                                    <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_pos)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint16_t</span> len, nlen;<font></font>
<font></font>
        p = istream_byte_align(is);<font></font>
<font></font>
        <span class="hljs-comment">/* Read len and nlen (2 x 16 bits). */</span>
        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">32</span>)) {
                <span class="hljs-keyword">return</span> HWINF_ERR; <span class="hljs-comment">/* Not enough input. */</span><font></font>
        }<font></font>
        len  = read16le(p);<font></font>
        nlen = read16le(p + <span class="hljs-number">2</span>);<font></font>
        p += <span class="hljs-number">4</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (nlen != (<span class="hljs-keyword">uint16_t</span>)~len) {
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!istream_advance(is, len * <span class="hljs-number">8</span>)) {
                <span class="hljs-keyword">return</span> HWINF_ERR; <span class="hljs-comment">/* Not enough input. */</span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (dst_cap - *dst_pos &lt; len) {
                <span class="hljs-keyword">return</span> HWINF_FULL; <span class="hljs-comment">/* Not enough room to output. */</span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">memcpy</span>(&amp;dst[*dst_pos], p, len);<font></font>
        *dst_pos += len;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> HWINF_OK;<font></font>
}<font></font>
</code></pre><br>
<a name="14"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desinfle los bloques utilizando c贸digos fijos de Huffman</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los bloques Deflate comprimidos usan el c贸digo Huffman para representar una secuencia de literales LZ77. </font><font style="vertical-align: inherit;">Los v铆nculos de retroceso se rompen usando marcadores de final de bloque. </font><font style="vertical-align: inherit;">Para literales, longitudes de backlink y marcadores, se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usa el</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> c贸digo </font><i><font style="vertical-align: inherit;">litlen</font></i><font style="vertical-align: inherit;"> Huffman </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Y para distancias de backlink, se usa el c贸digo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c35/0e1/a8c/c350e1a8c73f69203949ccc534141497.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Litlen codifica valores en el rango de 0-285. </font><font style="vertical-align: inherit;">Los valores 0-255 se usan para bytes literales, 256 es el marcador de fin de bloque y 257-285 se usan para longitudes de enlace de retroceso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los v铆nculos de retroceso son de 3-258 bytes de longitud. </font><font style="vertical-align: inherit;">El valor de Litlen determina la longitud base a la que se agregan cero o m谩s </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bits</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adicionales de la secuencia </font><font style="vertical-align: inherit;">para obtener la longitud completa de acuerdo con la tabla a continuaci贸n. </font><font style="vertical-align: inherit;">Por ejemplo, un valor litlen de 269 significa una longitud base de 19 y dos bits adicionales. </font><font style="vertical-align: inherit;">La adici贸n de dos bits de la secuencia da la longitud final de 19 a 22.</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Litlen</font></font></strong></td>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bits extra</font></font></strong></td>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Longitudes</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">257</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">258</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 4</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">259</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 5</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">260</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6 6</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">261</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7 7</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">262</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">263</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9 9</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">264</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">265</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11-12</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">266</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13-14</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">267</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15-16</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">268</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17-18</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">269</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19-22</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">270</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">23-26</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">271</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">27-30</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">272</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">31-34</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">273</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">35-42</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">274</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">43-50</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">275</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">51-58</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">276</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">59-66</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">277</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">67-82</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">278</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8398</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">279</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">99-114</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">280</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">115-130</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">281</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">131-162</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">282</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">163-194</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">283</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">195226</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">284</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">227257</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">285</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">258</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que un valor litlen de 284 m谩s 5 bits adicionales puede representar longitudes de 227 a 258, sin embargo, la especificaci贸n establece que la longitud 258, la longitud m谩xima del v铆nculo de retroceso, debe representarse utilizando un valor litlen separado. </font><font style="vertical-align: inherit;">Se supone que esto reduce la codificaci贸n en situaciones donde a menudo se encuentra la longitud m谩xima. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El descompresor usa la tabla para obtener la longitud base y los bits adicionales del valor litlen (menos 257):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Table of litlen symbol values minus 257 with corresponding base length
   and number of extra bits. */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">litlen_tbl_t</span> {</span>
        <span class="hljs-keyword">uint16_t</span> base_len : <span class="hljs-number">9</span>;
        <span class="hljs-keyword">uint16_t</span> ebits : <span class="hljs-number">7</span>;<font></font>
};<font></font>
<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">litlen_tbl_t</span> <span class="hljs-title">litlen_tbl</span>[29] = {</span>
<span class="hljs-comment">/* 257 */</span> { <span class="hljs-number">3</span>, <span class="hljs-number">0</span> },
<span class="hljs-comment">/* 258 */</span> { <span class="hljs-number">4</span>, <span class="hljs-number">0</span> },<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/* 284 */</span> { <span class="hljs-number">227</span>, <span class="hljs-number">5</span> },
<span class="hljs-comment">/* 285 */</span> { <span class="hljs-number">258</span>, <span class="hljs-number">0</span> }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El c贸digo litlen fijo de Huffman es can贸nico y utiliza las siguientes longitudes de palabra de c贸digo (286287 no son valores litlen v谩lidos, pero est谩n involucrados en la generaci贸n de c贸digo):</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valores de Litlen</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Longitud de palabra de c贸digo</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0-143</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">144-255</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9 9</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">256279</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7 7</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">280287</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El descompresor almacena estas longitudes en una tabla conveniente para la transmisi贸n a </font></font><code>huffman_decoder_init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> fixed_litlen_lengths[<span class="hljs-number">288</span>] = {
<span class="hljs-comment">/*   0 */</span> <span class="hljs-number">8</span>,
<span class="hljs-comment">/*   1 */</span> <span class="hljs-number">8</span>,<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/* 287 */</span> <span class="hljs-number">8</span>,<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las distancias de enlace de retroceso var铆an de 1 a 32.768. Se codifican utilizando un esquema que es similar a un esquema de codificaci贸n de longitud. </font><font style="vertical-align: inherit;">El c贸digo Huffman dist codifica valores de 0 a 29, cada uno de los cuales corresponde a la longitud base, a los que se agregan bits adicionales para obtener la distancia final:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dist</font></font></strong></td>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bits extra</font></font></strong></td>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distancias</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 4</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5-6</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7-8</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6 6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9-12</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7 7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13-16</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17-24</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9 9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2532</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">33-48</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">once</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">49-64</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65-96</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trece</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">97-128</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6 6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">129-192</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quince</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6 6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">193256</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diecis茅is</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7 7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">257384</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7 7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">385-512</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieciocho</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">513-768</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diecinueve</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">769-1024</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">veinte</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9 9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1025-1536</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9 9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1537-2048</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2049-3072</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">23</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30734096</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">once</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4097-6144</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">once</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">61458192</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">819312288</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">27</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1228916384</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trece</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1638524576</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">29</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trece</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2457732768</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El c贸digo fijo de Huffman dist es can贸nico. </font><font style="vertical-align: inherit;">Todas las palabras de c贸digo son de 5 bits de largo. </font><font style="vertical-align: inherit;">Es simple, el descompresor almacena los c贸digos en una tabla que se puede usar con </font></font><code>huffman_decoder_init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(los valores dist 3031 no son correctos. Se indica que est谩n involucrados en la generaci贸n de c贸digos Huffman, pero en realidad no tienen ning煤n efecto):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> fixed_dist_lengths[<span class="hljs-number">32</span>] = {
<span class="hljs-comment">/*  0 */</span> <span class="hljs-number">5</span>,
<span class="hljs-comment">/*  1 */</span> <span class="hljs-number">5</span>,<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/* 31 */</span> <span class="hljs-number">5</span>,<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C贸digo de descompresi贸n o desempaquetado: desinfle el bloque usando c贸digos fijos de Huffman:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">inf_fixed_block</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">uint8_t</span> *dst,
                                  <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_pos)</span>
</span>{
        <span class="hljs-keyword">huffman_decoder_t</span> litlen_dec, dist_dec;<font></font>
<font></font>
        huffman_decoder_init(&amp;litlen_dec, fixed_litlen_lengths,<font></font>
                             <span class="hljs-keyword">sizeof</span>(fixed_litlen_lengths) /
                             <span class="hljs-keyword">sizeof</span>(fixed_litlen_lengths[<span class="hljs-number">0</span>]));<font></font>
        huffman_decoder_init(&amp;dist_dec, fixed_dist_lengths,<font></font>
                             <span class="hljs-keyword">sizeof</span>(fixed_dist_lengths) /
                             <span class="hljs-keyword">sizeof</span>(fixed_dist_lengths[<span class="hljs-number">0</span>]));<font></font>
<font></font>
        <span class="hljs-keyword">return</span> inf_block(is, dst, dst_cap, dst_pos, &amp;litlen_dec, &amp;dist_dec);<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LITLEN_EOB 256</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LITLEN_MAX 285</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LITLEN_TBL_OFFSET 257</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LEN 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_LEN 258</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DISTSYM_MAX 29</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_DISTANCE 1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_DISTANCE 32768</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">inf_block</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_cap,
                            <span class="hljs-keyword">size_t</span> *dst_pos,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_decoder_t</span> *litlen_dec,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_decoder_t</span> *dist_dec)</span>
</span>{
        <span class="hljs-keyword">uint64_t</span> bits;
        <span class="hljs-keyword">size_t</span> used, used_tot, dist, len;
        <span class="hljs-keyword">int</span> litlen, distsym;
        <span class="hljs-keyword">uint16_t</span> ebits;<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
                <span class="hljs-comment">/* Read a litlen symbol. */</span><font></font>
                bits = istream_bits(is);<font></font>
                litlen = huffman_decode(litlen_dec, (<span class="hljs-keyword">uint16_t</span>)bits, &amp;used);<font></font>
                bits &gt;&gt;= used;<font></font>
                used_tot = used;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (litlen &lt; <span class="hljs-number">0</span> || litlen &gt; LITLEN_MAX) {
                        <span class="hljs-comment">/* Failed to decode, or invalid symbol. */</span>
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (litlen &lt;= UINT8_MAX) {
                        <span class="hljs-comment">/* Literal. */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, used_tot)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">if</span> (*dst_pos == dst_cap) {
                                <span class="hljs-keyword">return</span> HWINF_FULL;<font></font>
                        }<font></font>
                        lz77_output_lit(dst, (*dst_pos)++, (<span class="hljs-keyword">uint8_t</span>)litlen);
                        <span class="hljs-keyword">continue</span>;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (litlen == LITLEN_EOB) {
                        <span class="hljs-comment">/* End of block. */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, used_tot)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">return</span> HWINF_OK;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* It is a back reference. Figure out the length. */</span><font></font>
                assert(litlen &gt;= LITLEN_TBL_OFFSET &amp;&amp; litlen &lt;= LITLEN_MAX);<font></font>
                len   = litlen_tbl[litlen - LITLEN_TBL_OFFSET].base_len;<font></font>
                ebits = litlen_tbl[litlen - LITLEN_TBL_OFFSET].ebits;<font></font>
                <span class="hljs-keyword">if</span> (ebits != <span class="hljs-number">0</span>) {<font></font>
                        len += lsb(bits, ebits);<font></font>
                        bits &gt;&gt;= ebits;<font></font>
                        used_tot += ebits;<font></font>
                }<font></font>
                assert(len &gt;= MIN_LEN &amp;&amp; len &lt;= MAX_LEN);<font></font>
<font></font>
                <span class="hljs-comment">/* Get the distance. */</span>
                distsym = huffman_decode(dist_dec, (<span class="hljs-keyword">uint16_t</span>)bits, &amp;used);<font></font>
                bits &gt;&gt;= used;<font></font>
                used_tot += used;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (distsym &lt; <span class="hljs-number">0</span> || distsym &gt; DISTSYM_MAX) {
                        <span class="hljs-comment">/* Failed to decode, or invalid symbol. */</span>
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
                dist  = dist_tbl[distsym].base_dist;<font></font>
                ebits = dist_tbl[distsym].ebits;<font></font>
                <span class="hljs-keyword">if</span> (ebits != <span class="hljs-number">0</span>) {<font></font>
                        dist += lsb(bits, ebits);<font></font>
                        bits &gt;&gt;= ebits;<font></font>
                        used_tot += ebits;<font></font>
                }<font></font>
                assert(dist &gt;= MIN_DISTANCE &amp;&amp; dist &lt;= MAX_DISTANCE);<font></font>
<font></font>
                assert(used_tot &lt;= ISTREAM_MIN_BITS);<font></font>
                <span class="hljs-keyword">if</span> (!istream_advance(is, used_tot)) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Bounds check and output the backref. */</span>
                <span class="hljs-keyword">if</span> (dist &gt; *dst_pos) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (round_up(len, <span class="hljs-number">8</span>) &lt;= dst_cap - *dst_pos) {<font></font>
                        output_backref64(dst, *dst_pos, dist, len);<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &lt;= dst_cap - *dst_pos) {<font></font>
                        lz77_output_backref(dst, *dst_pos, dist, len);<font></font>
                } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">return</span> HWINF_FULL;<font></font>
                }<font></font>
                (*dst_pos) += len;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Preste atenci贸n a esta optimizaci贸n: cuando no hay suficiente espacio en el b煤fer saliente, emitimos v铆nculos de retroceso utilizando la funci贸n a continuaci贸n, que copia 64 bits a la vez. </font><font style="vertical-align: inherit;">Esto es "desordenado" en el sentido de que a menudo copia algunos bytes adicionales (hasta el siguiente m煤ltiplo de 8). </font><font style="vertical-align: inherit;">Pero funciona mucho m谩s r谩pido </font></font><code>lz77_output_backref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ya que requiere menos iteraciones c铆clicas y accesos a la memoria. </font><font style="vertical-align: inherit;">De hecho, los v铆nculos de retroceso cortos ahora se procesar谩n en una iteraci贸n, lo cual es muy bueno para predecir la ramificaci贸n.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Output the (dist,len) backref at dst_pos in dst using 64-bit wide writes.
   There must be enough room for len bytes rounded to the next multiple of 8. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">output_backref64</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_pos, <span class="hljs-keyword">size_t</span> dist,
                             <span class="hljs-keyword">size_t</span> len)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;
        <span class="hljs-keyword">uint64_t</span> tmp;<font></font>
<font></font>
        assert(len &gt; <span class="hljs-number">0</span>);<font></font>
        assert(dist &lt;= dst_pos &amp;&amp; <span class="hljs-string">"cannot reference before beginning of dst"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (len &gt; dist) {
                <span class="hljs-comment">/* Self-overlapping backref; fall back to byte-by-byte copy. */</span><font></font>
                lz77_output_backref(dst, dst_pos, dist, len);<font></font>
                <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">do</span> {
                <span class="hljs-built_in">memcpy</span>(&amp;tmp, &amp;dst[dst_pos - dist + i], <span class="hljs-number">8</span>);
                <span class="hljs-built_in">memcpy</span>(&amp;dst[dst_pos + i], &amp;tmp, <span class="hljs-number">8</span>);<font></font>
                i += <span class="hljs-number">8</span>;<font></font>
        } <span class="hljs-keyword">while</span> (i &lt; len);<font></font>
}<font></font>
</code></pre><br>
<a name="15"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desinfle los bloques usando c贸digos din谩micos de Huffman</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los bloques desinflados que utilizan c贸digos din谩micos de Huffman funcionan de la misma manera que se describe anteriormente. Pero en lugar de los c贸digos predefinidos para litlen y dist, usan los c贸digos almacenados en el flujo Deflate al comienzo del bloque. El nombre probablemente no tenga 茅xito, ya que los c贸digos din谩micos de Huffman tambi茅n se denominan c贸digos que cambian durante la codificaci贸n; esta es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la codificaci贸n adaptativa de Huffman</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Los c贸digos descritos aqu铆 no tienen nada que ver con ese procedimiento. Son din谩micos solo en el sentido de que diferentes bloques pueden usar diferentes c贸digos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Generar c贸digos din谩micos de litlen y dist es la parte m谩s dif铆cil del formato Deflate. Pero tan pronto como se generan los c贸digos, la descompresi贸n se realiza de la misma manera que se describe en la parte anterior, usando </font></font><code>inf_block</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">inf_dyn_block</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">uint8_t</span> *dst,
                                <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_pos)</span>
</span>{
        <span class="hljs-keyword">inf_stat_t</span> s;
        <span class="hljs-keyword">huffman_decoder_t</span> litlen_dec, dist_dec;<font></font>
<font></font>
        s = init_dyn_decoders(is, &amp;litlen_dec, &amp;dist_dec);<font></font>
        <span class="hljs-keyword">if</span> (s != HWINF_OK) {
                <span class="hljs-keyword">return</span> s;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> inf_block(is, dst, dst_cap, dst_pos, &amp;litlen_dec, &amp;dist_dec);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los c贸digos Litlen y dist para bloques Deflate din谩micos se almacenan como una serie de longitudes de palabras de c贸digo. </font><font style="vertical-align: inherit;">Las longitudes mismas se codifican usando el tercer c贸digo de Huffman: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codelen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este c贸digo est谩 determinado por la longitud de las palabras de c贸digo ( </font></font><code>codelen_lens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) que est谩n almacenadas en el bloque (驴mencion茅 que es dif铆cil?).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84e/1fc/0e3/84e1fc0e3d3cfcb56ff215702d14f73d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al comienzo del bloque din谩mico hay 14 bits que determinan el n煤mero de longitudes de palabras de c贸digo litlen, dist y codelen que se leer谩n desde el bloque:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_CODELEN_LENS 4</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_CODELEN_LENS 19</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LITLEN_LENS 257</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_LITLEN_LENS 288</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_DIST_LENS 1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_DIST_LENS 32</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_MAX_LIT 15</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_COPY 16</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_COPY_MIN 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_COPY_MAX 6</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS 17</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS_MIN 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS_MAX 10</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS2 18</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS2_MIN 11</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS2_MAX 138</span><font></font>
<font></font>
<span class="hljs-comment">/* RFC 1951, 3.2.7 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> codelen_lengths_order[MAX_CODELEN_LENS] =<font></font>
{ <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">13</span>, <span class="hljs-number">2</span>, <span class="hljs-number">14</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span> };<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">init_dyn_decoders</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is,
                                    <span class="hljs-keyword">huffman_decoder_t</span> *litlen_dec,
                                    <span class="hljs-keyword">huffman_decoder_t</span> *dist_dec)</span>
</span>{
        <span class="hljs-keyword">uint64_t</span> bits;
        <span class="hljs-keyword">size_t</span> num_litlen_lens, num_dist_lens, num_codelen_lens;
        <span class="hljs-keyword">uint8_t</span> codelen_lengths[MAX_CODELEN_LENS];
        <span class="hljs-keyword">uint8_t</span> code_lengths[MAX_LITLEN_LENS + MAX_DIST_LENS];
        <span class="hljs-keyword">size_t</span> i, n, used;
        <span class="hljs-keyword">int</span> sym;
        <span class="hljs-keyword">huffman_decoder_t</span> codelen_dec;<font></font>
<font></font>
        bits = istream_bits(is);<font></font>
<font></font>
        <span class="hljs-comment">/* Number of litlen codeword lengths (5 bits + 257). */</span>
        num_litlen_lens = lsb(bits, <span class="hljs-number">5</span>) + MIN_LITLEN_LENS;<font></font>
        bits &gt;&gt;= <span class="hljs-number">5</span>;<font></font>
        assert(num_litlen_lens &lt;= MAX_LITLEN_LENS);<font></font>
<font></font>
        <span class="hljs-comment">/* Number of dist codeword lengths (5 bits + 1). */</span>
        num_dist_lens = lsb(bits, <span class="hljs-number">5</span>) + MIN_DIST_LENS;<font></font>
        bits &gt;&gt;= <span class="hljs-number">5</span>;<font></font>
        assert(num_dist_lens &lt;= MAX_DIST_LENS);<font></font>
<font></font>
        <span class="hljs-comment">/* Number of code length lengths (4 bits + 4). */</span>
        num_codelen_lens = lsb(bits, <span class="hljs-number">4</span>) + MIN_CODELEN_LENS;<font></font>
        bits &gt;&gt;= <span class="hljs-number">4</span>;<font></font>
        assert(num_codelen_lens &lt;= MAX_CODELEN_LENS);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">5</span> + <span class="hljs-number">5</span> + <span class="hljs-number">4</span>)) {
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego vienen las longitudes de las palabras en c贸digo para el c贸digo codelen. </font><font style="vertical-align: inherit;">Estas longitudes son los valores habituales de tres bits, pero est谩n escritos en el orden especial especificado en </font></font><code>codelen_lengths_order</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como es necesario determinar 19 longitudes, solo se leer谩 de la secuencia </font></font><code>num_codelen_lens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">todo lo dem谩s es impl铆citamente nulo. </font><font style="vertical-align: inherit;">Las longitudes se enumeran en un cierto orden, por lo que es m谩s probable que las longitudes cero caigan al final de la lista y no se almacenen en el bloque.</font></font><br>
<br>
<pre><code class="cpp hljs">       <span class="hljs-comment">/* Read the codelen codeword lengths (3 bits each)
           and initialize the codelen decoder. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_codelen_lens; i++) {<font></font>
                bits = istream_bits(is);<font></font>
                codelen_lengths[codelen_lengths_order[i]] =<font></font>
                        (<span class="hljs-keyword">uint8_t</span>)lsb(bits, <span class="hljs-number">3</span>);
                <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">3</span>)) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
        }<font></font>
        <span class="hljs-keyword">for</span> (; i &lt; MAX_CODELEN_LENS; i++) {<font></font>
                codelen_lengths[codelen_lengths_order[i]] = <span class="hljs-number">0</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (!huffman_decoder_init(&amp;codelen_dec, codelen_lengths,<font></font>
                                  MAX_CODELEN_LENS)) {<font></font>
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al configurar el decodificador de codelen, podemos leer las longitudes de las palabras de c贸digo litlen y dist de la secuencia.</font></font><br>
<br>
<pre><code class="cpp hljs">       <span class="hljs-comment">/* Read the litlen and dist codeword lengths. */</span>
        i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (i &lt; num_litlen_lens + num_dist_lens) {<font></font>
                bits = istream_bits(is);<font></font>
                sym = huffman_decode(&amp;codelen_dec, (<span class="hljs-keyword">uint16_t</span>)bits, &amp;used);<font></font>
                bits &gt;&gt;= used;<font></font>
                <span class="hljs-keyword">if</span> (!istream_advance(is, used)) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (sym &gt;= <span class="hljs-number">0</span> &amp;&amp; sym &lt;= CODELEN_MAX_LIT) {
                        <span class="hljs-comment">/* A literal codeword length. */</span>
                        code_lengths[i++] = (<span class="hljs-keyword">uint8_t</span>)sym;<font></font>
                }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16, 17 y 18 no son longitudes reales, son indicadores de que la longitud anterior debe repetirse varias veces, o que necesita repetir la longitud cero:</font></font><br>
<br>
<pre><code class="cpp hljs">               <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_COPY) {
                        <span class="hljs-comment">/* Copy the previous codeword length 3--6 times. */</span>
                        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span>) {
                                <span class="hljs-keyword">return</span> HWINF_ERR; <span class="hljs-comment">/* No previous length. */</span><font></font>
                        }<font></font>
                        n = lsb(bits, <span class="hljs-number">2</span>) + CODELEN_COPY_MIN; <span class="hljs-comment">/* 2 bits + 3 */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">2</span>)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        assert(n &gt;= CODELEN_COPY_MIN &amp;&amp; n &lt;= CODELEN_COPY_MAX);<font></font>
                        <span class="hljs-keyword">if</span> (i + n &gt; num_litlen_lens + num_dist_lens) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">while</span> (n--) {<font></font>
                                code_lengths[i] = code_lengths[i - <span class="hljs-number">1</span>];<font></font>
                                i++;<font></font>
                        }<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_ZEROS) {
                        <span class="hljs-comment">/* 3--10 zeros. */</span>
                        n = lsb(bits, <span class="hljs-number">3</span>) + CODELEN_ZEROS_MIN; <span class="hljs-comment">/* 3 bits + 3 */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">3</span>)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        assert(n &gt;= CODELEN_ZEROS_MIN &amp;&amp;<font></font>
                               n &lt;= CODELEN_ZEROS_MAX);<font></font>
                        <span class="hljs-keyword">if</span> (i + n &gt; num_litlen_lens + num_dist_lens) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">while</span> (n--) {<font></font>
                                code_lengths[i++] = <span class="hljs-number">0</span>;<font></font>
                        }<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_ZEROS2) {
                        <span class="hljs-comment">/* 11--138 zeros. */</span>
                        n = lsb(bits, <span class="hljs-number">7</span>) + CODELEN_ZEROS2_MIN; <span class="hljs-comment">/* 7 bits +138 */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">7</span>)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        assert(n &gt;= CODELEN_ZEROS2_MIN &amp;&amp;<font></font>
                               n &lt;= CODELEN_ZEROS2_MAX);<font></font>
                        <span class="hljs-keyword">if</span> (i + n &gt; num_litlen_lens + num_dist_lens) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">while</span> (n--) {<font></font>
                                code_lengths[i++] = <span class="hljs-number">0</span>;<font></font>
                        }<font></font>
                } <span class="hljs-keyword">else</span> {
                        <span class="hljs-comment">/* Invalid symbol. */</span>
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que las longitudes litlen y dist se leen una por una en la matriz </font></font><code>code_lengths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No se pueden leer por separado, porque las ejecuciones de longitud de c贸digo se pueden transferir desde las 煤ltimas longitudes de litlen a las primeras longitudes de dist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una vez preparadas las longitudes de las palabras en c贸digo, podemos configurar los decodificadores Huffman y volver a la tarea de decodificar literales y v铆nculos de retroceso:</font></font><br>
<br>
<pre><code class="cpp hljs">       <span class="hljs-keyword">if</span> (!huffman_decoder_init(litlen_dec, &amp;code_lengths[<span class="hljs-number">0</span>],<font></font>
                                  num_litlen_lens)) {<font></font>
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (!huffman_decoder_init(dist_dec, &amp;code_lengths[num_litlen_lens],<font></font>
                                  num_dist_lens)) {<font></font>
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> HWINF_OK;<font></font>
}<font></font>
</code></pre><br>
<a name="16"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compresi贸n (deflaci贸n)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En las partes anteriores, creamos todas las herramientas necesarias para la compresi贸n Deflate: Lempel-Ziv, codificaci贸n Huffman, flujos de bits y una descripci贸n de los tres tipos de bloques Deflate. Y en esta parte lo pondremos todo junto para obtener la compresi贸n Deflate. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compresi贸n Lempel-Ziv analiza los datos de origen en una secuencia de v铆nculos de retroceso y literales. Esta secuencia debe dividirse y codificarse en bloques Deflate, como se describe en la parte anterior. Elegir un m茅todo de partici贸n a menudo se llama </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloqueo.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por un lado, cada nuevo bloque significa alg煤n tipo de sobrecarga, cuyo volumen depende del tipo de bloque y su contenido. </font><font style="vertical-align: inherit;">Menos bloques, menos gastos generales. </font><font style="vertical-align: inherit;">Por otro lado, estos costos de crear un nuevo bloque pueden dar sus frutos. </font><font style="vertical-align: inherit;">Por ejemplo, si las caracter铆sticas de los datos permiten una codificaci贸n Huffman m谩s eficiente y reducen la cantidad total de datos generados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El bloqueo es una tarea de optimizaci贸n dif铆cil. </font><font style="vertical-align: inherit;">Algunos compresores (por ejemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zopfli</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) funcionan mejor que otros, pero la mayor铆a simplemente utiliza el enfoque codicioso: emiten bloques tan pronto como alcanzan un cierto tama帽o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los diferentes tipos de bloques tienen sus propias restricciones de tama帽o:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los bloques sin comprimir no pueden contener m谩s de 65.535 bytes.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los c贸digos fijos de Huffman no tienen un tama帽o m谩ximo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los c贸digos din谩micos de Huffman generalmente no tienen un tama帽o m谩ximo, pero dado que nuestra implementaci贸n del algoritmo de Huffman usa secuencias de caracteres de 16 bits, estamos limitados a 65.535 caracteres.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para usar bloques de cualquier tipo libremente, limite su tama帽o a 65.534 bytes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* The largest number of bytes that will fit in any kind of block is 65,534.
   It will fit in an uncompressed block (max 65,535 bytes) and a Huffman
   block with only literals (65,535 symbols including end-of-block marker). */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_BLOCK_LEN_BYTES 65534</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para rastrear el flujo de bits saliente y el contenido del bloque actual durante la compresi贸n, usaremos la estructura:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deflate_state_t</span> <span class="hljs-title">deflate_state_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deflate_state_t</span> {</span>
        <span class="hljs-keyword">ostream_t</span> os;<font></font>
<font></font>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *block_src; <span class="hljs-comment">/* First src byte in the block. */</span><font></font>
<font></font>
        <span class="hljs-keyword">size_t</span> block_len;       <span class="hljs-comment">/* Number of symbols in the current block. */</span>
        <span class="hljs-keyword">size_t</span> block_len_bytes; <span class="hljs-comment">/* Number of src bytes in the block. */</span><font></font>
<font></font>
        <span class="hljs-comment">/* Symbol frequencies for the current block. */</span>
        <span class="hljs-keyword">uint16_t</span> litlen_freqs[LITLEN_MAX + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">uint16_t</span> dist_freqs[DISTSYM_MAX + <span class="hljs-number">1</span>];<font></font>
<font></font>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
                <span class="hljs-keyword">uint16_t</span> distance;    <span class="hljs-comment">/* Backref distance. */</span>
                <span class="hljs-keyword">union</span> {
                        <span class="hljs-keyword">uint16_t</span> lit; <span class="hljs-comment">/* Literal byte or end-of-block. */</span>
                        <span class="hljs-keyword">uint16_t</span> len; <span class="hljs-comment">/* Backref length (distance != 0). */</span><font></font>
                } u;<font></font>
        } block[MAX_BLOCK_LEN_BYTES + <span class="hljs-number">1</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reset_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s)</span>
</span>{<font></font>
        s-&gt;block_len = <span class="hljs-number">0</span>;<font></font>
        s-&gt;block_len_bytes = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">memset</span>(s-&gt;litlen_freqs, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(s-&gt;litlen_freqs));
        <span class="hljs-built_in">memset</span>(s-&gt;dist_freqs, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(s-&gt;dist_freqs));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para agregar resultados de trabajo al bloque, </font></font><code>lz77_compress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizaremos las funciones de devoluci贸n de llamada y, al alcanzar el tama帽o m谩ximo, escribiremos el bloque en el flujo de bits:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">lit_callback</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> lit, <span class="hljs-keyword">void</span> *aux)</span>
</span>{
        <span class="hljs-keyword">deflate_state_t</span> *s = aux;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (s-&gt;block_len_bytes + <span class="hljs-number">1</span> &gt; MAX_BLOCK_LEN_BYTES) {
                <span class="hljs-keyword">if</span> (!write_block(s, <span class="hljs-literal">false</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                s-&gt;block_src += s-&gt;block_len_bytes;<font></font>
                reset_block(s);<font></font>
        }<font></font>
<font></font>
        assert(s-&gt;block_len &lt; <span class="hljs-keyword">sizeof</span>(s-&gt;block) / <span class="hljs-keyword">sizeof</span>(s-&gt;block[<span class="hljs-number">0</span>]));<font></font>
        s-&gt;block[s-&gt;block_len  ].distance = <span class="hljs-number">0</span>;<font></font>
        s-&gt;block[s-&gt;block_len++].u.lit = lit;<font></font>
        s-&gt;block_len_bytes++;<font></font>
<font></font>
        s-&gt;litlen_freqs[lit]++;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">backref_callback</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> dist, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">void</span> *aux)</span>
</span>{
        <span class="hljs-keyword">deflate_state_t</span> *s = aux;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (s-&gt;block_len_bytes + len &gt; MAX_BLOCK_LEN_BYTES) {
                <span class="hljs-keyword">if</span> (!write_block(s, <span class="hljs-literal">false</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                s-&gt;block_src += s-&gt;block_len_bytes;<font></font>
                reset_block(s);<font></font>
        }<font></font>
<font></font>
        assert(s-&gt;block_len &lt; <span class="hljs-keyword">sizeof</span>(s-&gt;block) / <span class="hljs-keyword">sizeof</span>(s-&gt;block[<span class="hljs-number">0</span>]));<font></font>
        s-&gt;block[s-&gt;block_len  ].distance = (<span class="hljs-keyword">uint16_t</span>)dist;<font></font>
        s-&gt;block[s-&gt;block_len++].u.len = (<span class="hljs-keyword">uint16_t</span>)len;<font></font>
        s-&gt;block_len_bytes += len;<font></font>
<font></font>
        assert(len &gt;= MIN_LEN &amp;&amp; len &lt;= MAX_LEN);<font></font>
        assert(dist &gt;= MIN_DISTANCE &amp;&amp; dist &lt;= MAX_DISTANCE);<font></font>
        s-&gt;litlen_freqs[len2litlen[len]]++;<font></font>
        s-&gt;dist_freqs[distance2dist[dist]]++;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo m谩s interesante es la grabaci贸n de bloques. </font><font style="vertical-align: inherit;">Si el bloque no est谩 comprimido, entonces todo es simple:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_uncomp_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">final</span>)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> len_nlen[<span class="hljs-number">4</span>];<font></font>
<font></font>
        <span class="hljs-comment">/* Write the block header. */</span>
        <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, (<span class="hljs-number">0x0</span> &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-keyword">final</span>, <span class="hljs-number">3</span>)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        len_nlen[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">uint8_t</span>)(s-&gt;block_len_bytes &gt;&gt; <span class="hljs-number">0</span>);<font></font>
        len_nlen[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">uint8_t</span>)(s-&gt;block_len_bytes &gt;&gt; <span class="hljs-number">8</span>);<font></font>
        len_nlen[<span class="hljs-number">2</span>] = ~len_nlen[<span class="hljs-number">0</span>];<font></font>
        len_nlen[<span class="hljs-number">3</span>] = ~len_nlen[<span class="hljs-number">1</span>];<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!ostream_write_bytes_aligned(&amp;s-&gt;os, len_nlen, <span class="hljs-keyword">sizeof</span>(len_nlen))) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!ostream_write_bytes_aligned(&amp;s-&gt;os, s-&gt;block_src,<font></font>
                                         s-&gt;block_len_bytes)) {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para escribir un bloque est谩tico de Huffman, primero generamos c贸digos can贸nicos basados en longitudes de palabras de c贸digo fijas para los c贸digos litlen y dist. </font><font style="vertical-align: inherit;">Luego iteramos el bloque, escribiendo los caracteres que usan estos c贸digos:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_static_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">final</span>)</span>
</span>{
        <span class="hljs-keyword">huffman_encoder_t</span> litlen_enc, dist_enc;<font></font>
<font></font>
        <span class="hljs-comment">/* Write the block header. */</span>
        <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, (<span class="hljs-number">0x1</span> &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-keyword">final</span>, <span class="hljs-number">3</span>)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        huffman_encoder_init2(&amp;litlen_enc, fixed_litlen_lengths,<font></font>
                              <span class="hljs-keyword">sizeof</span>(fixed_litlen_lengths) /
                              <span class="hljs-keyword">sizeof</span>(fixed_litlen_lengths[<span class="hljs-number">0</span>]));<font></font>
        huffman_encoder_init2(&amp;dist_enc, fixed_dist_lengths,<font></font>
                              <span class="hljs-keyword">sizeof</span>(fixed_dist_lengths) /
                              <span class="hljs-keyword">sizeof</span>(fixed_dist_lengths[<span class="hljs-number">0</span>]));<font></font>
<font></font>
        <span class="hljs-keyword">return</span> write_huffman_block(s, &amp;litlen_enc, &amp;dist_enc);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_huffman_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *litlen_enc,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *dist_enc)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i, nbits;
        <span class="hljs-keyword">uint64_t</span> distance, dist, len, litlen, bits, ebits;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; s-&gt;block_len; i++) {
                <span class="hljs-keyword">if</span> (s-&gt;block[i].distance == <span class="hljs-number">0</span>) {
                        <span class="hljs-comment">/* Literal or EOB. */</span><font></font>
                        litlen = s-&gt;block[i].u.lit;<font></font>
                        assert(litlen &lt;= LITLEN_EOB);<font></font>
                        <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os,<font></font>
                                           litlen_enc-&gt;codewords[litlen],<font></font>
                                           litlen_enc-&gt;lengths[litlen])) {<font></font>
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Back reference length. */</span><font></font>
                len = s-&gt;block[i].u.len;<font></font>
                litlen = len2litlen[len];<font></font>
<font></font>
                <span class="hljs-comment">/* litlen bits */</span><font></font>
                bits = litlen_enc-&gt;codewords[litlen];<font></font>
                nbits = litlen_enc-&gt;lengths[litlen];<font></font>
<font></font>
                <span class="hljs-comment">/* ebits */</span><font></font>
                ebits = len - litlen_tbl[litlen - LITLEN_TBL_OFFSET].base_len;<font></font>
                bits |= ebits &lt;&lt; nbits;<font></font>
                nbits += litlen_tbl[litlen - LITLEN_TBL_OFFSET].ebits;<font></font>
<font></font>
                <span class="hljs-comment">/* Back reference distance. */</span><font></font>
                distance = s-&gt;block[i].distance;<font></font>
                dist = distance2dist[distance];<font></font>
<font></font>
                <span class="hljs-comment">/* dist bits */</span>
                bits |= (<span class="hljs-keyword">uint64_t</span>)dist_enc-&gt;codewords[dist] &lt;&lt; nbits;<font></font>
                nbits += dist_enc-&gt;lengths[dist];<font></font>
<font></font>
                <span class="hljs-comment">/* ebits */</span><font></font>
                ebits = distance - dist_tbl[dist].base_dist;<font></font>
                bits |= ebits &lt;&lt; nbits;<font></font>
                nbits += dist_tbl[dist].ebits;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, bits, nbits)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, escribir bloques din谩micos de Huffman es m谩s dif铆cil porque contienen codificaci贸n complicada de c贸digos litlen y dist. </font><font style="vertical-align: inherit;">Para representar esta codificaci贸n, utilizamos la siguiente estructura:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">codelen_sym_t</span> <span class="hljs-title">codelen_sym_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">codelen_sym_t</span> {</span>
        <span class="hljs-keyword">uint8_t</span> sym;
        <span class="hljs-keyword">uint8_t</span> count; <span class="hljs-comment">/* For symbols 16, 17, 18. */</span><font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, descartamos la cola de sus longitudes cero de las palabras de c贸digo litlen y dist, y luego las copiamos en una matriz regular para la codificaci贸n posterior. </font><font style="vertical-align: inherit;">No podemos descartar todos los ceros: es imposible codificar un bloque Deflate si no hay un 煤nico c贸digo dist en 茅l. </font><font style="vertical-align: inherit;">Tambi茅n es imposible tener menos de 257 c贸digos litlen, pero como siempre tenemos un marcador de finalizaci贸n de byte, siempre habr谩 una longitud de c贸digo distinta de cero para un car谩cter de 256.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Encode litlen_lens and dist_lens into encoded. *num_litlen_lens and
   *num_dist_lens will be set to the number of encoded litlen and dist lens,
   respectively. Returns the number of elements in encoded. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">encode_dist_litlen_lens</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *litlen_lens,
                                      <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *dist_lens,
                                      <span class="hljs-keyword">codelen_sym_t</span> *encoded,
                                      <span class="hljs-keyword">size_t</span> *num_litlen_lens,
                                      <span class="hljs-keyword">size_t</span> *num_dist_lens)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i, n;
        <span class="hljs-keyword">uint8_t</span> lens[LITLEN_MAX + <span class="hljs-number">1</span> + DISTSYM_MAX + <span class="hljs-number">1</span>];<font></font>
<font></font>
        *num_litlen_lens = LITLEN_MAX + <span class="hljs-number">1</span>;<font></font>
        *num_dist_lens = DISTSYM_MAX + <span class="hljs-number">1</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* Drop trailing zero litlen lengths. */</span>
        assert(litlen_lens[LITLEN_EOB] != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-string">"EOB len should be non-zero."</span>);
        <span class="hljs-keyword">while</span> (litlen_lens[*num_litlen_lens - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) {<font></font>
                (*num_litlen_lens)--;<font></font>
        }<font></font>
        assert(*num_litlen_lens &gt;= MIN_LITLEN_LENS);<font></font>
<font></font>
        <span class="hljs-comment">/* Drop trailing zero dist lengths, keeping at least one. */</span>
        <span class="hljs-keyword">while</span> (dist_lens[*num_dist_lens - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; *num_dist_lens &gt; <span class="hljs-number">1</span>) {<font></font>
                (*num_dist_lens)--;<font></font>
        }<font></font>
        assert(*num_dist_lens &gt;= MIN_DIST_LENS);<font></font>
<font></font>
        <span class="hljs-comment">/* Copy the lengths into a unified array. */</span>
        n = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; *num_litlen_lens; i++) {<font></font>
                lens[n++] = litlen_lens[i];<font></font>
        }<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; *num_dist_lens; i++) {<font></font>
                lens[n++] = dist_lens[i];<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> encode_lens(lens, n, encoded);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu茅s de agregar las longitudes de c贸digo en una matriz, realizamos la codificaci贸n utilizando caracteres especiales para ejecutar las mismas longitudes de c贸digo.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Encode the n code lengths in lens into encoded, returning the number of
   elements in encoded. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">encode_lens</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *lens, <span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">codelen_sym_t</span> *encoded)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i, j, num_encoded;
        <span class="hljs-keyword">uint8_t</span> count;<font></font>
<font></font>
        i = <span class="hljs-number">0</span>;<font></font>
        num_encoded = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (i &lt; n) {
                <span class="hljs-keyword">if</span> (lens[i] == <span class="hljs-number">0</span>) {
                        <span class="hljs-comment">/* Scan past the end of this zero run (max 138). */</span>
                        <span class="hljs-keyword">for</span> (j = i; j &lt; min(n, i + CODELEN_ZEROS2_MAX) &amp;&amp;<font></font>
                                    lens[j] == <span class="hljs-number">0</span>; j++);<font></font>
                        count = (<span class="hljs-keyword">uint8_t</span>)(j - i);<font></font>
<font></font>
                        <span class="hljs-keyword">if</span> (count &lt; CODELEN_ZEROS_MIN) {
                                <span class="hljs-comment">/* Output a single zero. */</span>
                                encoded[num_encoded++].sym = <span class="hljs-number">0</span>;<font></font>
                                i++;<font></font>
                                <span class="hljs-keyword">continue</span>;<font></font>
                        }<font></font>
<font></font>
                        <span class="hljs-comment">/* Output a repeated zero. */</span>
                        <span class="hljs-keyword">if</span> (count &lt;= CODELEN_ZEROS_MAX) {
                                <span class="hljs-comment">/* Repeated zero 3--10 times. */</span><font></font>
                                assert(count &gt;= CODELEN_ZEROS_MIN &amp;&amp;<font></font>
                                       count &lt;= CODELEN_ZEROS_MAX);<font></font>
                                encoded[num_encoded].sym = CODELEN_ZEROS;<font></font>
                                encoded[num_encoded++].count = count;<font></font>
                        } <span class="hljs-keyword">else</span> {
                                <span class="hljs-comment">/* Repeated zero 11--138 times. */</span><font></font>
                                assert(count &gt;= CODELEN_ZEROS2_MIN &amp;&amp;<font></font>
                                       count &lt;= CODELEN_ZEROS2_MAX);<font></font>
                                encoded[num_encoded].sym = CODELEN_ZEROS2;<font></font>
                                encoded[num_encoded++].count = count;<font></font>
                        }<font></font>
                        i = j;<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Output len. */</span><font></font>
                encoded[num_encoded++].sym = lens[i++];<font></font>
<font></font>
                <span class="hljs-comment">/* Scan past the end of the run of this len (max 6). */</span>
                <span class="hljs-keyword">for</span> (j = i; j &lt; min(n, i + CODELEN_COPY_MAX) &amp;&amp;<font></font>
                            lens[j] == lens[i - <span class="hljs-number">1</span>]; j++);<font></font>
                count = (<span class="hljs-keyword">uint8_t</span>)(j - i);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (count &gt;= CODELEN_COPY_MIN) {
                        <span class="hljs-comment">/* Repeat last len 3--6 times. */</span><font></font>
                        assert(count &gt;= CODELEN_COPY_MIN &amp;&amp;<font></font>
                               count &lt;= CODELEN_COPY_MAX);<font></font>
                        encoded[num_encoded].sym = CODELEN_COPY;<font></font>
                        encoded[num_encoded++].count = count;<font></font>
                        i = j;<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> num_encoded;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los caracteres utilizados para la codificaci贸n se grabar谩n utilizando el c贸digo Huffman - codelen. </font><font style="vertical-align: inherit;">Las longitudes de las palabras de c贸digo del c贸digo codelen se escriben en el bloque en un orden espec铆fico, de modo que es m谩s probable que las longitudes cero terminen al final. </font><font style="vertical-align: inherit;">Aqu铆 hay una funci贸n que calcula cu谩ntas longitudes se deben escribir:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> codelen_lengths_order[<span class="hljs-number">19</span>] =<font></font>
{ <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">13</span>, <span class="hljs-number">2</span>, <span class="hljs-number">14</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span> };<font></font>
<font></font>
<span class="hljs-comment">/* Count the number of significant (not trailing zeros) codelen lengths. */</span>
<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">count_codelen_lens</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *codelen_lens)</span>
</span>{
        <span class="hljs-keyword">size_t</span> n = MAX_CODELEN_LENS;<font></font>
<font></font>
        <span class="hljs-comment">/* Drop trailing zero lengths. */</span>
        <span class="hljs-keyword">while</span> (codelen_lens[codelen_lengths_order[n - <span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>) {<font></font>
                n--;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* The first 4 lengths in the order (16, 17, 18, 0) cannot be used to
           encode any non-zero lengths. Since there will always be at least
           one non-zero codeword length (for EOB), n will be &gt;= 4. */</span><font></font>
        assert(n &gt;= MIN_CODELEN_LENS &amp;&amp; n &lt;= MAX_CODELEN_LENS);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> n;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que ya hemos establecido los c贸digos litlen y dist, configuramos la codificaci贸n de las longitudes de sus palabras de c贸digo y el c贸digo para estas longitudes. </font><font style="vertical-align: inherit;">Ahora podemos escribir un bloque din谩mico de Huffman:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_dynamic_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">final</span>,
                                <span class="hljs-keyword">size_t</span> num_litlen_lens, <span class="hljs-keyword">size_t</span> num_dist_lens,
                                <span class="hljs-keyword">size_t</span> num_codelen_lens,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *codelen_enc,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">codelen_sym_t</span> *encoded_lens,
                                <span class="hljs-keyword">size_t</span> num_encoded_lens,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *litlen_enc,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *dist_enc)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;
        <span class="hljs-keyword">uint8_t</span> codelen, sym;
        <span class="hljs-keyword">size_t</span> nbits;
        <span class="hljs-keyword">uint64_t</span> bits, hlit, hdist, hclen, count;<font></font>
<font></font>
        <span class="hljs-comment">/* Block header. */</span>
        bits = (<span class="hljs-number">0x2</span> &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-keyword">final</span>;<font></font>
        nbits = <span class="hljs-number">3</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* hlit (5 bits) */</span><font></font>
        hlit = num_litlen_lens - MIN_LITLEN_LENS;<font></font>
        bits |= hlit &lt;&lt; nbits;<font></font>
        nbits += <span class="hljs-number">5</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* hdist (5 bits) */</span><font></font>
        hdist = num_dist_lens - MIN_DIST_LENS;<font></font>
        bits |= hdist &lt;&lt; nbits;<font></font>
        nbits += <span class="hljs-number">5</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* hclen (4 bits) */</span><font></font>
        hclen = num_codelen_lens - MIN_CODELEN_LENS;<font></font>
        bits |= hclen &lt;&lt; nbits;<font></font>
        nbits += <span class="hljs-number">4</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, bits, nbits)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Codelen lengths. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_codelen_lens; i++) {<font></font>
                codelen = codelen_enc-&gt;lengths[codelen_lengths_order[i]];<font></font>
                <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, codelen, <span class="hljs-number">3</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Litlen and dist code lengths. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_encoded_lens; i++) {<font></font>
                sym = encoded_lens[i].sym;<font></font>
<font></font>
                bits = codelen_enc-&gt;codewords[sym];<font></font>
                nbits = codelen_enc-&gt;lengths[sym];<font></font>
<font></font>
                count = encoded_lens[i].count;<font></font>
                <span class="hljs-keyword">if</span> (sym == CODELEN_COPY) { <span class="hljs-comment">/* 2 ebits */</span><font></font>
                        bits |= (count - CODELEN_COPY_MIN) &lt;&lt; nbits;<font></font>
                        nbits += <span class="hljs-number">2</span>;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_ZEROS) { <span class="hljs-comment">/* 3 ebits */</span><font></font>
                        bits |= (count - CODELEN_ZEROS_MIN) &lt;&lt; nbits;<font></font>
                        nbits += <span class="hljs-number">3</span>;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_ZEROS2) { <span class="hljs-comment">/* 7 ebits */</span><font></font>
                        bits |= (count - CODELEN_ZEROS2_MIN) &lt;&lt; nbits;<font></font>
                        nbits += <span class="hljs-number">7</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, bits, nbits)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> write_huffman_block(s, litlen_enc, dist_enc);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para cada bloque, queremos usar el tipo que requiere el menor n煤mero de bits. </font><font style="vertical-align: inherit;">La longitud de un bloque sin comprimir se puede calcular r谩pidamente:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Calculate the number of bits for an uncompressed block, including header. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">uncomp_block_len</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">deflate_state_t</span> *s)</span>
</span>{
        <span class="hljs-keyword">size_t</span> bit_pos, padding;<font></font>
<font></font>
        <span class="hljs-comment">/* Bit position after writing the block header. */</span>
        bit_pos = ostream_bit_pos(&amp;s-&gt;os) + <span class="hljs-number">3</span>;<font></font>
        padding = round_up(bit_pos, <span class="hljs-number">8</span>) - bit_pos;<font></font>
<font></font>
        <span class="hljs-comment">/* Header + padding + len/nlen + block contents. */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> + padding + <span class="hljs-number">2</span> * <span class="hljs-number">16</span> + s-&gt;block_len_bytes * <span class="hljs-number">8</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para los bloques codificados de Huffman, puede calcular la longitud del cuerpo utilizando las frecuencias litlen y dist de caracteres y las longitudes de las palabras de c贸digo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Calculate the number of bits for a Huffman encoded block body. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">huffman_block_body_len</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">deflate_state_t</span> *s,
                                     <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *litlen_lens,
                                     <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *dist_lens)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i, freq, len;<font></font>
<font></font>
        len = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= LITLEN_MAX; i++) {<font></font>
                freq = s-&gt;litlen_freqs[i];<font></font>
                len += litlen_lens[i] * freq;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (i &gt;= LITLEN_TBL_OFFSET) {<font></font>
                        len += litlen_tbl[i - LITLEN_TBL_OFFSET].ebits * freq;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= DISTSYM_MAX; i++) {<font></font>
                freq = s-&gt;dist_freqs[i];<font></font>
                len += dist_lens[i] * freq;<font></font>
                len += dist_tbl[i].ebits * freq;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> len;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La longitud total del bloque est谩tico es de 3 bits del encabezado m谩s la longitud del cuerpo. </font><font style="vertical-align: inherit;">Calcular el tama帽o del encabezado de un bloque din谩mico requiere mucho m谩s trabajo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Calculate the number of bits for a dynamic Huffman block. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">dyn_block_len</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">size_t</span> num_codelen_lens,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> *codelen_freqs,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *codelen_enc,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *litlen_enc,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *dist_enc)</span>
</span>{
        <span class="hljs-keyword">size_t</span> len, i, freq;<font></font>
<font></font>
        <span class="hljs-comment">/* Block header. */</span>
        len = <span class="hljs-number">3</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* Nbr of litlen, dist, and codelen lengths. */</span>
        len += <span class="hljs-number">5</span> + <span class="hljs-number">5</span> + <span class="hljs-number">4</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* Codelen lengths. */</span>
        len += <span class="hljs-number">3</span> * num_codelen_lens;<font></font>
<font></font>
        <span class="hljs-comment">/* Codelen encoding. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_CODELEN_LENS; i++) {<font></font>
                freq = codelen_freqs[i];<font></font>
                len += codelen_enc-&gt;lengths[i] * freq;<font></font>
<font></font>
                <span class="hljs-comment">/* Extra bits. */</span>
                <span class="hljs-keyword">if</span> (i == CODELEN_COPY) {<font></font>
                        len += <span class="hljs-number">2</span> * freq;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == CODELEN_ZEROS) {<font></font>
                        len += <span class="hljs-number">3</span> * freq;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == CODELEN_ZEROS2) {<font></font>
                        len += <span class="hljs-number">7</span> * freq;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> len + huffman_block_body_len(s, litlen_enc-&gt;lengths,<font></font>
                                            dist_enc-&gt;lengths);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora juntaremos todo y crearemos la funci贸n principal para escribir bloques:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Write the current deflate block, marking it final if that parameter is true,
   returning false if there is not enough room in the output stream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">final</span>)</span>
</span>{
        <span class="hljs-keyword">size_t</span> old_bit_pos, uncomp_len, static_len, dynamic_len;
        <span class="hljs-keyword">huffman_encoder_t</span> dyn_litlen_enc, dyn_dist_enc, codelen_enc;
        <span class="hljs-keyword">size_t</span> num_encoded_lens, num_litlen_lens, num_dist_lens;
        <span class="hljs-keyword">codelen_sym_t</span> encoded_lens[LITLEN_MAX + <span class="hljs-number">1</span> + DISTSYM_MAX + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">uint16_t</span> codelen_freqs[MAX_CODELEN_LENS] = {<span class="hljs-number">0</span>};
        <span class="hljs-keyword">size_t</span> num_codelen_lens;
        <span class="hljs-keyword">size_t</span> i;<font></font>
<font></font>
        old_bit_pos = ostream_bit_pos(&amp;s-&gt;os);<font></font>
<font></font>
        <span class="hljs-comment">/* Add the end-of-block marker in case we write a Huffman block. */</span>
        assert(s-&gt;block_len &lt; <span class="hljs-keyword">sizeof</span>(s-&gt;block) / <span class="hljs-keyword">sizeof</span>(s-&gt;block[<span class="hljs-number">0</span>]));<font></font>
        assert(s-&gt;litlen_freqs[LITLEN_EOB] == <span class="hljs-number">0</span>);<font></font>
        s-&gt;block[s-&gt;block_len  ].distance = <span class="hljs-number">0</span>;<font></font>
        s-&gt;block[s-&gt;block_len++].u.lit = LITLEN_EOB;<font></font>
        s-&gt;litlen_freqs[LITLEN_EOB] = <span class="hljs-number">1</span>;<font></font>
<font></font>
        uncomp_len = uncomp_block_len(s);<font></font>
<font></font>
        static_len = <span class="hljs-number">3</span> + huffman_block_body_len(s, fixed_litlen_lengths,<font></font>
                                                fixed_dist_lengths);<font></font>
<font></font>
        <span class="hljs-comment">/* Compute "dynamic" Huffman codes. */</span><font></font>
        huffman_encoder_init(&amp;dyn_litlen_enc, s-&gt;litlen_freqs,<font></font>
                             LITLEN_MAX + <span class="hljs-number">1</span>, <span class="hljs-number">15</span>);<font></font>
        huffman_encoder_init(&amp;dyn_dist_enc, s-&gt;dist_freqs, DISTSYM_MAX + <span class="hljs-number">1</span>, <span class="hljs-number">15</span>);<font></font>
<font></font>
        <span class="hljs-comment">/* Encode the litlen and dist code lengths. */</span><font></font>
        num_encoded_lens = encode_dist_litlen_lens(dyn_litlen_enc.lengths,<font></font>
                                                   dyn_dist_enc.lengths,<font></font>
                                                   encoded_lens,<font></font>
                                                   &amp;num_litlen_lens,<font></font>
                                                   &amp;num_dist_lens);<font></font>
<font></font>
        <span class="hljs-comment">/* Compute the codelen code. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_encoded_lens; i++) {<font></font>
                codelen_freqs[encoded_lens[i].sym]++;<font></font>
        }<font></font>
        huffman_encoder_init(&amp;codelen_enc, codelen_freqs, MAX_CODELEN_LENS, <span class="hljs-number">7</span>);<font></font>
        num_codelen_lens = count_codelen_lens(codelen_enc.lengths);<font></font>
<font></font>
        dynamic_len = dyn_block_len(s, num_codelen_lens, codelen_freqs,<font></font>
                                    &amp;codelen_enc, &amp;dyn_litlen_enc,<font></font>
                                    &amp;dyn_dist_enc);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (uncomp_len &lt;= dynamic_len &amp;&amp; uncomp_len &lt;= static_len) {
                <span class="hljs-keyword">if</span> (!write_uncomp_block(s, <span class="hljs-keyword">final</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                assert(ostream_bit_pos(&amp;s-&gt;os) - old_bit_pos == uncomp_len);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (static_len &lt;= dynamic_len) {
                <span class="hljs-keyword">if</span> (!write_static_block(s, <span class="hljs-keyword">final</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                assert(ostream_bit_pos(&amp;s-&gt;os) - old_bit_pos == static_len);<font></font>
        } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (!write_dynamic_block(s, <span class="hljs-keyword">final</span>, num_litlen_lens,<font></font>
                                         num_dist_lens, num_codelen_lens,<font></font>
                                         &amp;codelen_enc, encoded_lens,<font></font>
                                         num_encoded_lens, &amp;dyn_litlen_enc,<font></font>
                                         &amp;dyn_dist_enc)) {<font></font>
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                assert(ostream_bit_pos(&amp;s-&gt;os) - old_bit_pos == dynamic_len);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, el iniciador de todo el proceso de compresi贸n debe establecer el estado inicial, iniciar la compresi贸n Lempel-Ziv y escribir el bloque resultante:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Compress (deflate) the data in src into dst. The number of bytes output, at
   most dst_cap, is stored in *dst_used. Returns false if there is not enough
   room in dst. src and dst must not overlap. */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hwdeflate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len, <span class="hljs-keyword">uint8_t</span> *dst,
               <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_used)</span>
</span>{
        <span class="hljs-keyword">deflate_state_t</span> s;<font></font>
<font></font>
        ostream_init(&amp;s.os, dst, dst_cap);<font></font>
        reset_block(&amp;s);<font></font>
        s.block_src = src;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!lz77_compress(src, src_len, &amp;lit_callback,<font></font>
                           &amp;backref_callback, &amp;s)) {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!write_block(&amp;s, <span class="hljs-literal">true</span>)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* The end of the final block should match the end of src. */</span><font></font>
        assert(s.block_src + s.block_len_bytes == src + src_len);<font></font>
<font></font>
        *dst_used = ostream_bytes_written(&amp;s.os);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br>
<a name="17"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formato de archivo zip</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arriba, examinamos c贸mo funciona la compresi贸n Deflate utilizada en los archivos Zip. </font><font style="vertical-align: inherit;">驴Qu茅 pasa con el formato de archivo en s铆? </font><font style="vertical-align: inherit;">En esta parte, examinaremos en detalle su estructura e implementaci贸n. </font><font style="vertical-align: inherit;">El c贸digo est谩 disponible en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zip.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zip.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="18"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visi贸n general</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El formato del archivo se describe en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota de aplicaci贸n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PKZip </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada archivo, o elemento de archivo, en un archivo zip tiene un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encabezado de archivo local</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con metadatos sobre el elemento.</font></font></li>
<li><i> </i>   .         ,      ,    ,      Zip-.</li>
<li>  ,     <i>   </i>.       ,        .     Zip-.</li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/821/bba/6ce/821bba6cede767c834da639e00d7d6ba.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada elemento del archivo se comprime y almacena individualmente. Esto significa que incluso si hay coincidencias entre archivos en el archivo, no se tendr谩n en cuenta para mejorar la compresi贸n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La ubicaci贸n del cat谩logo central al final le permite completar gradualmente el archivo. A medida que los elementos del archivo se comprimen, se agregan al archivo. El 铆ndice se registra despu茅s de todos los tama帽os comprimidos, lo que le permite conocer las compensaciones de todos los archivos. Agregar archivos a un archivo existente es bastante f谩cil, se coloca despu茅s del 煤ltimo elemento y se sobrescribe el directorio central.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La capacidad de crear archivos gradualmente fue especialmente importante para diseminar informaci贸n en numerosos disquetes o vol煤menes. Mientras se comprim铆a, PKZip sugiri贸 que los usuarios insertaran nuevos disquetes y escribieran el directorio central en los 煤ltimos (煤ltimos). Para descomprimir un archivo de varios vol煤menes, PKZip primero solicit贸 el 煤ltimo disquete para escribir para leer el directorio central, y luego el resto del disquete necesario para extraer los archivos solicitados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto puede sorprenderlo, pero no hab铆a una regla que prohibiera tener m煤ltiples archivos con el mismo nombre en el archivo. Esto podr铆a generar mucha confusi贸n al desempacar: si hay varios archivos con el mismo nombre, 驴cu谩l deber铆a desempaquetar? A su vez, esto podr铆a conducir a problemas de seguridad. Debido al error "Master Key" en Android (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CVE-2013-4787</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diapositivas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del informe sobre Black Hat) un atacante podr铆a pasar por alto las comprobaciones del sistema operativo de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">firma criptogr谩fica</font></a><font style="vertical-align: inherit;"> al instalar programas. Los programas de Android se distribuyen en </font><font style="vertical-align: inherit;">archivos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que son archivos Zip. Al final result贸 que, si el APK conten铆a varios archivos con el mismo nombre, el c贸digo de verificaci贸n de firma seleccion贸 el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">煤ltimo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> archivo con el mismo nombre, y el instalador seleccion贸 el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> archivo, es decir, la verificaci贸n no se realiz贸. En otras palabras, esta peque帽a diferencia entre las dos bibliotecas Zip hizo posible omitir todo el modelo de seguridad del sistema operativo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A diferencia de la mayor铆a de los formatos, los archivos zip no deben comenzar con una firma o un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n煤mero m谩gico</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por lo general, no se indica que el archivo Zip deba comenzar de ninguna manera espec铆fica, lo que le permite crear f谩cilmente archivos que son v谩lidos como Zip y como un formato diferente: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archivos pol铆glotas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Por ejemplo, los archivos Zip autoextra铆bles (por ejemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pkz204g.exe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) suelen ser tanto archivos ejecutables como Zip: la primera parte es ejecutable, seguida de un archivo Zip (que la parte ejecutable desempaqueta). El sistema operativo puede ejecutarlo como ejecutable, pero el programa Zip lo abrir谩 como un archivo Zip. Tal caracter铆stica podr铆a hacer que no se requiera una firma al comienzo del archivo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aunque estos archivos pol铆glotas son inteligentes, pueden provocar problemas de seguridad porque pueden enga帽ar a los programas que intentan determinar el contenido del archivo y tambi茅n permiten entregar c贸digo malicioso en un lugar con archivos de diferentes tipos. Por ejemplo, los exploits utilizaron </font><font style="vertical-align: inherit;">archivos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GIFAR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que al mismo tiempo son im谩genes GIF correctas y archivos Java (JAR, un tipo de archivo Zip). Para obtener m谩s informaci贸n sobre este problema, consulte el art铆culo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abuso de formatos de archivo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (a partir de la p谩gina 18). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como veremos a continuaci贸n, los archivos Zip usan campos de 32 bits para desplazamientos y tama帽os para limitar el tama帽o del archivo y sus elementos a cuatro gigabytes. En la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nota de aplicaci贸n 4.5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PKWare ha agregado extensiones de formato que permiten el uso de compensaciones y tama帽os de 64 bits. Los archivos que usan estas extensiones est谩n en formato Zip64, pero no los consideraremos.</font></font><br>
<br>
<a name="19"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estructuras de datos</font></font></h3><br>
<a name="20"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fin de la entrada del directorio central</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El final de una entrada de directorio central (EOCDR) se usa generalmente como punto de partida para leer un archivo zip. Contiene la ubicaci贸n y el tama帽o del directorio central, as铆 como comentarios opcionales sobre todo el archivo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los archivos zip que ocupaban varios disquetes, o vol煤menes, el EOCDR tambi茅n conten铆a informaci贸n sobre qu茅 disco estamos usando actualmente, en qu茅 disco se inicia el directorio central, etc. Hoy, esta funcionalidad rara vez se usa, y el c贸digo de este art铆culo no procesa dichos archivos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EOCDR est谩 determinado por la firma 'P' 'K', seguido de los bytes 5 y 6. Le sigue la estructura a continuaci贸n, los n煤meros se almacenan de acuerdo con el principio little-endian:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* End of Central Directory Record. */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eocdr</span> {</span>
        <span class="hljs-keyword">uint16_t</span> disk_nbr;        <span class="hljs-comment">/* Number of this disk. */</span>
        <span class="hljs-keyword">uint16_t</span> cd_start_disk;   <span class="hljs-comment">/* Nbr. of disk with start of the CD. */</span>
        <span class="hljs-keyword">uint16_t</span> disk_cd_entries; <span class="hljs-comment">/* Nbr. of CD entries on this disk. */</span>
        <span class="hljs-keyword">uint16_t</span> cd_entries;      <span class="hljs-comment">/* Nbr. of Central Directory entries. */</span>
        <span class="hljs-keyword">uint32_t</span> cd_size;         <span class="hljs-comment">/* Central Directory size in bytes. */</span>
        <span class="hljs-keyword">uint32_t</span> cd_offset;       <span class="hljs-comment">/* Central Directory file offset. */</span>
        <span class="hljs-keyword">uint16_t</span> comment_len;     <span class="hljs-comment">/* Archive comment length. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comment;   <span class="hljs-comment">/* Archive comment. */</span><font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EOCDR debe ubicarse al final del archivo. </font><font style="vertical-align: inherit;">Pero dado que puede haber un comentario de longitud arbitraria de 16 bits en su cola, puede ser necesario encontrar una posici贸n espec铆fica:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Read 16/32 bits little-endian and bump p forward afterwards. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> READ16(p) ((p) += 2, read16le((p) - 2))</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> READ32(p) ((p) += 4, read32le((p) - 4))</span><font></font>
<font></font>
<span class="hljs-comment">/* Size of the End of Central Directory Record, not including comment. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EOCDR_BASE_SZ 22</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EOCDR_SIGNATURE 0x06054b50  <span class="hljs-comment">/* "PK\5\6" little-endian. */</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">find_eocdr</span><span class="hljs-params">(struct eocdr *r, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len)</span>
</span>{
        <span class="hljs-keyword">size_t</span> comment_len;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint32_t</span> signature;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (comment_len = <span class="hljs-number">0</span>; comment_len &lt;= UINT16_MAX; comment_len++) {
                <span class="hljs-keyword">if</span> (src_len &lt; EOCDR_BASE_SZ + comment_len) {
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
<font></font>
                p = &amp;src[src_len - EOCDR_BASE_SZ - comment_len];<font></font>
                signature = READ32(p);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (signature == EOCDR_SIGNATURE) {<font></font>
                        r-&gt;disk_nbr = READ16(p);<font></font>
                        r-&gt;cd_start_disk = READ16(p);<font></font>
                        r-&gt;disk_cd_entries = READ16(p);<font></font>
                        r-&gt;cd_entries = READ16(p);<font></font>
                        r-&gt;cd_size = READ32(p);<font></font>
                        r-&gt;cd_offset = READ32(p);<font></font>
                        r-&gt;comment_len = READ16(p);<font></font>
                        r-&gt;comment = p;<font></font>
                        assert(p == &amp;src[src_len - comment_len] &amp;&amp;<font></font>
                               <span class="hljs-string">"All fields read."</span>);<font></font>
<font></font>
                        <span class="hljs-keyword">if</span> (r-&gt;comment_len == comment_len) {
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
                        }<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grabar EOCDR es f谩cil. </font><font style="vertical-align: inherit;">Esta funci贸n escribe y devuelve el n煤mero de bytes escritos:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Write 16/32 bits little-endian and bump p forward afterwards. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WRITE16(p, x) (write16le((p), (x)), (p) += 2)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WRITE32(p, x) (write32le((p), (x)), (p) += 4)</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">write_eocdr</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">const</span> struct eocdr *r)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p = dst;<font></font>
<font></font>
        WRITE32(p, EOCDR_SIGNATURE);<font></font>
        WRITE16(p, r-&gt;disk_nbr);<font></font>
        WRITE16(p, r-&gt;cd_start_disk);<font></font>
        WRITE16(p, r-&gt;disk_cd_entries);<font></font>
        WRITE16(p, r-&gt;cd_entries);<font></font>
        WRITE32(p, r-&gt;cd_size);<font></font>
        WRITE32(p, r-&gt;cd_offset);<font></font>
        WRITE16(p, r-&gt;comment_len);<font></font>
        assert(p - dst == EOCDR_BASE_SZ);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (r-&gt;comment_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, r-&gt;comment, r-&gt;comment_len);<font></font>
                p += r-&gt;comment_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">size_t</span>)(p - dst);<font></font>
}<font></font>
</code></pre><br>
<a name="21"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encabezado de archivo central</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El directorio central consta de encabezados de archivo central escritos uno tras otro, uno para cada elemento de archivo. </font><font style="vertical-align: inherit;">Cada encabezado comienza con la firma 'P', 'K', 1, 2, y luego existe dicha estructura:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXT_ATTR_DIR (1U &lt;&lt; 4)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXT_ATTR_ARC (1U &lt;&lt; 5)</span><font></font>
<font></font>
<span class="hljs-comment">/* Central File Header (Central Directory Entry) */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfh</span> {</span>
        <span class="hljs-keyword">uint16_t</span> made_by_ver;    <span class="hljs-comment">/* Version made by. */</span>
        <span class="hljs-keyword">uint16_t</span> extract_ver;    <span class="hljs-comment">/* Version needed to extract. */</span>
        <span class="hljs-keyword">uint16_t</span> gp_flag;        <span class="hljs-comment">/* General purpose bit flag. */</span>
        <span class="hljs-keyword">uint16_t</span> method;         <span class="hljs-comment">/* Compression method. */</span>
        <span class="hljs-keyword">uint16_t</span> mod_time;       <span class="hljs-comment">/* Modification time. */</span>
        <span class="hljs-keyword">uint16_t</span> mod_date;       <span class="hljs-comment">/* Modification date. */</span>
        <span class="hljs-keyword">uint32_t</span> crc32;          <span class="hljs-comment">/* CRC-32 checksum. */</span>
        <span class="hljs-keyword">uint32_t</span> comp_size;      <span class="hljs-comment">/* Compressed size. */</span>
        <span class="hljs-keyword">uint32_t</span> uncomp_size;    <span class="hljs-comment">/* Uncompressed size. */</span>
        <span class="hljs-keyword">uint16_t</span> name_len;       <span class="hljs-comment">/* Filename length. */</span>
        <span class="hljs-keyword">uint16_t</span> extra_len;      <span class="hljs-comment">/* Extra data length. */</span>
        <span class="hljs-keyword">uint16_t</span> comment_len;    <span class="hljs-comment">/* Comment length. */</span>
        <span class="hljs-keyword">uint16_t</span> disk_nbr_start; <span class="hljs-comment">/* Disk nbr. where file begins. */</span>
        <span class="hljs-keyword">uint16_t</span> int_attrs;      <span class="hljs-comment">/* Internal file attributes. */</span>
        <span class="hljs-keyword">uint32_t</span> ext_attrs;      <span class="hljs-comment">/* External file attributes. */</span>
        <span class="hljs-keyword">uint32_t</span> lfh_offset;     <span class="hljs-comment">/* Local File Header offset. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *name;     <span class="hljs-comment">/* Filename. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *extra;    <span class="hljs-comment">/* Extra data. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comment;  <span class="hljs-comment">/* File comment. */</span><font></font>
};<font></font>
</code></pre><br>
<code>made_by_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>extract_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codificar informaci贸n sobre el sistema operativo y la versi贸n del programa utilizado para agregar este elemento, as铆 como qu茅 versi贸n se necesita para recuperarlo. </font><font style="vertical-align: inherit;">Los ocho bits m谩s importantes codifican el sistema operativo (por ejemplo, 0 significa DOS, 3 significa Unix, 10 significa Windows NTFS), y los ocho bits inferiores codifican la versi贸n del software. </font><font style="vertical-align: inherit;">Establezca el valor decimal en 20, lo que significa compatibilidad con PKZip 2.0. </font></font><br>
<br>
<code>gp_flag</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contiene diferentes banderas. </font><font style="vertical-align: inherit;">Estamos interesados:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 0, que indica el hecho de cifrado del elemento (no consideraremos esto);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y los bits 1 y 2, que codifican el nivel de compresi贸n Deflate (0 - normal, 1 - m谩ximo, 2 - r谩pido, 3 - muy r谩pido).</font></font></li>
</ul><br>
<code>method</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codifica un m茅todo de compresi贸n. 0 - datos no comprimidos, 8 - Delate aplicado. Otros valores se relacionan con algoritmos antiguos o nuevos, pero casi todos los Zip usan estos dos valores. </font></font><br>
<br>
<code>mod_time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>mod_date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contienen la fecha y hora en que se modific贸 el archivo, codificado en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">formato MS-DOS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Usando este c贸digo, convertiremos las marcas </font></font><code>time_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font><font style="vertical-align: inherit;">tiempo C habituales </font><font style="vertical-align: inherit;">hacia y desde el formato MS-DOS:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Convert DOS date and time to time_t. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">time_t</span> <span class="hljs-title">dos2ctime</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> dos_date, <span class="hljs-keyword">uint16_t</span> dos_time)</span>
</span>{
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> <span class="hljs-title">tm</span> = {</span><span class="hljs-number">0</span>};<font></font>
<font></font>
        tm.tm_sec = (dos_time &amp; <span class="hljs-number">0x1f</span>) * <span class="hljs-number">2</span>;  <span class="hljs-comment">/* Bits 0--4:  Secs divided by 2. */</span>
        tm.tm_min = (dos_time &gt;&gt; <span class="hljs-number">5</span>) &amp; <span class="hljs-number">0x3f</span>; <span class="hljs-comment">/* Bits 5--10: Minute. */</span>
        tm.tm_hour = (dos_time &gt;&gt; <span class="hljs-number">11</span>);      <span class="hljs-comment">/* Bits 11-15: Hour (0--23). */</span><font></font>
<font></font>
        tm.tm_mday = (dos_date &amp; <span class="hljs-number">0x1f</span>);          <span class="hljs-comment">/* Bits 0--4: Day (1--31). */</span>
        tm.tm_mon = ((dos_date &gt;&gt; <span class="hljs-number">5</span>) &amp; <span class="hljs-number">0xf</span>) - <span class="hljs-number">1</span>; <span class="hljs-comment">/* Bits 5--8: Month (1--12). */</span>
        tm.tm_year = (dos_date &gt;&gt; <span class="hljs-number">9</span>) + <span class="hljs-number">80</span>;       <span class="hljs-comment">/* Bits 9--15: Year-1980. */</span><font></font>
<font></font>
        tm.tm_isdst = <span class="hljs-number">-1</span>;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> mktime(&amp;tm);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Convert time_t to DOS date and time. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ctime2dos</span><span class="hljs-params">(<span class="hljs-keyword">time_t</span> t, <span class="hljs-keyword">uint16_t</span> *dos_date, <span class="hljs-keyword">uint16_t</span> *dos_time)</span>
</span>{
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">tm</span> = <span class="hljs-title">localtime</span>(&amp;<span class="hljs-title">t</span>);</span><font></font>
<font></font>
        *dos_time = <span class="hljs-number">0</span>;<font></font>
        *dos_time |= tm-&gt;tm_sec / <span class="hljs-number">2</span>;    <span class="hljs-comment">/* Bits 0--4:  Second divided by two. */</span>
        *dos_time |= tm-&gt;tm_min &lt;&lt; <span class="hljs-number">5</span>;   <span class="hljs-comment">/* Bits 5--10: Minute. */</span>
        *dos_time |= tm-&gt;tm_hour &lt;&lt; <span class="hljs-number">11</span>; <span class="hljs-comment">/* Bits 11-15: Hour. */</span><font></font>
<font></font>
        *dos_date = <span class="hljs-number">0</span>;<font></font>
        *dos_date |= tm-&gt;tm_mday;             <span class="hljs-comment">/* Bits 0--4:  Day (1--31). */</span>
        *dos_date |= (tm-&gt;tm_mon + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">5</span>;   <span class="hljs-comment">/* Bits 5--8:  Month (1--12). */</span>
        *dos_date |= (tm-&gt;tm_year - <span class="hljs-number">80</span>) &lt;&lt; <span class="hljs-number">9</span>; <span class="hljs-comment">/* Bits 9--15: Year from 1980. */</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El campo </font></font><code>crc32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contiene el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor del c贸digo c铆clico redundante de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> datos sin comprimir. Se utiliza para verificar la integridad de los datos despu茅s de la recuperaci贸n. Implementaci贸n aqu铆: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crc32.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<code>comp_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>uncomp_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contienen el tama帽o comprimido y sin comprimir de los datos del archivo del elemento. Los siguientes tres campos contienen la longitud del nombre, comentario y datos adicionales inmediatamente despu茅s del t铆tulo. </font></font><code>disk_nbr_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dise帽ado para archivos que utilizan m煤ltiples disquetes. </font></font><br>
<br>
<code>int_attrs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>ext_attrs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">describa los atributos internos y externos del archivo. Los internos se relacionan con el contenido del archivo, por ejemplo, el bit menos significativo indica si el archivo contiene solo texto. Los atributos externos indican si el archivo est谩 oculto, es de solo lectura, etc. El contenido de estos campos depende del sistema operativo, en particular, de</font></font><code>made_by_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En DOS, los 8 bits inferiores contienen el byte de atributo de archivo, que se puede obtener de la llamada al sistema </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Int 21 / AX = 4300h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Por ejemplo, el bit 4 significa que es un directorio, y el bit 5 significa que el atributo "archivo" est谩 establecido (verdadero para la mayor铆a de los archivos en DOS). Por lo que yo entiendo, en aras de la compatibilidad, estos bits se configuran de manera similar en otros sistemas operativos. En Unix, los 16 bits m谩s altos de este campo contienen bits de modo de archivo que son devueltos por </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stat (2)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en </font></font><code>st_mode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<code>lfh_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nos dice d贸nde buscar el encabezado del archivo local. </font></font><code>name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- nombre de archivo (l铆nea C), y </font></font><code>comment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- comentario opcional para este elemento de archivo (l铆nea C). </font></font><code>extra</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede contener datos adicionales opcionales, como informaci贸n sobre el propietario del archivo Unix, fecha y hora m谩s precisas del cambio o campos Zip64.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta funci贸n se usa para leer los encabezados centrales de los archivos:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Size of a Central File Header, not including name, extra, and comment. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CFH_BASE_SZ 46</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CFH_SIGNATURE 0x02014b50 <span class="hljs-comment">/* "PK\1\2" little-endian. */</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">read_cfh</span><span class="hljs-params">(struct cfh *cfh, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len,
                     <span class="hljs-keyword">size_t</span> offset)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint32_t</span> signature;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (offset &gt; src_len || src_len - offset &lt; CFH_BASE_SZ) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        p = &amp;src[offset];<font></font>
        signature = READ32(p);<font></font>
        <span class="hljs-keyword">if</span> (signature != CFH_SIGNATURE) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        cfh-&gt;made_by_ver = READ16(p);<font></font>
        cfh-&gt;extract_ver = READ16(p);<font></font>
        cfh-&gt;gp_flag = READ16(p);<font></font>
        cfh-&gt;method = READ16(p);<font></font>
        cfh-&gt;mod_time = READ16(p);<font></font>
        cfh-&gt;mod_date = READ16(p);<font></font>
        cfh-&gt;crc32 = READ32(p);<font></font>
        cfh-&gt;comp_size = READ32(p);<font></font>
        cfh-&gt;uncomp_size = READ32(p);<font></font>
        cfh-&gt;name_len = READ16(p);<font></font>
        cfh-&gt;extra_len = READ16(p);<font></font>
        cfh-&gt;comment_len = READ16(p);<font></font>
        cfh-&gt;disk_nbr_start = READ16(p);<font></font>
        cfh-&gt;int_attrs = READ16(p);<font></font>
        cfh-&gt;ext_attrs = READ32(p);<font></font>
        cfh-&gt;lfh_offset = READ32(p);<font></font>
        cfh-&gt;name = p;<font></font>
        cfh-&gt;extra = cfh-&gt;name + cfh-&gt;name_len;<font></font>
        cfh-&gt;comment = cfh-&gt;extra + cfh-&gt;extra_len;<font></font>
        assert(p == &amp;src[offset + CFH_BASE_SZ] &amp;&amp; <span class="hljs-string">"All fields read."</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (src_len - offset - CFH_BASE_SZ &lt;<font></font>
            cfh-&gt;name_len + cfh-&gt;extra_len + cfh-&gt;comment_len) {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">write_cfh</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">const</span> struct cfh *cfh)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p = dst;<font></font>
<font></font>
        WRITE32(p, CFH_SIGNATURE);<font></font>
        WRITE16(p, cfh-&gt;made_by_ver);<font></font>
        WRITE16(p, cfh-&gt;extract_ver);<font></font>
        WRITE16(p, cfh-&gt;gp_flag);<font></font>
        WRITE16(p, cfh-&gt;method);<font></font>
        WRITE16(p, cfh-&gt;mod_time);<font></font>
        WRITE16(p, cfh-&gt;mod_date);<font></font>
        WRITE32(p, cfh-&gt;crc32);<font></font>
        WRITE32(p, cfh-&gt;comp_size);<font></font>
        WRITE32(p, cfh-&gt;uncomp_size);<font></font>
        WRITE16(p, cfh-&gt;name_len);<font></font>
        WRITE16(p, cfh-&gt;extra_len);<font></font>
        WRITE16(p, cfh-&gt;comment_len);<font></font>
        WRITE16(p, cfh-&gt;disk_nbr_start);<font></font>
        WRITE16(p, cfh-&gt;int_attrs);<font></font>
        WRITE32(p, cfh-&gt;ext_attrs);<font></font>
        WRITE32(p, cfh-&gt;lfh_offset);<font></font>
        assert(p - dst == CFH_BASE_SZ);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (cfh-&gt;name_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, cfh-&gt;name, cfh-&gt;name_len);<font></font>
                p += cfh-&gt;name_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (cfh-&gt;extra_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, cfh-&gt;extra, cfh-&gt;extra_len);<font></font>
                p += cfh-&gt;extra_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (cfh-&gt;comment_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, cfh-&gt;comment, cfh-&gt;comment_len);<font></font>
                p += cfh-&gt;comment_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">size_t</span>)(p - dst);<font></font>
}<font></font>
</code></pre><br>
<a name="22"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encabezado de archivo local</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los datos de cada elemento de archivo est谩n precedidos por un encabezado de archivo local, que repite la mayor parte de la informaci贸n del encabezado central. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es probable que se haya introducido la duplicaci贸n de datos en los encabezados central y local para que PKZip no mantenga todo el directorio central en la memoria al desempaquetar. En cambio, a medida que se extrae cada archivo, su nombre y otra informaci贸n se pueden leer desde el encabezado local. Adem谩s, los encabezados locales son 煤tiles para recuperar archivos de archivos Zip en los que falta o est谩 da帽ado el directorio central. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, esta redundancia es tambi茅n la principal fuente de incertidumbre. Por ejemplo, 驴qu茅 sucede si los nombres de los archivos en los encabezados central y local no coinciden? Esto a menudo conduce a errores y problemas de seguridad.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No toda la informaci贸n del encabezado central est谩 duplicada. </font><font style="vertical-align: inherit;">Por ejemplo, campos con atributos de archivo. </font><font style="vertical-align: inherit;">Adem谩s, si se establece el tercer bit menos significativo </font></font><code>gp_flags</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(CRC-32), los campos comprimidos y no comprimidos se restablecer谩n a cero, y esta informaci贸n se puede encontrar en el bloque </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descriptor de datos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> despu茅s de los datos del archivo en s铆 (no lo consideraremos). </font><font style="vertical-align: inherit;">Esto le permite grabar un encabezado local antes de que se conozca el tama帽o del archivo del elemento o de qu茅 tama帽o se comprimir谩. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El encabezado local comienza con la firma 'P', 'K', 3, 4, y luego existe dicha estructura:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Local File Header. */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lfh</span> {</span>
        <span class="hljs-keyword">uint16_t</span> extract_ver;
        <span class="hljs-keyword">uint16_t</span> gp_flag;
        <span class="hljs-keyword">uint16_t</span> method;
        <span class="hljs-keyword">uint16_t</span> mod_time;
        <span class="hljs-keyword">uint16_t</span> mod_date;
        <span class="hljs-keyword">uint32_t</span> crc32;
        <span class="hljs-keyword">uint32_t</span> comp_size;
        <span class="hljs-keyword">uint32_t</span> uncomp_size;
        <span class="hljs-keyword">uint16_t</span> name_len;
        <span class="hljs-keyword">uint16_t</span> extra_len;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *name;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *extra;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas funciones leen y escriben encabezados locales, como otras estructuras de datos:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Size of a Local File Header, not including name and extra. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LFH_BASE_SZ 30</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LFH_SIGNATURE 0x04034b50 <span class="hljs-comment">/* "PK\3\4" little-endian. */</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">read_lfh</span><span class="hljs-params">(struct lfh *lfh, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len,
                     <span class="hljs-keyword">size_t</span> offset)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint32_t</span> signature;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (offset &gt; src_len || src_len - offset &lt; LFH_BASE_SZ) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        p = &amp;src[offset];<font></font>
        signature = READ32(p);<font></font>
        <span class="hljs-keyword">if</span> (signature != LFH_SIGNATURE) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        lfh-&gt;extract_ver = READ16(p);<font></font>
        lfh-&gt;gp_flag = READ16(p);<font></font>
        lfh-&gt;method = READ16(p);<font></font>
        lfh-&gt;mod_time = READ16(p);<font></font>
        lfh-&gt;mod_date = READ16(p);<font></font>
        lfh-&gt;crc32 = READ32(p);<font></font>
        lfh-&gt;comp_size = READ32(p);<font></font>
        lfh-&gt;uncomp_size = READ32(p);<font></font>
        lfh-&gt;name_len = READ16(p);<font></font>
        lfh-&gt;extra_len = READ16(p);<font></font>
        lfh-&gt;name = p;<font></font>
        lfh-&gt;extra = lfh-&gt;name + lfh-&gt;name_len;<font></font>
        assert(p == &amp;src[offset + LFH_BASE_SZ] &amp;&amp; <span class="hljs-string">"All fields read."</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (src_len - offset - LFH_BASE_SZ &lt; lfh-&gt;name_len + lfh-&gt;extra_len) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">write_lfh</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">const</span> struct lfh *lfh)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p = dst;<font></font>
<font></font>
        WRITE32(p, LFH_SIGNATURE);<font></font>
        WRITE16(p, lfh-&gt;extract_ver);<font></font>
        WRITE16(p, lfh-&gt;gp_flag);<font></font>
        WRITE16(p, lfh-&gt;method);<font></font>
        WRITE16(p, lfh-&gt;mod_time);<font></font>
        WRITE16(p, lfh-&gt;mod_date);<font></font>
        WRITE32(p, lfh-&gt;crc32);<font></font>
        WRITE32(p, lfh-&gt;comp_size);<font></font>
        WRITE32(p, lfh-&gt;uncomp_size);<font></font>
        WRITE16(p, lfh-&gt;name_len);<font></font>
        WRITE16(p, lfh-&gt;extra_len);<font></font>
        assert(p - dst == LFH_BASE_SZ);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (lfh-&gt;name_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, lfh-&gt;name, lfh-&gt;name_len);<font></font>
                p += lfh-&gt;name_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (lfh-&gt;extra_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, lfh-&gt;extra, lfh-&gt;extra_len);<font></font>
                p += lfh-&gt;extra_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">size_t</span>)(p - dst);<font></font>
}<font></font>
</code></pre><br>
<a name="23"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementaci贸n de Zip Read</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usando las funciones anteriores, implementamos la lectura del archivo Zip en la memoria y obtenemos un iterador para acceder a los elementos del archivo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">size_t</span> <span class="hljs-keyword">zipiter_t</span>; <span class="hljs-comment">/* Zip archive member iterator. */</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zip_t</span> <span class="hljs-title">zip_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zip_t</span> {</span>
        <span class="hljs-keyword">uint16_t</span> num_members;    <span class="hljs-comment">/* Number of members. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comment;  <span class="hljs-comment">/* Zip file comment (not terminated). */</span>
        <span class="hljs-keyword">uint16_t</span> comment_len;    <span class="hljs-comment">/* Zip file comment length. */</span>
        <span class="hljs-keyword">zipiter_t</span> members_begin; <span class="hljs-comment">/* Iterator to the first member. */</span>
        <span class="hljs-keyword">zipiter_t</span> members_end;   <span class="hljs-comment">/* Iterator to the end of members. */</span><font></font>
<font></font>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src;
        <span class="hljs-keyword">size_t</span> src_len;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Initialize zip based on the source data. Returns true on success, or false
   if the data could not be parsed as a valid Zip file. */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">zip_read</span><span class="hljs-params">(<span class="hljs-keyword">zip_t</span> *zip, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len)</span>
</span>{
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eocdr</span> <span class="hljs-title">eocdr</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfh</span> <span class="hljs-title">cfh</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lfh</span> <span class="hljs-title">lfh</span>;</span>
        <span class="hljs-keyword">size_t</span> i, offset;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comp_data;<font></font>
<font></font>
        zip-&gt;src = src;<font></font>
        zip-&gt;src_len = src_len;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!find_eocdr(&amp;eocdr, src, src_len)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (eocdr.disk_nbr != <span class="hljs-number">0</span> || eocdr.cd_start_disk != <span class="hljs-number">0</span> ||<font></font>
            eocdr.disk_cd_entries != eocdr.cd_entries) {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Cannot handle multi-volume archives. */</span><font></font>
        }<font></font>
<font></font>
        zip-&gt;num_members = eocdr.cd_entries;<font></font>
        zip-&gt;comment = eocdr.comment;<font></font>
        zip-&gt;comment_len = eocdr.comment_len;<font></font>
<font></font>
        offset = eocdr.cd_offset;<font></font>
        zip-&gt;members_begin = offset;<font></font>
<font></font>
        <span class="hljs-comment">/* Read the member info and do a few checks. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; eocdr.cd_entries; i++) {
                <span class="hljs-keyword">if</span> (!read_cfh(&amp;cfh, src, src_len, offset)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (cfh.gp_flag &amp; <span class="hljs-number">1</span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* The member is encrypted. */</span><font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (cfh.method != ZIP_STORED &amp;&amp; cfh.method != ZIP_DEFLATED) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Unsupported compression method. */</span><font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (cfh.method == ZIP_STORED &amp;&amp;<font></font>
                    cfh.uncomp_size != cfh.comp_size) {<font></font>
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (cfh.disk_nbr_start != <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Cannot handle multi-volume archives. */</span><font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memchr</span>(cfh.name, <span class="hljs-string">'\0'</span>, cfh.name_len) != <span class="hljs-literal">NULL</span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Bad filename. */</span><font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (!read_lfh(&amp;lfh, src, src_len, cfh.lfh_offset)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
<font></font>
                comp_data = lfh.extra + lfh.extra_len;<font></font>
                <span class="hljs-keyword">if</span> (cfh.comp_size &gt; src_len - (<span class="hljs-keyword">size_t</span>)(comp_data - src)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Member data does not fit in src. */</span><font></font>
                }<font></font>
<font></font>
                offset += CFH_BASE_SZ + cfh.name_len + cfh.extra_len +<font></font>
                          cfh.comment_len;<font></font>
        }<font></font>
<font></font>
        zip-&gt;members_end = offset;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como mencion茅 anteriormente, los iteradores de elementos son simplemente desplazamientos al encabezado del archivo central a trav茅s del cual puede acceder a los datos del elemento:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> { ZIP_STORED = <span class="hljs-number">0</span>, ZIP_DEFLATED = <span class="hljs-number">8</span> } <span class="hljs-keyword">method_t</span>;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zipmemb_t</span> <span class="hljs-title">zipmemb_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zipmemb_t</span> {</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *name;      <span class="hljs-comment">/* Member name (not null terminated). */</span>
        <span class="hljs-keyword">uint16_t</span> name_len;        <span class="hljs-comment">/* Member name length. */</span>
        <span class="hljs-keyword">time_t</span> mtime;             <span class="hljs-comment">/* Modification time. */</span>
        <span class="hljs-keyword">uint32_t</span> comp_size;       <span class="hljs-comment">/* Compressed size. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comp_data; <span class="hljs-comment">/* Compressed data. */</span>
        <span class="hljs-keyword">method_t</span> method;          <span class="hljs-comment">/* Compression method. */</span>
        <span class="hljs-keyword">uint32_t</span> uncomp_size;     <span class="hljs-comment">/* Uncompressed size. */</span>
        <span class="hljs-keyword">uint32_t</span> crc32;           <span class="hljs-comment">/* CRC-32 checksum. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comment;   <span class="hljs-comment">/* Comment (not null terminated). */</span>
        <span class="hljs-keyword">uint16_t</span> comment_len;     <span class="hljs-comment">/* Comment length. */</span>
        <span class="hljs-keyword">bool</span> is_dir;              <span class="hljs-comment">/* Whether this is a directory. */</span>
        <span class="hljs-keyword">zipiter_t</span> next;           <span class="hljs-comment">/* Iterator to the next member. */</span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Get the Zip archive member through iterator it. */</span>
<span class="hljs-function"><span class="hljs-keyword">zipmemb_t</span> <span class="hljs-title">zip_member</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">zip_t</span> *zip, <span class="hljs-keyword">zipiter_t</span> it)</span>
</span>{
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfh</span> <span class="hljs-title">cfh</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lfh</span> <span class="hljs-title">lfh</span>;</span>
        <span class="hljs-keyword">bool</span> ok;
        <span class="hljs-keyword">zipmemb_t</span> m;<font></font>
<font></font>
        assert(it &gt;= zip-&gt;members_begin &amp;&amp; it &lt; zip-&gt;members_end);<font></font>
<font></font>
        ok = read_cfh(&amp;cfh, zip-&gt;src, zip-&gt;src_len, it);<font></font>
        assert(ok);<font></font>
<font></font>
        ok = read_lfh(&amp;lfh, zip-&gt;src, zip-&gt;src_len, cfh.lfh_offset);<font></font>
        assert(ok);<font></font>
<font></font>
        m.name = cfh.name;<font></font>
        m.name_len = cfh.name_len;<font></font>
        m.mtime = dos2ctime(cfh.mod_date, cfh.mod_time);<font></font>
        m.comp_size = cfh.comp_size;<font></font>
        m.comp_data = lfh.extra + lfh.extra_len;<font></font>
        m.method = cfh.method;<font></font>
        m.uncomp_size = cfh.uncomp_size;<font></font>
        m.crc32 = cfh.crc32;<font></font>
        m.comment = cfh.comment;<font></font>
        m.comment_len = cfh.comment_len;<font></font>
        m.is_dir = (cfh.ext_attrs &amp; EXT_ATTR_DIR) != <span class="hljs-number">0</span>;<font></font>
<font></font>
        m.next = it + CFH_BASE_SZ +<font></font>
                 cfh.name_len + cfh.extra_len + cfh.comment_len;<font></font>
<font></font>
        assert(m.next &lt;= zip-&gt;members_end);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> m;<font></font>
}<font></font>
</code></pre><br>
<a name="24"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementaci贸n de registro postal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para escribir un archivo zip en el b煤fer de memoria, primero debe averiguar cu谩nta memoria asignarle. </font><font style="vertical-align: inherit;">Y dado que no sabemos cu谩ntos datos comprimiremos antes de intentar escribir, calculamos el l铆mite superior en funci贸n de los tama帽os de los elementos sin comprimir:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Compute an upper bound on the dst size required by zip_write() for an
 * archive with num_memb members with certain filenames, sizes, and archive
 * comment. Returns zero on error, e.g. if a filename is longer than 2^16-1, or
 * if the total file size is larger than 2^32-1. */</span>
<span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">zip_max_size</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> num_memb, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *filenames,
                      <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *file_sizes, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *comment)</span>
</span>{
        <span class="hljs-keyword">size_t</span> comment_len, name_len;
        <span class="hljs-keyword">uint64_t</span> total;
        <span class="hljs-keyword">uint16_t</span> i;<font></font>
<font></font>
        comment_len = (comment == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : <span class="hljs-built_in">strlen</span>(comment));
        <span class="hljs-keyword">if</span> (comment_len &gt; UINT16_MAX) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        total = EOCDR_BASE_SZ + comment_len; <span class="hljs-comment">/* EOCDR */</span><font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_memb; i++) {<font></font>
                assert(filenames[i] != <span class="hljs-literal">NULL</span>);<font></font>
                name_len = <span class="hljs-built_in">strlen</span>(filenames[i]);
                <span class="hljs-keyword">if</span> (name_len &gt; UINT16_MAX) {
                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
                }<font></font>
<font></font>
                total += CFH_BASE_SZ + name_len; <span class="hljs-comment">/* Central File Header */</span>
                total += LFH_BASE_SZ + name_len; <span class="hljs-comment">/* Local File Header */</span>
                total += file_sizes[i];          <span class="hljs-comment">/* Uncompressed data size. */</span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (total &gt; UINT32_MAX) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">uint32_t</span>)total;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este c贸digo escribe el archivo zip usando la compresi贸n desinflada de cada elemento, reduciendo su tama帽o:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Write a Zip file containing num_memb members into dst, which must be large
   enough to hold the resulting data. Returns the number of bytes written, which
   is guaranteed to be less than or equal to the result of zip_max_size() when
   called with the corresponding arguments. comment shall be a null-terminated
   string or null. callback shall be null or point to a function which will
   get called after the compression of each member. */</span>
<span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">zip_write</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">uint16_t</span> num_memb,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *filenames,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-keyword">const</span> *file_data,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *file_sizes,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">time_t</span> *mtimes,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *comment,
                   <span class="hljs-keyword">void</span> (*callback)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">uint32_t</span> size,
                                    <span class="hljs-keyword">uint32_t</span> comp_size))</span>
</span>{
        <span class="hljs-keyword">uint16_t</span> i;
        <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eocdr</span> <span class="hljs-title">eocdr</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfh</span> <span class="hljs-title">cfh</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lfh</span> <span class="hljs-title">lfh</span>;</span>
        <span class="hljs-keyword">bool</span> ok;
        <span class="hljs-keyword">uint16_t</span> name_len;
        <span class="hljs-keyword">uint8_t</span> *data_dst;
        <span class="hljs-keyword">size_t</span> comp_sz;
        <span class="hljs-keyword">uint32_t</span> lfh_offset, cd_offset, eocdr_offset;<font></font>
<font></font>
        p = dst;<font></font>
<font></font>
        <span class="hljs-comment">/* Write Local File Headers and deflated or stored data. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_memb; i++) {<font></font>
                assert(filenames[i] != <span class="hljs-literal">NULL</span>);<font></font>
                assert(<span class="hljs-built_in">strlen</span>(filenames[i]) &lt;= UINT16_MAX);<font></font>
                name_len = (<span class="hljs-keyword">uint16_t</span>)<span class="hljs-built_in">strlen</span>(filenames[i]);<font></font>
<font></font>
                data_dst = p + LFH_BASE_SZ + name_len;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (hwdeflate(file_data[i], file_sizes[i], data_dst,<font></font>
                              file_sizes[i], &amp;comp_sz) &amp;&amp;<font></font>
                                comp_sz &lt; file_sizes[i]) {<font></font>
                        lfh.method = ZIP_DEFLATED;<font></font>
                        assert(comp_sz &lt;= UINT32_MAX);<font></font>
                        lfh.comp_size = (<span class="hljs-keyword">uint32_t</span>)comp_sz;<font></font>
                } <span class="hljs-keyword">else</span> {
                        <span class="hljs-built_in">memcpy</span>(data_dst, file_data[i], file_sizes[i]);<font></font>
                        lfh.method = ZIP_STORED;<font></font>
                        lfh.comp_size = file_sizes[i];<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (callback != <span class="hljs-literal">NULL</span>) {<font></font>
                        callback(filenames[i], file_sizes[i], lfh.comp_size);<font></font>
                }<font></font>
<font></font>
                lfh.extract_ver = (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">8</span>) | <span class="hljs-number">20</span>; <span class="hljs-comment">/* DOS | PKZIP 2.0 */</span>
                lfh.gp_flag = (lfh.method == ZIP_DEFLATED ? (<span class="hljs-number">0x1</span> &lt;&lt; <span class="hljs-number">1</span>) : <span class="hljs-number">0x0</span>);<font></font>
                ctime2dos(mtimes[i], &amp;lfh.mod_date, &amp;lfh.mod_time);<font></font>
                lfh.crc32 = crc32(file_data[i], file_sizes[i]);<font></font>
                lfh.uncomp_size = file_sizes[i];<font></font>
                lfh.name_len = name_len;<font></font>
                lfh.extra_len = <span class="hljs-number">0</span>;<font></font>
                lfh.name = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>*)filenames[i];<font></font>
                p += write_lfh(p, &amp;lfh);<font></font>
                p += lfh.comp_size;<font></font>
        }<font></font>
<font></font>
        assert(p - dst &lt;= UINT32_MAX);<font></font>
        cd_offset = (<span class="hljs-keyword">uint32_t</span>)(p - dst);<font></font>
<font></font>
        <span class="hljs-comment">/* Write the Central Directory based on the Local File Headers. */</span>
        lfh_offset = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_memb; i++) {<font></font>
                ok = read_lfh(&amp;lfh, dst, SIZE_MAX, lfh_offset);<font></font>
                assert(ok);<font></font>
<font></font>
                cfh.made_by_ver = lfh.extract_ver;<font></font>
                cfh.extract_ver = lfh.extract_ver;<font></font>
                cfh.gp_flag = lfh.gp_flag;<font></font>
                cfh.method = lfh.method;<font></font>
                cfh.mod_time = lfh.mod_time;<font></font>
                cfh.mod_date = lfh.mod_date;<font></font>
                cfh.crc32 = lfh.crc32;<font></font>
                cfh.comp_size = lfh.comp_size;<font></font>
                cfh.uncomp_size = lfh.uncomp_size;<font></font>
                cfh.name_len = lfh.name_len;<font></font>
                cfh.extra_len = <span class="hljs-number">0</span>;<font></font>
                cfh.comment_len = <span class="hljs-number">0</span>;<font></font>
                cfh.disk_nbr_start = <span class="hljs-number">0</span>;<font></font>
                cfh.int_attrs = <span class="hljs-number">0</span>;<font></font>
                cfh.ext_attrs = EXT_ATTR_ARC;<font></font>
                cfh.lfh_offset = lfh_offset;<font></font>
                cfh.name = lfh.name;<font></font>
                p += write_cfh(p, &amp;cfh);<font></font>
<font></font>
                lfh_offset += LFH_BASE_SZ + lfh.name_len + lfh.comp_size;<font></font>
        }<font></font>
<font></font>
        assert(p - dst &lt;= UINT32_MAX);<font></font>
        eocdr_offset = (<span class="hljs-keyword">uint32_t</span>)(p - dst);<font></font>
<font></font>
        <span class="hljs-comment">/* Write the End of Central Directory Record. */</span>
        eocdr.disk_nbr = <span class="hljs-number">0</span>;<font></font>
        eocdr.cd_start_disk = <span class="hljs-number">0</span>;<font></font>
        eocdr.disk_cd_entries = num_memb;<font></font>
        eocdr.cd_entries = num_memb;<font></font>
        eocdr.cd_size = eocdr_offset - cd_offset;<font></font>
        eocdr.cd_offset = cd_offset;<font></font>
        eocdr.comment_len = (<span class="hljs-keyword">uint16_t</span>)(comment == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : <span class="hljs-built_in">strlen</span>(comment));<font></font>
        eocdr.comment = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>*)comment;<font></font>
        p += write_eocdr(p, &amp;eocdr);<font></font>
<font></font>
        assert(p - dst &lt;= zip_max_size(num_memb, filenames, file_sizes,<font></font>
                                       comment));<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">uint32_t</span>)(p - dst);<font></font>
}<font></font>
</code></pre><br>
<a name="25"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hwzip</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora sabemos c贸mo leer y escribir archivos Zip, c贸mo comprimir y descomprimir los datos almacenados en ellos. </font><font style="vertical-align: inherit;">Ahora escribamos un programa Zip simple que contenga todas estas herramientas. </font><font style="vertical-align: inherit;">El c贸digo est谩 disponible en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hwzip.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usaremos una macro para el manejo simple de errores y varias funciones auxiliares para la asignaci贸n de memoria comprobada:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PERROR_IF(cond, msg) <span class="hljs-meta-keyword">if</span> (cond) { perror(msg); exit(1); }</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">xmalloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span>
</span>{
        <span class="hljs-keyword">void</span> *ptr = <span class="hljs-built_in">malloc</span>(size);<font></font>
        PERROR_IF(ptr == <span class="hljs-literal">NULL</span>, <span class="hljs-string">"malloc"</span>);
        <span class="hljs-keyword">return</span> ptr;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">xrealloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">size_t</span> size)</span>
</span>{<font></font>
        ptr = <span class="hljs-built_in">realloc</span>(ptr, size);<font></font>
        PERROR_IF(ptr == <span class="hljs-literal">NULL</span>, <span class="hljs-string">"realloc"</span>);
        <span class="hljs-keyword">return</span> ptr;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las otras dos funciones se usan para leer y escribir archivos:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-title">read_file</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">size_t</span> *file_sz)</span>
</span>{<font></font>
        FILE *f;<font></font>
        <span class="hljs-keyword">uint8_t</span> *buf;
        <span class="hljs-keyword">size_t</span> buf_cap;<font></font>
<font></font>
        f = fopen(filename, <span class="hljs-string">"rb"</span>);<font></font>
        PERROR_IF(f == <span class="hljs-literal">NULL</span>, <span class="hljs-string">"fopen"</span>);<font></font>
<font></font>
        buf_cap = <span class="hljs-number">4096</span>;<font></font>
        buf = xmalloc(buf_cap);<font></font>
<font></font>
        *file_sz = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (feof(f) == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (buf_cap - *file_sz == <span class="hljs-number">0</span>) {<font></font>
                        buf_cap *= <span class="hljs-number">2</span>;<font></font>
                        buf = xrealloc(buf, buf_cap);<font></font>
                }<font></font>
<font></font>
                *file_sz += fread(&amp;buf[*file_sz], <span class="hljs-number">1</span>, buf_cap - *file_sz, f);<font></font>
                PERROR_IF(ferror(f), <span class="hljs-string">"fread"</span>);<font></font>
        }<font></font>
<font></font>
        PERROR_IF(fclose(f) != <span class="hljs-number">0</span>, <span class="hljs-string">"fclose"</span>);
        <span class="hljs-keyword">return</span> buf;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write_file</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *data, <span class="hljs-keyword">size_t</span> n)</span>
</span>{<font></font>
        FILE *f;<font></font>
<font></font>
        f = fopen(filename, <span class="hljs-string">"wb"</span>);<font></font>
        PERROR_IF(f == <span class="hljs-literal">NULL</span>, <span class="hljs-string">"fopen"</span>);<font></font>
        PERROR_IF(fwrite(data, <span class="hljs-number">1</span>, n, f) != n, <span class="hljs-string">"fwrite"</span>);<font></font>
        PERROR_IF(fclose(f) != <span class="hljs-number">0</span>, <span class="hljs-string">"fclose"</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestro programa Zip puede realizar tres funciones: hacer una lista del contenido de los archivos Zip y extraerlo, as铆 como crear archivos Zip. </font><font style="vertical-align: inherit;">Listado no es m谩s simple en ninguna parte:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">list_zip</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *zip_data;
        <span class="hljs-keyword">size_t</span> zip_sz;
        <span class="hljs-keyword">zip_t</span> z;
        <span class="hljs-keyword">zipiter_t</span> it;
        <span class="hljs-keyword">zipmemb_t</span> m;<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Listing ZIP archive: %s\n\n"</span>, filename);<font></font>
<font></font>
        zip_data = read_file(filename, &amp;zip_sz);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!zip_read(&amp;z, zip_data, zip_sz)) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Failed to parse ZIP file!\n"</span>);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (z.comment_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.*s\n\n"</span>, (<span class="hljs-keyword">int</span>)z.comment_len, z.comment);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (it = z.members_begin; it != z.members_end; it = m.next) {<font></font>
                m = zip_member(&amp;z, it);<font></font>
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.*s\n"</span>, (<span class="hljs-keyword">int</span>)m.name_len, m.name);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
<font></font>
        <span class="hljs-built_in">free</span>(zip_data);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La extracci贸n es un poco m谩s complicada. </font><font style="vertical-align: inherit;">Utilizaremos funciones auxiliares para la terminaci贸n nula del nombre del archivo (para pasarlo </font></font><code>fopen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) y desempaquetar:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> *<span class="hljs-title">terminate_str</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">char</span> *p = xmalloc(n + <span class="hljs-number">1</span>);
        <span class="hljs-built_in">memcpy</span>(p, str, n);<font></font>
        p[n] = <span class="hljs-string">'\0'</span>;
        <span class="hljs-keyword">return</span> p;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-title">inflate_member</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">zipmemb_t</span> *m)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">size_t</span> src_used, dst_used;<font></font>
<font></font>
        assert(m-&gt;method == ZIP_DEFLATED);<font></font>
<font></font>
        p = xmalloc(m-&gt;uncomp_size);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (hwinflate(m-&gt;comp_data, m-&gt;comp_size, &amp;src_used, p, m-&gt;uncomp_size,<font></font>
                      &amp;dst_used) != HWINF_OK) {<font></font>
                <span class="hljs-built_in">free</span>(p);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (src_used != m-&gt;comp_size || dst_used != m-&gt;uncomp_size) {
                <span class="hljs-built_in">free</span>(p);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> p;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestro programa omitir谩 cualquier elemento de archivo que tenga directorios. </font><font style="vertical-align: inherit;">Esto se hace para evitar los llamados </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ataques transversales de ruta</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : se utiliza un archivo malicioso para escribir un archivo desde fuera del directorio especificado por el usuario. </font><font style="vertical-align: inherit;">Lea los detalles en las </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">preguntas frecuentes de Info-ZIP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">extract_zip</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *zip_data;
        <span class="hljs-keyword">size_t</span> zip_sz;
        <span class="hljs-keyword">zip_t</span> z;
        <span class="hljs-keyword">zipiter_t</span> it;
        <span class="hljs-keyword">zipmemb_t</span> m;
        <span class="hljs-keyword">char</span> *tname;
        <span class="hljs-keyword">uint8_t</span> *inflated;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *uncomp_data;<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Extracting ZIP archive: %s\n\n"</span>, filename);<font></font>
<font></font>
        zip_data = read_file(filename, &amp;zip_sz);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!zip_read(&amp;z, zip_data, zip_sz)) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Failed to read ZIP file!\n"</span>);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (z.comment_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.*s\n\n"</span>, (<span class="hljs-keyword">int</span>)z.comment_len, z.comment);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (it = z.members_begin; it != z.members_end; it = m.next) {<font></font>
                m = zip_member(&amp;z, it);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (m.is_dir) {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" (Skipping dir: %.*s)\n"</span>,<font></font>
                               (<span class="hljs-keyword">int</span>)m.name_len, m.name);
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memchr</span>(m.name, <span class="hljs-string">'/'</span>,  m.name_len) != <span class="hljs-literal">NULL</span> ||
                    <span class="hljs-built_in">memchr</span>(m.name, <span class="hljs-string">'\\'</span>, m.name_len) != <span class="hljs-literal">NULL</span>) {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" (Skipping file in dir: %.*s)\n"</span>,<font></font>
                               (<span class="hljs-keyword">int</span>)m.name_len, m.name);
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                assert(m.method == ZIP_STORED || m.method == ZIP_DEFLATED);<font></font>
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %s: %.*s"</span>,<font></font>
                       m.method == ZIP_STORED ? <span class="hljs-string">"Extracting"</span> : <span class="hljs-string">" Inflating"</span>,<font></font>
                       (<span class="hljs-keyword">int</span>)m.name_len, m.name);<font></font>
                fflush(<span class="hljs-built_in">stdout</span>);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (m.method == ZIP_STORED) {<font></font>
                        assert(m.uncomp_size == m.comp_size);<font></font>
                        inflated = <span class="hljs-literal">NULL</span>;<font></font>
                        uncomp_data = m.comp_data;<font></font>
                } <span class="hljs-keyword">else</span> {<font></font>
                        inflated = inflate_member(&amp;m);<font></font>
                        <span class="hljs-keyword">if</span> (inflated == <span class="hljs-literal">NULL</span>) {
                                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error: inflation failed!\n"</span>);
                                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
                        }<font></font>
                        uncomp_data = inflated;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (crc32(uncomp_data, m.uncomp_size) != m.crc32) {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error: CRC-32 mismatch!\n"</span>);
                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
                }<font></font>
<font></font>
                tname = terminate_str((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)m.name, m.name_len);<font></font>
                write_file(tname, uncomp_data, m.uncomp_size);<font></font>
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
<font></font>
                <span class="hljs-built_in">free</span>(inflated);
                <span class="hljs-built_in">free</span>(tname);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        <span class="hljs-built_in">free</span>(zip_data);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para crear un archivo zip, leeremos los archivos de entrada y los alimentaremos </font></font><code>zip_write</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dado que la biblioteca est谩ndar de C no le permite obtener la hora de modificaci贸n del archivo, usaremos la hora actual (lo dejo como tarea para corregir esta funci贸n).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">zip_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">uint32_t</span> size, <span class="hljs-keyword">uint32_t</span> comp_size)</span>
</span>{
        <span class="hljs-keyword">bool</span> deflated = comp_size &lt; size;<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %s: %s"</span>, deflated ? <span class="hljs-string">"Deflated"</span> : <span class="hljs-string">"  Stored"</span>, filename);
        <span class="hljs-keyword">if</span> (deflated) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" (%u%%)"</span>, <span class="hljs-number">100</span> - <span class="hljs-number">100</span> * comp_size / size);<font></font>
        }<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create_zip</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *zip_filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *comment,
                       <span class="hljs-keyword">uint16_t</span> n, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *filenames)</span>
</span>{
        <span class="hljs-keyword">time_t</span> mtime;
        <span class="hljs-keyword">time_t</span> *mtimes;
        <span class="hljs-keyword">uint8_t</span> **file_data;
        <span class="hljs-keyword">uint32_t</span> *file_sizes;
        <span class="hljs-keyword">size_t</span> file_size, zip_size;
        <span class="hljs-keyword">uint8_t</span> *zip_data;
        <span class="hljs-keyword">uint16_t</span> i;<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Creating ZIP archive: %s\n\n"</span>, zip_filename);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (comment != <span class="hljs-literal">NULL</span>) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n\n"</span>, comment);<font></font>
        }<font></font>
<font></font>
        mtime = time(<span class="hljs-literal">NULL</span>);<font></font>
<font></font>
        file_data = xmalloc(<span class="hljs-keyword">sizeof</span>(*file_data) * n);<font></font>
        file_sizes = xmalloc(<span class="hljs-keyword">sizeof</span>(*file_sizes) * n);<font></font>
        mtimes = xmalloc(<span class="hljs-keyword">sizeof</span>(*mtimes) * n);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                file_data[i] = read_file(filenames[i], &amp;file_size);<font></font>
                <span class="hljs-keyword">if</span> (file_size &gt;= UINT32_MAX) {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s is too large!\n"</span>, filenames[i]);
                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
                }<font></font>
                file_sizes[i] = (<span class="hljs-keyword">uint32_t</span>)file_size;<font></font>
                mtimes[i] = mtime;<font></font>
        }<font></font>
<font></font>
        zip_size = zip_max_size(n, filenames, file_sizes, comment);<font></font>
        <span class="hljs-keyword">if</span> (zip_size == <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"zip writing not possible"</span>);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        zip_data = xmalloc(zip_size);<font></font>
        zip_size = zip_write(zip_data, n, filenames,<font></font>
                             (<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-keyword">const</span> *)file_data,<font></font>
                             file_sizes, mtimes, comment, zip_callback);<font></font>
<font></font>
        write_file(zip_filename, zip_data, zip_size);<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
<font></font>
        <span class="hljs-built_in">free</span>(zip_data);
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {
                <span class="hljs-built_in">free</span>(file_data[i]);<font></font>
        }<font></font>
        <span class="hljs-built_in">free</span>(mtimes);
        <span class="hljs-built_in">free</span>(file_sizes);
        <span class="hljs-built_in">free</span>(file_data);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verifica los argumentos de la l铆nea de comando y decide qu茅 hacer:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print_usage</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *argv0)</span>
</span>{
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Usage:\n\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"  %s list &lt;zipfile&gt;\n"</span>, argv0);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"  %s extract &lt;zipfile&gt;\n"</span>, argv0);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"  %s create &lt;zipfile&gt; [-c &lt;comment&gt;] &lt;files...&gt;\n"</span>, argv0);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"HWZIP "</span> VERSION <span class="hljs-string">" -- A very simple ZIP program "</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"from https://www.hanshq.net/zip.html\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"list"</span>) == <span class="hljs-number">0</span>) {<font></font>
                list_zip(argv[<span class="hljs-number">2</span>]);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"extract"</span>) == <span class="hljs-number">0</span>) {<font></font>
                extract_zip(argv[<span class="hljs-number">2</span>]);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argc &gt;= <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"create"</span>) == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (argc &gt;= <span class="hljs-number">5</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">3</span>], <span class="hljs-string">"-c"</span>) == <span class="hljs-number">0</span>) {<font></font>
                        create_zip(argv[<span class="hljs-number">2</span>], argv[<span class="hljs-number">4</span>], (<span class="hljs-keyword">uint16_t</span>)(argc - <span class="hljs-number">5</span>),<font></font>
                                   (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *)&amp;argv[<span class="hljs-number">5</span>]);<font></font>
                } <span class="hljs-keyword">else</span> {<font></font>
                        create_zip(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, (<span class="hljs-keyword">uint16_t</span>)(argc - <span class="hljs-number">3</span>),<font></font>
                                   (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *)&amp;argv[<span class="hljs-number">3</span>]);<font></font>
                }<font></font>
        } <span class="hljs-keyword">else</span> {<font></font>
                print_usage(argv[<span class="hljs-number">0</span>]);
                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br>
<a name="26"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instrucciones de montaje</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un conjunto completo de archivos fuente est谩 disponible en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hwzip-1.0.zip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">C贸mo compilar HWZip en Linux o Mac:</font></font><br>
<br>
<pre><code class="cpp hljs">$ clang generate_tables.c &amp;&amp; ./a.out &gt; tables.c<font></font>
$ clang -O3 -DNDEBUG -march=native -o hwzip crc32.c deflate.c huffman.c \<font></font>
        hwzip.c lz77.c tables.c zip.c<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Windows, en el s铆mbolo del sistema del desarrollador en Visual Studio (si no tiene Visual Studio, descargue las </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">herramientas de compilaci贸n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="cpp hljs">cl /TC generate_tables.c &amp;&amp; generate_tables &gt; tables.c<font></font>
cl /O2 /DNDEBUG /MT /Fehwzip.exe /TC crc32.c deflate.c huffman.c hwzip.c<font></font>
        lz77.c tables.c zip.c /link setargv.obj<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setargv.obj para </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expandir argumentos de l铆nea de comando comod铆n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .)</font></font><br>
<br>
<a name="27"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusi贸n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sorprendente c贸mo la tecnolog铆a se est谩 desarrollando r谩pida y lentamente. </font><font style="vertical-align: inherit;">El formato Zip fue creado hace 30 a帽os basado en tecnolog铆a de los a帽os cincuenta y setenta. </font><font style="vertical-align: inherit;">Y aunque mucho ha cambiado desde entonces, los archivos Zip, de hecho, se han mantenido igual y hoy son m谩s comunes que nunca. </font><font style="vertical-align: inherit;">Creo que ser谩 煤til tener una buena comprensi贸n de c贸mo funcionan.</font></font><br>
<br>
<a name="28"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejercicios</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haga que HWZip registre el tiempo que tard贸 en cambiar cada archivo, en lugar de la hora actual en que se cre贸 el archivo. </font><font style="vertical-align: inherit;">Use </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stat (2)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en Linux o Mac y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetFileTime</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en Windows. </font><font style="vertical-align: inherit;">O agregue un indicador de l铆nea de comando que permita al usuario establecer una hora espec铆fica para los cambios de archivo.</font></font></li>
<li>              gzip-.       ,    Deflate (   ).    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RFC 1952</a>.</li>
<li>    Zip-     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   </a>.  HWZip ,   <code>read_file</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mmap(2)</a>  Linux  Mac  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CreateFileMapping</a>  Windows.</li>
<li> HWZip ,          Zip64.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> appnote.txt</a>.</li>
</ul><br>
<a name="29"></a><h2> </h2><br>
<ul>
<li>  BBS-   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BBS: The Documentary</a>.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> YouTube</a>.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Part 8: Compression</a>    SEA  PKWare.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a>.</li>
<li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">A better Zip bomb</a>    Zip-,    芦禄    .</li>
<li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Zip Files All The Way Down</a> ,   <i>Zip-</i>  ,    .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ascii-zip</a>   ,  Deflate-   ASCII-.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rosetta Flash</a>.</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ten Thousand Security Pitfalls: the Zip File Format</a>         .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reading bits in far too many ways part 1</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">part 2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">part 3</a>        .</li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Understanding Compression</a>      .</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es490780/index.html">Intel Xeon escalable Gen2: gran venta de n煤cleos</a></li>
<li><a href="../es490782/index.html">Conferencia AnalogBytes: Roskomnadzor, media, highload y all-all-all</a></li>
<li><a href="../es490784/index.html">Soy desarrollador de Android y no me gustaba hacer trabajo manual.</a></li>
<li><a href="../es490786/index.html">An谩lisis de fugas de segundo orden: cuando se filtra de quienes roban datos de un banco</a></li>
<li><a href="../es490788/index.html">REPL in煤til. Informe Yandex</a></li>
<li><a href="../es490792/index.html">VXLAN en NSX-V - Base subyacente con problemas</a></li>
<li><a href="../es490796/index.html">C贸mo automatizar la seguridad de los contenedores al estilo de Pol铆tica como C贸digo usando CRD</a></li>
<li><a href="../es490804/index.html">C贸mo la madre de un hacker entr贸 en prisi贸n e infect贸 la computadora del jefe</a></li>
<li><a href="../es490808/index.html">Matem谩ticas en astron谩utica: motor de detonaci贸n rotacional</a></li>
<li><a href="../es490812/index.html">Spring Professional Certification 5 Experiencia de env铆o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>