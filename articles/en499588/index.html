<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÅ üë©üèæ‚Äçüéì ‚òùÔ∏è Authentication in .NET Core gRpc with JWT üë®üèΩ‚Äçü§ù‚Äçüë®üèª üë®‚Äçüë©‚Äçüëß üò∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will talk about the features of API authentication in gRpc services using JWT. I assume that you are familiar with JWT and HTTP head...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Authentication in .NET Core gRpc with JWT</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499588/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this article I will talk about the features of API authentication in gRpc services using JWT. </font><font style="vertical-align: inherit;">I assume that you are familiar with JWT and HTTP headers using them in .NET Core WebAPI, so I won‚Äôt discuss these details. </font><font style="vertical-align: inherit;">When I tried to implement authentication in gRpc, I came across the fact that most of the examples are written using console applications. </font><font style="vertical-align: inherit;">This is too far from the reality in which, in my opinion, developers live. </font><font style="vertical-align: inherit;">For example, I do not want to create a channel every time I want to call a service method. </font><font style="vertical-align: inherit;">I also do not want to worry about sending a token and user information with each request. </font><font style="vertical-align: inherit;">Instead, I want to have an infrastructure level that will take care of all this for me. </font><font style="vertical-align: inherit;">If this topic is interesting to you, then there will be more under the cut. </font><font style="vertical-align: inherit;">All examples in this article are valid for .NET Core 3.1.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Used example</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before delving into the topic, it is worth describing the example that is used in the article. The whole solution consists of two applications: a website and gRpc service (hereinafter API). Both are written in .NET Core 3.1. The user can log in and see some data if he is authorized for this. The website does not store user data and relies on an API in the authentication process. To communicate with the gRpc service, the website needs to have a valid JWT token, but this token does not relate to user authentication in the application. The web application uses cookies on its side. In order for the API to know which user makes the request to the service, information about this is sent along with the JWT token, but not in the token itself, but with an additional HTTP header. The figure below shows an example schema of the system that I just talked about:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/1-/a_/vn/1-a_vno-j3cfyv8ps49vdd_jv6m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here I should note that when I did this example, I did not have the goal of implementing the most correct authentication method for the API. </font><font style="vertical-align: inherit;">If you want to see some best practices, then look at </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the OpenID Connect specification</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Although, sometimes it seems to me that the most correct solution can be redundant in comparison with what can solve the problem and save time and money.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enable JWT Authentication in gRpc Service</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The configuration of the gRpc service is no different from the usual configuration that the .NET Core API requires. </font><font style="vertical-align: inherit;">An additional plus is that it is no different for HTTP and HTTPS protocols. </font><font style="vertical-align: inherit;">Briefly, you need to add standard authentication and authorization services, as well as middlewere in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startup.cs</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The place where you add middleware is important: you need to add it exactly between routing and points ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">some code is missing</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Configure</span>(<span class="hljs-params">...</span>)</span> {<font></font>
    app.UseRouting();<font></font>
    <font></font>
    app.UseAuthentication();<font></font>
    app.UseAuthorization();<font></font>
    <font></font>
    app.UseEndpoints(...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But the place where the services are registered is not so important, just add the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureServices ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method to the method </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">But here you need to configure the JWT token check. </font><font style="vertical-align: inherit;">It can be defined right here, but I recommend pulling it into a separate class. </font><font style="vertical-align: inherit;">Thus, the code may look like this:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConfigureServices</span>(<span class="hljs-params">...</span>)</span> {<font></font>
    services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)<font></font>
        .AddJwtBearer(o =&gt; {<font></font>
            <span class="hljs-keyword">var</span> validator = <span class="hljs-keyword">new</span> JwtTokenValidator(...);<font></font>
            o.SecurityTokenValidators.Add(validator);<font></font>
        });<font></font>
    services.AddAuthorization();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JwtTokenValidator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">is the one where you will define the validation logic. </font><font style="vertical-align: inherit;">You need to create the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TokenValidationParameters</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">with the correct settings and it will do the rest of the JWT validation work. </font><font style="vertical-align: inherit;">As a bonus, you can add an extra layer of security here. </font><font style="vertical-align: inherit;">It may be needed because JWT is a well-known format. </font><font style="vertical-align: inherit;">If you have JWT, you can go to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jwt.io</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and see some information. </font><font style="vertical-align: inherit;">I prefer to add extra encryption to the JWT, which makes decryption more difficult. </font><font style="vertical-align: inherit;">Here's what a validator might look like:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">JwtTokenValidator</span> : <span class="hljs-title">ISecurityTokenValidator</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">CanReadToken</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> securityToken</span>)</span> =&gt; <span class="hljs-literal">true</span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ClaimsPrincipal <span class="hljs-title">ValidateToken</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> securityToken, TokenValidationParameters validationParameters, <span class="hljs-keyword">out</span> SecurityToken validatedToken</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">new</span> JwtSecurityTokenHandler();
        <span class="hljs-keyword">var</span> tokenValidationParameters = <span class="hljs-keyword">new</span> TokenValidationParameters<font></font>
        {<font></font>
            ValidateIssuer = <span class="hljs-literal">true</span>,<font></font>
            ValidateAudience = <span class="hljs-literal">true</span>,<font></font>
            ValidateLifetime = <span class="hljs-literal">true</span>,<font></font>
            ValidateIssuerSigningKey = <span class="hljs-literal">true</span>,<font></font>
            ValidIssuer = <span class="hljs-string">"your string"</span>,<font></font>
            ValidAudience = <span class="hljs-string">"your string"</span>,<font></font>
            IssuerSigningKey = <span class="hljs-keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(<span class="hljs-string">"your secrete code"</span>))<font></font>
        };<font></font>
        <font></font>
        <span class="hljs-keyword">var</span> claimsPrincipal = handler.ValidateToken(token, tokenValidationParameters, <span class="hljs-keyword">out</span> validatedToken);
        <span class="hljs-keyword">return</span> claimsPrincipal;<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> CanValidateToken { <span class="hljs-keyword">get</span>; } = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> MaximumTokenSizeInBytes { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-keyword">int</span>.MaxValue;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And that‚Äôs all the API side needs. </font><font style="vertical-align: inherit;">The client setup history is slightly longer and slightly different depending on the selected HTTP or HTTPS protocol.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sending HTTP headers with every request to gRpc service</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You may know this one from the official documentation, which in fact you cannot use anywhere except in a dumb console program. For example, you can see </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> channel = GrpcChannel.ForAddress(<span class="hljs-string">"https://localhost:5001"</span>);
<span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> Greeter.GreeterClient(channel);
<span class="hljs-keyword">var</span> response = <span class="hljs-keyword">await</span> client.SayHelloAsync(
    <span class="hljs-keyword">new</span> HelloRequest { Name = <span class="hljs-string">"World"</span> });<font></font>
Console.WriteLine(response.Message);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To use this in a real project, we still need to have a centralized configuration and DI, which are almost not considered. Here is what you need to do. First, we need to add the necessary NuGet packages to our project. </font><font style="vertical-align: inherit;">
The </font><i><font style="vertical-align: inherit;">Grpc.Tools</font></i><font style="vertical-align: inherit;"> package </font><font style="vertical-align: inherit;">will help you create prototypes when building a project, and </font><i><font style="vertical-align: inherit;">Grpc.Net.ClientFactory</font></i><font style="vertical-align: inherit;"> will help you set up DI. </font><font style="vertical-align: inherit;">
When working with gRpc, if you need to implement your processing somewhere in the middle of the request-response chain, you need to use classes inherited from </font><i><font style="vertical-align: inherit;">Interceptor</font></i><font style="vertical-align: inherit;"> , which is part of </font><i><font style="vertical-align: inherit;">gRpc.Core</font></i><font style="vertical-align: inherit;"> . If you need to access </font><i><font style="vertical-align: inherit;">HttpContext.User.Identity</font></i><font style="vertical-align: inherit;"> inside your services, you can add the </font><i><font style="vertical-align: inherit;">IHttpContextAccessor</font></i><font style="vertical-align: inherit;"> interface</font></font><br>
<br>
<code>dotnet add package Grpc.Net.Client<br>
dotnet add package Google.Protobuf<br>
dotnet add package Grpc.Tools<br>
dotnet add package Grpc.Net.ClientFactory<br>
</code><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to your service (this requires additional registration in the services). </font><font style="vertical-align: inherit;">You need to add the following to your Startup.cs file.</font></font><br>
<br>
<pre><code class="cs hljs">services.AddTransient&lt;AuthHeadersInterceptor&gt;();<font></font>
services.AddHttpContextAccessor();<font></font>
<font></font>
<span class="hljs-keyword">var</span> httpClientBuilder = services.AddGrpcClient&lt;MygRpcService.MygRpcServiceClient&gt;(o =&gt; { o.Address = <span class="hljs-keyword">new</span> Uri(<span class="hljs-string">"grpc-endpoint-url"</span>); });<font></font>
httpClientBuilder.AddInterceptor&lt;AuthHeadersInterceptor&gt;();              <font></font>
httpClientBuilder.ConfigureChannel(o =&gt; o.Credentials = ChannelCredentials.Insecure);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AuthHeadersInterceptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">is our own class, derived from the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interceptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It uses IHttpContextAccessor and registering </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.AddHttpContextAccessor ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> allows you to do this.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuration Features for HTTP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You may notice the following configuration:</font></font><br>
<br>
<pre><code class="cs hljs">httpClientBuilder.ConfigureChannel(o =&gt; o.Credentials = ChannelCredentials.Insecure);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is necessary for working through HTTP, but this is not enough. </font><font style="vertical-align: inherit;">You also need to exclude this line from the Configure () method.</font></font><br>
<br>
<pre><code class="cs hljs">app.UseHttpsRedirection();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And still you need to </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dance to</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> establish a special setting before creating any gRpc channel. </font><font style="vertical-align: inherit;">This can be done only once during application launch. </font><font style="vertical-align: inherit;">Therefore, I added it at almost the same position as the deleted line mentioned above. </font><font style="vertical-align: inherit;">This should only be called for HTTP.</font></font><br>
<br>
<pre><code class="cs hljs">AppContext.SetSwitch(<span class="hljs-string">"System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport"</span>, <span class="hljs-literal">true</span>);
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuration Features for HTTPS</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are some difficulties with working with SSL on Windows and Linux. </font><font style="vertical-align: inherit;">It may happen that you develop on a Windows computer and deploy to Docker / Kubernetes using Linux-based images. </font><font style="vertical-align: inherit;">In this case, the configuration is not as simple as described in many posts. </font><font style="vertical-align: inherit;">I will describe this configuration in another article, and here I will only touch on the code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We need to reconfigure the gRpc channel to use SSL credentials. </font><font style="vertical-align: inherit;">If you deploy to Docker and make Linux-based images, you may also need to configure HttpClient to allow invalid certificates. </font><font style="vertical-align: inherit;">HttpClient is created for each channel.</font></font><br>
<br>
<pre><code class="cs hljs">httpClientBuilder.ConfigureChannel(o =&gt;<font></font>
{<font></font>
    <span class="hljs-comment">// add SSL credentials</span>
    o.Credentials = <span class="hljs-keyword">new</span> SslCredentials();
    <span class="hljs-comment">// allow invalid/untrusted certificates</span>
    <span class="hljs-keyword">var</span> httpClientHandler = <span class="hljs-keyword">new</span> HttpClientHandler<font></font>
    {<font></font>
        ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator<font></font>
    };<font></font>
    <span class="hljs-keyword">var</span> httpClient = <span class="hljs-keyword">new</span> HttpClient(httpClientHandler);<font></font>
    o.HttpClient = httpClient;<font></font>
});<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adding HTTP Headers</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Headers are added in the interceptor class (successor from </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interceptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">gRpc uses the concept of metadata, which is sent along with requests as headers. </font><font style="vertical-align: inherit;">The interceptor class should add metadata for the call context.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AuthHeadersInterceptor</span> : <span class="hljs-title">Interceptor</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AuthHeadersInterceptor</span>(<span class="hljs-params">IHttpContextAccessor httpContextAccessor</span>)</span><font></font>
    {<font></font>
        _httpContextAccessor = httpContextAccessor;<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> AsyncUnaryCall&lt;TResponse&gt; AsyncUnaryCall&lt;TRequest, TResponse&gt;(TRequest request, ClientInterceptorContext&lt;TRequest, TResponse&gt; context, AsyncUnaryCallContinuation&lt;TRequest, TResponse&gt; continuation)<font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> metadata = <span class="hljs-keyword">new</span> Metadata<font></font>
        {<font></font>
            {HttpHeaderNames.Authorization, <span class="hljs-string">$"Bearer &lt;JWT_TOKEN&gt;"</span>}<font></font>
        };<font></font>
        <span class="hljs-keyword">var</span> userIdentity = _httpContextAccessor.HttpContext.User.Identity;
        <span class="hljs-keyword">if</span> (userIdentity.IsAuthenticated)<font></font>
        {<font></font>
            metadata.Add(HttpHeaderNames.User, userIdentity.Name);<font></font>
        }<font></font>
        <span class="hljs-keyword">var</span> callOption = context.Options.WithHeaders(metadata);<font></font>
        context = <span class="hljs-keyword">new</span> ClientInterceptorContext&lt;TRequest, TResponse&gt;(context.Method, context.Host, callOption);<font></font>
        <font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">base</span>.AsyncUnaryCall(request, context, continuation);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the scenario, when you just call the gRpc service, you only need to override the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AsyncUnaryCall</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Of course, the JWT token can be saved in configuration files. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And it's all. </font><font style="vertical-align: inherit;">Later I will add a link to the code with a simple example of the described use case. </font><font style="vertical-align: inherit;">If you have further questions, please write to me. </font><font style="vertical-align: inherit;">I will try to answer.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en499576/index.html">How to work with negative keywords in Yandex.Direct and Google Ads [and automate the process]</a></li>
<li><a href="../en499578/index.html">DOS network using the mTCP stack</a></li>
<li><a href="../en499582/index.html">Predator-Prey Model at Node.js</a></li>
<li><a href="../en499584/index.html">Industrial touch monitor FPM-215W</a></li>
<li><a href="../en499586/index.html">How to think through navigation in mobile applications</a></li>
<li><a href="../en499592/index.html">AI: Complementing tomorrow's world</a></li>
<li><a href="../en499594/index.html">How to limit the frequency of requests in HAProxy: step-by-step instructions</a></li>
<li><a href="../en499598/index.html">And we will go north! Will it be possible to save on the cooling of data centers due to the weather?</a></li>
<li><a href="../en499600/index.html">How to work together, working apart</a></li>
<li><a href="../en499602/index.html">Moving a Conference Online: InnerSource Commons Summit Experience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>