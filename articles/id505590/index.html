<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🚒 🧑‍🤝‍🧑 🧜 Bagaimana komputasi GPU benar-benar menyelamatkan saya di tempat kerja. Contoh python 👩‍👩‍👧‍👧 😡 🐑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 
 
 Hari ini kami menyentuh topik yang paling relevan - Python untuk bekerja dengan GPU. Penulis menganggap sebuah contoh, sepele dalam ke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Bagaimana komputasi GPU benar-benar menyelamatkan saya di tempat kerja. Contoh python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/505590/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo, Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hari ini kami menyentuh topik yang paling relevan - Python untuk bekerja dengan GPU. </font><font style="vertical-align: inherit;">Penulis menganggap sebuah contoh, sepele dalam keburukannya, dan menunjukkan solusinya, menyertainya dengan daftar yang luas. </font><font style="vertical-align: inherit;">Selamat membaca!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xb/mv/xr/xbmvxrrximpm1_fchk6fsi9v5fg.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tak satu pun dari kita, dalam satu atau lain bentuk, telah melewati hype baru-baru ini di sekitar komputasi GPU. Sebelum Anda membaca lebih lanjut, saya akan menjelaskan: Saya bukan ahli GPU. Perjalanan saya di dunia GPU baru saja dimulai. Tetapi hari ini teknologi ini telah mencapai kekuatan sedemikian rupa sehingga, jika dipersenjatai, Anda dapat menyelesaikan banyak masalah. Saya ditugaskan tugas di tempat kerja, mesin menghabiskan waktu berjam-jam di atasnya, dan tidak ada kemajuan yang terlihat. Tapi, segera setelah saya mengambil GPU - dan masalah mulai diselesaikan dalam hitungan detik. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tugas, yang kira-kira butuh 2 hari untuk menyelesaikan, saya bisa menyelesaikan hanya dalam 20 detik</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bagian berikut, saya akan menjelaskan tugas ini secara rinci. </font><font style="vertical-align: inherit;">Kami juga akan membahas bagaimana dan kapan menggunakan GPU untuk menyelesaikan masalah tersebut. </font><font style="vertical-align: inherit;">Jadi, kami membaca dengan seksama - percayalah, Anda tidak akan menyesalinya. </font><font style="vertical-align: inherit;">Pertama, kita akan mempelajari rincian tugas, kemudian terbiasa dengan GPU dan, akhirnya, menggunakan GPU untuk menyelesaikan masalah ini. </font><font style="vertical-align: inherit;">Saya akan menggunakan perpustakaan Python </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numba</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU Nvidia Volta V100 16GB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Penjelasan rinci tentang tugas</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sektor ritel, Anda sering harus mencari benda yang mirip atau terdekat. </font><font style="vertical-align: inherit;">Saya diberi daftar posisi, yang masing-masing diwakili oleh atribut laten. </font><font style="vertical-align: inherit;">Jadi, saya diperintahkan untuk menemukan 3 posisi teratas paling mirip dengan masing-masing posisi dalam daftar. </font><font style="vertical-align: inherit;">Metrik kesamaan dalam masalah ini dipilih cosinus similarity. </font><font style="vertical-align: inherit;">Seperti inilah data saya. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s1/02/if/s102ifuqgnhoe_pv81htzopsye4.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daftar item data dengan 64 karakteristik laten </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompleksitas tugas</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya diberi daftar di mana ada sekitar 10⁵ posisi. </font><font style="vertical-align: inherit;">Mencari 3 posisi paling mirip untuk masing-masing dari mereka akan memerlukan memeriksa kesamaan cosinus dengan masing-masing dan setiap elemen dalam daftar. </font><font style="vertical-align: inherit;">Ini akan menghasilkan operasi n * k, di mana n adalah jumlah posisi, dan k adalah atribut untuk setiap posisi. </font><font style="vertical-align: inherit;">Penting untuk mendapatkan produk skalar dari posisi ini dari masing-masing posisi yang tersisa dalam daftar.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top_3_similar_items</span>(<span class="hljs-params">X,mindex</span>):</span> <span class="hljs-comment"># X   ,    -3 ,       'mindex'</span>
    SMALL = <span class="hljs-number">-9999.0</span> <span class="hljs-comment">#   ,         ( )</span>
    first_best_val = SMALL <span class="hljs-comment">#         </span>
    first_best_index = <span class="hljs-number">-1</span> <span class="hljs-comment">#       </span>
    second_best_val = SMALL <span class="hljs-comment">#        </span>
    second_best_index = <span class="hljs-number">-1</span> <span class="hljs-comment">#       </span>
    third_best_val = SMALL <span class="hljs-comment">#        </span>
    third_best_index = <span class="hljs-number">-1</span> <span class="hljs-comment">#       </span>
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n): <span class="hljs-comment">#  n-  </span>
            <span class="hljs-keyword">if</span>(mindex==j):
                <span class="hljs-keyword">continue</span>
            tmp = np.dot(X[mindex],X[j])/(np.sqrt(np.sum(np.square(X[mindex]))) * np.sqrt(np.sum(np.square(X[j])))) <span class="hljs-comment">#   </span>
            <span class="hljs-keyword">if</span>(tmp&gt;=first_best_val):<font></font>
                third_best_val = second_best_val<font></font>
                third_best_index = second_best_index<font></font>
                second_best_val = first_best_val<font></font>
                second_best_index = first_best_index<font></font>
                first_best_val = tmp<font></font>
                first_best_index = j<font></font>
            <span class="hljs-keyword">elif</span>(tmp&gt;=second_best_val):<font></font>
                third_best_val = second_best_val<font></font>
                third_best_index = second_best_index<font></font>
                second_best_val = tmp<font></font>
                second_best_index = j<font></font>
            <span class="hljs-keyword">elif</span>(tmp&gt;third_best_val):<font></font>
                third_best_val = tmp<font></font>
                third_best_index = j<font></font>
    <span class="hljs-keyword">return</span> first_best_val,first_best_index,second_best_val,second_best_index,third_best_val,third_best_index <span class="hljs-comment">#   </span></code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode untuk menemukan tiga posisi yang semirip mungkin dengan</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sekarang, ketika Anda menemukan 3 posisi teratas yang sama untuk semua posisi dalam daftar, kompleksitasnya dikalikan dengan n lainnya. </font><font style="vertical-align: inherit;">Kompleksitas terakhir adalah O (n * n * k) = O (n²k).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top_3_similar_all_items</span>(<span class="hljs-params">X</span>):</span> <span class="hljs-comment"># X   ,      3     </span>
    SMALL = <span class="hljs-number">-9999.99</span> <span class="hljs-comment">#   ,         ( )</span>
    first_best_index = np.zeros(n,dtype=int) <span class="hljs-comment">#        </span>
    first_best_val = np.zeros(n,dtype=float) <span class="hljs-comment">#       </span>
    second_best_index = np.zeros(n,dtype=int) <span class="hljs-comment">#        </span>
    second_best_val = np.zeros(n,dtype=float) <span class="hljs-comment">#       </span>
    third_best_index = np.zeros(n,dtype=int) <span class="hljs-comment">#        </span>
    third_best_val = np.zeros(n,dtype=float) <span class="hljs-comment">#       </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):
        <span class="hljs-comment"># Initialisation</span><font></font>
        first_best_val[i] = SMALL<font></font>
        first_best_index[i] = <span class="hljs-number">-1</span><font></font>
        second_best_val[i] = SMALL<font></font>
        second_best_index[i] = <span class="hljs-number">-1</span><font></font>
        third_best_val[i] = SMALL<font></font>
        third_best_index[i] = <span class="hljs-number">-1</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n):
            <span class="hljs-keyword">if</span>(i==j):
                <span class="hljs-keyword">continue</span>
            tmp = np.dot(X[i],X[j])/(np.sqrt(np.sum(np.square(X[i]))) * np.sqrt(np.sum(np.square(X[j])))) <span class="hljs-comment">#   </span>
            <span class="hljs-keyword">if</span>(tmp&gt;=first_best_val[i]):<font></font>
                third_best_val[i] = second_best_val[i]<font></font>
                third_best_index[i] = second_best_index[i]<font></font>
                second_best_val[i] = first_best_val[i]<font></font>
                second_best_index[i] = first_best_index[i]<font></font>
                first_best_val[i] = tmp<font></font>
                first_best_index[i] = j<font></font>
            <span class="hljs-keyword">elif</span>(tmp&gt;=second_best_val[i]):<font></font>
                third_best_val[i] = second_best_val[i]<font></font>
                third_best_index[i] = second_best_index[i]<font></font>
                second_best_val[i] = tmp<font></font>
                second_best_index[i] = j<font></font>
            <span class="hljs-keyword">elif</span>(tmp&gt;third_best_val[i]):<font></font>
                third_best_val[i] = tmp<font></font>
                third_best_index[i] = j<font></font>
    <span class="hljs-keyword">return</span> first_best_val,first_best_index,second_best_val,second_best_index,third_best_val,third_best_index <span class="hljs-comment">#   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode untuk menemukan tiga posisi yang paling mirip untuk setiap posisi dalam </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uji coba dan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> daftar </font><i><font style="vertical-align: inherit;">evaluasi waktu</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
saya menjalankan kode, mencoba untuk menemukan 3 posisi paling mirip dari himpunan bagian yang berisi n = 10 k posisi dengan k = 64. Butuh sekitar 17 untuk menyelesaikan tugas ini dengan Python detik pada kecepatan rata-rata 3,7 * 10⁶ operasi per detik. </font><font style="vertical-align: inherit;">Kode telah dioptimalkan dengan baik menggunakan operasi dan array Numpy. </font><font style="vertical-align: inherit;">Saya perhatikan bahwa semua operasi ini dilakukan secara berurutan pada CPU.</font></font><br>
<br>
<pre><code class="python hljs">%time first_best_val,first_best_index,second_best_val,second_best_index,third_best_val,third_best_index = top_3_similar_all_items(X)</code></pre><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalankan untuk n = 10³ posisi</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/z7/fr/p9/z7frp96r6jga71hy_eh5kqc6soo.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Kesimpulan: waktu yang diperlukan untuk n = 10³ posisi </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, saya meningkatkan subset tes ke n = 10⁴ posisi. Karena kompleksitasnya adalah O (n²k), waktu eksekusi telah meningkat 100 kali (karena n telah meningkat 10 kali). Butuh 1700 detik = 28,33 menit untuk mengeksekusi kode. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1t/hz/we/1thzweestkdve12ggxihgenaisu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kesimpulan: waktu yang diperlukan untuk memproses n = 10⁴ posisi </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, kita sampai pada yang paling penting: memperkirakan waktu yang diperlukan untuk memproses daftar lengkap 10⁵ posisi. Menghitung, kita melihat bahwa kompleksitas waktu kembali meningkat sebesar 100 kali, karena kompleksitas waktu dari algoritma adalah O (n²k). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perkiraan waktu = 1700 * 100 detik = 2834 menit = 47,2 jam ~ 2 hari. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya Tuhan! Sangat lama !!!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda mungkin sudah menyadari bahwa saya sebenarnya berhasil melakukan semuanya dengan sangat cepat, menggunakan kekuatan GPU. </font><font style="vertical-align: inherit;">Bahkan, perolehan waktu saat menggunakan GPU cukup mengejutkan. </font><font style="vertical-align: inherit;">Saya akan meninggalkan angka untuk camilan, tetapi untuk sekarang saya sarankan Anda berkenalan dengan dunia GPU.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Perbandingan CPU dan GPU</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Central Processing Unit (CPU), pada dasarnya, adalah otak dari semua perangkat komputasi: ia menjalankan instruksi yang tertulis dalam program, melakukan kontrol, operasi logis, serta operasi input / output. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Benar, CPU modern masih tidak memiliki banyak core, dan struktur dasar dan tujuan CPU - pemrosesan perhitungan yang rumit - pada dasarnya, belum berubah. </font><font style="vertical-align: inherit;">Bahkan, CPU paling cocok untuk memecahkan masalah yang melibatkan penguraian atau menafsirkan logika kompleks yang terkandung dalam kode.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada gilirannya, prosesor grafis (GPU) memiliki core logis yang lebih kecil, yang, bagaimanapun, jauh lebih besar (kita berbicara tentang perangkat logika aritmatika (ALU), elemen kontrol dan memori cache), yang dirancang dengan harapan pemrosesan paralel secara keseluruhan operasi yang identik dan relatif sederhana.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dv/rj/_r/dvrj_rfbqkiabwugkvilkoka3oo.png"><br>
 <blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU memiliki lebih banyak unit aritmatika logika (ALU) daripada CPU pada umumnya, sehingga kemampuan untuk memproses operasi sederhana secara paralel telah ditingkatkan</font></font></blockquote><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar: Bandingkan CPU dan GPU ~ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber Gambar</font></font></a></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Kapan menggunakan komputasi GPU </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CPU lebih cocok untuk tugas linier yang kompleks. Terlepas dari kenyataan bahwa inti CPU lebih kuat, GPU memungkinkan Anda untuk lebih efisien dan cepat memproses tugas-tugas yang berkaitan dengan AI, pembelajaran mesin dan pembelajaran mendalam. GPU menangani beban kerja dengan memparalelkan operasi serupa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gagasan operasi dari sudut pandang GPU: ambil, misalnya, operasi menemukan kata dalam dokumen. Itu dapat dilakukan secara berurutan, memilah satu per satu semua kata dalam dokumen, baik secara paralel, yaitu, baris demi baris, atau dengan pencarian kata tertentu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gagasan operasi dari sudut pandang CPU - ada operasi seperti itu, misalnya, perhitungan seri Fibonacci, yang tidak dapat diparalelkan. Bagaimanapun, Anda dapat menemukan nomor berikutnya hanya setelah Anda menghitung dua sebelumnya. Operasi semacam itu paling cocok untuk CPU.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada gilirannya, operasi seperti penambahan matriks dan perkalian mudah dilakukan dengan menggunakan GPU, karena sebagian besar operasi ini dalam sel matriks tidak tergantung satu sama lain, sifatnya serupa, dan karenanya dapat diparalelkan.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Secara singkat tentang CUDA</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CUDA adalah platform komputasi paralel dan model API yang dibuat oleh Nvidia. Menggunakan API ini, Anda dapat menggunakan prosesor yang mendukung grafik CUDA untuk berbagai perhitungan. Pendekatan ini disebut GPGPU (komputasi non-khusus pada GPU). Di sini mereka dijelaskan secara </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lebih rinci</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUMBA</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Numba adalah kompiler JIT freeware yang menerjemahkan subset dari Python dan NumPy menjadi kode mesin cepat menggunakan LLVM, ini dilakukan dengan menggunakan paket llvmlite dalam Python. Paket ini menawarkan sejumlah opsi untuk memparalelkan kode Python untuk CPU dan GPU, sementara perubahan minimal seringkali cukup dalam kode itu sendiri. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lihat lebih banyak</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bekerja dengan prosesor</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nvidia Volta V100 16GB GPU</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , saya menggunakan perpustakaan Numba. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detail Arsitektur ~ Streaming, Blok, dan Kisi</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
CUDA mengatur komputasi paralel menggunakan abstraksi seperti aliran, blok, dan kisi. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aliran</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">Aliran</font></b><font style="vertical-align: inherit;"> CUDA adalah rantai instruksi yang ditugaskan / mengalir ke inti CUDA (pada kenyataannya, itu hanya sebuah saluran pipa). Dengan cepat, hingga 32 utas dapat ada pada inti CUDA yang sama (dalam hal ini, semua tautan pipa ini diisi). Ini adalah eksekusi kernel dengan indeks yang diberikan. Setiap utas menggunakan indeksnya untuk mengakses elemen-elemen dalam array sedemikian rupa sehingga seluruh rangkaian utas yang tersedia memproses seluruh rangkaian data bersama-sama. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blok</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Ini adalah grup utas. Tidak banyak yang bisa dikatakan tentang eksekusi thread dalam sebuah blok: mereka dapat dieksekusi baik secara berurutan atau paralel, atau tanpa urutan tertentu. Anda dapat mengoordinasikan utas, misalnya, menggunakan fungsi </font></font><code>_syncthreads()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang memaksa utas untuk berhenti pada titik tertentu di kernel dan menunggu sampai semua utas lainnya di blok yang sama juga mencapai titik yang sama. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kisi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ini adalah sekelompok blok. Tidak ada sinkronisasi antara blok. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fu/q_/rm/fuq_rmemxkfpo8o9wkx4es362s8.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CUDA: utas, blok, kisi ~ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Tapi di mana tepatnya thread, blok, dan kisi dieksekusi? Dalam kasus arsitektur GPU Gvid Nvidia, perhitungannya tampaknya didistribusikan sebagai berikut: </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kotak → GPU: Seluruh kotak diproses oleh prosesor GPU tunggal.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Blok → MP: Prosesor GPU disusun sebagai kumpulan multi-prosesor, di mana setiap multi-prosesor bertanggung jawab untuk memproses satu atau lebih blok dalam jaringan. </font><font style="vertical-align: inherit;">Satu blok tidak pernah dibagi antara beberapa anggota parlemen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streaming → PP: Setiap MP dibagi lagi menjadi stream processor (PP), dan setiap PP memproses satu atau lebih utas dalam satu blok. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya meminjam beberapa bahan dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel yang ditulis dengan sangat baik ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Saya sarankan membacanya dengan cermat.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Program sederhana untuk menambahkan array di Python menggunakan GPU</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang saya katakan di awal, inti dari artikel ini adalah untuk membantu khalayak luas memahami kekuatan GPU dan mendapatkan pemahaman intuitif tentang cara menggunakan GPU untuk menyelesaikan tugas sehari-hari. Sebelum Anda mulai menulis kode untuk GPU, Anda mungkin harus melakukan riset pendahuluan. Untuk melakukan ini, mari kita ambil contoh program untuk menambahkan array. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan kita memiliki dua array, 'a' dan 'b' dengan ukuran 'n'. Kami ingin menghasilkan array 'c' sehingga setiap elemen array c adalah jumlah elemen dengan indeks yang sama dari array 'a' dan 'b'. Namun dalam kasus ini, untuk menyelesaikan masalah, kami tidak akan menggunakan perhitungan sekuensial, tetapi perhitungan paralel yang dilakukan menggunakan GPU.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan meluncurkan n utas / inti. Indeks di mana setiap thread bekerja, dapat diturunkan dari rumus berikut: </font></font><br>
<br>
<code>index = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus matriks dua dimensi, indeks berisi dua komponen yang berarti baris dan kolom, yang dapat ditampilkan sebagai berikut: </font><font style="vertical-align: inherit;">
Kita juga harus menentukan jumlah utas per blok, katakanlah, tpb blok per kisi, katakan bpg. Kami akan menggunakan nomor standar untuk mereka. </font><font style="vertical-align: inherit;">
Penting untuk mencatat konsep penting lainnya di sini: ketika perhitungan harus dilakukan pada GPU, data yang sesuai harus ditransfer ke memori global GPU, dan hasil perhitungan kemudian dapat ditransfer kembali ke tuan rumah. Operasi ini dilakukan menggunakan </font><font style="vertical-align: inherit;">dan </font><font style="vertical-align: inherit;">fungsi yang </font><font style="vertical-align: inherit;">disediakan di perpustakaan Python Numba.</font></font><br>
<br>
<code>row = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x<br>
col = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>cuda.to_device()</code><font style="vertical-align: inherit;"></font><code>copy_to_host()</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bawah ini adalah implementasi dari solusi ini untuk CPU dan GPU. </font><font style="vertical-align: inherit;">Lihat kedua daftar untuk perbedaan.</font></font><br>
<br>
<pre><code class="python hljs">c = np.zeroes(n)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):<font></font>
    c[i] = a[i] + b[i]<font></font>
<span class="hljs-keyword">return</span> c</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi berurutan untuk CPU.</font></font></i><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> cuda <span class="hljs-comment">#  Nvidia    GPU </span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <font></font>
<font></font>
<span class="hljs-meta">@cuda.jit('void(float32[:], float32[:], float32[:])') #  Cuda </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cuda_addition</span>(<span class="hljs-params">a,b,c</span>):</span>
    <span class="hljs-string">"""     ."""</span>
    i = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x <span class="hljs-comment">#     </span>
    <span class="hljs-keyword">if</span> i &gt; c.size:
        <span class="hljs-keyword">return</span>
    c[i] = a[i]+b[i] <span class="hljs-comment">#Perform the addition</span><font></font>
 <font></font>
<span class="hljs-comment">#   </span><font></font>
device = cuda.get_current_device()<font></font>
<font></font>
<span class="hljs-comment">#     </span>
d_a = cuda.to_device(a)  <span class="hljs-comment">#      GPU</span>
d_b = cuda.to_device(b)  <span class="hljs-comment">#      GPU</span><font></font>
d_c = cuda.device_array_like(a)<font></font>
<font></font>
tpb = device.WARP_SIZE       <span class="hljs-comment">#blocksize     ,   = 32</span>
bpg = int(np.ceil((n)/tpb))  <span class="hljs-comment">#   </span><font></font>
<font></font>
cuda_addition[bpg, tpb](d_a, d_b, d_c) <span class="hljs-comment">#  </span><font></font>
<font></font>
<span class="hljs-comment">#      </span><font></font>
c = d_c.copy_to_host()<font></font>
print(c)<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi paralel untuk GPU </font></font></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Menemukan 3 posisi paling mirip untuk setiap posisi dalam daftar menggunakan GPU</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah mempelajari teori dan praktik dengan saksama, kami kembali ke tugas semula: untuk menemukan 3 posisi teratas yang sama untuk setiap posisi dalam daftar menggunakan perhitungan GPU. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, ide utamanya adalah bahwa kita memiliki n posisi, dan kita akan memulai n utas. </font><font style="vertical-align: inherit;">Setiap utas akan bekerja secara paralel dengan yang lain dan secara terpisah dari mereka, menghitung 3 posisi paling mirip untuk setiap posisi dalam daftar. </font><font style="vertical-align: inherit;">Setiap posisi akan bertanggung jawab untuk satu utas.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> cuda <span class="hljs-comment"># Nvidia's GPU Library</span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np 
<span class="hljs-keyword">import</span> math <span class="hljs-comment">#  , ,   , Numpy    GPU</span>
<span class="hljs-keyword">import</span> random<font></font>
<font></font>
<span class="hljs-comment">#                   </span>
<span class="hljs-meta">@cuda.jit('void(float32[:,:],float32[:],int32[:],float32[:],int32[:],float32[:],int32[:])') # CUDA Just-in-time Compiler</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cuda_dist</span>(<span class="hljs-params">X,first_best_val,first_best_index,second_best_val,second_best_index,third_best_val,third_best_index</span>):</span>
    <span class="hljs-string">"""     ."""</span>
    <span class="hljs-comment">#    </span><font></font>
    row = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x;<font></font>
    <span class="hljs-keyword">if</span> ((row &gt;= n)): <span class="hljs-comment">#      </span>
        <span class="hljs-keyword">return</span>
    first_best_val[row] = SMALL <span class="hljs-comment">#       </span>
    first_best_index[row] = <span class="hljs-number">-1</span> <span class="hljs-comment">#        </span>
    second_best_val[row] = SMALL <span class="hljs-comment">#       </span>
    second_best_index[row] = <span class="hljs-number">-1</span> <span class="hljs-comment">#        </span>
    third_best_val[row] = SMALL <span class="hljs-comment">#       </span>
    third_best_index[row] = <span class="hljs-number">-1</span> <span class="hljs-comment">#        </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):
        <span class="hljs-keyword">if</span>(i==row): <span class="hljs-comment">#   </span>
            <span class="hljs-keyword">continue</span>
        <span class="hljs-comment">#     ,        numpy   GPU</span>
        tmp = <span class="hljs-number">0.0</span>
        magnitude1 = <span class="hljs-number">0.0</span>
        magnitude2 = <span class="hljs-number">0.0</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(k):<font></font>
            tmp += X[row,j] * X[i,j]<font></font>
            magnitude1 += (X[row,j]* X[row,j])<font></font>
            magnitude2 += (X[i,j]* X[i,j])<font></font>
        tmp /= (math.sqrt(magnitude1)*math.sqrt(magnitude2)) <span class="hljs-comment">#    Dot_product(a,b) = a.b/(|a|*|b|)</span>
        <span class="hljs-keyword">if</span>(tmp&gt;=first_best_val[row]):<font></font>
            third_best_val[row] = second_best_val[row]<font></font>
            third_best_index[row] = second_best_index[row]<font></font>
            second_best_val[row] = first_best_val[row]<font></font>
            second_best_index[row] = first_best_index[row]<font></font>
            first_best_val[row] = tmp<font></font>
            first_best_index[row] = i<font></font>
        <span class="hljs-keyword">elif</span>(tmp&gt;=second_best_val[row]):<font></font>
            third_best_val[row] = second_best_val[row]<font></font>
            third_best_index[row] = second_best_index[row]<font></font>
            second_best_val[row] = tmp<font></font>
            second_best_index[row] = i<font></font>
        <span class="hljs-keyword">elif</span>(tmp&gt;third_best_val[row]):<font></font>
            third_best_val[row] = tmp<font></font>
            third_best_index[row] = i<font></font>
<font></font>
<span class="hljs-comment">#   </span><font></font>
device = cuda.get_current_device()<font></font>
<font></font>
d_x = cuda.to_device(X)<font></font>
d_first_val = cuda.device_array_like(first_val)<font></font>
d_first_index = cuda.device_array_like(first_index)<font></font>
d_second_val = cuda.device_array_like(second_val)<font></font>
d_second_index = cuda.device_array_like(second_index)<font></font>
d_third_val = cuda.device_array_like(third_val)<font></font>
d_third_index = cuda.device_array_like(third_index)<font></font>
<font></font>
<font></font>
tpb = device.WARP_SIZE       <span class="hljs-comment"># blocksize     </span>
bpg = int(np.ceil((n)/tpb))  <span class="hljs-comment">#   </span><font></font>
<font></font>
%time cuda_dist[bpg,tpb](d_x,d_first_val,d_first_index,d_second_val,d_second_index,d_third_val,d_third_index) <span class="hljs-comment">#  </span><font></font>
<font></font>
<span class="hljs-comment">#      </span><font></font>
first_val = d_first_val.copy_to_host()<font></font>
<span class="hljs-keyword">print</span> (first_val[:<span class="hljs-number">10</span>]) <span class="hljs-comment">#  10 </span>
<span class="hljs-comment">#      </span><font></font>
first_index = d_first_index.copy_to_host()<font></font>
<span class="hljs-keyword">print</span> (first_index[:<span class="hljs-number">10</span>]) <span class="hljs-comment">#  10 </span>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi untuk GPU ~ Kode untuk menemukan 3 posisi paling mirip dengan </font></font></i><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">waktu yang </font></font></b><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">diberikan</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
dihabiskan Total waktu yang dihabiskan oleh GPU untuk menemukan 3 posisi teratas yang sama untuk setiap posisi dalam daftar adalah 481 ms (0,5 detik). </font><font style="vertical-align: inherit;">Butuh 20 detik untuk menyalin data dari perangkat ke host dan dari host ke perangkat.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Kesimpulan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tugas, solusi yang pada CPU akan memakan waktu sekitar 2 hari, pada GPU diselesaikan dalam 20,5 detik. </font><font style="vertical-align: inherit;">Ini dimungkinkan hanya karena sifat tugas. </font><font style="vertical-align: inherit;">Pencarian untuk 3 posisi paling mirip untuk 'A' tidak tergantung pada pencarian untuk 3 posisi paling mirip untuk 'B'. </font><font style="vertical-align: inherit;">Kami mengambil keuntungan dari fakta ini dan menerapkan paralelisme yang disediakan oleh GPU untuk mempercepat proses. </font><font style="vertical-align: inherit;">Contoh ini juga menggambarkan jenis tugas apa yang paling mudah diselesaikan dengan bantuan GPU yang kuat.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Ucapan Terima Kasih</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penelitian ini dilakukan pada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Walmart Labs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MLP (platform pembelajaran mesin) </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Terima kasih kepada Ayush Kumar karena membantu merampingkan alur kerja.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id505558/index.html">Amazon DeepLens Deep Learning Camera. Membongkar, menghubungkan, dan menggunakan proyek</a></li>
<li><a href="../id505560/index.html">Set kedua untuk program manajemen produk di pusat CS: apa yang siswa katakan</a></li>
<li><a href="../id505568/index.html">Mentransfer file menggunakan pipa dan hal-hal kecil lainnya di Delphi</a></li>
<li><a href="../id505574/index.html">Pembelajaran yang diperkuat melalui jaringan saraf kompetitif</a></li>
<li><a href="../id505580/index.html">Menggunakan spreadsheet dan perangkat lunak komputasi untuk pemodelan Newsvendor</a></li>
<li><a href="../id505592/index.html">Pemrograman untuk BK0010 menggunakan Android</a></li>
<li><a href="../id505594/index.html">Cara mengubah pengunjung situs menjadi klien: panduan untuk membuat formulir prospek</a></li>
<li><a href="../id505604/index.html">Kerentanan kecanduan</a></li>
<li><a href="../id505608/index.html">Vuex - pecahkan perselisihan lama dengan metode baru</a></li>
<li><a href="../id505612/index.html">MK-61: sejarah, emulasi, perangkat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>