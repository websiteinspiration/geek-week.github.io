<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍙 🐤 🏠 関数型JavaScript：高次関数とは何ですか？なぜそれらが必要なのですか？ ↙️ 🕷️ 👨🏼‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="「高階関数」は、散在することが多いフレーズの1つです。しかし、それが何であるかを誰かが止めて説明することはめったにありません。高階関数と呼ばれるものをすでに知っているかもしれません。しかし、実際のプロジェクトでそれらをどのように使用しますか？いつ、なぜ役立つのですか？彼らの助けを借りてDOMを操作で...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>関数型JavaScript：高次関数とは何ですか？なぜそれらが必要なのですか？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/458896/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/st/le/mw/stlemwjifksb6iqurxqvutclf9s.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「高階関数」は、散在することが多いフレーズの1つです。</font><font style="vertical-align: inherit;">しかし、それが何であるかを誰かが止めて説明することはめったにありません。</font><font style="vertical-align: inherit;">高階関数と呼ばれるものをすでに知っているかもしれません。</font><font style="vertical-align: inherit;">しかし、実際のプロジェクトでそれらをどのように使用しますか？</font><font style="vertical-align: inherit;">いつ、なぜ役立つのですか？</font><font style="vertical-align: inherit;">彼らの助けを借りてDOMを操作できますか？</font><font style="vertical-align: inherit;">それとも、これらの機能を使用している人は単に自慢しているのでしょうか？</font><font style="vertical-align: inherit;">おそらく、コードを無意味に複雑にしていますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高階関数は便利だと思っていました。</font><font style="vertical-align: inherit;">今、私はそれらを言語としてのJavaScriptの最も重要な特性であると考えています。</font><font style="vertical-align: inherit;">しかし、これを説明する前に、まず高次関数とは何かを理解しましょう。</font><font style="vertical-align: inherit;">そして、変数としての関数から始めます。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファーストクラスのオブジェクトとして機能</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptでは、新しい関数を書くには少なくとも3つの方法があります（全部でもっとあります）。</font><font style="vertical-align: inherit;">最初に、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数宣言を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">書くことができます</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// Take a DOM element and wrap it in a list item element.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">itemise</span>(<span class="hljs-params">el</span>) </span>{
    <span class="hljs-keyword">const</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'li'</span>);<font></font>
    li.appendChild(el);<font></font>
    <span class="hljs-keyword">return</span> li;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが明確になっていることを願っています。</font><font style="vertical-align: inherit;">また、おそらく</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数式を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記述できることはご存じでしょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> itemise = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el</span>) </span>{
    <span class="hljs-keyword">const</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'li'</span>);<font></font>
    li.appendChild(el);<font></font>
    <span class="hljs-keyword">return</span> li;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、同じ関数を書く別の方法があります- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アロー関数</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> itemise = <span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'li'</span>);<font></font>
    li.appendChild(el);<font></font>
    <span class="hljs-keyword">return</span> li;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、3つの方法はすべて同等です。</font><font style="vertical-align: inherit;">これは常に発生するわけではありませんが、実際には、各メソッドには、スタックトレース内の特定のキーワードとタグの魔法に何が起こるかに関連する小さな違いがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、最後の2つの例では、関数を変数に割り当てていることに注意してください。</font><font style="vertical-align: inherit;">ささいなことのようです。</font><font style="vertical-align: inherit;">変数に関数を割り当てませんか？</font><font style="vertical-align: inherit;">しかし、それは非常に重要です。</font><font style="vertical-align: inherit;">JavaScriptの関数は「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファーストクラス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」に</font><font style="vertical-align: inherit;">属し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">したがって、次のことができます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数に関数を割り当てます。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を引数として他の関数に渡します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他の関数から関数を返します。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはすばらしいことですが、これはすべて高次関数とどう関係しているのでしょうか。</font><font style="vertical-align: inherit;">最後の2つの点に注意してください。</font><font style="vertical-align: inherit;">すぐにそれらに戻りますが、ここではいくつかの例を見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数への関数の割り当てを見ました。</font><font style="vertical-align: inherit;">それらをパラメーターとして渡すのはどうですか？</font><font style="vertical-align: inherit;">DOM要素で使用できる関数を書いてみましょう。</font><font style="vertical-align: inherit;">実行する</font></font><code>document.querySelectorAll()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、代わりに配列ではなくを取得し</font></font><code>NodeList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">配列のような</font></font><code>NodeList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">ない</font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、次のように記述します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// Apply a given function to every item in a NodeList and return an array.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">elListMap</span>(<span class="hljs-params">transform, list</span>) </span>{
    <span class="hljs-comment">// list might be a NodeList, which doesn't have .map(), so we convert</span>
    <span class="hljs-comment">// it to an array.</span>
    <span class="hljs-keyword">return</span> [...list].map(transform);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Grab all the spans on the page with the class 'for-listing'.</span>
<span class="hljs-keyword">const</span> mySpans = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'span.for-listing'</span>);<font></font>
<font></font>
<span class="hljs-comment">// Wrap each one inside an &lt;li&gt; element. We re-use the</span>
<span class="hljs-comment">// itemise() function from earlier.</span>
<span class="hljs-keyword">const</span> wrappedList = elListMap(itemise, mySpans);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、関数</font></font><code>itemise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を引数として</font><font style="vertical-align: inherit;">関数に渡し</font><font style="vertical-align: inherit;">ます</font></font><code>elListMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、</font></font><code>elListMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リストを作成するためだけに</font><font style="vertical-align: inherit;">使用することはでき</font><font style="vertical-align: inherit;">ません。</font><font style="vertical-align: inherit;">たとえば、その助けを借りて、クラスを一連の要素に追加できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSpinnerClass</span>(<span class="hljs-params">el</span>) </span>{<font></font>
    el.classList.add(<span class="hljs-string">'spinner'</span>);
    <span class="hljs-keyword">return</span> el;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Find all the buttons with class 'loader'</span>
<span class="hljs-keyword">const</span> loadButtons = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'button.loader'</span>);<font></font>
<font></font>
<span class="hljs-comment">// Add the spinner class to all the buttons we found.</span><font></font>
elListMap(addSpinnerClass, loadButtons);<font></font>
</code></pre><br>
<code>elLlistMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別の関数をパラメーターとして取り、変換します。</font><font style="vertical-align: inherit;">つまり、</font></font><code>elListMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまな問題を解決するために</font><font style="vertical-align: inherit;">使用できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数をパラメーターとして渡す例を調べました。</font><font style="vertical-align: inherit;">次に、関数から関数を返す方法について説明します。</font><font style="vertical-align: inherit;">それはどのように見えますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、通常の古い関数を記述します。</font><font style="vertical-align: inherit;">要素のリストを取得して</font></font><code>li</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラップ</font><font style="vertical-align: inherit;">する必要があり</font></font><code>ul</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">簡単：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapWithUl</span>(<span class="hljs-params">children</span>) </span>{
    <span class="hljs-keyword">const</span> ul = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'ul'</span>);
    <span class="hljs-keyword">return</span> [...children].reduce(<span class="hljs-function">(<span class="hljs-params">listEl, child</span>) =&gt;</span> {<font></font>
        listEl.appendChild(child);<font></font>
        <span class="hljs-keyword">return</span> listEl;<font></font>
    }, ul);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ラップしたい段落要素がたくさんあるとし</font></font><code>div</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たら？</font><font style="vertical-align: inherit;">問題ありません。このための関数をもう1つ記述します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapWithDiv</span>(<span class="hljs-params">children</span>) </span>{
    <span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
    <span class="hljs-keyword">return</span> [...children].reduce(<span class="hljs-function">(<span class="hljs-params">divEl, child</span>) =&gt;</span> {<font></font>
        divEl.appendChild(child);<font></font>
        <span class="hljs-keyword">return</span> divEl;<font></font>
    }, div);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
よく働く。</font><font style="vertical-align: inherit;">ただし、これら2つの関数は非常に似ています。唯一の違いは、作成した親要素です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これ</font><font style="vertical-align: inherit;">で、親要素のタイプと子要素のリストの2つのパラメーターを取る関数を作成</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でき</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました。</font><font style="vertical-align: inherit;">しかし、別のオプションがあります。</font><font style="vertical-align: inherit;">関数を返す関数を作成できます。</font><font style="vertical-align: inherit;">例えば：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createListWrapperFunction</span>(<span class="hljs-params">elementType</span>) </span>{
    <span class="hljs-comment">// Straight away, we return a function.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span>(<span class="hljs-params">children</span>) </span>{
      <span class="hljs-comment">// Inside our wrap function, we can 'see' the elementType parameter.</span>
      <span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.createElement(elementType);
      <span class="hljs-keyword">return</span> [...children].reduce(<span class="hljs-function">(<span class="hljs-params">parentEl, child</span>) =&gt;</span> {<font></font>
          parentEl.appendChild(child);<font></font>
          <span class="hljs-keyword">return</span> parentEl;<font></font>
      }, parent);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は少し複雑に見えるかもしれないので、コードを分割しましょう。</font><font style="vertical-align: inherit;">別の関数を返すだけの関数を作成しました。</font><font style="vertical-align: inherit;">ただし、この戻り関数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータを</font><i><font style="vertical-align: inherit;">記憶してい</font></i><font style="vertical-align: inherit;">ます</font></font><code>elementType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そして、返された関数を呼び出すとき、作成する要素はすでにわかっています。</font><font style="vertical-align: inherit;">したがって、あなたが作成することができます</font></font><code>wrapWithUl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>wrapWithDiv</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> wrapWithUl  = createListWrapperFunction(<span class="hljs-string">'ul'</span>);
<span class="hljs-comment">// Our wrapWithUl() function now 'remembers' that it creates a ul element.</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> wrapWithDiv = createListWreapperFunction(<span class="hljs-string">'div'</span>);
<span class="hljs-comment">// Our wrapWithDiv() function now 'remembers' that it creates a div element.</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このトリックは、返された関数が何かを「覚えている」とき、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クロージャ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ば</font><i><font style="vertical-align: inherit;">れ</font></i><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">詳しくは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらをご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">クロージャーは信じられないほど便利ですが、今のところは考えません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だから、私たちは作りました：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数に関数を割り当てる。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数をパラメーターとして渡します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別の関数から関数を返す...</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、ファーストクラスの機能は楽しいものです。</font><font style="vertical-align: inherit;">しかし</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、高次関数はそれと</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのような関係が</font><i><font style="vertical-align: inherit;">あるの</font></i><font style="vertical-align: inherit;">でしょうか。</font><font style="vertical-align: inherit;">定義を見てみましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高次関数とは何ですか？</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定義</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、関数を引数として取るか、結果として関数を返す関数です。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おなじみですか？</font><font style="vertical-align: inherit;">JavaScriptでは、これらはファーストクラスの関数です。</font><font style="vertical-align: inherit;">つまり、「高次関数」にもまったく同じ利点があります。</font><font style="vertical-align: inherit;">言い換えれば、それは単純なアイデアの単なる空想的な名前です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高次関数の例</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検索を始めると、どこにでも高次関数に気づき始めます。</font><font style="vertical-align: inherit;">最も一般的なのは、他の関数をパラメーターとして取る関数です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他の関数をパラメーターとして取る関数</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コールバックを渡すときは、高次関数を使用します。</font><font style="vertical-align: inherit;">フロントエンド開発では、どこにでもあります。</font><font style="vertical-align: inherit;">最も一般的なのはメソッド</font></font><code>.addEventListener()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">一部のイベントに対応してアクションを実行する場合に使用します。</font><font style="vertical-align: inherit;">たとえば、警告を表示するボタンを作成したいとします。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showAlert</span>(<span class="hljs-params"></span>) </span>{<font></font>
  alert(<span class="hljs-string">'Fallacies do not cease to be fallacies because they become fashions'</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">document</span>.body.innerHTML += <span class="hljs-string">`&lt;button type="button" class="js-alertbtn"&gt;
  Show alert
&lt;/button&gt;`</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.js-alertbtn'</span>);<font></font>
<font></font>
btn.addEventListener(<span class="hljs-string">'click'</span>, showAlert);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、警告を表示する関数を作成し、ページにボタンを追加し、関数</font></font><code>showAlert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を引数としてに</font><font style="vertical-align: inherit;">渡しました</font></font><code>btn.addEventListener()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我々はまた、我々が使用している場合、高階関数を見つける</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反復配列の方法を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、例えば</font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>.filter()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>.reduce()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">関数のように</font></font><code>elListMap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">elListMap</span>(<span class="hljs-params">transform, list</span>) </span>{
    <span class="hljs-keyword">return</span> [...list].map(transform);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高次関数は、遅延とタイミングの処理にも役立ちます。</font><font style="vertical-align: inherit;">関数</font></font><code>setTimeout()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">関数が実行される</font><i><font style="vertical-align: inherit;">タイミング</font></i></font><code>setInterval()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を制御</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘルプ</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">たとえば、30秒後にクラスを削除する必要がある場合は</font></font><code>highlight</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次のように実行できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeHighlights</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> highlightedElements = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.highlighted'</span>);<font></font>
    elListMap(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.classList.remove(<span class="hljs-string">'highlighted'</span>), highlightedElements);<font></font>
}<font></font>
<font></font>
setTimeout(removeHighlights, <span class="hljs-number">30000</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでも、関数を作成し、それを引数として別の関数に渡しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、JavaScriptには他の関数を受け入れる関数が含まれていることがよくあります。</font><font style="vertical-align: inherit;">そして、おそらくすでにそれらを使用しています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を返す関数</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この種の関数は、以前の関数ほど頻繁には見つかりません。</font><font style="vertical-align: inherit;">しかし、それらはまた有用です。</font><font style="vertical-align: inherit;">最良の例の1つは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おそらく（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">です。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AllongéJavaScriptブックの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バリアントを採用しました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maybe</span>(<span class="hljs-params">fn</span>)
    <span class="hljs-title">return</span> <span class="hljs-title">function</span> <span class="hljs-title">_maybe</span>(<span class="hljs-params">...args</span>) </span>{
        <span class="hljs-comment">// Note that the == is deliberate.</span>
        <span class="hljs-keyword">if</span> ((args.length === <span class="hljs-number">0</span>) || args.some(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> (a == <span class="hljs-literal">null</span>)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, args);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードがどのように機能するかを理解する代わりに、最初にそれがどのように適用されるかを見てみましょう。</font><font style="vertical-align: inherit;">関数をもう一度見てみましょう</font></font><code>elListMap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// Apply a given function to every item in a NodeList and return an array.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">elListMap</span>(<span class="hljs-params">transform, list</span>) </span>{
    <span class="hljs-comment">// list might be a NodeList, which doesn't have .map(), so we convert</span>
    <span class="hljs-comment">// it to an array.</span>
    <span class="hljs-keyword">return</span> [...list].map(transform);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誤って</font></font><code>elListMap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullまたは未定義の値を</font><font style="vertical-align: inherit;">渡した場合はどうなります</font><font style="vertical-align: inherit;">か？</font><font style="vertical-align: inherit;">TypeErrorと現在の操作のフォールを取得します。</font><font style="vertical-align: inherit;">これを回避するには、次の関数を使用します</font></font><code>maybe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> safeElListMap = maybe(elListMap);<font></font>
safeElListMap(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x, <span class="hljs-literal">null</span>);
<span class="hljs-comment">// ￩ undefined</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数は落下するのではなく、を返し</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">そして、それを別の関数protected </font></font><code>maybe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">渡した場合は</font><font style="vertical-align: inherit;">、再び</font><font style="vertical-align: inherit;">取得</font><font style="vertical-align: inherit;">し</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">を使用</font></font><code>maybe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すると、任意の数の関数を保護できるため、10億の式を作成するのがはるかに簡単になります</font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数を返す関数は、Reactの世界でも一般的です。</font><font style="vertical-align: inherit;">例えば</font></font><code>connect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それでは、次は何ですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高階関数の使用例をいくつか見ました。</font><font style="vertical-align: inherit;">それでは、次は何ですか？</font><font style="vertical-align: inherit;">彼らなしでは得ることができないものを彼らは私たちに何を与えることができますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この質問に答えるために、別の例、組み込みの配列メソッドを見てみましょう</font></font><code>.sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">はい、彼には欠点があります。</font><font style="vertical-align: inherit;">新しい配列を返すのではなく、配列を変更します。</font><font style="vertical-align: inherit;">しかし、今はそれについて忘れましょう。</font><font style="vertical-align: inherit;">メソッド</font></font><code>.sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は高次関数であり、パラメーターの1つとして別の関数を受け取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使い方？</font><font style="vertical-align: inherit;">数値の配列をソートする場合は、最初に比較関数を作成する必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareNumbers</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">if</span> (a === b) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (a &gt; b)   <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-comment">/* else */</span>   <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、配列を並べ替えます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> nums = [<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>];<font></font>
nums.sort(compareNumbers);<font></font>
<span class="hljs-built_in">console</span>.log(nums);
<span class="hljs-comment">// 〕[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数値のリストを並べ替えることができます。</font><font style="vertical-align: inherit;">しかし、それは何が良いのでしょうか？</font><font style="vertical-align: inherit;">ソートする数値のリストはどのくらいの頻度でありますか？</font><font style="vertical-align: inherit;">まれに。</font><font style="vertical-align: inherit;">通常、オブジェクトの配列を並べ替える必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> typeaheadMatches = [<font></font>
    {<font></font>
        <span class="hljs-attr">keyword</span>: <span class="hljs-string">'bogey'</span>,
        <span class="hljs-attr">weight</span>: <span class="hljs-number">0.25</span>,
        <span class="hljs-attr">matchedChars</span>: [<span class="hljs-string">'bog'</span>],<font></font>
    },<font></font>
    {<font></font>
        <span class="hljs-attr">keyword</span>: <span class="hljs-string">'bog'</span>,
        <span class="hljs-attr">weight</span>: <span class="hljs-number">0.5</span>,
        <span class="hljs-attr">matchedChars</span>: [<span class="hljs-string">'bog'</span>],<font></font>
    },<font></font>
    {<font></font>
        <span class="hljs-attr">keyword</span>: <span class="hljs-string">'boggle'</span>,
        <span class="hljs-attr">weight</span>: <span class="hljs-number">0.3</span>,
        <span class="hljs-attr">matchedChars</span>: [<span class="hljs-string">'bog'</span>],<font></font>
    },<font></font>
    {<font></font>
        <span class="hljs-attr">keyword</span>: <span class="hljs-string">'bogey'</span>,
        <span class="hljs-attr">weight</span>: <span class="hljs-number">0.25</span>,
        <span class="hljs-attr">matchedChars</span>: [<span class="hljs-string">'bog'</span>],<font></font>
    },<font></font>
    {<font></font>
        <span class="hljs-attr">keyword</span>: <span class="hljs-string">'toboggan'</span>,
        <span class="hljs-attr">weight</span>: <span class="hljs-number">0.15</span>,
        <span class="hljs-attr">matchedChars</span>: [<span class="hljs-string">'bog'</span>],<font></font>
    },<font></font>
    {<font></font>
        <span class="hljs-attr">keyword</span>: <span class="hljs-string">'bag'</span>,
        <span class="hljs-attr">weight</span>: <span class="hljs-number">0.1</span>,
        <span class="hljs-attr">matchedChars</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'g'</span>],<font></font>
    }<font></font>
];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この配列を各レコードの重みでソートしたいとします。私は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能性が</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゼロから新しいソート関数を記述します。しかし、なぜ、新しい比較関数を作成できるのか。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareTypeaheadResult</span>(<span class="hljs-params">word1, word2</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> * compareNumbers(word1.weight, word2.weight);<font></font>
}<font></font>
<font></font>
typeaheadMatches.sort(compareTypeaheadResult);<font></font>
<span class="hljs-built_in">console</span>.log(typeaheadMatches);
<span class="hljs-comment">// 〕[{keyword: "bog", weight: 0.5, matchedChars: ["bog"]}, … ]</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あらゆる種類の配列の比較関数を作成できます。この方法</font></font><code>.sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は私たちに役立ちます。「比較関数を提供してくれれば、配列を並べ替えます。中身は気にしないでください。並べ替え関数を指定すると、並べ替えられます。」したがって、ソートアルゴリズムを自分で作成する必要はありません。2つの要素を比較するというはるかに単純なタスクに焦点を当てます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、高次関数を使用していないことを想像してください。メソッドに関数を渡すことはできません</font></font><code>.sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。別の種類の配列をソートする必要があるたびに、新しいソート関数を作成する必要があります。または、関数ポインターまたはオブジェクトを使用して同じことを再発明する必要があります。いずれにしても、それは非常にぎこちないことが判明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ソート関数を比較関数から分離できるようにする高次関数があります。スマートブラウザの開発者が</font></font><code>.sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、より高速なアルゴリズムを使用するように</font><font style="vertical-align: inherit;">更新</font><font style="vertical-align: inherit;">したとします。そうすれば、ソート可能な配列の内部に関係なく、コードは勝つだけです。そしてこのスキームは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、より高次の配列の関数セット全体に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当てはまり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは私たちをそのような考えに導きます。このメソッド</font><font style="vertical-align: inherit;">は、</font><i><font style="vertical-align: inherit;">コンテンツ</font></i><font style="vertical-align: inherit;">から</font><i><font style="vertical-align: inherit;">並べ替え</font></i><font style="vertical-align: inherit;">タスク</font><font style="vertical-align: inherit;">を</font></font><code>.sort()</code> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象化</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し</font><i><font style="vertical-align: inherit;">ます</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アレイ。これは、懸念の分離と呼ばれます。高次関数を使用すると、抽象化を作成できます。抽象化を行わないと、非常に面倒で、不可能ですらあります。また、抽象化の作成は、ソフトウェアエンジニアの作業の80％を占めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードをリファクタリングして繰り返しを削除すると、抽象化が作成されます。パターンを見て、それを抽象的な表現に置き換えます。その結果、コードはより意味があり、理解しやすくなります。少なくともそれが目標です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高次関数は、抽象化を作成するための強力なツールです。そして、抽象化には、数学、カテゴリー理論の全分野が結びついています。より正確には、カテゴリー理論は抽象化の抽象化の検索に専念しています。つまり、パターンのパターンを見つけることについて話しているのです。そして過去70年間、賢いプログラマーはそこから多くのアイデアを借りてきており、それが言語とライブラリーの特性に変わりました。これらのパターンを学ぶと、大きなコードを置き換えることができる場合があります。または、複雑な問題を単純なビルディングブロックのエレガントな組み合わせに単純化します。これらのブロックは高次関数です。したがって、これらは非常に重要であり、コードの複雑さと戦うための強力なツールを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高次関数に関する追加資料：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  </a>:    <i>Eloquent JavaScript</i>.<br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  </a>:    <i>Composing Sofware</i>.<br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">    JavaScript</a>.<br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらくすでに高次関数を使用しています。</font><font style="vertical-align: inherit;">これはJavaScriptでは非常に簡単なので、私たちはそれについてさえ考えていません。</font><font style="vertical-align: inherit;">しかし、このフレーズを言うとき、人々が何について話しているかを知っている方が良いです。</font><font style="vertical-align: inherit;">これは難しくありません。</font><font style="vertical-align: inherit;">しかし、単純なアイデアの背後には多くの力があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数型プログラミングの経験があれば、純粋な関数ではなく、いくつかの...詳細な関数名を使用していることに気づいたかもしれません。</font><font style="vertical-align: inherit;">これは、汚れた関数や関数型プログラミングの一般原則について聞いたことがないためではありません。</font><font style="vertical-align: inherit;">そして、私は本番環境でそのようなコードを書きません。</font><font style="vertical-align: inherit;">初心者にも分かりやすい具体例を挙げてみました。</font><font style="vertical-align: inherit;">時には妥協する必要がありました。</font><font style="vertical-align: inherit;">興味があれば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数型の清潔さ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数型プログラミングの一般原則</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">についてはすでに書きました</font><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja458886/index.html">最も有用なMail.ru Design Conf×Dribbble Meetup 2019論文by True Engineering</a></li>
<li><a href="../ja458888/index.html">夏のドロイドのMeetup</a></li>
<li><a href="../ja458890/index.html">サンプリングと計算の精度</a></li>
<li><a href="../ja458892/index.html">機械学習モデルの脆弱性と保護に関する提案</a></li>
<li><a href="../ja458894/index.html">典型的な人々と彼らが住んでいるネットワーク</a></li>
<li><a href="../ja458900/index.html">モデムとしてのコンソールカートリッジ</a></li>
<li><a href="../ja458902/index.html">5つの一般的な初心者のPythonの間違い</a></li>
<li><a href="../ja458904/index.html">Rのアニメーション化された棒グラフを使用したNBAチームの勝利数の視覚化</a></li>
<li><a href="../ja458906/index.html">[エカテリンブルク、発表] Flutteron-Flutterの開発に関するワークショップ</a></li>
<li><a href="../ja458908/index.html">ネットワーク経由でドキュメントをスキャンする</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>