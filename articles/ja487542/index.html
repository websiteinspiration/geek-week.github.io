<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍜 🤝 🏀 PRESENT-超軽量ブロック暗号（元のPRESENTの翻訳：超軽量ブロック暗号） 👂🏼 ⏳ ✋🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！これは、ロバートB.ウェイデボグダノフ、レンダー、パール、ポッシュマン、ロブシャフ、スリン、ウィッケルソイによるオリジナル記事「現在：超軽量ブロック暗号」の翻訳です。
 
 
 注釈
ほとんどの場合AESは優れたソリューションであるため 、AESの導入により、新しいブロック暗号ア...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PRESENT-超軽量ブロック暗号（元のPRESENTの翻訳：超軽量ブロック暗号）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487542/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！</font><font style="vertical-align: inherit;">これは、</font><strike><font style="vertical-align: inherit;">ロバートB.</font></strike><font style="vertical-align: inherit;">ウェイデボグダノフ、レンダー、パール、ポッシュマン、ロブシャフ、スリン、ウィッケルソイ</font><font style="vertical-align: inherit;">による</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オリジナル記事「現在：超軽量ブロック暗号」の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳です。</font></font><strike><font style="vertical-align: inherit;"></font></strike><font style="vertical-align: inherit;"></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/n7/eg/txn7egneg1_32856cpillz8r9_a.jpeg" width="400"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注釈</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどの場合</font><acronym><font style="vertical-align: inherit;">AES</font></acronym><font style="vertical-align: inherit;">は優れたソリューションで</font><font style="vertical-align: inherit;">あるため</font><font style="vertical-align: inherit;">
、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><abbr title="高度な暗号化規格"><font style="vertical-align: inherit;">AES</font></abbr></a><font style="vertical-align: inherit;">の導入により、</font><font style="vertical-align: inherit;">新しいブロック暗号アルゴリズムの必要性は急激に低下してい</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">ただし、</font><acronym><font style="vertical-align: inherit;">AESは</font></acronym><font style="vertical-align: inherit;">実装が容易であるにもかかわらず、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><abbr title="無線周波数識別"><font style="vertical-align: inherit;">RFID</font></abbr></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">タグやリーダー</font></a><font style="vertical-align: inherit;">などの非常に限られた環境には適していません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この記事では、超軽量ブロック暗号化アルゴリズムPRESENTについて説明します。</font><font style="vertical-align: inherit;">このアルゴリズムの開発中に、鉄の実装の効率と暗号化の信頼性の両方が考慮されました。</font><font style="vertical-align: inherit;">その結果、システム要件の結果は、今日の主要なコンパクトストリーム暗号に匹敵します。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"> <abbr title="高度な暗号化規格"><font style="vertical-align: inherit;"></font></abbr></a><font style="vertical-align: inherit;"></font><acronym><font style="vertical-align: inherit;"></font></acronym><font style="vertical-align: inherit;"></font><acronym><font style="vertical-align: inherit;"></font></acronym><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><abbr title="無線周波数識別"><font style="vertical-align: inherit;"></font></abbr><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.はじめに</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今世紀のITの主な流れは、消費者向け製品だけでなく、環境の不可欠な、そして目に見えない部分である通信インフラストラクチャーも形成する、小さなコンピューティングデバイスの開発です。このような実装は、非常に具体的なセキュリティ脅威の全範囲を生み出すことがすでに明らかになっています。同時に、利用可能な暗号化ソリューションは、かなり原始的なものであっても、リソースが非常に限られている環境での使用には適していないことがよくあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、可能な限り最大のサイズと電力制限で開発された、ハードウェア最適化された新しいブロック暗号アルゴリズムを提供します。同時に、データの漏えいを避けようとしました。これを達成するために、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><abbr title="データ暗号化標準-対称暗号化のアルゴリズム"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DESの</font></font></abbr></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">経験</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">活用し</font><font style="vertical-align: inherit;">、プロパティを補足しました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><abbr title="AESコンテストのファイナリストアルゴリズム"><font style="vertical-align: inherit;"></font></abbr></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハードウェアで驚くべきパフォーマンスを示した</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><abbr title="AESコンテストのファイナリストアルゴリズム"><font style="vertical-align: inherit;">蛇</font></abbr></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、新しいブロック暗号を開発することにした理由を説明する価値があります。一般的に認められている事実は、ストリーム暗号は潜在的にコンパクトであることです。実際、最初に、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eSTREAM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトでの作業の過程でコンパクトストリーム暗号の設計を理解する努力をしました。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">また</font></a><font style="vertical-align: inherit;">、他のいくつかの有望な仮定が即効性があるように見えます。しかし、それでもブロック暗号を選択したいくつかの理由に気づきました。まず、ブロック暗号化は普遍的で原始的であり、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">暗号化モードで</font></a><font style="vertical-align: inherit;">使用した場合</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、つまりすでに暗号化されたブロックを使用して以下を暗号化すると、ストリーミング暗号化が得られます。第二に、おそらく、主に、ブロック暗号の動作原理の複雑さは、ストリーム暗号化アルゴリズムの動作原理よりもよく研究されているようです。たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形フィードバックを備えたシフトレジスタ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の使用に基づく広範な理論がありますが、</font><font style="vertical-align: inherit;">これらのブロックを安全なオファーを提供するような方法で組み合わせるのは簡単ではありません。きちんと設計されたブロック暗号は、新しく作成されたストリーム暗号よりも安全であると想定しています。したがって、コンパクトストリーム暗号と同じくらい多くの鉄のリソースを必要とするブロック暗号は非常に興味深いものであることがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に目を引くパフォーマンスで新しいブロック暗号アルゴリズムを作成する場合、私たちは革新を追求するだけではないことに注意することが重要です。逆に、暗号の開発と実装は密接に関係しており、いくつかの基本的な制限と固有の制限が明らかになっています。たとえば、特定のレベルのセキュリティでは、キーとブロックの最小長に制限が課されます。 80ビットのキーで64ビットの状態を処理する場合でも、最小デバイスサイズが制限されます。また、ハードウェアでの実施-特にハードウェア実装のコンパクトさ-が再現性に貢献していることにも気づくでしょう。小さな変更でもデバイスのボリュームに悪影響を与える可能性があります。ただし、暗号解読者は再現性も重視し、多くのラウンドで簡単に増加する数学的な構造を探します。では、システムのセキュリティを損なうことなく、いくつの単純な繰り返し構造を使用できるのでしょうか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、この記事ではコンパクトブロック暗号PRESENTについて説明します。</font><font style="vertical-align: inherit;">既存の文献を少し見直した後、残りの記事を標準形式で設計しました。</font><font style="vertical-align: inherit;">コードはセクション3で説明され、セクション4では設計上の決定事項が説明されています。</font><font style="vertical-align: inherit;">セクション5ではセキュリティについて検討し、セクション6ではパフォーマンスの詳細な分析を行います。</font><font style="vertical-align: inherit;">この仕事は私たちの結論で終わります。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.既存の作品</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
安価な暗号に専念する仕事の量は常に増加していますが、超軽量暗号に専念する記事の数は驚くほど少ないです。プロトコルデバイスに焦点を移し、安価な通信および識別プロトコルに関する作業については触れません。コンパクトな実装に関する最も広範な作業の1つは、現在eSTREAMプロジェクトに関連しています。このプロジェクトの一部として、ハードウェアでの効果的な実装に適合した新しいストリーム暗号が提案されました。この作業の過程で、有望な候補者が概説されます。これまでの比率は概算ですが、実装パンフレットから、eSTREAMプロジェクトのコンパクトな暗号には約1300〜2600 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GE（ゲート相当）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が必要であることがわかり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロック暗号のうち、広く知られているものの1つであるDESは、機器の効率を考慮して作成されました。 1970年代初頭の非常に限られた半導体の状態を考えると、DESが非常に競争力のある実装特性を備えていることは驚くに値しません。開発中、3000GEはDESに費やされ、シリアル化後</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この数は2300GEに減少しました。ただし、DES鍵の長さは、多くのアプリケーションでその有用性を制限し、たとえば、暗号強度の向上や鍵の拡張など、それに基づいて特殊な変更が行われるという事実につながります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最新のブロック暗号に関して、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は低コストの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">AESを</font></a><font style="vertical-align: inherit;">徹底的に分析します</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、その実装には約3,600 GEが必要です。これは、8ビットおよび32ビットプロセッサの罰金の設計の間接的な結果です。</font><font style="vertical-align: inherit;">システム要件&lt;a href = " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TEAは</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不明ですが、概算では約2100 GEが必要です。低コストの機器用に設計されたソリューションが4つあります：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mCRYPTON</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2949 GEを正確に実行）、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HIGHT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（約3000 GE）、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（約2280 GE）およびCGEN（これも約2280 GE）。後者はブロック暗号として考えられていなかったという事実にもかかわらず。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.ブロック暗号PRESENT</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PRESENTは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPネットワークの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特別なケースで、</font><font style="vertical-align: inherit;">31ラウンドで構成されています。ブロック長は64ビットで、鍵は80ビットと128ビットの2つのバージョンでサポートされています。このレベルの保護は、タグに基づく展開に通常使用される低セキュリティアプリケーションに十分である必要があります。さらに重要なことに、PRESENTは設計機能においてeSTREAMプロジェクトのストリーム暗号とほぼ一致し、ハードウェアでの効果的な実装のためにシャープにされているため、適切に比較できます。彼ら。</font></font><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">128ビットバージョンのセキュリティ要件と運用プロパティは、元の記事の付録に記載されています。</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
31ラウンドのそれぞれは、1≤i≤32のキーK </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を入力するXOR演算で構成されます</font><font style="vertical-align: inherit;">。ここで、K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32は</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーの「ブリーチング」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、線形ビットごとの置換、および非線形置換レイヤー（または、より簡単には、暗号化の強度を高める）。非線形層は、個別の4ビット</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sブロックを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用し</font><font style="vertical-align: inherit;">、各ラウンドで16回並列に適用されます。擬似コードで記述された暗号を図に示し</font></font><br>
<br>
<img src="https://habrastorage.org/webt/39/jf/bc/39jfbcgtriqxlsbdkyojjycyc_a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これで、各ステージが順番に決定されます。設計の正当性についてはセクション4で説明します。ビットには、ブロックまたはワードの正しいビットから始めて、ゼロからどこでも番号が付けられます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラウンドキーを追加します（addRoundKey）。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラウンドキーK </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = k </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ここで1≤i≤32、および現在の状態b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。現在の状態にラウンド鍵を追加するモジュロ2発生（B用</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = B </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ⊕K </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、J</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ここで、0≤J≤63）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S-Boxレイヤー（sBoxlayer）。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRESENTで使用されるSブロックは、4ビットブロックを4ビットブロックにマッピングします。 16進数システムでのこのブロックのアクションを次の表に示します</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5d/dv/2a/5ddv2ahldslwpoziqdpth4a5dwe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。Sブロックレイヤーの場合、現在の状態b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は16個の4ビットワードw </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0で</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ここでw </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 * i + 3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ||です。 b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 * i + 2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> || b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 * i + 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> || b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 * i（</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0≤i≤15の場合）フレーム出力S [w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]更新された状態値を明白な方法で返します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">順列レイヤー（pLayer）。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次の表で定義されているPRESENTを使用したビットごとの置換（ビットiの状態は位置P（i）にシフトされます）：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/et/bh/ng/etbhngoueocjgcnf0hhswl-lobs.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">鍵変換（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">鍵スケジュール</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRESENTは80ビットと128ビットのキーを使用できますが、ここでは80ビットバージョンに焦点を当てます。ユーザーによって提供された鍵は、k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として表される鍵レジスターKに保管されます</font><font style="vertical-align: inherit;">。 i番目のラウンドでは、64ビットのラウンドキーK </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">62</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、レジスタKの現在の内容の左64ビットで構成されます。したがって、i番目のラウンドでは、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">62</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16となり</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ラウンドキーK </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iを</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アンパックした後</font><sub><font style="vertical-align: inherit;">、</font></sub><font style="vertical-align: inherit;">キーレジスタK = k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0は</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のように更新されます</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。1. [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] = [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">77</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">76</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] = S [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">79</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">77</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">76</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] = [k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]⊕round_counter </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、レジスタキーは61桁左にシフトされ、左端の4つのビットはSブロックを通過し、round_counter iの値は2を法としてビットk </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k </font><sub><font style="vertical-align: inherit;">15で</font></sub><font style="vertical-align: inherit;">加算されます。</font></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kから、round_counterから右への最下位ビット。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/jl/5d/o1/jl5do1gwvqcgmezpu_id0cdsxhi.png"><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">128ビットアルゴリズムのキー変換は、元の記事の付録にあります。</font></font></em><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. PRESENTのデザイン機能</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セキュリティと効率的な実装に加えて、PRESENTの主な成果はそのシンプルさです。</font><font style="vertical-align: inherit;">したがって、同様のプロジェクトが他の状況で採用され、学生の教科書としてさえ使用されたのは当然のことです。</font><font style="vertical-align: inherit;">このセクションでは、PRESENTの設計時に行った決定を正当化します。</font><font style="vertical-align: inherit;">ただし、最初に、予想されるアプリケーション要件について説明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1。</font><font style="vertical-align: inherit;">目的とアプリケーション環境</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
厳しく制約された環境で適用可能なブロック暗号を設計する場合、多くの状況で確実に適用できるブロック暗号を作成していないことを理解することが重要です-これにはAESがあります。</font><font style="vertical-align: inherit;">逆に、AESが適していない非常に特定のアプリケーションを対象としています。</font><font style="vertical-align: inherit;">上記は、次の特性を決定します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 暗号は「ハードウェアで」実装されます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションは、セキュリティレベルを調整するためにのみ必要です。</font><font style="vertical-align: inherit;">したがって、80ビットのキーは堅牢なソリューションになります。</font><font style="vertical-align: inherit;">eSTREAMプロジェクトのストリーム暗号の開発者も同じ立場に固執することに注意してください。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションは、大量のデータの暗号化を必要としません。</font><font style="vertical-align: inherit;">したがって、あまり変更を加えることなく、パフォーマンスやスペースを最適化できます。</font></font></li>
<li>     ,      .   ,       (       ).</li>
<li>      ,  ,         , , ,      .</li>
<li>  ,      ,        (encryption-only mode).  ,      - (challenge-response)  , ,    ,          ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"> </a>.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような考慮事項に基づいて、PRESENTを80ビットのキーを持つ64ビットのブロック暗号として作成することにしました。この場合、暗号化と復号化の物理要件はほぼ同じです。暗号化と復号化の両方をサポートする機能により、PRESENTはAES暗号化のみをサポートするよりもコンパクトになります。暗号化のみの実行の場合、暗号は完全に超簡単です。暗号化</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブキー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、外出先で計算されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文献には多くの例があり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、時間、日付とメモリの間の妥協の攻撃</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用して、または攻撃</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">誕生日の</font></a><font style="vertical-align: inherit;">パラドックスは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大量のデータを暗号化する場合。</font><font style="vertical-align: inherit;">ただし、これらの攻撃は暗号のパラメータにのみ依存し、内部構造を使用しません。</font><font style="vertical-align: inherit;">私たちの目標は、これらの攻撃を私たちに対して使用できる最高のものにすることです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サードパーティのチャネル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">攻撃と直接的なチップ破壊攻撃は、他の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暗号プリミティブ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と同じくらい現在を脅かしてい</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">ただし、可能性のあるアプリケーションの場合、セキュリティ要件が中程度であるため、実際の攻撃者にとってのメリットは非常に限られています。</font><font style="vertical-align: inherit;">リスク評価では、このような脅威は重要な要素として認識されていません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2。</font><font style="vertical-align: inherit;">順列層</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーミキシングレイヤーを選択する場合、ハードウェアの効率に注意を向けるには、最小限の数の制御要素（たとえば、トランジスター）で実装できる線形レイヤーが必要です。</font><font style="vertical-align: inherit;">これはビットごとの順列につながります。</font><font style="vertical-align: inherit;">単純さに注意して、透過的なセキュリティ分析を行うのに役立つ通常のビット単位の置換を選択しました（セクション5を参照）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3。</font><font style="vertical-align: inherit;">Sブロック。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PRESENTでは、4ビットを4ビットに変換する個別のSブロックを使用します（F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> →F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。これは、ハードウェア効率に対する私たちの要望の直接的な結果であり、そのようなSブロックの実装は、通常、8ビットSブロックの実装よりもはるかにコンパクトです。線形拡散層にはビットマップ順列を使用するため、AESのような拡散技術は暗号化のオプションではありません。したがって、いわゆる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「雪崩効果」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を低減するために、Sブロックにいくつかの条件を追加します</font><font style="vertical-align: inherit;">。より正確には、本のためのSブロックは、我々はによってフーリエ係数Sを表し、以下の条件、満足</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wの</font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）=Σ（-1）</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;B、S（X）&gt; + &lt;、X&gt;</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、x∈F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
いずれかの固定された非ゼロ入力バイアスΔ1. </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ∈F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">及び任意の固定された非ゼロ入力バイアスΔ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ∈F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> S-ブロック内、我々は必要</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
＃{X∈F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> S（X）+ S（X +Δ| </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）=Δ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> }≤4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
任意の固定非ゼロの入力差分2.Δ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ∈F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">及び任意の固定された非ゼロ出力差Δ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ∈F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ように重量（Δ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）=質量（Δ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）= 1 、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{x∈F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">| S（x）+ S（x + ∆ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）= ∆ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> } =∅3 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.すべての非ゼロa∈F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">およびすべての非ゼロb∈F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4について</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、| S </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（a）| </font><font style="vertical-align: inherit;">≤8 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.すべての非ゼロa∈F </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">およびすべての非ゼロb∈F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について、wt（a）= wt（b）= 1、S </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W </font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（a）=±4 </font><font style="vertical-align: inherit;">が成り立つ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セクション5から明らかなように、これらの条件により、PRESENTは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">差別的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">線形の攻撃に</font></a><font style="vertical-align: inherit;">耐性があり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます。</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">上記の条件を満たすすべての4ビットSブロックの分類を使用して、効率的なハードウェア実装に特に適したSブロックを選択しました。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.セキュリティ分析</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、現在のセキュリティ分析の結果を示します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">微分および線形暗号解読</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
微分および線形暗号解読は、暗号解読者が利用できる最も強力な方法の一部です。</font><font style="vertical-align: inherit;">PRESENTの微分および線形解読に対する耐性を測定するために、微分（または線形）特性に関与するいわゆるアクティブSブロックの数に下限を設定します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">差分解読</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
差分暗号解読の場合は、次の定理でカバーされます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定理1. </font></font></b> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PRESENTの5回路差動特性には、少なくとも10個のアクティブSブロックがあります。</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定理1は、元の記事の付録3で証明されており、観察を続けます。</font><font style="vertical-align: inherit;">16個のSブロックを4つのグループに分割</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cu/vb/xb/cuvbxb5bl5psjid8dpwqxjwpkiq.png"><br>
<br>
<sub><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">します。入力（上）の数字は、前のステップのSブロックの数を示し、出力（下部）の-次のSブロックの数を示します</font></font></em></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sブロックへの入力ビットは、同じグループの4つの異なるSブロックからのものです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4つのsブロックのグループの入力ビットは、16の異なるsブロックからのものです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のSブロックからの4つの出力ビットは、4つの異なるSブロックに含まれ、それぞれが次のラウンドのSブロックの個別のグループに属します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なるグループのsブロックの出力ビットは、異なるsブロックに送られます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定理1によると、25ラウンドを超えるPRESENTの微分特性には、少なくとも5×10 = 50のアクティブなSブロックが必要です。 PRESENT Sブロックの最大微分確率は2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であるため、単一の25ラウンド微分特性の確率は2 </font><sup><font style="vertical-align: inherit;">-100に</font></sup><font style="vertical-align: inherit;">制限されます。</font></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">高度な方法により、暗号分析者はより短い特性を使用するために暗号から外部ラウンドを削除できます。ただし、攻撃者が暗号から6ラウンドを削除することを許可したとしても、これは前例のない状況ですが、残りの25ラウンドの差分特性を使用するために必要なデータは、利用可能な量を超えます。</font><font style="vertical-align: inherit;">したがって、セキュリティの境界は信頼できる以上のものです。</font><font style="vertical-align: inherit;">ただし、定理1のアクティブなSブロックの数の境界は厳しいことを実際に確認しています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実用的な確認</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5回のラウンドで10個のSブロックを含む特性を定義できます。次の2ラウンドの反復特性には、ラウンドごとに2つのSブロックが含まれ</font><font style="vertical-align: inherit;">、5ラウンド</font><font style="vertical-align: inherit;">で</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2〜25の</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">確率で保持され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より複雑な特性は</font><font style="vertical-align: inherit;">、5ラウンド</font><font style="vertical-align: inherit;">で2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-21の</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">確率で保持され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この2番目の特性の確率は2 </font><sup><font style="vertical-align: inherit;">-20の</font></sup><font style="vertical-align: inherit;">境界に非常に近いですが</font></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは反復的ではなく、実用的な価値はほとんどありません。</font><font style="vertical-align: inherit;">代わりに、2ラウンドの反復微分の可能性を実験的に確認しました。</font><font style="vertical-align: inherit;">223の選択された平文のペアを使用して100を超える独立したサブキーを使用した実験では、観測された確率が予測されました。</font><font style="vertical-align: inherit;">これは、この特定の特性について、付随する有意差がないことを示唆しているようです。</font><font style="vertical-align: inherit;">ただし、予備的な分析が推奨されていたとしても、差異の影響の程度を特定することは複雑で時間のかかる作業です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形暗号解読</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
線形PRESENT暗号解読のケースは、次の定理で考慮されます。ここでは、PRESENTの4つのラウンドに対する最良の線形近似を分析します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定理2.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4R</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を、PRESENTを使用した4ラウンド近似の最大線形変位とします。そして、E </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4R</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ≤2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定理の証明は、元の記事の付録4に含まれています。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、28ラウンドの最大変位は</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×E </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4R </font></font></sub><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ×（2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-43になります。</font></font></sup><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、暗号解析者がPRESENTの31ラウンドのうち約28ラウンドだけで鍵復旧攻撃を開始すると仮定すると、暗号の線形暗号解析には約2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">84の</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">既知の平文/暗号文</font><font style="vertical-align: inherit;">が必要になります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このようなデータ要件は、利用可能なテキストを超えています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかの高度な差分/線形攻撃</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PRESENT構造により、いくつかの際立った形式の攻撃を検討できます。しかし、それらのいずれも、線形暗号解読のテキスト要件の下限よりも少ないテキストを必要とする攻撃をもたらしませんでした。区別された攻撃の中で、対称的な違いが拡散層全体で1（つまり常に）の確率で持続するため、パリンドロームの違いを使用する攻撃と、いくつかの高度なバージョンの微分線形攻撃を検討しました。攻撃はいくつかのラウンドで有望であるように見えましたが、それらはすぐに実際的な価値を失い、現在の暗号解析に役立つ可能性はほとんどありません。また、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">切り捨てられた差分解読法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、次の2つのラウンドでは価値が限られている可能性が高い</font><font style="vertical-align: inherit;">こともわかりました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
切り捨てられた展開は、1の確率で実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに特定された微分特性の長さを短縮するために使用された場合でも、データ要件は過剰のままです。</font><font style="vertical-align: inherit;">ランク展開は、1の確率で実行されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2。</font><font style="vertical-align: inherit;">構造攻撃</font></font></h3><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">統合された暗号解読</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">やボトルネック分析</font><font style="vertical-align: inherit;">
などの構造攻撃は、</font><font style="vertical-align: inherit;">AESのような暗号の分析に適しています。</font><font style="vertical-align: inherit;">このような暗号は、通常はバイトである、単語のような強力な構造を持っています。ただし、プレゼンテーションのデザインはほとんどビット単位であり、順列操作はある程度規則的ですが、暗号で使用されるビット単位の操作によってワード構造の開発と配布が中断されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3。</font><font style="vertical-align: inherit;">代数的攻撃</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代数的攻撃は</font><font style="vertical-align: inherit;">、ブロックするためではなく、ストリーム暗号に適用した場合の成功率</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下げる</font><font style="vertical-align: inherit;">ために使用さ</font><b><font style="vertical-align: inherit;">れ</font></b><font style="vertical-align: inherit;">ました。ただし、PRESENTの単純な構造は、真剣な研究に値することを意味します。 PRESENT Sブロックは、フィールドG（2）上の8つの入力/出力ビット変数に対する21の二次方程式によって記述されます。これは驚くべきことではありません。これは、4ビットのSブロックは少なくとも21個のそのような方程式で記述できることがよく知られているためです。次に、暗号全体は、変数v = n×8の2次方程式e = n×21で記述できます。ここで、nは暗号化およびキー変換アルゴリズムのSブロックの数です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PRESENTの場合、n =（31×16）+ 31となるため、システム全体は4,216変数の11,0​​67二次方程式で構成されます。多次元二次方程式のシステムを解く一般的な問題はNP困難です。ただし、ブロック暗号で得られるシステムは、単純な線形層で接続されたn個の小さなシステムで構成されるため、非常にまれです。ただし、このことをいわゆる代数的攻撃に利用できるかどうかは明らかではない。 XLやXSLなど、いくつかの特殊な方法が提案されていますが、両方の方法で欠点が発見されています。代わりに、ブロック暗号の代数暗号解読に関する唯一の実用的な結果は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buchberger</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">F4</font></a><font style="vertical-align: inherit;">アルゴリズムを適用することによって得られました。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マグマの一部として。小規模バージョンのAESでのモデリングでは、最小の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPネットワーク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を除くすべてについて</font><font style="vertical-align: inherit;">、時間とメモリの複雑さの両方ですぐに問題が発生することがわかりました。 PRESENTも同様です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実用的な確認。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マグマ社のF4アルゴリズムを使用して、小規模バージョンのシミュレーションを行いました。</font><font style="vertical-align: inherit;">Sブロックが1つ、つまりサイズが4ビットの非常に小さいブロックである場合、マグマは、得られた連立方程式を多くのラウンドで解くことができます。</font><font style="vertical-align: inherit;">ただし、ブロックサイズが大きくなり、Sブロックが追加され、それに対応する線形拡散層のバリアントが追加されると、方程式系がすぐに大きくなりすぎます。</font><font style="vertical-align: inherit;">7つのSブロックで構成されるシステム、つまりブロックサイズが28ビットのシステムを検討した場合でも、妥当な時間内に、2ラウンドを通過した短縮暗号バージョンのソリューションを得ることができませんでした。</font><font style="vertical-align: inherit;">私たちの分析は、代数的攻撃がPRESENTに脅威をもたらす可能性は低いことを示しています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.4。</font><font style="vertical-align: inherit;">キー変換攻撃</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主要な変革の開発に関する確立されたガイドラインがないため、多種多様なプロジェクトと、プロジェクトの特性に基づく多種多様な攻撃の両方があります。</font><font style="vertical-align: inherit;">最も効果的な攻撃は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、関連するキー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">への</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">攻撃</font></a><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シャーアタック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の一般的な見出しに該当し、</font><font style="vertical-align: inherit;">どちらも、サブキーの異なるセット間の識別可能な関係の構築に基づいています。</font><font style="vertical-align: inherit;">この脅威に対抗するために、サブキーセットを簡単に「シフト」できないようにラウンド依存のカウンターを使用し、非線形操作を使用してキーレジスタKの内容を混合します。特に：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーレジスタのすべてのビットは、21を丸めるためにユーザーが指定した80ビットキーの非線形関数です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラウンド21以降のキーレジスタの各ビットは、少なくとも4つのユーザー指定のキービットに依存します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を取得するまでに</font><font style="vertical-align: inherit;">、6ビットは80のユーザー指定のキービットのうち2次の式であり、24ビットは3次であり、残りのビットは6次または9次のユーザー指定のキービットの関数です。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの特性は、キー変換に基づくキー攻撃に耐えるのに十分であると信じています。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.「鉄」の生産性</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PRESENT-80を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VHDLに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font><font style="vertical-align: inherit;">し、UMC L180 0.18μ1P6Mロジックに基づく標準の仮想シリコンセルライブラリ（VST）に適合させました。シミュレーションにはMentor Graphics Modelsim SE PLUS 5.8 cを使用し、消費電力の合成とモデリングにはSynopsys Design Compilerversion Y-2006.06を使用しました。鋳造所の典型的な値が使用され（コア電圧は1.8ボルト、温度は25°C）、提案されたワイヤー負荷のモデルが電力のモデル化に使用されました。このようなシミュレーションは約10,000 GEの構造物を対象としているため、電力結果ははるかに小さい構造物に対して悲観的になることに注意してください。画像上</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tt/8i/bg/tt8ibga5aprmwzqrrckekekzv2a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
示されているデータパスはスペース最適化されたPRESENT-80で、復号化の可能性なし（暗号化のみ）であり、サイクルごとに1ラウンドを実行します。つまり、データパスは64ビット幅です。現在の設計段階では、16個の異なるSブロックではなく、同じSブロックを16回使用することに注意してください。これにより、プロジェクトのシリアル化がさらに容易になります。つまり、4ビットのデータチャネルを使用できます。私たちの実装では、80ビットの鍵で64ビットの平文を暗号化するために32クロックサイクルが必要で、1570 GEを要し、変調で5 micWの電力消費があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ek/7o/xq/ek7oxqtiawboi4wjqqrivgxvzmy.png"><br>
<br>
<em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空間要件PRESENT</font></font></sup></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
領域のほとんどは、キーとデータの状態を保存するためのトリガーで占められており、その後にSレイヤーとXORキーイング部門が続きます。</font><font style="vertical-align: inherit;">単純な順列ビット順列は、実装が配置配線の段階に達したときにのみ領域を増やします。</font><font style="vertical-align: inherit;">実装の主な目的は少量のハードウェアでしたが、電力用に最適化されたプロセスも合成したことに注意してください。</font><font style="vertical-align: inherit;">53 GEを追加すると、エネルギー消費量はわずか3.3μWになり、現在の128は推定1886 GEを占有します。</font><font style="vertical-align: inherit;">非常に小さいサイズに加えて、PRESENTはかなり高いスループットを持ち、ビットあたりのエネルギーが優れています。</font><font style="vertical-align: inherit;">他の暗号との比較を表に示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m9/yt/7j/m9yt7jonvvcpkjnluz273z1ksga.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.まとめ</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、新しいPRESENTブロック暗号について説明しました。</font><font style="vertical-align: inherit;">私たちの目標は、64ビットブロックと80ビットキーのサイズに見合ったレベルのセキュリティを提供する超軽量暗号でした。</font><font style="vertical-align: inherit;">その結果、PRESENTには、多くのコンパクトストリーム暗号と同様の実装要件があります。</font><font style="vertical-align: inherit;">したがって、私たちはそれが理論的および実用的な関心の両方であると信じています。</font><font style="vertical-align: inherit;">すべての新しい提案と同様に、PRESENTをすぐに展開することはお勧めしませんが、その分析を要請します。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">告白</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この文書で紹介されている作業は、研究開発のためのEUフレームワークプログラム（www.ist-ubisecsens.org）のSTREP UbiSec＆Sensを通じて、欧州委員会によって部分的にサポートされていました。</font><font style="vertical-align: inherit;">この文書に含まれる意見と結論は著者のものであり、UbiSec＆Sensプロジェクトまたは欧州委員会によって表明または承認された公式のポリシーまたは承認を構成するものとして解釈されるべきではありません。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja487524/index.html">ハードウェアスタートアップハッカソンが必要な理由</a></li>
<li><a href="../ja487528/index.html">Изменения в пользовательском соглашении и политике конфиденциальности на сервисах Хабра</a></li>
<li><a href="../ja487534/index.html">etcd 3.4.3：ストレージの信頼性とセキュリティの研究</a></li>
<li><a href="../ja487538/index.html">.NET Interactiveが登場！| .NETノートブックプレビュー2</a></li>
<li><a href="../ja487540/index.html">HighLoad ++、Anastasia Tsymbalyuk、Stanislav Tselovalnikov（Sberbank）：MDAになった経緯</a></li>
<li><a href="../ja487544/index.html">.NETドキュメント：1月の新機能</a></li>
<li><a href="../ja487548/index.html">新しい実験：gRPC-Webを使用してブラウザーから.NET gRPCサービスを呼び出す</a></li>
<li><a href="../ja487550/index.html">Pythonの3D画像（ほぼ）通常のパフォーマンス</a></li>
<li><a href="../ja487552/index.html">Swift 5.2-新機能</a></li>
<li><a href="../ja487556/index.html">OpenStreetMap No. 497の世界からのニュース（2020年1月21日〜2020年2月27日）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>