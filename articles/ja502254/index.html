<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐙 👵🏼 🥐 PostgreSQL：人間の言語でのサーバー側プログラミング（PL / Perl、PL / Python、PL / v8） 🧓🏿 🕴🏿 🕜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Postgresはその拡張性で知られており、手続き型言語（PL）のサポートにも適用されます。この長さの言語のリストを使用して言語を自慢することはできません。このリストはまったく制限されない可能性があります。言語をサーバーに接続するために、追加の作業は必要ありません。独自の言語を考え出し、それをサーバ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL：人間の言語でのサーバー側プログラミング（PL / Perl、PL / Python、PL / v8）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/502254/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Postgresはその拡張性で知られており、手続き型言語（PL）のサポートにも適用されます。</font><font style="vertical-align: inherit;">この長さの言語のリストを</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用し</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て</font><s><font style="vertical-align: inherit;">言語を</font></s><font style="vertical-align: inherit;">自慢することはできません。</font><font style="vertical-align: inherit;">このリストはまったく制限されない可能性があります。言語をサーバーに接続するために、追加の作業は必要ありません。独自の言語を考え出し、それをサーバープロシージャ言語にすることもできます。 DBMSの変更ではこれは必要ありません。さらに多くのように、この拡張性は当初からPostgresアーキテクチャに組み込まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクのためにPL言語を書くことは可能であり、時には必要です。さらに良いのは、誰かが言語を書くためのフレームワークを書いて、Cで書くのではなく、言語開発者にとってより快適な言語を選択できるようにすることです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pythonで記述できる</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FDWと同様</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PgConf.Russia 2019</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PgConf.Russia 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DevConf 2017の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会議で著者が作成した、このトピックに関する多数のレポートとマスタークラスに基づいて作成されました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはエキゾチックではなく、最も一般的な手続き型言語PL / Perl、PL / PythonおよびPL / V8（つまりJavaScript）について、それらの機能をPL / pgSQLと比較します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの言語はいつ使用する価値がありますか？</font><font style="vertical-align: inherit;">SQLとPL / pgSQLはいつ不足していますか？</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、複雑な構造やアルゴリズムで作業する必要がある場合：たとえばツリーの走査、またはHTMLまたはXMLの解析が必要な場合、特にアーカイブからそれらを抽出する場合。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複雑なSQL（レポート、ORM）を動的に生成する必要がある場合。</font><font style="vertical-align: inherit;">PL / pgSQLでは不便なだけでなく、場合によっては動作が遅くなることもあります。</font></font></li>
<li>         Perl  Python,        C/C++,      Perl  Python    .         . ,    Oracle.     ,    Postgres   .    Perl  Python  .</li>
<li>   —    .   , ,   untrusted- (  — . ),    Perlu  Python(3)u,    PL/V8.   Postgres  ,     ,   FDW,    ,         .       .  !</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そしてもう1つ：Cで何かを作成する場合は、迅速な開発により適したこれらの言語でプロトタイプを作成できます。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Postgresに言語を埋め込む方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要な言語を実装するには、Cで1つから3つの関数を記述します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HANDLER-言語で関数を実行する呼び出しハンドラ（これは必須の部分です）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INLINE-匿名ブロックハンドラー（言語で匿名ブロックをサポートする場合）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VALIDATOR-関数の作成時のコード検証関数（この検証を実行する場合）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメントで詳細に説明されてい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「すぐに使える言語」と他の言語</font></font></h3><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Tclの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
「そのまま」でサポートされている言語は4つだけ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">です</font></a><font style="vertical-align: inherit;">が、くすぐりはむしろ歴史への賛辞です。今ではほとんど使われていないので、これ以上は触れません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Perl、PL / Python、そしてもちろん、PL / pgSQLはPostgresコミュニティによってサポートされています。他の非ボックス言語のサポートは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メンテナー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（企業、コミュニティ、またはDBMS内で言語を機能させることに関心のある特定の開発者）にかかっています。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はGoogleを宣伝しています。しかし時々</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理由があります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8の雲一つない未来を疑います。 Googleの現在のPL / V8プロジェクトメンテナーであるJerry Sievertは、異なるエンジン（QuickJSなど）に基づくpostgresサーバーベースのJSサポートを検討しています。PL/ V8は構築が難しく、3〜5 GBが必要です。ビルド時にLinuxであらゆる種類のものを使用しているため、さまざまなOSで問題が発生することがよくあります。しかし、PL / V8は広く使用され、徹底的にテストされています。 PL / JSが別のJSエンジンの代替として、または今のところ、移行期間中に慣れている名前として表示される可能性があります。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Java</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はめったに使用されません。 PL / PerlとPL / V8にはほとんどすべてのタスクに十分な機能があるので、私は個人的にPL / Javaで書く必要はありませんでした。 Pythonでさえ、特に機能を追加していません。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / R</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">統計が好きでこの言語が好きな人に便利です。ここでも彼については触れません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人気のある言語は、ストレージの書き込みで必ずしも人気があるわけではありません：PL / PHPがありますが、実際には誰もサポートしていません-サーバープロシージャを記述したい人はほとんどいません。 PL / Ruby言語の場合、画像は何とか同じですが、言語はより近代的であるようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goベースの手続き型言語が開発されています</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。PL/ Go</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Luaを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ご覧ください</font><font style="vertical-align: inherit;">。それらを研究する必要があります。シェルの頑固なファンには、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Sh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さえあり</font><font style="vertical-align: inherit;">、それが何のためにあるのかさえ想像するのは難しいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少なくとも1つのドメイン固有の手続き型言語（DSL）があり、そのタスクに特化しています</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-PL /プロキシ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、これはサーバーの負荷のプロキシとバランスをとるために非常に人気がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、主に最もよく使用される言語について説明します。もちろん、これはPL / PgSQL、PL / Perl、PL / PythonおよびPL / V8 </font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">以下では</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼びます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「箱から出して」という言語は、ほとんど文字通り箱から出してインストールされます-通常、インストールは簡単です。しかし、PL / V8をインストールするには、OSのリポジトリで必要なバージョンのパッケージが見つからなかった場合、これはほとんど偉業です。これを行うには、V8全体、つまりChromiumを実際にビルドする必要があるためです。同時に、開発インフラストラクチャ全体がV8自体と一緒にgoogle.comからダウンロードされます-数ギガバイトのトラフィックを期待してください。 UbuntuでのPostgres 11の場合、PL / V8パッケージはまだ登場しておらず、これまでのところリポジトリにはPG 10用のV8しかありません。また、リポジトリにあるバージョンがかなり古い可能性が高いことも重要です。記事の公開時の最新バージョンは2.3.14です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語自体をインストールしたら、言語を「作成」する必要があります。システムディレクトリに登録してください。</font><font style="vertical-align: inherit;">これはチームが行う必要があります。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> plperl;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（plperlの代わりに、別の言語の名前で置き換えることができます。特定のニュアンスがあります。以下を参照してください）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何が起こったかを見てみましょう。</font></font><br>
<br>
<pre><code class="plaintext hljs">test_langs=# \x<font></font>
test_langs=# \dL+<font></font>
List of languages<font></font>
-[ RECORD 1 ]-----+---------------------------------<font></font>
Name              | plperl<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plperl_call_handler()<font></font>
Validator         | plperl_validator(oid)<font></font>
Inline handler    | plperl_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       | PL/Perl procedural language<font></font>
-[ RECORD 2 ]-----+---------------------------------<font></font>
Name              | plpgsql<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plpgsql_call_handler()<font></font>
Validator         | plpgsql_validator(oid)<font></font>
Inline handler    | plpgsql_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       | PL/pgSQL procedural language<font></font>
[ RECORD 3 ]-----+---------------------------------<font></font>
Name              | plv8<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plv8_call_handler()<font></font>
Validator         | plv8_call_validator(oid)<font></font>
Inline handler    | plv8_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       |</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / pgSQLは特別に作成する必要はなく、常にデータベースにすでに存在しています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQLをSQLと混同しないでください。</font><font style="vertical-align: inherit;">これは別の言語です。</font><font style="vertical-align: inherit;">ただし、PostgresはプレーンSQLで関数を記述することもできます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">規格</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DBMSの世界では、SQL標準への準拠についてよく話します。</font><font style="vertical-align: inherit;">手続き型言語にも標準がありますが、あまり話題にされていません。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL / PSM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準</font><font style="vertical-align: inherit;">は、DB2手続き言語に高度に準拠しています。</font><font style="vertical-align: inherit;">概念的には近いですが、その実装はPL / pgSQLにはほど遠いです。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL / JRT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はJavaプロシージャの標準であり、PL / Javaが最適です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信頼できる言語と信頼できない言語</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postgresの手続き型言語は信頼できる（信頼できる）と信頼できない（信頼できない）です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
信頼できる言語では、ネットワークを含むI / Oを直接操作する可能性はなく、実際にシステムリソースを使用する可能性もありません。したがって、そのような関数は任意のデータベースユーザーが作成でき、何かを台無しにし、彼はあまり学習することができなくなります。信頼できない言語の関数は、監督者のみが作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語インタープリターがこのような制限をサポートしている場合、それを使用して、信頼できる言語と信頼できない言語の両方を作成できます。したがって、Perlでは、さまざまな言語</font></font><code>plperl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とがあり</font></font><code>plperlu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。手紙</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後に、言語の信頼されていない文字を出力します。</font><font style="vertical-align: inherit;">Pythonは、信頼できないバージョンにのみ存在します。</font><font style="vertical-align: inherit;">PL / v8-逆に、信頼されている場合のみ。</font><font style="vertical-align: inherit;">その結果、PL / v8は、データベースからのみ、ディスクからモジュールまたはライブラリをロードできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UNTRUSTED言語の関数は、電子メールの送信、サイトへのping、外部データベースへのログイン、HTTP要求の実行など、何でも実行できます。</font><font style="vertical-align: inherit;">信頼できる言語は、データベースからのデータの処理に限定されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TRUSTEDには以下が含まれます</font></font><code>plpgsql, plperl, plv8, pljava</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UNTRUSTEDには以下が含まれます</font></font><code>plperlu, pljavau, plpython2u, plpython3u</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意：TRUSTEDのようなPL / Pythonはなく（リソースへのアクセスに制限を設定できないため）、PLpgSQLとPL / V8はその逆です。これらはUNTRUSTEDではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、PerlとJavaは両方のバージョンで使用できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQLとPL / *</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / pgSQLコードは、Postgresが持つすべてのデータ型でネイティブに動作します。他の言語には多くのPostgresタイプがないため、言語インタープリターがデータを言語の内部表現に変換し、あいまいなタイプをテキストに置き換えます。しかし、彼はTRANSFORMの助けを借りて助けることができます。これについては、記事の最後の方で話します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / pgSQLでの関数呼び出しは、多くの場合より高価です。他の言語の関数は、システムカタログを見なくてもライブラリにアクセスできます。 PL / pgSQLはそのようには動作しません。 PL / pgSQLの一部のクエリは、多くの型がサポートされているという事実のために、長時間にわたって機能します。2つの整数を追加するには、インタープリターは、他のいくつかのエキゾチックな型ではなく、整数を処理していることを認識して、決定する必要があります。それらを折りたたむ方法、そしてその後のみ実際にそれらを折りたたみます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / pgSQLは信頼できるため、そこからネットワークとディスクを操作することはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネストされたデータ構造を操作する場合、PL / pgSQLにはJSONを操作するためのPostgresツールしかありません。これは他の言語では非常に面倒で非生産的です。ネストされた構造を操作する方がはるかに簡単で経済的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / *には独自のメモリ管理があり、メモリを監視するか、制限する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラー処理を注意深く監視する必要がありますが、これも誰にとっても異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、PL / *にはグローバルインタープリターコンテキストがあり、たとえば、クエリプランを含むデータのキャッシュに使用できます。</font><font style="vertical-align: inherit;">言語が信頼できない場合は、ネットワークとドライブを使用できます。</font><font style="vertical-align: inherit;">これらすべての言語は、原則としてSPIを介してデータベースと連携しますが、後で詳しく説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / *言語の機能を詳しく見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlインタープリターはメモリー内の多額のコードですが、幸い、接続が開かれたときに作成されるのではなく、最初のストアード・プロシージャー/関数PL / Perlが起動されたときにのみ作成されます。</font><font style="vertical-align: inherit;">初期化されると、Postgres構成パラメーターで指定されたコードが実行されます。</font><font style="vertical-align: inherit;">通常、モジュールがロードされ、事前計算が行われます。</font><font style="vertical-align: inherit;">
データベースの実行中に構成ファイルに追加した場合は、Postgresに構成を再度読み取らせます。</font><font style="vertical-align: inherit;">この記事の例では、モジュール</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用して</font><font style="vertical-align: inherit;">データ構造を視覚化します。</font><font style="vertical-align: inherit;">
TRUSTEDおよびUNTRUSTED Perlを個別に初期化するためのパラメーターと、もちろんパラメーターがあります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Perlでプログラミングする人は、それなし</font><font style="vertical-align: inherit;">では言語ではなく、1つの誤解があることを</font><font style="vertical-align: inherit;">知ってい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<code>plperl.on_init= 'use Data::Dumper;'<br>
plperl.on_plperl_init= ' ... '<br>
plperl.on_plperlu_init= ' ... '<br>
plperl.use_strict= on</code><br>
<br><font style="vertical-align: inherit;"></font><code>Data::Dumper</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>use_strict=on</code><font style="vertical-align: inherit;"></font><code>strict</code><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その中で、インタプリタは最初にアクセスされたときと同じ方法で作成されます。そして、ここではあなたが欲しいPythonをすぐに決めることが重要です：2番目か3番目か。ご存知のように、Pythonは2つの一般的なバージョン（Python 2とPython 3）で存在しますが、問題は、それらのso-shkiが1つのプロセスで連携しないことです。名前による競合があります。 1つのセッションでv2を操作してからv3を呼び出すと、Postgresがクラッシュし、サーバープロセス（バックエンド）の場合、これは致命的なエラーになります。別のバージョンにアクセスするには、別のセッションを開く必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlとは異なり、Pythonは初期化中に何をすべきかを指示できません。別の不便：シングルライナーは行うのに不便です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのPython関数では、静的</font></font><code>SD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とグローバルの</font><font style="vertical-align: inherit;">2つの辞書が定義されてい</font></font><code>GD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。グローバル</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は許可します</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのバックエンド内のすべての機能とデータを交換します。これは同時に魅力的で危険です。</font><font style="vertical-align: inherit;">各関数には静的辞書があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Pythonでは、サブトランザクションを作成できます。これについては以下で説明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
信頼できるだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
便利なことに、JSONデータは自動的にJS構造に変換されます。 PL / V8では、PL / Pythonと同様に、サブトランザクションを実行できます。単純化された関数呼び出し用のインターフェースがあります。これは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィンドウ関数を定義できる</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題の唯一の手続き型言語</font><font style="vertical-align: inherit;">です。彼らはそれら</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をPL / R</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">定義できること</font></a><font style="vertical-align: inherit;">を示唆してい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ますが</font></a><font style="vertical-align: inherit;">、この言語はこの記事の範囲外です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、PL / V8でのみ実行タイムアウトがあります。確かに、デフォルトではオンになっておらず、PL / V8を手動でビルドする場合は、アセンブリ中にオンになったことを伝える必要があります。構成パラメーターを使用して、関数呼び出しのタイムアウトを設定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / V8での初期化は面白そうです。信頼できるため、ディスクからライブラリを読み取ることができず、どこからでも何もロードできません。</font><font style="vertical-align: inherit;">彼は必要なものすべてを基地からしか取り出せません。</font><font style="vertical-align: inherit;">したがって、言語インタープリターの開始時に呼び出されるストアード初期化関数が定義されています。</font><font style="vertical-align: inherit;">関数名は、特別な構成パラメーターで指定されます。</font></font><br>
<br>
<pre><code class="pgsql hljs">plv8.start_proc=my_init # ( PL/V8-)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期化中に、グローバル変数と関数は、これらの値をthis変数の属性に割り当てることで作成できます。</font><font style="vertical-align: inherit;">たとえば、次のようになります。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> my_init()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span> <span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span> $$<span class="php">
     this.get_57 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">57</span>; }; <span class="hljs-comment">//   </span>
     this.pi_square = <span class="hljs-number">9.8696044</span>;  <span class="hljs-comment">//   </span>
$$</span>;
<span class="hljs-keyword">SET</span> plv8.start_proc = <span class="hljs-string">'my_init'</span>;
<span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, pi_square, get_57() );
$$</span>;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl対PL / Python対PL / V8の実際の比較</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"こんにちは世界"</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、3つの言語すべてでこの句の出力を使用して簡単な演習を実行してみましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そして、彼に何か他の役に立つことをさせてください、例えば、彼のバージョンを伝えます：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     elog(<span class="hljs-keyword">NOTICE</span>,"Hello World! $]");
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  Hello World!<font></font>
DO<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のPerl関数</font></font><code>warn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とを</font><font style="vertical-align: inherit;">使用することもでき</font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Pythonです</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。より正確にはPL / Python3u（untrusted）-明確さのため。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">import</span> sys
     plpy.<span class="hljs-keyword">notice</span>(<span class="hljs-string">'Hello World! '</span> , hint=" ", detail=sys.version_info)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
NOTICE:  Hello World! <font></font>
DETAIL:  sys.version_info(major=3, minor=6, micro=9, releaselevel='final', serial=0)<font></font>
HINT:   <font></font>
DO<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用できます</font></font><code>throw 'Errmsg'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Postgresメッセージから抽出できるものはたくさんあります。それらには、ヒント、詳細、行番号、およびその他の多くのパラメータが含まれています。</font><font style="vertical-align: inherit;">PL / Pythonでは、それらを渡すことができますが、検討中の他の言語ではできません：それらの手段はプレーンテキスト行でしか呪うことができません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Pythonでは、postgresの各ロギングレベルに独自の機能があります。通知、警告、デバッグ、ログ、情報、致命的です。</font><font style="vertical-align: inherit;">ERRORの場合はトランザクションが低下し、FATALの場合はバックエンド全体が低下しています。</font><font style="vertical-align: inherit;">幸いにも、問題はパニックに達しませんでした。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらで読む</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この言語では、Hello worldは真珠によく似ています。</font><font style="vertical-align: inherit;">を</font></font><code>exception</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用して</font><font style="vertical-align: inherit;">終了できます。</font></font><code>throw</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これもエラー処理になりますが、ツールはPythonほど高度ではありません。</font><font style="vertical-align: inherit;">あなたが書くなら</font></font><code>plv8.elog(ERROR)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ちなみに、効果は同じです。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, <span class="hljs-string">'Hello World!'</span>, plv8.<span class="hljs-keyword">version</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  Hello World! 2.3.14<font></font>
DO<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベースで作業する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ストアドプロシージャからデータベースを操作する方法を見てみましょう。 PostgresにはSPI（Server Programming Interface）があります。これは、すべての拡張機能の作成者が使用できるC関数のセットです。ほとんどすべてのPL言語はSPIのラッパーを提供しますが、言語ごとに少し異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cで記述されているがSPIを使用している関数は、PL / PgSQLや他の手続き型言語と比較して大幅な向上をもたらす可能性は低いです。ただし、SPIをバイパスし、仲介なしでデータを処理するC関数（たとえば</font></font><code>table_beginscan/heap_getnext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は、1桁速く動作します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / JavaもSPIを使用しています。ただし、データベースの操作は、JDBCおよびJDBC標準のスタイルで行われます。 PL / Javaのコードの作成者は、クライアントアプリケーションから作業しているかのようにすべてが発生しますが、JNI（Java Native Interface）はデータベースへの呼び出しを同じSPI関数に変換します。これは便利であり、この原則をPL / PerlおよびPL / Pythonに変換するための基本的な障害はありませんが、何らかの理由でこれが行われておらず、現在のところ計画には表示されていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、ご希望であれば、通常の方法でDBIまたは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Psycopgを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介して外国の拠点に行くこともできます</font><font style="vertical-align: inherit;">。データベースをローカル化することは可能ですが、それはなぜですか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全体的なトピック「ベースでのプロセスとクライアントでのプロセス」に触れず、すぐにデータに近い最大処理から（少なくともネットワーク経由で巨大なサンプルを駆動しないようにするために）続行した場合、サーバーに保存されている関数を使用するソリューションは当然。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンス</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：SPIにはある程度のオーバーヘッドがあり、関数内のSQLクエリは関数なしの場合よりも遅くなる可能性があることに注意してください。 13番目のpostgresには、</font><font style="vertical-align: inherit;">これらのコストを削減</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するKonstantin Knizhnikによるパッチが</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">含まれてい</font><font style="vertical-align: inherit;">ました。ただし、もちろん、ストアドファンクションでのクエリ結果の処理では、結果をクライアントに転送する必要がないため、パフォーマンスの点で有益です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：デバッグおよびテストされた一連の機能により、データベース構造がユーザーから分離され、SQLインジェクションやその他の悪用から保護されます。</font><font style="vertical-align: inherit;">それ以外の場合は、すべてのアプリケーション開発者にとって頭痛の種のままです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再利用：多数の複雑なアプリケーションがデータベースで機能する場合は、有用な関数を各アプリケーションに再度書き込むのではなく、サーバーに保存すると便利です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースからデータを取得する方法と形式</font></font></h3><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、すべてが単純明快です。</font><font style="vertical-align: inherit;">呼び出し</font></font><code>spi_exec_query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、処理された行数、ステータス、およびSQLクエリによって選択された行の配列を返します。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="ruby"> 
     warn Data::Dumper::Dumper(
          spi_exec_query(<span class="hljs-string">'SELECT 57 AS x'</span>)
     )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  $VAR1 = {<font></font>
          'rows' =&gt; [<font></font>
                    {<font></font>
                      'x' =&gt; '57'<font></font>
                    }<font></font>
                  ],<font></font>
          'processed' =&gt; 1,<font></font>
          'status' =&gt; 'SPI_OK_SELECT'<font></font>
        };<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pythonの、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここでは、クエリと、このような結果を見て何かが、関数は、データ構造体を返しますが、あなたはさまざまな方法で作業ができることを特別なオブジェクトはありません。</font><font style="vertical-align: inherit;">通常は配列のふりをするので、そこから文字列を抽出できます。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plpy.<span class="hljs-keyword">notice</span>(
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 AS x'</span>)
     )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  &lt;PLyResult status=5 nrows=1 rows=[{'x': 57}]&gt;<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、1行目を取得し、そこからXを取り出して、値（数値）を取得します。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plpy.<span class="hljs-keyword">notice</span>(
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 AS x'</span>)[<span class="hljs-number">0</span>][<span class="hljs-string">'x'</span>]
      )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  57<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, <span class="hljs-type">JSON</span>.stringify(
          plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 as x'</span>))
     );
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  [{"x":57}]<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造を確認するために、特にロードする必要のないライブラリ関数JSON.stringifyを使用しました。これは、デフォルトでPL / v8の一部としてすでに使用可能です。 </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シールド</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
悪意のあるSQLインジェクションを回避するには、クエリの一部の文字をエスケープする必要があります。これを行うには、まず、SPIラッパーのように機能する言語のSPI関数と対応する関数（Cで記述）があります。たとえば、PL / Perlの場合：</font></font><br>
<br>
<code>quote_literal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-アポストロフィとダブルを受け取ります 'と\テキストデータのスクリーニング用に設計されています。</font></font><br>
<code>quote_nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-同じですが</font></font><code>undef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、NULLに変換されます。</font></font><br>
<code>quote_ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-必要に応じて、テーブルまたはフィールドの名前を引用符で囲みます。 SQLクエリを作成し、その中のデータベースオブジェクトの名前を置き換える場合に役立ちます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> <span class="hljs-string">"macy's"</span>;
     <span class="hljs-keyword">warn</span> quote_literal(<span class="hljs-string">"macy's"</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  macy's at line 2.<font></font>
WARNING:  'macy''s' at line 3.<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
覚えておいてください：テーブル名はテキスト行のようにエスケープしてはいけません。</font><font style="vertical-align: inherit;">それが機能がある理由</font></font><code>quote_ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、PL / Perlには、個々のpost-gres型のデータをシールドする他の関数があります。</font><font style="vertical-align: inherit;">
関数</font><font style="vertical-align: inherit;">は、任意の型を受け入れ、非定型の疑わしい文字を明らかに安全なものに変換する必要があります。</font><font style="vertical-align: inherit;">非常に多くのタイプで機能しますが、それでもすべてでは機能しません。</font><font style="vertical-align: inherit;">たとえば、彼女は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">範囲タイプ</font></a><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">理解せず、</font><font style="vertical-align: inherit;">それらを単にテキスト文字列として認識します。</font></font><br>
<br>
<code>encode_bytea<br>
decode_bytea<br>
encode_array_literal<br>
encode_typed_literal<br>
encode_array_constructor</code><br>
<br><font style="vertical-align: inherit;"></font><code>quote_typed_literal</code><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> encode_typed_literal(
          [<span class="hljs-string">""</span>, <span class="hljs-string">" "</span>], <span class="hljs-string">"text[]"</span>
     );
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  {," "} at line 2.<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には3つの類似した関数</font><font style="vertical-align: inherit;">
があり</font><font style="vertical-align: inherit;">、それらはほとんど同じように機能</font><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<code>plpy.quote_literal<br>
plpy.quote_nullable<br>
plpy.quote_ident</code><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> plpy.<span class="hljs-keyword">notice</span>(
     plpy.quote_literal("Macy's"));
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><pre><code class="plaintext hljs">NOTICE:  'Macy''s'<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
機能</font><b><font style="vertical-align: inherit;">は</font></b><font style="vertical-align: inherit;">同じ</font><font style="vertical-align: inherit;">ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん！</font><font style="vertical-align: inherit;">構文機能まではすべて同じです。</font></font><br>
<br>
<code>plv8.quote_literal<br>
plv8.quote_nullable<br>
plv8.quote_ident</code><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
    plv8.elog(<span class="hljs-keyword">NOTICE</span>, plv8.quote_nullable("Macy's"));
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  'Macy''s'</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どの言語が最速ですか？通常、彼らは答えます：C。しかし、正しい答えはC </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SQLです。なぜSQLなのか？実際、この言語の関数は常に明示的に実行されるとは限りません。リクエストに埋め込まれ（スケジューラーがメインリクエストの本文に関数を埋め込む）、リクエストで適切に最適化され、結果が速くなります。しかし、どのような条件下でリクエストにコードを埋め込むことができますか？</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、たとえば、いくつかの簡単な条件について読むことができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。たとえば、関数は所有者の権限（セキュリティ定義者になる）で実行されるべきではありません。ほとんどの単純な関数はこれらの条件に適合します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、真剣にではなく、「膝の上」で測定します。大まかな比較が必要です。最初にタイミングをオンにします。</font></font><br>
<br>
<pre><code class="plaintext hljs">\timing</code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
試してみましょう</font><font style="vertical-align: inherit;">（以下のコマンドの実行時間は、作成者がアンロードされた6歳のPCで受け取った丸められた平均値です。それらは互いに比較できますが、科学的であるとは主張していません）。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">FROM</span> pg_class;
<span class="hljs-number">0.5</span> ms
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは非常に速く動作します。</font><font style="vertical-align: inherit;">他の言語では、その言語から関数を呼び出すのに時間がかかります。</font><font style="vertical-align: inherit;">もちろん、インタプリタの初期化が原因で、リクエストの初回の実行が遅くなります。</font><font style="vertical-align: inherit;">その後、安定します。</font><b><font style="vertical-align: inherit;">PL / pgSQLを</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
試してみましょう</font><font style="vertical-align: inherit;">：</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">int</span>;
     <span class="hljs-keyword">BEGIN</span>
          <span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">INTO</span> a <span class="hljs-keyword">FROM</span> pg_class;
     <span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">0.7</span> ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $x = spi_exec_query(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">0.7</span> ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python：</font></font></b><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     x = plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpythonu;
<span class="hljs-number">0.8</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはPython 2でした。今では</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python 3です</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（リコール：Python2とPython3は同じセッション内で平和的に生きていないため、名前の競合が発生する可能性があります）：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     x = plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">0.9</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     var x = plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8 ;
<span class="hljs-number">0.9</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、それはどういうわけか非常に高速です。</font><font style="vertical-align: inherit;">クエリを1000回または100万回実行してみましょう。突然違いが顕著になります：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">int</span>; i <span class="hljs-type">int</span>;
     <span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">0.</span><span class="hljs-number">.999999</span> <span class="hljs-keyword">LOOP</span>
          <span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">INTO</span> a <span class="hljs-keyword">FROM</span> pg_class;
    <span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;
<span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">53</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="ruby">
     <span class="hljs-keyword">for</span> (<span class="hljs-number">0</span>..<span class="hljs-number">999999</span>) {
          spi_exec_query(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     }
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">102</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range (<span class="hljs-number">0</span>,<span class="hljs-number">1000000</span>) :
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">98</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">for</span>(var i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)
          plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;
<span class="hljs-number">100</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / V8では、実験は100万回ではなく1000回で行われたことに注意してください。適度なリソースがあれば、PL / V8は100万回のサイクルですべてのメモリを消費し、車を完全に停止させます。すでに1,000回の反復で、postgresプロセスは3.5GBのメモリと100％ディスクへの書き込みを選択します。実際、postgresはV8環境を起動し、もちろんメモリを消費します。リクエストの実行後、このターボモンスターはメモリを返さなくなります。メモリを解放するには、セッションを終了する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / pgSQLはすでにPL / PerlとPL / Pythonより2倍速いことがわかります。 PL / V8はまだ少し遅れていますが、記事の終わりに近づくにつれて部分的にリハビリされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、これらの実験でのPythonを使用したPerlは、ほぼ同じ結果を示しています。</font><font style="vertical-align: inherit;">Perlは以前はPythonよりも少し劣っていましたが、最近のバージョンでは少し高速です。</font><font style="vertical-align: inherit;">3番目のpythonは2番目よりも少し遅いです。</font><font style="vertical-align: inherit;">全体の差は15％以内です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PREPAREによるパフォーマンス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
知っている人は理解するでしょう：何かが間違っています。</font><font style="vertical-align: inherit;">PL / pgSQLは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クエリプラン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">自動的にキャッシュ</font></a><font style="vertical-align: inherit;">でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。PL </font><font style="vertical-align: inherit;">/ *では、クエリが再度スケジュールされるたびに</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">キャッシュされます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">良い方法では、リクエストを準備し、リクエストプランを作成し、このプランに従って、必要に応じて何回でも実行する必要があります。</font><font style="vertical-align: inherit;">PL / *では、クエリプランを明示的に操作できます。これを</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から始めます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     <span class="hljs-keyword">for</span> (<span class="hljs-number">0</span>..<span class="hljs-number">999999</span>) {
          spi_exec_prepared($h);
     }
     spi_freeplan($h);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">60</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     h = plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>)
     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range (<span class="hljs-number">0</span>,<span class="hljs-number">1000000</span>): plpy.<span class="hljs-keyword">execute</span>(h)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">62</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     var h=plv8.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     <span class="hljs-keyword">for</span>(var i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++) h.<span class="hljs-keyword">execute</span>();
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;
<span class="hljs-number">53</span>ms</code></pre><br><font style="vertical-align: inherit;"></font><code>prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我々の2つの言語、私たちは、ほぼPL / pgSQLのに追いついて、そして3つ目はまたしたかったが、原因成長しているメモリ要件にフィニッシュラインに到達しませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、メモリを考慮に入れなければ、すべての言語がほとんど向かい合っていることは明らかです-偶然ではありません。</font><font style="vertical-align: inherit;">彼らのボトルネックは今や一般的です-SPIを介してデータベースを操作します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンピューティングパフォーマンス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語のパフォーマンスは、データベースの操作にかかっていることがわかります。</font><font style="vertical-align: inherit;">言語を互いに比較するために、データベースに頼らずに、たとえば平方和などを計算してみましょう。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">bigint</span>; a <span class="hljs-type">bigint</span>;
     <span class="hljs-keyword">BEGIN</span> a=<span class="hljs-number">0</span>;
     <span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">0.</span><span class="hljs-number">.1000000</span> <span class="hljs-keyword">LOOP</span>
          a=a+i*i::<span class="hljs-type">bigint</span>;
     <span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;
<span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">280</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $a=<span class="hljs-number">0</span>;
     <span class="hljs-keyword">for</span> <span class="hljs-keyword">my</span> $i (<span class="hljs-number">0</span>..<span class="hljs-number">1000000</span>) { $a+=$i*$i; };
     <span class="hljs-keyword">warn</span> $a;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">63</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
a=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">1000001</span>): a=a+i*i
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">73</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="plaintext hljs">DO $$<font></font>
     var a=0;<font></font>
     for(var i=0;i&lt;=1000000;i++) a+=i*i;<font></font>
     plv8.elog(NOTICE, a);<font></font>
$$ language plv8;<font></font>
7.5ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / PerlとPL / PythonがPL / pgSQLを追い越し、追い抜いたことがわかります。</font><font style="vertical-align: inherit;">そして、8人はみんなを引き裂いています！</font><font style="vertical-align: inherit;">しかし、それは本当に無料なのでしょうか？</font><font style="vertical-align: inherit;">それとも頭につけますか？</font><font style="vertical-align: inherit;">はいします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptの数値は浮動小数点数であり、結果は高速ですが正確</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ではあり</font><font style="vertical-align: inherit;">ません：333333833333500000ではなく333333833333127550 </font><font style="vertical-align: inherit;">です。正確な結果が</font><font style="vertical-align: inherit;">計算</font><font style="vertical-align: inherit;">される式は次のとおりです。</font></font><br>
<br>
<pre><code class="plaintext hljs">∑ = n*(n+1)*(2n+1)/6
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
演習として、数学的帰納法を使用してそれを証明できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
笑い順</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
plv8.elog(<span class="hljs-keyword">NOTICE</span>, parseInt(<span class="hljs-number">33333383333312755033</span>)) $$</span>;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:<font></font>
33333383333312754000</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javascriptでは</font></font><code>parseInt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Intではなく、floatを実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それにもかかわらず、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BigInt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は2018年にV8に登場し、</font><font style="vertical-align: inherit;">現在は確実に数えることができますが、64ビット整数ではなく任意のビット深度の整数であるため、速度に悪影響があります。</font><font style="vertical-align: inherit;">ただし、PL / V8では、この革新はまだヒットしていません。</font><font style="vertical-align: inherit;">他の手続き型言語では、任意のビット数（SQLのアナログ</font></font><code>numeric</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）が特別なライブラリを通じてサポートされています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlには、</font><font style="vertical-align: inherit;">任意の精度で計算するための</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Math :: BigFloatモジュール</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があり、Pythonでは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bigfloat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージ</font><font style="vertical-align: inherit;">が</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">GNU MPFR</font></a><font style="vertical-align: inherit;">ライブラリの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cython</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラッパー</font><font style="vertical-align: inherit;">です。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並べ替えのパフォーマンス関数</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数が異なる言語で書かれている場合、関数によるソートのパフォーマンスの違いを示す実際の例を次に示します。</font><font style="vertical-align: inherit;">タスク：ジャーナルの問題の番号を含むテキストフィールドを並べ替えます。</font></font><br>
<br>
<pre><code class="plaintext hljs">1<font></font>
2<font></font>
3<font></font>
4-5<font></font>
6<font></font>
6A<font></font>
6<font></font>
11<font></font>
12<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それら。</font><font style="vertical-align: inherit;">実際には文字列ですが、数値で始まり、これらの数値で並べ替える必要があります。</font><font style="vertical-align: inherit;">したがって、文字列として正しくソートするために、数値部分を左側のゼロで補完して取得します。</font></font><br>
<br>
<pre><code class="plaintext hljs">0000000001<font></font>
0000000002<font></font>
0000000003<font></font>
0000000004-5<font></font>
0000000006<font></font>
0000000006A<font></font>
0000000006<font></font>
0000000011<font></font>
0000000012<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、私はこれが問題の唯一の解決策ではないことを知っています（そして、まったく正しくありません）。</font><font style="vertical-align: inherit;">しかし、例えば、それは行います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプをリクエスト</font></font><code>SELECT ... ORDER BY nsort(n)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するには、ジャーナル番号を次の形式に変換する関数をPL / Perl、SQL、PL / Python、およびPL / V8で記述します。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> nsort(<span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> PLPERL <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="perl">
    <span class="hljs-keyword">my</span> $x = <span class="hljs-keyword">shift</span>;
    <span class="hljs-keyword">return</span> ($x =~ <span class="hljs-regexp">/^\s*(\d+)(.*)$/</span>)
        ? <span class="hljs-keyword">sprintf</span>(<span class="hljs-string">"%010d"</span>, $1).$2
        : $x;
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> _nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span>
     <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">SQL</span>  <span class="hljs-keyword">IMMUTABLE</span>  <span class="hljs-keyword">AS</span> $$<span class="pgsql">
 <span class="hljs-keyword">WITH</span> y <span class="hljs-keyword">AS</span> (
    <span class="hljs-keyword">SELECT</span> regexp_match(x,<span class="hljs-string">'^\s*(\d*)(.*)$'</span>) <span class="hljs-keyword">as</span> z
 )
 <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> z[<span class="hljs-number">1</span>] = <span class="hljs-string">''</span> <span class="hljs-keyword">THEN</span> x <span class="hljs-keyword">ELSE</span> lpad(z[<span class="hljs-number">1</span>],<span class="hljs-number">10</span>,<span class="hljs-string">'0'</span>) || z[<span class="hljs-number">2</span>] <span class="hljs-keyword">END</span> <span class="hljs-keyword">FROM</span> y;
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> py_nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> plpython2u <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="pgsql">
<span class="hljs-keyword">import</span> re
r = re.match(<span class="hljs-string">'^\s*(\d+)(.*)$'</span>, x)
<span class="hljs-keyword">return</span> x <span class="hljs-keyword">if</span> r == <span class="hljs-keyword">None</span> <span class="hljs-keyword">else</span> (<span class="hljs-string">'%010d'</span> % <span class="hljs-type">int</span>(r.<span class="hljs-keyword">group</span>(<span class="hljs-number">1</span>))) + r.<span class="hljs-keyword">group</span>(<span class="hljs-number">2</span>)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> js_nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="ruby">
var m = x.match(<span class="hljs-regexp">/^\s*(\d+)(.*)$/</span>);
<span class="hljs-keyword">if</span>(m) { <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>].padStart(<span class="hljs-number">10</span>-m[<span class="hljs-number">1</span>].length,<span class="hljs-string">'0'</span>) + m[<span class="hljs-number">2</span>]; }
<span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> x; } 
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の15.5千のジャーナル記事のライブラリでは、PL / Perlの関数を使用したクエリは、PL / Pythonの120ミリ秒とPL / PgSQLの200ミリ秒に対して約64ミリ秒かかります。</font><font style="vertical-align: inherit;">しかし、最も速い-PL / v8：54ms。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並べ替えを試す場合は、並べ替えがメモリに入るように必要な量の作業メモリを提供します（EXPLAINはを表示します</font></font><code>Sort Method: quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">メモリの量はパラメータによって設定されます</font></font><code>work_mem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">set</span> work_mem = <span class="hljs-string">'20MB'</span>;
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記憶</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlはループ構造を好みません;彼はそれらをきれいにする方法を知りません。</font><font style="vertical-align: inherit;">あなたがいる場合</font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にポインタ持っている</font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、と</font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のポインタを</font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その後、参照カウンタがリセットされることはありませんし、メモリが解放されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ガベージコレクション言語には他の問題があります。</font><font style="vertical-align: inherit;">たとえば、メモリがいつ解放されるか、またはまったく解放されるかどうかは不明です。</font><font style="vertical-align: inherit;">または、意図的にこれを行わない場合、コレクターは最も不都合なときにゴミを収集しに行きます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、Postgresに直接関連するメモリ管理機能もあります。</font><font style="vertical-align: inherit;">SPIが割り当てる構造があり、Perlはそれらを解放する必要があることを常に認識しているわけではありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これはそれがどうなるかではありません：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">return</span> spi_exec_query(
           <span class="hljs-string">'SELECT count(*) FROM pg_class'</span>
     )-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてそれは行く：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(
          <span class="hljs-string">'SELECT count(*) FROM pg_class'</span>
     );
     <span class="hljs-keyword">return</span> spi_exec_prepared($h)-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行後、ハンドラー</font></font><code>$h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は生きているままです。ただし、</font><font style="vertical-align: inherit;">ハンドラー</font><font style="vertical-align: inherit;">へのリンクが1つも残っていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは大丈夫です、あなたは明示的にリソースを明示的に解放する必要性を覚える必要があります</font></font><code>spi_freeplan($h)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     <span class="hljs-keyword">my</span> $res = spi_exec_prepared($h)-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
     spi_freeplan($h);
     <span class="hljs-keyword">return</span> $res;
$$</span>;</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python：</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Python </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がフローすることは</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あり</font><b><font style="vertical-align: inherit;">ません。</font></b><font style="vertical-align: inherit;">プランは自動的にリリースされます。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr3() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plpythonu <span class="hljs-keyword">as</span>
$$<span class="pgsql">
     <span class="hljs-keyword">return</span> plpy.<span class="hljs-keyword">execute</span>(
           <span class="hljs-string">'select count(*) from pg_class'</span>
     )[<span class="hljs-number">0</span>][<span class="hljs-string">'count'</span>]
$$</span>;</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Perlと同じ話。</font><font style="vertical-align: inherit;">次のようには流れません。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     <span class="hljs-keyword">return</span> plv8.<span class="hljs-keyword">execute</span>(
          <span class="hljs-string">'select count(*) from pg_class‘
     )[0].count;
$$</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてそれは行く：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     var h = plv8.<span class="hljs-keyword">prepare</span>(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     <span class="hljs-keyword">return</span> h.<span class="hljs-keyword">execute</span>()[<span class="hljs-number">0</span>].count;
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しますが、リソースを解放することを忘れないでください。</font><font style="vertical-align: inherit;">ここにあります</font></font><code>h.free();</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
流れません：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     var h = plv8.<span class="hljs-keyword">prepare</span>(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     var r = h.<span class="hljs-keyword">execute</span>()[<span class="hljs-number">0</span>].count;
     h.free();
     <span class="hljs-keyword">return</span> r;
$$</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメーター</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
引数が関数に渡される方法を理解する時が来ました。</font><font style="vertical-align: inherit;">例では、型付きの4つのパラメーターを関数に渡します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全体;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">byteaおよび</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsonb</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らは</font><font style="vertical-align: inherit;">どのように</font><font style="vertical-align: inherit;">して</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perlに入り</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ますか？</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq(a <span class="hljs-type">int</span>, b
<span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span> ) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
    <span class="hljs-keyword">warn</span> Dumper(@_);
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> crq(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  $VAR1 = '1';<font></font>
$VAR2 = '\\x61626364';<font></font>
$VAR3 = bless( {<font></font>
                 'array' =&gt; [<font></font>
                              '1',<font></font>
                              '2',<font></font>
                              '3'<font></font>
                            ],<font></font>
                 'typeoid' =&gt; 1007<font></font>
               }, 'PostgreSQL::InServer::ARRAY' );<font></font>
$VAR4 = '{"a": 2, "b": 3}';<font></font>
 crq <font></font>
-----<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはJSONまたはJSONBのどちらになります-この場合、違いはありません。文字列の形式のままです。これは汎用性の代償です。Postgresには、さまざまな程度の「組み込み」タイプの多くのタイプがあります。新しいタイプをすぐに提供し、すべてのPL / *の変換関数を提供することを開発者に要求するには多すぎるでしょう。デフォルトでは、多くのタイプが文字列として渡されます。しかし、これは必ずしも便利ではありません。これらの用語を解析する必要があります。もちろん、私はPostgresのデータがすぐに適切なPerl構造に変わることを望みます。デフォルトでは、これは発生しませんが、9.6から、TRANSFORMメカニズムが出現しました-型変換関数を定義する機能：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CREATE TRANSFORM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TRANSFORMを作成するには、Cで2つの関数を作成する必要があります。1つは特定のタイプのデータを片側に変換し、もう一方は逆に変換します。</font><font style="vertical-align: inherit;">TRANSFORMは4つの場所で機能します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数にパラメーターを渡す場合;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数値を返すとき;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数内でSPI呼び出しにパラメーターを渡す場合。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数内のSPI呼び出しの結果を受信すると。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anton Bykovが開発したPerlおよびPython用のTRANSFORM JSONBは、Postgresの11番目のバージョンに登場しました。</font><font style="vertical-align: inherit;">これで、JSONBを解析する必要がなくなり、対応する構造としてすぐにPerlに入ります。</font><font style="vertical-align: inherit;">jsonb_plperl拡張機能を作成する必要があります。その後、TRANSFORMを使用できます。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> jsonb_plperl;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq2(d <span class="hljs-type">jsonb</span>)
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span> <span class="hljs-keyword">LANGUAGE</span> plperl
<span class="hljs-keyword">TRANSFORM</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">TYPE</span> <span class="hljs-type">jsonb</span> <span class="hljs-keyword">AS</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> Dumper(@_);
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数を呼び出して、JSONBがパールハッシュに変わったことを確認できます。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> crq2( <span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  $VAR1 = {<font></font>
          'a' =&gt; '2',<font></font>
          'b' =&gt; '3'<font></font>
        };<font></font>
 crq2 <font></font>
------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まったく別の問題！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事の著者は、TRANSFORMの開発にも携わっていました。このような単純なデータ型は、</font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perlに不便な形式でテキスト文字列</font></font><code>'t'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font><font style="vertical-align: inherit;">として</font><font style="vertical-align: inherit;">渡されることがわかりました</font></font><code>'f'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。しかし、Perlの理解では、文字列「f」は真です。この不便さを解消する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ために、ブール型の変換を定義</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">パッチ</font></a><font style="vertical-align: inherit;">が発明</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">されました</font></a><font style="vertical-align: inherit;">。このパッチはPostgreSQL 13にヒットし、まもなく利用可能になります。単純であるため、bool_plperlは、他の変換を作成するための最小限の開始モデルとして機能できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰かが他のデータ型（bytea、配列、日付、数値）のTRANSFORMを開発することを願っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、パラメーターが</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pythonで</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのように渡されるかを見てみましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> jsonb_plpython3u;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> pdump(a <span class="hljs-type">int</span>, b <span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span> ) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plpython3u
<span class="hljs-keyword">TRANSFORM</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">TYPE</span> <span class="hljs-type">jsonb</span> <span class="hljs-keyword">AS</span> $$<span class="pgsql">
      plpy.<span class="hljs-built_in">warning</span>(a,b,c,d)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> pdump(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  (1, b'abcd', [1, 2, 3], {'a': Decimal('2'), 'b': Decimal('3')})<font></font>
 pdump <font></font>
-------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列は配列に変換されます-これは適切です（バージョンPG10の多次元配列もPythonに正しく転送されるため）。</font><font style="vertical-align: inherit;">Perlでは、配列は特別なクラスのオブジェクトに変換されました。</font><font style="vertical-align: inherit;">まあ、</font></font><code>jsonb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変身。</font><font style="vertical-align: inherit;">TRANSFORMがない場合、jsonbは文字列として渡されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、パラメーターが</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSに渡さ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れる形式を確認します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> jsdump(a <span class="hljs-type">int</span>, b <span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span> $$<span class="pgsql">
     plv8.elog(<span class="hljs-built_in">WARNING</span>,a,b,c,d)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> jsdump(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  1 97,98,99,100 1,2,3 [object Object]<font></font>
jsdump <font></font>
-------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSONBは、TRANSFORMなしでJavaScriptオブジェクトに変換されます！</font><font style="vertical-align: inherit;">一時的なPostgres型もDate JS型に変換されます。</font><font style="vertical-align: inherit;">ブール値でも同じです。</font><font style="vertical-align: inherit;">すべての変換はすでにPL / V8に組み込まれています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無限に働く</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
INFINITY定数はあまり使用されませんが、それを使ったずさんな作業は危険です。</font><font style="vertical-align: inherit;">PostgreSQLでは、Infinityと-Infinityは、いくつかの一時的な浮動小数点型の特別な値として存在します。</font><font style="vertical-align: inherit;">ただし、Infinityを手続き型言語に、またはその逆に転送することは、言語だけでなく、ライブラリ、OS、さらにはハードウェアにも依存する可能性があるため、詳細に説明する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonには、数値の無限大を定義するNumpyモジュールがあります。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> nm<font></font>
a = nm.inf<font></font>
b = -nm.inf<font></font>
print(a, b)</code></pre><br>
<pre><code class="plaintext hljs">inf -inf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlも無限大で、に</font></font><code>"infinity"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">短縮できる</font><font style="vertical-align: inherit;">文字列</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用します</font></font><code>"inf"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">たとえば、次のように言うことができます。</font></font><br>
<br>
<pre><code class="perl hljs">perl -e <span class="hljs-string">'print 1 * "inf"'</span></code></pre><br>
<pre><code class="plaintext hljs">Inf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または</font></font><br>
<br>
<pre><code class="perl hljs">perl -e <span class="hljs-string">'print 1/"inf"'</span></code></pre><br>
<pre><code class="plaintext hljs">0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Perl、PL / Python、PL / v8では、Postgresからの数値の無限大は正しく渡されますが、無限の日付は正しくありません。</font><font style="vertical-align: inherit;">むしろ、PL / PerlとPL / Pythonでは、時間の組み込みデータ型はなく、文字列がそこに来ます。</font><font style="vertical-align: inherit;">PL / V8には組み込み型のDateがあり、postgresからの通常の日付がそれに変わります。</font><font style="vertical-align: inherit;">しかし、V8は無限の日付を知らないため、転送されるとに変わり</font></font><code>Invalid Date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準備されたリクエストにパラメーターを渡す</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
に戻り</font></font><code>prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、パラメーターがそこにどのように渡されるかを検討します。</font><font style="vertical-align: inherit;">異なる言語はすべてSPIに基づいているため、多くの共通点があります。</font><b><font style="vertical-align: inherit;">PL / Perl</font></b><font style="vertical-align: inherit;">で</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クエリを準備するとき</font><font style="vertical-align: inherit;">は、転送されるパラメーターのタイプを決定する必要があります。クエリを実行するときは、これらのパラメーターの値のみを指定します（パラメーターは同じ方法でPL / pgSQLに転送されます）。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plperl $$<span class="perl">
     <span class="hljs-keyword">my</span> $h= spi_prepare(<span class="hljs-string">'SELECT * FROM pg_class WHERE
          relname ~ $1'</span>, <span class="hljs-string">'text'</span> );                     <span class="hljs-comment">#   </span>
     <span class="hljs-keyword">warn</span> Dumper(spi_exec_prepared($h, <span class="hljs-string">'pg_language'</span>)); <span class="hljs-comment">#   </span>
     spi_freeplan($h);
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Pythonの、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本質は同じですが、構文が若干異なります。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u $$<span class="pgsql">
     h= plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT relname FROM pg_class WHERE relname ~ $1'</span>, [<span class="hljs-string">'text'</span>] )
     plpy.<span class="hljs-keyword">notice</span>(.<span class="hljs-keyword">execute</span> ([<span class="hljs-string">'pg_language'</span>]))
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">違いは最小限です。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
    var h= plv8.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT relname FROM pg_class WHERE relname ~ $1'</span>, [<span class="hljs-string">'text'</span>] );
    plv8.elog(<span class="hljs-keyword">NOTICE</span>, h.<span class="hljs-keyword">execute</span> ([<span class="hljs-string">'pg_language'</span>]));
    h.free();
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Javaの、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてが異なっています。</font><font style="vertical-align: inherit;">そこでは、SPIは明らかに使用されていませんが、データベースへの疑似JDBC接続が形成されています。</font><font style="vertical-align: inherit;">PL / Javaプログラマーにとって、クライアントアプリケーションを作成しているかのようにすべてが起こります。</font><font style="vertical-align: inherit;">これは便利で、PL / PerlとPL / Pythonの設計にアプローチすることもできますが、何らかの理由でこれが行われませんでした（ただし、PL / PerlとPL / Pythonの実装をさらに2つ作成することを禁じている人はいません）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カーソルを操作する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースに行ったときに使用したすべてのSPI関数（</font></font><code>spi_exec_query()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">およびその他）には、返される行数を制限するパラメーターがあります。</font><font style="vertical-align: inherit;">返される行が大量に必要な場合は、カーソルを使わずに少し引き上げることはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カーソルはこれらすべての言語で機能します。</font><font style="vertical-align: inherit;">で</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perlの、</font></font></b> <br>
<code>spi_exec_query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一度に文字列1を抽出することができ、そこからカーソルを返します。</font><font style="vertical-align: inherit;">カーソルを閉じる必要はありません。それ自体が閉じます。</font><font style="vertical-align: inherit;">ただし、再検出する場合は、コマンドを使用して明示的に閉じることができます</font></font><code>close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plperl $$<span class="perl">
    <span class="hljs-keyword">my</span> $cursor = spi_query(<span class="hljs-string">'SELECT * FROM pg_class'</span>);
    <span class="hljs-keyword">my</span> $row;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">defined</span>($row = spi_fetchrow($cursor))) {
         <span class="hljs-keyword">warn</span> $row-&gt;{relname};
    }
$$</span>;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  pg_statistic at line 5.<font></font>
WARNING:  pg_toast_2604 at line 5.<font></font>
WARNING:  pg_toast_2604_index at line 5.<font></font>
WARNING:  pg_toast_2606 at line 5.<font></font>
WARNING:  pg_toast_2606_index at line 5.<font></font>
WARNING:  pg_toast_2609 at line 5.<font></font>
WARNING:  pg_toast_2609_index at line 5.<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Pythonの、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてが非常に似ていますが、カーソルは、あなたがサイクルが通過できることをオブジェクトとして提示されています。</font></font><br>
<br>
<pre><code class="pgsql hljs">h = plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT ...'</span>);
<span class="hljs-keyword">cursor</span> = plpy.<span class="hljs-keyword">cursor</span>(h);
<span class="hljs-keyword">for</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">cursor</span>:<font></font>
...<font></font>
<span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>() //  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてがまた非常に似ていますが、準備されたクエリプランを解放することを忘れないでください：</font></font><br>
<br>
<pre><code class="pgsql hljs">var h = plv.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT ...'</span>);<font></font>
var <span class="hljs-keyword">cursor</span> = h.<span class="hljs-keyword">cursor</span>();<font></font>
var <span class="hljs-keyword">row</span>;
<span class="hljs-keyword">while</span>(<span class="hljs-keyword">row</span> = <span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">fetch</span>()) {<font></font>
...<font></font>
}<font></font>
<span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>();<font></font>
h.free();</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8：機能へのクイックアクセス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / V8では、通常のSELECTからではなく関数を呼び出すことができますが、名前でその関数を見つけ、すぐにで起動でき</font></font><code>plv8.find_function(name);</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">ただし、JSでは、関数はPostgreSQLのようにポリモーフィックにすることはできないことに注意してください。PostgreSQLでは、同じ名前でパラメータが異なる関数が共存できます。</font><font style="vertical-align: inherit;">PL / v8ではもちろん、多態性関数を作成できます</font></font><code>find_function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、それ</font><font style="vertical-align: inherit;">を使用しようとする</font><font style="vertical-align: inherit;">とエラーが発生</font><font style="vertical-align: inherit;">します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">ERROR:  Error: more than one function named "jsdump"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
名前による関数が明確である場合、SPIおよび型変換なしで呼び出すことができます。</font><font style="vertical-align: inherit;">はるかに高速。</font><font style="vertical-align: inherit;">たとえば、次のようになります。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="ruby">
plv8.find_function(<span class="hljs-string">'jsdump'</span>)(<span class="hljs-number">1</span>, <span class="hljs-string">'abc'</span>);
$$</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取引</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postgres 11には多くの楽しみがあります。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手順</font><font style="vertical-align: inherit;">が登場しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Postgresには以前は機能しかありませんでした。</font><font style="vertical-align: inherit;">喜びは、SQL標準への互換性とコンプライアンスにあるだけでなく、その理由でもあります。プロシージャ内で、トランザクションをコミットおよびロールバックできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / PerlとPL / Pythonにはすでにトランザクションを管理するためのSPI関数がありますが、PL / V8にはまだありません。</font><font style="vertical-align: inherit;">PL / Perlでは、これらの関数は</font></font><code>spi_commit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andと</font><font style="vertical-align: inherit;">呼ばれ</font><font style="vertical-align: inherit;">、</font></font><code>spi_rollback()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用例は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメントにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">PL / Pythonでは、これは</font></font><code>plpy.commit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>plpy.rollback()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブトランザクション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サブトランザクションは、複雑なマルチレベルロジックでの正しいエラー処理に便利です。</font><b><font style="vertical-align: inherit;">PL / pgSQLの</font></b><font style="vertical-align: inherit;">トランザクション内、EXCEPTIONキーワードを有する各ブロックがサブトランザクションです。この場合に発生する可能性があるいくつかのパフォーマンスと信頼性の問題については、たとえば</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">こちらを参照してください</font></a><font style="vertical-align: inherit;">。</font><b><font style="vertical-align: inherit;">PL / Perl</font></b><font style="vertical-align: inherit;">には明示的なサブトランザクション</font><font style="vertical-align: inherit;">
はあり</font><font style="vertical-align: inherit;">ませんが、savaepointsを介してシミュレートできます。どうやら、あなたが望むなら、明示的な形式でサブトランザクションを実装するpearlモジュールを書くのは簡単です。</font><font style="vertical-align: inherit;">
では</font><b><font style="vertical-align: inherit;">PL / Pythonの、</font></b><font style="vertical-align: inherit;">サブトランザクションは、ずっと前に登場：9.5から</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">明示的に</font></a><font style="vertical-align: inherit;">、ありましたその前に</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、暗黙的なもの</font></a><font style="vertical-align: inherit;">。トランザクションを定義してラップすることができます</font></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><code>try-</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして実行します。</font><font style="vertical-align: inherit;">サブトランザクションが落ちる場合は、ブロック</font></font><code>except</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に落ちます。落ちない場合は、ブロックに入り、次に進み</font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="pgsql hljs">try:
     <span class="hljs-keyword">with</span> plpy.subtransaction():<font></font>
          plpy.<span class="hljs-keyword">execute</span>("...")<font></font>
          plpy.<span class="hljs-keyword">execute</span>("...")
<span class="hljs-keyword">except</span> plpy.SPIError, e:<font></font>
. . .<font></font>
<span class="hljs-keyword">else</span>:<font></font>
. . .</code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にもJS構文でのみ</font><font style="vertical-align: inherit;">
同様のデザインが存在し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="pgsql hljs">try {<font></font>
plv8.subtransaction(<span class="hljs-keyword">function</span>() {<font></font>
plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'UPDATE...'</span>);<font></font>
plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'UPDATE...'</span>);<font></font>
});<font></font>
}<font></font>
catch(e) {<font></font>
...<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
試してみてください。ただし乱用しないでください:) PL / *の知識は、いくつかの利点をもたらします。</font><font style="vertical-align: inherit;">他のツールと同様に、意図した目的で使用することが大好きです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / v8は非常に有望ですが、予期しない動作をすることがあり、多くの問題があります。</font><font style="vertical-align: inherit;">したがって、タスクに適した言語であれば、すぐに使える言語を使用することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イゴール・レフシン（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Igor_Le</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、記事の資料の準備で私を大いに助けてくれて、いくつかの有用なアイデアを投げかけました。彼らが提案した修正については、Yevgeny SergeyevとAlexey Fadeevも同様です。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja502244/index.html">人口の物語、遺伝学、遺伝的アルゴリズム</a></li>
<li><a href="../ja502246/index.html">アリスの大胆な答えはドローンと何が共通するのですか？</a></li>
<li><a href="../ja502248/index.html">デジタルリソース用の新しいGOSTが施行されました。すべてのプラットフォームは、障害を持つ人々がアクセスできる必要があります</a></li>
<li><a href="../ja502250/index.html">今日の民間航空：トレーニングにおける重要な側面と課題</a></li>
<li><a href="../ja502252/index.html">リモコンとドローン</a></li>
<li><a href="../ja502256/index.html">Neo4jを使用してSpring統合グラフを視覚化する方法は？</a></li>
<li><a href="../ja502258/index.html">ヘルプ/ドキュメント用のVue.jsコンポーネント</a></li>
<li><a href="../ja502260/index.html">ESP-NOWは、ESP8266およびESP32の代替通信プロトコルです。基本概念</a></li>
<li><a href="../ja502262/index.html">銀行のAIOpsと包括的モニタリングの理由、または顧客関係の構築について</a></li>
<li><a href="../ja502264/index.html">公開鍵インフラストラクチャ。自己分離の状態での証明書の発行</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>