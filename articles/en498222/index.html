<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§õüèº ü§≥üèº üëßüèª ZX Spectrum from coronavirus and sticks (actually, not really) ü§µ üîç üñ§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Self-isolation is the scourge of modern humanity. Here, for example, in the neighboring city, on Fridays and Saturdays, after traditional clapping at ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ZX Spectrum from coronavirus and sticks (actually, not really)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498222/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Self-isolation is the scourge of modern humanity. Here, for example, in the neighboring city, on Fridays and Saturdays, after traditional clapping at 8 pm, they organize balcony concerts. They feel good, their houses are tall and their neighbors are young. Our neighbors are elderly, they don‚Äôt want concerts. And the houses are low, which also does not contribute to idleness. Therefore, we are saved as we can. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the afternoon, on a remote site, not so bad. As in the evening, until the children fall asleep. As in the first few days, until the books run out and the series get bored. But a month passes, followed by another. The soul requires old iron. But not just, but with perversion. And I rummaged through the trash bins and found the Zilog Z80 processor there:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7f1/fe7/7c9/7f1fe77c9972b2270ad8478702521555.jpg" alt="image"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I must say, I really love this processor. Probably the only thing I like about him is the 486th chip, but my hands will not reach it soon, because it‚Äôs difficult and pointless to insert it into the breadboard. Have to solder. But I do not want to solder yet. And even more than the Z80 itself, I love the ZX Spectrum computer built on its basis. But the native Spectrum suffers from a misfortune in the form of a ULA custom logic chip, and its clones on the loose side are not particularly difficult to build and refine, but still not for the layout, and indeed, why so many worries when there is arduino?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A smart, balanced and adequate reader here will either stop reading or throw something like ‚Äú1 FPGA microcircuit will accommodate the Spectrum computer class‚Äù before stopping. I'm not smart, not adequate, although balanced, but I only know about FPGA that it's cool. I can only do arduino. But really wants to poke the wires in the Z80. Highly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, let's begin. But first, Disclaimer.</font></font><b>,   ,   ,    .  ‚Äî       .      ,    , .      ,    (,   ?), ,   ,   ,     ,  .       ,    ,  ,   ,   ,    .</b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To begin with, what is an adequate 8-bit computer. This is, in fact, a processor connected to ROM and RAM, and on the side is a couple of counters to display on the composite screen. Sometimes, a timer to squeak. ZX Spectrum is no different from the traditional scheme, except for one but. There is a ULA. This, in fact, is the ‚Äúchipset‚Äù of the Spectrum. ULA manages peripherals, such as a tape recorder, tweeter, keyboard (partially), output to the screen (yes, yes, the integrated video card appeared in the Spectrum chipset before it became mainstream). There was also a shared memorial, the first 16 KiB of RAM (addresses from 0x4000 to 0x5B00). From it, the ULA drew a composite onto the screen, and so that the Z80 would not fumble there when it was not necessary, the ULA could stop the processor, if necessary, because the clock signal on the Z80 came from it. That is, if ULA worked with memory, and detected,that the processor also creeps into this memory (for this, it constantly monitored the MREQ and the A15 and A14 lines), it simply stopped the processor clocking until it itself finished doing what it needed. By the way, in order to avoid data corruption on the bus, parts of the bus on the processor side and on the ULA side were delimited by ... resistors ... Moreover, the memory was sitting on the bus from the ULA side and, accordingly, in the event of a collision, completely ignored the data and address from the processor side.completely ignored the data and address from the processor.completely ignored the data and address from the processor.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, the Spectrum had ROMs (addresses 0x0000 - 0x3FFF) and its own processor memory (0x8000 - 0xFFFF), to which ULA did not have access, and which worked faster than 16 KiB of shared memory, since the processor did not interfere with ULA in this area . But that was only on the 48K version of the computer. In the basic version, there were only ROMs and 16 KiB compatible with ULA. We‚Äôll start with her.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It‚Äôs convenient that the Z80 processor can regenerate DRAM, but somehow I don‚Äôt want to bother with it, because SRAM is easier to find and I don‚Äôt have a multiplexer (or I can‚Äôt find it). So, we will use SRAM. To begin with, we will assemble the main skeleton, on which then everything else can be hung. The skeleton will be a processor, ROM with firmware, mapped to the address of the Spectrum's ROM, RAM, mapped to the first 16 KiB after the ROM and some chips to wrap everything ... I must say that for a long time I did not want to rotate, because I have Chinese layouts $ 1 for 2 pieces in ibee. But, for me, the fuss is worth it. If you do not want to mess around for a long time, take good layouts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, install the Z80. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see from the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datasheet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ee/n6/i0/een6i0aw3zjgv2b4gah5oo9t2ja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The processor has 40 pins divided into groups: address bus, data bus, system control, processor control, processor bus control, well, power and clock. Not all of these conclusions are used in real systems, such as the ZX Spectrum, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as can be seen from the diagram.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Of the group "processor control" in the Spectrum, only INT and RESET signals are used. Signal M1 is not used from the ‚Äúsystem control‚Äù group, the ‚Äúbus control‚Äù group is not used at all. There is a reason for this. The old 8-bit systems were very simple, and the Spectrum was created with the idea of ‚Äã‚Äãbeing as simple as possible and everything that could be ignored was ignored. Of course, peripheral manufacturers could use interrupts (INT and NMI signals), they were routed to the expansion slot, but NMI was not used in the spectrum itself. As can be seen from the above diagram, the NMI, WAIT, BUSREQ signals are pulled up by power resistors, since these are low-level activated inputs (this is indicated by the bar above the signal name), and there must be a logical unit (i.e. + 5V) so that God forbid the unnecessary signal did not work. And here are the findings, BUSACK, HALT, M1,and hang in the air, not connected to anything. By the way, note that there is no reset button in the Spectrum. The reset pin is connected via</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RC chain</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to power (RESET is also activated by a low level), since, according to the datasheet, after turning on RESET, at least 3 clock cycles must be active for the processor to enter the operating mode. This RC-circuit keeps a low level until the capacitor is charged to a high level through a resistor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's briefly go over the rest of the signals: </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M1.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We do not need. He reports that the processor began to execute the next instruction. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MREQ.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I need it. It reports that the processor is accessing memory. If this signal becomes low (that is, connected to the power ground), then we will need to activate the memory connected to the processor. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOREQ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . I need it. It reports that the processor is accessing a peripheral device. For example, to the keyboard.</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . I need it. Informs that the processor will read data from memory (if MREQ is active) or peripherals (IOREQ). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . I need it. Reports that the processor will write data to memory / peripherals. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFSH</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . I need it. In general, this signal is needed for dynamic memory (DRAM). I do not plan to use it, since its addressing is more difficult (matrix, not linear, that is, it will be necessary to install a multiplexer), and in general, in our time, low-capacity SRAM microcircuits are easier to get. But since the processor itself regenerates DRAM by sorting addresses on the memory bus, this signal will allow us to ignore the regeneration cycles and not activate the memory with active RFSH. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HALT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Not needed. Indicates that the processor is stopped. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WAIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Not needed. This signal is needed to ask the processor to stop and wait a bit. Usually used by slow peripherals or memory. But not in the Spectrum. When in the Spectrum peripherals (ULA) decides to stop the processor, then it simply ceases to send a clock signal to it. This is more reliable, because after receiving WAIT, the processor does not immediately stop. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Interrupt. It is not clear yet. We assume that it is not needed yet. Then we'll figure it out. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The NMI</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Unmaskable interruption. Super interrupt. Not necessary. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RESET</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Without it, it won‚Äôt fly. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUSREQ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Not needed. Asks the processor to disconnect from the data / address buses, as well as the control signals. It is necessary if some device wants to gain control over the bus. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUSACK</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Not needed. Serves to inform the device that performed BUSREQ that the bus is free. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The CLOCK</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Clock signal. Clearly, he is needed. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meals are</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> also needed. Glory to the developers, only + 5V / GND. No 3 stresses for you. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A0-A15</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the address bus. On it, the processor displays either a memory address (MREQ is active) or an I / O port address (IOREQ is active) with appropriate calls. As you can see, the bus is 16 bits wide, which allows you to directly address 64 KiB of memory. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D0-D7</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - data bus. The processor outputs to it (WR active), or reads from it (RD active) the requested data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we will place the processor on the breadboard. So his conclusions are physically located:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/dcb/b3f/2c4/dcbb3f2c401007d7aa3e1083e403f301.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Connect the power (pin 11 and 29). Just in case, I also put a 10 pF capacitor between these legs. But he did not help me in the end. Pins 27, 23, 18 may remain unconnected to anything. Pins 26, 25, 24, 17, 16 are connected via resistors (I used 10 kOhm) to the power supply. I brought the address bus (pins 1-5 and 30-40) to the opposite side of the breadboard, and the data bus (pins 7-10 and 12-15) to a separate data bus made from prototype power buses. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pins 6 (clock signal) and 26 (RESET) are connected (later) to Arduin so that you can control the processor from it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It turned out like this:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jm/in/rx/jminrxjfjixmm4pod6jhxw3kzfy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Until you pay attention to the wires from above, they go from the ROM, we will move on to it a bit later. Also, in the photo next to the processor, one more chip is visible. We need it to decode the upper bits of the address. As I said above, there are 3 types of memory in the Spectrum. The lower 16 KiB of the address space is ROM. Accordingly, if the terminals A14 and A15 are in a low state (0 Volts), we need to disconnect everything except the ROM chip from the bus. Next up is 16 KiB of shared memory. Accordingly, we need to connect this memory to the bus (and disconnect the rest) if the output A15 is low and A14 is high (+5 Volts). Well, then comes 32 KiB of fast memory. We will attach this memory later, and we will activate it if the output A15 is in a high state. In addition, do not forget that we only activate memory when active (here, active - low,0 Volt) MREQ and inactive (here, inactive - high, + 5V) RFSH. All this is quite simple to implement on standard logic, on the same NANDs, such as 74HC00, or Orthodox K155LA3, and I understand this task is for the preparatory group of the kindergarten, however, I can only think in truth tables in freedom and in captivity</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have a complete Harlequin diagram there</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , from which you can simply take the part where U4 is drawn (74HC138, fortunately I have about a hundred of them). </font><font style="vertical-align: inherit;">We will ignore U11 for clarity, since the upper 32KiB are not of interest to us so far. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Connecting is very simple. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2h/my/p2/2hmyp2xuiiuejpixie4e1mnoo1w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As can be seen from the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">brief description</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The microcircuit is a decoder that receives binary numbers from 000 to 111 on the terminals 1 through 3 and activates one of 8 outputs (legs 7 and 9 to 15) corresponding to this number. </font><font style="vertical-align: inherit;">Since only 8 different numbers can be stored in 3 bits, there are only eight outputs. </font><font style="vertical-align: inherit;">As you can see, the conclusions are inverted, that is, the one that will be active will have a level of 0V, and all the others + 5V. </font><font style="vertical-align: inherit;">In addition, a key in the form of a 3-input gate of type ‚ÄúI‚Äù is built into the chip, and two of its three inputs are also inverted.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our case, we connect the decoder itself as follows: the most significant bit (3rd leg) to the ground, there will always be 0. The middle bit is to line A15. There will be 1 only if the processor accesses the upper 32KiB of memory (addresses 0x8000 - 0xFFFF, or 1000000000000000 - 1111111111111111 in binary, when the most significant bit is always set to 1). We connect the least significant bit to the A14 line, where the high level will be in case of accessing either the memory after the first 16 KiB, but up to the top 32 KiB (addresses 0x4000 - 0x7FFF, or 0100000000000000 - 0111111111111111 in binary form), or to the most recent 16 KiB of the address spaces (addresses 0xB000 - 0xFFFF, or 1100000000000000 - 1111111111111111 in binary form). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's see what the output will be in each of the cases:</font></font><br>
<br>
<ul>
<li>  14  15    ,       16  ,    ,     000,  0    (    ),     Y0 (15 ).      ,      .</li>
<li>  14   ,   15 ‚Äî  ,         16 ,   32 ,    001,  1   ,     Y1 (14 ).      ,  16 ,       .</li>
<li>  14   ,   15 ‚Äî  ,     -  32   48 ,    010,     Y2 (13 ).      ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If both lines (A14 and A15) are active, the processor accesses the top 16 KiB of memory, from 48 to 64 KiB, we don‚Äôt have it, so the Y3 pin (12th pin) is also in the air.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, thanks to another element, the microcircuit will activate its findings only if inputs 4 and 5 are low and 6 are high. </font><font style="vertical-align: inherit;">The 4th input is always in the low state (it is connected directly to the ground), the 5th will only be low when the processor is accessing memory (remember, MREQ in the low state means accessing the memory), and the 6th will be high when the processor does not perform an update cycle DRAM (we have SRAM, so DRAM update cycles are the safest way to just ignore). </font><font style="vertical-align: inherit;">It turns out great. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, put the ROM.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I took the W27C512 because it‚Äôs cheap, cheerful, everything will fit and you can also bank. 64KiB! 4 firmware can be uploaded. Well, I have about a million of these microcircuits. I decided that I would only sew the upper half, since on Harlequin the A15 leg is tied to + 5V, and the A14 is adjustable with a jumper. Thus, I can test the firmware on Harlequin so as not to mess around for a long time. Smorim </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datasheet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . We put the chip on the breadboard. Again, I put it in the right corner to place the address bus on the left. We pull leg A15 to power, A14 wiring to the ground. Wiring - this is so that you can change the memory banks. Since the A15 will always be at a high level, only the top 32 KiB flash drives will be available to us. Of these, the A14 line will select the upper (+ 5V) or lower (ground) 16 KiB. In them, I filled the </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">test image with the</font></a><font style="vertical-align: inherit;"> programmer</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">48K BASIC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> firmware </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The remaining 14 address lines (A0 - A13) are connected to the address bus on the left. We connect the data bus (Q0 - Q7) to our improvised bus in the form of power buses from the breadboard models. Do not forget about food!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now the control signals. </font><font style="vertical-align: inherit;">OE is an output enable. </font><font style="vertical-align: inherit;">We need the ROM to send data to the data bus when the processor reads it. </font><font style="vertical-align: inherit;">So we connect directly to the output of the RD processor. </font><font style="vertical-align: inherit;">Conveniently, both pins, both OE on ROM and RD on the processor, are active in a low state. </font><font style="vertical-align: inherit;">This is important; you don‚Äôt need to invert anything. </font><font style="vertical-align: inherit;">In addition, the ROM has a CS input, also active in a low state. </font><font style="vertical-align: inherit;">If this input is not active, the ROM will ignore all other signals and will not output anything to the data bus. </font><font style="vertical-align: inherit;">We will connect this input to the Y0 pin (15 pin) of the 74HC138 chip, which is also active in the low state. </font><font style="vertical-align: inherit;">In the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harlequin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> circuit, </font><font style="vertical-align: inherit;">this signal, for some reason, is connected through a resistor. </font><font style="vertical-align: inherit;">We will do the same. </font><font style="vertical-align: inherit;">Why, I don‚Äôt know. </font><font style="vertical-align: inherit;">Maybe smart people tell me in the comments ... </font><i><font style="vertical-align: inherit;">They told</font></i><font style="vertical-align: inherit;"> me </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Thank,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sterr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><blockquote>  .       ,    ¬´¬ª .            .</blockquote></i><br>
<br>
<img src="https://habrastorage.org/webt/1k/n7/h3/1kn7h3nfgruh121jefz2qfhucts.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now RAM. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is more difficult with it, since not only the processor, but also ULA, or, in our case, Arduino, work with RAM (with our 16 KiB). Since it is necessary to read something that is displayed on the screen. Therefore, we need to be able to disconnect control signals and the RAM address bus from the processor. We will not disconnect the data bus, we will act as in the original spectrum (and in Harlequin): we will divide the bus with resistors (470-500 Ohms). On the one hand, the resistors will be the processor and ROM, on the other hand, RAM and Arduino. Thus, in the event of a conflict on the data bus, it will work as 2 separate buses. But for the rest we use </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">74HC245</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harlequin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (U43, U44 in the diagram), although in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">present Speccy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there were also resistors (between IC1 on the one hand, this is ULA, and IC3, IC4 on the other). </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The 74HC245</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is an 8-bit bus buffer. But we have 2 control signals (RD - in the case of reading from memory and CE for activating the RAM itself. We will deal with WR in the case of writing to memory later) and 14 bits of the address: remember, above we already generate a signal to the memory using 74HC138 only in the event that the processor activated A14 with A15 inactive, so we do not need to do any additional decoding of the address, the memory will work only when accessing the first 16 KiB after the ROM. Well, of course, to address 16 KiB you need just 14 address lines (A0-A13). In total, 16 signals are obtained, so we need 2 74HC245 microcircuits. We connect them to the breadboard on the left, in place of the address bus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From the datasheet on the 74HC245 it is clear that, in general, it doesn‚Äôt matter which side to connect the microcircuits to, but since I started to build up the layouts from the bottom up, and all the other microcircuits are installed with the first pin to the left, the address bus will connect to side A (pins 2 -9 chips, in the datasheet are designated as A0-A7). The transfer direction is always from the processor to the RAM, since the RAM never sets the address, but only receives it. In the 74HC245, pin 1 (DIR) is responsible for the direction of transmission. According to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datasheet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that on the B side there is an output equal to the input on the A side, the DIR must be set to HIGH. So connect the 1st pin of both circuits to + 5V. OE (20th pin, activated by a low level) is connected using wiring to the ground so that it can be quickly switched to + 5V and disconnected from the processor. Further simpler. Connect the power for both chips. The rightmost pins of the right microcircuit (8th and 9th pins, inputs A6 and A7) will be control signals. I connected A7 to the RD terminal of the processor, and A6 to the Y1 pin of the 74HC138 chip, since there will be a low level only when the processor accesses our RAM. The remaining conclusions from side A of both microcircuits (legs 2‚Äì9 for the left and legs 2‚Äì7 for the right) I connected to the address bus, terminals A13-A0. We do not need the upper 2 bits of the address, because they are already decoded in the signal from the 74HC138.Now about the RAM itself. Naturally, I used what I already had: a cache chip from the old motherboard. I came across</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IS61C256</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> at 20 ns, but any will do. Speccy worked at a frequency of 3.5 MHz, but for now we will generally be treating Arduinki. If 100 kHz comes out, there will be happiness! So, we connect. Of course, do not forget about food. Conclusions I / O0 - I / O7 are connected to the breadboard of the data bus AFTER the resistors. I was lucky (in fact, not), on my Chinese mockups, the power buses are divided exactly in the middle. I used this feature to separate the bus with resistors. If your layouts are wrong, you have to be </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perverted</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make a second data bus, and connect it with resistors to the first. The conclusions of A0-A13 are thrown at the corresponding B-conclusions of the 74HC245 chips, not forgetting that the rightmost ones are connected not to the data bus, but to the control signals. A14 - by choice, either to the ground, or to + 5V. A 32 KiB chip, so this conclusion will determine which half we will use. If you find a 16 KiB SRAM, there will be no A14 line in it. The outputs are WE (write enable), CE (chip enable) and OE (output enable). All are activated low. OE must be connected to the processor‚Äôs RD, but, of course, not directly, but through the right 74HC245, where the RD comes to my A7 foot, and accordingly comes out of the B7 foot (11th pin). There and connect. CE must be connected to Y1 from the 74HC138, which decodes the address. Her signal comes to me on the A6 of the right chip 74HC245, respectively,comes out of foot B6 (12 pins). WE I directly connected to the output of the WR processor. I also installed a jumper wire from the OE signal and stuck it just in the unused part of the layout. By connecting this wire to the power ground, I can force the RAM to be activated when I read it from Arduinka. Still, I pulled all the control signals of the RAM to + 5V using resistors of 10 kOhm. Just in case. It turned out like this:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9y/0k/3h/9y0k3ht6ehvrsvzoehp70h428mo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, here, and if at all, at the very beginning, there should be an educational program on the timing of signals on the tires. I will not do this, since it has been done many times on the network by much more intelligent people than me. For those interested, I can recommend this video:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/i_wrxBdXTgM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, if you are not subscribed to this channel and are interested in electronics as an amateur, and not as a professional, I highly recommend it to you. This is a very high quality content. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, that‚Äôs almost all. Now you just need to understand how to read data from RAM in Arduino. To begin with, let's calculate how many Arduinki conclusions we need. We need to give a clock signal and control the RESET, these are 2 pins. 8 bits of data bus - another 8 pins. Plus 13 bits of address, total 23 pins. In addition, we need to communicate with Arduinka, we will do this through her serial interface, this is another 2 pins. Unfortunately, there are only 20 conclusions on my DNA.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, it doesn‚Äôt matter. I do not know a single person who has Arduino and does not have 74HC595. It seems to me that they are sold only in the kit. At least I only have 74HC00 chips more than 595x. So we use them. Moreover, I will save space in the article, because the work of the 595x with arduino is perfectly described </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. 595mi we will generate the address. The chip will need 2 pieces (since we have 13 bits of the address, and the 595th has 8 pins). How to connect several 595x for bus expansion is described in detail at the link above. I only note that in the examples at that link OE (pin 13) 595x is pulled to the ground. We categorically will not do this, we will send a signal from Arduinki there, since the 595x pins will be connected directly to the RAM address bus, and we do not need any spurious signal there. After connecting the 595x pins to the RAM address bus, nothing more needs to be done on the mock-ups. Time to connect the arduinka. But first, write a sketch:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// CPU defines</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CPU_CLOCK_PIN 2</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CPU_RESET_PIN 3</span><font></font>
<font></font>
<span class="hljs-comment">// RAM defines</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_OUTPUT_ENABLE_PIN 4</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_WRITE_ENABLE_PIN 5</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_CHIP_ENABLE_PIN 6</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_BUFFER_PIN 7</span><font></font>
<font></font>
<span class="hljs-comment">// Shift Register defines</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_DATA_PIN 8</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_OUTPUT_ENABLE_PIN 9</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_LATCH_PIN 10</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_CLOCK_PIN 11</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{<font></font>
  <span class="hljs-comment">// All CPU and RAM control signals need to be configured as inputs by default</span><font></font>
  <span class="hljs-comment">// and only changed to outputs when used.</span><font></font>
  <span class="hljs-comment">// Shift register control signals may be preconfigured</span><font></font>
<font></font>
  <span class="hljs-comment">// CPU controls seetup</span><font></font>
  DDRC = B00000000;<font></font>
  pinMode(CPU_CLOCK_PIN, INPUT);<font></font>
  pinMode(CPU_RESET_PIN, INPUT);<font></font>
<font></font>
  <span class="hljs-comment">// RAM setup</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_BUFFER_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_BUFFER_PIN, LOW);<font></font>
<font></font>
  <span class="hljs-comment">// SR setup</span><font></font>
  pinMode(SR_LATCH_PIN, OUTPUT);<font></font>
  pinMode(SR_CLOCK_PIN, OUTPUT);<font></font>
  pinMode(SR_DATA_PIN, OUTPUT);<font></font>
  pinMode(SR_OUTPUT_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
<font></font>
  <span class="hljs-comment">// common setup</span><font></font>
  Serial.begin(<span class="hljs-number">9600</span>);<font></font>
  Serial.println(<span class="hljs-string">"Hello"</span>);<font></font>
}<span class="hljs-comment">// setup</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shiftReadValueFromAddress</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> address, <span class="hljs-keyword">uint8_t</span> *value)</span> </span>{<font></font>
  <span class="hljs-comment">// disable RAM output</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_WRITE_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  <span class="hljs-comment">// set address</span><font></font>
  digitalWrite(SR_LATCH_PIN, LOW);<font></font>
  shiftOut(SR_DATA_PIN, SR_CLOCK_PIN, MSBFIRST, address&gt;&gt;<span class="hljs-number">8</span>); <font></font>
  shiftOut(SR_DATA_PIN, SR_CLOCK_PIN, MSBFIRST, address);  <font></font>
  digitalWrite(SR_LATCH_PIN, HIGH);<font></font>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, LOW); <span class="hljs-comment">// active low</span><font></font>
  <span class="hljs-comment">// write value to RAM</span><font></font>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, LOW); <span class="hljs-comment">// active low</span><font></font>
  delay(<span class="hljs-number">1</span>);<font></font>
  DDRC = B00000000;<font></font>
  *value = PINC;<font></font>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  <span class="hljs-comment">// disable SR</span><font></font>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
}<span class="hljs-comment">// shiftWriteValueToAddress</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">runClock</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> cycles)</span> </span>{<font></font>
  <span class="hljs-keyword">uint32_t</span> currCycle = <span class="hljs-number">0</span>;<font></font>
  pinMode(CPU_CLOCK_PIN, OUTPUT);<font></font>
  <span class="hljs-keyword">while</span>(currCycle &lt; cycles) {<font></font>
    digitalWrite(CPU_CLOCK_PIN, HIGH);<font></font>
    digitalWrite(CPU_CLOCK_PIN, LOW);<font></font>
    currCycle++;<font></font>
  }<font></font>
  pinMode(CPU_CLOCK_PIN, INPUT);<font></font>
}<span class="hljs-comment">// runClock</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trySpectrum</span><span class="hljs-params">()</span> </span>{<font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
  pinMode(CPU_RESET_PIN, OUTPUT);<font></font>
  digitalWrite(CPU_RESET_PIN, LOW);<font></font>
  runClock(<span class="hljs-number">30</span>);<font></font>
  digitalWrite(CPU_RESET_PIN, HIGH);<font></font>
  runClock(<span class="hljs-number">12500000</span>);<font></font>
}<span class="hljs-comment">// trySpectrum</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">readDisplayLines</span><span class="hljs-params">()</span> </span>{<font></font>
  <span class="hljs-keyword">uint8_t</span> value;<font></font>
  digitalWrite(RAM_BUFFER_PIN, HIGH);<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_CHIP_ENABLE_PIN, LOW);<font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">uint16_t</span> i=<span class="hljs-number">16384</span>; i&lt;<span class="hljs-number">16384</span>+<span class="hljs-number">6144</span>;i++) {<font></font>
    shiftReadValueFromAddress(i, &amp;value);<font></font>
    Serial.println(value);<font></font>
  }<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, INPUT);<font></font>
}<span class="hljs-comment">// readDisplayLines</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{<font></font>
  trySpectrum();<font></font>
  Serial.println(<span class="hljs-string">"Hope we are ok now. Please set up memory for reading"</span>);<font></font>
  delay(<span class="hljs-number">40000</span>);<font></font>
  Serial.println(<span class="hljs-string">"Reading memory"</span>);<font></font>
  readDisplayLines();<font></font>
  Serial.println(<span class="hljs-string">"Done"</span>);<font></font>
  delay(<span class="hljs-number">100000</span>);<font></font>
}<span class="hljs-comment">// loop</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see from the sketch (well, really, suddenly, someone read it), I read the data bus to port C. As Arduischik can remember, in CID port C is 6 pins. That is, I read only 6 bits. Yes, for the simplicity of the process, I ignore the 2 high bits in each byte of the screen buffer. This will result in the fact that every 2 pixels after 6 there will always be background colors. While a ride, then fix it. This is the skeleton. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now for the connection itself. In principle, everything is painted at the very top of the sketch:</font></font><br>
<br>
<pre><code class="plaintext hljs">// CPU defines<font></font>
#define CPU_CLOCK_PIN 2 -  2     6  ( )<font></font>
#define CPU_RESET_PIN 3 -  3     26  (RESET)<font></font>
<font></font>
// RAM defines<font></font>
#define RAM_OUTPUT_ENABLE_PIN 4 -  4     22  (OE)<font></font>
#define RAM_WRITE_ENABLE_PIN 5 -  5    .     .<font></font>
#define RAM_CHIP_ENABLE_PIN 6 -  6     .        ,        .   - ,   -  .   ,   .<font></font>
#define RAM_BUFFER_PIN 7 -  ,    6,    .<font></font>
<font></font>
// Shift Register defines<font></font>
#define SR_DATA_PIN 8   -  8     14 "" 595.        9 ,     .<font></font>
#define SR_OUTPUT_ENABLE_PIN 9 -   13  595<font></font>
#define SR_LATCH_PIN 10 -   12  595<font></font>
#define SR_CLOCK_PIN 11 -   11  595.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything is simple. Here's how it looks like everything in my collection (the arduinka was cut in the picture, but there isn‚Äôt much to see): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pj/q5/si/pjq5siebaxafimb_nqnjxyry6_u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At startup, Arduino cheerfully says Hello to the serial port of the computer (albeit virtual), and starts tormenting the processor. Having thoroughly tortured him (a couple of minutes), the program will stop the poor guy and will offer you to rearrange the jumpers with the pens on the breadboard, disconnecting the memory from the address bus and processor control signals. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we need to use the handles to rearrange the wiring connected to pins 19 of both 74HC245 from the ground to + 5V. Thus, we disconnect the processor from RAM. Pin 22 of the RAM chip itself must be connected to the ground (I wrote above about the wiring, which I just stuck in the breadboard so far, in an unused place). Thus, we forcibly turn on the RAM.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After that, having waited a little, Arduinka will begin to read the contents of the memory and output it in a column to the serial port. There will be many, many numbers. Now you can copy this data from there and paste it, say, into a text file, without forgetting to clean up all unnecessary text (a couple of lines at the top, and ‚ÄúDone‚Äù at the bottom), we only need numbers. This is what our Speccy recorded in video memory. It remains only to see what was there in the video memory. And the Spectrum‚Äôs video memory is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not easy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, the pixels themselves are stored separately from the color. We will ignore the color for now, let's read only the pixels themselves. But they are not so easy to decode. After much pain in Visual Studio, I came to this elegant solution:</font></font><br>
<br>
<pre><code class="cpp hljs"><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND, UINT, WPARAM, LPARAM)</span></span>;<font></font>
<span class="hljs-keyword">uint8_t</span> *scrData;<font></font>
<font></font>
<span class="hljs-function">VOID <span class="hljs-title">OnPaint</span><span class="hljs-params">(HDC hdc)</span> </span>{<font></font>
	<span class="hljs-keyword">size_t</span> arrSize = <span class="hljs-number">6144</span>;<span class="hljs-comment">//sizeof(scrData) / sizeof(scrData[0]);</span><font></font>
	<span class="hljs-comment">//int currRow = 0, currX = 0, currBlock = 0, currY = 0, currBase = 0;</span><font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> arrPos = <span class="hljs-number">0</span>; arrPos &lt; arrSize; arrPos++) {<font></font>
		<span class="hljs-keyword">int</span> blockPos = arrPos % <span class="hljs-number">2048</span>;<font></font>
		<span class="hljs-keyword">int</span> currBase = (blockPos % <span class="hljs-number">256</span>) / <span class="hljs-number">32</span>;<font></font>
		<span class="hljs-keyword">int</span> currX = blockPos % <span class="hljs-number">32</span>;<font></font>
		<span class="hljs-keyword">int</span> currBlock = arrPos / <span class="hljs-number">2048</span>;<font></font>
		<span class="hljs-keyword">int</span> currRow = blockPos / <span class="hljs-number">256</span>;<font></font>
		<span class="hljs-keyword">int</span> currY = currBlock * <span class="hljs-number">64</span> + currBase * <span class="hljs-number">8</span> + currRow;<font></font>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> trueX = <span class="hljs-number">0</span>; trueX &lt; <span class="hljs-number">8</span>; trueX++) {<font></font>
			<span class="hljs-keyword">char</span> r = ((scrData[arrPos] &gt;&gt; trueX) &amp; <span class="hljs-number">1</span>)*<span class="hljs-number">255</span>;<font></font>
			SetPixel(hdc, currX * <span class="hljs-number">8</span> + (<span class="hljs-number">8</span>-trueX), currY, RGB(r, r, r));<font></font>
		}<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadData</span><span class="hljs-params">()</span> </span>{<font></font>
	FILE *file;<font></font>
	<span class="hljs-keyword">errno_t</span> err;<font></font>
	<span class="hljs-keyword">if</span> ((err = fopen_s(&amp;file, <span class="hljs-string">"data.txt"</span>, <span class="hljs-string">"r"</span>))) {<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, <span class="hljs-string">L"Unable to oopen the file"</span>, <span class="hljs-string">L"Error"</span>, <span class="hljs-number">1</span>);<font></font>
	}<font></font>
	scrData = (<span class="hljs-keyword">uint8_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">6144</span>);<font></font>
	<span class="hljs-keyword">int</span> currDataPos = <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">char</span> buffer[<span class="hljs-number">256</span>];<font></font>
	<span class="hljs-keyword">char</span> currChar = <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">int</span> currLinePos = <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">while</span> (currChar != EOF) {<font></font>
		currChar = getc(file);<font></font>
		buffer[currLinePos++] = currChar;<font></font>
		<span class="hljs-keyword">if</span> (currChar == <span class="hljs-string">'\n'</span>) {<font></font>
			buffer[currLinePos] = <span class="hljs-number">0</span>;<font></font>
			scrData[currDataPos++] = (<span class="hljs-keyword">uint8_t</span>)atoi(buffer);<font></font>
			currLinePos = <span class="hljs-number">0</span>;<font></font>
		}<font></font>
	}<font></font>
	fclose(file);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">INT WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE, PSTR, INT iCmdShow)</span> </span>{<font></font>
	HWND                hWnd;<font></font>
	MSG                 msg;<font></font>
	WNDCLASS            wndClass;<font></font>
	wndClass.style = CS_HREDRAW | CS_VREDRAW;<font></font>
	wndClass.lpfnWndProc = WndProc;<font></font>
	wndClass.cbClsExtra = <span class="hljs-number">0</span>;<font></font>
	wndClass.cbWndExtra = <span class="hljs-number">0</span>;<font></font>
	wndClass.hInstance = hInstance;<font></font>
	wndClass.hIcon = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
	wndClass.hCursor = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);<font></font>
	wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<font></font>
	wndClass.lpszMenuName = <span class="hljs-literal">NULL</span>;<font></font>
	wndClass.lpszClassName = TEXT(<span class="hljs-string">"GettingStarted"</span>);<font></font>
	RegisterClass(&amp;wndClass);<font></font>
	hWnd = CreateWindow(<font></font>
		TEXT(<span class="hljs-string">"GettingStarted"</span>),   <span class="hljs-comment">// window class name</span><font></font>
		TEXT(<span class="hljs-string">"Getting Started"</span>),  <span class="hljs-comment">// window caption</span><font></font>
		WS_OVERLAPPEDWINDOW,      <span class="hljs-comment">// window style</span><font></font>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial x position</span><font></font>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial y position</span><font></font>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial x size</span><font></font>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial y size</span><font></font>
		<span class="hljs-literal">NULL</span>,                     <span class="hljs-comment">// parent window handle</span><font></font>
		<span class="hljs-literal">NULL</span>,                     <span class="hljs-comment">// window menu handle</span><font></font>
		hInstance,                <span class="hljs-comment">// program instance handle</span><font></font>
		<span class="hljs-literal">NULL</span>);                    <span class="hljs-comment">// creation parameters</span><font></font>
	loadData();<font></font>
	ShowWindow(hWnd, iCmdShow);<font></font>
	UpdateWindow(hWnd);<font></font>
	<span class="hljs-keyword">while</span> (GetMessage(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) {<font></font>
		TranslateMessage(&amp;msg);<font></font>
		DispatchMessage(&amp;msg);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> msg.wParam;<font></font>
}  <span class="hljs-comment">// WinMain</span><font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>{<font></font>
	HDC          hdc;<font></font>
	PAINTSTRUCT  ps;<font></font>
	<span class="hljs-keyword">switch</span> (message) {<font></font>
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		hdc = BeginPaint(hWnd, &amp;ps);<font></font>
		OnPaint(hdc);<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		PostQuitMessage(<span class="hljs-number">0</span>);<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">default</span>:<font></font>
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);<font></font>
	}<font></font>
} <span class="hljs-comment">// WndProc</span><font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The program opens the data.txt file from its directory. </font><font style="vertical-align: inherit;">In this file, the text output of the arduino (after deleting all the extra lines, as mentioned above.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We feed it the resulting file, and as a result: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tv/ai/3f/tvai3fcvvg-y53dlrcxogjo9o-c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yes, while the result is very far from ideal, but it is definitely the output to the screen. </font><font style="vertical-align: inherit;">Moreover, the one that is needed. </font><font style="vertical-align: inherit;">From ROM with diagnostic firmware. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, the computer skeleton is ready. </font><font style="vertical-align: inherit;">Yes, it‚Äôs impossible to use it yet, but you can see how extremely simple the old 8-bit computers were arranged. </font><font style="vertical-align: inherit;">I still beat a little over the breadboard, but the conclusion only got worse. </font><font style="vertical-align: inherit;">It seems that the next step is to solder on a normal, unsoldered breadboard, with normal power. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But is it necessary?</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en498208/index.html">Security Week 17: Implications of Linux Server Attack</a></li>
<li><a href="../en498214/index.html">Maria Popova: ‚ÄúSome first learned about OpenStreetMap due to the fact that they marked hogweed on the map‚Äù</a></li>
<li><a href="../en498216/index.html">Coloring texts in html and React</a></li>
<li><a href="../en498218/index.html">As I wrote music from cosmic rays</a></li>
<li><a href="../en498220/index.html">How coronavirus (COVID-XX) can help 1C take over the world?</a></li>
<li><a href="../en498224/index.html">Create an interactive exhibit with .NET, Azure Functions and the magic of cognitive services</a></li>
<li><a href="../en498226/index.html">Decomposition. How to disassemble a huge project into understandable segments for a preliminary assessment</a></li>
<li><a href="../en498234/index.html">Real Management Myths About DevOps</a></li>
<li><a href="../en498238/index.html">Electrically conductive polymer: how scientists made plastic from metal</a></li>
<li><a href="../en498242/index.html">Using storage in media content</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>