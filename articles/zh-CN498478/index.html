<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍳 🧗 🌷 什么是Windows PowerShell？它吃什么？第5部分：访问外部对象 🧑🏿‍🤝‍🧑🏻 📭 👩🏿‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Windows操作系统支持各种对象基础结构。您可以使用应用程序编程接口（API）来访问它们，但是开发成熟的应用程序并不总是合理的。PowerShell具有特殊的cmdlet，允许您以交互方式访问.NET，COM，WMI（CIM）和ADSI对象。在本系列的第四部分中，我们以.NET Core类为重点学...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>什么是Windows PowerShell？它吃什么？第5部分：访问外部对象</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/498478/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/-b/i_/73/-bi_73lwdxmnzvtveeghrwvtqay.png"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows操作系统支持各种对象基础结构。</font><font style="vertical-align: inherit;">您可以使用应用程序编程接口（API）来访问它们，但是开发成熟的应用程序并不总是合理的。</font><font style="vertical-align: inherit;">PowerShell具有特殊的cmdlet，允许您以交互方式访问.NET，COM，WMI（CIM）和ADSI对象。</font><font style="vertical-align: inherit;">在本</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系列</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">第四部分中，</font></a><font style="vertical-align: inherit;">我们以.NET Core类为重点学习了基础知识，现在，我们想加深主题并了解PowerShell与外部对象交互的功能。</font></font><a name="habracut"></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目录：</font></font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用JSON，XML和CSV </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用WMI和CIM </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用COM对象</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用ADSI目录服务</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">格式化输出</font></font></a><br>
<br>
<a name="section1"></a><h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用JSON，XML和CSV</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在PowerShell脚本中，您通常必须解析JSON，XML和CSV数据。通常，在使用Internet服务或配置文件时会出现这种需求。一些管理员尝试使用正则表达式解析数据，但是没有必要做出这样的牺牲：PowerShell具有用于双向转换的特殊cmdlet。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ep/q6/tr/epq6trkxgw_sfw21p1wmfixyrfk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSON格式允许您描述各种对象，并且实质上是可以嵌套的哈希表。</font><font style="vertical-align: inherit;">相应地，使用PowerShell将JSON对象转换为.NET对象很容易。</font><font style="vertical-align: inherit;">由于Internet服务通常会提供很长的行而不是格式精美的文件，因此此转换对于以交互方式工作也很有用。</font><font style="vertical-align: inherit;">在下面的示例中，我们使用多行文本变量来描述JSON对象：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$user</span> = <span class="hljs-string">@"
{
   "firstName": "Ivan",
   "lastName": "Danko",
   "address": {
       "streetAddress": "Kremlin",
       "city": "Moscow"
   },
   "phoneNumbers": [
       "+7 495 1234567",
       "+7 499 1234567"
   ]
}
"@</span> | <span class="hljs-built_in">ConvertFrom-Json</span>
</code></pre><br>
<img src="https://habrastorage.org/webt/vu/2j/x6/vu2jx6vrks90qvsuoehs6ky43ke.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
反问题以类似的方式解决：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$file</span> = <span class="hljs-built_in">Get-ChildItem</span> C:\Windows\System32\notepad.exe
<span class="hljs-variable">$file</span>.VersionInfo | <span class="hljs-built_in">ConvertTo-Json</span></code></pre><br>
<img src="https://habrastorage.org/webt/rd/tb/dq/rdtbdqlfwsepqmnggw_2uk7omkw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生成的JSON格式字符串很容易通过网络发送到另一个应用程序。</font><font style="vertical-align: inherit;">例如，它可以是某些RESTful服务。</font><font style="vertical-align: inherit;">使用ConvertFrom-Csv，ConvertTo-Csv和ConvertTo-Xml cmdlet的方式大致相同，我们建议读者自己研究它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要使用XML和CSV，我们将需要其他cmdlet：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jz/hy/m7/jzhym7nqvb5id7fvdys9ao59meq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用这些工具，您需要了解将二进制对象转换为文本格式仅保存其属性的值，而不保存方法的值。</font><font style="vertical-align: inherit;">仅在有效的情况下，才能使用PowerShell将JSON，XML或CSV数据转换为.NET对象。</font></font><br>
<br>
<a name="section2"></a><h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用WMI和CIM</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows Management Instrumentation（WMI）是WBEM（基于Web的企业管理）标准的Microsoft开发和Windows适应的实现。它基于创建通用解决方案以监视企业的分布式信息环境并管理其组件的想法。 WBEM数据结构又基于公共信息模型（CIM），该模型实现了一种面向对象的方法来表示计算机系统。 Windows中WMI的进一步开发和支持已经停止； Microsoft建议使用类似的机制来管理基础结构-CIM对象。为了与它们一起使用，特殊的cmdlet出现在PowerShell 3.0中，我们将与WMI对应的cmdlet一起考虑。如果代码包含使用WMI的cmdlet调用，则应尽可能重写它。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h6/io/mw/h6iomwnjjrssdkl_tw7gi0mwjhm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在CIM模型的框架（在WMI中也使用）中，操作系统数据以具有属性和方法的类的形式表示。类按照名称空间技术或管理区域按层次结构排序并在逻辑上相关。有一个根Root名称空间，它具有以下子空间：CIMv2，Default，Secutiry和WMI。为了明确标识类（对象）的实例并描述相应资源的状态，使用了类属性，这些属性通常是只读的。方法用于管理资源。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以通过完整路径访问类实例，该路径具有以下形式：</font></font><br>
<br>
<pre><code class="powershell hljs">[\\<span class="hljs-type">ComputerName</span>\<span class="hljs-type">NameSpace</span>][:<span class="hljs-type">ClassName</span>][<span class="hljs-type">.KeyProperty1</span>=<span class="hljs-type">Value1</span>][,<span class="hljs-type">KeyProperty2</span>=<span class="hljs-type">Value2</span>]…]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其中</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ComputerName是计算机的名称；</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NameSpace-名称空间；</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ClassName-类的名称；</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
KeyProperty1 =值1，KeyProperty2 =值2-对象的属性以及用于标识对象的值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在PowerShell之前，不存在简单的WMI工具。</font><font style="vertical-align: inherit;">要访问这些对象，您必须使用高级语言（C ++，Visual Basic，Java Script）编写相当复杂的程序，或者使用自己的语言研究WMIC shell（WMI命令行，也已停产）。</font><font style="vertical-align: inherit;">通过PowerShell，普通用户可以通过命令行或脚本访问WMI对象。</font><font style="vertical-align: inherit;">首先，连接到WMI子系统，并使用Get-WmiObject cmdlet（别名gwmi）获得可用类的列表。</font><font style="vertical-align: inherit;">若要获取CIM类的列表，请使用Get-CimClass cmdlet。</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-built_in">Get-CimClass</span>
<span class="hljs-built_in">Get-WmiObject</span> <span class="hljs-literal">-List</span></code></pre><br>
<img src="https://habrastorage.org/webt/g7/1z/wz/g71zwzueejpnyrgwqkoqpxlwn7a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们已经在本地计算机上列出了这些类，但是您可以连接到远程计算机：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-built_in">Get-CimClass</span> <span class="hljs-literal">-ComputerName</span> IP- 
<span class="hljs-built_in">Get-CimClass</span> <span class="hljs-literal">-ComputerName</span> _</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要么</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-built_in">Get-WmiObject</span> <span class="hljs-literal">-ComputerName</span> IP- <span class="hljs-literal">-List</span>
<span class="hljs-built_in">Get-WmiObject</span> <span class="hljs-literal">-ComputerName</span> _ <span class="hljs-literal">-List</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
默认情况下，Get-CimClass和Get-WmiObject cmdlet连接到Root \ CIMV2名称空间，该名称空间存储了大量用于管理系统的类。</font><font style="vertical-align: inherit;">要更改名称空间，请使用-Namespace参数：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-built_in">Get-CimClass</span> <span class="hljs-literal">-Namespace</span> Root
<span class="hljs-built_in">Get-WmiObject</span> <span class="hljs-literal">-Namespace</span> Root <span class="hljs-literal">-List</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
知道了类的名称后，获取它的实例并不难。</font><font style="vertical-align: inherit;">以下命令返回Win32_Service的所有实例，即 </font><font style="vertical-align: inherit;">在本地计算机上注册的服务：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-built_in">Get-WmiObject</span> Win32_Service</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与其他类型的对象一样，使用Get-Member显示属性和方法的列表。</font><font style="vertical-align: inherit;">WMI对象方法可以直接访问，也可以使用Invoke-WmiMethod cmdlet访问。</font><font style="vertical-align: inherit;">您还可以将cmdlet用于WMI对象以进行排序，过滤，分组等。</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-built_in">Get-WmiObject</span> Win32_Service | <span class="hljs-built_in">Get-Member</span></code></pre><br>
<img src="https://habrastorage.org/webt/pq/rn/nk/pqrnnkbv1abfqzn5hlnsgunzamu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
若要获取CIM对象（类的实例），请使用Get-CimInstance cmdlet。</font><font style="vertical-align: inherit;">与WMI不同，生成的CIM对象（结果对象或类实例）不包含类方法。</font><font style="vertical-align: inherit;">由于无法直接提取方法，因此必须调用Invoke-CimMethod cmdlet。</font><font style="vertical-align: inherit;">考虑Win32_Service类-在系统上运行的服务）及其在本地计算机上的后台打印程序服务的实例：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-built_in">Get-CimInstance</span> Win32_service <span class="hljs-literal">-filter</span> <span class="hljs-string">"Name='spooler'"</span> </code></pre><br>
<img src="https://habrastorage.org/webt/qm/jf/cz/qmjfcz-_u-le6js9tibb3qc5y2i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看一下结果对象的结构：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-built_in">Get-CimInstance</span> Win32_service <span class="hljs-literal">-filter</span> <span class="hljs-string">"Name='spooler'"</span> | <span class="hljs-built_in">Get-Member</span></code></pre><br>
<img src="https://habrastorage.org/webt/t4/uo/ub/t4uoublc7mxrlb6khyrycfozod4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这一点上，使用cmdlet处理CIM对象的好处尚不明显。</font><font style="vertical-align: inherit;">它们主要涉及分布式环境中的远程工作，并且将在致力于解决实际管理问题的系列的最后一篇文章中进行详细讨论。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有一个特定于WMI的工具包：WMI查询语言（WQL），一种类似SQL的查询语言。</font><font style="vertical-align: inherit;">启动服务系统时，用于搜索所有初创公司的WQL查询如下所示：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-built_in">select</span> * from win32_service <span class="hljs-built_in">where</span> startmode=<span class="hljs-string">"Auto"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在PowerShell中，它们执行如下：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-built_in">Get-WmiObject</span> <span class="hljs-literal">-Query</span> <span class="hljs-string">'select * from win32_service where startmode="Auto"'</span></code></pre><br>
<img src="https://habrastorage.org/webt/wc/y7/wf/wcy7wfk7619yx_9es0cjz9bi4vw.png"><br>
<br>
<a name="section3"></a><h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用COM对象</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了确保Windows中应用程序之间的交互，开发了一种用于链接和嵌入对象的技术（对象链接和嵌入或OLE）。后来，出现了OLE自动化技术，借助该技术，自动化客户端应用程序可以调用其他应用程序的功能-自动化服务器。 OLE和OLE Automation基于组件对象模型（COM）的核心技术，该组件对象模型为软件组件提供了一个二进制标准。使用它创建并在操作系统中注册的对象可以在其他应用程序中使用可执行文件或动态库来使用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在90年代中期，代替OLE，开始使用另一个术语-ActiveX。</font><font style="vertical-align: inherit;">在.NET平台出现之前，ActiveX技术被认为是关键，并且COM对象仍被积极地用于将应用程序集成到Windows中-许多Microsoft和第三方产品都是自动化服务器，并通过它们提供对服务的访问。</font><font style="vertical-align: inherit;">为了访问对象，使用ProgID-在Windows注册表中注册时分配给它们的符号标识符。</font><font style="vertical-align: inherit;">它具有以下形式：</font></font><br>
<br>
<pre><code class="powershell hljs">_..</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常不指示版本：</font></font><br>
<br>
<pre><code class="powershell hljs">_.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可用的ProgID的一些示例是：InternetExplorer.Application（Internet Explorer应用程序），Word.Application（Microsoft Word应用程序），WScript.Shell（Windows脚本宿主或WSH脚本服务器对象模型中的Shell类）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以使用上一篇文章中讨论的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New-Object cmdlet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建对象的实例</font><font style="vertical-align: inherit;">，并使用Get-Member查看其结构：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$myshell</span> = <span class="hljs-built_in">New-Object</span> <span class="hljs-literal">-ComObject</span> WScript.Shell
<span class="hljs-variable">$myshell</span> | <span class="hljs-built_in">Get-Member</span></code></pre><br>
<img src="https://habrastorage.org/webt/bk/s5/fh/bks5fhq3q-yhle1fwb4-vjkqpk0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要使用对象，必须使用属性和方法。</font><font style="vertical-align: inherit;">说，要在用户桌面上创建快捷方式，您需要调用CreateShortcut（）方法：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$link</span> = <span class="hljs-variable">$myshell</span>.CreateShortcut(<span class="hljs-string">"<span class="hljs-variable">$Home</span>\Desktop\Home.lnk"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，快捷方式也是一个COM对象：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$link</span> | <span class="hljs-built_in">Get-Member</span></code></pre><br>
<img src="https://habrastorage.org/webt/05/d8/4_/05d84_-mbzmfuffczrmr76khfyg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们仍然需要填写其属性并保存：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$link</span>.TargetPath = <span class="hljs-variable">$Home</span>
<span class="hljs-variable">$link</span>.Save()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样，我们在活动用户的桌面上创建了一个快捷方式，现在我们将使用Shell.Application COM对象的示例来分析使用外部自动化服务。</font><font style="vertical-align: inherit;">使用它，您可以在Windows资源管理器中自动执行一些操作：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$myshell</span>=<span class="hljs-built_in">New-Object</span> <span class="hljs-literal">-ComObject</span> Shell.Application</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
或简称：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$myshell</span>=<span class="hljs-built_in">New-Object</span> <span class="hljs-literal">-com</span> Shell.Application
<span class="hljs-variable">$myshell</span> | <span class="hljs-built_in">Get-Member</span></code></pre><br>
<img src="https://habrastorage.org/webt/__/iu/qy/__iuqyjf29nliwugz-jybihkfj0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Shell.Application对象具有许多不同的窗口管理方法。</font><font style="vertical-align: inherit;">例如，要显示给定目录的内容，请使用Explore（）：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$myshell</span>.Explore(<span class="hljs-string">"c:\"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用Help（）方法调用帮助系统：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$myshell</span>.Help()</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有三种调用搜索对话框的方法：FindFiles（），FindComputer（）和FindPrinter（）。</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$myshell</span>.FindFiles()
<span class="hljs-variable">$myshell</span>.FindComputer()
<span class="hljs-variable">$myshell</span>.FindPrinter()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以使用FileRun（）方法打开程序启动对话框，并且要调用日期/时间设置窗口，则需要SetTime（）方法。</font><font style="vertical-align: inherit;">例如，有用于调用任务栏设置窗口的方法，指示可用cpl文件之一的控制面板元素，用于管理打开的窗口的方法：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$myshell</span>.MinimizeAll()
<span class="hljs-variable">$myshell</span>.UndoMinimizeAll()
<span class="hljs-variable">$myshell</span>.TileHorizontally()
<span class="hljs-variable">$myshell</span>.TileVertically()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows（）方法允许您在资源管理器或Internet Explorer中访问打开的窗口的集合。</font><font style="vertical-align: inherit;">让我们看看该集合可用的属性和方法：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$myshell</span>.Windows() | <span class="hljs-built_in">Get-Member</span></code></pre><br>
<img src="https://habrastorage.org/webt/dq/ls/yo/dqlsyokgkrtk6rc-okuskmpwsvo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有其他有用的COM对象，其数量取决于系统中安装的软件。</font><font style="vertical-align: inherit;">曾几何时，Windows中的主要自动化工具是WSH脚本服务器，其对象模型还包括COM对象：旨在与我们已经提到的WScript.Network和WScript.Shell的网络功能一起使用。</font><font style="vertical-align: inherit;">后者不仅可以在桌面上创建快捷方式，还可以借助它的帮助显示例如带有消息和按钮的信息窗口，在应用程序之间切换，启动程序或模拟按键。</font></font><br>
<br>
<a name="section4"></a><h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用ADSI目录服务</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，目录是指信息源，其中存储了有关某些对象的数据。目录服务是指分布式计算机系统的一部分，该系统允许您访问和操作存储的对象。目录服务可以合并有关网络对象和对其进行操作的服务的数据，它代表与网络资源进行交互的单个入口点。异构计算机网络中可能有许多这样的服务：用于非域计算机的本地SAM（安全帐户管理器），Active Directory等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与不同目录服务的交互需要不同的工具，这会带来某些不便。从Windows 2000开始，Microsoft已为不依赖特定网络访问协议的操作系统引入了统一的Active Directory服务接口（ADSI）技术。为了找到对象，为目录定义了名称空间。由于不同的目录服务使用不同的命名方法，因此ADSI定义了一个唯一标识任何对象的约定。引入了两部分绑定字符串或ADsPath的概念。名称的第一部分定义目录服务（ADSI提供程序），第二部分-对象在目录中的位置。以下是指定不同ADSI提供程序的示例：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LDAP：//</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于基于LDAP的目录服务，包括 </font><font style="vertical-align: inherit;">用于Active Directory；</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WinNT：//</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于本地计算机。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在PowerShell中没有使用ADSI的特殊cmdlet。</font><font style="vertical-align: inherit;">而是使用强制转换运算符[ADSI]，后跟绑定字符串。</font><font style="vertical-align: inherit;">例如，要从域test.ru连接到用户Ivanov，需要以下构造：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$user</span> = [<span class="hljs-type">ADSI</span>]<span class="hljs-string">"LDAP://CN=Ivanov,DC=TEST,DC=RU"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要使用本地帐户，您将必须使用相应名称连接到计算机（要连接到本地计算机，只需使用点号代替名称）：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$computer</span> = [<span class="hljs-type">ADSI</span>]<span class="hljs-string">"WinNT://."</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，在本地计算机上创建一个新用户Ivanov：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$user</span> = <span class="hljs-variable">$computer</span>.Create(<span class="hljs-string">"user"</span>,<span class="hljs-string">"Ivanov"</span>)
<span class="hljs-variable">$user</span>.Put(<span class="hljs-string">"Description"</span>,<span class="hljs-string">"  PowerShell"</span>)
<span class="hljs-variable">$user</span>.SetInfo()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在连接到它：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$user1</span> = [<span class="hljs-type">ADSI</span>]<span class="hljs-string">"WinNT://./Ivanov,user"</span>
<span class="hljs-variable">$user1</span>.Description</code></pre><br>
<img src="https://habrastorage.org/webt/pb/9l/5m/pb9l5mpw09oocoetnw3x4iawzmm.png"><br>
<br>
<a name="section5"></a><h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输出格式</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
交互式工作通常需要显示数据。在其他Shell中，命令和实用程序本身用于格式化输出，但是函数和cmdlet返回的二进制对象通常不知道如何执行此操作。在PowerShell中，输出由四个特殊的cmdlet格式化，这些cmdlet通过管道馈送对象。可以使用Get-Help获得更多详细信息：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Format-Table以表的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形式格式化输出，该表的列包含对象属性的值或计算出的值。支持分组数据的功能；</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Format-List</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将对象显示为属性列表，每个属性都显示在新行上。支持分组数据的功能；</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">格式自定义</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用自定义视图格式化输出；</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宽</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">格式将对象</font><b><font style="vertical-align: inherit;">格式化</font></b><font style="vertical-align: inherit;">为一张宽表，其中每个对象仅显示一个属性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果未调用任何列出的cmdlet，则使用适合于所显示数据类型的格式化模块。显示规则以扩展名.ps1xml的XML格式存储在配置文件中，位于$ PSHome目录中。可以使用以下命令获取它们的列表：</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-built_in">dir</span> <span class="hljs-variable">$pshome</span>\*format*.ps1xm</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不建议手动编辑配置文件；最好使用Update-FormatData cmdlet创建自己的配置文件并将其包含在下载文件列表中。如果未定义所需类型的默认格式化程序，PowerShell将在列表中的屏幕上显示对象的属性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
到此结束了在PowerShell中使用对象的描述，本系列的最后一篇文章将致力于解决管理企业分布式信息环境的实际问题。在其中，所有描述的工具对我们都很有用。主要重点将放在CIM对象及其与WMI的比较上。过去的部分可以在下面的链接中找到。</font></font><br>
<br>
<hr><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> 1:   Windows PowerShell</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> 2:     Windows PowerShell</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> 3:      ,  </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> 4:   ,  </a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/iq/fi/b4/iqfib45pgphfrxv--zfemt0qnmw.jpeg"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN498458/index.html">具有虚拟背景和开源工具的视频通话</a></li>
<li><a href="../zh-CN498462/index.html">带有横幅的无限滚动，或者如何处理三个视图</a></li>
<li><a href="../zh-CN498466/index.html">激光和传感器如何帮助法官保持紧张</a></li>
<li><a href="../zh-CN498472/index.html">单页应用程序Docker映像</a></li>
<li><a href="../zh-CN498476/index.html">辅助功能 如何使残障用户可以访问该应用程序</a></li>
<li><a href="../zh-CN498482/index.html">情况：美国提供商被要求取消下载数据的门槛-最终</a></li>
<li><a href="../zh-CN498484/index.html">Wi-Fi 6和华为P40：连接在哪里？</a></li>
<li><a href="../zh-CN498486/index.html">如何在狭窄的细分市场中扩展搜索广告的英语语义</a></li>
<li><a href="../zh-CN498490/index.html">有效的认证体系，将使您成为更好的领导者</a></li>
<li><a href="../zh-CN498492/index.html">亲爱的，我们杀死官僚主义：数字化如何改变供应商与X5之间的对话</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>