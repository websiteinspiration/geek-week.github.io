<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚¨ÜÔ∏è ü§æüèº üà∂ Cr√©er roguelike dans Unity √† partir de z√©ro: g√©n√©rateur de donjon üë®üèª‚Äç‚úàÔ∏è üëäüèæ ü§Ω</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cette fois, nous allons plonger dans l'impl√©mentation de l'algorithme du g√©n√©rateur de donjon. Dans le dernier article, nous avons cr√©√© la premi√®re sa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Cr√©er roguelike dans Unity √† partir de z√©ro: g√©n√©rateur de donjon</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495588/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette fois, nous allons plonger dans l'impl√©mentation de l'algorithme du g√©n√©rateur de donjon. Dans le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dernier article,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous avons cr√©√© la premi√®re salle, et maintenant nous allons g√©n√©rer le reste du niveau du donjon. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais avant de commencer, je voudrais corriger une erreur d'un post pr√©c√©dent. En fait, au cours des derni√®res semaines, j'ai appris quelque chose de nouveau, c'est pourquoi une partie du travail que j'ai fait est d√©pass√©e et je veux en parler. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous vous souvenez de la classe Position que nous avons cr√©√©e? En fait, Unity a d√©j√† une classe int√©gr√©e qui ex√©cute exactement les m√™mes fonctions, mais avec un contr√¥le l√©g√®rement meilleur - il est plus facile de d√©clarer et de traiter. Cette classe est appel√©e Vector2Int. Par cons√©quent, avant de commencer, nous allons supprimer la classe Position de MapManager.cs et remplacer chaque variable Position par la variable Vector2Int.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/b7d/f40/656b7df4053976af99cbd2d359edd494.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La m√™me chose doit √™tre effectu√©e √† plusieurs endroits dans le script DungeonGenerator.cs. </font><font style="vertical-align: inherit;">Passons maintenant au reste de l'algorithme.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtape 7 - g√©n√©ration de salle / hall</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons commencer par une petite modification de la fonction FirstRoom () cr√©√©e la derni√®re fois. </font><font style="vertical-align: inherit;">Au lieu de cr√©er une autre fonction pour g√©n√©rer tous les autres √©l√©ments de la carte et dupliquer un tas de code, nous transformons simplement cette fonction, en la transformant en une GenerateFeature () g√©n√©ralis√©e. </font><font style="vertical-align: inherit;">Par cons√©quent, modifiez le nom de FirstRoom en GenerateFeature. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons maintenant devoir passer des param√®tres √† cette fonction. </font><font style="vertical-align: inherit;">Tout d'abord, vous devez savoir quelle fonction il g√©n√®re - une pi√®ce ou un couloir. </font><font style="vertical-align: inherit;">Nous pouvons simplement passer une cha√Æne appel√©e </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ensuite, la fonction doit conna√Ætre le point de d√©part de l'√©l√©ment, c'est-√†-dire de quel mur elle provient (car nous cr√©ons toujours un nouvel √©l√©ment √† partir du mur de l'√©l√©ment plus ancien), et pour cela, passer comme argument Wall est suffisant. </font><font style="vertical-align: inherit;">Enfin, la premi√®re pi√®ce √† cr√©er a des caract√©ristiques sp√©ciales, nous avons donc besoin d'une variable bool√©enne facultative qui indique si l'√©l√©ment est la premi√®re pi√®ce. </font><font style="vertical-align: inherit;">Par d√©faut, c'est faux: bool isFirst = false. </font><font style="vertical-align: inherit;">Le titre de la fonction changera donc de ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5f/b79/d17/e5fb79d178098b3bcde238ff733f9ca9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sur ce:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45e/124/afc/45e124afc4b4f60b12ab18deaa060719.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien. </font><font style="vertical-align: inherit;">L'√©tape suivante consiste √† modifier la fa√ßon dont vous calculez la largeur et la hauteur de l'√©l√©ment. </font><font style="vertical-align: inherit;">Pendant que nous les calculons, obtenir une valeur al√©atoire entre les valeurs min et max de la hauteur et de la largeur des pi√®ces - c'est id√©al pour les pi√®ces, mais ne fonctionnera pas pour les couloirs. </font><font style="vertical-align: inherit;">Donc, jusqu'√† pr√©sent, nous avons les √©l√©ments suivants:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f5/c0d/976/2f5c0d9765a596c2d2188b56b1f7b7ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais les couloirs auront une taille constante de 3 en largeur ou en hauteur, selon l'orientation. </font><font style="vertical-align: inherit;">Par cons√©quent, nous devons v√©rifier ce qu'est l'√©l√©ment - une pi√®ce ou un couloir, puis effectuer les calculs appropri√©s.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/071/163/df8/071163df82fc248fc92d370672369743.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc. </font><font style="vertical-align: inherit;">nous v√©rifions si l'article est une pi√®ce. </font><font style="vertical-align: inherit;">Si oui, alors nous faisons la m√™me chose qu'avant </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - nous obtenons un nombre al√©atoire dans l'intervalle entre min et max de hauteur et de largeur. </font><font style="vertical-align: inherit;">Mais maintenant, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sinon,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si vous devez faire quelque chose d'un peu diff√©rent. </font><font style="vertical-align: inherit;">Nous devons v√©rifier l'orientation du couloir. </font><font style="vertical-align: inherit;">Heureusement, lors de la g√©n√©ration d'un mur, nous enregistrons des informations sur la direction dans laquelle il est dirig√©, nous l'utilisons donc pour obtenir l'orientation du couloir.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91a/a84/328/91aa84328140d1414b8512843e1cd397.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais nous n'avons pas encore d√©clar√© la variable minCorridorLength. </font><font style="vertical-align: inherit;">Vous devez revenir aux d√©clarations de variables et les d√©clarer, juste au-dessus de maxCorridorLength.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/857/6e1/f138576e1dc1cb4a9949fd51e8c5fe47.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Revenons maintenant √† nos instructions de changement conditionnel. </font><font style="vertical-align: inherit;">Ce que nous faisons ici: nous obtenons la valeur de la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direction du</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mur, c'est-√†-dire o√π le mur regarde, d'o√π le couloir ira. </font><font style="vertical-align: inherit;">La direction ne peut avoir que quatre valeurs possibles: Sud, Nord, Ouest et Est. </font><font style="vertical-align: inherit;">Dans le cas du Sud et du Nord, le couloir aura une largeur de 3 (deux murs et un plancher au milieu) et une hauteur variable (longueur). </font><font style="vertical-align: inherit;">Pour l'Ouest et l'Est, tout sera invers√©: la hauteur sera constamment √©gale √† 3 et la largeur aura une longueur variable. </font><font style="vertical-align: inherit;">Alors faisons-le.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e2/175/8d6/0e21758d6d2e17406ce516c3fef6ccf5.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sensationnel. </font><font style="vertical-align: inherit;">Et c'est l√† que nous avons fini par dimensionner le nouvel article. </font><font style="vertical-align: inherit;">Maintenant, vous devez d√©cider o√π le mettre. </font><font style="vertical-align: inherit;">Nous avons plac√© la premi√®re pi√®ce dans un endroit al√©atoire dans les valeurs de seuil par rapport au centre de la carte.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fb/d53/010/6fbd5301066f6b0ba77ab90142370a5d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais pour tous les autres √©l√©ments, cela ne fonctionnera pas. Ils doivent commencer √† c√¥t√© du point al√©atoire sur le mur √† partir duquel l'√©l√©ment est g√©n√©r√©. Modifions donc le code. Tout d'abord, nous devons v√©rifier si l'√©l√©ment est la premi√®re pi√®ce. S'il s'agit de la premi√®re pi√®ce, nous d√©finissons les points de d√©part de la m√™me mani√®re que pr√©c√©demment - comme la moiti√© de la largeur et de la hauteur de la carte.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d29/44d/ff3d2944da973a48200a6c9c3066d20d.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans d' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">autre,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si l'√©l√©ment est pas la premi√®re chambre, nous obtenons un point au </font><font style="vertical-align: inherit;">hasard sur le mur √† </font><font style="vertical-align: inherit;">partir de </font><font style="vertical-align: inherit;">laquelle l'√©l√©ment est g√©n√©r√©. Tout d'abord, nous devons v√©rifier si le mur a une taille de 3 (cela signifie qu'il s'agit du point final du couloir), et si c'est le cas, le point central sera toujours s√©lectionn√©, c'est-√†-dire l'index 1 du tableau de murs (avec 3 √©l√©ments, le tableau a indices 0, 1, 2). Mais si la taille n'est pas √©gale √† 3 (le mur n'est pas le point final du couloir), alors nous prenons un point al√©atoire dans l'intervalle entre le point 1 et la longueur du mur moins 2. Ceci est n√©cessaire pour √©viter les passages cr√©√©s dans le coin. C'est-√†-dire, par exemple, sur un mur d'une longueur de 6, nous excluons les index 0 et 5 (premier et dernier) et s√©lectionnons un point al√©atoire parmi les points 1, 2, 3 et 4.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/4e1/703/ee24e1703c28b4cfa96e98d84a76c790.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons maintenant la position du point sur le mur o√π un nouvel √©l√©ment sera cr√©√©. Mais nous ne pouvons pas simplement commencer √† g√©n√©rer un √©l√©ment √† partir de l√†, car de cette fa√ßon, il sera bloqu√© par des murs d√©j√† plac√©s. Il est √©galement important de noter que l'√©l√©ment commence √† √™tre g√©n√©r√© √† partir de son coin inf√©rieur gauche, puis l'incr√©mentation est effectu√©e vers la droite et vers le haut, nous devons donc d√©finir la position initiale √† diff√©rents endroits, selon la direction dans laquelle le mur regarde. De plus, la premi√®re colonne x et la premi√®re ligne y seront des murs, et si nous commen√ßons un nouvel √©l√©ment juste √† c√¥t√© d'un point sur le mur, nous pouvons cr√©er un couloir se terminant dans un coin de la pi√®ce et non √† un endroit appropri√© sur le mur.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, si le mur est dirig√© vers le nord, il est n√©cessaire que l'√©l√©ment commence dans une position au nord le long de l'axe y, mais dans un nombre al√©atoire de positions √† l'ouest le long de l'axe x, dans la plage de 1 √† la largeur de la pi√®ce-2. </font><font style="vertical-align: inherit;">Dans la direction sud, l'axe x agit de la m√™me fa√ßon, mais la position de d√©part sur l'axe y est la position du point sur le mur moins la hauteur de la pi√®ce. </font><font style="vertical-align: inherit;">Les murs ouest et est suivent la m√™me logique, uniquement avec des axes invers√©s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais avant de faire tout cela, nous devons enregistrer la position du point de mur dans la variable Vector2Int afin de pouvoir le manipuler plus tard.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/374/129/41a/37412941a3a58f32fd2dd38c1fc2c252.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
G√©nial. </font><font style="vertical-align: inherit;">Faisons cela.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/2c7/ec0/1402c7ec0596d77f9a9b70b5eac076a9.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons donc g√©n√©r√© un √©l√©ment avec la taille et la position, et l'√©tape suivante consiste √† placer l'√©l√©ment sur la carte. </font><font style="vertical-align: inherit;">Mais d'abord, nous devons savoir s'il y a vraiment de la place sur la carte pour cet √©l√©ment dans cette position. </font><font style="vertical-align: inherit;">Pour l'instant, nous appelons simplement la fonction CheckIfHasSpace (). </font><font style="vertical-align: inherit;">Il sera surlign√© en rouge, car nous ne l'avons pas encore mis en ≈ìuvre. </font><font style="vertical-align: inherit;">Nous le ferons juste apr√®s avoir termin√© ce qui doit √™tre fait ici dans la fonction GenerateFeature (). </font><font style="vertical-align: inherit;">Par cons√©quent, ignorez le soulignement rouge et continuez.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/805/942/b2080594237c23cae023cabb20b2d20e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la partie suivante, des murs sont cr√©√©s. </font><font style="vertical-align: inherit;">Jusqu'√† ce que nous le touchions, √† l'exception du fragment dans la seconde boucle </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/227/d7f/e2b/227d7fe2bf3c2eef41f423e36b4afc79.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En √©crivant ce post, j'ai remarqu√© que ces constructions if-else sont compl√®tement fausses. Par exemple, certains murs en eux recevront une longueur de 1. Cela se produit parce que lorsque la position doit √™tre ajout√©e, par exemple, au mur nord, alors si elle √©tait au coin du mur est, elle ne sera pas ajout√©e au mur est, comme il se doit. Cela a provoqu√© des bogues ennuyeux dans l'algorithme de g√©n√©ration. √âliminons-les. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les r√©parer est assez simple. Il suffit de supprimer tout le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reste</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour que la position passe par toutes les constructions </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et ne s'arr√™te pas au premier si elle retourne </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ensuite, le dernier </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">autre</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (celui qui n'est pas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) est chang√© en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui v√©rifie que la position a d√©j√† √©t√© ajout√©e en tant que mur et, dans le cas contraire, l'ajoute en tant que sol.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/784/834/65c784834461a2d8b05d1d39dd9ee44c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incroyable, nous avons presque fini ici. </font><font style="vertical-align: inherit;">Nous avons maintenant un √©l√©ment compl√®tement nouveau, cr√©√© au bon endroit, mais il est le m√™me que notre premi√®re pi√®ce: il est compl√®tement clos de murs. </font><font style="vertical-align: inherit;">Cela signifie que le joueur ne pourra pas acc√©der √† ce nouvel endroit. </font><font style="vertical-align: inherit;">Autrement dit, nous devons convertir un point sur le mur (qui, comme nous le rappelons, est stock√© dans une variable de type Vector2Int) et le point correspondant sur le mur d'un nouvel √©l√©ment dans Floor. </font><font style="vertical-align: inherit;">Mais seulement lorsque l'√©l√©ment n'est pas la premi√®re pi√®ce.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/350/67f/5ac/35067f5ac7db26fd304578b8dd53326c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce morceau de code v√©rifie si le nouvel √©l√©ment est la premi√®re pi√®ce. </font><font style="vertical-align: inherit;">Sinon, il convertit la derni√®re position du mur au sol, puis v√©rifie la direction dans laquelle le mur regarde afin de v√©rifier quelle tuile du nouvel √©l√©ment doit se transformer en sol. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons atteint la derni√®re partie de la fonction GenerateFeature (). </font><font style="vertical-align: inherit;">Il contient d√©j√† des lignes qui ajoutent des informations sur l'√©l√©ment cr√©√© par la fonction.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fe/165/626/4fe165626aca42951f86568a4d6649c7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous devons changer quelque chose. </font><font style="vertical-align: inherit;">Premi√®rement, le type d'√©l√©ment n'est pas toujours √©gal √† Room. </font><font style="vertical-align: inherit;">Heureusement, la variable requise est transmise √† la fonction en tant que param√®tre, √† savoir la cha√Æne de type. </font><font style="vertical-align: inherit;">Rempla√ßons simplement ici "Room" par type.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b57/d12/f17/b57d12f17802ec40e0c609d26803f661.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien. </font><font style="vertical-align: inherit;">Maintenant, pour que l'algorithme g√©n√©rant tous les √©l√©ments du jeu fonctionne correctement, nous devons ajouter de nouvelles donn√©es ici. </font><font style="vertical-align: inherit;">A savoir, un int qui compte le nombre d'√©l√©ments cr√©√©s et une liste de tous les √©l√©ments cr√©√©s. </font><font style="vertical-align: inherit;">Nous montons √† l'endroit o√π nous d√©clarons toutes les variables et d√©clarons un int avec le nom countFeatures, ainsi qu'une liste d'√©l√©ments avec le nom allFeatures. </font><font style="vertical-align: inherit;">La liste de tous les √©l√©ments doit √™tre publique et le compteur int peut √™tre priv√©.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcb/ebf/8dd/bcbebf8ddbc768864ba70331317cc72c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Revenons maintenant √† la fonction GenerateFeature () et ajoutez quelques lignes √† la fin: incr√©menter la variable countFeatures et ajouter un nouvel √©l√©ment √† la liste allFeatures.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e6/8a8/496/5e68a8496d7047c87650a609acb912cf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, notre GenerateFeature () est presque termin√©e. </font><font style="vertical-align: inherit;">Plus tard, nous devrons y retourner pour remplir la fonction CheckIfHasSpace vide, mais nous devons d'abord la cr√©er. </font><font style="vertical-align: inherit;">C‚Äôest ce que nous allons faire maintenant.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtape 8 - v√©rifier s'il y a une place</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cr√©ons maintenant une nouvelle fonction juste apr√®s la fin de la fonction GenerateFeature (). Elle a besoin de deux arguments: la position √† laquelle l'√©l√©ment commence et la position √† laquelle il se termine. Vous pouvez utiliser deux variables Vector2Int comme elles. La fonction doit renvoyer une valeur bool√©enne afin qu'elle puisse √™tre utilis√©e dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour v√©rifier l'espace.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/998/f03/cad/998f03cad9a6bd8a05bd7d8b9658bad6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est soulign√© en rouge, car jusqu'√† pr√©sent il n'a rien retourn√©. Bient√¥t, nous allons le r√©parer, mais pour l'instant nous n'y ferons pas attention. Dans cette fonction, nous allons parcourir toutes les positions entre le d√©but et la fin de l'√©l√©ment et v√©rifier si la position actuelle dans MapManager.map est nulle ou si quelque chose est d√©j√† l√†. S'il y a quelque chose, alors nous arr√™tons la fonction et retournons false. Sinon, continuez. Si la fonction atteint la fin de la boucle sans rencontrer les emplacements remplis, retournez true. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, avant de v√©rifier la position pour null, nous avons besoin d'une ligne pour v√©rifier si la position est dans la carte. Parce que sinon, nous pouvons obtenir une erreur d'index de tableau et un plantage du jeu.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/473/582/a5b/473582a5b560d6738de08b2f6190cf6b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien. </font><font style="vertical-align: inherit;">Revenons maintenant √† l'endroit o√π nous ins√©rons cette fonction √† l'int√©rieur de la fonction GenerateFeature (). </font><font style="vertical-align: inherit;">Nous devons corriger cet appel car il ne transmet pas les arguments n√©cessaires. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous voulons ins√©rer une </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instruction if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour v√©rifier s'il y a suffisamment d'espace pour l'√©l√©ment. </font><font style="vertical-align: inherit;">Si le r√©sultat est faux, nous terminons la fonction sans ins√©rer un nouvel √©l√©ment dans MapManager.map.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/068/661/e53/068661e533ef21536a51f17ae3de570b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous devons passer les arguments requis, c'est-√†-dire deux variables Vector2Int. </font><font style="vertical-align: inherit;">Avec le premier, tout est simple, c'est la position avec les coordonn√©es x et y du point de d√©part de l'√©l√©ment.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c1/869/26d/0c186926d741d2423c791500adbed2cd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La seconde est plus difficile, mais pas de beaucoup. </font><font style="vertical-align: inherit;">Il s'agit du point de d√©part plus la hauteur pour y et la largeur pour x, en soustrayant 1 des deux (car le d√©but a d√©j√† √©t√© pris en compte).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a18/f85/4a9/a18f854a9e0a0bbe5883012bf2e313ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons maintenant √† l'√©tape suivante: cr√©er un algorithme pour appeler la fonction GenerateFeature ().</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtape 9 - √âl√©ments g√©n√©r√©s par l'appel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retour √† la fonction GenerateDungeon () cr√©√©e dans la partie pr√©c√©dente de l'article. </font><font style="vertical-align: inherit;">Maintenant, cela devrait ressembler √† ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/57c/5e3/3e957c5e316f5329e935353e961df47b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'appel √† FirstRoom () est soulign√© en rouge car nous avons chang√© le nom de cette fonction. </font><font style="vertical-align: inherit;">Appelons donc la premi√®re g√©n√©ration de pi√®ces.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d6/926/908/8d692690826997750f3bc860ae9216f0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons pass√© les arguments n√©cessaires: "Room" comme type, car la premi√®re salle sera toujours Room, new Wall (), car la premi√®re salle ne sera pas cr√©√©e √† partir d'une autre, nous passons donc null, et c'est tout √† fait normal. Au lieu de nouveau Wall (), vous pouvez remplacer </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , c'est une question de pr√©f√©rence personnelle. Le dernier argument d√©termine si le nouvel √©l√©ment est la premi√®re pi√®ce, donc dans notre cas, nous passons </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vrai</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous arrivons maintenant au point principal. Nous utilisons une boucle for qui s'ex√©cutera 500 fois - oui, nous allons essayer d'ajouter des √©l√©ments 500 fois. Mais si le nombre d'√©l√©ments cr√©√©s (variable countFeatures) est √©gal au nombre maximal sp√©cifi√© d'√©l√©ments (variable maxFeatures), alors nous interrompons ce cycle.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e6/410/ded/9e6410ded47210776fcda40ae2492229.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La premi√®re √©tape de cette boucle consiste √† d√©clarer l'√©l√©ment √† partir duquel le nouvel √©l√©ment sera cr√©√©. </font><font style="vertical-align: inherit;">Si nous n'avons cr√©√© qu'un seul √©l√©ment (la premi√®re salle), ce sera l'original. </font><font style="vertical-align: inherit;">Sinon, nous s√©lectionnons au hasard l'un des √©l√©ments d√©j√† cr√©√©s.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddb/e84/f92/ddbe84f92cbb06f56e3ccce561dde991.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons maintenant choisir le mur de cet √©l√©ment qui sera utilis√© pour cr√©er le nouvel √©l√©ment.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/e7c/0e4/7ade7c0e438985098eed6f5dbdd42e6d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez noter que nous n'avons pas encore cette fonction ChoseWall (). </font><font style="vertical-align: inherit;">√âcrivons-le rapidement. </font><font style="vertical-align: inherit;">Descendez jusqu'√† la fin de la fonction et cr√©ez-la. </font><font style="vertical-align: inherit;">Il doit renvoyer un mur et utiliser un √©l√©ment comme argument pour que la fonction puisse s√©lectionner le mur de cet √©l√©ment.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aeb/631/9f1/aeb6319f1ee6f601474d0aa0e32e2c77.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je l'ai cr√©√© entre les fonctions CheckIfHasSpace () et DrawMap (). </font><font style="vertical-align: inherit;">Notez que si vous travaillez dans Visual Studio, qui est install√© avec Unity, vous pouvez utiliser les champs - / + sur la gauche pour r√©duire / d√©velopper des parties du code pour simplifier le travail. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cette fonction, nous trouverons le mur √† partir duquel l'√©l√©ment n'a pas encore √©t√© cr√©√©. </font><font style="vertical-align: inherit;">Parfois, nous obtiendrons des √©l√©ments avec un ou plusieurs murs auxquels d'autres √©l√©ments sont d√©j√† attach√©s, nous devons donc v√©rifier encore et encore si l'un des murs al√©atoires est libre. </font><font style="vertical-align: inherit;">Pour ce faire, nous utilisons une boucle for r√©p√©t√©e dix fois - si apr√®s ces dix fois aucun mur libre n'est trouv√©, la fonction retourne null.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/44a/028/b1044a028bf9ab566a0120690311396d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Revenons maintenant √† la fonction GenerateDungeon () et passez l'√©l√©ment d'origine en tant que param√®tre √† la fonction ChoseWall ().</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/281/8aa/0a32818aafc77ddd87f1ffac21b6981e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La ligne </font></font><code>if (wall == null) continue;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">signifie que si la fonction de recherche de mur a renvoy√© false, alors l'√©l√©ment d'origine ne peut pas g√©n√©rer un nouvel √©l√©ment, donc la fonction </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuera le</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cycle, c'est-√†-dire qu'elle ne pourrait pas cr√©er un nouvel √©l√©ment et passera √† l'it√©ration suivante du cycle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous devons s√©lectionner le type pour l'√©l√©ment suivant. </font><font style="vertical-align: inherit;">Si l'√©l√©ment source est une pi√®ce, alors le suivant doit √™tre un couloir (nous ne voulons pas que la pi√®ce m√®ne directement √† une autre pi√®ce sans couloir entre elles). </font><font style="vertical-align: inherit;">Mais s'il s'agit d'un couloir, nous devons cr√©er la probabilit√© qu'un autre couloir ou une autre pi√®ce soit le prochain.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b22/df0/954/b22df0954bbe21d82506d42e5118a70f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien. </font><font style="vertical-align: inherit;">Il nous suffit maintenant d'appeler la fonction GenerateFeature (), en lui passant le mur et en tapant comme param√®tres.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a07/90b/834/a0790b83479f46dc17c57fbb981aef81.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, acc√©dez √† l'inspecteur Unity, s√©lectionnez l'objet GameManager et modifiez les valeurs comme suit:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cc/09c/786/9cc09c786641bf85a89674cc33042ebf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous cliquez maintenant sur le bouton de lecture, vous verrez d√©j√† les r√©sultats!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme je l'ai dit, ce n'est pas le meilleur donjon. </font><font style="vertical-align: inherit;">Nous avons eu beaucoup d'impasses. </font><font style="vertical-align: inherit;">Mais il est enti√®rement fonctionnel et garantit que vous n'aurez pas de pi√®ce non connect√©e √† une autre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'esp√®re que tu as aim√©! </font><font style="vertical-align: inherit;">Dans le prochain post, nous allons cr√©er un joueur qui se d√©placera √† travers le donjon, puis nous transformerons la carte d'ASCII en sprite.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.UI;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Post3</span> : <span class="hljs-title">MonoBehaviour</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapWidth;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapHeight;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMaxRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMaxRoom;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> minCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxFeatures;
    <span class="hljs-keyword">int</span> countFeatures;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isASCII;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> List&lt;Feature&gt; allFeatures;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        MapManager.map = <span class="hljs-keyword">new</span> Tile[mapWidth, mapHeight];<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GenerateDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        GenerateFeature(<span class="hljs-string">"Room"</span>, <span class="hljs-keyword">new</span> Wall(), <span class="hljs-literal">true</span>);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) {<font></font>
            Feature originFeature;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (allFeatures.Count == <span class="hljs-number">1</span>) {<font></font>
                originFeature = allFeatures[<span class="hljs-number">0</span>];<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {<font></font>
                originFeature = allFeatures[Random.Range(<span class="hljs-number">0</span>, allFeatures.Count - <span class="hljs-number">1</span>)];<font></font>
            }<font></font>
<font></font>
            Wall wall = ChoseWall(originFeature);<font></font>
            <span class="hljs-keyword">if</span> (wall == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
            <span class="hljs-keyword">string</span> type;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (originFeature.type == <span class="hljs-string">"Room"</span>) {<font></font>
                type = <span class="hljs-string">"Corridor"</span>;<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) &lt; <span class="hljs-number">90</span>) {<font></font>
                    type = <span class="hljs-string">"Room"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                    type = <span class="hljs-string">"Corridor"</span>;<font></font>
                }<font></font>
            }<font></font>
<font></font>
            GenerateFeature(type, wall);<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (countFeatures &gt;= maxFeatures) <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
<font></font>
        DrawMap(isASCII);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GenerateFeature</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> type, Wall wall, <span class="hljs-keyword">bool</span> isFirst = <span class="hljs-literal">false</span></span>)</span> {<font></font>
        Feature room = <span class="hljs-keyword">new</span> Feature();<font></font>
        room.positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
<font></font>
        <span class="hljs-keyword">int</span> roomWidth = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> roomHeight = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) {<font></font>
            roomWidth = Random.Range(widthMinRoom, widthMaxRoom);<font></font>
            roomHeight = Random.Range(heightMinRoom, heightMaxRoom);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">int</span> xStartingPoint;
        <span class="hljs-keyword">int</span> yStartingPoint;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint = mapWidth / <span class="hljs-number">2</span>;<font></font>
            yStartingPoint = mapHeight / <span class="hljs-number">2</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">int</span> id;
            <span class="hljs-keyword">if</span> (wall.positions.Count == <span class="hljs-number">3</span>) id = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> id = Random.Range(<span class="hljs-number">1</span>, wall.positions.Count - <span class="hljs-number">2</span>);<font></font>
<font></font>
            xStartingPoint = wall.positions[id].x;<font></font>
            yStartingPoint = wall.positions[id].y;<font></font>
        }<font></font>
<font></font>
        Vector2Int lastWallPosition = <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth);<font></font>
            yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint ++;<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    xStartingPoint -= roomWidth;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    xStartingPoint++;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
         <span class="hljs-keyword">if</span> (!CheckIfHasSpace(<span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint), <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint + roomWidth - <span class="hljs-number">1</span>, yStartingPoint + roomHeight - <span class="hljs-number">1</span>))) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        room.walls = <span class="hljs-keyword">new</span> Wall[<span class="hljs-number">4</span>];<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; room.walls.Length; i++) {<font></font>
            room.walls[i] = <span class="hljs-keyword">new</span> Wall();<font></font>
            room.walls[i].positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
            room.walls[i].length = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">switch</span> (i) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"South"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"North"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"West"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"East"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; roomHeight; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; roomWidth; x++) {<font></font>
                Vector2Int position = <span class="hljs-keyword">new</span> Vector2Int();<font></font>
                position.x = xStartingPoint + x;<font></font>
                position.y = yStartingPoint + y;<font></font>
<font></font>
                room.positions.Add(position);<font></font>
<font></font>
                MapManager.map[position.x, position.y] = <span class="hljs-keyword">new</span> Tile();<font></font>
                MapManager.map[position.x, position.y].xPosition = position.x;<font></font>
                MapManager.map[position.x, position.y].yPosition = position.y;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">0</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">0</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (y == (roomHeight - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">1</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">1</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">2</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">2</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == (roomWidth - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">3</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">3</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (MapManager.map[position.x, position.y].type != <span class="hljs-string">"Wall"</span>) {<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Floor"</span>;<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!isFirst) {<font></font>
            MapManager.map[lastWallPosition.x, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y - <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y + <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    MapManager.map[lastWallPosition.x - <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    MapManager.map[lastWallPosition.x + <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        room.width = roomWidth;<font></font>
        room.height = roomHeight;<font></font>
        room.type = type;<font></font>
        allFeatures.Add(room);<font></font>
        countFeatures++;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckIfHasSpace</span>(<span class="hljs-params">Vector2Int start, Vector2Int end</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = start.y; y &lt;= end.y; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = start.x; x &lt;= end.x; x++) {
                <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= mapWidth || y &gt;= mapHeight) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">if</span> (MapManager.map != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">Wall <span class="hljs-title">ChoseWall</span>(<span class="hljs-params">Feature feature</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            <span class="hljs-keyword">int</span> id = Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) / <span class="hljs-number">25</span>;
            <span class="hljs-keyword">if</span> (!feature.walls[id].hasFeature) {
                <span class="hljs-keyword">return</span> feature.walls[id];<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawMap</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> isASCII</span>)</span> {
        <span class="hljs-keyword">if</span> (isASCII) {<font></font>
            Text screen = GameObject.Find(<span class="hljs-string">"ASCIITest"</span>).GetComponent&lt;Text&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">string</span> asciiMap = <span class="hljs-string">""</span>;<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = (mapHeight - <span class="hljs-number">1</span>); y &gt;= <span class="hljs-number">0</span>; y--) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; mapWidth; x++) {
                    <span class="hljs-keyword">if</span> (MapManager.map[x, y] != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">switch</span> (MapManager.map[x, y].type) {
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Wall"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"#"</span>;
                                <span class="hljs-keyword">break</span>;
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Floor"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"."</span>;
                                <span class="hljs-keyword">break</span>;<font></font>
                        }<font></font>
                    }<font></font>
                    <span class="hljs-keyword">else</span> {<font></font>
                        asciiMap += <span class="hljs-string">" "</span>;<font></font>
                    }<font></font>
<font></font>
                    <span class="hljs-keyword">if</span> (x == (mapWidth - <span class="hljs-number">1</span>)) {<font></font>
                        asciiMap += <span class="hljs-string">"\n"</span>;<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
<font></font>
            screen.text = asciiMap;<font></font>
        }<font></font>
    }<font></font>
}</code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr495554/index.html">Programme de recherche de VKontakte aux vues similaires [Open source]</a></li>
<li><a href="../fr495556/index.html">Fortinet - une s√©lection de mat√©riaux utiles</a></li>
<li><a href="../fr495560/index.html">Tendances de l'Internet des objets: l'IA r√©pond aux appels, les nuages ‚Äã‚Äãet la 5G apprivoisent les m√©gadonn√©es, le logement et les services publics - Leader en innovation</a></li>
<li><a href="../fr495576/index.html">Plate-forme automotrice sur l'esp8266 MK avec micropython</a></li>
<li><a href="../fr495580/index.html">JVM concombre - pas seulement BDD</a></li>
<li><a href="../fr495592/index.html">Comment utiliser les dictionnaires (et pas seulement)</a></li>
<li><a href="../fr495594/index.html">Commencez √† gagner de l'argent avec les logiciels: cr√©er des mini-entreprises num√©riques</a></li>
<li><a href="../fr495596/index.html">Travail √† distance au bureau. RDP, Port Knocking, Mikrotik: simple et s√ªr</a></li>
<li><a href="../fr495602/index.html">Commencer avec Core Data! Difficile avec des mots simples [Partie 2]</a></li>
<li><a href="../fr495604/index.html">Localisation temporaire sur Symfony 4 + Twig</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>