<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☮️ 🉑 😋 ドードーが止まった日。非同期スクリプト 🏇🏾 👸🏽 🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！私たちのチームの各SREは、かつて夜に安らかに眠ることを夢見ていました。夢がかなう。この記事では、これと、Dodo ISシステムのパフォーマンスと安定性をどのように実現するかについて説明します。
 
 
 Dodo IS *システムの崩壊に関する一連の記事：
 
 1 . Dod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ドードーが止まった日。非同期スクリプト</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/461081/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！</font><font style="vertical-align: inherit;">私たちのチームの各SREは、かつて夜に安らかに眠ることを夢見ていました。</font><font style="vertical-align: inherit;">夢がかなう。</font><font style="vertical-align: inherit;">この記事では、これと、Dodo ISシステムのパフォーマンスと安定性をどのように実現するかについて説明します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wk/2o/t6/wk2ot6razkmzgly1s69fdwz5quq.png"><a name="habracut"></a><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dodo IS *システムの崩壊に関する一連の記事</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dodo ISが停止した日。</font><font style="vertical-align: inherit;">同期スクリプト。</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Dodoが停止した日。</font><font style="vertical-align: inherit;">非同期スクリプト。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
* </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">資料は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モスクワのDotNext 2018での私のパフォーマンスに</font></font></a></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">基づいて書かれ</font></i><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ました</font></a></i><font style="vertical-align: inherit;">。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前回の記事では、プリエンプティブマルチタスクパラダイムでブロッキングコードの問題について説明しました。</font><font style="vertical-align: inherit;">async / awaitでブロッキングコードを書き換える必要があると想定されていました。</font><font style="vertical-align: inherit;">だから私たちはしました。</font><font style="vertical-align: inherit;">次に、これを行ったときに発生した問題について説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同時実行という用語を紹介します </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期になる前に、Concurrencyという用語を入力する必要があります。 </font></font><br>
<blockquote>    <b>Concurrency</b> –   ,       .  Concurrency   Parallelism,       .</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concurrencyを初めて使用する場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rob Pikeのビデオをお勧めし</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。同時実行性とは、同時に多くのことを処理するときであり、並列処理とは、同時に多くのことを行うときです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンピューターでは、並行して発生することは多くありません。そのようなものの1つは、複数のプロセッサでのコンピューティングです。並列処理の程度は、CPUスレッドの数によって制限されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、スレッドはプリエンプティブマルチタスクの概念の一部であり、並行性の質問でオペレーティングシステムに依存する場合にプログラムで並行性をモデル化する1つの方法です。このモデルは、並行性ではなく並行性モデルを具体的に扱っていることを理解している限り、有用です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Async / awaitは、シングルスレッド環境で実行できるもう1つの便利な同時実行モデルであるState Machineの構文シュガーです。</font><font style="vertical-align: inherit;">本質的に、これは協調マルチタスクです。モデル自体は並列処理をまったく考慮していません。</font><font style="vertical-align: inherit;">マルチスレッディングと組み合わせると、1つのモデルを他のモデルの上に重ねることができ、人生は非常に複雑になります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つのモデルの比較</font></font></h2><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリエンプティブマルチタスクモデルでの仕組み</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1秒あたり20のスレッドと20のリクエストの処理があるとします。</font><font style="vertical-align: inherit;">図はピークを示しています-システム内で同時に200リクエスト。</font><font style="vertical-align: inherit;">これはどのようにして起こりますか：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">200のクライアントが同時にボタンを押した場合、リクエストをグループ化できます。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガベージコレクターは、要求を数十ミリ秒停止する可能性があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロキシがキューをサポートしている場合、リクエストはどのキューでも遅延する可能性があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短期間のリクエストが蓄積され、1つのバンドルにまとめられる理由は数多くあります。いずれにしても、ひどいことは何も起こらず、スレッドプールキューに立ってゆっくりと完了しました。ピークはなくなり、何も起こらなかったかのようにすべてが続きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スマートスレッドプールアルゴリズム（およびそこに機械学習要素がある）が、これまでにスレッド数を増やす理由はないと判断したと仮定します。スレッド= 20であるため、MySqlの接続プールも20です。したがって、SQLへの接続は20しか必要ありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gm/ch/pz/gmchpzxpvegoyljdauranwzgn7k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、外部システムの観点から見たサーバーの並行性レベルは200です。サーバーは既にこれらの要求を受信して​​いますが、まだ完了していません。</font><font style="vertical-align: inherit;">ただし、マルチスレッディングパラダイムで実行されているアプリケーションの場合、同時要求の数はスレッドプールの現在のサイズ= 20によって制限されます。したがって、同時実行度= 20を扱います。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期モデルですべてが機能する仕組み</font></font></h4><br>
<img width="33%" height="33%" src="https://habrastorage.org/webt/dg/yz/pz/dgyzpzj-nl9rawn5ctxdfr3gxgm.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じ負荷とリクエストの分散でasync / awaitを実行しているアプリケーションで何が起こるか見てみましょう。タスクを作成する前のキューはなく、リクエストはすぐに処理されます。もちろん、ThreadPoolのThreadが短時間使用され、データベースに接続する前のリクエストの最初の部分がすぐに実行されます。スレッドはすぐにスレッドプールに戻るため、処理するスレッドの数は多くありません。この図では、スレッドプールはまったく表示されておらず、透過的です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bm/6h/to/bm6hto7o6gxnrlg9ruzhfsxfet0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは私たちのアプリケーションにとって何を意味しますか？</font><font style="vertical-align: inherit;">外部の画像は同じです-並行性のレベル=200。同時に、内部の状況が変化しました。</font><font style="vertical-align: inherit;">以前は、リクエストはThreadPoolキューで「混雑」していましたが、TaskSchedulerの部分に制限がないため、アプリケーションの同時実行性の度合いも200になりました。</font><font style="vertical-align: inherit;">やったー！</font><font style="vertical-align: inherit;">私たちは非同期の目標を達成しました-アプリケーションはほぼすべての程度の並行性で「対応」します！</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果：システムの非線形劣化</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションは並行性に関して透過的になり、並行性はデータベースに投影されます。</font><font style="vertical-align: inherit;">次に、同じサイズ= 200の接続プールが必要です。データベースは、CPU、メモリ、ネットワーク、ストレージです。</font><font style="vertical-align: inherit;">これは、他と同様に、問題のある同じサービスです。</font><font style="vertical-align: inherit;">同時に実行しようとするリクエストが多いほど、実行速度は遅くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースにフル負荷がかかると、せいぜい応答時間は直線的に低下します。クエリを2倍にすると、2倍の速度で動作し始めます。</font><font style="vertical-align: inherit;">実際には、クエリの競合により、オーバーヘッドが必然的に発生し、システムが非線形的に低下することが判明する場合があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜそれが起こるのですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の注文の理由：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、データベースをデータ構造のメモリに同時に保存して、より多くの要求に対応する必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在、データベースはより大きなコレクションを提供する必要があります（これはアルゴリズム的に不利です）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の注文理由： </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">競合について</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、前回の記事で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少し説明し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ました</font></a><font style="vertical-align: inherit;">。</font></font></li>
</ul> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結局、非同期は限られたリソースと戦って...勝利します！</font><font style="vertical-align: inherit;">データベースが立ち上がらず、速度が低下し始めます。</font><font style="vertical-align: inherit;">これにより、サーバーは並行性をさらに向上させ、システムはこの状況から名誉を失うことができなくなります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバー突然死症候群</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時々、興味深い状況が発生します。</font><font style="vertical-align: inherit;">サーバーがあります。</font><font style="vertical-align: inherit;">彼はそのように自分のために働いています、すべてが順調です。</font><font style="vertical-align: inherit;">余裕があっても十分なリソースがあります。</font><font style="vertical-align: inherit;">次に、クライアントからサーバーが遅くなっているというメッセージを突然受け取ります。</font><font style="vertical-align: inherit;">グラフを見ると、顧客の活動にある程度の急増があったことがわかりますが、現在はすべて正常です。</font><font style="vertical-align: inherit;">DOS攻撃または偶然のことを考えています。</font><font style="vertical-align: inherit;">今、すべてがうまくいくようです。</font><font style="vertical-align: inherit;">今だけサーバーは愚かであり、タイムアウトが入り始めるまでそれはより厳しくなります。</font><font style="vertical-align: inherit;">しばらくすると、同じデータベースを使用する別のサーバーも曲がり始めます。</font><font style="vertical-align: inherit;">身近な状況？</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜシステムは死んだのですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ある時点でサーバーがピーク数のリクエストを受信して​​「壊れた」という事実で説明できます。</font><font style="vertical-align: inherit;">しかし、負荷が軽減されたことがわかります。その後のサーバーは、負荷が完全になくなるまで、長期間にわたって改善されませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
修辞的な質問：サーバーは過剰な負荷のために壊れるはずでしたか？</font><font style="vertical-align: inherit;">彼らはそれをしますか？</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーのクラッシュ状況をシミュレートします</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、実際の生産システムからのグラフは分析しません。サーバーがクラッシュしたとき、そのようなスケジュールを取得できないことがよくあります。サーバーのCPUリソースが不足しているため、ログを書き込むことができず、メトリックを提供できません。震災時の図では、すべてのグラフの途切れがよく見られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SREは、この影響を受けにくい監視システムを作成できる必要があります。どのような状況でも少なくともいくつかの情報を提供し、同時に断片的な情報を使用して死後システムを分析できるシステム。教育目的のために、この記事では少し異なるアプローチを使用しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数学的に負荷のかかったサーバーのように機能するモデルを作成してみましょう。</font><font style="vertical-align: inherit;">次に、サーバーの特性を調べます。</font><font style="vertical-align: inherit;">実サーバーの非線形性を破棄し、負荷が公称値を超えたときに線形減速が発生する状況をシミュレートします。</font><font style="vertical-align: inherit;">必要な数の2倍のリクエスト-2倍の速度でサービスを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチにより、次のことが可能になります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">せいぜいどうなるかを考えてください。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正確なメトリックを取得します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予定されたナビゲーション：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">青-サーバーへのリクエストの数。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">緑-サーバーの応答。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">黄色-タイムアウト。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">濃い灰色-クライアントがタイムアウト応答を待たなかったためにサーバーリソースで無駄になった要求。</font><font style="vertical-align: inherit;">切断によってクライアントがサーバーにこれを報告する場合がありますが、一般に、たとえばサーバーがクライアントとの連携なしにCPUにバインドされた作業を行う場合、そのような贅沢は技術的に実現できない場合があります。</font></font></li>
</ul><br>
<br>
<img src="https://habrastorage.org/webt/8d/r8/lr/8dr8lr7gizm-ovozc0laylwadaa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントのリクエストグラフ（図の青色）がなぜそうなったのですか？</font><font style="vertical-align: inherit;">通常、私たちのピッツェリアの注文のスケジュールは、朝はスムーズに増加し、夜は減少します。</font><font style="vertical-align: inherit;">しかし、通常の均一な曲線の背景に対して3つのピークが観察されます。</font><font style="vertical-align: inherit;">この形式のグラフは、偶然モデルに選択されたのではなく、むしろ選択されました。</font><font style="vertical-align: inherit;">モデルは、ワールドカップ中にロシアのピザ屋のコンタクトセンターのサーバーでの実際の事件の調査中に生まれました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ケース「ワールドカップ」</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは座ってさらに注文を待った。チャンピオンシップに備えて、サーバーは強度テストに合格することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のピーク-フットボールのファンは選手権を見に行き、空腹でピザを買います。前半は忙しく注文できません。しかし、サッカーに無関心な人はそうすることができるので、チャートではすべてがいつものように進んでいます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして前半が終わり、次のピークが来る。ファンは緊張し、空腹になり、最初のピーク時の3倍の注文をしました。ピザはひどいレートで購入されています。その後、後半が始まり、再びピザではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その間、コンタクトセンターサーバーはゆっくりと曲がり始め、リクエストの処理速度が徐々に低下します。システムコンポーネント、この場合は、コールセンターWebサーバーが不安定になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目のピークは、試合が終わったときに表示されます。</font><font style="vertical-align: inherit;">ファンとシステムはペナルティを待っています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバークラッシュの理由を分析します</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どうしたサーバーは100個の条件付きリクエストを保持できます。私たちはそれがこの力のために設計されており、もはやそれに耐えられないことを理解しています。それ自体はそれほど大きくないピークが到着します。しかし、並行性の灰色の領域ははるかに高いです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルは、同時実行性が1秒あたりの注文数と数値的に等しくなるように設計されているため、グラフ上では視覚的に同じスケールでなければなりません。ただし、蓄積されるため、はるかに高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここにグラフからの影が見えます-これらはクライアントに戻り始め、実行されたリクエストです（最初の赤い矢印で示されています）。ここの時間スケールは、時間オフセットを見るための条件付きです。 2番目のピークはすでにサーバーをノックアウトしています。彼はクラッシュし、通常より4倍少ないリクエストを処理し始めました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/n1/92/qw/n192qwxtwdrfatt_a-lb8y8eire.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラフの後半では、最初はまだいくつかのリクエストが実行されていましたが、黄色のスポットが表示されました-リクエストの処理が完全に停止しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pi/la/nv/pilanvzebdl_vl3k3hno9vwezga.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一度全体のスケジュール。</font><font style="vertical-align: inherit;">コンカレンシーが急激に進んでいることがわかります。</font><font style="vertical-align: inherit;">巨大な山が現れます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ci/l6/kb/cil6kblebzhjokmuvzkwolmngvo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、完全に異なるメトリックを分析しました：リクエストの完了速度、1秒あたりのリクエスト数。</font><font style="vertical-align: inherit;">同時実行性についても検討していません。この指標についても考えていません。</font><font style="vertical-align: inherit;">しかし、サーバーの障害の瞬間を最もよく示すのはまさにこの量であるため、無駄です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、そのような巨大な山はどこから来たのでしょうか？</font><font style="vertical-align: inherit;">最大のピーク負荷はすでに過ぎています！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リトルロー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リトルの法則は同時実行性を支配します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L（システム内の顧客の数）=λ（滞在の速度）∗ W（システム内で費やす時間）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これは平均です。しかし、私たちの状況は劇的に進展しており、平均は私たちには合いません。この方程式を微分して統合します。これを行うには、この公式を発明したJohn Littleの本を見て、そこで積分を見てください。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sx/f5/dz/sxf5dzgwc9l7low8fild5cpsrf0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システム内のエントリの数とシステムを離れる人の数があります。リクエストは到着し、すべてが完了すると終了します。以下は、同時実行性の線形成長に対応する成長グラフの領域です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ax/rv/du/axrvdu3vyx1iw9afieohv5pe-cs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
緑のリクエストはほとんどありません。</font><font style="vertical-align: inherit;">これらは実際に実装されているものです。</font><font style="vertical-align: inherit;">青いものは来るものです。</font><font style="vertical-align: inherit;">時々、通常のリクエスト数があり、状況は安定しています。</font><font style="vertical-align: inherit;">しかし、並行性はまだ成長しています。</font><font style="vertical-align: inherit;">サーバーはこの状況自体に対処できなくなります。</font><font style="vertical-align: inherit;">これは彼がすぐに落ちることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、なぜ同時実行性が高まっているのでしょうか。</font><font style="vertical-align: inherit;">定数の積分を見てみましょう。</font><font style="vertical-align: inherit;">私たちのシステムでは何も変化しませんが、積分は成長するだけの線形関数のように見えます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遊びますか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数学を覚えていない場合、積分の説明は複雑になります。</font><font style="vertical-align: inherit;">ここでは、ウォームアップしてゲームをプレイすることを提案します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームナンバー1</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前提条件</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：サーバーはリクエストを受信し、それぞれがCPUで3つの処理期間を必要とします。 CPUリソースは、すべてのタスク間で均等に分割されます。これは、プリエンプティブマルチタスク中にCPUリソースが消費される方法に似ています。セル内の数値は、このメジャーの後に残った作業量を意味します。条件付きステップごとに、新しいリクエストが到着します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエストを受け取ったとします。 3ユニットのみの作業で、最初の処理期間の終了時に2ユニットが残ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の期間では、別のリクエストが階層化され、両方のCPUがビジーになります。最初の2つのクエリに対して1つの作業単位を実行しました。最初と2番目の要求に対して、それぞれ1ユニットと2ユニットを完了する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで3つ目のリクエストが届き、楽しみが始まります。最初の要求は完了しているように見えますが、この期間では3つの要求がすでにCPUリソースを共有しているため、3つの要求すべての完了の程度は、3番目の処理期間の終わりにわずかになりました</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k-/tq/mv/k-tqmvjsqabbv0zgwt_vmkfkhy4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。 4番目のリクエストが追加され、4つのリクエストすべてがこの期間にリソースを必要としたため、並行性の度合いはすでに4になっています。一方、4番目の期間の終わりまでの最初の要求はすでに完了しており、次の期間には移動せず、CPUの作業が残っていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のリクエストはすでに完了しているので、要約すると、予想よりも3分の1長くかかりました。各タスクの水平方向の長さは、理想的には、作業量で3であると想定されました。結果に完全に満足していないことを示すために、オレンジでマークします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ap/9n/uy/ap9nuyfqun_gd1ggeidqdlomxuy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5番目の要求が到着します。並行性の程度はまだ4ですが、5列目には残りの作業の合計が多いことがわかります。これは、4列目が3列目よりも多くの作業を残したために発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに3つの期間を継続します。答えを待っています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-サーバー、こんにちは！</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
- ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tv/2m/8r/tv2m8r8selzumgub75zkvs78deu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-あなたの呼び出しは、私達にとって非常に重要である... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ud/k9/rk/udk9rk7ynqduovmhyymp7shqe0q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、最終的には、第2のリクエストに答えが来ています。応答時間は予想の2倍になります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tt/7m/iv/tt7mivq-stfincjhlwxm7wqznsq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並行性の程度はすでに3倍になっており、状況がより良く変化することを示すものは何もありません。</font><font style="vertical-align: inherit;">3番目の要求に対する応答時間が画像に収まらないため、これ以上描画しませんでした。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちのサーバーは望ましくない状態に入りました。それ自体から決して終了することはありません。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームオーバー</font></font></b></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーのGameOver状態の特徴は何ですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエストは無期限にメモリに蓄積されます。遅かれ早かれ、メモリは単に終了します。さらに、スケールの増加に伴い、さまざまなデータ構造を処理するためのCPUオーバーヘッドが増加します。たとえば、接続プールはより多くの接続のタイムアウトを追跡し、ガベージコレクターはヒープ上のより多くのオブジェクトを再チェックする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクティブオブジェクトの蓄積がもたらす可能性のあるすべての結果を調査することは、この記事の目的ではありませんが、RAMにデータを単純に蓄積するだけでも、サーバーをいっぱいにするのに十分です。さらに、クライアントサーバーが同時実行性の問題をデータベースサーバー、およびクライアントとして使用する他のサーバーに投影することは既に確認しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も興味深いのは、サーバーに低い負荷をかけたとしても、回復しないことです。</font><font style="vertical-align: inherit;">すべてのリクエストはタイムアウトで終了し、サーバーは利用可能なすべてのリソースを消費します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、私たちは実際に何を期待しましたか？！</font><font style="vertical-align: inherit;">結局のところ、私たちは意図的にサーバーに処理できない量の作業を与えました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分散システムアーキテクチャを扱うときは、一般の人々がこのような問題をどのように解決するかを考えると役に立ちます。</font><font style="vertical-align: inherit;">たとえば、ナイトクラブを見てみましょう。</font><font style="vertical-align: inherit;">入力する人が多すぎると機能しなくなります。</font><font style="vertical-align: inherit;">バウンサーはこの問題に単純に対処します。内部に何人の人がいるかを調べます。</font><font style="vertical-align: inherit;">1つが出てきた-他の打ち上げ。</font><font style="vertical-align: inherit;">新しいゲストが来て、キューのサイズに感謝します。</font><font style="vertical-align: inherit;">行列が長ければ、彼は家に帰ります。</font><font style="vertical-align: inherit;">このアルゴリズムをサーバーに適用するとどうなりますか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wg/tn/p3/wgtnp3n6qq57dqzfi-ac9s0rj1u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一度遊びましょう。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム番号2</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前提条件</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：再び、2つのCPUがあり、同じ期間に3ユニットのタスクが到着しますが、今度はバウンサーを設定します。タスクはスマートになります。キューが2であることがわかった場合、タスクはすぐに帰ります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/b4/cs/gt/b4csgtkcmi3hw1qog4fko6aus2o.png"><br>
<br>
<img src="https://habrastorage.org/webt/uw/gi/-v/uwgi-vopihzere8fs_c5f5yctfo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目のリクエストが来ました。この時期、彼は並んでいる。彼は期間の終わりに数3を持っています。 2つのCPUが2つのタスクを実行するため、残差には小数はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つのリクエストがスタックされていますが、システム内の同時実行の度合いは2です。3番目はキューにあり、カウントされません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nm/x4/yw/nmx4ywd6xdqyte5b6vkwgco3hdq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4番目が来ました-同じ写真ですが、さらに作業が蓄積されています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uq/jb/_5/uqjb_5b8whjwjzzetwqwrzjusfy.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6番目の期間では、3番目のリクエストは3番目の遅延を伴って完了し、同時実行の度合いはすでに= 4です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xs/i1/sf/xsi1sf60jniqqbamvlko-bmd_xa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時実行の度合いは2倍になりました。私たちはこれを明確に禁止しているので、彼女はもう成長できません。最高の速度で、最初の2つの要求のみが完了しました-最初にクラブに来た人と、すべての人のための十分なスペースがありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
黄色のリクエストはシステムに長く存在しましたが、それらは並んでいて、CPUリソースを引き出すことはありませんでした。そのため、内部は静かに楽しまれていました。これは、男が来て、列に並ばず、家に帰る、と言うまでも続きます。これは満たされていない要求です</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tf/qf/qr/tfqfqrsfqvhxphy3wzrdqf_cpvk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。クエリの実行時間は同じレベル（希望する時間の2倍）のままで、状況は際限なく繰り返されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xh/l2/8-/xhl28-uoe_jao9hjppy5zc30in8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時実行性レベルの単純な制限により、サーバーの実行可能性の問題が解消されることがわかります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同時実行レベルの制限を通じてサーバーの生存率を向上させる方法</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自分で書くことができる最も簡単な「用心棒」。</font><font style="vertical-align: inherit;">以下は、セマフォを使用したコードです。</font><font style="vertical-align: inherit;">外の線の長さに制限はありません。</font><font style="vertical-align: inherit;">コードは説明のみを目的としており、コピーする必要はありません。</font></font><br>
<br>
<pre><code class="swift hljs">const int <span class="hljs-type">MaxConcurrency</span> = <span class="hljs-number">100</span>;
<span class="hljs-type">SemaphoreSlim</span> bulkhead = new <span class="hljs-type">SemaphoreSlim</span>(<span class="hljs-type">MaxConcurrency</span>, <span class="hljs-type">MaxConcurrency</span>);<font></font>
<font></font>
<span class="hljs-keyword">public</span> async <span class="hljs-type">Task</span> <span class="hljs-type">ProcessRequest</span>()<font></font>
{<font></font>
    <span class="hljs-keyword">if</span> (!await bulkhead.<span class="hljs-type">WaitAsync</span>())<font></font>
    {<font></font>
        <span class="hljs-keyword">throw</span> new <span class="hljs-type">OperationCanceledException</span>();<font></font>
    }<font></font>
    <span class="hljs-keyword">try</span> { await <span class="hljs-type">ProcessRequestInternal</span>(); <span class="hljs-keyword">return</span>; }<font></font>
    finally { bulkhead.<span class="hljs-type">Release</span>(); }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
制限付きキューを作成するには、2つのセマフォが必要です。これに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Microsoftが推奨</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">するPollyライブラリ</font></a><font style="vertical-align: inherit;">が適してい</font><font style="vertical-align: inherit;">ます。隔壁パターンに注意してください。文字通り「隔壁」-船が沈まないようにする構造要素。正直なところ、「用心棒」という言葉の方が適していると思います。重要なことに、このパターンにより、サーバーは絶望的な状況でも生き残ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、サーバーからロードベンチで可能なすべてのことを絞り込み、サーバーが保持できる要求の数を決定します。たとえば、100と判断しました。隔壁を付けました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、サーバーは必要な数のリクエストのみをスキップし、残りはキューに入れられます。</font><font style="vertical-align: inherit;">マージンがあるように、少し低い値を選択することをお勧めします。</font><font style="vertical-align: inherit;">コンテキストと特定の状況に強く依存しているため、この件については既成の推奨事項はありません。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーの動作がリソースの観点から負荷に安定して依存している場合、この数は制限に近づく可能性があります。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">媒体が負荷変動の影響を受ける場合は、これらの変動のサイズを考慮して、より保守的な数値を選択する必要があります。</font><font style="vertical-align: inherit;">このような変動はさまざまな理由で発生する可能性があります。たとえば、GCのパフォーマンス環境は、CPUの負荷の小さなピークによって特徴付けられます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーがスケジュールに従って定期的なタスクを実行する場合は、これも考慮する必要があります。</font><font style="vertical-align: inherit;">サーバーを低下させることなく、同時に送信できるクエリの数を計算するアダプティブバルクヘッドを開発することもできます（ただし、これは既にこの調査の範囲外です）。</font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クエリ実験</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後にこの死後を見てください。これは二度と見られません。</font></font><br>
<img src="https://habrastorage.org/webt/n1/qn/1i/n1qn1irfrgm-fezifzonark7j94.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このすべての灰色のヒープは、サーバーのクラッシュと明確に相関しています。</font><font style="vertical-align: inherit;">グレイはサーバーにとって死です。</font><font style="vertical-align: inherit;">それを切り取って、何が起こるか見てみましょう。</font><font style="vertical-align: inherit;">特定の数のリクエストが帰宅し、単に実行されないようです。</font><font style="vertical-align: inherit;">しかし、どのくらいですか？</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内側100、外側100</font></font></h4><br>
<img src="https://habrastorage.org/webt/u0/6c/m5/u06cm5odrt-dxltnomhwatmhwze.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのサーバーは非常によく、楽しい生活を始めました。</font><font style="vertical-align: inherit;">彼は常に最大の力で耕す。</font><font style="vertical-align: inherit;">もちろん、ピークが発生すると、彼は追い出されますが、長い間ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
成功に触発されて、私たちは彼がまったく跳ね返されないように努めます。</font><font style="vertical-align: inherit;">キューの長さを増やしてみましょう。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内側100、外側500</font></font></h4><br>
<img src="https://habrastorage.org/webt/sk/5i/gi/sk5igi9cfgyjajp8lujawwunace.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
良くなったが、しっぽは大きくなった。</font><font style="vertical-align: inherit;">これらは、後で長時間実行されるリクエストです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内側100、外側1000</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何かが良くなったので、それを不条理の点に持っていこうとしましょう。キューの長さを同時に提供できる時間の10倍に解決しましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2g/qd/s6/2gqds68piszleawyid_yk_rtdhg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラブのメタファーとバウンサーについて話す場合、この状況はほとんど起こり得ません。クラブで過ごす時間よりも長い間エントランスで待つことを望んでいる人はいません。また、これがシステムの通常の状況であると偽ることはしません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各画面を30秒間読み込んで会社の評判を損なうことで、サイトやモバイルアプリケーションでクライアントを苦しめるよりも、クライアントにまったくサービスを提供しない方がよいでしょう。一部のお客様に正直に、現在は対応できないことを伝えた方がよいでしょう。それ以外の場合は、状況がかなり長い間続くことをグラフが示しているため、すべての顧客へのサービスが数倍遅くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つのリスクがあります。他のシステムコンポーネントがそのようなサーバーの動作用に設計されていない可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、最初のオプション「100/100」に戻り、容量のスケーリング方法を検討します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">勝者-内側100、外側100</font></font></h4> <br>
<img src="https://habrastorage.org/webt/z5/cg/pv/z5cgpvn4qs9abj5ifewfelapa6g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¯\ _（ツ）_ /¯ </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのパラメーターを使用すると、実行時の最大の劣化は「公称値」のちょうど2倍になります。同時に、クエリの実行時間は100％低下します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントがランタイムに敏感な場合（そして、これは通常、人間のクライアントとサーバークライアントの両方に当てはまります）、キューの長さをさらに短くすることを考えることができます。この場合、内部の同時実行性の一部の割合をとることができ、サービスが応答時間で平均してこの割合を超えて低下しないことが確実にわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、私たちはキューを作成しようとしているのではなく、負荷の変動から身を守ろうとしています。</font><font style="vertical-align: inherit;">ここでは、バルクヘッドの最初のパラメータ（内部の数量）を決定する場合と同様に、クライアントで発生する可能性のある負荷の変動を決定することが役立ちます。</font><font style="vertical-align: inherit;">したがって、大まかに言えば、潜在的なサービスからの利益を逃してしまうケースがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーと対話するシステムの他のコンポーネントに耐えられる遅延の変動を判別することはさらに重要です。</font><font style="vertical-align: inherit;">したがって、サービスを完全に失う危険を冒すことなく、既存のシステムを最大限に活用していることがわかります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">診断と治療</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
制御されていない並行処理を隔壁分離で処理しています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法は、このシリーズの記事で説明した他の方法と同様に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Pollyライブラリ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって便利に実装され</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法の利点は、システムの個々のコンポーネント自体を不安定にすることが非常に難しいことです。</font><font style="vertical-align: inherit;">システムは、成功した要求を完了するための時間に関して非常に予測可能な動作を獲得し、成功した完全な要求のはるかに高い可能性 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、すべての問題を解決できるわけではありません。</font><font style="vertical-align: inherit;">たとえば、サーバーの電力不足の問題です。</font><font style="vertical-align: inherit;">この状況では、負荷が急上昇した場合に「バラストを落とす」ことを明らかに決定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの研究が扱っていないさらなる測定には、例えば、動的スケーリングが含まれる場合があります。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja461071/index.html">ビルダー向けのB2Bサービスの例でのデータベースクエリの最適化</a></li>
<li><a href="../ja461073/index.html">オンライン地図をスマートフォンのナビゲーターに接続します。パート3-OverpassTurbo</a></li>
<li><a href="../ja461075/index.html">ビジネス分析。ITオブジェクト、コンポーネント、ツール</a></li>
<li><a href="../ja461077/index.html">ペンテスターはどのように調理されますか？デジタルセキュリティインターンの入学試験</a></li>
<li><a href="../ja461079/index.html">渋滞のない都市</a></li>
<li><a href="../ja461083/index.html">クライアント/サーバーユーティリティWindowsの機能を備えたソフトウェアの作成、パート02</a></li>
<li><a href="../ja461085/index.html">Androidアプリケーションで言語を切り替える</a></li>
<li><a href="../ja461087/index.html">ゲーム用のダンジョンと洞窟を生成する</a></li>
<li><a href="../ja461091/index.html">LED Camelionランプ</a></li>
<li><a href="../ja461093/index.html">OpenStreetMap No. 469の世界からのお知らせ（07/09/2019-07/07/2019）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>