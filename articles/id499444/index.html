<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¡ ğŸ˜” ğŸ» Postgres: bloat, pg_repack, dan batasan yang ditangguhkan ğŸ§“ğŸ¾ ğŸ§œğŸ¼ ğŸ‘¨ğŸ½â€ğŸ”¬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Efek dari tabel dan indeks kembung (bloat) sudah dikenal luas dan tidak hanya ada di Postgres. Ada cara untuk menghadapinya "out of the box" seperti V...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Postgres: bloat, pg_repack, dan batasan yang ditangguhkan</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/miro/blog/499444/"><img src="https://habrastorage.org/webt/vf/eu/y5/vfeuy53s9e1md_jhdwxbkkmr-8e.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Efek dari tabel dan indeks kembung (bloat) sudah dikenal luas dan tidak hanya ada di Postgres. </font><font style="vertical-align: inherit;">Ada cara untuk menghadapinya "out of the box" seperti VACUUM FULL atau CLUSTER, tetapi mereka memblokir tabel selama operasi dan karenanya tidak selalu dapat digunakan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini akan memiliki sedikit teori tentang bagaimana mengasapi terjadi, bagaimana menghadapinya, tentang kendala yang ditangguhkan, dan tentang masalah yang mereka bawa ke penggunaan ekstensi pg_repack.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini didasarkan pada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presentasi saya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di PgConf.Russia 2020.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/8vaVeCKuz6M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa kembung terjadi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postgres didasarkan pada model multi-versi ( </font></font><abbr title="Kontrol Konkurensi Multi-Versi"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MVCC</font></font></a></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Esensinya adalah bahwa setiap baris dalam tabel dapat memiliki beberapa versi, sementara transaksi tidak lebih dari satu versi ini, tetapi tidak harus sama. Ini memungkinkan beberapa transaksi untuk bekerja secara bersamaan dan hampir tidak memiliki pengaruh satu sama lain. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jelas, semua versi ini perlu disimpan. Postgres bekerja dengan halaman memori per halaman dan halaman adalah jumlah minimum data yang dapat dibaca dari disk atau tertulis. Mari kita lihat contoh kecil untuk memahami bagaimana ini terjadi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan kita memiliki tabel di mana kita telah menambahkan beberapa catatan. Di halaman pertama file tempat tabel disimpan, data baru telah muncul. Ini adalah versi live string yang tersedia untuk transaksi lain setelah komit (untuk kesederhanaan, kami akan menganggap bahwa tingkat isolasi yang dilakukan Read Read). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pb/ep/av/pbepavyhm5_alpqup33j8vfcocm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian kami memperbarui salah satu entri dan dengan demikian menandai versi lama sebagai tidak relevan. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/na/tr/tg/natrtgitck2f7ymtdalnr_coecu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Langkah demi langkah, memperbarui dan menghapus versi baris, kami mendapat halaman di mana sekitar setengah dari data adalah "sampah". Data ini tidak terlihat oleh transaksi apa pun. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_j/8d/ji/_j8djifah3idpuohxwseop01xcw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postgres memiliki mekanisme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VACUUM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang membersihkan versi yang tidak relevan dan membebaskan ruang untuk data baru. Tetapi jika tidak cukup dikonfigurasi secara agresif atau sibuk bekerja di tabel lain, maka "data sampah" tetap ada, dan kita harus menggunakan halaman tambahan untuk data baru. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi dalam contoh kita, pada suatu titik waktu, tabel akan terdiri dari empat halaman, tetapi hanya akan ada setengah data langsung di dalamnya. Akibatnya, saat mengakses tabel, kita akan membaca lebih banyak data daripada yang diperlukan. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nz/ni/rn/nznirnw2kenpvkn7kv7hqwi1k08.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan jika VACUUM sekarang menghapus semua versi string yang tidak relevan, situasinya tidak akan membaik secara dramatis. Kami akan memiliki ruang kosong di halaman atau bahkan seluruh halaman untuk baris baru, tetapi kami akan terus membaca lebih banyak data daripada yang diperlukan.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Omong-omong, jika halaman yang benar-benar kosong (yang kedua dalam contoh kita) berada di akhir file, maka VACUUM dapat memangkasnya. </font><font style="vertical-align: inherit;">Tapi sekarang dia ada di tengah, jadi tidak ada yang bisa dilakukan dengannya. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fy/ix/rq/fyixrqdxzpivbooplfjoqpeyc-q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika jumlah halaman kosong atau sangat datar tersebut menjadi besar, yang disebut mengasapi, itu mulai mempengaruhi kinerja. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Segala sesuatu yang dijelaskan di atas adalah mekanisme terjadinya mengasapi dalam tabel. </font><font style="vertical-align: inherit;">Dalam indeks, ini terjadi dengan cara yang hampir sama.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah saya mengalami gembung?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada beberapa cara untuk menentukan apakah Anda kembung. Gagasan pertama adalah menggunakan statistik Postgres internal, yang berisi informasi perkiraan tentang jumlah baris dalam tabel, jumlah baris "langsung", dll. Di Internet, Anda dapat menemukan banyak variasi skrip yang sudah jadi. Kami mengambil sebagai dasar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">naskah</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari PostgreSQL Pakar, yang dapat mengevaluasi tabel mengasapi bersama dengan roti bakar dan indeks btree mengasapi. Dalam pengalaman kami, kesalahannya adalah 10-20%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cara lain adalah dengan menggunakan ekstensi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pgstattuple</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang memungkinkan Anda untuk melihat ke dalam halaman dan mendapatkan nilai mengasapi yang diperkirakan dan akurat. Tetapi dalam kasus kedua, Anda harus memindai seluruh tabel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nilai mengasapi kecil, hingga 20%, kami anggap dapat diterima. </font><font style="vertical-align: inherit;">Ini dapat dianggap sebagai analog dari fillfactor untuk </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tabel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indeks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pada 50% ke atas, masalah kinerja dapat dimulai.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara mengatasi kembung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada beberapa cara untuk mengatasi mengasapi kotak di Postgres, tetapi mereka jauh dari selalu cocok untuk semua orang. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atur AUTOVACUUM agar mengasapi tidak terjadi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dan lebih tepatnya, untuk mempertahankannya pada tingkat yang dapat diterima untuk Anda. Ini tampaknya menjadi saran "kapten", tetapi dalam kenyataannya ini tidak selalu mudah dicapai. Misalnya, Anda secara aktif mengembangkan dengan perubahan reguler pada skema data atau semacam migrasi data yang terjadi. Akibatnya, profil pemuatan Anda dapat sering berubah dan, biasanya, dapat berbeda untuk tabel yang berbeda. Ini berarti bahwa Anda harus terus bekerja sedikit di depan kurva dan menyesuaikan AUTOVACUUM dengan perubahan profil setiap tabel. Tetapi jelas bahwa ini tidak mudah.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alasan umum lainnya bahwa AUTOVACUUM tidak punya waktu untuk memproses tabel adalah adanya transaksi yang panjang yang mencegahnya dari kliring data karena fakta bahwa itu tersedia untuk transaksi ini. Rekomendasi di sini juga jelas - singkirkan transaksi yang menggantung dan meminimalkan waktu transaksi aktif. Tetapi jika beban pada aplikasi Anda adalah hibrida dari OLAP dan OLTP, maka pada saat yang sama Anda dapat memiliki banyak pembaruan dan permintaan singkat, serta operasi yang panjang - misalnya, membuat laporan. Dalam situasi seperti itu, ada baiknya memikirkan untuk menyebarkan beban ke pangkalan yang berbeda, yang akan memungkinkan penyetelan yang lebih baik dari masing-masing.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh lain - bahkan jika profilnya seragam, tetapi basis datanya berada di bawah beban yang sangat tinggi, bahkan AUTOVACUUM yang paling agresif pun tidak dapat mengatasinya, dan akan terjadi bloat. Penskalaan (vertikal atau horizontal) adalah satu-satunya solusi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi bagaimana dengan situasi ketika Anda mengkonfigurasi AUTOVACUUM, tetapi mengasapi terus tumbuh. </font><b><font style="vertical-align: inherit;">VACUUM FULL</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Command</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membangun kembali isi tabel dan indeks dan hanya menyisakan data yang relevan di dalamnya. Untuk menghilangkan mengasapi, ia bekerja dengan sempurna, tetapi selama eksekusi, kunci eksklusif di atas meja (AccessExclusiveLock) ditangkap, yang tidak akan mengizinkan kueri ke tabel ini, bahkan memilih. Jika Anda mampu menghentikan layanan Anda atau bagian dari itu untuk sementara waktu (dari puluhan menit hingga beberapa jam, tergantung pada ukuran database dan perangkat keras Anda), maka opsi ini adalah yang terbaik. Sayangnya, kami tidak punya waktu untuk menjalankan VACUUM FULL selama pemeliharaan terjadwal, jadi metode ini tidak cocok untuk kami. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perintah </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CLUSTER</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu juga membangun kembali isi tabel, seperti halnya VACUUM FULL, pada saat yang sama memungkinkan Anda untuk menentukan indeks yang menurutnya data akan dipesan secara fisik pada disk (tetapi di masa depan pesanan tidak dijamin). Dalam situasi tertentu, ini adalah optimasi yang baik untuk sejumlah pertanyaan - dengan membaca beberapa catatan berdasarkan indeks. Kerugian dari perintah ini sama dengan VACUUM FULL - itu mengunci tabel selama operasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perintah </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">REINDEX</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mirip dengan dua sebelumnya, tetapi membangun kembali indeks tertentu atau semua indeks di atas meja. Kunci sedikit lebih lemah: ShareLock di atas meja (mencegah modifikasi, tetapi memungkinkan Anda untuk memilih) dan AccessExclusiveLock pada indeks yang dapat disetel (memblokir permintaan menggunakan indeks ini). Namun, dalam versi 12 Postgres, parameter </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CONCURRENTLY</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang memungkinkan Anda membangun kembali indeks tanpa memblokir penambahan, modifikasi, atau penghapusan catatan secara paralel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam versi Postgres sebelumnya, Anda dapat mencapai hasil yang mirip dengan REINDEX CONCURRENTLY dengan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CREATE INDEX CONCURRENTLY</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini memungkinkan Anda untuk membuat indeks tanpa pemblokiran ketat (ShareUpdateExclusiveLock, yang tidak mengganggu kueri paralel), lalu mengganti indeks lama dengan yang baru dan menghapus indeks yang lama. Ini menghilangkan indeks kembung tanpa mengganggu aplikasi Anda. Penting untuk mempertimbangkan bahwa ketika membangun kembali indeks akan ada beban tambahan pada subsistem disk. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, jika ada cara bagi indeks untuk menghilangkan bloat "panas", maka untuk tabel tidak ada. Di sini berbagai ekstensi eksternal ikut </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">berperan</font></a><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_repack</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(sebelumnya pg_reorg), </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pgcompact</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pgcompacttable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">dan lainnya. </font><font style="vertical-align: inherit;">Dalam kerangka artikel ini, saya tidak akan membandingkannya dan hanya akan berbicara tentang pg_repack, yang, setelah beberapa perbaikan, kami gunakan di rumah.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara kerja pg_repack</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/5j/bp/ng/5jbpng5ietzdlekjqc32gdf_5cs.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan kita memiliki tabel yang sangat normal untuk diri kita sendiri - dengan indeks, batasan, dan, sayangnya, dengan mengasapi. Langkah pertama adalah pg_repack membuat tabel log untuk menyimpan data tentang semua perubahan selama operasi. Pemicu akan mereplikasi perubahan ini untuk setiap memasukkan, memperbarui, dan menghapus. Kemudian dibuat tabel yang mirip dengan aslinya dalam struktur, tetapi tanpa indeks dan batasan, agar tidak memperlambat proses memasukkan data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, pg_repack mentransfer data dari yang lama ke tabel baru, secara otomatis memfilter semua baris yang tidak relevan, dan kemudian membuat indeks untuk tabel baru. Selama pelaksanaan semua operasi ini, perubahan diakumulasikan dalam tabel log.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Langkah selanjutnya adalah mentransfer perubahan ke tabel baru. </font><font style="vertical-align: inherit;">Migrasi dilakukan dalam beberapa iterasi, dan ketika kurang dari 20 entri tetap dalam tabel log, pg_repack menangkap kunci ketat, mentransfer data terbaru dan mengganti tabel lama dengan yang baru di tabel sistem Postgres. </font><font style="vertical-align: inherit;">Ini adalah satu-satunya titik waktu yang sangat singkat ketika Anda tidak dapat bekerja dengan tabel. </font><font style="vertical-align: inherit;">Setelah itu, tabel lama dan tabel dengan log dihapus dan ruang dibebaskan di sistem file. </font><font style="vertical-align: inherit;">Proses selesai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara teori, semuanya tampak hebat, apa yang dipraktikkan? </font><font style="vertical-align: inherit;">Kami menguji pg_repack tanpa memuat dan di bawah beban, kami memeriksa operasinya jika terjadi penghentian prematur (dengan kata lain, Ctrl + C). </font><font style="vertical-align: inherit;">Semua tes positif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami pergi ke prod - dan kemudian semuanya berjalan salah seperti yang kami harapkan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pancake pertama pada prod</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada kluster pertama, kami menerima kesalahan tentang melanggar batasan unik:</font></font><br>
<br>
<pre><code class="bash hljs">$ ./pg_repack -t tablename -o id<font></font>
INFO: repacking table <span class="hljs-string">"tablename"</span><font></font>
ERROR: query failed: <font></font>
    ERROR: duplicate key value violates unique constraint <span class="hljs-string">"index_16508"</span><font></font>
DETAIL:  Key (id, index)=(100500, 42) already exists.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pembatasan ini memiliki nama yang dihasilkan secara otomatis index_16508 - itu dibuat oleh pg_repack. </font><font style="vertical-align: inherit;">Dengan atribut yang termasuk dalam komposisinya, kami menentukan batasan "kami", yang sesuai dengannya. </font><font style="vertical-align: inherit;">Masalahnya ternyata bukan pembatasan biasa, tetapi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kendala yang ditangguhkan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mis. </font><font style="vertical-align: inherit;">verifikasi dilakukan lebih lambat dari perintah sql, yang mengarah pada konsekuensi yang tidak terduga.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kendala yang ditangguhkan: mengapa mereka dibutuhkan dan bagaimana cara kerjanya</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sedikit teori tentang kendala yang ditangguhkan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan contoh sederhana: kami memiliki tabel referensi mobil dengan dua atribut - nama dan urutan mobil di direktori.</font></font><br>
<img src="https://habrastorage.org/webt/n8/1s/td/n81stdw9kie5wll03ylnel18aie.png" align="right"><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> cars<font></font>
(<font></font>
  <span class="hljs-type">name</span> <span class="hljs-type">text</span> <span class="hljs-keyword">constraint</span> pk_cars <span class="hljs-keyword">primary key</span>,<font></font>
  ord <span class="hljs-type">integer</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">constraint</span> uk_cars <span class="hljs-keyword">unique</span><font></font>
);<font></font>
</code></pre><br>
<br clear="all"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Katakanlah kita perlu menukar mobil pertama dan kedua. </font><font style="vertical-align: inherit;">Solusi "di dahi" adalah memperbarui nilai pertama ke yang kedua, dan yang kedua ke yang pertama:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">begin</span>;
  <span class="hljs-keyword">update</span> cars <span class="hljs-keyword">set</span> ord = <span class="hljs-number">2</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">'audi'</span>;
  <span class="hljs-keyword">update</span> cars <span class="hljs-keyword">set</span> ord = <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">'bmw'</span>;
<span class="hljs-keyword">commit</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi ketika mengeksekusi kode ini, kami diharapkan mendapatkan pelanggaran batasan, karena urutan nilai dalam tabel adalah unik:</font></font><br>
<br>
<pre><code class="bash hljs">[23305] ERROR: duplicate key value violates unique constraint â€œuk_carsâ€<font></font>
Detail: Key (ord)=(2) already exists.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana cara melakukannya secara berbeda? Opsi satu: tambahkan pengganti nilai tambahan dengan pesanan yang dijamin tidak ada dalam tabel, misalnya, "-1". Dalam pemrograman, ini disebut "bertukar nilai dua variabel melalui yang ketiga." Satu-satunya kelemahan dari metode ini adalah pembaruan tambahan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Opsi dua: mendesain ulang tabel untuk menggunakan tipe data titik-mengambang untuk nilai pesanan, bukan bilangan bulat. Kemudian, ketika memperbarui nilai dari 1, misalnya, ke 2.5, catatan pertama akan secara otomatis "berdiri" antara yang kedua dan ketiga. Solusi ini berfungsi, tetapi ada dua batasan. Pertama, itu tidak akan bekerja untuk Anda jika nilainya digunakan di suatu tempat di antarmuka. Kedua, tergantung pada keakuratan tipe data, Anda akan memiliki jumlah kemungkinan insert yang terbatas sebelum menghitung ulang nilai semua record.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Opsi tiga: buat pembatasan ditangguhkan sehingga diperiksa hanya pada saat komit:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> cars<font></font>
(<font></font>
  <span class="hljs-type">name</span> <span class="hljs-type">text</span> <span class="hljs-keyword">constraint</span> pk_cars <span class="hljs-keyword">primary key</span>,<font></font>
  ord <span class="hljs-type">integer</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">constraint</span> uk_cars <span class="hljs-keyword">unique</span> <span class="hljs-keyword">deferrable</span> <span class="hljs-keyword">initially</span> <span class="hljs-keyword">deferred</span>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena logika permintaan awal kami memastikan bahwa semua nilai unik pada saat komit, itu akan berhasil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh di atas, tentu saja, sangat sintetis, tetapi ia mengungkapkan idenya. </font><font style="vertical-align: inherit;">Dalam aplikasi kami, kami menggunakan batasan yang ditangguhkan untuk mengimplementasikan logika yang bertanggung jawab untuk menyelesaikan konflik sambil bekerja secara bersamaan dengan objek widget umum di papan tulis. </font><font style="vertical-align: inherit;">Menggunakan batasan semacam itu memungkinkan kita membuat kode aplikasi sedikit lebih mudah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, tergantung pada jenis kendala di Postgres, ada tiga tingkat rincian untuk memeriksanya: tingkat baris, transaksi, dan ekspresi. </font></font><br>
<img src="https://habrastorage.org/webt/vn/bw/qq/vnbwqqmhgjpnd7kb8dtxpixb8xi.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sumber: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengemis</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PERIKSA dan BUKAN NULL selalu dicentang di tingkat baris, untuk pembatasan lain, seperti dapat dilihat dari tabel, ada opsi yang berbeda. </font><font style="vertical-align: inherit;">Baca lebih lanjut di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk meringkas secara singkat, pembatasan yang tertunda dalam beberapa situasi memberikan kode lebih mudah dibaca dan lebih sedikit perintah. </font><font style="vertical-align: inherit;">Namun, Anda harus membayar untuk ini dengan mempersulit proses debug, sejak saat kesalahan terjadi dan saat Anda mengetahuinya dipisahkan dalam waktu. </font><font style="vertical-align: inherit;">Masalah lain yang mungkin adalah bahwa penjadwal tidak selalu dapat membangun rencana optimal jika kendala tertunda terlibat dalam permintaan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perbaikan pg_repack</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami telah menemukan batasan yang tertunda, tetapi bagaimana kaitannya dengan masalah kami? </font><font style="vertical-align: inherit;">Ingat kesalahan yang sebelumnya kami terima:</font></font><br>
<br>
<pre><code class="bash hljs">$ ./pg_repack -t tablename -o id<font></font>
INFO: repacking table <span class="hljs-string">"tablename"</span><font></font>
ERROR: query failed: <font></font>
    ERROR: duplicate key value violates unique constraint <span class="hljs-string">"index_16508"</span>
DETAIL:  Key (id, index)=(100500, 42) already exists.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu terjadi pada saat menyalin data dari tabel log ke tabel baru. Terlihat aneh karena data dalam tabel log dilakukan bersama dengan data dalam tabel asli. Jika mereka memenuhi batasan dari tabel asli, lalu bagaimana mereka bisa melanggar batasan yang sama di yang baru? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ternyata, akar masalahnya terletak pada langkah sebelumnya dari pg_repack, di mana hanya indeks yang dibuat, tetapi bukan batasan: tabel lama memiliki kendala unik, dan yang baru malah membuat indeks unik.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_y/da/fc/_ydafcxizllawi1jo3o5ai-x-kg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penting untuk dicatat di sini bahwa jika batasannya normal dan tidak ditangguhkan, maka indeks unik yang dibuat bukan setara dengan pembatasan ini, karena </font><font style="vertical-align: inherit;">Kendala unik Postgres diimplementasikan dengan membuat indeks unik. </font><font style="vertical-align: inherit;">Tetapi dalam kasus kendala yang ditangguhkan, perilaku tidak sama, karena indeks tidak dapat ditangguhkan dan selalu diperiksa pada saat perintah sql dieksekusi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, inti dari masalahnya terletak pada "penundaan" dari cek: pada tabel asli itu terjadi pada saat komit, dan pada yang baru - pada saat pelaksanaan perintah sql. </font><font style="vertical-align: inherit;">Jadi kita perlu memastikan bahwa pemeriksaan dilakukan dengan cara yang sama dalam kedua kasus: selalu ditunda, atau selalu segera. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi ide apa yang kita miliki?</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat indeks yang mirip dengan ditangguhkan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gagasan pertama adalah melakukan kedua pemeriksaan dalam mode langsung. Hal ini dapat menimbulkan beberapa pemicu positif palsu dari pembatasan, tetapi jika ada beberapa di antaranya, maka ini seharusnya tidak mempengaruhi pekerjaan pengguna, karena konflik seperti itu normal bagi mereka. Mereka terjadi, misalnya, ketika dua pengguna mulai secara bersamaan mengedit widget yang sama, dan klien pengguna kedua tidak punya waktu untuk mendapatkan informasi bahwa widget sudah dikunci untuk diedit oleh pengguna pertama. Dalam situasi ini, server menolak pengguna kedua, dan kliennya memutar kembali perubahan dan memblokir widget. Beberapa saat kemudian, ketika pengguna pertama selesai mengedit, yang kedua akan menerima informasi bahwa widget tidak lagi terkunci, dan akan dapat mengulangi tindakannya.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/dw/oq/jw/dwoqjwhuqva3veavihajfcd5t4c.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memastikan bahwa pemeriksaan selalu dalam mode darurat, kami membuat indeks baru yang mirip dengan batasan tangguhan asli:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">CONCURRENTLY</span> uk_tablename__immediate <span class="hljs-keyword">ON</span> tablename (id, <span class="hljs-keyword">index</span>);
<span class="hljs-comment">-- run pg_repack</span>
<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">CONCURRENTLY</span> uk_tablename__immediate;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di lingkungan pengujian, kami hanya menerima beberapa kesalahan yang diharapkan. Keberhasilan! Kami kembali meluncurkan pg_repack pada prod dan mendapat 5 kesalahan pada cluster pertama dalam satu jam kerja. Ini adalah hasil yang dapat diterima. Namun, sudah di cluster kedua, jumlah kesalahan meningkat berkali-kali dan kami harus menghentikan pg_repack. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kenapa ini terjadi? Probabilitas kesalahan tergantung pada berapa banyak pengguna yang bekerja secara bersamaan dengan widget yang sama. Rupanya, pada saat itu dengan data yang disimpan di cluster pertama, ada perubahan kompetitif yang jauh lebih sedikit daripada yang lain, yaitu kami hanya "beruntung." </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gagasan itu tidak berhasil. Pada saat itu, kami melihat dua opsi solusi lain: menulis ulang kode aplikasi kami untuk mengabaikan batasan yang tertunda, atau "mengajar" pg_repack untuk bekerja dengannya. Kami telah memilih yang kedua.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ganti indeks di tabel baru dengan batasan yang ditangguhkan dari tabel sumber</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tujuan revisi jelas - jika tabel asli memiliki batasan yang ditangguhkan, maka untuk yang baru Anda perlu membuat batasan seperti itu, bukan indeks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menguji perubahan kami, kami menulis tes sederhana:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tabel dengan pembatasan yang ditangguhkan dan satu catatan;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masukkan data dalam loop yang bertentangan dengan catatan yang ada;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melakukan pembaruan - data tidak lagi konflik;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">komit perubahan.</font></font></li>
</ul><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test_table<font></font>
(<font></font>
  id <span class="hljs-type">serial</span>,<font></font>
  val <span class="hljs-type">int</span>,
  <span class="hljs-keyword">constraint</span> uk_test_table__val <span class="hljs-keyword">unique</span> (val) <span class="hljs-keyword">deferrable</span> <span class="hljs-keyword">initially</span> <span class="hljs-keyword">deferred</span> <font></font>
);<font></font>
</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test_table (val) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">0</span>);
<span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">1.</span><span class="hljs-number">.10000</span> <span class="hljs-keyword">LOOP</span>
  <span class="hljs-keyword">BEGIN</span>
    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test_table <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">0</span>) <span class="hljs-keyword">RETURNING</span> id <span class="hljs-keyword">INTO</span> v_id;
    <span class="hljs-keyword">UPDATE</span> test_table <span class="hljs-keyword">set</span> val = i <span class="hljs-keyword">where</span> id = v_id;
    <span class="hljs-keyword">COMMIT</span>;
  <span class="hljs-keyword">END</span>;
<span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versi asli pg_repack selalu macet di sisipan pertama, versi revisi berfungsi tanpa kesalahan. </font><font style="vertical-align: inherit;">Baik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami pergi ke prod dan sekali lagi kami mendapatkan kesalahan dalam fase yang sama menyalin data dari tabel log ke yang baru:</font></font><br>
<br>
<pre><code class="bash hljs">$ ./pg_repack -t tablename -o id<font></font>
INFO: repacking table <span class="hljs-string">"tablename"</span><font></font>
ERROR: query failed: <font></font>
    ERROR: duplicate key value violates unique constraint <span class="hljs-string">"index_16508"</span>
DETAIL:  Key (id, index)=(100500, 42) already exists.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Situasi klasik: semuanya berfungsi pada lingkungan pengujian, tetapi tidak pada prod ?!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APPLY_COUNT dan sambungan dua bets</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mulai menganalisis kode secara harfiah baris demi baris dan menemukan poin penting: data ditransfer dari tabel log ke yang baru dengan batch, konstanta APPLY_COUNT menunjukkan ukuran batch:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">for</span> (;;)<font></font>
{<font></font>
num = apply_log(connection, table, APPLY_COUNT);<font></font>
<font></font>
<span class="hljs-keyword">if</span> (num &gt; MIN_TUPLES_BEFORE_SWITCH)
     <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">/* there might be still some tuples, repeat. */</span><font></font>
...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya adalah bahwa data transaksi asli, di mana beberapa operasi berpotensi melanggar pembatasan, dapat ditransfer ke gabungan dua batch selama transfer - setengah dari tim akan berkomitmen dalam pertandingan pertama dan setengah lainnya di yang kedua. Dan inilah betapa beruntungnya: jika tim dalam kelompok pertama tidak melanggar apa pun, maka semuanya baik-baik saja, tetapi jika mereka melanggar - kesalahan terjadi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
APPLY_COUNT sama dengan 1000 entri, yang menjelaskan mengapa pengujian kami berhasil - tidak mencakup kasus "persimpangan batch". Kami menggunakan dua perintah - masukkan dan perbarui, jadi 500 transaksi dari dua tim selalu ditempatkan dalam batch dan kami tidak mengalami masalah. Setelah menambahkan pembaruan kedua, hasil edit kami berhenti bekerja:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">1.</span><span class="hljs-number">.10000</span> <span class="hljs-keyword">LOOP</span>
  <span class="hljs-keyword">BEGIN</span>
    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test_table <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>) <span class="hljs-keyword">RETURNING</span> id <span class="hljs-keyword">INTO</span> v_id;
    <span class="hljs-keyword">UPDATE</span> test_table <span class="hljs-keyword">set</span> val = i <span class="hljs-keyword">where</span> id = v_id;
    <span class="hljs-keyword">UPDATE</span> test_table <span class="hljs-keyword">set</span> val = i <span class="hljs-keyword">where</span> id = v_id; <span class="hljs-comment">-- one more update</span>
    <span class="hljs-keyword">COMMIT</span>;
  <span class="hljs-keyword">END</span>;
<span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, tugas selanjutnya adalah memastikan bahwa data dari tabel sumber yang berubah dalam satu transaksi termasuk dalam tabel baru juga dalam transaksi yang sama.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penolakan Butching</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan lagi kami punya dua solusi. </font><font style="vertical-align: inherit;">Pertama: mari kita sepenuhnya meninggalkan batching dan melakukan transfer data dalam satu transaksi. </font><font style="vertical-align: inherit;">Yang mendukung solusi ini adalah kesederhanaannya - perubahan kode yang diperlukan minimal (omong-omong, dalam versi yang lebih lama maka pg_reorg bekerja seperti itu). </font><font style="vertical-align: inherit;">Tapi ada masalah - kami membuat transaksi panjang, dan ini, seperti yang dikatakan sebelumnya, merupakan ancaman bagi munculnya bloat baru.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi kedua lebih rumit, tetapi mungkin lebih benar: buat kolom di tabel log dengan pengidentifikasi transaksi yang menambahkan data ke tabel. Kemudian, saat menyalin data, kami akan dapat mengelompokkannya berdasarkan atribut ini dan memastikan bahwa perubahan terkait akan ditransfer bersama. Kumpulan akan dibentuk dari beberapa transaksi (atau satu yang besar) dan ukurannya akan bervariasi tergantung pada seberapa banyak data telah berubah dalam transaksi ini. Penting untuk dicatat bahwa karena data transaksi yang berbeda jatuh ke dalam tabel log dalam urutan acak, itu tidak akan mungkin untuk membacanya secara berurutan, seperti sebelumnya. seqscan untuk setiap permintaan yang difilter oleh tx_id terlalu mahal, Anda memerlukan indeks, tetapi itu akan memperlambat metode karena overhead memperbaruinya. Secara umum, seperti biasa, Anda perlu mengorbankan sesuatu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, kami memutuskan untuk memulai dengan opsi pertama, sebagai opsi yang lebih sederhana. Pertama, perlu dipahami apakah transaksi lama akan menjadi masalah nyata. Karena transfer data utama dari tabel lama ke yang baru juga terjadi dalam satu transaksi panjang, pertanyaannya telah berubah menjadi "berapa banyak kita akan meningkatkan transaksi ini?" Durasi transaksi pertama tergantung terutama pada ukuran tabel. Durasi yang baru tergantung pada berapa banyak perubahan yang terakumulasi dalam tabel selama transfer data, mis. dari intensitas beban. Run pg_repack terjadi selama beban minimum pada layanan, dan jumlah perubahannya sangat kecil dibandingkan dengan ukuran tabel asli. Kami memutuskan bahwa kami dapat mengabaikan waktu transaksi baru (sebagai perbandingan, ini adalah rata-rata 1 jam dan 2-3 menit).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eksperimennya positif. Berjalan di prod juga. Untuk kejelasan, gambar dengan ukuran salah satu pangkalan setelah dijalankan: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z4/ps/gu/z4psgu_s8jsbhwnxst2pogfcsfa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena solusi ini sangat cocok untuk kami, kami tidak mencoba menerapkan yang kedua, tetapi kami mempertimbangkan untuk mendiskusikannya dengan pengembang ekstensi. Sayangnya, revisi kami saat ini belum siap untuk dipublikasikan, karena kami telah menyelesaikan masalah hanya dengan pembatasan tertunda yang unik, dan untuk tambalan lengkap, perlu untuk membuat dukungan dari jenis lain. Kami berharap dapat melakukan ini di masa depan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin Anda memiliki pertanyaan, mengapa kami terlibat dalam cerita ini dengan penyelesaian pg_repack, dan tidak, misalnya, menggunakan analognya? </font><font style="vertical-align: inherit;">Pada titik tertentu, kami juga memikirkan hal ini, tetapi pengalaman positif menggunakannya sebelumnya, di atas meja tanpa batasan yang tertunda, memotivasi kami untuk mencoba memahami esensi masalah dan memperbaikinya. </font><font style="vertical-align: inherit;">Selain itu, untuk menggunakan solusi lain, itu juga membutuhkan waktu untuk melakukan tes, jadi kami memutuskan bahwa pertama kami akan mencoba untuk memperbaiki masalah di dalamnya, dan jika kami menyadari bahwa kami tidak dapat melakukannya dalam jumlah waktu yang wajar, maka kami akan mulai mempertimbangkan analog.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temuan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang dapat kami rekomendasikan berdasarkan pengalaman kami sendiri:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pantau bloat Anda. </font><font style="vertical-align: inherit;">Berdasarkan data pemantauan, Anda dapat memahami seberapa baik autovacuum dikonfigurasi.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapkan AUTOVACUUM untuk menjaga kembung pada tingkat yang wajar.</font></font></li>
<li>   bloat           â€œ â€,     .  â€“   .</li>
<li>        â€“        ,     .</li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id499434/index.html">Bagaimana menerapkan manajemen pengetahuan: manfaat "kantong", "duri burung beo" dan pemikiran klip</a></li>
<li><a href="../id499436/index.html">Enzim yang dikendalikan dari jarak jauh akan mempercepat pengobatan stroke dan cedera tulang belakang</a></li>
<li><a href="../id499438/index.html">Streaming untuk penguji dan tidak hanya</a></li>
<li><a href="../id499440/index.html">Saat kami menulis autopilot paling keren di dunia untuk lokomotif shunting</a></li>
<li><a href="../id499442/index.html">Membuat Game Balap Pseudo-3D: Menerapkan Bukit dan Menyelesaikan Game</a></li>
<li><a href="../id499446/index.html">Menguji bootloader format STEP untuk VR</a></li>
<li><a href="../id499448/index.html">Menerapkan arsitektur SOLID dan layered di Node.js dengan TypeScript dan InversifyJS</a></li>
<li><a href="../id499450/index.html">Memilih peralatan untuk game Persia menggunakan genetika / evolusi dengan Python</a></li>
<li><a href="../id499452/index.html">Kehidupan sehari-hari seorang dokter spesialis mata di klinik: ketika dokter tidak cukup</a></li>
<li><a href="../id499454/index.html">Video Langsung! Rapat Lokalisasi Badoo 21 April</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>