<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗂️ 🕕 😀 PCI Express in FPGAs der Intel V-Serie: Schnittstellengrundlagen und Hardware-Kernfunktionen 🔒 👨🏿‍🎤 👨🏼‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung
 Die PCI Express- oder PCIe-Schnittstelle, die vielen bekannt ist, stand Entwicklern von FPGA-Systemen bereits zur Verfügung, als sie sich ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PCI Express in FPGAs der Intel V-Serie: Schnittstellengrundlagen und Hardware-Kernfunktionen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496702/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die PCI Express- oder PCIe-Schnittstelle, die vielen bekannt ist, stand Entwicklern von FPGA-Systemen bereits zur Verfügung, als sie sich gerade erst in der digitalen Technologie verbreitete. Zu diesem Zeitpunkt gab es eine Lösung, bei der der Softwarekern mit einem externen Mikrokreislauf auf physikalischer Ebene verbunden war [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]. Dies ermöglichte die Erstellung einer einspurigen PCIe-Leitung mit einer Geschwindigkeit von 2,5 Gigatransaktionen pro Sekunde. Dank der Entwicklung von Technologien wurde die physische Schicht der Schnittstelle auf die PCIe-Hardwareblöcke innerhalb der FPGAs selbst migriert. Die Anzahl der möglichen Kanäle stieg auf 8 und in einer Reihe neuer Mikroschaltungen auf 16. Nach modernen Standards sind die möglichen Datenübertragungsraten gestiegen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gleichzeitig ist es immer noch schwierig, Hilfsmaterialien für die Arbeit mit den Hardwarekernen moderner FPGAs in russischsprachigen Quellen zu finden, da auf der PCIe-Schnittstelle selbst nicht viele Informationen verfügbar sind. Leitfaden zur Hardware PCI Express-Kerne impliziert, dass der Entwickler bereits mit dem Standard vertraut ist und die Grundlagen der Datenübertragung zwischen dem Gerät und einem Personal Computer (PC) versteht. Die Fülle an Informationen im PCIe-Standard selbst versteht jedoch nicht sofort, welche Schritte unternommen werden müssen, um Daten erfolgreich vom Gerät in den PC-Speicher zu übertragen oder umgekehrt. Um ein vollständigeres Bild zu erhalten, muss ein beträchtlicher Teil der Informationen Stück für Stück aus verschiedenen Quellen gesammelt werden. Für Entwickler von Intel FPGA-Systemen ist die Schwierigkeit ebenfallsDie meisten verfügbaren Materialien und Artikel beschreiben die Arbeit mit Xilinx FPGA-Hardwarekernen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel wird der Autor versuchen, darüber zu sprechen, was der FPGA-Systemdesigner wissen muss, um mit der PCI Express-Schnittstelle arbeiten zu können. </font><font style="vertical-align: inherit;">wird die Funktionen der Arbeit mit Hardwarekernen PCI Express FPGAs der V-Serie von Intel in der Avalon-ST-Version berücksichtigen.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCIe-Ebenen und Pakettypen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass PCI Express oft als Bus bezeichnet wird, ist diese Schnittstelle ein Netzwerk von Geräten, die durch Gruppen von seriellen Duplexkanälen verbunden sind. Das PCI Express-Netzwerk selbst besteht aus mehreren Hauptknoten: dem Root (Root), dem Endpunkt (Endpoint) und dem Router (Switch) (Abbildung 1). Um Daten nur zwischen zwei Geräten zu übertragen, müssen ein Root und ein Endpunkt vorhanden sein. Bei modernen PCs befindet sich die Netzwerkwurzel zusammen mit den Kernen des Zentralprozessors auf einem Substrat. Unabhängig davon, wo sich das PCIe-Stammverzeichnis befindet, ist es dem Systemspeicher zugeordnet. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_c/hp/8v/_chp8va2uvyrgrc_pt0irj-wnrk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 1 - PCIe-Netzwerk</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das PCIe-Datenübertragungsprotokoll ist in drei Schichten unterteilt: die Transaktionsschicht, die Datenverbindungsschicht und die physikalische Schicht. </font><font style="vertical-align: inherit;">Schnittstellendaten werden in Form von Paketen übertragen. </font><font style="vertical-align: inherit;">Eine verallgemeinerte Ansicht von Paketen ist in Abbildung 2 dargestellt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pe/eg/sa/peegsa43-ji_l00myvwxe8kt6tg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 2 - Eine verallgemeinerte Ansicht von PCIe-Paketen</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Auf Transaktionsebene besteht jedes Paket (TLP) aus mindestens einem Header. </font><font style="vertical-align: inherit;">Je nach Pakettyp können auf den Header Daten folgen - der nützliche Inhalt des Pakets. </font><font style="vertical-align: inherit;">Eine zusätzliche Prüfsumme kann auch am Ende des Pakets hinzugefügt werden. </font><font style="vertical-align: inherit;">Es gibt die folgenden Haupttypen von Paketen auf Transaktionsebene (Tabelle 1): </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabelle 1 - Arten von Paketen auf Transaktionsebene</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nr. P.</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paketansicht</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Name des Pakettyps gemäß Spezifikation</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherleseanforderung </font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherleseanforderung</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherschreibanforderung</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherschreibanforderung</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leseanforderung für E / A-Speicherplatz</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E / A-Leseanforderung</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schreibanforderung für E / A-Speicherplatz</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E / A-Schreibanforderung</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurationsanforderung lesen</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leseanforderung für die Konfiguration</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurationsanforderung schreiben</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurationsschreibanforderung</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leseantwort</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertigstellung</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Botschaft</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Botschaft</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der Verbindungsschicht werden jedem Paket auf Transaktionsebene eine Paketsequenznummer und eine Verbindungsprüfsumme hinzugefügt. </font><font style="vertical-align: inherit;">Die Datenverbindungsschicht bildet auch ihre eigenen Pakettypen (DLLP), einschließlich (Tabelle 2): </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabelle 2 - Datenverbindungspakettypen</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nr. P.</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paketansicht</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Name des Pakettyps gemäß Spezifikation</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paketbestätigung auf Transaktionsebene</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLP Ack</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ablehnung von Paketen auf Transaktionsebene</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLP Nack</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Energieverwaltung</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Energieverwaltung</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenflusskontrolle</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ablaufsteuerung</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich ergänzt die physikalische Schicht die Pakete mit Symbolen für den Anfang und das Ende der Pakete, die aus dem IEEE 802.3-Standard entlehnt sind. </font><font style="vertical-align: inherit;">Für Pakete auf Transaktionsebene werden die Symbole K27.7 bzw. K29.7 verwendet; </font><font style="vertical-align: inherit;">für Datenverbindungspakete die Symbole K28.2 und K29.7. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Arbeit mit FPGA-Hardwarekernen muss der Entwickler nur Pakete auf Transaktionsebene erstellen. </font><font style="vertical-align: inherit;">Kanal- und physikalische Schichtpakete werden durch Kernelblöcke gebildet.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paketrouting auf Transaktionsebene</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Insgesamt können verschiedene Arten von Paketen auf drei Arten vom Absender zum Empfänger gelangen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weiterleitung an die Adresse; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ID-Routing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> indirektes Routing.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Beziehung zwischen der Routing-Methode und dem Typ des Pakets auf Transaktionsebene ist in Tabelle 3 dargestellt. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabelle 3 - Entsprechung der Routing-Methode und des Pakettyps</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">№p</font></font></th>
<th> </th>
<th> </th>
</tr>
<tr>
<td>1</td>
<td>  </td>
<td>       . <br>
    I/O     I/O<br>
</td>
</tr>
<tr>
<td>2</td>
<td>  </td>
<td>     . <br>
    ID.<br>
  <br>
</td>
</tr>
<tr>
<td>3</td>
<td> </td>
<td>    ID</td>
</tr>
</tbody></table></div><br>
<h2>   .        </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder Endpunkt verfügt über einen eigenen Konfigurationsbereich, in dem sich verschiedene Befehls- und Statusregister befinden. Darunter befinden sich das Basisadressregister oder die BAR. Bei der Initialisierung der Endpunkte durchsucht das BIOS oder Betriebssystem die BAR der Endpunkte, um festzustellen, wie viel Speicher und Speicherplatz für jeden Endpunkt erforderlich ist. Dann wird in jede aktive BAR die Startadresse des zugewiesenen Teils des Systemspeichers geschrieben. Infolgedessen erhält der Endpunkt eine Adresse, an die entsprechende Anforderungen gesendet werden können. Normalerweise wird am Endpunkt eine Registerkarte gebildet, die an die zugewiesenen Speicherbereiche gebunden ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Außerdem erhält jeder Endpunkt bzw. das darin enthaltene logische Gerät seine eindeutige Kennung, die aus drei Teilen besteht: Busnummer, Gerätenummer, Nummer des logischen Geräts (Funktion).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise verfügt das System über genügend Informationen, um mit dem Endpunkt zu kommunizieren. Das Übertragen von Daten mithilfe von Abfragen in der BAR weist jedoch eine schlechte Leistung auf. Erstens ist für eine 32 Bit breite BAR die verwendbare Anforderungslänge auf ein Doppelwort (DWORD) begrenzt; für eine 64-Bit-Leiste zwei Doppelwörter. Zweitens erfolgt jede Anforderung unter Beteiligung des Zentralprozessors. Um die Belastung des Zentralprozessors zu verringern und die Größe jedes Pakets zu erhöhen, muss der Endpunkt Daten unabhängig voneinander in den oder aus dem Systemspeicher verschieben. Dazu muss der Endpunkt wissen, an welchen Systemspeicheradressen er Daten schreiben oder lesen kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Anbetracht des Obigen kann das allgemeine Datenübertragungsschema zwischen dem Endpunkt und dem Systemspeicher wie folgt dargestellt werden:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Endpunkttreiber weist Puffer im Systemspeicher zum Schreiben von Daten zu. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Treiber bildet im Systemspeicher eine Reihe von Adressen und Puffergrößen - Pufferdeskriptoren zum Schreiben von Daten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Endpunkttreiber schreibt die Adresse des Satzes von Deskriptoren in die Geräteregister, die den BAR-Bereichen zugeordnet sind.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Endpunkttreiber programmiert Datenübertragungssteuerregister, die BAR-Bereichen zugeordnet sind; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Endpunkt sendet eine Anforderung zum Lesen des Systemspeichers, um einen Satz von Deskriptoren zum Schreiben in den Systemspeicher zu erhalten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Endpunkt sendet Schreibanforderungen an den Systemspeicher und füllt die Speicherpuffer.</font></font></li>
<li>      /   ,    ,        ,  ;</li>
<li>                   PCIe. </li>
</ol><br>
<h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Phase, in der der Treiber die Endpunktregister konfiguriert, erhält der Endpunkt abhängig von der Art des der BAR zugeordneten Adressraums eine Schreibanforderung in den Speicher (Abbildung 3) oder eine Schreibanforderung in den E / A-Bereich. Wenn der Treiber während der Registerkonfiguration ein Register liest, empfängt der Endpunkt auch die entsprechenden Leseanforderungen (Abbildung 4). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/w0/_e/5o/w0_e5oqkd6yfw7uyv9vewkmokw4.png" alt="Bild"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 3 - Beispiel einer Anforderung zum Schreiben in den Speicher 1 DW lang </font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/ca/by/yk/cabyyk_ju4inqbsdevo3b-z3pma.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 4 - Beispiel einer Anforderung zum Lesen aus dem Speicher 1 DW lang</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Gegensatz zu Schreib- oder Leseanforderungen weisen E / A-Anforderungen eine Reihe von Einschränkungen auf. Erstens erfordern sowohl Schreib- als auch Leseanforderungen eine Antwort des Empfängers. Dies führt dazu, dass die Datenübertragungsrate unter Verwendung von Anforderungen an den E / A-Raum viel niedriger wird, als es die theoretische PCIe-Bandbreite zulässt. Zweitens ist die Adresse von E / A-Speicherplatzanforderungen auf 32 Bit begrenzt, wodurch kein Zugriff auf Fragmente des Systemspeichers über 4 GB hinaus möglich ist. Drittens dürfen E / A-Speicherplatzanforderungen ein Doppelwort nicht überschreiten und nicht mehrere virtuelle Kanäle für den Transport verwenden. Aus diesen Gründen werden Anfragen zum Schreiben und Lesen in den E / A-Bereich nicht weiter berücksichtigt. Dennoch,Der Inhalt der Header für den Schreib- / Lesespeicher und den E / A-Raum unterscheidet sich nur in einer Reihe von Feldern. Daher gelten die in den 3, 4 gezeigten Paketstrukturen auch für Anforderungen im E / A-Raum.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein Endpunkt oder ein PCIe-Stamm eine Anforderung zum Lesen des Speichers oder des E / A-Speicherplatzes empfängt, muss das Gerät eine Antwort senden. Wenn der Absender der Anfrage innerhalb einer bestimmten Zeit keine Antwort erhält, führt dies zu einem Fehler beim Warten auf eine Antwort. Wenn das Gerät aus irgendeinem Grund die angeforderten Daten nicht senden kann, muss es eine Fehlerantwort generieren. Mögliche Gründe können sein: Der Empfänger unterstützt diese Anforderung nicht (nicht unterstützte Anforderung); Der Empfänger ist nicht bereit, die Konfigurationsanforderung anzunehmen, und fordert sie auf, sie später zu wiederholen (Wiederholungsstatus der Konfigurationsanforderung). Es ist ein interner Fehler aufgetreten, aufgrund dessen der Empfänger nicht antworten und die Anforderung ablehnen kann (Abbruch des Abschlusses). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Formate für eine erfolgreiche Antwort auf eine Leseanforderung und eine Fehlerantwort für eine nicht unterstützte Anforderung sind in den 5, 6 gezeigt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gp/pl/y4/gpply4dawc8olvy6iyeipyeraos.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 5 - Beispiel für eine erfolgreiche Antwort auf das Lesen </font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/3s/uw/bv/3suwbvjqkiqpoaogl9ewbnbixjq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 6 - Beispiel für eine Antwort auf eine nicht unterstützte Anforderung</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Während der Endpunkt auf einen Speicherbereich innerhalb von 4 GB zugreift, unterscheidet sich das Format der Paket-Header nicht von den in den Abbildungen 3, 4 gezeigten Headern. Für Schreibanforderungen Wenn Sie einen Speicher von mehr als 4 GB lesen, wird im Header ein zusätzliches Doppelwort mit höherwertigen Bits der Zieladresse verwendet (Abbildung 7). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rr/1o/w6/rr1ow6yxljdhqffy9gguw6v-3os.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 7 - Ein Beispiel für einen 128-Byte-Schreibanforderungsheader.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Erläuterungen zu abgekürzten Namen von Paketheaderfeldern sind in Tabelle 4 aufgeführt. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabelle 4 - Liste der Abkürzungen für Headerfelder</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nr. P.</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feldbezeichnung</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feldname</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geplanter Termin</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verkehrskategorie - Verkehrsklasse</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definiert die Mitgliedschaft im virtuellen Kanal</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atr</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attribute</font></font></td>
<td>   : , ,    ID,       ID.</td>
</tr>
<tr>
<td>3</td>
<td>TH</td>
<td>    ‒ TLP Processing Hint</td>
<td>,         [1..0]      .</td>
</tr>
<tr>
<td>4</td>
<td>TD</td>
<td>       ‒ TLP Digest</td>
<td>,          .</td>
</tr>
<tr>
<td>5</td>
<td>EP</td>
<td>    </td>
<td>,      .</td>
</tr>
<tr>
<td>6</td>
<td>AT</td>
<td>  ‒ Address Translation</td>
<td>,     :   ,  ,  </td>
</tr>
<tr>
<td>7</td>
<td>BE</td>
<td>        ‒ Byte Enable</td>
<td>         </td>
</tr>
<tr>
<td>8</td>
<td>PH</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paketverarbeitungshinweis - Verarbeitungshinweis</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt dem Paketempfänger Tipps zur Verwendung des Pakets sowie zur Datenstruktur</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BCM</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Vorhandensein einer Änderung in der Anzahl der Bytes</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt an, ob sich die Anzahl der Bytes im Paket geändert hat. </font><font style="vertical-align: inherit;">Nur ein Absender angesichts eines PCI-X-Geräts kann ein Flag setzen</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein Endpunkt Interrupts verwendet, um ein Ereignis zu melden, muss er auch ein geeignetes Paket bilden. </font><font style="vertical-align: inherit;">Insgesamt kann PCIe drei Arten von Interrupts verwenden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legacy-Interrupts (Legacy-Interrupts oder INT);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterbrechungen in Form von Nachrichten (Message Signaled Interrupts oder MSI);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erweiterte Nachrichteninterrupts (Message Signaled Interrupts Extended oder MSI-X).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Geerbte INT-Interrupts werden aus Gründen der Kompatibilität mit Systemen verwendet, die keine Nachrichteninterrupts unterstützen. Tatsächlich ist diese Art von Interrupt eine Nachricht (ein Paket vom Typ Nachricht), die den Betrieb einer physischen Interruptleitung simuliert. Bei einem bestimmten Ereignis sendet der Endpunkt eine Nachricht an das PCIe-Stammverzeichnis, dass der INT-Interrupt aktiviert wurde, und wartet dann auf die Aktion des Interrupt-Handlers. Bis der Interrupt-Handler die angegebene Aktion ausführt, befindet sich der INT-Interrupt im aktivierten Zustand. Bei geerbten Interrupts können Sie die Quelle des Ereignisses nicht bestimmen, wodurch der Interrupt-Handler gezwungen wird, alle Endpunkte im PCIe-Baum nacheinander zu scannen, um diesen Interrupt zu bedienen. Wenn der Interrupt bedient wird, sendet der Endpunkt eine Nachricht, die dies besagtdass der INT-Interrupt inaktiver ist. Die FPGA-Hardwarekerne erzeugen auf ein Signal von der Benutzerlogik unabhängig die erforderlichen Nachrichten für INT-Interrupts, sodass die Paketstruktur nicht berücksichtigt wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachrichteninterrupts sind zusammen mit ihrer erweiterten Version die Haupt- und obligatorische Art von Interrupt in PCIe. Beide Arten von Interrupts sind in der Tat eine Anforderung, mit einer Länge von einem Doppelwort in den Systemspeicher zu schreiben. Der Unterschied zu einer regulären Anforderung besteht darin, dass die Aufzeichnungsadresse und der Paketinhalt in der Phase der Systemkonfiguration jedem Gerät zugewiesen werden. In diesem Fall wird der lokale Advanced Programmable Interrupt Controller (LAPIC) im Zentralprozessor zum Ziel. Bei Verwendung dieser Art von Interrupt müssen nicht alle Geräte im PCIe-Baum nacheinander abgefragt werden. Wenn das System dem Gerät erlaubt, mehrere Interruptvektoren zu verwenden, kann darüber hinaus jedem Vektor ein eigenes Ereignis zugeordnet werden.Zusammen reduziert dies die Prozessorzeit für die Verarbeitung von Interrupts und erhöht die Gesamtsystemleistung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSI-Interrupts ermöglichen die Bildung von bis zu 32 separaten Vektoren. Die genaue Anzahl hängt von den Funktionen des Endpunkts ab. In diesem Fall kann das System die Verwendung nur eines Teils der Vektoren erlauben. In der Konfigurationsphase schreibt das System die Interruptadresse und die Anfangsdaten zum Schreiben in die speziellen Register des Konfigurationsraums des Endpunkts. Alle aktiven Interrupts verwenden dieselbe Adresse. Für jeden Vektor ändert der Endpunkt jedoch die Bits der Anfangsdaten. Lassen Sie beispielsweise einen Endpunkt maximal 4 Interruptvektoren unterstützen, alle 4 Vektoren sind im System zulässig und die Anfangsdaten zum Schreiben sind 0x4970. Um den ersten Vektor zu bilden, übergibt der Endpunkt die Anfangsdaten unverändert. Für den zweiten Vektor ändert das Gerät das erste Bit und sendet die Nummer 0x4971.Für den dritten und vierten Vektor sendet das Gerät die Nummern 0x4972 bzw. 0x4973.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die FPGA-Hardwarekerne bilden unabhängig voneinander ein Paket mit einem MSI-Interrupt durch ein Signal von der Benutzerlogik. Bevor der Kernel jedoch angewiesen wird, einen Interrupt zu senden, muss die Benutzerlogik auch den Inhalt des Pakets für den erforderlichen Vektor an eine spezielle Kernelschnittstelle senden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSI-X-Interrupts ermöglichen die Bildung von bis zu 2048 einzelnen Vektoren. In den entsprechenden Registern des Konfigurationsraums gibt der Endpunkt an, in welchem ​​der BAR-Adressräume und mit welchem ​​Versatz von der Basisadresse sich die Interrupt-Tabelle (Abbildung 8) und die Tabelle der anstehenden Interrupt-Flags (Pending Bit Array - PBA, Abbildung 9) sowie die Größen beider befinden Tabellen. Das System schreibt eine separate Adresse und Daten zum Schreiben in jede Zeile der Interrupt-Tabelle und erlaubt oder verbietet auch die Verwendung eines bestimmten Vektors durch das erste Bit des Vektorsteuerungsfeldes. Für ein bestimmtes Ereignis setzt der Endpunkt ein Flag in der Flag-Tabelle der ausstehenden Interrupts. Wenn für diesen Interrupt im Feld Vector Control keine Maske festgelegt ist, sendet der Endpunkt einen Interrupt an die Adresse aus der Interrupt-Tabelle mit dem angegebenen Inhalt des Pakets.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zl/6q/el/zl6qelezf6aixg5qjw-rbeotwkc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 8 - Tabelle der MSI-X-Interrupt-Vektoren </font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/q8/ms/as/q8msasscf-ytecdpefn-ohdjc1q.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 9 - Tabelle der Flags für ausstehende Interrupts</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
FPGA-Hardwarekerne verfügen nicht über eine spezielle Schnittstelle für MSI-X-Interrupts. </font><font style="vertical-align: inherit;">Der Entwickler selbst muss eine Interrupt-Tabelle in der Benutzerlogik und eine Tabelle mit Flags ausstehender Interrupts erstellen. </font><font style="vertical-align: inherit;">Ein Interrupt-Paket wird auch vollständig vom Benutzer generiert und zusammen mit anderen Pakettypen über die allgemeine Kernel-Schnittstelle übertragen. </font><font style="vertical-align: inherit;">Das Paketformat entspricht in diesem Fall, wie oben bereits erwähnt, einer Anforderung zum Schreiben in den Systemspeicher mit einer Länge von einem Doppelwort.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merkmale der Hardwarekerne PCI Express FPGA V-Serie von Intel in der Version Avalon-ST</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass die Hardwarekerne von PCI Express-FPGAs verschiedener Hersteller ähnliche Funktionen implementieren, können sich die einzelnen Kernschnittstellen oder die Reihenfolge ihres Betriebs unterscheiden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PCI Express FPGA-Hardwarekerne der Intel V-Serie sind in zwei Versionen erhältlich: mit Avalon-MM und Avalon-ST. Letzteres ermöglicht es Ihnen, die meiste Bandbreite zu erhalten, obwohl dies vom Entwickler mehr Aufwand erfordert. Aus diesem Grund wird ein Kernel mit einer Avalon-MM-Schnittstelle nicht berücksichtigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der PCI Express-Kerndokumentation mit der Avalon-ST-Schnittstelle werden die Kernelparameter, Eingangs- und Ausgangssignale ausreichend detailliert beschrieben. Der Kernel verfügt jedoch über eine Reihe von Funktionen, auf die ein Entwickler achten sollte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste Gruppe von Funktionen bezieht sich auf Methoden, mit denen Sie FPGAs innerhalb von 100 ms gemäß den PCIe-Anforderungen konfigurieren können. Zusätzlich zum parallelen Laden des FPP-Typs werden dem Entwickler Methoden wie die Konfiguration über Protokoll (CvP) und den autonomen Modus des Kernels (autonomer Modus) angeboten. Der Entwickler muss sicherstellen, dass die Konfiguration über das Protokoll oder den Standalone-Kernel-Modus für die ausgewählte PCIe-Geschwindigkeit unterstützt wird (Parameter „Lane Rate“). Für die Konfiguration über das Protokoll finden Sie relevante Informationen in der Kerneldokumentation. Im Offline-Modus gibt es keine solchen Informationen, daher müssen Sie das Projekt kompilieren. Wenn der eigenständige Kernelmodus für die aktuelle Kernelgeschwindigkeit nicht unterstützt wird, generiert Quartus einen entsprechenden Fehler (Abbildung 10).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xj/hy/ok/xjhyokbx1mvolf2dweiawoytyzk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 10 - Fehler beim Kompilieren eines PCIe-Kernels für den Offline-Modus</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn ein Entwickler die Konfiguration über ein Protokoll verwenden möchte, sollte er auch darauf achten, mit welchem ​​FPGA-Kern der PCIe-Anschluss verbunden ist. Dies gilt insbesondere dann, wenn der Entwickler kein fertiges Board, sondern sein eigenes Gerät verwendet. In FPGAs mit mehreren PCIe-Hardwarekernen kann CvP nur mit einem Kern aktiviert werden. Die Position des Kerns mit CvP-Unterstützung ist in der FPGA-Dokumentation angegeben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite Gruppe von Merkmalen betrifft die Avalon-ST-Datenübertragungsschnittstelle selbst. Über diese Schnittstelle werden Pakete auf Transaktionsebene zwischen der Benutzerlogik und dem Kernel übertragen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der Empfangsseite verfügt der Kernel über zwei Signale, mit denen der Benutzer den Empfang empfangener Pakete unterbrechen kann: das Signal rx_st_mask und das Signal rx_st_ready. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dem Signal rx_st_ready kann der Entwickler die Ausgabe aller Pakettypen anhalten. Wenn Sie dieses Signal jedoch aktivieren, stoppt der Kernel die Ausgabe von Paketen nach nur zwei Taktzyklen der Betriebsfrequenz. Daher muss die Benutzerlogik während der Signalaktivierung bereit sein, eine zusätzliche Datenmenge zu empfangen. Wenn ein Entwickler beispielsweise einen Puffer in Form eines FIFO verwendet, sollte er Pufferüberläufe vermeiden. Andernfalls geht ein Teil des Paketinhalts verloren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dem Signal "rx_st_mask" setzt der Entwickler die Ausgabe von Anfragen aus, für die Antworten gesendet werden müssen. Dieses Signal stoppt auch nicht sofort die Ausgabe von Paketen. Gemäß der Dokumentation kann der Kernel nach Aktivierung des Signals bis zu 10 Anforderungen ausgeben. Wenn die Benutzerlogik "rx_st_mask" aktiviert und nicht genügend Speicherplatz im Puffer vorhanden ist, um empfangene Pakete zu verarbeiten, kann dies auch das Signal "rx_st_ready" aktivieren. In dieser Situation hört die Benutzerlogik auf, Pakete aus dem internen Hardware-Kernel-Puffer zu lesen. Dies überschreitet nicht nur die Hardware-Kernel-Puffer, sondern verstößt auch gegen die Anforderungen an die Paketreihenfolge. Das Gerät muss Anforderungen, für die keine Antwort erforderlich ist, überspringen und Antworten lesen. Andernfalls wird der Datenkanal dicht blockiert.Aus diesem Grund sollte der Entwickler einen zusätzlichen Puffer verwenden, um Anforderungen mit Antworten zu verarbeiten, und der Logik nicht erlauben, Pakete mit höherer Priorität zu blockieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der Sendeseite können die Signale tx_st_valid und tx_st_ready Probleme verursachen. Wenn das Signal tx_st_ready aktiv ist, darf die Benutzerlogik das tx_st_valid in der Mitte des ausgehenden Pakets nicht zurücksetzen. Dies bedeutet, dass der Entwickler während der Übertragung den gesamten Inhalt des Pakets bereitstellen muss. Wenn die Datenquelle langsamer als die Kernelschnittstelle ist, muss die Benutzerlogik vor dem Start des Pakets die erforderliche Datenmenge akkumulieren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sowohl auf der Empfangsseite als auch auf der Sendeseite sollte der Entwickler auf die Bytereihenfolge im Header und den Inhalt des Pakets sowie auf die Datenausrichtung achten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Avalon-ST-Paket des Hardwarekerns folgen die Bytes innerhalb jedes Doppelworts im Header des PCIe-Pakets von niedrig nach hoch; im Verpackungsinhalt - vom ältesten zum jüngsten. Der Entwickler muss in ausgehenden Paketen eine ähnliche Reihenfolge verwenden, um Daten erfolgreich vom Endpunkt zum Stamm zu übertragen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Avalon-ST-Schnittstelle des Hardwarekerns richtet die Daten in Vielfachen von 64 Bit aus. Abhängig von der Breite der Avalon-ST-Schnittstelle, der Länge des Paket-Headers auf Transaktionsebene und der Paketadresse kann der Kernel ein leeres Doppelwort zwischen dem Paket-Header und seinem Inhalt hinzufügen. Bei der Datenübertragung muss die Benutzerlogik wiederum analog zum Kernel im Voraus ein leeres Doppelwort hinzufügen. Dieses leere Doppelwort wird in der Paketlänge nicht berücksichtigt und ist nur für den korrekten Betrieb des Hardware-Kernels erforderlich.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die nächste Funktion bezieht sich auf eingehende Leseantworten. Die Kernelbeschreibung besagt, dass eingehende Antworten, deren Kennung nicht mit der ausgehenden Anforderung übereinstimmt, nicht übersehen werden. Gleichzeitig sollte die Benutzerlogik der Wartezeit für Antworten folgen. Wenn die Wartezeit überschritten wird, muss die Benutzerlogik das Flag "cpl_err [0]" oder "cpl_err [1]" setzen. Aus der Dokumentation geht nicht hervor, wie die Filterung funktioniert, wenn der Endpunkt mehrere Leseanforderungen sendet. Die Benutzerlogik teilt dem Kernel nur mit, dass das Zeitlimit für eine der Anforderungen abgelaufen ist, kann jedoch die Kennung dieser Anforderung nicht an den Kernel übergeben. Es besteht die Möglichkeit, dass der Kernel Antworten für eine Anforderung mit einem abgelaufenen Zeitlimit an die Benutzerseite sendet. Daher muss der Entwickler einen eigenen Filter für eingehende Antworten erstellen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich wird Entwicklern dringend empfohlen, die Informationen zu verfügbaren Darlehen für ausgehende Pakete zu verwenden. </font><font style="vertical-align: inherit;">Die Kerndokumentation besagt, dass dies nicht erforderlich ist, da der Kernel Kredite prüft und Pakete blockiert, wenn nicht genügend Kredite vorhanden sind. </font><font style="vertical-align: inherit;">Alle Arten von Paketen gelangen jedoch über eine einzige Schnittstelle zum Kernel. </font><font style="vertical-align: inherit;">Wenn der Kernel-Paketpuffer überläuft, senkt der Kernel das Signal tx_st_ready auf Null. </font><font style="vertical-align: inherit;">Bis das Signal tx_st_ready auf eins gesetzt ist, kann die Benutzerlogik im Prinzip keine Pakete senden. </font><font style="vertical-align: inherit;">Die Anzahl der verfügbaren Kredite wird durch Pakete von einem Partnergerät aktualisiert. </font><font style="vertical-align: inherit;">Wenn die Logik des Benutzers nicht nur häufig schreibt, sondern auch liest, sinkt die Geschwindigkeit, mit der der Kernel die Grenzwertzähler aktualisiert. </font><font style="vertical-align: inherit;">Am Ende leidet die Gesamtsystemleistung.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel beschreibt die allgemeinen Prinzipien der Datenübertragung über PCI Express, die Formate der Hauptdatenpakete. </font><font style="vertical-align: inherit;">Trotzdem hat der Autor Schnittstellenkomponenten wie virtuelle Kanäle weggelassen, die Kontrolle des Volumens der eingehenden Antworten zum Lesen und die Reihenfolge der Pakete ist nicht streng. </font><font style="vertical-align: inherit;">Diese Themen werden in einer Reihe ausländischer Quellen ausführlich diskutiert [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel enthält auch die Funktionen der FPGA-FPGA-Hardwarekerne der Intel Express V-Serie, auf die der Autor bei der Arbeit am Schnittstellencontroller gestoßen ist. </font><font style="vertical-align: inherit;">Diese Erfahrung kann für andere Entwickler nützlich sein.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste der verwendeten Quellen</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine PCIe-DMA-Architektur für die Datenübertragung mit mehreren Gigabyte pro Sekunde / L. Rota, M. Caselle, et. </font><font style="vertical-align: inherit;">al. </font><font style="vertical-align: inherit;">// IEEE TRANSACTIONS ON NUCLEAR SCIENCE, VOL. </font><font style="vertical-align: inherit;">62, NO. </font><font style="vertical-align: inherit;">3. Juni 2015.</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">An Efficient and Flexible Host-FPGA PCIe Communication Library / Jian Gong, Tao Wang, Jiahua Chen et. al. // 2014 24th International Conference on Field Programmable Logic and Applications.</a></li>
<li>Design and Implementation of a High-Speed Data Acquisition Card Based on PCIe Bus / Li Mu-guo, Huang Ying, Liu Yu-zhi // 《测控技术》2013年第32卷第7期。</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Down to the TLP: How PCI express devices talk (Part I) / Eli Billauer</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Low-Cost FPGA Solution for PCI Express Implementation / Intel Corporation.</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Managing Receive-Buffer Space for Inbound Completions / Xilinx // Virtex-7 FPGA Gen3 Integrated Block for PCI Express v4.3, Appendix B</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">PCIe Completion Timeout / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">PCIe packet in cyclone VI GX / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">PCIe simple transaction / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">PCIe w/ Avalon ST: Equivalent of ko_cpl_spc_vc0? / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Point me in the right Direction – PCIe / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitüberschreitungen im PCIE / Altera Forum anfordern</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hochgeschwindigkeits-Schnittstellendesign basierend auf PCIe der nicht kooperativen Empfängerverifizierungsplattform / Li Xiao-ning, Yao Yuan-cheng und Qin Ming-wei // 2016 Internationale Konferenz für Mechanik, Steuerung, Elektrik, Mechatronik, Information und Computer</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCI Express-Basisspezifikation Revision 3.0 / PCI-SIG</font></font></a> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stratix V Avalon-ST-Schnittstelle für PCIe Solutions / Intel Corporation </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cyclone V Avalon-ST-Schnittstelle für PCIe Solutions / Intel Corporation</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de496680/index.html">Industrie 4.1: Roboterbesitz, neuronale Netze und Open Source-Monetarisierung</a></li>
<li><a href="../de496682/index.html">So bleiben Sie professionell gefragt</a></li>
<li><a href="../de496686/index.html">Wie Verkehrsanalysesysteme Hacker-Taktiken erkennen von MITRE ATT & CK, Teil 4</a></li>
<li><a href="../de496690/index.html">Coronavirus-Steuerungstechnologien</a></li>
<li><a href="../de496692/index.html"># 06 - Und ein ganzes Byte reicht nicht ... | Flaches Wetter</a></li>
<li><a href="../de496704/index.html">Leiterplatte der Saturn-5-Rakete - Reverse Engineering mit Erläuterungen</a></li>
<li><a href="../de496706/index.html">Wochenendlesung: Eine Geschichte der Audioformate - Das Zeitalter der Kassetten und die Entwicklung von Sprachsynthesetechnologien</a></li>
<li><a href="../de496708/index.html">Raumkanone, Dampfrakete und Orbitalspiegel</a></li>
<li><a href="../de496710/index.html">Computerinformationen: Einfach und schnell</a></li>
<li><a href="../de496712/index.html">Einmal bei einem Pentest oder wie man mit Hilfe eines Urologen und Roskomnadzors alles kaputt macht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>