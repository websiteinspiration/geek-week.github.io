<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóÇÔ∏è üïï üòÄ PCI Express in FPGAs der Intel V-Serie: Schnittstellengrundlagen und Hardware-Kernfunktionen üîí üë®üèø‚Äçüé§ üë®üèº‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung
 Die PCI Express- oder PCIe-Schnittstelle, die vielen bekannt ist, stand Entwicklern von FPGA-Systemen bereits zur Verf√ºgung, als sie sich ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PCI Express in FPGAs der Intel V-Serie: Schnittstellengrundlagen und Hardware-Kernfunktionen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496702/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einf√ºhrung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die PCI Express- oder PCIe-Schnittstelle, die vielen bekannt ist, stand Entwicklern von FPGA-Systemen bereits zur Verf√ºgung, als sie sich gerade erst in der digitalen Technologie verbreitete. Zu diesem Zeitpunkt gab es eine L√∂sung, bei der der Softwarekern mit einem externen Mikrokreislauf auf physikalischer Ebene verbunden war [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]. Dies erm√∂glichte die Erstellung einer einspurigen PCIe-Leitung mit einer Geschwindigkeit von 2,5 Gigatransaktionen pro Sekunde. Dank der Entwicklung von Technologien wurde die physische Schicht der Schnittstelle auf die PCIe-Hardwarebl√∂cke innerhalb der FPGAs selbst migriert. Die Anzahl der m√∂glichen Kan√§le stieg auf 8 und in einer Reihe neuer Mikroschaltungen auf 16. Nach modernen Standards sind die m√∂glichen Daten√ºbertragungsraten gestiegen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gleichzeitig ist es immer noch schwierig, Hilfsmaterialien f√ºr die Arbeit mit den Hardwarekernen moderner FPGAs in russischsprachigen Quellen zu finden, da auf der PCIe-Schnittstelle selbst nicht viele Informationen verf√ºgbar sind. Leitfaden zur Hardware PCI Express-Kerne impliziert, dass der Entwickler bereits mit dem Standard vertraut ist und die Grundlagen der Daten√ºbertragung zwischen dem Ger√§t und einem Personal Computer (PC) versteht. Die F√ºlle an Informationen im PCIe-Standard selbst versteht jedoch nicht sofort, welche Schritte unternommen werden m√ºssen, um Daten erfolgreich vom Ger√§t in den PC-Speicher zu √ºbertragen oder umgekehrt. Um ein vollst√§ndigeres Bild zu erhalten, muss ein betr√§chtlicher Teil der Informationen St√ºck f√ºr St√ºck aus verschiedenen Quellen gesammelt werden. F√ºr Entwickler von Intel FPGA-Systemen ist die Schwierigkeit ebenfallsDie meisten verf√ºgbaren Materialien und Artikel beschreiben die Arbeit mit Xilinx FPGA-Hardwarekernen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel wird der Autor versuchen, dar√ºber zu sprechen, was der FPGA-Systemdesigner wissen muss, um mit der PCI Express-Schnittstelle arbeiten zu k√∂nnen. </font><font style="vertical-align: inherit;">wird die Funktionen der Arbeit mit Hardwarekernen PCI Express FPGAs der V-Serie von Intel in der Avalon-ST-Version ber√ºcksichtigen.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCIe-Ebenen und Pakettypen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass PCI Express oft als Bus bezeichnet wird, ist diese Schnittstelle ein Netzwerk von Ger√§ten, die durch Gruppen von seriellen Duplexkan√§len verbunden sind. Das PCI Express-Netzwerk selbst besteht aus mehreren Hauptknoten: dem Root (Root), dem Endpunkt (Endpoint) und dem Router (Switch) (Abbildung 1). Um Daten nur zwischen zwei Ger√§ten zu √ºbertragen, m√ºssen ein Root und ein Endpunkt vorhanden sein. Bei modernen PCs befindet sich die Netzwerkwurzel zusammen mit den Kernen des Zentralprozessors auf einem Substrat. Unabh√§ngig davon, wo sich das PCIe-Stammverzeichnis befindet, ist es dem Systemspeicher zugeordnet. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_c/hp/8v/_chp8va2uvyrgrc_pt0irj-wnrk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 1 - PCIe-Netzwerk</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das PCIe-Daten√ºbertragungsprotokoll ist in drei Schichten unterteilt: die Transaktionsschicht, die Datenverbindungsschicht und die physikalische Schicht. </font><font style="vertical-align: inherit;">Schnittstellendaten werden in Form von Paketen √ºbertragen. </font><font style="vertical-align: inherit;">Eine verallgemeinerte Ansicht von Paketen ist in Abbildung 2 dargestellt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pe/eg/sa/peegsa43-ji_l00myvwxe8kt6tg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 2 - Eine verallgemeinerte Ansicht von PCIe-Paketen</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Auf Transaktionsebene besteht jedes Paket (TLP) aus mindestens einem Header. </font><font style="vertical-align: inherit;">Je nach Pakettyp k√∂nnen auf den Header Daten folgen - der n√ºtzliche Inhalt des Pakets. </font><font style="vertical-align: inherit;">Eine zus√§tzliche Pr√ºfsumme kann auch am Ende des Pakets hinzugef√ºgt werden. </font><font style="vertical-align: inherit;">Es gibt die folgenden Haupttypen von Paketen auf Transaktionsebene (Tabelle 1): </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabelle 1 - Arten von Paketen auf Transaktionsebene</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nr. P.</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paketansicht</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Name des Pakettyps gem√§√ü Spezifikation</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherleseanforderung </font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherleseanforderung</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherschreibanforderung</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherschreibanforderung</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leseanforderung f√ºr E / A-Speicherplatz</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E / A-Leseanforderung</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schreibanforderung f√ºr E / A-Speicherplatz</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E / A-Schreibanforderung</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurationsanforderung lesen</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leseanforderung f√ºr die Konfiguration</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurationsanforderung schreiben</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurationsschreibanforderung</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leseantwort</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertigstellung</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Botschaft</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Botschaft</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der Verbindungsschicht werden jedem Paket auf Transaktionsebene eine Paketsequenznummer und eine Verbindungspr√ºfsumme hinzugef√ºgt. </font><font style="vertical-align: inherit;">Die Datenverbindungsschicht bildet auch ihre eigenen Pakettypen (DLLP), einschlie√ülich (Tabelle 2): </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabelle 2 - Datenverbindungspakettypen</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nr. P.</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paketansicht</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Name des Pakettyps gem√§√ü Spezifikation</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paketbest√§tigung auf Transaktionsebene</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLP Ack</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ablehnung von Paketen auf Transaktionsebene</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLP Nack</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Energieverwaltung</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Energieverwaltung</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenflusskontrolle</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ablaufsteuerung</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schlie√ülich erg√§nzt die physikalische Schicht die Pakete mit Symbolen f√ºr den Anfang und das Ende der Pakete, die aus dem IEEE 802.3-Standard entlehnt sind. </font><font style="vertical-align: inherit;">F√ºr Pakete auf Transaktionsebene werden die Symbole K27.7 bzw. K29.7 verwendet; </font><font style="vertical-align: inherit;">f√ºr Datenverbindungspakete die Symbole K28.2 und K29.7. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Arbeit mit FPGA-Hardwarekernen muss der Entwickler nur Pakete auf Transaktionsebene erstellen. </font><font style="vertical-align: inherit;">Kanal- und physikalische Schichtpakete werden durch Kernelbl√∂cke gebildet.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paketrouting auf Transaktionsebene</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Insgesamt k√∂nnen verschiedene Arten von Paketen auf drei Arten vom Absender zum Empf√§nger gelangen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weiterleitung an die Adresse; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ID-Routing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> indirektes Routing.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Beziehung zwischen der Routing-Methode und dem Typ des Pakets auf Transaktionsebene ist in Tabelle 3 dargestellt. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabelle 3 - Entsprechung der Routing-Methode und des Pakettyps</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ññp</font></font></th>
<th> </th>
<th> </th>
</tr>
<tr>
<td>1</td>
<td>  </td>
<td>       . <br>
    I/O     I/O<br>
</td>
</tr>
<tr>
<td>2</td>
<td>  </td>
<td>     . <br>
    ID.<br>
  <br>
</td>
</tr>
<tr>
<td>3</td>
<td> </td>
<td>    ID</td>
</tr>
</tbody></table></div><br>
<h2>   .        </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder Endpunkt verf√ºgt √ºber einen eigenen Konfigurationsbereich, in dem sich verschiedene Befehls- und Statusregister befinden. Darunter befinden sich das Basisadressregister oder die BAR. Bei der Initialisierung der Endpunkte durchsucht das BIOS oder Betriebssystem die BAR der Endpunkte, um festzustellen, wie viel Speicher und Speicherplatz f√ºr jeden Endpunkt erforderlich ist. Dann wird in jede aktive BAR die Startadresse des zugewiesenen Teils des Systemspeichers geschrieben. Infolgedessen erh√§lt der Endpunkt eine Adresse, an die entsprechende Anforderungen gesendet werden k√∂nnen. Normalerweise wird am Endpunkt eine Registerkarte gebildet, die an die zugewiesenen Speicherbereiche gebunden ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au√üerdem erh√§lt jeder Endpunkt bzw. das darin enthaltene logische Ger√§t seine eindeutige Kennung, die aus drei Teilen besteht: Busnummer, Ger√§tenummer, Nummer des logischen Ger√§ts (Funktion).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise verf√ºgt das System √ºber gen√ºgend Informationen, um mit dem Endpunkt zu kommunizieren. Das √úbertragen von Daten mithilfe von Abfragen in der BAR weist jedoch eine schlechte Leistung auf. Erstens ist f√ºr eine 32 Bit breite BAR die verwendbare Anforderungsl√§nge auf ein Doppelwort (DWORD) begrenzt; f√ºr eine 64-Bit-Leiste zwei Doppelw√∂rter. Zweitens erfolgt jede Anforderung unter Beteiligung des Zentralprozessors. Um die Belastung des Zentralprozessors zu verringern und die Gr√∂√üe jedes Pakets zu erh√∂hen, muss der Endpunkt Daten unabh√§ngig voneinander in den oder aus dem Systemspeicher verschieben. Dazu muss der Endpunkt wissen, an welchen Systemspeicheradressen er Daten schreiben oder lesen kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Anbetracht des Obigen kann das allgemeine Daten√ºbertragungsschema zwischen dem Endpunkt und dem Systemspeicher wie folgt dargestellt werden:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Endpunkttreiber weist Puffer im Systemspeicher zum Schreiben von Daten zu. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Treiber bildet im Systemspeicher eine Reihe von Adressen und Puffergr√∂√üen - Pufferdeskriptoren zum Schreiben von Daten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Endpunkttreiber schreibt die Adresse des Satzes von Deskriptoren in die Ger√§teregister, die den BAR-Bereichen zugeordnet sind.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Endpunkttreiber programmiert Daten√ºbertragungssteuerregister, die BAR-Bereichen zugeordnet sind; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Endpunkt sendet eine Anforderung zum Lesen des Systemspeichers, um einen Satz von Deskriptoren zum Schreiben in den Systemspeicher zu erhalten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Endpunkt sendet Schreibanforderungen an den Systemspeicher und f√ºllt die Speicherpuffer.</font></font></li>
<li>      /   ,    ,        ,  ;</li>
<li>                   PCIe. </li>
</ol><br>
<h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Phase, in der der Treiber die Endpunktregister konfiguriert, erh√§lt der Endpunkt abh√§ngig von der Art des der BAR zugeordneten Adressraums eine Schreibanforderung in den Speicher (Abbildung 3) oder eine Schreibanforderung in den E / A-Bereich. Wenn der Treiber w√§hrend der Registerkonfiguration ein Register liest, empf√§ngt der Endpunkt auch die entsprechenden Leseanforderungen (Abbildung 4). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/w0/_e/5o/w0_e5oqkd6yfw7uyv9vewkmokw4.png" alt="Bild"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 3 - Beispiel einer Anforderung zum Schreiben in den Speicher 1 DW lang </font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/ca/by/yk/cabyyk_ju4inqbsdevo3b-z3pma.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 4 - Beispiel einer Anforderung zum Lesen aus dem Speicher 1 DW lang</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Gegensatz zu Schreib- oder Leseanforderungen weisen E / A-Anforderungen eine Reihe von Einschr√§nkungen auf. Erstens erfordern sowohl Schreib- als auch Leseanforderungen eine Antwort des Empf√§ngers. Dies f√ºhrt dazu, dass die Daten√ºbertragungsrate unter Verwendung von Anforderungen an den E / A-Raum viel niedriger wird, als es die theoretische PCIe-Bandbreite zul√§sst. Zweitens ist die Adresse von E / A-Speicherplatzanforderungen auf 32 Bit begrenzt, wodurch kein Zugriff auf Fragmente des Systemspeichers √ºber 4 GB hinaus m√∂glich ist. Drittens d√ºrfen E / A-Speicherplatzanforderungen ein Doppelwort nicht √ºberschreiten und nicht mehrere virtuelle Kan√§le f√ºr den Transport verwenden. Aus diesen Gr√ºnden werden Anfragen zum Schreiben und Lesen in den E / A-Bereich nicht weiter ber√ºcksichtigt. Dennoch,Der Inhalt der Header f√ºr den Schreib- / Lesespeicher und den E / A-Raum unterscheidet sich nur in einer Reihe von Feldern. Daher gelten die in den 3, 4 gezeigten Paketstrukturen auch f√ºr Anforderungen im E / A-Raum.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein Endpunkt oder ein PCIe-Stamm eine Anforderung zum Lesen des Speichers oder des E / A-Speicherplatzes empf√§ngt, muss das Ger√§t eine Antwort senden. Wenn der Absender der Anfrage innerhalb einer bestimmten Zeit keine Antwort erh√§lt, f√ºhrt dies zu einem Fehler beim Warten auf eine Antwort. Wenn das Ger√§t aus irgendeinem Grund die angeforderten Daten nicht senden kann, muss es eine Fehlerantwort generieren. M√∂gliche Gr√ºnde k√∂nnen sein: Der Empf√§nger unterst√ºtzt diese Anforderung nicht (nicht unterst√ºtzte Anforderung); Der Empf√§nger ist nicht bereit, die Konfigurationsanforderung anzunehmen, und fordert sie auf, sie sp√§ter zu wiederholen (Wiederholungsstatus der Konfigurationsanforderung). Es ist ein interner Fehler aufgetreten, aufgrund dessen der Empf√§nger nicht antworten und die Anforderung ablehnen kann (Abbruch des Abschlusses). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Formate f√ºr eine erfolgreiche Antwort auf eine Leseanforderung und eine Fehlerantwort f√ºr eine nicht unterst√ºtzte Anforderung sind in den 5, 6 gezeigt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gp/pl/y4/gpply4dawc8olvy6iyeipyeraos.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 5 - Beispiel f√ºr eine erfolgreiche Antwort auf das Lesen </font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/3s/uw/bv/3suwbvjqkiqpoaogl9ewbnbixjq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 6 - Beispiel f√ºr eine Antwort auf eine nicht unterst√ºtzte Anforderung</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
W√§hrend der Endpunkt auf einen Speicherbereich innerhalb von 4 GB zugreift, unterscheidet sich das Format der Paket-Header nicht von den in den Abbildungen 3, 4 gezeigten Headern. F√ºr Schreibanforderungen Wenn Sie einen Speicher von mehr als 4 GB lesen, wird im Header ein zus√§tzliches Doppelwort mit h√∂herwertigen Bits der Zieladresse verwendet (Abbildung 7). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rr/1o/w6/rr1ow6yxljdhqffy9gguw6v-3os.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 7 - Ein Beispiel f√ºr einen 128-Byte-Schreibanforderungsheader.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Erl√§uterungen zu abgek√ºrzten Namen von Paketheaderfeldern sind in Tabelle 4 aufgef√ºhrt. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabelle 4 - Liste der Abk√ºrzungen f√ºr Headerfelder</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nr. P.</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feldbezeichnung</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feldname</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geplanter Termin</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verkehrskategorie - Verkehrsklasse</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definiert die Mitgliedschaft im virtuellen Kanal</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atr</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attribute</font></font></td>
<td>   : , ,    ID,       ID.</td>
</tr>
<tr>
<td>3</td>
<td>TH</td>
<td>    ‚Äí TLP Processing Hint</td>
<td>,         [1..0]      .</td>
</tr>
<tr>
<td>4</td>
<td>TD</td>
<td>       ‚Äí TLP Digest</td>
<td>,          .</td>
</tr>
<tr>
<td>5</td>
<td>EP</td>
<td>    </td>
<td>,      .</td>
</tr>
<tr>
<td>6</td>
<td>AT</td>
<td>  ‚Äí Address Translation</td>
<td>,     :   ,  ,  </td>
</tr>
<tr>
<td>7</td>
<td>BE</td>
<td>        ‚Äí Byte Enable</td>
<td>         </td>
</tr>
<tr>
<td>8</td>
<td>PH</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paketverarbeitungshinweis - Verarbeitungshinweis</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt dem Paketempf√§nger Tipps zur Verwendung des Pakets sowie zur Datenstruktur</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BCM</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Vorhandensein einer √Ñnderung in der Anzahl der Bytes</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt an, ob sich die Anzahl der Bytes im Paket ge√§ndert hat. </font><font style="vertical-align: inherit;">Nur ein Absender angesichts eines PCI-X-Ger√§ts kann ein Flag setzen</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein Endpunkt Interrupts verwendet, um ein Ereignis zu melden, muss er auch ein geeignetes Paket bilden. </font><font style="vertical-align: inherit;">Insgesamt kann PCIe drei Arten von Interrupts verwenden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legacy-Interrupts (Legacy-Interrupts oder INT);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterbrechungen in Form von Nachrichten (Message Signaled Interrupts oder MSI);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erweiterte Nachrichteninterrupts (Message Signaled Interrupts Extended oder MSI-X).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Geerbte INT-Interrupts werden aus Gr√ºnden der Kompatibilit√§t mit Systemen verwendet, die keine Nachrichteninterrupts unterst√ºtzen. Tats√§chlich ist diese Art von Interrupt eine Nachricht (ein Paket vom Typ Nachricht), die den Betrieb einer physischen Interruptleitung simuliert. Bei einem bestimmten Ereignis sendet der Endpunkt eine Nachricht an das PCIe-Stammverzeichnis, dass der INT-Interrupt aktiviert wurde, und wartet dann auf die Aktion des Interrupt-Handlers. Bis der Interrupt-Handler die angegebene Aktion ausf√ºhrt, befindet sich der INT-Interrupt im aktivierten Zustand. Bei geerbten Interrupts k√∂nnen Sie die Quelle des Ereignisses nicht bestimmen, wodurch der Interrupt-Handler gezwungen wird, alle Endpunkte im PCIe-Baum nacheinander zu scannen, um diesen Interrupt zu bedienen. Wenn der Interrupt bedient wird, sendet der Endpunkt eine Nachricht, die dies besagtdass der INT-Interrupt inaktiver ist. Die FPGA-Hardwarekerne erzeugen auf ein Signal von der Benutzerlogik unabh√§ngig die erforderlichen Nachrichten f√ºr INT-Interrupts, sodass die Paketstruktur nicht ber√ºcksichtigt wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachrichteninterrupts sind zusammen mit ihrer erweiterten Version die Haupt- und obligatorische Art von Interrupt in PCIe. Beide Arten von Interrupts sind in der Tat eine Anforderung, mit einer L√§nge von einem Doppelwort in den Systemspeicher zu schreiben. Der Unterschied zu einer regul√§ren Anforderung besteht darin, dass die Aufzeichnungsadresse und der Paketinhalt in der Phase der Systemkonfiguration jedem Ger√§t zugewiesen werden. In diesem Fall wird der lokale Advanced Programmable Interrupt Controller (LAPIC) im Zentralprozessor zum Ziel. Bei Verwendung dieser Art von Interrupt m√ºssen nicht alle Ger√§te im PCIe-Baum nacheinander abgefragt werden. Wenn das System dem Ger√§t erlaubt, mehrere Interruptvektoren zu verwenden, kann dar√ºber hinaus jedem Vektor ein eigenes Ereignis zugeordnet werden.Zusammen reduziert dies die Prozessorzeit f√ºr die Verarbeitung von Interrupts und erh√∂ht die Gesamtsystemleistung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSI-Interrupts erm√∂glichen die Bildung von bis zu 32 separaten Vektoren. Die genaue Anzahl h√§ngt von den Funktionen des Endpunkts ab. In diesem Fall kann das System die Verwendung nur eines Teils der Vektoren erlauben. In der Konfigurationsphase schreibt das System die Interruptadresse und die Anfangsdaten zum Schreiben in die speziellen Register des Konfigurationsraums des Endpunkts. Alle aktiven Interrupts verwenden dieselbe Adresse. F√ºr jeden Vektor √§ndert der Endpunkt jedoch die Bits der Anfangsdaten. Lassen Sie beispielsweise einen Endpunkt maximal 4 Interruptvektoren unterst√ºtzen, alle 4 Vektoren sind im System zul√§ssig und die Anfangsdaten zum Schreiben sind 0x4970. Um den ersten Vektor zu bilden, √ºbergibt der Endpunkt die Anfangsdaten unver√§ndert. F√ºr den zweiten Vektor √§ndert das Ger√§t das erste Bit und sendet die Nummer 0x4971.F√ºr den dritten und vierten Vektor sendet das Ger√§t die Nummern 0x4972 bzw. 0x4973.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die FPGA-Hardwarekerne bilden unabh√§ngig voneinander ein Paket mit einem MSI-Interrupt durch ein Signal von der Benutzerlogik. Bevor der Kernel jedoch angewiesen wird, einen Interrupt zu senden, muss die Benutzerlogik auch den Inhalt des Pakets f√ºr den erforderlichen Vektor an eine spezielle Kernelschnittstelle senden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSI-X-Interrupts erm√∂glichen die Bildung von bis zu 2048 einzelnen Vektoren. In den entsprechenden Registern des Konfigurationsraums gibt der Endpunkt an, in welchem ‚Äã‚Äãder BAR-Adressr√§ume und mit welchem ‚Äã‚ÄãVersatz von der Basisadresse sich die Interrupt-Tabelle (Abbildung 8) und die Tabelle der anstehenden Interrupt-Flags (Pending Bit Array - PBA, Abbildung 9) sowie die Gr√∂√üen beider befinden Tabellen. Das System schreibt eine separate Adresse und Daten zum Schreiben in jede Zeile der Interrupt-Tabelle und erlaubt oder verbietet auch die Verwendung eines bestimmten Vektors durch das erste Bit des Vektorsteuerungsfeldes. F√ºr ein bestimmtes Ereignis setzt der Endpunkt ein Flag in der Flag-Tabelle der ausstehenden Interrupts. Wenn f√ºr diesen Interrupt im Feld Vector Control keine Maske festgelegt ist, sendet der Endpunkt einen Interrupt an die Adresse aus der Interrupt-Tabelle mit dem angegebenen Inhalt des Pakets.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zl/6q/el/zl6qelezf6aixg5qjw-rbeotwkc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 8 - Tabelle der MSI-X-Interrupt-Vektoren </font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/q8/ms/as/q8msasscf-ytecdpefn-ohdjc1q.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 9 - Tabelle der Flags f√ºr ausstehende Interrupts</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
FPGA-Hardwarekerne verf√ºgen nicht √ºber eine spezielle Schnittstelle f√ºr MSI-X-Interrupts. </font><font style="vertical-align: inherit;">Der Entwickler selbst muss eine Interrupt-Tabelle in der Benutzerlogik und eine Tabelle mit Flags ausstehender Interrupts erstellen. </font><font style="vertical-align: inherit;">Ein Interrupt-Paket wird auch vollst√§ndig vom Benutzer generiert und zusammen mit anderen Pakettypen √ºber die allgemeine Kernel-Schnittstelle √ºbertragen. </font><font style="vertical-align: inherit;">Das Paketformat entspricht in diesem Fall, wie oben bereits erw√§hnt, einer Anforderung zum Schreiben in den Systemspeicher mit einer L√§nge von einem Doppelwort.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merkmale der Hardwarekerne PCI Express FPGA V-Serie von Intel in der Version Avalon-ST</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass die Hardwarekerne von PCI Express-FPGAs verschiedener Hersteller √§hnliche Funktionen implementieren, k√∂nnen sich die einzelnen Kernschnittstellen oder die Reihenfolge ihres Betriebs unterscheiden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PCI Express FPGA-Hardwarekerne der Intel V-Serie sind in zwei Versionen erh√§ltlich: mit Avalon-MM und Avalon-ST. Letzteres erm√∂glicht es Ihnen, die meiste Bandbreite zu erhalten, obwohl dies vom Entwickler mehr Aufwand erfordert. Aus diesem Grund wird ein Kernel mit einer Avalon-MM-Schnittstelle nicht ber√ºcksichtigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der PCI Express-Kerndokumentation mit der Avalon-ST-Schnittstelle werden die Kernelparameter, Eingangs- und Ausgangssignale ausreichend detailliert beschrieben. Der Kernel verf√ºgt jedoch √ºber eine Reihe von Funktionen, auf die ein Entwickler achten sollte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste Gruppe von Funktionen bezieht sich auf Methoden, mit denen Sie FPGAs innerhalb von 100 ms gem√§√ü den PCIe-Anforderungen konfigurieren k√∂nnen. Zus√§tzlich zum parallelen Laden des FPP-Typs werden dem Entwickler Methoden wie die Konfiguration √ºber Protokoll (CvP) und den autonomen Modus des Kernels (autonomer Modus) angeboten. Der Entwickler muss sicherstellen, dass die Konfiguration √ºber das Protokoll oder den Standalone-Kernel-Modus f√ºr die ausgew√§hlte PCIe-Geschwindigkeit unterst√ºtzt wird (Parameter ‚ÄûLane Rate‚Äú). F√ºr die Konfiguration √ºber das Protokoll finden Sie relevante Informationen in der Kerneldokumentation. Im Offline-Modus gibt es keine solchen Informationen, daher m√ºssen Sie das Projekt kompilieren. Wenn der eigenst√§ndige Kernelmodus f√ºr die aktuelle Kernelgeschwindigkeit nicht unterst√ºtzt wird, generiert Quartus einen entsprechenden Fehler (Abbildung 10).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xj/hy/ok/xjhyokbx1mvolf2dweiawoytyzk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 10 - Fehler beim Kompilieren eines PCIe-Kernels f√ºr den Offline-Modus</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn ein Entwickler die Konfiguration √ºber ein Protokoll verwenden m√∂chte, sollte er auch darauf achten, mit welchem ‚Äã‚ÄãFPGA-Kern der PCIe-Anschluss verbunden ist. Dies gilt insbesondere dann, wenn der Entwickler kein fertiges Board, sondern sein eigenes Ger√§t verwendet. In FPGAs mit mehreren PCIe-Hardwarekernen kann CvP nur mit einem Kern aktiviert werden. Die Position des Kerns mit CvP-Unterst√ºtzung ist in der FPGA-Dokumentation angegeben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite Gruppe von Merkmalen betrifft die Avalon-ST-Daten√ºbertragungsschnittstelle selbst. √úber diese Schnittstelle werden Pakete auf Transaktionsebene zwischen der Benutzerlogik und dem Kernel √ºbertragen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der Empfangsseite verf√ºgt der Kernel √ºber zwei Signale, mit denen der Benutzer den Empfang empfangener Pakete unterbrechen kann: das Signal rx_st_mask und das Signal rx_st_ready. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dem Signal rx_st_ready kann der Entwickler die Ausgabe aller Pakettypen anhalten. Wenn Sie dieses Signal jedoch aktivieren, stoppt der Kernel die Ausgabe von Paketen nach nur zwei Taktzyklen der Betriebsfrequenz. Daher muss die Benutzerlogik w√§hrend der Signalaktivierung bereit sein, eine zus√§tzliche Datenmenge zu empfangen. Wenn ein Entwickler beispielsweise einen Puffer in Form eines FIFO verwendet, sollte er Puffer√ºberl√§ufe vermeiden. Andernfalls geht ein Teil des Paketinhalts verloren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dem Signal "rx_st_mask" setzt der Entwickler die Ausgabe von Anfragen aus, f√ºr die Antworten gesendet werden m√ºssen. Dieses Signal stoppt auch nicht sofort die Ausgabe von Paketen. Gem√§√ü der Dokumentation kann der Kernel nach Aktivierung des Signals bis zu 10 Anforderungen ausgeben. Wenn die Benutzerlogik "rx_st_mask" aktiviert und nicht gen√ºgend Speicherplatz im Puffer vorhanden ist, um empfangene Pakete zu verarbeiten, kann dies auch das Signal "rx_st_ready" aktivieren. In dieser Situation h√∂rt die Benutzerlogik auf, Pakete aus dem internen Hardware-Kernel-Puffer zu lesen. Dies √ºberschreitet nicht nur die Hardware-Kernel-Puffer, sondern verst√∂√üt auch gegen die Anforderungen an die Paketreihenfolge. Das Ger√§t muss Anforderungen, f√ºr die keine Antwort erforderlich ist, √ºberspringen und Antworten lesen. Andernfalls wird der Datenkanal dicht blockiert.Aus diesem Grund sollte der Entwickler einen zus√§tzlichen Puffer verwenden, um Anforderungen mit Antworten zu verarbeiten, und der Logik nicht erlauben, Pakete mit h√∂herer Priorit√§t zu blockieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der Sendeseite k√∂nnen die Signale tx_st_valid und tx_st_ready Probleme verursachen. Wenn das Signal tx_st_ready aktiv ist, darf die Benutzerlogik das tx_st_valid in der Mitte des ausgehenden Pakets nicht zur√ºcksetzen. Dies bedeutet, dass der Entwickler w√§hrend der √úbertragung den gesamten Inhalt des Pakets bereitstellen muss. Wenn die Datenquelle langsamer als die Kernelschnittstelle ist, muss die Benutzerlogik vor dem Start des Pakets die erforderliche Datenmenge akkumulieren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sowohl auf der Empfangsseite als auch auf der Sendeseite sollte der Entwickler auf die Bytereihenfolge im Header und den Inhalt des Pakets sowie auf die Datenausrichtung achten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Avalon-ST-Paket des Hardwarekerns folgen die Bytes innerhalb jedes Doppelworts im Header des PCIe-Pakets von niedrig nach hoch; im Verpackungsinhalt - vom √§ltesten zum j√ºngsten. Der Entwickler muss in ausgehenden Paketen eine √§hnliche Reihenfolge verwenden, um Daten erfolgreich vom Endpunkt zum Stamm zu √ºbertragen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Avalon-ST-Schnittstelle des Hardwarekerns richtet die Daten in Vielfachen von 64 Bit aus. Abh√§ngig von der Breite der Avalon-ST-Schnittstelle, der L√§nge des Paket-Headers auf Transaktionsebene und der Paketadresse kann der Kernel ein leeres Doppelwort zwischen dem Paket-Header und seinem Inhalt hinzuf√ºgen. Bei der Daten√ºbertragung muss die Benutzerlogik wiederum analog zum Kernel im Voraus ein leeres Doppelwort hinzuf√ºgen. Dieses leere Doppelwort wird in der Paketl√§nge nicht ber√ºcksichtigt und ist nur f√ºr den korrekten Betrieb des Hardware-Kernels erforderlich.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die n√§chste Funktion bezieht sich auf eingehende Leseantworten. Die Kernelbeschreibung besagt, dass eingehende Antworten, deren Kennung nicht mit der ausgehenden Anforderung √ºbereinstimmt, nicht √ºbersehen werden. Gleichzeitig sollte die Benutzerlogik der Wartezeit f√ºr Antworten folgen. Wenn die Wartezeit √ºberschritten wird, muss die Benutzerlogik das Flag "cpl_err [0]" oder "cpl_err [1]" setzen. Aus der Dokumentation geht nicht hervor, wie die Filterung funktioniert, wenn der Endpunkt mehrere Leseanforderungen sendet. Die Benutzerlogik teilt dem Kernel nur mit, dass das Zeitlimit f√ºr eine der Anforderungen abgelaufen ist, kann jedoch die Kennung dieser Anforderung nicht an den Kernel √ºbergeben. Es besteht die M√∂glichkeit, dass der Kernel Antworten f√ºr eine Anforderung mit einem abgelaufenen Zeitlimit an die Benutzerseite sendet. Daher muss der Entwickler einen eigenen Filter f√ºr eingehende Antworten erstellen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schlie√ülich wird Entwicklern dringend empfohlen, die Informationen zu verf√ºgbaren Darlehen f√ºr ausgehende Pakete zu verwenden. </font><font style="vertical-align: inherit;">Die Kerndokumentation besagt, dass dies nicht erforderlich ist, da der Kernel Kredite pr√ºft und Pakete blockiert, wenn nicht gen√ºgend Kredite vorhanden sind. </font><font style="vertical-align: inherit;">Alle Arten von Paketen gelangen jedoch √ºber eine einzige Schnittstelle zum Kernel. </font><font style="vertical-align: inherit;">Wenn der Kernel-Paketpuffer √ºberl√§uft, senkt der Kernel das Signal tx_st_ready auf Null. </font><font style="vertical-align: inherit;">Bis das Signal tx_st_ready auf eins gesetzt ist, kann die Benutzerlogik im Prinzip keine Pakete senden. </font><font style="vertical-align: inherit;">Die Anzahl der verf√ºgbaren Kredite wird durch Pakete von einem Partnerger√§t aktualisiert. </font><font style="vertical-align: inherit;">Wenn die Logik des Benutzers nicht nur h√§ufig schreibt, sondern auch liest, sinkt die Geschwindigkeit, mit der der Kernel die Grenzwertz√§hler aktualisiert. </font><font style="vertical-align: inherit;">Am Ende leidet die Gesamtsystemleistung.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel beschreibt die allgemeinen Prinzipien der Daten√ºbertragung √ºber PCI Express, die Formate der Hauptdatenpakete. </font><font style="vertical-align: inherit;">Trotzdem hat der Autor Schnittstellenkomponenten wie virtuelle Kan√§le weggelassen, die Kontrolle des Volumens der eingehenden Antworten zum Lesen und die Reihenfolge der Pakete ist nicht streng. </font><font style="vertical-align: inherit;">Diese Themen werden in einer Reihe ausl√§ndischer Quellen ausf√ºhrlich diskutiert [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel enth√§lt auch die Funktionen der FPGA-FPGA-Hardwarekerne der Intel Express V-Serie, auf die der Autor bei der Arbeit am Schnittstellencontroller gesto√üen ist. </font><font style="vertical-align: inherit;">Diese Erfahrung kann f√ºr andere Entwickler n√ºtzlich sein.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste der verwendeten Quellen</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine PCIe-DMA-Architektur f√ºr die Daten√ºbertragung mit mehreren Gigabyte pro Sekunde / L. Rota, M. Caselle, et. </font><font style="vertical-align: inherit;">al. </font><font style="vertical-align: inherit;">// IEEE TRANSACTIONS ON NUCLEAR SCIENCE, VOL. </font><font style="vertical-align: inherit;">62, NO. </font><font style="vertical-align: inherit;">3. Juni 2015.</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">An Efficient and Flexible Host-FPGA PCIe Communication Library / Jian Gong, Tao Wang, Jiahua Chen et. al. // 2014 24th International Conference on Field Programmable Logic and Applications.</a></li>
<li>Design and Implementation of a High-Speed Data Acquisition Card Based on PCIe Bus / Li Mu-guo, Huang Ying, Liu Yu-zhi // „ÄäÊµãÊéßÊäÄÊúØ„Äã2013Âπ¥Á¨¨32Âç∑Á¨¨7Êúü„ÄÇ</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Down to the TLP: How PCI express devices talk (Part I) / Eli Billauer</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Low-Cost FPGA Solution for PCI Express Implementation / Intel Corporation.</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Managing Receive-Buffer Space for Inbound Completions / Xilinx // Virtex-7 FPGA Gen3 Integrated Block for PCI Express v4.3, Appendix B</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">PCIe Completion Timeout / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">PCIe packet in cyclone VI GX / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">PCIe simple transaction / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">PCIe w/ Avalon ST: Equivalent of ko_cpl_spc_vc0? / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Point me in the right Direction ‚Äì PCIe / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit√ºberschreitungen im PCIE / Altera Forum anfordern</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hochgeschwindigkeits-Schnittstellendesign basierend auf PCIe der nicht kooperativen Empf√§ngerverifizierungsplattform / Li Xiao-ning, Yao Yuan-cheng und Qin Ming-wei // 2016 Internationale Konferenz f√ºr Mechanik, Steuerung, Elektrik, Mechatronik, Information und Computer</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCI Express-Basisspezifikation Revision 3.0 / PCI-SIG</font></font></a> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stratix V Avalon-ST-Schnittstelle f√ºr PCIe Solutions / Intel Corporation </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cyclone V Avalon-ST-Schnittstelle f√ºr PCIe Solutions / Intel Corporation</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de496680/index.html">Industrie 4.1: Roboterbesitz, neuronale Netze und Open Source-Monetarisierung</a></li>
<li><a href="../de496682/index.html">So bleiben Sie professionell gefragt</a></li>
<li><a href="../de496686/index.html">Wie Verkehrsanalysesysteme Hacker-Taktiken erkennen von MITRE ATT & CK, Teil 4</a></li>
<li><a href="../de496690/index.html">Coronavirus-Steuerungstechnologien</a></li>
<li><a href="../de496692/index.html"># 06 - Und ein ganzes Byte reicht nicht ... | Flaches Wetter</a></li>
<li><a href="../de496704/index.html">Leiterplatte der Saturn-5-Rakete - Reverse Engineering mit Erl√§uterungen</a></li>
<li><a href="../de496706/index.html">Wochenendlesung: Eine Geschichte der Audioformate - Das Zeitalter der Kassetten und die Entwicklung von Sprachsynthesetechnologien</a></li>
<li><a href="../de496708/index.html">Raumkanone, Dampfrakete und Orbitalspiegel</a></li>
<li><a href="../de496710/index.html">Computerinformationen: Einfach und schnell</a></li>
<li><a href="../de496712/index.html">Einmal bei einem Pentest oder wie man mit Hilfe eines Urologen und Roskomnadzors alles kaputt macht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>