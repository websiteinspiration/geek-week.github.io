<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛱️ 👩🏿‍🤝‍👨🏾 📃 非負行列分解を使用して白黒画像をASCIIグラフィックに変換します 👨🏿‍🎓 🍈 📼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="一般に、画像をASCIIグラフィックに変換するのはかなり時間がかかる作業ですが、このプロセスを自動化するアルゴリズムがあります。この記事では、研究者Paul D. O'GradyとScott T. Rickardが「非負の制約を使用したバイナリイメージの自動ASCIIアート変換」で提案したアプローチ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>非負行列分解を使用して白黒画像をASCIIグラフィックに変換します</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463193/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hq/s7/wl/hqs7wlxixfh79akhz1b_mtsqdby.png" width="500"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、画像をASCIIグラフィックに変換するのはかなり時間がかかる作業ですが、このプロセスを自動化するアルゴリズムがあります。</font><font style="vertical-align: inherit;">この記事では、研究者Paul D. O'GradyとScott T. Rickardが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「非負の制約を使用したバイナリイメージの自動ASCIIアート変換」で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提案したアプローチについて説明し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">彼らによって説明された方法は、画像変換プロセスを最適化問題として表現し、非負行列分解を使用してこの問題を解決することを含みます。</font><font style="vertical-align: inherit;">以下は、問題のアルゴリズムとその実装の説明です。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズムの説明</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元の画像は、サイズのブロックに分割されます</font></font><img src="https://habrastorage.org/getpro/habr/post_images/8ff/59f/7d7/8ff59f7d770613863cd2c0483685db98.svg" alt="M \ N倍"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ここで</font></font><img src="https://habrastorage.org/getpro/habr/post_images/8da/056/75e/8da05675e58b0287c1cca7e37cdc1d99.svg" alt="M"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、および</font></font><img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、1文字の幅と高さ（ピクセル単位）です。</font><font style="vertical-align: inherit;">画像の幅\高さが文字の幅\高さの倍数でない場合、画像はトリミングされるか、目的のサイズの白い領域で補足されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/se/qe/pu/seqepumqylvcdk6upn-dd9vi_4q.png" width="250"></div><br><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/b95/4f4/3ce/b954f43ce67f65a92502a661914b76e4.svg" alt="K"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分割後に取得された</font><font style="vertical-align: inherit;">
各</font><font style="vertical-align: inherit;">ブロックは、長さのベクトルとして表され</font></font><img src="https://habrastorage.org/getpro/habr/post_images/840/ed3/a5a/840ed3a5a13dc397969bf6a205f84279.svg" alt="R = M * N"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。その値は、画像ピクセルの色の強度です（値は0から255で、白いピクセルは0に対応し、黒いピクセルは255に対応します）。</font><font style="vertical-align: inherit;">結果のベクトルは、ノルムを使用して正規化する必要があります</font></font><img src="https://habrastorage.org/getpro/habr/post_images/966/980/a89/966980a893368f21382de225cb386c40.svg" alt="l_2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9d/025/739/b9d025739593e0f7204d847a453696f6.svg" alt="v_i = \ frac {v_i} {\ sqrt {\ sum ^ R_ {k = 1} {v ^ 2_k}}}"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/dy/yp/lz/dyyplzoz5tqb1lcykfkm-4imbm8.png" width="500"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正規化されたベクトルは列の形に書き直され、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/16c/36a/136/16c36a136a8b7f32e276c761a28366ad.svg" alt="V"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズの</font><font style="vertical-align: inherit;">行列を形成し</font><font style="vertical-align: inherit;">ます</font></font><img src="https://habrastorage.org/getpro/habr/post_images/083/983/d7b/083983d7b6c59f43192e4290078b5f25.svg" alt="R \ K"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/86/sx/hn/86sxhn1rqtrj8zgc4ggxdysimxa.png" width="550"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果の行列</font></font><img src="https://habrastorage.org/getpro/habr/post_images/16c/36a/136/16c36a136a8b7f32e276c761a28366ad.svg" alt="V"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、行列</font></font><img src="https://habrastorage.org/getpro/habr/post_images/b01/e2a/c4f/b01e2ac4f751abe6f542b4e3e5d7ff46.svg" alt="W"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">との</font><font style="vertical-align: inherit;">積として表す必要があります</font><font style="vertical-align: inherit;">。その</font></font><img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての要素は負ではありません。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47e/bda/50f/47ebda50f4a5615da97271890fec3f87.svg" alt="V_ {R \回K} = W_ {R \回L} H_ {L \回K}"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
行列は</font></font><img src="https://habrastorage.org/getpro/habr/post_images/b01/e2a/c4f/b01e2ac4f751abe6f542b4e3e5d7ff46.svg" alt="W"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事前にわかっています</font><font style="vertical-align: inherit;">。行列と</font><font style="vertical-align: inherit;">同様に構成され</font></font><img src="https://habrastorage.org/getpro/habr/post_images/16c/36a/136/16c36a136a8b7f32e276c761a28366ad.svg" alt="V"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ますが、元の画像のセクションの代わりに、ASCIIグラフィックスの生成に使用されるすべてのシンボルの画像が使用されます。</font><font style="vertical-align: inherit;">該当するセットに</font></font><img src="https://habrastorage.org/getpro/habr/post_images/899/a67/551/899a675510d28419769a9b42281f0c65.svg" alt="L"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文字が</font><font style="vertical-align: inherit;">含まれている場合、</font><font style="vertical-align: inherit;">マトリックス</font></font><img src="https://habrastorage.org/getpro/habr/post_images/b01/e2a/c4f/b01e2ac4f751abe6f542b4e3e5d7ff46.svg" alt="W"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のサイズはになり</font></font><img src="https://habrastorage.org/getpro/habr/post_images/a76/a5a/884/a76a5a884fe0da7d2cdfeeab7d895c8f.svg" alt="R \ L倍"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
と</font><font style="vertical-align: inherit;">製品の</font></font><img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">違いを特徴付ける目的関数の値を最小化するような方法で</font><font style="vertical-align: inherit;">マトリックスを選択するだけ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/16c/36a/136/16c36a136a8b7f32e276c761a28366ad.svg" alt="V"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です</font></font><img src="https://habrastorage.org/getpro/habr/post_images/606/4df/837/6064df837796bdcfd80eee8bf2cb5eba.svg" alt="WH"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そのような関数として、次の依存関係が使用されます。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35d/fe5/834/35dfe58346bb38035eb7f9f1e5c0cc2d.svg" alt="D（V、W、H、\ beta）= \ sum_ {ik} \ bigg（{v_ {ik} \ frac {v_ {ik} ^ {\ beta-1}-[WH] ^ {\ beta-1} _ {ik}} {\ beta（\ beta-1）}} + [WH] ^ {\ beta-1} _ {ik} \ frac {[WH] _ {ik} -v_ {ik}} {\ beta } \ bigg）"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この式は、基本的にいくつかの目的関数を組み合わせています。</font></font><img src="https://habrastorage.org/getpro/habr/post_images/215/e6c/c96/215e6cc967c4f2092c353e52ef79ead5.svg" alt="\ベータ= 2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユークリッド距離の2乗（2乗ユークリッド距離）に変換されるとき</font></font><img src="https://habrastorage.org/getpro/habr/post_images/e2b/8cc/041/e2b8cc04156c65f9868bf19291640ceb.svg" alt="\ベータ\ rightarrow 1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、カルバックライブラーダイバージェンス</font></font><img src="https://habrastorage.org/getpro/habr/post_images/419/9a1/7fa/4199a17fa752d575915ac78f256b3ca4.svg" alt="\ベータ\ rightarrow 0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">距離</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">近づくとき、および</font><font style="vertical-align: inherit;">-板倉-斉藤距離（板倉-斉藤）に発散）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マトリックスは</font></font><img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のように</font><font style="vertical-align: inherit;">直接選択さ</font><font style="vertical-align: inherit;">れます：</font></font><img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0から1までのランダムな値で初期化された後、その値は次のルールに従って反復的に更新されます（反復回数は事前に設定されています）。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce2/ab9/9ba/ce2ab99baf9cf808d44be37992988bd9.svg" alt="h_ {jk} = h_ {jk} \ frac {\ sum ^ R_ {i = 1} {w_ {ij} \ frac {v_ {ik}} {[WH] ^ {2- \ beta} _ {ik}} }} {\ sum ^ R_ {i = 1} {w_ {ij} [WH] ^ {\ beta-1} _ {ik}}}"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各値</font><font style="vertical-align: inherit;">は、画像の</font><font style="vertical-align: inherit;">i番目の</font><font style="vertical-align: inherit;">領域で</font><font style="vertical-align: inherit;">使用されるセットからのi番目のシンボルの</font></font><img src="https://habrastorage.org/getpro/habr/post_images/40e/522/a20/40e522a2076658bdacea86b0879cbd0e.svg" alt="h_ {ij}"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">類似度に対応し</font><font style="vertical-align: inherit;">ます。</font></font><img src="https://habrastorage.org/getpro/habr/post_images/75c/b01/aa8/75cb01aa8d9f97db4343ac0c5ef11b2d.svg" alt="私"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/c73/07a/1bf/c7307a1bf9d387db2abbcfc4215797c1.svg" alt="j"><font style="vertical-align: inherit;"></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/jn/1m/pbjn1mivzxwizfdv4icdcxw-fam.png" width="380"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/c73/07a/1bf/c7307a1bf9d387db2abbcfc4215797c1.svg" alt="j"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i番目のセグメント</font><font style="vertical-align: inherit;">を置き換えるシンボルを決定するに</font></font><img src="https://habrastorage.org/getpro/habr/post_images/c73/07a/1bf/c7307a1bf9d387db2abbcfc4215797c1.svg" alt="j"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、行列の</font><font style="vertical-align: inherit;">i番目の</font><font style="vertical-align: inherit;">列で</font><font style="vertical-align: inherit;">最大値を見つけるだけで十分</font></font><img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">この値が配置されている行番号は、セット内で検索する文字の番号になります。</font><font style="vertical-align: inherit;">さらに、いくつかのしきい値を入力できます。</font></font><img src="https://habrastorage.org/getpro/habr/post_images/dfd/a20/501/dfda20501ea6a3b10420bbd24587e600.svg" alt="\イプシロン"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見つかった最大値がこのしきい値よりも小さい場合、画像領域はスペースに置き換えられます。</font><font style="vertical-align: inherit;">スペースを使用すると、類似性の低い記号を使用する場合と比較して、結果の画像の外観に良い影響を与えることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムはC＃で実装されています。</font><font style="vertical-align: inherit;">ASCIIグラフィックスは、11x23ピクセルのサイズの95文字（0x20から0x7E）を使用して生成されます。</font><font style="vertical-align: inherit;">使用されているフォントはCourierです。</font><font style="vertical-align: inherit;">以下は、元の画像をASCIIグラフィックに変換する関数のソースコードです。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[,] ConvertImage(<font></font>
    Bitmap image, <font></font>
    <span class="hljs-keyword">double</span> beta,
    <span class="hljs-keyword">double</span> threshold,
    <span class="hljs-keyword">ushort</span> iterationsCount,
    <span class="hljs-keyword">ushort</span> threadsNumber,<font></font>
    Action&lt;<span class="hljs-keyword">int</span>&gt; ProgressUpdated)<font></font>
{<font></font>
    <span class="hljs-keyword">int</span> charNumHor = (<span class="hljs-keyword">int</span>)Math.Round((<span class="hljs-keyword">double</span>)image.Width / glyphWidth);
    <span class="hljs-keyword">int</span> charNumVert = (<span class="hljs-keyword">int</span>)Math.Round((<span class="hljs-keyword">double</span>)image.Height / glyphHeight);
    <span class="hljs-keyword">int</span> totalCharactersNumber = charNumVert * charNumHor;
    <span class="hljs-keyword">int</span> glyphSetSize = wNorm.ColumnCount;<font></font>
<font></font>
    Matrix&lt;<span class="hljs-keyword">double</span>&gt; v = SplitImage(image, charNumVert, charNumHor);<font></font>
<font></font>
    Matrix&lt;<span class="hljs-keyword">double</span>&gt; h = Matrix&lt;<span class="hljs-keyword">double</span>&gt;.Build.Random(<font></font>
        glyphSetSize, <font></font>
        totalCharactersNumber, <font></font>
        <span class="hljs-keyword">new</span> ContinuousUniform());<font></font>
<font></font>
    <span class="hljs-keyword">int</span> progress = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">ushort</span> step = (<span class="hljs-keyword">ushort</span>)(iterationsCount / <span class="hljs-number">10</span>);<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">ushort</span> i = <span class="hljs-number">0</span>; i &lt; iterationsCount; i++)<font></font>
    {<font></font>
        UpdateH(v, wNorm, h, beta, threadsNumber);<font></font>
<font></font>
        <span class="hljs-keyword">if</span>((i + <span class="hljs-number">1</span>) % step == <span class="hljs-number">0</span>)<font></font>
        {<font></font>
            progress += <span class="hljs-number">10</span>;<font></font>
<font></font>
            <span class="hljs-keyword">if</span>(progress &lt; <span class="hljs-number">100</span>)<font></font>
            {<font></font>
                ProgressUpdated(progress);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">var</span> result = GetAsciiRepresentation(h, charNumVert, charNumHor, threshold);<font></font>
    ProgressUpdated(<span class="hljs-number">100</span>);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> result;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ステップを個別に検討します</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。1）画像の幅と高さにいくつの文字が収まるかを計算します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">int</span> charNumHor = (<span class="hljs-keyword">int</span>)Math.Round((<span class="hljs-keyword">double</span>)image.Width / glyphWidth);
<span class="hljs-keyword">int</span> charNumVert = (<span class="hljs-keyword">int</span>)Math.Round((<span class="hljs-keyword">double</span>)image.Height / glyphHeight);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
計算された値を使用して、元の画像を必要なサイズのブロックに分割します。</font><font style="vertical-align: inherit;">各ブロックについて、マトリックスの対応する列にピクセルカラー強度の値を書き込み</font></font><img src="https://habrastorage.org/getpro/habr/post_images/16c/36a/136/16c36a136a8b7f32e276c761a28366ad.svg" alt="V"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（必要に応じて、白いピクセルに対応するゼロ値をマトリックスに追加して元の画像を拡張します）、すべての列を正規化します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Matrix&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">SplitImage</span>(<span class="hljs-params">
    Bitmap image, 
    <span class="hljs-keyword">int</span> charNumVert, 
    <span class="hljs-keyword">int</span> charNumHor</span>)</span><font></font>
{<font></font>
    Matrix&lt;<span class="hljs-keyword">double</span>&gt; result = Matrix&lt;<span class="hljs-keyword">double</span>&gt;.Build.Dense(<font></font>
        glyphHeight * glyphWidth, <font></font>
        charNumHor * charNumVert);<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; charNumVert; y++)<font></font>
    {<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; charNumHor; x++)<font></font>
        {<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; glyphHeight; j++)<font></font>
            {<font></font>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; glyphWidth; i++)<font></font>
                {<font></font>
                    <span class="hljs-keyword">byte</span> color = <span class="hljs-number">0</span>;<font></font>
<font></font>
                    <span class="hljs-keyword">if</span> ((x * glyphWidth + i &lt; image.Width) &amp;&amp;<font></font>
                        (y * glyphHeight + j &lt; image.Height))<font></font>
                    {<font></font>
                        color = (<span class="hljs-keyword">byte</span>)(<span class="hljs-number">255</span> - image.GetPixel(<font></font>
                            x * glyphWidth + i,<font></font>
                            y * glyphHeight + j).R);<font></font>
                    }<font></font>
<font></font>
                    result[glyphWidth * j + i, charNumHor * y + x] = color;<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
    result = result.NormalizeColumns(<span class="hljs-number">2.0</span>);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> result;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2）行列に</font></font><img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0から1までのランダムな値を入力します：</font></font><br>
<br>
<pre><code class="cs hljs">Matrix&lt;<span class="hljs-keyword">double</span>&gt; h = Matrix&lt;<span class="hljs-keyword">double</span>&gt;.Build.Random(<font></font>
    glyphSetSize, <font></font>
    totalCharactersNumber, <font></font>
    <span class="hljs-keyword">new</span> ContinuousUniform());
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更新ルールをその要素に指定された回数適用します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">ushort</span> i = <span class="hljs-number">0</span>; i &lt; iterationsCount; i++)<font></font>
{<font></font>
    UpdateH(v, wNorm, h, beta, threadsNumber);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>((i + <span class="hljs-number">1</span>) % step == <span class="hljs-number">0</span>)<font></font>
    {<font></font>
        progress += <span class="hljs-number">10</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(progress &lt; <span class="hljs-number">100</span>)<font></font>
        {<font></font>
            ProgressUpdated(progress);<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マトリックス要素の直接更新は次のように実装されます（残念ながら、ゼロによる除算に関連する問題は、いくつかの松葉杖を使用して解決されます）。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateH</span>(<span class="hljs-params">
    Matrix&lt;<span class="hljs-keyword">double</span>&gt; v, 
    Matrix&lt;<span class="hljs-keyword">double</span>&gt; w, 
    Matrix&lt;<span class="hljs-keyword">double</span>&gt; h, 
    <span class="hljs-keyword">double</span> beta,
    <span class="hljs-keyword">ushort</span> threadsNumber</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> epsilon = <span class="hljs-number">1e-6</span>;<font></font>
    Matrix&lt;<span class="hljs-keyword">double</span>&gt; vApprox = w.Multiply(h);<font></font>
<font></font>
    Parallel.For(<font></font>
        <span class="hljs-number">0</span>, <font></font>
        h.RowCount, <font></font>
        <span class="hljs-keyword">new</span> ParallelOptions() { MaxDegreeOfParallelism = threadsNumber }, <font></font>
        j =&gt;<font></font>
        {<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; h.ColumnCount; k++)<font></font>
            {<font></font>
                <span class="hljs-keyword">double</span> numerator = <span class="hljs-number">0.0</span>;
                <span class="hljs-keyword">double</span> denominator = <span class="hljs-number">0.0</span>;<font></font>
<font></font>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; w.RowCount; i++)<font></font>
                {<font></font>
                    <span class="hljs-keyword">if</span> (Math.Abs(vApprox[i, k]) &gt; epsilon)<font></font>
                    {<font></font>
                        numerator += <font></font>
                            w[i, j] * v[i, k] / Math.Pow(vApprox[i, k], <span class="hljs-number">2.0</span> - beta);<font></font>
                        denominator += <font></font>
                            w[i, j] * Math.Pow(vApprox[i, k], beta - <span class="hljs-number">1.0</span>);<font></font>
                    }<font></font>
                    <span class="hljs-keyword">else</span><font></font>
                    {<font></font>
                        numerator += w[i, j] * v[i, k];<font></font>
<font></font>
                        <span class="hljs-keyword">if</span> (beta - <span class="hljs-number">1.0</span> &gt; <span class="hljs-number">0.0</span>)<font></font>
                        {<font></font>
                            denominator += <font></font>
                                w[i, j] * Math.Pow(vApprox[i, k], beta - <span class="hljs-number">1.0</span>);<font></font>
                        }<font></font>
                        <span class="hljs-keyword">else</span><font></font>
                        {<font></font>
                            denominator += w[i, j];<font></font>
                        }<font></font>
                    }<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (Math.Abs(denominator) &gt; epsilon)<font></font>
                {<font></font>
                    h[j, k] = h[j, k] * numerator / denominator;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span><font></font>
                {<font></font>
                    h[j, k] = h[j, k] * numerator;<font></font>
                }<font></font>
            }<font></font>
        });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3）最後のステップは、行列の列の最大値を見つけることにより、各画像セクションに適切なシンボルを選択することです</font></font><img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[,] GetAsciiRepresentation(<font></font>
    Matrix&lt;<span class="hljs-keyword">double</span>&gt; h, 
    <span class="hljs-keyword">int</span> charNumVert, 
    <span class="hljs-keyword">int</span> charNumHor, 
    <span class="hljs-keyword">double</span> threshold)<font></font>
{<font></font>
    <span class="hljs-keyword">char</span>[,] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[charNumVert, charNumHor];<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; h.ColumnCount; j++)<font></font>
    {<font></font>
        <span class="hljs-keyword">double</span> max = <span class="hljs-number">0.0</span>;
        <span class="hljs-keyword">int</span> maxIndex = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; h.RowCount; i++)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (max &lt; h[i, j])<font></font>
            {<font></font>
                max = h[i, j];<font></font>
                maxIndex = i;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        result[j / charNumHor, j % charNumHor] =<font></font>
            (max &gt;= threshold) ? (<span class="hljs-keyword">char</span>)(firstGlyphCode + maxIndex) : <span class="hljs-string">' '</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> result;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果の画像はhtmlファイルに書き込まれます。</font><font style="vertical-align: inherit;">プログラムの完全なソースコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成された画像の例</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、さまざまなパラメーター値</font></font><img src="https://habrastorage.org/getpro/habr/post_images/818/11b/0b2/81811b0b26d4b7e534b439a41d4eb61f.svg" alt="\ベータ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と反復回数</font><font style="vertical-align: inherit;">に対して生成された画像の例です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">元の画像のサイズはそれぞれ407x500ピクセルで、結果の画像のサイズは37x22文字でした。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/t-/ah/4s/t-ah4s39lekdubpaxzd_jj8zhte.png" width="600"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検討中のアルゴリズムでは、次の欠点を区別できます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長い画像処理：画像のサイズと反復回数に応じて、その処理には数十秒から数十分かかることがあります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">詳細な画像の質の悪い処理。</font><font style="vertical-align: inherit;">たとえば、人間の顔の画像を変換しようとすると、次のような結果になります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/uh/mx/9c/uhmx9cl4ccuqhzhh1sydlp6ieai.png" width="600"></div></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、画像の明るさとコントラストを増やしてパーツ数を減らすと、結果の画像の外観を大幅に改善できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/l4/qs/qo/l4qsqozovwtwlkdw_ajn_wpbueq.png" width="600"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、これらの欠点にもかかわらず、アルゴリズムは満足のいく結果をもたらすと結論付けることができます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja463179/index.html">ビッグデータビッグビリング：テレコムのビッグデータについて</a></li>
<li><a href="../ja463181/index.html">figma-デザイナーにとってはシンプルなソリューション、レイアウトデザイナーにとっては難しいソリューション</a></li>
<li><a href="../ja463183/index.html">Cisco 200-125 CCNA v3.0のトレーニング。13日目。VLANを構成する</a></li>
<li><a href="../ja463185/index.html">ボリビアの地震が地下660キロの深さで山を発見した方法</a></li>
<li><a href="../ja463189/index.html">インターネット上の匿名性、生活とその相対性について</a></li>
<li><a href="../ja463195/index.html">Tele2インターネットはどうなりますか</a></li>
<li><a href="../ja463197/index.html">Blazor + MVVM = Silverlightが反撃し、古代の悪は無敵です</a></li>
<li><a href="../ja463203/index.html">時間の重い負担。Yandexは時間を扱う際の一般的な間違いについて報告しています</a></li>
<li><a href="../ja463205/index.html">最初は動作しない：Windows 10のラップトップと32ギガバイトのドライブで生き残る方法</a></li>
<li><a href="../ja463207/index.html">チャットボットの開発（電報+ YouTube）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>