<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧‍👦 👩‍❤️‍💋‍👨 🙌🏿 メッセージブローカーについて理解する。ActiveMQとKafkaを介してメッセージングのメカニズムを学ぶ。第3章カフカ 🚷 ⏭️ 🌮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="小さな本の翻訳の続き：
 「Understanding Message Brokers」、
 著者：Jakub Korab、出版社：O'Reilly Media、Inc.、発行日：2017年6月、ISBN：9781492049296。
 
 翻訳者：tele.gg/middle_java
 
 前の...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>メッセージブローカーについて理解する。ActiveMQとKafkaを介してメッセージングのメカニズムを学ぶ。第3章カフカ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466585/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小さな本の翻訳の続き：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「Understanding Message Brokers」、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
著者：Jakub Korab、出版社：O'Reilly Media、Inc.、発行日：2017年6月、ISBN：9781492049296。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳者：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tele.gg/middle_java</font></font></a></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
前のパート：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージブローカーについて。</font><font style="vertical-align: inherit;">ActiveMQとKafkaを介してメッセージングのメカニズムを学ぶ。</font><font style="vertical-align: inherit;">第2章ActiveMQ</font></font></a><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第3章</font></font></h2><br>
 <h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カフカ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafkaは、従来のメッセージブローカーの制限の一部を回避し、さまざまなポイントツーポイントインタラクション用に複数のメッセージブローカーを構成する必要を回避するためにLinkedInで開発されました。 LinkedInは主に、ページやアクセスログのクリックなど、非常に大量のデータの一方向の吸収に依存していると同時に、プロデューサーや他のコンシューマーのパフォーマンスに影響を与えることなく、このデータを複数のシステムで使用できるようにしています。</font><font style="vertical-align: inherit;">実際、Kafkaが存在する理由は、Universal Data Pipelineが説明するメッセージングアーキテクチャを取得するためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この最終的な目標を考えると、他の要件が自然に発生しました。</font><font style="vertical-align: inherit;">カフカは：</font></font><br>
<br>
<ul>
<li>  </li>
<li>       </li>
<li>  «-»  «-»</li>
<li>    . ,   ,    ActiveMQ       </li>
<li>  ;   ,  (persists) ,        ,            </li>
<li>       </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべてを実現するために、Kafkaは、クライアントとメッセージングブローカーの役割と責任を再定義するアーキテクチャを採用しています。 JMSモデルはブローカーに非常に重点を置いています。ブローカーはメッセージの配信を担当し、顧客はメッセージの送受信についてのみ心配する必要があります。一方、カフカは顧客指向であり、クライアントは、非常に高速でスケーラブルなブローカーを受け取る代わりに、コンシューマー間での関連メッセージの公平な分配など、従来のブローカーの多くの機能を引き受けます。従来のメッセージングシステムを使用している人にとって、Kafkaを使用するには、態度を根本的に変える必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このエンジニアリングの方向性により、従来のブローカーと比較して桁違いにスループットを向上させることができるメッセージングインフラストラクチャが作成されました。</font><font style="vertical-align: inherit;">後で説明するように、このアプローチには妥協が伴います。つまり、Kafkaは特定のタイプのロードおよびインストールされたソフトウェアには適していません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">統合宛先モデル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の要件を満たすために、Kafkaはパブリケーションサブスクリプションとポイントツーポイントメッセージングを1つのタイプの宛先- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トピックに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">組み合わせました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、メッセージングシステムで作業している人々を混乱させるものです。「トピック」という言葉は、（トピックからの）読み取りが信頼できない（永続的ではない）ブロードキャストメカニズムを指します。</font><font style="vertical-align: inherit;">この本の概要で定義されているように、Kafkaトピックは、宛先のハイブリッドタイプと見なされます。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この章の残りの部分では、特に明記しない限り、トピックという用語はKafkaトピックを指します。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トピックの動作とトピックが提供する保証を完全に理解するには、まずトピックがKafkaでどのように実装されるかを検討する必要があります。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カフカの各トピックには独自の雑誌があります。</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafkaにメッセージを送信するプロデューサーはこの雑誌に追加し、消費者は常に前進するポインターを使用して雑誌から読みます。</font><font style="vertical-align: inherit;">Kafkaは、これらの部分のメッセージが読み取られたかどうかに関係なく、ジャーナルの最も古い部分を定期的に削除します。</font><font style="vertical-align: inherit;">Kafkaの設計の中心的な部分は、ブローカーがメッセージが読み取られるかどうかを気にしないことです。これはクライアントの責任です。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ジャーナル」および「インデックス」という用語は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafkaのドキュメントに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はありません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらのよく知られた用語は、理解を助けるためにここで使用されています。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このモデルはActiveMQとは完全に異なります。ActiveMQでは、すべてのキューからのメッセージが1つのジャーナルに保存され、ブローカーはメッセージが読み取られた後にメッセージを削除済みとしてマークします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、もう少し詳しく見て、トピックマガジンを詳しく見てみましょう。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafka Magazineは、いくつかのパーティションで構成されてい</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">図3-1</font></a><font style="vertical-align: inherit;">）。 Kafkaは、すべてのパーティションで厳密な順序を保証します。つまり、特定の順序でパーティションに書き込まれたメッセージは、同じ順序で読み取られます。各パーティションは、</font><i><font style="vertical-align: inherit;">サブセット</font></i><font style="vertical-align: inherit;">を含むローリング（ログ）ログファイルとして実装されます</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロデューサによってトピックに送信されたすべてのメッセージの（サブセット）。</font><font style="vertical-align: inherit;">作成されたトピックには、デフォルトで1つのパーティションが含まれています。</font><font style="vertical-align: inherit;">パーティション分割は、水平スケーリングに関するKafkaの中心的な考え方です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tm/w2/yf/tmw2yf3lanppqtrumxoidotplhi.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3-1。</font><font style="vertical-align: inherit;">Kafkaパーティション</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
プロデューサーは、Kafkaトピックにメッセージを送信するときに、メッセージを送信するパーティションを決定します。</font><font style="vertical-align: inherit;">これについては、後で詳しく検討します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージを読む</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージを読みたいクライアントは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンシューマーグループ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれる名前付きポインターを制御します</font><font style="vertical-align: inherit;">。これは</font><font style="vertical-align: inherit;">、パーティション内のメッセージ</font><font style="vertical-align: inherit;">の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オフセット</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を示し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">オフセットは、パーティションの先頭の0から始まる番号が増加する位置です。</font><font style="vertical-align: inherit;">APIでユーザー定義の識別子group_idを介して参照されるこのコンシューマーのグループは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つの論理的なコンシューマーまたはシステムに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">対応し</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどのメッセージングシステムは、複数のインスタンスとスレッドを介して受信者からデータを読み取り、メッセージを並列処理します。</font><font style="vertical-align: inherit;">したがって、通常、同じグループの消費者を共有する消費者のインスタンスが多数存在します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読み取りの問題は次のように表すことができます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トピックにはいくつかのパーティションがあります</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数のグループの消費者が同時にトピックを使用できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消費者グループには、いくつかの個別のインスタンスがある場合があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、重要な多対多の問題です。</font><font style="vertical-align: inherit;">Kafkaがコンシューマーのグループ、コンシューマーのインスタンス、およびパーティション間の関係をどのように処理するかを理解するために、ますます複雑になる一連の読み取りスクリプトを見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消費者と消費者グループ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単一パーティションのトピックを出発点として考えてみましょう（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3-2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6z/tz/dh/6ztzdhqmjweck-z15htxb2xbe28.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3-2。コンシューマーがパーティションから読み取る</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コンシューマーインスタンスが独自のgroup_idでこのトピックに接続すると、読み取るパーティションとこのパーティション内のオフセットが割り当てられます。このオフセットの位置は、最新の位置（最新のメッセージ）または最も古い位置（最も古いメッセージ）へのポインターとしてクライアントで構成されます。コンシューマーはトピックからのメッセージを要求（ポーリング）します。これにより、ジャーナルからの順次読み取りが行われます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オフセット位置は定期的にKafkaにコミットされ、内部トピック</font><i><font style="vertical-align: inherit;">_consumer_offsetsに</font></i><font style="vertical-align: inherit;">メッセージとして保存されます</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">通常のブローカーとは異なり、読み取りメッセージはまだ削除されません。クライアントは、すでに表示されたメッセージを再処理するためにオフセットを巻き戻すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の論理コンシューマーが別のgroup_idを使用して接続されている場合、2番目のコンシューマーは、最初のコンシューマーから独立した2番目のポインターを制御します（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3-3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">したがって、Kafkaトピックは、1つのコンシューマーが存在するキューとして機能し、通常のトピックとして、複数のコンシューマーがサブスクライブするパブリッシャーサブスクライバー（pub-sub）として機能します。さらに、すべてのメッセージが保存され、何度も処理できるという利点もあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qe/v1/yk/qev1yktga3s-g1gqlynylbe3n9w.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3-3。</font><font style="vertical-align: inherit;">異なるコンシューマーグループの2つのコンシューマーが同じパーティションから読み取る</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消費者グループの消費者</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前のセクションで説明したように、コンシューマーの1つのインスタンスがパーティションからデータを読み取ると、ポインターが完全に制御され、メッセージが処理されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンシューマの複数のインスタンスが1つのパーティションを持つトピックに同じgroup_idで接続されている場合、最後に接続されたインスタンスがポインタを制御し、それ以降はすべてのメッセージを受信します（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3-4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0j/ao/f2/0jaof2mdwg3cqvmwemhtxkrltuq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3-4。同じコンシューマーのグループ内の2つのコンシューマーが同じパーティションから読み取る</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この処理モードでは、コンシューマのインスタンスの数がパーティションの数を超えているため、一種の独占コンシューマと見なすことができます。</font><font style="vertical-align: inherit;">これは、コンシューマのインスタンスの「アクティブ-パッシブ」（または「ホット-ウォーム」）クラスタリングが必要な場合に役立ちますが、複数のコンシューマ（「アクティブ-アクティブ」または「ホット-ホット」）の並列操作はコンシューマよりもはるかに一般的ですスタンバイ中。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記のこのメッセージ配信動作は、通常のJMSキューの動作と比較すると驚くべきものです。</font><font style="vertical-align: inherit;">このモデルでは、キューに送信されたメッセージは2つのコンシューマー間で均等に分散されます。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、コンパイラーの複数のインスタンスを作成するとき、メッセージの並列処理のため、または読み取り速度を上げるため、または読み取りプロセスの安定性を高めるためにこれを行います。コンシューマーの1つのインスタンスのみがパーティションからデータを読み取ることができるので、Kafkaでこれをどのように実現しますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行う1つの方法は、コンシューマーの1つのインスタンスを使用してすべてのメッセージを読み取り、スレッドプールに送信することです。このアプローチは処理スループットを向上させますが、コンシューマロジックの複雑さを増加させ、読み取りシステムの安定性を向上させることはありません。停電または同様のイベントによりコンシューマの1つのインスタンスが切断されると、校正は停止します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafkaでこの問題を解決する標準的な方法は、</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パーティション数の増加</font><i><font style="vertical-align: inherit;">について</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パーティショニング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーティションは、ブローカーの1つのインスタンスの帯域幅を超えてトピックの読み取りとスケーリングを並列化するための主要なメカニズムです。これをよりよく理解するために、2つのパーティションを持つトピックがあり、1つのコンシューマがこのトピックにサブスクライブする状況を見てみましょう（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3-5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/en/9g/ct/en9gct0o017cqp8buawguwlscty.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3-5。 1つのコンシューマーが複数のパーティションから読み取ります。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このシナリオでは、コンシューマーには、両方のパーティションで彼のgroup_idに対応するポインターに対する制御が与えられ、両方のパーティションからメッセージの読み取りが開始されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じgroup_idのこのトピックに追加のCompuratorが追加されると、Kafkaは最初のパーティションから2番目のパーティションに1つのパーティションを再割り当て（再割り当て）します。その後、コンシューマの各インスタンスがトピックの1つのパーティションから差し引かれます（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3-6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージが20スレッドで並列処理されるようにするには、少なくとも20のパーティションが必要です。</font><font style="vertical-align: inherit;">パーティションの数が少ない場合でも、先に排他的モニターの説明で説明したように、何もする必要のないコンシューマーがいます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8b/a0/um/8ba0umn2yzr9yy3vztonhdfiub0.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3-6。</font><font style="vertical-align: inherit;">同じコンシューマーグループ内の2つのコンシューマーは、異なるパーティションから読み取ります。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このスキームにより、JMSキューをサポートするために必要なメッセージ分散と比較して、Kafkaブローカーの複雑さが大幅に軽減されます。</font><font style="vertical-align: inherit;">次の点に注意する必要はありません。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラウンドロビン分散、現在のプリフェッチバッファ容量、または前のメッセージ（JMSメッセージグループの場合）に基づいて、次のメッセージを受信するコンシューマ。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのコンシューマにどのメッセージが送信されたか、および障害発生時に再送信する必要があるか。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafkaブローカーがすべきことは、アドバイザーが要求したときに常にアドバイザーにメッセージを送信することだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、校正と失敗したメッセージの再送信を並列化するための要件は消えていません。それらに対する責任はブローカーからクライアントに渡されるだけです。</font><font style="vertical-align: inherit;">つまり、それらをコードに組み込む必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージを送信する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージを送信するパーティションを決定する責任は、メッセージのプロデューサーです。これが行われるメカニズムを理解するには、まず、実際に送信する内容を正確に検討する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JMSでは、メタデータ（ヘッダーとプロパティ）とペイロードを含む本文を持つメッセージ構造を使用しますが、Kafkaでは、メッセージは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーと値のペア</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。メッセージのペイロードは値として送信されます。一方、キーは主にパーティション化に使用され、</font><font style="vertical-align: inherit;">関連するメッセージを同じパーティションに入れる</font><font style="vertical-align: inherit;">ための</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジネスロジック固有のキー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">含む必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第2章では、関連するイベントを1人の消費者が順番に処理する必要がある場合のオンライン賭博シナリオについて説明しました。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーアカウントが構成されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お金は口座に入金されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アカウントからお金を引き出す賭けが行われます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各イベントがトピックに送信されるメッセージである場合、この場合、アカウント識別子が自然なキーになります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafka Producer APIを使用してメッセージが送信されると、メッセージはパーティション関数に渡され、メッセージとKafkaクラスターの現在の状態が与えられると、メッセージの送信先のパーティションの識別子が返されます。</font><font style="vertical-align: inherit;">この関数は、Partitionerインターフェースを介してJavaで実装されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このインターフェースは次のとおりです。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Partitioner</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(String topic,
        Object key, <span class="hljs-keyword">byte</span>[] keyBytes, Object value, <span class="hljs-keyword">byte</span>[] valueBytes, Cluster cluster)</span></span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Partitionerの実装では、パーティションを決定するためにキーが指定されていない場合、キーまたはラウンドロビンに対してデフォルトの汎用ハッシュアルゴリズムが使用されます。</font><font style="vertical-align: inherit;">ほとんどの場合、このデフォルト値は適切に機能します。</font><font style="vertical-align: inherit;">ただし、将来的には独自に作成する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独自のパーティショニング戦略を作成する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージペイロードと共にメタデータを送信する場合の例を見てみましょう。この例のペイロードは、ゲームアカウントに入金するための命令です。命令は、送信中に変更されないことを保証したいものであり、信頼できる上位システムのみがこの命令を開始できることを確認したい。この場合、送信システムと受信システムは、署名を使用してメッセージを認証することに同意します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のJMSでは、メッセージ署名プロパティを定義してメッセージに追加するだけです。ただし、Kafkaはメタデータを送信するメカニズムを提供しません。キーと値のみです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値は銀行振込のペイロード（銀行振込ペイロード）であり、その整合性を維持したいので、キーで使用するデータ構造を決定するしかありません。</font><font style="vertical-align: inherit;">パーティション分割にアカウント識別子が必要であると仮定すると、アカウントに関連するすべてのメッセージが順番に処理される必要があるため、次のJSON構造が考えられます。</font></font><br>
<br>
<pre><code class="json hljs">{
  <span class="hljs-attr">"signature"</span>: <span class="hljs-string">"541661622185851c248b41bf0cea7ad0"</span>,
  <span class="hljs-attr">"accountId"</span>: <span class="hljs-string">"10007865234"</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
署名の値はペイロードによって異なるため、デフォルトのPartitionerインターフェースのハッシュ戦略では、関連するメッセージを確実にグループ化できません。</font><font style="vertical-align: inherit;">したがって、このキーを分析してaccountIdの値を共有する独自の戦略を作成する必要があります。</font></font><br>
<blockquote>Kafka               .          ,    .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーのパーティション分割戦略では、関連するすべてのメッセージが同じパーティションに配置されるようにする必要があります。これは単純なように見えますが、関連するメッセージの順序付けの重要性と、このトピックではパーティション数の修正方法が原因で、要件が複雑になる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トピックのパーティションの数は、トラフィックが最初の予想を超えた場合に追加される可能性があるため、時間の経過とともに変化する可能性があります。したがって、メッセージキーは、最初に送信されたパーティションに関連付けることができます。これは、プロデューサーインスタンス間で配布する必要がある状態の一部を意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考慮すべきもう1つの要素は、パーティション間のメッセージの均一な分散です。原則として、キーはメッセージ全体に均等に分散されておらず、ハッシュ関数は、少数のキーのセットに対するメッセージの公平な分散を保証しません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージをどのように分割するかに関係なく、セパレーター自体を再利用する必要がある場合があることに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
地理的に異なる場所にあるKafkaクラスター間のデータ複製の要件を検討してください。この目的のために、KafkaにはMirrorMakerと呼ばれるコマンドラインツールが付属しています。これは、あるクラスターからメッセージを読み取り、それらを別のクラスターに転送するために使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このトピックのパーティション数は2つのクラスターで一致しない可能性があるため、MirrorMakerは、クラスター間のレプリケーション中にメッセージ間の相対的な順序を維持するために、レプリケーショントピックのキーを理解する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどのシナリオではデフォルトのハッシュまたはラウンドロビンが正常に機能するため、カスタムのパーティション分割戦略は比較的まれです。ただし、順序付けを厳密に保証する必要がある場合、またはペイロードからメタデータを抽出する必要がある場合は、パーティション分割をよく検討する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafkaのスケーラビリティとパフォーマンスの利点は、従来のブローカーの責任の一部をクライアントに移すことから得られます。</font><font style="vertical-align: inherit;">この場合、並行して作業している複数のコンシューマ間で潜在的に関連するメッセージの配信が決定されます。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JMSブローカーもこのような要件に対処する必要があります。</font><font style="vertical-align: inherit;">興味深いことに、JMSメッセージグループを介して実装された同じアカウントに関連メッセージを送信するメカニズム（一種のスティッキーロードバランシング（SLB）バランシング戦略）では、送信者がメッセージを関連としてマークする必要があります。</font><font style="vertical-align: inherit;">JMSの場合、ブローカーは、関連するメッセージのグループを多数の顧客の1つに送信し、顧客が落ちた場合にグループの所有権を転送する責任があります。</font></font></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロデューサー契約</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージを送信するときに考慮すべきことは、パーティション化だけではありません。 Java APIのProducerクラスのsend（）メソッドを見てみましょう。</font></font><br>
<br>
<pre><code class="java hljs">Future &lt; RecordMetadata &gt; send(ProducerRecord &lt; K, V &gt; record);<font></font>
Future &lt; RecordMetadata &gt; send(ProducerRecord &lt; K, V &gt; record, Callback callback);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どちらのメソッドもFutureを返すことにすぐに注意してください。これは、送信操作がすぐには実行されないことを示しています。</font><font style="vertical-align: inherit;">その結果、メッセージ（ProducerRecord）が各アクティブパーティションの送信バッファーに書き込まれ、Kafkaクライアントライブラリのバックグラウンドストリームでブローカーに送信されることがわかります。</font><font style="vertical-align: inherit;">これにより作業が信じられないほど高速になりますが、それは、経験の浅いアプリケーションがそのプロセスが停止した場合にメッセージを失う可能性があることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いつものように、パフォーマンスのために送信操作の信頼性を高める方法があります。</font><font style="vertical-align: inherit;">このバッファーのサイズは0に設定でき、メッセージがブローカーに送信されるまで、送信アプリケーションのスレッドは次のように強制的に待機されます。</font></font><br>
<br>
<pre><code class="java hljs">RecordMetadata metadata = producer.send(record).get();</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージを読むことについてもう一度</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージの読み取りには、考慮する必要がある追加の困難があります。メッセージに応答してメッセージリスナーを開始できるJMS APIとは異なり、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consumer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kafka </font><font style="vertical-align: inherit;">インターフェイス</font><font style="vertical-align: inherit;">はポーリングのみを行い</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この目的で使用される</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">poll（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドを詳しく見てみましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="java hljs">ConsumerRecords &lt; K, V &gt; poll(<span class="hljs-keyword">long</span> timeout);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドの戻り値は、</font><font style="vertical-align: inherit;">潜在的に複数のパーティションからの</font><font style="vertical-align: inherit;">複数の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConsumerRecord</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトを含むコンテナ構造</font><font style="vertical-align: inherit;">です。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConsumerRecord</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自体は、派生元のパーティションなど、関連するメタデータを持つキーと値のペアのホルダーオブジェクトです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第2章で説明したように、たとえば、クライアントがメッセージを処理できない場合や、作業を中断した場合など、メッセージの処理が成功または失敗した後のメッセージに常に何が起こるかを覚えておく必要があります。 JMSでは、これは確認応答モードで処理されていました。ブローカーは、正常に処理されたメッセージを削除するか、（トランザクションが使用されている場合）生のメッセージまたは反転したメッセージを再配信します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafkaはまったく異なる方法で機能します。</font><font style="vertical-align: inherit;">校正後のメッセージはブローカーで削除されず、失敗時に何が起こるかはコード自体にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに述べたように、消費者のグループは雑誌のオフセットに関連付けられています。</font><font style="vertical-align: inherit;">このバイアスに関連するログの位置は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">poll（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に応答して発行される次のメッセージに対応しています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">読み取りで重要なのは、このオフセットが増加する時点です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述の読み取りモデルに戻ると、メッセージ処理は3つの段階で構成されています。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読むメッセージを取得します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージを処理します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージを確認します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafkaコンシューマーには、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enable.auto.commit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成</font><i><font style="vertical-align: inherit;">オプション</font></i><font style="vertical-align: inherit;">が付属してい</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。これは、「自動」という単語を含む設定の場合と同様に、一般的に使用されるデフォルト設定です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafka 0.10より前のバージョンでは、このパラメーターを使用するクライアントは、</font><font style="vertical-align: inherit;">処理後の</font><font style="vertical-align: inherit;">次の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">poll（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しで最後の読み取りメッセージのオフセットを送信していました</font><font style="vertical-align: inherit;">。これは、すでにフェッチされたメッセージは、クライアントがすでに処理していた場合は再処理できるが、</font><i><font style="vertical-align: inherit;">poll（）を</font></i><font style="vertical-align: inherit;">呼び出す前に予期せず破棄されたことを意味します</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ブローカーはメッセージが読み取られた回数に関するステータスを保存しないため、このメッセージを取得する次のコンシューマーは、何か問題が発生したことを知りません。この動作は疑似トランザクションでした。オフセットは、メッセージの処理が成功した場合にのみコミットされましたが、クライアントが中断した場合、ブローカーは再び同じメッセージを別のクライアントに送信しました。この動作は、「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少なくとも1回</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」の</font><font style="vertical-align: inherit;">メッセージ配信保証と一致していました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafka 0.10では、設定</font><i><font style="vertical-align: inherit;">auto.commit.interval.ms</font></i><font style="vertical-align: inherit;">に従って、クライアントライブラリによって定期的にコミットが開始されるようにクライアントコードが変更され</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この動作は、JMS AUTO_ACKNOWLEDGEモードとDUPS_OK_ACKNOWLEDGEモードの間のどこかにあります。自動コミットを使用すると、メッセージが実際に処理されたかどうかに関係なくメッセージを確認できます。これは、コンシューマが遅い場合に発生する可能性があります。 Compuratorが中断された場合、メッセージは次のCompuratorによって保護された位置から取得されるため、メッセージがスキップされる可能性があります。この場合、Kafkaはメッセージを失いませんでした。読み取りコードは単にメッセージを処理しませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このモードはバージョン0.9と同じ見通しを持っています。メッセージは処理できますが、障害が発生した場合、オフセットが閉じられない可能性があり、配信の重複につながる可能性があります。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">poll（）を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行するときに取得するメッセージが</font><font style="vertical-align: inherit;">多いほど、この問題は大きくなります。</font></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第2章の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
「キューからのメッセージの減算」</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">セクション</font></a><font style="vertical-align: inherit;">で説明した</font><font style="vertical-align: inherit;">ように、障害モードが与えられた場合、メッセージングシステムには1回限りのメッセージ配信などはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafkaでは、オフセット（オフセット）を修正（コミット）する方法として、自動と手動の2つがあります。</font><font style="vertical-align: inherit;">どちらの場合も、メッセージは処理されたがコミット前に失敗した場合は、メッセージを数回処理できます。</font><font style="vertical-align: inherit;">コミットがバックグラウンドで発生し、コードが処理を開始する前に完了した場合（おそらくKafka 0.9以前のバージョン）、メッセージをまったく処理できません。</font><i><font style="vertical-align: inherit;">enable.auto.commit</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を設定することにより、Kafka </font><i><font style="vertical-align: inherit;">コンシューマー</font></i><font style="vertical-align: inherit;"> APIでオフセットを手動でコミットするプロセスを制御できます</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> falseにして、次のメソッドの1つを明示的に呼び出します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">commitSync</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">commitAsync</span><span class="hljs-params">()</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージを「少なくとも1回」</font><font style="vertical-align: inherit;">処理する場合は、メッセージを処理した直後にこのコマンドを実行</font><font style="vertical-align: inherit;">して、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commitSync（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して手動でオフセットをコミットする必要があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの方法では、メッセージを処理する前に確認応答することはできませんが、潜在的な処理の重複を排除することはできず、同時にトランザクション性の外観を作成します。</font><font style="vertical-align: inherit;">Kafkaにはトランザクションがありません。</font><font style="vertical-align: inherit;">クライアントは次のことを行う機会がありません。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロールバックメッセージを自動的にロールバックします。</font><font style="vertical-align: inherit;">メッセージの再配信をブローカーに依存できないため、コンシューマー自体が、問題のあるペイロードとバックエンドの切断から生じる例外を処理する必要があります。</font></font></li>
<li>         .    ,              Kafka,      .         ,       KIP-98.</li>
<li>             .  ,  Kafka     ,           . ,    API,     <i> </i> <i> </i> .  JMS    <i>Session</i>,    <i>MessageProducers </i> <i>MessageConsumers</i>.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トランザクションに依存できない場合、どのようにして従来のメッセージングシステムによって提供されるセマンティクスに近いセマンティクスを提供できますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顧客の障害時などに、メッセージが処理される前にコンシューマーのオフセットが増加する可能性がある場合、顧客は、パーティションを割り当てるときに顧客のグループがメッセージを通過したかどうかを確認する方法がありません。したがって、1つの戦略は、オフセットを前の位置に巻き戻すことです。 Kafka Consumer Advisor APIは、このために次のメソッドを提供します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">seek</span><span class="hljs-params">(TopicPartition partition, <span class="hljs-keyword">long</span> offset)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">seekToBeginning</span><span class="hljs-params">(Collection &lt; TopicPartition &gt; partitions)</span></span>;</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーク（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドを用いて使用することができる</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offsetsForTimesの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><i><font style="vertical-align: inherit;">（MAP &lt;TopicPartition、ロング&gt; timestampsToSearch）</font></i><font style="vertical-align: inherit;">過去のある特定の時点の状態に巻き戻します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暗黙的に、この方法を使用すると、以前に処理された一部のメッセージが読み取られて再度処理される可能性が非常に高くなります。これを回避するには、第4章で説明されているように、べき等読み取りを使用して、以前に表示されたメッセージを追跡し、重複を排除します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の方法として、メッセージの損失または重複が許容される場合は、コンシューマーのコードを単純にすることができます。ログイベントの処理、メトリック、クリックトラッキングなど、Kafkaが通常使用される使用シナリオを見ると、個々のメッセージの損失が周囲のアプリケーションに大きな影響を与える可能性は低いことがわかります。このような場合、デフォルト値で問題ありません。一方、アプリケーションが支払いを転送する必要がある場合は、個々のメッセージに注意する必要があります。それはすべて文脈に帰着します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
個人的な観察によると、メッセージの強度が増加すると、個々のメッセージの価値が減少します。大量のメッセージは、集約された形式で表示すると貴重になる傾向があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高可用性</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafkaの高可用性アプローチは、ActiveMQとは大きく異なります。</font><font style="vertical-align: inherit;">Kafkaは、ブローカーのすべてのインスタンスがメッセージを同時に受信および配信する、水平方向にスケーラブルなクラスターに基づいて開発されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafkaクラスターは、異なるサーバーで実行されているいくつかのブローカーインスタンスで構成されています。</font><font style="vertical-align: inherit;">Kafkaは、各ノードに専用のストレージがある従来のスタンドアロンハードウェアで動作するように設計されています。</font><font style="vertical-align: inherit;">複数の計算ノードが一時的な</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番目のストレージ間隔で</font><font style="vertical-align: inherit;">競合し、競合が発生する可能性があるため、ネットワークストレージ（SAN）の使用はお勧めしません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カフカは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常にオンです</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システム。多くの大規模なKafkaユーザーはクラスターを消滅させることはなく、ソフトウェアは常に再起動して更新を提供します。これは、メッセージとブローカー間の相互作用について、以前のバージョンとの互換性を保証することによって実現されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブローカーは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZooKeeper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバー</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">クラスターに</font></a><font style="vertical-align: inherit;">接続され</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。これは、特定の構成レジストリーとして機能し、各ブローカーの役割を調整するために使用されます。 ZooKeeper自体は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クォーラムを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">確立することによって情報の複製を通じて高可用性を提供する分散システムです</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的なケースでは、トピックは次のプロパティでKafkaクラスターに作成されます。</font></font><br>
<br>
<ul>
<li> .   ,  ,  ,      .</li>
<li> ()  ,           .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
調整にZooKeepersを使用して、Kafkaはクラスター内のブローカー間で新しいパーティションを公平に分散しようとしています。これは、コントローラーとして機能する1つのインスタンスによって行われます。</font><i><font style="vertical-align: inherit;">トピックの各パーティションの</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
実行時</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、</font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コントローラー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リーダー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（リーダー、マスター、リーダー）と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォロワー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（フォロワー、スレーブ、部下）</font><font style="vertical-align: inherit;">の役割をブローカーに割り当て</font><font style="vertical-align: inherit;">ます。このパーティションのリーダーとして機能するブローカーは、プロデューサーによって彼に送信されたすべてのメッセージを受信し、コンシューマーにメッセージを配信する責任があります。トピックパーティションにメッセージを送信すると、メッセージはこのパーティションのフォロワーとして機能するすべてのブローカーのノードに複製されます。パーティションのログを含む各ノードは、</font><i><font style="vertical-align: inherit;">レプリカ</font></i><font style="vertical-align: inherit;">と呼ばれ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ブローカーは、一部のパーティションのリーダーおよび他のパーティションのフォロワーとして機能できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リーダーによって保存されたすべてのメッセージを含むフォロワーは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期レプリカ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（同期状態のレプリカ</font><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">同期レプリカ</font></i><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。パーティションのリーダーとして機能しているブローカーが切断されている場合、このパーティションの更新または同期状態にあるブローカーは、リーダーの役割を引き受けることができます。これは信じられないほど持続可能な設計です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロデューサーの構成の一部は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acks</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータです</font><font style="vertical-align: inherit;">。これは、アプリケーションストリームが送信を続ける前に、メッセージの受信を確認する必要があるレプリカの数を決定し</font><font style="vertical-align: inherit;">ます</font><i><font style="vertical-align: inherit;">。0、1</font></i><font style="vertical-align: inherit;">、またはすべて。</font><i><font style="vertical-align: inherit;">すべてに</font></i><font style="vertical-align: inherit;">設定した場合</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その後、リーダーはメッセージを受信すると、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min.insync.replicas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トピック</font><i><font style="vertical-align: inherit;">設定</font></i><font style="vertical-align: inherit;">（デフォルトでは1）で</font><font style="vertical-align: inherit;">定義されたいくつかのレプリカ（自分自身を含む）からレコードの確認を受信するとすぐに、確認をプロデューサーに</font><i><font style="vertical-align: inherit;">送り返し</font></i><font style="vertical-align: inherit;">ます。メッセージを正常に複製できない場合、プロデューサーはアプリケーションの例外（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NotEnoughReplicas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NotEnoughReplicasAfterAppend</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">をスローします</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的な構成では、トピックは複製係数3（各リーダーに1つのリーダー、2つのフォロワー）と</font><i><font style="vertical-align: inherit;">min.insync.replicas</font></i><font style="vertical-align: inherit;">パラメーターで</font><i><font style="vertical-align: inherit;">作成され</font></i><font style="vertical-align: inherit;">ます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この場合、クラスターは、トピックパーティションを管理しているブローカーの1つを、クライアントアプリケーションに影響を与えずに切断できるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、パフォーマンスと信頼性の間ですでにおなじみの妥協点に戻ることができます。複製は、フォロワーからの確認（確認）の追加の待機時間が原因で発生します。ただし、並列で実行されるため、少なくとも3つのノードへのレプリケーションは、2つと同じパフォーマンスを発揮します（ネットワーク帯域幅の使用量の増加を無視）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このレプリケーションスキームを使用すると、Kafkaは</font><i><font style="vertical-align: inherit;">sync（）</font></i><font style="vertical-align: inherit;">操作を使用して各メッセージをディスクに物理的に書き込む必要を巧みに回避します</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。プロデューサーによって送信された各メッセージはパーティションログに書き込まれますが、第2章で説明したように、ファイルへの書き込みは最初にオペレーティングシステムのバッファーで実行されます。このメッセージがKafkaの別のインスタンスに複製され、そのメモリ内にある場合、リーダーが失われたことは、メッセージ自体が失われたことを意味するわけではありません。</font><i><font style="vertical-align: inherit;">同期（）</font></i></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
操作のオプトアウト</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafkaは、メモリに書き込むことができる速度でメッセージを受信できることを意味します。逆に、ディスクへのメモリのフラッシュを回避できる時間が長ければ長いほど良いです。このため、Kafkaブローカーが64 GB以上のメモリを割り当てることは珍しくありません。このメモリ使用量は、Kafkaの1つのインスタンスが、従来のメッセージブローカーよりも何千倍も速い速度で簡単に実行できることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafkaは、</font><i><font style="vertical-align: inherit;">sync（）</font></i><font style="vertical-align: inherit;">を使用するように構成することもできます</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージパッケージへ。 Kafkaのすべてがパッケージ指向であるため、実際には多くのユースケースで非常にうまく機能し、非常に強力な保証を必要とするユーザーにとって便利なツールです。 Kafkaの純粋なパフォーマンスのほとんどは、パケットとしてブローカーに送信されるメッセージと、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゼロコピー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作（1つのメモリ領域からにデータをコピーするタスクを実行しない操作を</font><font style="vertical-align: inherit;">使用して連続するブロックでブローカーから読み取られるという事実）に関連しています</font><font style="vertical-align: inherit;">別の）。後者は、パフォーマンスとリソースの点で大きなメリットであり、パーティション構成を定義する基本的なログデータ構造を使用することによってのみ可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kafkaクラスターでは、トピックパーティションを多数の個別のマシンで水平方向にスケーリングできるため、単一のKafkaブローカーを使用する場合よりもはるかに高いパフォーマンスが可能です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この章では、Kafkaアーキテクチャがクライアントとブローカー間の関係を再解釈して、通常のメッセージブローカーよりも何倍も高いスループットで、非常に堅牢なメッセージングパイプラインを提供する方法を検討しました。これを実現するために使用する機能について説明し、この機能を提供するアプリケーションのアーキテクチャを簡単に確認しました。次の章では、メッセージングアプリケーションが解決する必要のある一般的な問題を検討し、それらを解決するための戦略について説明します。この章の最後に、ユースケースへの適合性を評価できるように、メッセージングテクノロジー全般について話す方法の概要を示します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳完了：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tele.gg/middle_java</font></font></a></b><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">続き...</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja466575/index.html">PythonからDLLに2次元リストを渡す</a></li>
<li><a href="../ja466577/index.html">2人の生徒がiOSでゲームを作成した方法と、ゲームで獲得した金額</a></li>
<li><a href="../ja466579/index.html">テトリスのランダム化アルゴリズムの歴史</a></li>
<li><a href="../ja466581/index.html">量子ダーウィニズム：客観的現実を説明するアイデアが最初のテストに合格</a></li>
<li><a href="../ja466583/index.html">嘘発見器の簡単な歴史</a></li>
<li><a href="../ja466587/index.html">複数行のサイトのCSS変数とカラーテーマ</a></li>
<li><a href="../ja466591/index.html">CなしのMVC：アプリケーションアーキテクチャのSwiftUIは何が変更されますか？</a></li>
<li><a href="../ja466593/index.html">状況：ハイブリッドクラウドとIaaSの展望</a></li>
<li><a href="../ja466597/index.html">Mini AI Cup 4の2位の歴史：ペーパーIO</a></li>
<li><a href="../ja466599/index.html">音声認識を使用してキャプチャをバイパスする方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>