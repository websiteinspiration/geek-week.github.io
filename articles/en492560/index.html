<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚ù§Ô∏è‚Äçüë® üê§ üë∫ Simple hash table for GPU üßê üßùüèø üôéüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I posted on Github a new project called A Simple GPU Hash Table . 
 
 This is a simple hash table for the GPU, capable of processing hundreds of milli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Simple hash table for GPU</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/492560/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/m2/fd/e_/m2fde_n27bcwfhvj00ovkweqofm.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I posted on Github a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new project</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> called </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">A Simple GPU Hash Table</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a simple hash table for the GPU, capable of processing hundreds of millions of inserts per second. </font><font style="vertical-align: inherit;">On my laptop with an NVIDIA GTX 1060, the code inserts 64 million randomly generated key-value pairs in about 210 ms and removes 32 million pairs in about 64 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, the speed on the laptop is approximately 300 million inserts / sec and 500 million removals / sec. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The table is written in CUDA, although the same technique can be applied to HLSL or GLSL. </font><font style="vertical-align: inherit;">The implementation has several limitations that ensure high performance on the video card:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Only 32-bit keys and the same values ‚Äã‚Äãare processed.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The hash table has a fixed size.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this size should be equal to two in degree.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For keys and values, you need to reserve a simple delimiting marker (in the code above it is 0xffffffff).</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hash table without locks</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The hash table uses open addressing with </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linear sensing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , that is, it is just an array of key-value pairs that is stored in memory and has excellent cache performance. </font><font style="vertical-align: inherit;">This is not the case with chaining, which means looking for a pointer in a linked list. </font><font style="vertical-align: inherit;">A hash table is a simple array storing elements </font></font><code>KeyValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KeyValue</span>
{</span>
    <span class="hljs-keyword">uint32_t</span> key;
    <span class="hljs-keyword">uint32_t</span> value;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The size of the table is equal to two in power, and not a prime number, because to use pow2 / AND-mask, one quick instruction is enough, and the module operator is much slower. This is important in the case of linear sensing, since in a linear search in the table, the slot index must be wrapped in each slot. And as a result, the cost of the operation is added modulo in each slot. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The table stores only the key and value for each item, not the key hash. Since the table only stores 32-bit keys, the hash is calculated very quickly. The above code uses the Murmur3 hash, which performs only a few shifts, XORs, and multiplications.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The hash table uses a lock protection technique that does not depend on the memory placement order. Even if some write operations violate the order of other such operations, the hash table will still maintain the correct state. We will talk about this below. The technique works great with video cards in which thousands of threads compete. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keys and values ‚Äã‚Äãin the hash table are initialized to empty. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The code can be modified so that it can process both 64-bit keys and values. Keys require atomic read, write, and exchange operations (compare-and-swap). And values ‚Äã‚Äãrequire atomic read and write operations. Fortunately, in CUDA, read-write operations for 32- and 64-bit values ‚Äã‚Äãare atomic as long as they are naturally aligned (see </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), and modern video cards support 64-bit atomic operations of comparison with exchange. </font><font style="vertical-align: inherit;">Of course, when switching to 64 bits, performance will decrease slightly.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hash Table Status</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each key-value pair in a hash table can have one of four states:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The key and meaning is empty. </font><font style="vertical-align: inherit;">In this state, the hash table is initialized.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The key has been recorded, but the value is not yet. </font><font style="vertical-align: inherit;">If another thread of execution is reading data at that moment, then it returns an empty value. </font><font style="vertical-align: inherit;">This is normal, the same thing would happen if another thread of execution worked a little earlier, and we are talking about a competitive data structure.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both the key and the value are recorded.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The value is available for other threads of execution, but the key is not yet. </font><font style="vertical-align: inherit;">This can happen because the CUDA programming model implies a poorly ordered memory model. </font><font style="vertical-align: inherit;">This is normal; in any event, the key is still empty, even if the value is no longer such.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An important nuance is that as soon as the key has been written to the slot, it no longer moves - even if the key is deleted, we will talk about this below. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The hash table code even works with poorly ordered memory models that do not know the order of reading and writing to memory. </font><font style="vertical-align: inherit;">When we analyze the insert, search and delete in the hash table, remember that each key-value pair is in one of the four states described above.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insert into a hash table</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A CUDA function that inserts key-value pairs into a hash table looks like this:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">uint32_t</span> prev = atomicCAS(&amp;hashtable[slot].key, kEmpty, key);
        <span class="hljs-keyword">if</span> (prev == kEmpty || prev == key)<font></font>
        {<font></font>
            hashtable[slot].value = value;<font></font>
            <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity<span class="hljs-number">-1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To insert a key, the code iterates over the hash table array starting with the hash of the inserted key. In each slot of the array, an atomic comparison operation is performed with the exchange, in which the key in this slot is compared with an empty one. If a mismatch is detected, the key in the slot is updated to the inserted key, and then the original key of the slot is returned. If this original key was empty or corresponded to the inserted key, then the code found a slot suitable for insertion and brings the inserted value into the slot. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If in one kernel call</font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are several elements with the same key, then any of their values ‚Äã‚Äãcan be written to the key slot. </font><font style="vertical-align: inherit;">This is considered normal: one of the key-value write operations during the call will be successful, but since all this happens in parallel within several threads of execution, we cannot predict which write operation to memory will be the last.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hash Table Search</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Key Finder Code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">gpu_hashtable_lookup</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key)</span>
</span>{
        <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> hashtable[slot].value;<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> kEmpty;<font></font>
            }<font></font>
            slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To find the value of the key stored in the table, we iterate over the array starting with the hash of the desired key. </font><font style="vertical-align: inherit;">In each slot, we check whether the key is the one we are looking for, and if so, then return its value. </font><font style="vertical-align: inherit;">We also check if the key is empty, and if so, we interrupt the search. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we cannot find the key, then the code returns an empty value. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All of these search operations can be performed competitively during insertions and deletions. </font><font style="vertical-align: inherit;">Each pair in the table will have one of the four states described above for the stream.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hash table deletion</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Key Removal Code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_delete</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
        {<font></font>
            hashtable[slot].value = kEmpty;<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Removing a key is unusual: we leave the key in the table and mark its value (not the key itself) empty. </font><font style="vertical-align: inherit;">This code is very similar to </font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, except that when a match is found for the key, it makes its value empty. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As mentioned above, once the key is written to the slot, it no longer moves. </font><font style="vertical-align: inherit;">Even when you delete an item from the table, the key remains in place, just its value becomes empty. </font><font style="vertical-align: inherit;">This means that we do not need to use the atomic operation of writing the value of the slot, because it does not matter whether the current value is empty or not - it will still become empty.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resize a hash table</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can resize the hash table by creating a larger table and inserting non-empty elements from the old table into it. </font><font style="vertical-align: inherit;">I did not implement this functionality because I wanted to keep the sample code simple. </font><font style="vertical-align: inherit;">Moreover, in CUDA programs, memory allocation is often done in the host code, and not in the CUDA core. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Lock-Free Wait-Free Hash Table</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> article </font><font style="vertical-align: inherit;">describes how to change such a lock-protected data structure.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Competitiveness</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the above code snippets, the functions </font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">process one key-value pair at a time. </font><font style="vertical-align: inherit;">And below </font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">they </font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">process an array of pairs in parallel, each pair in a separate GPU thread of execution:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// CPU code to invoke the CUDA kernel on the GPU</span>
<span class="hljs-keyword">uint32_t</span> threadblocksize = <span class="hljs-number">1024</span>;
<span class="hljs-keyword">uint32_t</span> gridsize = (numkvs + threadblocksize - <span class="hljs-number">1</span>) / threadblocksize;<font></font>
gpu_hashtable_insert_kernel&lt;&lt;&lt;gridsize, threadblocksize&gt;&gt;&gt;(hashtable, kvs, numkvs);<font></font>
<font></font>
<span class="hljs-comment">// GPU code to process numkvs key/values in parallel</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert_kernel</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">const</span> KeyValue* kvs, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> numkvs)</span>
</span>{
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> threadid = blockIdx.x*blockDim.x + threadIdx.x;
    <span class="hljs-keyword">if</span> (threadid &lt; numkvs)<font></font>
    {<font></font>
        gpu_hashtable_insert(hashtable, kvs[threadid].key, kvs[threadid].value);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A lockable hash table supports concurrent inserts, searches, and deletes. Since the key-value pairs are always in one of four states, and the keys do not move, the table guarantees correctness even when using different types of operations. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, if we process a packet of insertions and deletions in parallel, and if duplicate keys are contained in the input array of pairs, then we will not be able to predict which pairs will ‚Äúwin‚Äù - they will be written to the hash table last. Suppose we called an insert code with an input array of pairs </font></font><code>A/0 B/1 A/2 C/3 A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. When the code is completed, the pairs </font></font><code>B/1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and are </font></font><code>C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">guaranteed to be present in the table, but at the same time any of the pairs will appear in it </font></font><code>A/0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>A/2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or</font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This may or may not be a problem - it all depends on the application. You may know in advance that there are no duplicate keys in the input array, or it may not matter to you what value was last written. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If this is a problem for you, then you need to split the duplicate pairs into different system CUDA calls. In CUDA, any kernel call operation always ends before the next kernel call (at least within the same thread. In different threads, the kernel executes in parallel). If in the above example, call one core with </font></font><code>A/0 B/1 A/2 C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the other with </font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then the key </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will get a value </font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's talk about whether the function </font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use a simple (plain) or variable (volatile) a pointer to an array of pairs in a hash table.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CUDA documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> states that:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The compiler can, at its discretion, optimize the read and write operations to the global or shared memory ... These optimizations can be disabled using the keyword </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: ... any link to this variable is compiled into a real read or write instruction in memory.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Correctness considerations do not require application </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If the thread of execution uses the cached value from an earlier read operation, then this means that it will use a bit outdated information. </font><font style="vertical-align: inherit;">But still, this is information from the correct state of the hash table at a certain point in the kernel call. </font><font style="vertical-align: inherit;">If you need to use the latest information, you can use the pointer </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but then performance will decrease slightly: according to my tests, when you delete 32 million items, the speed decreases from 500 million delete / s to 450 million delete / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the test for inserting 64 million elements and deleting 32 million of them, there is </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">practically no </font><font style="vertical-align: inherit;">competition between </font><font style="vertical-align: inherit;">and the hash table for the GPU:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f10/342/41f/f1034241fbcf8c6f9ac61e2061aabf4a.png"></div><br>
<code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spent 70 691 ms on insertion and removal of elements with subsequent release </font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(release from millions of elements takes a lot of time, because </font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">numerous memory allocations are performed </font><font style="vertical-align: inherit;">inside </font><font style="vertical-align: inherit;">). Honestly, there are </font></font><code>std:unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">completely different limitations. This is a single CPU-thread of execution, it supports key-values ‚Äã‚Äãof any size, works well at high utilization rates and shows stable performance after numerous deletions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The duration of the hash table for the GPU and inter-program communication was 984 ms. This includes the time taken to place the table in memory and delete it (one-time allocation of 1 GB of memory, which in CUDA takes some time), insertion and deletion of elements, and also iteration over them. Also taken into account all the copying to and from the memory of the video card. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The hash table itself took 271 ms. This includes the time spent by the video card to insert and remove items, and does not take into account the time it takes to copy to memory and iterate over the resulting table. If the GPU table lives for a long time, or if the hash table is contained entirely in the memory of the video card (for example, to create a hash table that will be used by another GPU code and not the central processor), then the test result is relevant.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The hash table for the video card demonstrates high performance due to its high bandwidth and active parallelization.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disadvantages</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The hash table architecture has several issues to keep in mind:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clustering interferes with linear probing, because of which the keys in the table are far from ideal.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keys are not deleted using the function </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and over time clutter up the table.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, the performance of the hash table may gradually decrease, especially if it exists for a long time and numerous insertions and deletions are performed in it. </font><font style="vertical-align: inherit;">One way to mitigate these shortcomings is to rehash a new table with a fairly low utilization rate and filter remote keys when rehashing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To illustrate the problems described, I use the above code to create a table for 128 million elements, I will cyclically insert 4 million elements until I fill 124 million slots (utilization is about 0.96). </font><font style="vertical-align: inherit;">Here is the results table, each row is a call to the CUDA core with the insertion of 4 million new elements into one hash table:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilization rate </font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Duration of insertion 4 194 304 elements</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11.608448 ms (361.314798 million keys / sec.)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,03</font></font></td>
<td>11,751424  (356,918799  /.)</td>
</tr>
<tr>
<td>0,06</td>
<td>11,942592  (351,205515  /.)</td>
</tr>
<tr>
<td>0,09</td>
<td>12,081120  (347,178429  /.)</td>
</tr>
<tr>
<td>0,12</td>
<td>12,242560  (342,600233  /.)</td>
</tr>
<tr>
<td>0,16</td>
<td>12,396448  (338,347235  /.)</td>
</tr>
<tr>
<td>0,19</td>
<td>12,533024  (334,660176  /.)</td>
</tr>
<tr>
<td>0,22</td>
<td>12,703328  (330,173626  /.)</td>
</tr>
<tr>
<td>0,25</td>
<td>12,884512  (325,530693  /.)</td>
</tr>
<tr>
<td>0,28</td>
<td>13,033472  (321,810182  /.)</td>
</tr>
<tr>
<td>0,31</td>
<td>13,239296  (316,807174  /.)</td>
</tr>
<tr>
<td>0,34</td>
<td>13,392448  (313,184256  /.)</td>
</tr>
<tr>
<td>0,37</td>
<td>13,624000  (307,861434  /.)</td>
</tr>
<tr>
<td>0,41</td>
<td>13,875520  (302,280855  /.)</td>
</tr>
<tr>
<td>0,44</td>
<td>14,126528  (296,909756  /.)</td>
</tr>
<tr>
<td>0,47</td>
<td>14,399328  (291,284699  /.)</td>
</tr>
<tr>
<td>0,50</td>
<td>14,690304  (285,515123  /.)</td>
</tr>
<tr>
<td>0,53</td>
<td>15,039136  (278,892623  /.)</td>
</tr>
<tr>
<td>0,56</td>
<td>15,478656  (270,973402  /.)</td>
</tr>
<tr>
<td>0,59</td>
<td>15,985664  (262,379092  /.)</td>
</tr>
<tr>
<td>0,62</td>
<td>16,668673  (251,627968  /.)</td>
</tr>
<tr>
<td>0,66</td>
<td>17,587200  (238,486174  /.)</td>
</tr>
<tr>
<td>0,69</td>
<td>18,690048  (224,413765  /.)</td>
</tr>
<tr>
<td>0,72</td>
<td>20,278816  (206,831789  /.)</td>
</tr>
<tr>
<td>0,75</td>
<td>22,545408  (186,038058  /.)</td>
</tr>
<tr>
<td>0,78</td>
<td>26,053312  (160,989275  /.)</td>
</tr>
<tr>
<td>0,81</td>
<td>31,895008  (131,503463  /.)</td>
</tr>
<tr>
<td>0,84</td>
<td>42,103294  (99,619378  /.)</td>
</tr>
<tr>
<td>0,87</td>
<td>61,849056  (67,815164  /.)</td>
</tr>
<tr>
<td>0,90</td>
<td>105,695999  (39,682713  /.)</td>
</tr>
<tr>
<td>0,94</td>
<td>240,204636  (17,461378  /.)</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As utilization increases, productivity decreases. This is undesirable in most cases. If an application inserts elements into a table and then discards them (for example, when counting words in a book), then this is not a problem. But if the application uses a long-lived hash table (for example, in a graphics editor to store non-empty parts of images when the user often inserts and deletes information), then this behavior can be troublesome. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And he measured the depth of probing the hash table after 64 million inserts (utilization factor 0.5). The average depth was 0.4774, so most keys were located either in the best possible slot or in one slot from the best position. The maximum sounding depth was 60.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then I measured the sounding depth in the table with 124 million inserts (utilization rate 0.97). The average depth was already 10.1757, and the maximum - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6474</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (!!). Linear sounding performance drops dramatically at high utilization rates. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It‚Äôs best to keep this hash table low. But then we increase productivity by consuming memory. Fortunately, in the case of 32-bit keys and values, this can be justified. If in the above example in the table for 128 million elements the utilization coefficient of 0.25 is stored, then we can place no more than 32 million elements in it, and the remaining 96 million slots will be lost - 8 bytes for each pair, 768 MB of lost memory.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Please note that we are talking about the loss of video card memory, which is a more valuable resource than system memory. </font><font style="vertical-align: inherit;">Although most modern desktop graphics cards that support CUDA have at least 4 GB of memory (at the time of writing, NVIDIA 2080 Ti has 11 GB), losing such volumes will not be the wisest decision. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Later, I will write more about creating hash tables for video cards that have no problems with the depth of sounding, as well as ways to reuse remote slots.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sensing Depth Measurement</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To determine the depth of key sounding, we can extract the key hash (its ideal index in the table) from its actual table index:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// get_key_index() -&gt; index of key in hash table</span>
<span class="hljs-keyword">uint32_t</span> probelength = (get_key_index(key) - hash(key)) &amp; (hashtablecapacity<span class="hljs-number">-1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Due to the magic of two binary numbers in the additional code and the fact that the capacity of the hash table is equal to two in power, this approach will work even when the key index is moved to the beginning of the table. </font><font style="vertical-align: inherit;">Take a key that is hashed at 1 but inserted in slot 3. Then for a table with capacity 4 we get </font></font><code>(3 ‚Äî 1) &amp; 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">what is equivalent to 2.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you have questions or comments, write me on </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or open a new topic in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This code is inspired by some great articles:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The World's Simplest Lock-Free Hash Table</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Lock-Free Wait-Free Hash Table</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the future, I will continue to write about hash table implementations for video cards and will analyze their performance. </font><font style="vertical-align: inherit;">I have plans to chain, hash Robin Hood and cuckoo hash using atomic operations in data structures that are convenient for video cards.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en492540/index.html">The game "Wait a moment!" on arduino</a></li>
<li><a href="../en492546/index.html">Checking the vulnerability of any site using Nikto</a></li>
<li><a href="../en492548/index.html">Unity Machine Learning: Teaching MO Agents to Jump Over Walls</a></li>
<li><a href="../en492552/index.html">How to live and work in quarantine in Barcelona</a></li>
<li><a href="../en492558/index.html">Hello, this is COVID19: Does the coronavirus live on the surface of a smartphone?</a></li>
<li><a href="../en492562/index.html">Three useful Apache Ignite webinars in your quarantine program</a></li>
<li><a href="../en492566/index.html">Analysis of the combination of a greedy click search algorithm with partial enumeration of graph vertices</a></li>
<li><a href="../en492568/index.html">Get an extract from Rosreestr through FSIS USRN and python. Part 2</a></li>
<li><a href="../en492572/index.html">The current state of the Java world: trends and facts for one of the most popular programming languages</a></li>
<li><a href="../en492574/index.html">Reflections on Takeoff Probability: Apple AirPods with Momentum True Wireless 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>