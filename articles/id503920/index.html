<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒ¬ï¸ ğŸ‘¢ â¬‡ï¸ Bagaimana kami menguji sistem mikrofon pada STM32: pengalaman pengembang perangkat Yandex ğŸ”Œ ğŸ‘©â€âš•ï¸ ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, saya Gennady "Crail" Kruglov dari tim solusi perangkat keras Yandex. 
 
 Pemilihan mikrofon untuk matriks mikrofon adalah bagian yang kompleks da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami menguji sistem mikrofon pada STM32: pengalaman pengembang perangkat Yandex</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/503920/"><img src="https://habrastorage.org/webt/dg/ni/vr/dgnivrsbkyzydcn6d-uvht3oygc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hai, saya Gennady "Crail" Kruglov dari tim solusi perangkat keras Yandex. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pemilihan mikrofon untuk matriks mikrofon adalah bagian yang kompleks dan menarik dari pekerjaan kami: kami menguji model dengan berbagai parameter, bereksperimen dengan berbagai konfigurasi matriks, dan meningkatkan algoritma pemrosesan suara. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sangat nyaman bagi pengembang yang membuat algoritma pengurangan gema dan kebisingan untuk tidak hanya memproses data mentah yang sebelumnya diambil dari perangkat di laboratorium, tetapi juga untuk berinteraksi, misalnya, dengan matriks mikrofon baru secara real time dengan menghubungkannya ke laptop mereka.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tampaknya sederhana hanya pada pandangan pertama. </font><font style="vertical-align: inherit;">Pada artikel ini saya akan menjelaskan bagaimana kami memecahkan masalah mentransfer suara dari tujuh mikrofon dengan antarmuka PDM ke komputer melalui USB, nuansa perangkat keras dan perangkat lunak apa yang kami temui dan bagaimana cara mengatasinya (spoiler: pendekatan ini dapat disesuaikan untuk matriks dengan jumlah mikrofon â‰¤ 8 ) </font><font style="vertical-align: inherit;">Di akhir posting saya akan membagikan tautan ke stream, tempat saya menunjukkan proses pengembangan pada mikrokontroler STM32, dan berbicara tentang seri selanjutnya.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perumusan masalah</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sedikit latar belakang: untuk membuat berkas kepekaan yang terkontrol, untuk Yandex.Station pertama, rangkaian dengan tujuh mikrofon (analog) dipilih, untuk versi Mini - dengan empat (sudah digital). Untuk produk lain, berbagai konfigurasi dipertimbangkan, tetapi tetap matriks tujuh-mikrofon bagi kami adalah dasar, klasik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, diberikan: tujuh mikrofon digital, kebutuhan untuk mengujinya. Temukan: tidak terlalu sulit untuk diterapkan dan cara fleksibel untuk berinteraksi dengan mereka. Adalah logis untuk membagi tugas menjadi dua: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Dapatkan data dari mikrofon. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Kirim mereka ke komputer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada perangkat yang sudah jadi, ketika pengguna menghubungi Alice, sinyal dari mikrofon digital dikirim langsung ke prosesor pusat (lebih tepat menyebutnya SOC - System-on-Chip, tetapi "prosesor" lebih akrab dan nyaman), ia memiliki kekuatan yang cukup untuk memprosesnya. Tetapi untuk algoritma debugging, jauh lebih mudah untuk mendapatkan data ini langsung ke komputer pengembang. Cara termudah adalah terhubung melalui USB: dengan demikian, board harus memiliki mikrokontroler dengan unit yang sesuai. Kami menyukai pengontrol STM32, tetapi tidak mungkin mengirim aliran suara langsung dari mikrofon ke sana: tidak ada unit penerimaan sinyal PDM (modulasi kepadatan pulsa) - antarmuka keluaran mikrofon digital.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pilihan lain adalah menghubungkan papan mikrofon ke papan debug dari pabrikan SoC yang digunakan. </font><font style="vertical-align: inherit;">Tetapi keputusan ini terkait dengan Linux alsamixer, dan parameternya sangat mempengaruhi hasil konversi PDM ke PCM. </font><font style="vertical-align: inherit;">Blok ini mungkin berbeda tidak hanya untuk prosesor dari pabrikan yang berbeda, tetapi bahkan untuk dua model dari vendor yang sama. </font><font style="vertical-align: inherit;">Saya mengingatkan Anda bahwa kami membutuhkan solusi sederhana, transparan dan dapat diprediksi.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi perangkat keras</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terima ketidakmampuan STM32 untuk menerima PDM multi-saluran. Seseorang dapat menggunakan blok SPI untuk menerima sinyal PDM, tetapi hanya satu mikrofon yang dapat dihubungkan ke satu bus SPI. Kami bekerja dengan pengontrol STM32L476RC, di mana hanya ada tiga bus seperti itu. Kompleksitas tambahan: sinyal PDM memiliki frekuensi cukup tinggi, perlu melakukan penipisan, rata-rata, pemrosesan, pemfilteran - untuk tujuh mikrofon, tugas ini cukup rumit.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena kita berbicara tentang papan debug, dan bukan prototipe untuk produksi massal, kami akan fokus pada chip khusus TSDP18xx. Itu melakukan semua yang diperlukan: itu menghasilkan frekuensi dan sinyal yang diperlukan untuk PDM, rata-rata dan proses sinyal PDM, mengubah semuanya menjadi sinyal I2S. Lebih tepatnya, TDM (Time Division Multiplexing), karena I2S-bus mengasumsikan dua saluran, dan jika Anda berkendara lebih banyak melalui kabel yang sama, tidak lagi benar untuk menyebutnya I2S. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keuntungan dari pendekatan ini adalah bahwa semua pekerjaan persiapan dan rata-rata dilakukan oleh TSDP. Minus - semua algoritma terhubung dengan kabel di dalam sirkuit mikro ini, dan tidak dapat diubah. Secara khusus, Anda tidak dapat menyesuaikan volume dengan memodifikasi parameter rata-rata. Tetapi untuk debugging, ini tidak penting.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Awasi tangan Anda: ada tujuh mikrofon, delapan saluran di sirkuit mikro. Yang tidak digunakan, output masih ada, jadi di masa depan untuk kesederhanaan saya akan berbicara tentang aliran audio delapan saluran. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, kami menaikkan TDM delapan saluran ke STM32, kami mendapatkan aliran audio delapan saluran. Bagaimana data bergerak: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/w1/pe/40/w1pe40wix4cok_xc_xmaslgas3a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SAI - STM32 perangkat keras untuk bekerja dengan I2S / TDM. Ini sangat fleksibel dan memungkinkan Anda untuk mengimplementasikan banyak opsi protokol. Tetapi karena ini, mudah untuk bingung dalam persyaratan untuk frekuensi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pohon jam layak untuk dilihat lebih dekat. Sebuah resonator kuarsa 12 MHz terhubung ke mikrokontroler. Kami membagi frekuensi ini sebelum menerapkan ke blok PLL dengan 3 dan mendapatkan 4 MHz. Maka kerjanya seperti ini:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Alangkah baiknya untuk membuat frekuensi inti lebih tinggi untuk mengikuti semuanya: misalnya, maksimum untuk pengontrol ini adalah 80 MHz. Kami menggunakan blok PLL pertama: kami mengalikan 4 MHz dengan 40 dan membaginya dengan 2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. USB membutuhkan 48 MHz. Untuk melakukan ini, gunakan blok PLL kedua: kalikan 4 MHz dengan 24 dan bagi dengan 2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. Tentang mikrofon. Papan uji kami menggunakan frekuensi sampling Fs = 16 kHz, standar yang diadopsi di bidang pengenalan ucapan. Dari frekuensi awal 4 MHz Anda perlu mendapatkan sesuatu yang dapat diubah menjadi frekuensi frame bus TDM 16 kHz (alias LRCK, alias FCK, alias FrameSync). Dalam hal ini: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[frekuensi sinkronisasi bit (BCLK, BitClk, Sync, SCK)] = Fs âˆ™ [jumlah saluran] âˆ™ [jumlah bit per saluran] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yaitu: SCK = 16 kHz âˆ™ 8 âˆ™ 16 = 2048 kHz.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. Lembar data menunjukkan bahwa rasio antara Master Clock dan laju sampling Fs adalah sebagai berikut: MasterClock = 16 kHz âˆ™ Pembagi MCLK âˆ™ 256. Di sini 256 adalah konstanta, dan pembagi dapat diatur dalam register. </font><font style="vertical-align: inherit;">Mari kita periksa skema - untuk fungsionalitas yang diperlukan ada koefisien untuk membagi frekuensi PLL dengan 7 atau 17: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qk/9n/zo/qk9nzo9zysl0dsggr-la2lux9-m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk meringkas masalah: Anda perlu memilih seperangkat faktor PLL dan SAI dan pembagi untuk mendapatkan frekuensi sampling 16 kHz dan frekuensi bit 128 kali lebih banyak. </font><font style="vertical-align: inherit;">Karena set memiliki pembagi wajib oleh 7 (atau 17), itu tidak berfungsi untuk mendapatkan hasil yang diinginkan. </font><font style="vertical-align: inherit;">Saya harus membuat tabel pengganda dan pembagi untuk mendapatkan 24.571 MHz. </font><font style="vertical-align: inherit;">Membagi frekuensi ini dengan 6 (MCLK Divider), dan kemudian 256 (konstan), akhirnya, kami mendapatkan angka yang cukup dekat hingga 16 kHz. </font><font style="vertical-align: inherit;">Sekarang saya akan menjelaskan mengapa ini sangat penting.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operasi USB</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USB menggunakan jenis transfer isochronous untuk bekerja dengan data multimedia: dalam hal ini, bandwidth dan nilai penundaan tertentu dijamin pada bus USB. Pengiriman data tidak dijamin: jika suatu paket datang dengan kegagalan, maka itu akan dianggap hilang. Ini karena batas waktu yang ketat: tidak ada cara untuk bertanya lagi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan jenis transfer isochronous pada kecepatan USB FullSpeed â€‹â€‹(12 Mbit / s; pada kecepatan inilah blok USB STM32 dapat bekerja) komputer datang ke perangkat untuk data setiap milidetik: setelah periode waktu ini, ia harus mengumpulkan data yang terakumulasi. Biarkan saya mengingatkan Anda yang pengantar: frekuensi sampling adalah 16 kHz, 8 saluran, masing-masing saluran membutuhkan dua byte, karena suara enam belas-bit. Total 16000 âˆ™ 2 âˆ™ 8/1000 = 256 byte per milidetik. Ukuran satu paket untuk jenis transmisi isochronous dapat mencapai 1023 byte, sehingga tidak ada masalah pada saat ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, ukuran paket adalah 256 byte. Tampaknya semuanya baik-baik saja. Enam belas kali menerima data pada TDM, dimasukkan ke buffer, USB datang, kami berikan paket, kami ulangi ... Tapi ini hanya terjadi di dunia yang ideal. Masalahnya adalah bahwa di satu sisi kita memiliki 16 kHz tidak sempurna (sedikit kurang), dan sebagai hasilnya, data datang sedikit kurang dari sekali setiap milidetik. Di sisi lain, milidetik komputer juga mengapung, karena sibuk: ketika bisa, maka itu datang. Artinya, frekuensi pengambilan sampel mikrofon berbeda dari 16 kHz (tetapi selalu sama), dan milidetik USB juga berbeda panjangnya (perbedaannya kemungkinan besar mengambang: ternyata sedikit lebih banyak, kemudian sedikit kurang dari satu milidetik ideal).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa ini menjadi masalah? Anda bisa kehilangan paket. Mungkin tidak perlu dijelaskan bahwa data lengkap diperlukan untuk debugging yang benar dari algoritma. Bagaimana paket tersebut hilang: mereka mengumpulkan 256 byte hasil, menempatkannya di buffer, dan melanjutkan pengukuran. Komputer datang, mengambil 256 pertama, kami masih terus mengukur. Komputer datang lagi, tetapi pengukuran belum selesai - komputer pergi dengan paket kosong. Kemudian kami selesai mengisi buffer dan mulai mengisi yang lain, yang berikutnya, sampai komputer datang lagi. Komputer hanya mengambil paket terakhir, sebagai hasilnya, satu paket hilang. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/of/o0/ol/ofo0olk2bqjbjtm5keb0upd58xo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya, sebenarnya, diketahui. Ada tiga pendekatan untuk menghadapinya:</font></font><br>
<br>
<ul>
<li><b></b>.            USB.    â€”    .   Â«Â» â€”   .   USB          .       ,     ,   (  ,  16 ),       .        ,          .</li>
<li><b></b>.             .</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah yang terbaik untuk tugas ini. </font><font style="vertical-align: inherit;">Perangkat ini memiliki generator frekuensi yang stabil. </font><font style="vertical-align: inherit;">Kecepatan pengambilan sampel dipertahankan persis sama tanpa merujuk ke USB. </font><font style="vertical-align: inherit;">Dalam hal ini, Anda perlu mentransfer data ke perangkat sehingga tidak ada perbedaan yang signifikan.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua ini telah dibahas lebih dari satu kali di Internet untuk kasus pemutaran dari komputer ke speaker melalui perangkat dengan digital-to-analog coder, di mana perangkat sebagai umpan balik memberitahu Anda berapa banyak periode pengambilan sampel telah datang sejak paket terakhir diterima. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/4m/xx/ng/4mxxngiif53s98nf0v08vuuyds0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi tugas kami adalah sebaliknya, debugging membutuhkan penerimaan data dari mikrofon ke komputer, dan pertanyaan tentang merekam sinyal dari mikrofon ke komputer hanya disebutkan yang terbaik. </font><font style="vertical-align: inherit;">Mengapa tidak melakukan hal yang sama: masukkan umpan balik dari komputer? </font><font style="vertical-align: inherit;">Ada opsi yang lebih mudah.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu dia</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami sering menggunakan penambahan sampel dan dua buffer untuk menyimpan data untuk pengiriman. 16 kali per milidetik, kami menambahkan ke buffer terpilih sampel berikutnya. Pada titik waktu tertentu, terjadi gangguan: USB mengambil paket sebelumnya. Jika buffer No. 1 penuh, ia beralih ke buffer No. 2. Ketika USB tiba untuk paket berikutnya, ia sudah disiapkan. Kirim nomor penyangga 2 dan kembali ke nomor 1.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ob/td/0m/obtd0mcd2tzmv8iut7w7-5_vpzc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USB datang untuk data di berbagai titik waktu, paket menyertakan jumlah sampel yang berbeda. Itu bisa berubah menjadi lebih dan kurang dari enam belas, sehingga ada peluang untuk melebihi paket dengan ukuran 256 byte, lebih baik untuk meninggalkan ruang untuk bermanuver. Biarkan 384 = 256 + 128: ini akan memberikan margin setengah milidetik, yaitu, ia akan memaafkan fase berenang dari sinyal USB sebesar 50% - margin seperti itu harus lebih dari cukup. Total: kadang-kadang lebih atau kurang 256 byte dikirim, tetapi tidak pernah paket kosong, yang menghindari kehilangan data. Artinya, masalah ketidakseimbangan diselesaikan dengan meningkatkan paket, dengan biaya meningkatkan bagian dari bandwidth bus yang dialokasikan untuk perangkat kami dan mengurangi bagian ini untuk perangkat lain.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentang ini, pengiriman data ke komputer berakhir. </font><font style="vertical-align: inherit;">Pengembang dapat didebug, dan Anda dapat mengajukan pertanyaan di komentar jika beberapa jenis paket data tidak cukup untuk pemahaman yang lengkap.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streaming saya dan episode berikutnya</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akhir-akhir ini saya mengalir dua kali dari lab solder rumah saya. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada awalnya saya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hanya menunjukkan proses penyolderan dan memberi tahu perangkat mana yang saya gunakan. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seri kedua</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hanya ditujukan untuk pengembangan pada STM32. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streaming berlanjut. </font><font style="vertical-align: inherit;">Jumat ini pukul 19.00, kolega saya dari tim pengembangan solusi perangkat keras Andrey Laptev akan mengatur analisis online Yandex.Stations Mini - tunjukkan bagian dalamnya dan bagikan sejarah produksi. </font><font style="vertical-align: inherit;">Untuk lebih menyenangkan, Andrey akan mengacaukan baterai ke kolom - tidak semua sama, bekerja dari kawat. </font><font style="vertical-align: inherit;">Di final, Anda akan menerima panduan yang memungkinkan Anda mengulangi pengalaman ini sendiri atau menghasilkan desain yang lebih menarik. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menonton arus. </font><font style="vertical-align: inherit;">Anda akan menerima surat dengan file untuk kalender dan pengingat pada hari udara. </font><font style="vertical-align: inherit;">Terima kasih telah membaca!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id503906/index.html">LabVIEW NXG - Jenis Data Sederhana dan Jenis Pemaksaan</a></li>
<li><a href="../id503908/index.html">Panggil perpustakaan bersama dari Similink</a></li>
<li><a href="../id503910/index.html">Eksperimen pada orang yang telah pergi ke "udalenka"</a></li>
<li><a href="../id503916/index.html">Belajar berdagang di bursa. Bagian satu: mengatur lingkungan pengujian</a></li>
<li><a href="../id503918/index.html">Mengelola Paket dengan Modul Go: A Pragmatic Guide</a></li>
<li><a href="../id503922/index.html">Mengapa UE memberantas dinding cookie</a></li>
<li><a href="../id503924/index.html">Tinjauan Umum tentang Pemindai 3D Intraoral Medit i500</a></li>
<li><a href="../id503926/index.html">Siapa yang ada dalam ekosistem pembayaran 2020. Bagian 2</a></li>
<li><a href="../id503928/index.html">Aerosol VS irigasi: mana yang lebih baik, dan apakah ada perbedaan?</a></li>
<li><a href="../id503932/index.html">Saya bosan dengan kenyataan bahwa penjual biasa menyamar sebagai pengembang dan memalukan industri. Mereka membuat dunia lebih buruk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>