<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏼 🎄 🎚️ 异步PHP 🛶 🈲 🛀🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="十年前，我们有一个经典的LAMP堆栈：Linux，Apache，MySQL和PHP，它们以mod_php的慢速模式工作。世界已经改变，速度也变得重要。 PHP-FPM出现了，它可以显着提高PHP解决方案的性能，而不必紧急地重写某些内容。
 
 同时，ReactPHP库是使用事件循环概念开发的，用于处...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>异步PHP</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/487258/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十年前，我们有一个经典的LAMP堆栈：Linux，Apache，MySQL和PHP，它们以mod_php的慢速模式工作。世界已经改变，速度也变得重要。 PHP-FPM出现了，它可以显着提高PHP解决方案的性能，而不必紧急地重写某些内容。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同时，ReactPHP库是使用事件循环概念开发的，用于处理来自操作系统的信号并提供异步操作的结果。 ReactPHP-AMPHP想法的发展。与ReactPHP不同，该库使用相同的事件循环，但支持协程。它们使您可以编写看起来像同步的异步代码。也许这是用PHP开发异步应用程序的最新框架。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tf/03/e6/tf03e6u08mt8gake9o4lbbfbdca.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是越来越需要速度，工具还不够，因此PHP异步编程的思想是加快查询处理和更好地利用资源的方法之一。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anton Shabovta</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谈论的</font><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zloyusr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）是Onliner的开发人员。</font><font style="vertical-align: inherit;">超过10年的经验：我从C / C ++的桌面应用程序开始，然后转向PHP的Web开发。</font><font style="vertical-align: inherit;">他用C＃和Python 3编写“家庭”项目，并在PHP中尝试DDD，CQRS，事件源，异步多任务。</font></font><br>
<a name="habracut"></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本文基于Anton关于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP Russia 2019</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的报告的笔录</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在其中，我们将了解PHP中的阻塞和非阻塞操作，我们将从内部研究事件循环和异步基元（例如Promise和协程）的结构。</font><font style="vertical-align: inherit;">最后，我们将在ext-async，AMPHP 3和PHP 8中找到等待我们的内容。</font></font></i><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/w75P9RrVgKg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们介绍了两个定义。</font><font style="vertical-align: inherit;">很长一段时间，我试图找到异步和异步操作的确切定义，但是我没有找到并编写我的。</font></font><br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是软件系统不阻塞执行主线程的能力。</font></font><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步操作</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是在完成之前不会阻塞程序执行流的操作。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这似乎很简单，但是首先您需要了解哪些操作会阻止执行流程。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">封锁作业</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHP是一种解释器语言。</font><font style="vertical-align: inherit;">他逐行读取代码，将其翻译成指令并执行。</font><font style="vertical-align: inherit;">下例中的哪一行代码将被阻止？</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">User $user</span>)</span><font></font><span class="hljs-function">
</span>{<font></font>
    <span class="hljs-keyword">try</span> {<font></font>
        $sql = <span class="hljs-string">'UPDATE users SET ...'</span>;<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;connection-&gt;execute($sql, $user-&gt;data());<font></font>
    } <span class="hljs-keyword">catch</span> (\PDOException $error) {<font></font>
        log($error-&gt;getMessage());<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们通过PDO连接到数据库，则执行线程将在SQL-server：的查询字符串上被阻止</font></font><code>return $this-&gt;connection-&gt;execute($sql, $user-&gt;data());</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是因为PHP不知道SQL Server将处理该查询多长时间以及它是否将完全执行。</font><font style="vertical-align: inherit;">它等待服务器的响应，并且程序一直没有运行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHP还阻止所有I / O操作的执行流程。</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件系统</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><code>fwrite</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>file_get_contents</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据库</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><code>PDOConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>RedisClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">默认情况下，几乎所有用于连接数据库的扩展都以阻止模式工作。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流程</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><code>exec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>system</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>proc_open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这些都是阻塞操作，因为所有处理流程都是通过系统调用构建的。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与标准输入/输出工作</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><code>readline</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>echo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>print</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，以下</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计时器</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会阻止执行</font><font style="vertical-align: inherit;">：</font></font><code>sleep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>usleep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这些操作中，我们明确地告诉线程入睡一段时间。</font><font style="vertical-align: inherit;">PHP将一直闲置。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步SQL客户端</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是现代PHP是一种通用语言，不仅限于1997年的PHP / FI之类的网络。</font><font style="vertical-align: inherit;">因此，我们可以从头开始编写异步SQL客户端。</font><font style="vertical-align: inherit;">任务不是最琐碎的，而是可以解决的。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execAsync</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> $query, <span class="hljs-keyword">array</span> $params = []</span>)</span><font></font><span class="hljs-function">
</span>{<font></font>
    $socket = stream_socket_client(<span class="hljs-string">'127.0.0.1:3306'</span>, ...);<font></font>
<font></font>
    stream_set_blocking($socket, <span class="hljs-literal">false</span>);<font></font>
<font></font>
    $data = <span class="hljs-keyword">$this</span>-&gt;packBinarySQL($query, $params);<font></font>
    <font></font>
    socket_write($socket, $data, strlen($data));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样的客户做什么？</font><font style="vertical-align: inherit;">它连接到我们的SQL Server，将套接字置于非阻塞模式，以SQL Server可以理解的二进制格式打包请求，然后将数据写入套接字。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于套接字处于非阻塞模式，因此来自PHP的写操作速度很快。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，这样的操作会返回什么？</font><font style="vertical-align: inherit;">我们不知道SQL Server将响应什么。</font><font style="vertical-align: inherit;">可能需要很长时间才能完成请求，或者根本不完成。</font><font style="vertical-align: inherit;">但是需要退货吗？</font><font style="vertical-align: inherit;">如果使用PDO并</font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在SQL Server上</font><font style="vertical-align: inherit;">调用</font><font style="vertical-align: inherit;">查询，则返回</font></font><code>affected rows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-此查询更改的行数。</font><font style="vertical-align: inherit;">我们还不能退货，因此我们只</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">承诺</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">退货。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">诺言</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是异步编程领域的一个概念。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise是异步操作结果的包装对象。</font><font style="vertical-align: inherit;">而且，该操作的结果仍然是我们未知的。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不幸的是，没有单一的Promise标准，并且不可能直接将标准从JavaScript领域转移到PHP。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">承诺如何运作</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于还没有结果，我们只能建立一些结果</font></font><code>callbacks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ia/n1/qq/ian1qqvr_xs0faonifptkfrd2jc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当数据可用时，有必要执行callback </font></font><code>onResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8v/bk/sf/8vbksfxvsfxskeozp3jckft5rmg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果发生错误，将执行回调</font></font><code>onReject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以处理错误。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8x/hw/0v/8xhw0vsdhfryxyxalvsydiydfsc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Promise界面看起来像这样。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Promise</span></span><font></font><span class="hljs-class">
</span>{<font></font>
    <span class="hljs-keyword">const</span><font></font>
        STATUS_PENDING = <span class="hljs-number">0</span>,<font></font>
        STATUS_RESOLVED = <span class="hljs-number">1</span>,<font></font>
        STATUS_REJECTED = <span class="hljs-number">2</span><font></font>
    ;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onResolve</span>(<span class="hljs-params"><span class="hljs-keyword">callable</span> $callback</span>)</span>;<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onReject</span>(<span class="hljs-params"><span class="hljs-keyword">callable</span> $callback</span>)</span>;<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">$data</span>)</span>;<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">\<span class="hljs-built_in">Throwable</span> $error</span>)</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Promise具有设置回调和填充（</font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）的</font><font style="vertical-align: inherit;">状态和方法，并</font><font style="vertical-align: inherit;">带有数据或错误（</font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">但是存在差异和变化。</font><font style="vertical-align: inherit;">方法可以被不同地调用，或者代替用于建立回调的单独方法，</font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且</font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能有一些方法，例如在AMPHP中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
填充Promise </font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并</font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在单独的对象中提取</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deferred-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储状态异步函数</font><strong><font style="vertical-align: inherit;">的常用技术</font></strong><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它可以被视为Promise的一种工厂。</font><font style="vertical-align: inherit;">这是一次性的：一拖一便许下诺言。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bq/on/aq/bqonaqi04ql4kdhakfezn9nu25g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们决定自己编写，如何在SQL客户端中应用呢？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步SQL客户端</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们创建了Deferred，使用套接字完成了所有工作，记录了数据并返回Promise-一切都很简单。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execAsync</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> $query, <span class="hljs-keyword">array</span> $params = []</span>)</span><font></font><span class="hljs-function">
</span>{<font></font>
    $deferred = <span class="hljs-keyword">new</span> Deferred;<font></font>
<font></font>
    $socket = stream_socket_client(<span class="hljs-string">'127.0.0.1:3306'</span>, ...);<font></font>
    stream_set_blocking($socket, <span class="hljs-literal">false</span>);<font></font>
<font></font>
    $data = <span class="hljs-keyword">$this</span>-&gt;packBinarySQL($query, $params);<font></font>
    socket_write($socket, $data, strlen($data));<font></font>
<font></font>
    <span class="hljs-keyword">return</span> $deferred-&gt;promise();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我们有了Promise时，我们可以例如：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置回调并获得</font></font><code>affected rows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回给我们</font><font style="vertical-align: inherit;">的回调</font></font><code>PDOConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理错误，添加到日志中；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果SQL Server响应错误，请重试查询。</font></font></li>
</ul><br>
<pre><code class="php hljs">$promise = <span class="hljs-keyword">$this</span>-&gt;execAsync($sql, $user-&gt;data());<font></font>
<font></font>
$promise-&gt;onResolve(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-keyword">int</span> $rows</span>) </span>{<font></font>
    <span class="hljs-keyword">echo</span> <span class="hljs-string">"Affected rows: {$rows}"</span>;<font></font>
});<font></font>
<font></font>
$promise-&gt;onReject(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">\<span class="hljs-built_in">Throwable</span> $error</span>) </span>{<font></font>
    log($error-&gt;getMessage());<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
问题仍然存在：我们设置了回调，谁将呼叫</font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件循环</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个事件循环</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的概念</font><strong><font style="vertical-align: inherit;">-事件循环</font></strong><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他能够在异步环境中处理消息。</font><font style="vertical-align: inherit;">对于异步I / O，这些将是来自操作系统的消息，表明套接字已准备好读取或写入。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
怎么运行的。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">客户端告诉事件循环，它对某种套接字感兴趣。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件循环通过系统调用轮询OS </font></font><code>stream_select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：是否已准备好套接字，是否已写入所有数据，是否是来自另一端的数据。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果操作系统报告套接字未准备好，已阻塞，则事件循环将重复循环。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当操作系统通知套接字已准备就绪时，事件循环将控制权返回给客户端并启用（</font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）承诺。</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/ln/ey/bb/lneybbz-tylmfanfoizqm2hscik.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们在代码中表达了这一概念：采用最简单的情况，消除错误处理和其他细微差别，从而保留一个无限循环。</font><font style="vertical-align: inherit;">在每次迭代中，它将轮询操作系统有关准备读取或写入的套接字的信息，并为特定套接字调用回调。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span><font></font><span class="hljs-function">
</span>{<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {<font></font>
        stream_select($readSockets, $writeSockets, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>);<font></font>
        <font></font>
        <span class="hljs-keyword">foreach</span> ($readSockets <span class="hljs-keyword">as</span> $i =&gt; $socket) {<font></font>
            call_user_func(<span class="hljs-built_in">self</span>::readCallbacks[$i], $socket);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">// Do same for write sockets</span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们补充了我们的SQL客户端。</font><font style="vertical-align: inherit;">我们通知事件循环，一旦来自SQL Server的数据到达我们正在使用的套接字，就需要将Deferred置于“完成”状态，并将数据从套接字传输到Promise。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execAsync</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> $query, <span class="hljs-keyword">array</span> $params = []</span>)</span><font></font><span class="hljs-function">
</span>{<font></font>
    $deferred = <span class="hljs-keyword">new</span> Deferred;<font></font>
    ...<font></font>
    Loop::onReadable($socket, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$socket</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$deferred</span>) </span>{<font></font>
        $deferred-&gt;resolve(socket_read($socket));<font></font>
    });<font></font>
<font></font>
    <span class="hljs-keyword">return</span> $deferred-&gt;promise();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事件循环</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以处理我们的I / O</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与套接字一起使用</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他还能做什么？</font></font><br>
<br>
<ul>
<li> JavaScript   <code>setTimeout</code>  <code>setInterval</code> — .             N . <strong>Event Loop      </strong>.</li>
<li>Event Loop  <strong>   </strong>.    <code>process control</code>,       .</li>
</ul><br>
<h3> Event Loop</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
编写事件循环不仅是可能的，而且是必要的。如果要使用异步PHP，重要的是编写自己的简单实现以了解其工作原理。但是，在生产中，我们当然不会使用它，但是我们将采用现成的实现方式：稳定，无错误且在工作中得到证明。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主要有三种实现。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReactPHP</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。最古老的项目始于PHP 5.3。现在最低要求的PHP版本是5.3.8。该项目实现</font><font style="vertical-align: inherit;">了JavaScript世界中</font><font style="vertical-align: inherit;">的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promises / A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标准</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMPHP</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我更喜欢使用这种实现。最低要求是PHP 7.0，因为下一版本已经是7.3。它在Promise的顶部使用协程。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">旋风</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个有趣的中文框架，开发人员在其中尝试将一些概念从Go世界移植到PHP。</font><font style="vertical-align: inherit;">英文文档不完整，大部分文档都以中文发布在GitHub上。</font><font style="vertical-align: inherit;">如果您会说这种语言，请继续，但是到目前为止，我不敢工作。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zo/n3/cq/zon3cqtbmsf-vnd0uliqqupphoo.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReactPHP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看看使用ReactPHP for MySQL的客户端的外观。</font></font><br>
<br>
<pre><code class="php hljs">$connection = (<span class="hljs-keyword">new</span> ConnectionFactory)-&gt;createLazyConnection();<font></font>
<font></font>
$promise = $connection-&gt;query(<span class="hljs-string">'UPDATE users SET ...'</span>);<font></font>
$promise-&gt;then(<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">QueryResult $command</span>) </span>{<font></font>
        <span class="hljs-keyword">echo</span> count($command-&gt;resultRows) . <span class="hljs-string">' row(s) in set.'</span>;<font></font>
    },<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">Exception</span> $error</span>) </span>{<font></font>
        <span class="hljs-keyword">echo</span> <span class="hljs-string">'Error: '</span> . $error-&gt;getMessage();<font></font>
    });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一切几乎都与我们写的相同：我们创建</font></font><code>onnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并执行请求。</font><font style="vertical-align: inherit;">我们可以设置回调以处理结果（return </font></font><code>affected rows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><br>
<br>
<pre><code class="php hljs">    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">QueryResult $command</span>) </span>{<font></font>
        <span class="hljs-keyword">echo</span> count($command-&gt;resultRows) . <span class="hljs-string">' row(s) in set.'</span>;<font></font>
    },</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
和回调以进行错误处理：</font></font><br>
<br>
<pre><code class="php hljs">    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">Exception</span> $error</span>) </span>{<font></font>
        <span class="hljs-keyword">echo</span> <span class="hljs-string">'Error: '</span> . $error-&gt;getMessage();<font></font>
    });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从这些回调中，您可以构建长链，因为</font></font><code>then</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReactPHP中的</font><font style="vertical-align: inherit;">每个结果</font><font style="vertical-align: inherit;">还返回Promise。</font></font><br>
<br>
<pre><code class="php hljs">$promise<font></font>
    -&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$data</span>) </span>{<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(...);<font></font>
    })<font></font>
    -&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$data</span>) </span>{<font></font>
        ...<font></font>
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$error</span>) </span>{<font></font>
        log($error);<font></font>
    })<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个称为回调地狱的问题的解决方案。</font><font style="vertical-align: inherit;">不幸的是，在ReactPHP实现中，当</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要</font></font></strong><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10-11个回调</font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">来正确连接RabbitMQ</font></strong><font style="vertical-align: inherit;">时，这会导致“ Promise hell”问题</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用此类代码并进行修复很困难。</font><font style="vertical-align: inherit;">我很快意识到这不是我的，而是切换到AMPHP。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Amphp</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个项目比ReactPHP还年轻，它提倡了不同的概念- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协程</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果您考虑在AMPHP中使用MySQL，那么您会发现这与</font></font><code>PDOConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在PHP中</font><font style="vertical-align: inherit;">使用几乎相同</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="php hljs">$pool = Mysql\pool(<span class="hljs-string">"host=127.0.0.1 port=3306 db=test"</span>);<font></font>
<font></font>
<span class="hljs-keyword">try</span> {<font></font>
    $result = <span class="hljs-keyword">yield</span> $pool-&gt;query(<span class="hljs-string">"UPDATE users SET ..."</span>);<font></font>
<font></font>
    <span class="hljs-keyword">echo</span> $result-&gt;affectedRows . <span class="hljs-string">' row(s) in set.'</span>;<font></font>
} <span class="hljs-keyword">catch</span> (\<span class="hljs-built_in">Throwable</span> $error) {<font></font>
    <span class="hljs-keyword">echo</span> <span class="hljs-string">'Error: '</span> . $error-&gt;getMessage();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们创建一个池，连接并执行请求。</font><font style="vertical-align: inherit;">我们可以通过通常的错误来处理错误</font></font><code>try...catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们不需要回调。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是在异步调用之前，关键字-出现在此处</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发电机</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关键字</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将我们的函数变成生成器。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generator</span>(<span class="hljs-params">$counter = <span class="hljs-number">1</span></span>)</span><font></font><span class="hljs-function">
</span>{<font></font>
    <span class="hljs-keyword">yield</span> $counter++;<font></font>
<font></font>
    <span class="hljs-keyword">echo</span> <span class="hljs-string">"A"</span>;<font></font>
<font></font>
    <span class="hljs-keyword">yield</span> $counter;<font></font>
<font></font>
    <span class="hljs-keyword">echo</span> <span class="hljs-string">"B"</span>;<font></font>
<font></font>
    <span class="hljs-keyword">yield</span> ++$counter;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一旦PHP解释器</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在体内</font><font style="vertical-align: inherit;">遇到</font><font style="vertical-align: inherit;">函数，它就会意识到这是一个生成器函数。</font><font style="vertical-align: inherit;">在调用时会创建一个类对象，而不是执行</font></font><code>Generator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生成器继承迭代器接口。</font></font><br>
<br>
<pre><code class="php hljs">$generator = <span class="hljs-built_in">generator</span>(<span class="hljs-number">1</span>);<font></font>
<font></font>
<span class="hljs-keyword">foreach</span> ($generator <span class="hljs-keyword">as</span> $value) {<font></font>
    <span class="hljs-keyword">echo</span> $value;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">while</span> ($generator-&gt;valid()) {<font></font>
    <span class="hljs-keyword">echo</span> $generator-&gt;current();<font></font>
<font></font>
    $generator-&gt;next();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，它可以运行周期</font></font><code>foreach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并</font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和其他人。</font><font style="vertical-align: inherit;">但是，更有趣的是，迭代器具有方法</font></font><code>current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们一步一步地解决它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
运行我们的功能</font></font><code>generator($counter = 1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们称生成器方法</font></font><code>current()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">变量的值将被返回</font></font><code>$counter++</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一旦执行生成器</font></font><code>next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，代码将转到生成器内部的下一个调用</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">两者之间的整个代码段都</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将执行，这很酷。</font><font style="vertical-align: inherit;">继续旋转生成器，我们得到结果。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协程</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是生成器具有更有趣的功能-我们可以从外部将数据发送到生成器。</font><font style="vertical-align: inherit;">在这种情况下，它不是生成器，而是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协程</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或协程。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printer</span>(<span class="hljs-params"></span>) </span>{  <font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {     <font></font>
        <span class="hljs-keyword">echo</span> <span class="hljs-keyword">yield</span>;       <font></font>
    }                             <font></font>
}                                <font></font>
<font></font>
$print = printer();<font></font>
$print-&gt;send(<span class="hljs-string">'Hello'</span>);<font></font>
$print-&gt;send(<span class="hljs-string">' PHPRussia'</span>);<font></font>
$print-&gt;send(<span class="hljs-string">' 2019'</span>);<font></font>
$print-&gt;send(<span class="hljs-string">'!'</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在代码的这一部分中，有趣的是它</font></font><code>while (true)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会阻塞执行流程，而是会执行一次。</font><font style="vertical-align: inherit;">我们将数据发送到Corutin并接收</font></font><code>'Hello'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">发送多收</font></font><code>'PHPRussia'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">原理很明确。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了将数据发送到生成器之外，您还可以从内部发送错误并进行处理，这很方便。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printer</span>(<span class="hljs-params"></span>) </span>{<font></font>
    <span class="hljs-keyword">try</span> {<font></font>
        <span class="hljs-keyword">echo</span> <span class="hljs-keyword">yield</span>;<font></font>
    } <span class="hljs-keyword">catch</span> (\<span class="hljs-built_in">Throwable</span> $e) {<font></font>
        <span class="hljs-keyword">echo</span> $e-&gt;getMessage();<font></font>
    }<font></font>
}<font></font>
<font></font>
printer()-&gt;throw(<span class="hljs-keyword">new</span> \<span class="hljs-built_in">Exception</span>(<span class="hljs-string">'Ooops...'</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总结一下。</font><font style="vertical-align: inherit;">Corutin是程序的组件，该程序</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支持在维持当前状态的同时停止和继续执行</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Corutin会记住他的调用堆栈和内部数据，并可以在将来使用它们。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发电机与承诺</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看一下生成器和Promise接口。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span></span><font></font><span class="hljs-class">
</span>{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send</span>(<span class="hljs-params">$data</span>)</span>;<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throw</span>(<span class="hljs-params">\<span class="hljs-built_in">Throwable</span> $error</span>)</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span></span><font></font><span class="hljs-class">
</span>{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">$data</span>)</span>;<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">\<span class="hljs-built_in">Throwable</span> $error</span>)</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它们的外观相同，但方法名称不同。</font><font style="vertical-align: inherit;">我们可以发送数据并向生成器和Promise抛出错误。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如何使用？</font><font style="vertical-align: inherit;">让我们编写一个函数。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recoil</span>(<span class="hljs-params">\<span class="hljs-built_in">Generator</span> $generator</span>)</span><font></font><span class="hljs-function">
</span>{<font></font>
    $promise = $generator-&gt;current();<font></font>
<font></font>
    $promise-&gt;onResolve(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$data</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$generator</span>) </span>{<font></font>
        $generator-&gt;send($data);<font></font>
        recoil($generator);<font></font>
    };<font></font>
<font></font>
    $promise-&gt;onReject(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$error</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$generator</span>) </span>{<font></font>
        $generator-&gt;throw($error);<font></font>
        recoil($generator);<font></font>
    });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该函数获取生成器的当前值：</font></font><code> $promise = $generator-&gt;current();</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我有点夸张了。</font><font style="vertical-align: inherit;">是的，我们必须检查返回给我们的当前值是否是某种</font></font><code>instanceof</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise。</font><font style="vertical-align: inherit;">如果是这样，那么我们可以要求他回电。</font><font style="vertical-align: inherit;">当Promise成功并以递归方式启动该函数时，它将在内部将数据发送回生成器</font></font><code>recoil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="php hljs">    $promise-&gt;onResolve(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$data</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$generator</span>) </span>{<font></font>
        $generator-&gt;send($data);<font></font>
        recoil($generator);<font></font>
    };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以通过错误完成相同的操作。</font><font style="vertical-align: inherit;">例如，如果Promise失败，则SQL服务器说：“连接太多”，那么我们可以将错误抛出到生成器中，然后继续下一步。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有这些将我们带到了协作多任务的重要概念。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合作多任务</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一种多任务处理，其中仅在当前任务显式声明自己准备好为处理器分配时间以执行其他任务之后，才执行下一个任务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我很少遇到简单的事情，例如仅使用一个数据库。通常，在更新用户的过程中，您需要更新数据库中搜索索引中的数据，然后清理或更新缓存，然后再向RabbitMQ发送15条消息。在PHP中，一切看起来都像这样。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m6/w7/5n/m6w75nkbjrduxzynamn9qiinfwm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们一个接一个地执行操作：我们更新了数据库，索引，然后更新了缓存。但是默认情况下，PHP会阻止此类操作（I / O），因此，如果仔细观察，实际上一切都是如此。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wk/3d/wc/wk3dwckb_gjjfnoprw63gxnoxlm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在黑暗的地方，我们封锁了。他们花费最多的时间。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们以异步模式工作，那么这些部分不存在，执行时间线是间歇性的。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qj/mx/xv/qjmxxv9oiwkix-_oebyl48qbio4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以将它们全部粘合在一起，然后一件一件地制作。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t0/o0/x5/t0o0x5ddiw6pij4rlmvzst2oyaq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这都是为了什么？</font><font style="vertical-align: inherit;">如果您看一下时间轴的大小，一开始会花费很多时间，但是一旦我们将其粘合在一起，应用程序就会加速。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事件循环和协作式多任务处理的概念很早就已在各种应用程序中使用：Nginx，Node.js，Memcached和Redis。</font><font style="vertical-align: inherit;">它们都在Event Loop内部使用，并基于相同的原理构建。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自从我们开始讨论Nginx和Node.js Web服务器以来，让我们回想一下如何在PHP中处理请求。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用PHP处理请求</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
浏览器发送一个请求，该请求到达HTTP服务器，该服务器后面有一个FPM流池。</font><font style="vertical-align: inherit;">线程之一将这个请求变为现实，连接我们的代码并开始执行它。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/s1/p_/bgs1p_g8r9ytthxrst0mszi7_bw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当下一个请求到达时，另一个FPM线程将接起它，连接代码并执行它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种工作方案有很多</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优点</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简单的错误处理</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果出现问题，并且其中一个请求失败了，我们不需要做任何事情-下一个请求将会到来，这不会影响其工作。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不考虑记忆</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们不需要清理或监视内存。</font><font style="vertical-align: inherit;">在下一个请求时，将清除所有内存。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个很酷的方案，从一开始就在PHP中起作用，但仍然可以成功工作。</font><font style="vertical-align: inherit;">但是也有</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弊端</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">限制进程数</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果服务器上有50个FPM线程，则第51个请求到达时，它将等待直到其中一个线程变为空闲。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上下文切换的成本</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">操作系统在FPM流之间切换请求。</font><font style="vertical-align: inherit;">此处理器级别的操作称为上下文切换。</font><font style="vertical-align: inherit;">它很昂贵，并采取了大量措施。</font><font style="vertical-align: inherit;">有必要保存所有寄存器，调用堆栈，处理器中的所有内容，然后切换到另一个进程，加载其寄存器和调用堆栈，在那里再次执行某些操作，再次切换，再次保存...很长时间。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们以不同的方式处理这个问题-我们将用PHP本身编写一个HTTP服务器。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步HTTP服务器</font></font></h2><br>
<img src="https://habrastorage.org/webt/nd/dy/yt/nddyyt6dhjy0dxnkmpokppvvcr4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以办到。</font><font style="vertical-align: inherit;">我们已经学习了如何在非阻塞模式下使用套接字，并且HTTP连接是相同的套接字。</font><font style="vertical-align: inherit;">它的外观和工作方式如何？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是在AMPHP框架中启动HTTP服务器的示例。</font></font><br>
<br>
<pre><code class="php hljs">Loop::run(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{<font></font>
    $app = <span class="hljs-keyword">new</span> Application();<font></font>
    $app-&gt;bootstrap();<font></font>
<font></font>
    $sockets = [Socket\listen(<span class="hljs-string">'0.0.0.0:80'</span>)];<font></font>
<font></font>
    $server = <span class="hljs-keyword">new</span> Server($sockets, <span class="hljs-keyword">new</span> CallableRequestHandler(<font></font>
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Request $request</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$app</span>) </span>{<font></font>
            $response = <span class="hljs-keyword">yield</span> $app-&gt;dispatch($request);<font></font>
<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response(Status::OK, [], $response);<font></font>
        })<font></font>
    );<font></font>
<font></font>
    <span class="hljs-keyword">yield</span> $server-&gt;start();<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一切都非常简单：加载</font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并创建一个套接字池（一个或多个）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，我们启动服务器，将其设置为</font></font><code>Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">服务器</font><font style="vertical-align: inherit;">将在每个请求上执行，并将请求发送给我们</font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的服务器以获取响应。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后要做的是启动服务器</font></font><code>yield $server-&gt;start();</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在ReactPHP中，它看起来大致相同，但是只有150个用于不同选项的回调，这不是很方便。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHP中存在一些异步问题。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺乏标准</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。每个框架：Swoole，ReactPHP或AMPHP都实现了自己的Promise接口，并且它们不兼容。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从理论上讲，AMPHP可以与ReactPHP中的Promise进行交互，但是有一个警告。如果用于ReactPHP的代码编写得不太好，并且在某个地方隐式调用或创建了事件循环，那么事实证明两个事件循环将在内部旋转。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript具有实现Guzzle的相对较好的Promises / A +标准。如果框架遵循它，那就太好了。但是到目前为止，还不是。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内存泄漏</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。当我们以常规FPM模式在PHP中工作时，我们可能不会考虑内存。即使某个扩展程序的开发人员忘记编写出色的代码，忘记运行Valgrind并在内存流中的某个位置运行，也没关系-下一个请求将被清除并重新开始。但是在异步模式下，您负担不起，因为迟早我们会掉下去</font></font><code>OutOfMemoryException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以修理，但困难又痛苦。在某些情况下，Xdebug可以帮助strace解析引起的错误</font></font><code>OutOfMemoryException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阻塞操作</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在编写异步代码时，不要阻塞事件循环至关重要。一旦阻塞执行流程，应用程序就会变慢，我们的每个协程都会开始运行得更慢。</font></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kelunik / loop-block</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
软件包将帮助找到AMPHP的此类操作</font><font style="vertical-align: inherit;">。他将计时器设置为非常小的间隔。如果计时器不起作用，那么我们就被堵在某个地方。该程序包有助于查找阻塞位置，但并非总是如此：在某些扩展程序中可能不会注意到阻塞。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库支持：Cassandra，Influx，ClickHouse</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。所有异步PHP的主要问题是对库的支持。我们不能用通常的</font></font><code>PDOConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>RedisClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他司机为</font><font style="vertical-align: inherit;">大家</font><font style="vertical-align: inherit;">-我们需要无阻塞的实现。它们还必须以非阻塞模式用PHP编写，因为C驱动程序很少提供可以集成到异步代码中的接口。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我使用Cassandra数据库驱动程序得到的最奇怪的经历。他们提供操作</font></font><code>ExecuteAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>GetAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等人，但在同一时间，他们返回一个对象</font></font><code>Future</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与单个方法</font></font><code>get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阻止。</font><font style="vertical-align: inherit;">有机会异步获取某些东西，但是要等待结果，我们仍然会阻塞整个循环。</font><font style="vertical-align: inherit;">以某种方式（例如，通过回调）执行此操作无效。</font><font style="vertical-align: inherit;">我什至为Cassandra写了我的客户，因为我们在工作中使用它。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型指示</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是AMPHP和corutin的问题。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span></span><font></font><span class="hljs-class">
</span>{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> $id</span>): \<span class="hljs-title">Generator</span></span><font></font><span class="hljs-function">
    </span>{<font></font>
        $data = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">$this</span>-&gt;db-&gt;query(<span class="hljs-string">'SELECT ...'</span>, $id);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> User::fill($data);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果它出现在function中</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么它将成为生成器。</font><font style="vertical-align: inherit;">在这一点上，我们不能再指定正确的返回数据类型。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP 8</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHP 8等待着我们什么？</font><font style="vertical-align: inherit;">我将告诉您有关我的假设或更确切地说是我的愿望（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编者注：Dmitry Stogov </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">知道</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PHP 8中将实际出现的内容</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件循环 </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它有可能出现，因为正在进行将某种形式的事件循环引入内核的工作。</font><font style="vertical-align: inherit;">如果发生这种情况，我们将有一个函数</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如JavaScript或C＃，它将使我们能够在某个位置等待异步操作的结果。</font><font style="vertical-align: inherit;">在这种情况下，我们不需要任何扩展，一切都将在内核级别异步进行。</font></font><br>
<br>
<pre><code class="php hljs"><font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span></span><font></font><span class="hljs-class">
</span>{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> $id</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">User</span>&gt;</span><font></font><span class="hljs-function">
    </span>{<font></font>
        $data = await <span class="hljs-keyword">$this</span>-&gt;db-&gt;query(<span class="hljs-string">'SELECT ...'</span>, $id);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> User::fill($data);<font></font>
    }<font></font>
}</code></pre><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">泛型 </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go正在等待泛型，我们正在等待泛型，每个人都在等待泛型。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span></span><font></font><span class="hljs-class">
</span>{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> $id</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">User</span>&gt;</span><font></font><span class="hljs-function">
    </span>{<font></font>
        $data = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">$this</span>-&gt;db-&gt;query(<span class="hljs-string">'SELECT ...'</span>, $id);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> User::fill($data);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是我们不是在等待泛型的集合，而是要表明Promise的结果将恰好是User对象。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么要这样？</font></font></h2><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了速度和性能。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP是一种大多数操作都受I / O约束的语言。</font><font style="vertical-align: inherit;">我们很少编写与处理器中的计算紧密相关的代码。</font><font style="vertical-align: inherit;">最可能的是，我们使用套接字：我们需要向数据库发出请求，读取内容，返回响应，发送文件。</font><font style="vertical-align: inherit;">异步允许您加快此类代码的速度。</font><font style="vertical-align: inherit;">如果我们查看1000个请求的平均响应时间，则可以将速度提高8倍，将10,000个请求的速度提高近6倍！</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2020年5月13日，我们将第二次聚集在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP俄罗斯</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，讨论该语言，库和框架，提高生产率的方式以及炒作解决方案的陷阱。</font><font style="vertical-align: inherit;">我们已经接受了前4 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">份报告</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是征文通知仍在进行中。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果你想与社区分享您的体验。</font></font></blockquote></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN487258/">https://habr.com/ru/post/zh-CN487258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN487246/index.html">Tensor认证中心可能会破坏客户私钥</a></li>
<li><a href="../zh-CN487248/index.html">有关不正确测试的更多信息</a></li>
<li><a href="../zh-CN487250/index.html">延迟Alpha混合</a></li>
<li><a href="../zh-CN487254/index.html">如何使用CCTV摄像机不仅监视入侵者</a></li>
<li><a href="../zh-CN487256/index.html">燃烧并从灰烬或凤凰城人那里回来</a></li>
<li><a href="../zh-CN487260/index.html">NoVerify：一个运行良好的PHP linter</a></li>
<li><a href="../zh-CN487262/index.html">公开会议PHP俄罗斯在线</a></li>
<li><a href="../zh-CN487266/index.html">GitLab 12.7随父子管道和Windows常用作业处理程序的beta版一起发布</a></li>
<li><a href="../zh-CN487270/index.html">钙钛矿可以延长小工具屏幕的寿命</a></li>
<li><a href="../zh-CN487272/index.html">书签-计数结束</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>