<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🌾 🖲️ 🌶️ Nous étudions les opérateurs RxJS multicast 💡 🐸 👨‍👩‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous présente la traduction de l'article "Comprendre les opérateurs de multidiffusion RxJS" par Netanel Basal. 
 
 Les opérateurs de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Nous étudions les opérateurs RxJS multicast</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490988/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, Habr! </font><font style="vertical-align: inherit;">Je vous présente la traduction de l'article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Comprendre les opérateurs de multidiffusion RxJS"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> par Netanel Basal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les opérateurs de diffusion ou de multidiffusion semblent souvent être le sujet le plus difficile à apprendre sur RxJS. </font><font style="vertical-align: inherit;">Dans cet article, je vais essayer de tout expliquer de manière accessible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous considérerons la structure interne des opérateurs de multidiffusion et les tâches qu'ils résolvent.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons par décrire les blocs de construction de base de RxJS.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observable</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans RxJS, les objets observables (ci-après dénommés «flux») sont initialement froids. Cela signifie que chaque fois que vous vous abonnez à un flux, un rappel de l'abonnement est effectué. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour une meilleure compréhension, créez l'implémentation suivante:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observable</span> </span>{
  <span class="hljs-keyword">constructor</span>(subscriptionFn) {
    <span class="hljs-keyword">this</span>.subscriptionFn = subscriptionFn;<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.subscriptionFn(observer);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le constructeur </font></font><code>Observable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accepte un seul paramètre - le rappel de l'abonnement </font></font><br>
 <code>subscriptionFn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il sera appelé chaque fois que nous nous abonnerons au stream ( </font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parfois, ils appellent un rappel d'un abonnement </font></font><code>producer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car cela «produit» également des valeurs pour l'abonné (l'objet observateur dans notre code). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La méthode </font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend une entrée </font></font><code>observer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il est un objet avec trois méthodes propres: </font></font><code>next(), error(), complete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dans RxJS en direct, vous pouvez passer trois fonctions au lieu d'un objet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La méthode, </font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsqu'elle est appelée, appelle la fonction d'abonnement en la passant à l'entrée </font></font><code>observer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous n'avons pas mentionné la méthode maintenant</font></font><code>unsubscribe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais il ne faut pas oublier que chaque abonnement permet de le détruire. </font><font style="vertical-align: inherit;">Le plus souvent, un abonnement renvoie une fonction (ou un objet avec la méthode appropriée), au cours de laquelle la connexion entre le flux et ses abonnés est détruite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout cela est assez simple. </font><font style="vertical-align: inherit;">Rapprochez-vous de la réalité maintenant. </font><font style="vertical-align: inherit;">Par exemple, encapsuler une API XHR native dans un flux</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">http</span>(<span class="hljs-params">url</span>) </span>{
  <span class="hljs-comment">// This function will be called when we call http().subscribe()</span>
  <span class="hljs-keyword">const</span> subscriptionFn = <span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> {<font></font>
    log(<span class="hljs-string">'Observable execution: http'</span>);
    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<font></font>
    xhr.addEventListener(<span class="hljs-string">'load'</span>, () =&gt; {
      <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span> &amp;&amp; xhr.status === <span class="hljs-number">200</span>) {<font></font>
        observer.next(<span class="hljs-built_in">JSON</span>.parse(xhr.responseText));<font></font>
        observer.complete();<font></font>
      }<font></font>
    });<font></font>
    xhr.open(<span class="hljs-string">'GET'</span>, url);<font></font>
    xhr.send();<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> xhr.abort()<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(subscriptionFn);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons écrit une fonction </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui reçoit une URL, exécute une demande http et renvoie un flux qui émet la réponse http reçue. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, en regardant notre implémentation, que pensez-vous qu'il se passera lorsque nous nous abonnerons à ce flux deux fois?</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-comment">// A small observer helper</span>
<span class="hljs-keyword">const</span> observer = <span class="hljs-function"><span class="hljs-params">tag</span> =&gt;</span> ({<font></font>
  next(value) {<font></font>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${tag}</span>:`</span>, value);<font></font>
  }<font></font>
});<font></font>
<font></font>
http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .subscribe(observer(<span class="hljs-string">'subscriber-1'</span>));<font></font>
<font></font>
http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .subscribe(observer(<span class="hljs-string">'subscriber-2'</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Correctement, deux requêtes http seront exécutées. </font><font style="vertical-align: inherit;">Si nous regardons à nouveau l'implémentation de la classe Observable, nous verrons pourquoi il en est ainsi. </font><font style="vertical-align: inherit;">Chaque abonné appelle un rappel d'abonnement, qui à son tour effectue une demande http à chaque fois.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ay/by/ee/aybyeesbyfdzvcjcp3etc8jhfww.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les opérateurs</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un opérateur est une fonction qui prend un flux en entrée, effectue n'importe quelle action et renvoie un flux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous écrirons notre premier opérateur.</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">source</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> {<font></font>
      log(<span class="hljs-string">'Observable execution: map'</span>);
      <span class="hljs-keyword">return</span> source.subscribe({<font></font>
        next(value) {<font></font>
          observer.next(fn(value));<font></font>
        }<font></font>
      });<font></font>
    });<font></font>
  };<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction </font></font><code>map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoie un opérateur qui accepte le flux d'origine et retourne un flux dans lequel toutes les valeurs de passage seront transmises via la fonction </font></font><code>fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceux. </font><font style="vertical-align: inherit;">à l'intérieur, il y a toujours un abonnement au flux d'entrée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant d'utiliser ce nouvel opérateur, nous devons l'attacher en quelque sorte au flux. </font><font style="vertical-align: inherit;">Prolongez notre classe </font></font><code>Observable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en</font></font><code>pipe()</code><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observable</span> </span>{
  <span class="hljs-keyword">constructor</span>(subscriptionFn) {
    <span class="hljs-keyword">this</span>.subscriptionFn = subscriptionFn;<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.subscriptionFn(observer);<font></font>
  }<font></font>
<font></font>
  pipe(...operators) {<font></font>
    <span class="hljs-keyword">return</span> operators.reduce(<span class="hljs-function">(<span class="hljs-params">source, next</span>) =&gt;</span> next(source), <span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une méthode simple, une seule ligne de code. </font></font><code>pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il prend un tableau d'opérateurs et les appelle à son tour, en passant à chaque entrée le résultat de la précédente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilisons notre opérateur:</font></font><br>
<br>
<pre><code class="javascript hljs">http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .pipe(map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">0</span>]))<font></font>
  .subscribe(observer(<span class="hljs-string">'subscriber'</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsqu'il est appelé </font></font><code>subscribe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, un abonnement au flux de sortie sera exécuté </font></font><code>map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et à son tour </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, un abonnement au flux d'origine sera exécuté à l' </font><font style="vertical-align: inherit;">intérieur </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le flux http émet la valeur dans laquelle il tombe </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ensuite, la fonction est exécutée </font></font><code>fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le flux de </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">émet la valeur vers l'abonnement final. </font><font style="vertical-align: inherit;">Cela fonctionne comme une </font></font><code>observable chain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaîne de fils. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/4a/ou/8r/4aou8rffl-aqkm6asdvs2224n84.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous souscrivons à une chaîne deux fois, chaque abonnement de la chaîne sera appelé deux fois.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> firstUser$ = http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
    .pipe(map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">0</span>]));<font></font>
<font></font>
firstUser$.subscribe(observer(<span class="hljs-string">'subscriber-1'</span>));<font></font>
firstUser$.subscribe(observer(<span class="hljs-string">'subscriber-2'</span>));
</code></pre><br>
<img src="https://habrastorage.org/webt/kg/c2/iw/kgc2iwjualmgnqh_kcaxfe4c45g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et si ce comportement ne nous convient pas? </font><font style="vertical-align: inherit;">Si nous voulons appeler la fonction d'abonnement une seule fois, combien d'abonnements aurions-nous? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, que se passe-t-il si nous voulons faire une seule requête http et utiliser le résultat pour tous les abonnés? </font><font style="vertical-align: inherit;">Dans ce cas, vous en avez besoin </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sujets</font></font></h2><br>
<code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c'est à la fois un flux et un abonné. </font><font style="vertical-align: inherit;">Le flux - parce qu'il a une méthode </font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, l'abonné - parce qu'il implémente l'interface d'abonné - méthodes </font></font><code>next(), error(), complete().</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Écrivons-le.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.observers = [];<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">this</span>.observers.push(observer);<font></font>
  }<font></font>
<font></font>
  next(value) {<font></font>
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.next(value));<font></font>
  }<font></font>
<font></font>
  error(error) {<font></font>
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.error(error));<font></font>
  }<font></font>
<font></font>
  complete() {<font></font>
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.complete());<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
<code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut servir d'intermédiaire entre le flux froid et de nombreux abonnés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modifiez notre exemple comme suit:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> Subject();<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber1'</span>));<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber2'</span>));<font></font>
<font></font>
http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .pipe(map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">0</span>]))<font></font>
  .subscribe(subject);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsqu'elle est appelée </font></font><code>subject.subscribe(someFn)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, une seule opération simple est effectuée - ajouter une </font></font><code>subject.observers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonction </font><font style="vertical-align: inherit;">au tableau </font></font><code>someFn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, comme il </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se comporte également comme un abonné, vous pouvez le souscrire au flux d'origine, c'est-à-dire </font><font style="vertical-align: inherit;">lorsque le thread d'origine émet une valeur, elle est appelée </font></font><code>subject.next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui entraîne le transfert de cette valeur à chacun des abonnés </font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons maintenant le rappel d'origine de l'abonnement exécuté une seule fois, et une seule requête http sera exécutée.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hk/8h/ld/hk8hld-xyjtum5d3srqpquhaqic.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les retardataires du parti</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que se passe-t-il si le flux d'origine a déjà fonctionné avant notre inscription? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il ne sera pas possible de le montrer dans l'exemple précédent, car http est asynchrone, même si vous vous y abonnez immédiatement après, la valeur viendra toujours après l'abonnement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créons rapidement une fonction génératrice </font></font><code>of</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">of</span>(<span class="hljs-params">...values</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> {<font></font>
    log(<span class="hljs-string">'Observable execution: of'</span>);<font></font>
    values.forEach(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> observer.next(value));<font></font>
  });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un flux créé par moyen </font></font><code>of()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">émet des valeurs de manière synchrone, l'une après l'autre. </font><font style="vertical-align: inherit;">Nous nous abonnerons </font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">après qu'il a déjà souscrit à.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> Subject();
<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).subscribe(subject);<font></font>
<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber1'</span>));<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber2'</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos abonnés n'ont rien reçu. Pourquoi? Notre implémentation ne prend pas en charge les abonnés «tardifs». Lorsque le flux d'origine </font></font><code>of()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">émet des valeurs, les abonnés ne sont pas encore enregistrés, ces valeurs n'iront nulle part. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans des exemples réels sur Angular, il se pourrait bien que le flux source ait fonctionné, mais votre composant n'est pas encore présent sur la page. Et lorsque le composant apparaît, il s'abonne à la source, mais ne reçoit pas les valeurs qui ont déjà été transmises. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une façon de résoudre le problème est la suivante </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nous décrivons sa version et voyons comment cela fonctionne.</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReplaySubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span> </span>{
  <span class="hljs-keyword">constructor</span>(bufferSize) {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.observers = [];
    <span class="hljs-keyword">this</span>.bufferSize = bufferSize;
    <span class="hljs-keyword">this</span>.buffer = [];<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">this</span>.buffer.forEach(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> observer.next(val));
    <span class="hljs-keyword">this</span>.observers.push(observer);<font></font>
  }<font></font>
<font></font>
  next(value) {<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.buffer.length === <span class="hljs-keyword">this</span>.bufferSize) {
      <span class="hljs-keyword">this</span>.buffer.shift();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">this</span>.buffer.push(value);
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.next(value));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le concept est simple. Comme son nom l'indique, </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">celui-ci est spécial </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et peut reproduire les anciennes valeurs à tous les nouveaux abonnés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque valeur publiée sera transférée à tous les abonnés actuels et enregistrée pour les futurs, la taille de la mémoire tampon est </font></font><code>bufferSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">définie dans le constructeur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Réécrivez l'exemple précédent avec </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> ReplaySubject(<span class="hljs-number">3</span>);
<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).subscribe(subject);<font></font>
<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber1'</span>));<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber2'</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le résultat a changé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malgré l'abonnement tardif, nous les avons tous pris. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sg/xv/y1/sgxvy1flevy8totuzlejeiphvm0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En résumé, le but </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est la distribution de valeurs à tous les abonnés et leur mise en cache pour les futurs abonnés "tardifs". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de continuer, je vous recommande d'essayer d'écrire votre propre implémentation </font></font><code>BehaviorSubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vous pouvez trouver le code fini à la fin de l'article. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous passons enfin aux opérateurs de multidiffusion. </font><font style="vertical-align: inherit;">J'espère que les exemples ci-dessus vous aideront à les comprendre plus rapidement.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opérateurs de multidiffusion</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multidiffusion et connexion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'opérateur </font></font><code>multicast() </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilise </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour envoyer le flux source à plusieurs abonnés.</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-keyword">import</span> { interval, Subject, ConnectableObservable } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { multicast } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-keyword">new</span> Subject())<font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">const</span> observer1 = connectableObservable.subscribe(log);
<span class="hljs-keyword">const</span> observer2 = connectableObservable.subscribe(log);<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectableSubscription = (connectableObservable <span class="hljs-keyword">as</span> ConnectableObservable&lt;any&gt;)<font></font>
  .connect();<font></font>
</code></pre><br>
<code>multicast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoie un objet </font></font><code>ConnectableObservable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui a une méthode </font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Son but est de signer le sujet reçu dans le flux source. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La méthode </font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous permet de déterminer quand démarrer l'exécution du thread d'origine. </font><font style="vertical-align: inherit;">Il y a un moment à garder à l'esprit - pour vous désabonner de la source, vous devez faire:</font></font><br>
<br>
<pre><code class="javascript hljs">connectableSubscription.unsubscribe();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous ne sommes pas limités au simple </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au lieu de cela, vous pouvez utiliser n'importe quelle classe dérivée, par exemple </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { interval, ReplaySubject, ConnectableObservable } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { multicast } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-keyword">new</span> ReplaySubject(<span class="hljs-number">1</span>))<font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">const</span> observer1 = connectableObservable.subscribe(log);<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Late subscriber</span><font></font>
  connectableObservable.subscribe(log);<font></font>
}, <span class="hljs-number">3000</span>)<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectable = (connectableObservable <span class="hljs-keyword">as</span> ConnectableObservable&lt;any&gt;).connect();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À partir de ce code, vous pouvez deviner ce qui se passera sous le capot. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque nous utilisons </font></font><code>multicast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous pouvons transférer non seulement </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais aussi une fonction d'usine, qui renvoie une nouvelle à chaque fois </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Réutilisé déjà terminé </font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne peut pas l'être, la fonction d'usine résout ce problème.</font></font><br>
<br>
<pre><code class="javascript hljs">interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> Subject())<font></font>
)<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refount</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque nous utilisons l'opérateur </font></font><code>multicast()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous sommes responsables de l'appel </font></font><code>connect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour commencer l'exécution de l'observable d'origine. </font><font style="vertical-align: inherit;">De plus, nous devons toujours surveiller les éventuelles fuites de mémoire, en vous désinscrivant manuellement </font></font><code>ConnectableSubscription</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'automatisation du processus éviterait les erreurs et simplifierait le code. </font><font style="vertical-align: inherit;">Les aimables développeurs RxJS y ont pensé et ont créé un </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opérateur. </font></font><br>
<br>
<code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compte les abonnements et lorsque le premier apparaît, il appelle </font></font><code>connect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, c'est-à-dire </font><font style="vertical-align: inherit;">s'abonne. </font><font style="vertical-align: inherit;">Quand il revient à zéro, une réponse sera appelée.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-keyword">new</span> Subject()),<font></font>
  refCount()<font></font>
)<font></font>
 <font></font>
<span class="hljs-comment">// refCount === 1 =&gt; source.subscribe();</span>
<span class="hljs-keyword">const</span> observer1 = source.subscribe(log);<font></font>
<font></font>
<span class="hljs-comment">// refCount === 2</span>
<span class="hljs-keyword">const</span> observer2 = source.subscribe(log);<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// refCount - 1</span><font></font>
  observer1.unsubscribe();<font></font>
  <span class="hljs-comment">// refCount - 1</span><font></font>
  observer2.unsubscribe();<font></font>
  <span class="hljs-comment">// refCount === 0 =&gt; source.unsubcribe();</span>
}, <span class="hljs-number">3000</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notez qu'après avoir </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obtenu l'observable habituel, non </font></font><code>ConnectableObservable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Publier et ses variantes</font></font></h3><br>
<code>multicast() + Subject + refCount()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c'est un cas assez typique dans RxJS et les développeurs l'ont réduit à un seul opérateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons quelles options nous avons.</font></font><br>
<br>
<ul>
<li><code>publish()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> équivalent </font></font><code>multicast(() =&gt; new Subject())</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publish()<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>publishBehavior()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> équivalent </font></font><code>multicast(new BehaviorSubject())</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publishBehavior(<span class="hljs-number">100</span>)<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>publishReplay()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> équivalent </font></font><code>multicast(() =&gt; new ReplaySubject(x))</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publishReplay(<span class="hljs-number">3</span>)<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>publishLast()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> équivalent </font></font><code>multicast(new AsyncSubject())</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  take(<span class="hljs-number">2</span>),<font></font>
  publishLast()<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>share()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> équivalent </font></font><code>multicast(() =&gt; new Subject()) + refCount()</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  share()<font></font>
)<font></font>
</code></pre><br>
</li>
<li><code>shareReplay(bufferSize) </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit d'un opérateur de multidiffusion qui utilise </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il n'a pas à l'intérieur </font></font><code>multicast()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et son résultat est observable, non </font></font><code>ConnectableObservable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il peut être utilisé avec </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou sans. </font><font style="vertical-align: inherit;">Voici les deux options:</font></font><br>
<br>
<pre><code class="javascript hljs">interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  shareReplay({ <span class="hljs-attr">refCount</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bufferSize</span>: <span class="hljs-number">1</span> })<font></font>
)<font></font>
<font></font>
interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  shareReplay(<span class="hljs-number">1</span>)<font></font>
)<font></font>
</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsqu'il est </font></font><code>shareReplay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appelé avec, </font></font><code>{ refCount: false }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c'est comme appeler </font></font><code>shareReplay(x)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, il n'y aura pas de comptage de références. </font><font style="vertical-align: inherit;">Cela signifie que jusqu'à ce que le flux d'origine soit terminé, il </font></font><code>shareReplay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y sera abonné, qu'il ait lui-même ou non les abonnés finaux. </font><font style="vertical-align: inherit;">Tous les nouveaux abonnés recevront les dernières valeurs x.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shareReplay vs publishReplay + refCount</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À première vue </font><font style="vertical-align: inherit;">, c'est </font></font><code>shareReplay({ refCount: true, bufferSize: X })</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">identique </font></font><code>publishReplay(X) + refCount() </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais ce n'est pas tout à fait vrai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons quelles sont les similitudes et quelle est la différence. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ils ont le même comportement </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- s'abonner et se désinscrire du flux d'origine en fonction du nombre d'abonnés. </font><font style="vertical-align: inherit;">Ils réagissent également de la même manière lorsque le flux d'origine est terminé - tous les nouveaux abonnés reçoivent X dernières valeurs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, si le flux d'origine n'est pas encore finalisé, dans ce cas où nous l'avons </font></font><code>publishReplay(X) + refCount()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- tous les nouveaux abonnés reçoivent des valeurs X du tampon, puis seront re-signés en utilisant le même </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais si nous utilisons les </font></font><code>shareReplay({ refCount: true, bufferSize: 1 })</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dernières valeurs X, ils ne les obtiendront pas, car à l'intérieur, il en crée une </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nouvelle</font></font></i> <code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et l'utilise pour se réabonner à la source.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exemples illustrant cela:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publishReplay(<span class="hljs-number">1</span>),<font></font>
  refCount()<font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">const</span> one = source.subscribe(observer(<span class="hljs-string">'subcriber-1'</span>));<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
  one.unsubscribe();<font></font>
 <font></font>
  <span class="hljs-comment">// This subscriber will get the last emitted values from the source</span>
  <span class="hljs-keyword">const</span> two = source.subscribe(observer(<span class="hljs-string">'subcriber-2'</span>));<font></font>
}, <span class="hljs-number">3000</span>);</code></pre><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  shareReplay({ <span class="hljs-attr">refCount</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bufferSize</span>: <span class="hljs-number">1</span> })<font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">const</span> one = source.subscribe(observer(<span class="hljs-string">'subcriber-1'</span>));<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
  one.unsubscribe();<font></font>
  <font></font>
  <span class="hljs-comment">// This subscriber will NOT get the last emitted values from the source</span>
  <span class="hljs-keyword">const</span> two = source.subscribe(observer(<span class="hljs-string">'subcriber-2'</span>));<font></font>
}, <span class="hljs-number">3000</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/6i/j1/ih/6ij1ihusgtdo_avliuz4tk4gsca.png"><br>
<br>
<img src="https://habrastorage.org/webt/ew/nk/6q/ewnk6q0ems5ysw574aa7unvy2jc.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemples réels en angulaire</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment utiliser les opérateurs de multidiffusion étudiés dans des conditions de combat.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons le partage</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que nous ayons un composant qui a besoin de données du flux d'origine. </font><font style="vertical-align: inherit;">Cela peut être une requête http, un état ou autre. </font><font style="vertical-align: inherit;">Et nous avons également besoin de manipulation de données, comme le filtrage, le tri, etc.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;users-list [users]="allUsers$ | async"&gt;&lt;/users-list&gt;
  `</span>,<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersPageComponent</span> </span>{
  <span class="hljs-attr">allUsers$</span>: Observable&lt;User[]&gt;;<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {<font></font>
  }<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">this</span>.allUsers$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://api/users'</span>).pipe(<font></font>
      map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> filter/sort),<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant, nous avons besoin d'un autre composant qui ne montre que le premier utilisateur. </font><font style="vertical-align: inherit;">Si nous nous abonnons au flux source tel quel, alors:</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;user [user]="firstUser$ | async"&gt;&lt;/user&gt;
    &lt;users-list [users]="allUsers$ | async"&gt;&lt;/users-list&gt;
  `</span>,<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersPageComponent</span> </span>{
  <span class="hljs-attr">allUsers$</span>: Observable&lt;User[]&gt;;<font></font>
  firstUser$: Observable&lt;User&gt;;<font></font>
  <font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {<font></font>
  }<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">this</span>.allUsers$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://api/users'</span>).pipe(<font></font>
      map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> filter/sort),<font></font>
    );<font></font>
    <font></font>
    <span class="hljs-keyword">this</span>.firstUser$ = <span class="hljs-keyword">this</span>.allUsers$.pipe(map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> users[<span class="hljs-number">0</span>]));<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant nous avons deux requêtes http, les opérations de tri ou de filtrage seront effectuées deux fois. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous appliquons </font></font><code>share</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;user [user]="firstUser$ | async"&gt;&lt;/user&gt;
    &lt;users-list [users]="allUsers$ | async"&gt;&lt;/users-list&gt;
  `</span>,<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersPageComponent</span> </span>{
  <span class="hljs-attr">allUsers$</span>: Observable&lt;User[]&gt;;<font></font>
  firstUser$: Observable&lt;User&gt;;<font></font>
  <font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {<font></font>
  }<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">this</span>.allUsers$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://api/users'</span>).pipe(<font></font>
      map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> filter/sort),<font></font>
      share()<font></font>
    );<font></font>
    <font></font>
    <span class="hljs-keyword">this</span>.firstUser$ = <span class="hljs-keyword">this</span>.allUsers$.pipe(map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> users[<span class="hljs-number">0</span>]));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous savons déjà qu'il en crée un nouveau </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui s'abonne à la source. </font><font style="vertical-align: inherit;">Lorsque la source émet, le sujet transmet cette valeur à tous ses abonnés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le problème est résolu, et lorsque nous nous sommes abonnés à </font></font><code>firstUser$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- nous nous sommes abonnés au </font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flux </font><font style="vertical-align: inherit;">interne </font><font style="vertical-align: inherit;">, et non directement au flux d'origine.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation de ShareReplay</font></font></h3><br>
<code>ShareReplay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s'applique lorsque vous devez émettre, mettre en cache et répéter les dernières valeurs X. </font><font style="vertical-align: inherit;">Un exemple typique est un service singleton qui exécute une requête http.</font></font><br>
<br>
<pre><code class="javascript hljs">
@Injectable({ <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlogService</span> </span>{<font></font>
  posts$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://jsonplaceholder.typicode.com/posts'</span>)<font></font>
              .pipe(shareReplay(<span class="hljs-number">1</span>));<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peu importe le nombre de composants qui demanderont des données maintenant ou à l'avenir, il n'y aura qu'une seule demande http et le résultat sera enregistré dans le tampon interne </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il peut toujours y avoir un cas où vous devez annuler une demande incomplète, car il n'y a pas d'abonnés, vous devrez alors postuler </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code complet peut être trouvé </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr490976/index.html">Section frontend sur DUMP2020: nous préviendrons qu'il y aura à nouveau un full. Top rapports de l'année dernière et sujets de cette</a></li>
<li><a href="../fr490978/index.html">Envoyer des commandes à plusieurs appareils en même temps à l'aide de SecureCRT</a></li>
<li><a href="../fr490982/index.html">Mauvais conseils à l'employeur. Comment interagir "correctement" avec le développeur</a></li>
<li><a href="../fr490984/index.html">Matériaux de la mitap Android Nizhny Novgorod. MotionLayout, Kotlin Coroutines, infrastructure CI / CD et systèmes de conception</a></li>
<li><a href="../fr490986/index.html">Test des processeurs AMD Ryzen pour fonctionner avec KOMPAS-3D</a></li>
<li><a href="../fr490992/index.html">Gestion des remises de prix: modèles de quantification de l'effet des stations-service à titre d'exemple</a></li>
<li><a href="../fr490996/index.html">STOP RESCUE! Instructions pour l'auto-assemblage du "masque médical"</a></li>
<li><a href="../fr490998/index.html">Test de matériel dans SIBUR</a></li>
<li><a href="../fr491000/index.html">Option de sélection de style (presque) sans JavaScript</a></li>
<li><a href="../fr491006/index.html">Intel NUC comme passe dans Unity3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>