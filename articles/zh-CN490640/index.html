<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♨️ ⛔️ 🤴🏼 C ++中的重载。第三部分 重载新/删除语句 👨‍🏭 🤘🏽 ♐️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们继续“深入探索C ++”系列。本系列文章的目的是尽可能多地告诉您该语言的各种功能，可能很特殊。本文是关于运算符重载的new/delete。这是本系列的第三篇文章，第一篇专门讨论重载函数和模板，位于此处，第二篇专门研究重载运算符，位于此处。本文总结了有关C ++重载的三篇文章。
 
 目录
 目录...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C ++中的重载。第三部分 重载新/删除语句</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490640/"><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们继续“深入探索C ++”系列。</font><font style="vertical-align: inherit;">本系列文章的目的是尽可能多地告诉您该语言的各种功能，可能很特殊。</font><font style="vertical-align: inherit;">本文是关于运算符重载的</font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是本系列的第三篇文章，第一篇专门讨论重载函数和模板，位于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，第二篇专门研究重载运算符，位于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">本文总结了有关C ++重载的三篇文章。</font></font><br>
<hr><a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目录</font></font></h1><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目录</font></font></b><div class="spoiler_text">&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.    new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.1.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.3.     </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.1.     </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.2.1.      new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.2.2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.2.3.  </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.2.4. </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.2.5.    operator delete()</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.   new/delete</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.    </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5. -  </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a><br>
</div></div><br>
<a name="id-1"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.新/删除运算符的标准格式</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++支持多种运算符选项</font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它们可以分为基本标准，附加标准和自定义。</font><font style="vertical-align: inherit;">本节和第2节讨论标准格式；自定义格式将在第3节中讨论。</font></font><br>
<br>
<a name="id-1-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1。</font><font style="vertical-align: inherit;">基本标准表格</font></font></h2><br><font style="vertical-align: inherit;"></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建和删除对象以及类型的数组时使用</font><font style="vertical-align: inherit;">
的运算符的主要标准格式</font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如下：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span> T[<span class="hljs-comment">/*   */</span>]
<span class="hljs-keyword">delete</span> ptr;
<span class="hljs-keyword">delete</span>[] ptr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他们的工作可以描述如下。调用运算符时</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，首先将内存分配给该对象。如果选择成功，则调用构造函数。如果构造函数引发异常，则释放分配的内存。当调用运算符时，</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一切都以相反的顺序发生：首先，调用析构函数，然后释放内存。析构函数不应引发异常。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当操作员</font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于创建对象数组时，首先为整个数组分配内存。如果选择成功，则从零开始为数组的每个元素调用默认构造函数（或另一个构造函数，如果有初始化程序）。如果任何构造函数引发异常，则对于所有创建的数组元素，以构造函数调用的相反顺序调用析构函数，然后释放分配的内存。要删除数组，必须调用operator </font></font><code>delete[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且对于数组的所有元素，将以构造函数的相反顺序调用析构函数，然后释放分配的内存。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意！必须调用正确的运算符形式</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取决于是删除单个对象还是数组。必须严格遵守此规则，否则您将获得未定义的行为，即可能发生任何事情：内存泄漏，崩溃等。有关详细信息，请参见[Meyers1]。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在以上描述中，需要进行澄清。对于所谓的琐碎类型（内置类型，C样式结构），可能不会调用默认构造函数，并且在任何情况下析构函数都不会执行任何操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当无法满足请求时，标准内存分配函数将引发类型异常</font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是可以捕获此异常，为此您需要使用函数调用安装全局拦截器</font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，有关更多详细信息，请参见[Meyers1]。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
任何形式的运算符</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全地应用于null指针。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用运算符创建数组时，</font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大小可以设置为零。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
两种形式的运算符都</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许在括号中使用初始化程序。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>{<span class="hljs-number">42</span>}
<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>]{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>}</code></pre><br>
<a name="id-1-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2。</font><font style="vertical-align: inherit;">附加标准表格</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
连接头文件时</font></font><code>&lt;new&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，可以使用另外4种标准运算符形式</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(ptr) T(<span class="hljs-comment">/*  */</span>);
<span class="hljs-keyword">new</span>(ptr) T[<span class="hljs-comment">/*   */</span>];
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T(<span class="hljs-comment">/*   */</span>);
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T[<span class="hljs-comment">/*   */</span>];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其中的前两个称为</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非分配放置</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。参数</font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是指向足以容纳实例或数组的内存区域的指针。另外，存储区域必须具有适当的对齐方式。此版本的运算符</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不分配内存；它仅提供对构造函数的调用。因此，此选项允许您将内存分配和对象初始化阶段分开。此功能已在标准容器中积极使用。</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，不能调用以这种方式创建的对象</font><font style="vertical-align: inherit;">的运算符</font><font style="vertical-align: inherit;">。要删除对象，必须直接调用析构函数，然后以一种依赖于分配内存方法的方式释放内存。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
后两个选项称为不抛出异常的操作符</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（nothrow </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），不同之处在于如果无法满足请求，它们将返回</font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但不会抛出类型异常</font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用main运算符删除对象</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这些选项被认为已过时，不建议使用。</font></font><br>
<br>
<a name="id-1-3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3。</font><font style="vertical-align: inherit;">内存分配和自由功能</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
标准形式的运算符</font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用以下分配和解除分配功能：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些函数在全局名称空间中定义。</font><font style="vertical-align: inherit;">主机语句的内存分配功能</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不执行任何操作，仅返回即可</font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 17支持内存分配和释放函数的其他形式，指示对齐。</font><font style="vertical-align: inherit;">这里是其中的一些：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用户无法直接访问这些表格，编译器将其用于对齐要求超过的对象</font></font><code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此，主要问题在于用户不会意外隐藏它们（请参阅第2.2.1节）。</font><font style="vertical-align: inherit;">回想一下，在C ++ 11中，可以显式设置用户类型的对齐方式。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">struct <span class="hljs-title">alignas</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span> X </span>{ <span class="hljs-comment">/* ... */</span> };</code></pre><br>
<a name="id-2"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.重载新/删除运算符的标准格式</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重载标准形式的运算符</font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包括定义用户定义的函数，这些函数用于分配和释放其签名与标准签名一致的内存。</font><font style="vertical-align: inherit;">这些函数可以在全局名称空间或类中定义，但不能在全局名称空间之外定义。</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能在全局名称空间中定义</font><font style="vertical-align: inherit;">标准主机语句的内存分配功能</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">经过这样的定义，相应的运算符</font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将使用它们，而不是标准的</font><font style="vertical-align: inherit;">运算符</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="id-2-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1。</font><font style="vertical-align: inherit;">全局命名空间中的重载</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，假设在全局名称空间的模块中定义了用户定义的函数：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
</span>{
<span class="hljs-comment">// ...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，实际上将替换（替换）标准函数，以便为</font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整个模块中任何类（包括标准类）的</font><font style="vertical-align: inherit;">所有操作员调用分配和释放内存</font><font style="vertical-align: inherit;">。这可能导致完全混乱。注意，所描述的替换机制是仅针对这种情况实现的特殊机制，而不是某些常规的C ++机制。在这种情况下，当实现用于分配和释放内存的用户函数时，将无法调用相应的标准函数，它们被完全隐藏（操作员</font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无济于事），并且当您尝试调用它们时，将对用户函数进行递归调用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全局命名空间定义函数</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它也将取代标准的，但是潜在的问题会更少，因为</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很少使用</font><font style="vertical-align: inherit;">不会抛出异常的运算符</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是标准形式也不可用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与数组函数相同的情况。</font><font style="vertical-align: inherit;">强烈建议不要在全局名称空间中</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重载语句</font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="id-2-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2。</font><font style="vertical-align: inherit;">类重载</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
类中的重载运算符</font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有上述缺点。</font><font style="vertical-align: inherit;">重载仅在创建和删除相应类的实例时才有效，而与调用operator的上下文无关</font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用操作员实现用户定义的函数来分配和释放内存时，</font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以访问相应的标准函数。</font><font style="vertical-align: inherit;">考虑一个例子。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span>
{</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete\n"</span>;<font></font>
        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(ptr)</span></span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new[]\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete[]\n"</span>;<font></font>
        ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](ptr);<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此示例中，仅将跟踪添加到标准操作中。</font><font style="vertical-align: inherit;">现在来讲</font></font><code>new X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>new X[N]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将使用这些函数来分配和释放内存。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些函数在形式上是静态的，可以声明为</font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是从本质上讲，它们是实例，通过函数调用</font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，实例的创建开始，并且函数调用</font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成其删除。</font><font style="vertical-align: inherit;">这些功能从不用于其他任务。</font><font style="vertical-align: inherit;">此外，如下所示，该功能</font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实质上是虚拟的。</font><font style="vertical-align: inherit;">因此，将它们声明为不更正确</font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="id-2-2-1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1。</font><font style="vertical-align: inherit;">访问新/删除运算符的标准格式</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
运算符</font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以与其他范围解析运算符一起使用，例如</font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在这种情况下，</font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将忽略类中定义</font><font style="vertical-align: inherit;">的函数</font><font style="vertical-align: inherit;">，并使用相应的标准。</font><font style="vertical-align: inherit;">同样，您可以使用运算符</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="id-2-2-2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2。</font><font style="vertical-align: inherit;">隐藏其他形式的new / delete运算符</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果现在对于该类，</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们尝试使用抛出异常或不抛出异常</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则会出现错误。</font><font style="vertical-align: inherit;">事实是该函数</font></font><code>operator new(std::size_t size)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将隐藏其他形式</font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该问题可以通过两种方式解决。</font><font style="vertical-align: inherit;">首先，您需要向类添加适当的选项（这些选项应仅委派标准函数的操作）。</font><font style="vertical-align: inherit;">在第二个中，您需要将一个运算符</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与一个范围解析运算</font><font style="vertical-align: inherit;">符</font><font style="vertical-align: inherit;">一起</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">，例如</font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="id-2-2-3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3。</font><font style="vertical-align: inherit;">标准容器</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">如果尝试将实例放置</font><font style="vertical-align: inherit;">在某个标准容器中，</font></font><code>std::vector&lt;X&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">则会看到我们的函数未用于分配和释放内存。</font><font style="vertical-align: inherit;">事实是，所有标准容器都有其自己的分配和释放内存的机制（特殊的分配器类，它是容器的模板参数），并且它们使用放置运算符来初始化元素</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="id-2-2-4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.4。</font><font style="vertical-align: inherit;">遗产</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
继承了分配和释放内存的函数。如果这些函数是在基类中定义的，而不是在派生类中定义的，则运算符将在派生类中重载，</font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且在基类中定义和分配的函数将用于分配和释放内存。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在考虑一个多态类层次结构，其中每个类都会重载operator </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。现在，使用运算符</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过指向基类的指针来</font><font style="vertical-align: inherit;">删除派生类的实例</font><font style="vertical-align: inherit;">。如果基类的析构函数是虚拟的，则标准保证将调用此派生类的析构函数。在这种情况下</font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">也可以保证</font><font style="vertical-align: inherit;">为此派生类定义的</font><font style="vertical-align: inherit;">函数调用</font><font style="vertical-align: inherit;">。因此，该功能</font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上是虚拟的。</font></font><br>
<br>
<a name="id-2-2-5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.5。</font><font style="vertical-align: inherit;">运算符delete（）函数的替代形式</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在类中（尤其是在使用继承时），有时可以方便地使用函数的另一种形式来释放内存：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该参数</font></font><code>size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置元素的大小（甚至在数组的版本中）。</font><font style="vertical-align: inherit;">这种形式使您可以使用不同的函数来分配和释放内存，具体取决于特定的派生类。</font></font><br>
<br>
<a name="id-3"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.用户操作员新建/删除</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++可以支持</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下形式的</font><font style="vertical-align: inherit;">自定义运算符形式</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T[<span class="hljs-comment">/*   */</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了支持这些格式，有必要确定适当的函数来分配和释放内存：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>);
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内存分配函数的其他参数列表不应为空，并且不应由一个</font></font><code>void*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font><font style="vertical-align: inherit;">组成</font></font><code>const std::nothrow_t&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，也就是说，其签名不应与标准参数之一相同。中的附加参数列表，</font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且</font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须匹配。传递给运算符的</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数必须对应于内存分配函数的其他参数。自定义函数</font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也可以采用带有可选size参数的形式。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些函数可以在全局名称空间或类中定义，但不能在全局名称空间之外定义。如果它们是在全局名称空间中定义的，则它们不会替换，而是会使分配和释放内存的标准函数过载，因此它们的使用是可预测的且安全的，并且标准函数始终可用。如果在类中定义它们，它们将隐藏标准格式，但是可以使用运算符来访问标准格式</font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这将在2.2节中详细介绍。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用户</font><font style="vertical-align: inherit;">定义的</font><font style="vertical-align: inherit;">运算符表单</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">称为</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户定义的位置</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。请勿将它们与</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2节中描述</font><font style="vertical-align: inherit;">的标准（非分配）放置运算符混淆</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
相应的运算符表单</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不存在。</font><font style="vertical-align: inherit;">有</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两种方法可以</font><font style="vertical-align: inherit;">删除使用用户定义的运算符创建的对象</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果用户定义的函数</font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将内存分配操作委派给标准内存分配函数，则可以使用标准运算符</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果不是，则必须显式调用析构函数，然后再调用用户定义的函数</font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">编译器</font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅</font><font style="vertical-align: inherit;">在以下</font><font style="vertical-align: inherit;">一种情况下</font><font style="vertical-align: inherit;">调用用户定义的函数</font><font style="vertical-align: inherit;">：当</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">构造</font><font style="vertical-align: inherit;">函数在</font><font style="vertical-align: inherit;">用户定义的运算符的操作期间</font><font style="vertical-align: inherit;">引发异常</font><font style="vertical-align: inherit;">时</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个示例（在全球范围内）。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"new "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"delete "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;<font></font>
    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> {</span><span class="hljs-comment">/* ... */</span>};<font></font>
X* p = <span class="hljs-keyword">new</span>(<span class="hljs-number">42</span>, <span class="hljs-string">"meow"</span>) X(); <span class="hljs-comment">// : new 42 + meow</span>
<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//   ::operator delete()</span></code></pre><br>
<a name="id-4"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.内存分配功能的定义</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这些示例中，用户功能</font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">委托操作与标准功能相对应。有时，此选项很有用，但是重载的主要目的</font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是创建一种新的机制来分配/释放内存。这项任务并不简单，在进行这项工作之前，必须仔细考虑所有事情。 Scott Meyers [Meyers1]讨论了做出此决定的可能动机（当然，主要动机是效率）。他还讨论了与正确实现用户定义的函数有关的主要技术问题，这些函数用于分配和释放内存（使用该函数</font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，多线程同步，对齐）。</font><font style="vertical-align: inherit;">Guntheroth提供了一个相对简单的用户定义的内存分配和释放功能的实现示例。</font><font style="vertical-align: inherit;">在创建自己的版本之前，您应该寻找现成的解决方案，例如，您可以从Boost项目中引入Pool库。</font></font><br>
<br>
<a name="id-5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.标准容器的分配器类别</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如上所述，标准容器使用特殊的分配器类来分配和释放内存。</font><font style="vertical-align: inherit;">这些类是容器的模板参数，用户可以定义其类的版本。</font><font style="vertical-align: inherit;">这种解决方案的动机与重载运算符大致相同</font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">[Guntheroth]介绍了如何创建此类。</font></font><br>
<br>
<a name="id-refs"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考书目</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Guntheroth] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gunteroth，Kurt。</font><font style="vertical-align: inherit;">C ++中程序的优化。</font><font style="vertical-align: inherit;">经验证的提高生产率的方法。</font><font style="vertical-align: inherit;">来自英语 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-SPb。：Alpha-book </font><font style="vertical-align: inherit;">LLC，2017年。</font><font style="vertical-align: inherit;">[Meyers1] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meyers，Scott。</font><font style="vertical-align: inherit;">有效使用C ++。</font><font style="vertical-align: inherit;">55种肯定的方法来改善程序的结构和代码。</font><font style="vertical-align: inherit;">来自英语 </font><font style="vertical-align: inherit;">-M.：DMK出版社，2014年。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN490626/index.html">有关数据的完整指南* HTML属性</a></li>
<li><a href="../zh-CN490628/index.html">CSS阻止页面解析时该怎么办？</a></li>
<li><a href="../zh-CN490630/index.html">从磁盘加载NumPy数组：比较memmap（）和Zarr / HDF5</a></li>
<li><a href="../zh-CN490634/index.html">3月2日至8日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN490636/index.html">3月2日至8日在圣彼得堡举行的数字活动</a></li>
<li><a href="../zh-CN490642/index.html">用于监视K8s应用程序的插件DevOpsProdigy KubeGraf v1.3.0：新版本和新功能</a></li>
<li><a href="../zh-CN490644/index.html">使用Inotify和Webdav的简单rpm存储库</a></li>
<li><a href="../zh-CN490648/index.html">在Kubernetes中使用Kata容器</a></li>
<li><a href="../zh-CN490650/index.html">初学者IT专家编写简历的主要错误</a></li>
<li><a href="../zh-CN490652/index.html">后勤。介绍 只是复杂</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>