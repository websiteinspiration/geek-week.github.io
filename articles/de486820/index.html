<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍🏽 🆑 🍹 70 Fragen zum Javascript-Interview 🌼 Ⓜ️ 👩🏽‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, Freunde! 
 
 Ich hoffe, dieser Artikel ist sowohl für Anfänger als auch für erfahrene Entwickler nützlich. 
 
 In Fragen, die mir schwierig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>70 Fragen zum Javascript-Interview</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486820/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guten Tag, Freunde! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, dieser Artikel ist sowohl für Anfänger als auch für erfahrene Entwickler nützlich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Fragen, die mir schwieriger erschienen als andere, wird auf zusätzliche Literatur verwiesen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für die ausführlichen Kommentare wäre ich dankbar. </font><font style="vertical-align: inherit;">Alle Kommentare werden bei der Bearbeitung des Artikels berücksichtigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So lass uns gehen.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70 Fragen zum Javascript-Interview</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fragen: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Was ist der Unterschied zwischen null und undefiniert? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Wofür wird der Operator &amp;&amp; verwendet? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Wofür wird der Operator "||" verwendet? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Ist die Verwendung des unären Plus-Operators (+ Operator) der schnellste Weg, eine Zeichenfolge in eine Zahl umzuwandeln? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Was ist ein DOM? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Was ist Event Propogation? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Was ist Ereignisblasen? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Was ist Ereigniserfassung? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. Was ist der Unterschied zwischen den Methoden event.preventDefault () und event.stopPropagation ()? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. Wie lerne ich die Verwendung der event.preventDefault () -Methode kennen? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. Warum führt obj.someprop.x zu einem Fehler? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12. Was ist ein Ereignisziel oder ein Zielelement (event.target)?</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">13.      (event.currentTarget)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">14.      "=="  "==="?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">15.        false?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">16.     "!!"?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">17.       ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">18.    (Hoisting)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">19.     (Scope)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">20.    (Closures)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">21.    JS  ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">22.  ,    ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">23.     «use strict»?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">24.    this?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">25.    ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">26.   IIFE?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">27.     Function.prototype.apply?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">28.     Function.prototype.call?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">29.      call  apply?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">30.     Function.prototype.bind?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">31.        JS         ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">32.      (Higher Order Functions)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">33.    JS     (First-class Objects)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">34.      Array.prototype.map?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">35.      Array.prototype.filter?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">36.      Array.prototype.reduce?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">37.    arguments?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">38.   ,   ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">39.      b     ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">40.   ECMAScript?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">41.     JS  ES6  ECMAScript2015?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">42.       «var», «let»  «const»?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">43.     (Arrow Functions)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">44.    (Classes)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">45.     (Template Literals)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">46.     (Object Destructuring)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">47.    (Modules)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">48.    Set?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">49.      (Callback Function)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">50.    (Promises)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">51.   async/await?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">52.     spread-  rest-?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">53.      (Default Parameters)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">54.     (Wrapper Objects)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">55.             (Implicit and Explicit Coercion)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">56.   NaN?  ,    NaN?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">57.  ,    ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">58.  ,    ,          ( "%")?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">59.      ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">60.   AJAX?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">61.   JS  ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">62.      Object.freeze  Object.seal?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">63.      «in»   hasOwnProperty?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64. Welche Techniken zum Arbeiten mit asynchronem Code in JS kennen Sie? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65. Was ist der Unterschied zwischen einer normalen Funktion und einem funktionalen Ausdruck? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">66. Wie rufe ich eine Funktion in JS auf? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">67. Was ist Auswendiglernen oder Auswendiglernen? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68. Wie würden Sie die Hilfsfunktion des Auswendiglernen implementieren? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69. Warum gibt typeof null ein Objekt zurück? </font><font style="vertical-align: inherit;">Wie überprüfe ich, ob ein Wert null ist? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70. Wofür wird das Schlüsselwort "neu" verwendet?</font></font></a><br>
<br>
<a name="1"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Was ist der Unterschied zwischen null und undefiniert?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns zunächst darüber sprechen, was sie gemeinsam haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens gehören sie zu 7 JS "Primitiven" (primitiven Typen):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> primitiveTypes = [<span class="hljs-string">'string'</span>, <span class="hljs-string">'number'</span>, <span class="hljs-string">'null'</span>, <span class="hljs-string">'undefined'</span>, <span class="hljs-string">'boolean'</span>, <span class="hljs-string">'symbol'</span>, <span class="hljs-string">'bigint'</span>]
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens sind sie falsche Werte, d.h. </font><font style="vertical-align: inherit;">das Ergebnis der Konvertierung in einen Booleschen Wert mit Boolean () oder dem Operator "!!" </font><font style="vertical-align: inherit;">ist falsch:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Okay, jetzt zu den Unterschieden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
undefiniert ist der Standardwert:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Variable, der kein Wert zugewiesen wurde, d.h. </font><font style="vertical-align: inherit;">eine deklarierte, aber nicht initialisierte Variable;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Funktion, die nichts explizit zurückgibt, z. B. console.log (1);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht vorhandene Eigenschaft des Objekts.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesen Fällen setzt die JS-Engine den Wert auf undefiniert.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> _thisIsUndefined
<span class="hljs-keyword">const</span> doNothing = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}
<span class="hljs-keyword">const</span> someObj = {
    <span class="hljs-attr">a</span>: <span class="hljs-string">'ay'</span>,
    <span class="hljs-attr">b</span>: <span class="hljs-string">'bee'</span>,
    <span class="hljs-attr">c</span>: <span class="hljs-string">'si'</span><font></font>
}<font></font>
<span class="hljs-built_in">console</span>.log(_thisIsUndefined) <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(doNothing()) <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(someObj[<span class="hljs-string">'d'</span>]) <span class="hljs-comment">// undefined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
null ist der "Wert ohne Wert". </font><font style="vertical-align: inherit;">null ist der Wert, der der Variablen explizit zugewiesen wird. </font><font style="vertical-align: inherit;">Im folgenden Beispiel erhalten wir null, wenn die Methode fs.readFile fehlerfrei funktioniert:</font></font><br>
<br>
<pre><code class="javascript hljs">fs.readFile(<span class="hljs-string">'path/to/file'</span>, (e, data) =&gt; {
    <span class="hljs-built_in">console</span>.log(e) <span class="hljs-comment">//    null</span>
<span class="hljs-keyword">if</span>(e) {
    <span class="hljs-built_in">console</span>.log(e)<font></font>
}<font></font>
    <span class="hljs-built_in">console</span>.log(data)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Vergleich von null und undefiniert erhalten wir true, wenn der Operator "==" verwendet wird, und false, wenn der Operator "===" verwendet wird. </font><font style="vertical-align: inherit;">Informationen dazu finden Sie weiter unten.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span>
</code></pre><br>
<a name="2"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Wofür wird der Operator &amp;&amp; verwendet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Operator &amp;&amp; (logisch und) findet und gibt den ersten falschen Wert oder den letzten Operanden zurück, wenn alle Werte wahr sind. </font><font style="vertical-align: inherit;">Es wird ein Kurzschluss verwendet, um unnötige Kosten zu vermeiden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-number">1</span> &amp;&amp; []) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">' '</span> &amp;&amp; <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-number">5</span>) <span class="hljs-comment">// 5</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der if-Anweisung:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> router: Router = Router()<font></font>
<font></font>
router.get(<span class="hljs-string">'/endpoint'</span>, (req: Request, <span class="hljs-attr">res</span>: Response) =&gt; {
    <span class="hljs-keyword">let</span> conMobile: PoolConnection
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">//    </span>
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">if</span> (conMobile) {<font></font>
            conMobile.release()<font></font>
        }<font></font>
    }<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gleiches gilt für den Operator &amp;&amp;:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> router: Router = Router()<font></font>
<font></font>
router.get(<span class="hljs-string">'/endpoint'</span>, (req: Request, <span class="hljs-attr">res</span>: Response) =&gt; {
    <span class="hljs-keyword">let</span> conMobile: PoolConnection
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">//    </span>
    } <span class="hljs-keyword">catch</span> (e) {<font></font>
        conMobile &amp;&amp; conMobile.release()<font></font>
    }<font></font>
})<font></font>
</code></pre><br>
<a name="3"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Wofür wird der Operator "||" verwendet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Operator "||" </font><font style="vertical-align: inherit;">(boolean oder) findet und gibt den ersten wahren Wert zurück. </font><font style="vertical-align: inherit;">Es wird auch ein Kurzschluss verwendet. </font><font style="vertical-align: inherit;">Dieser Operator wurde verwendet, um Standardparameter in Funktionen zuzuweisen, bevor die Standardparameter in ES6 standardisiert wurden.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> || <span class="hljs-number">1</span> || <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// 1</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logName</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">let</span> n = name || Mark
    <span class="hljs-built_in">console</span>.log(n)<font></font>
}<font></font>
<font></font>
logName() <span class="hljs-comment">// Mark</span>
</code></pre><br>
<a name="4"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Ist die Verwendung des unären Plus-Operators (+ Operator) der schnellste Weg, eine Zeichenfolge in eine Zahl umzuwandeln?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Laut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der Operator + in der Tat der schnellste Weg, eine Zeichenfolge in eine Zahl umzuwandeln, da er keine Operationen für einen Wert ausführt, der eine Zahl ist.</font></font><br>
<br>
<a name="5"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Was ist ein DOM?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das DOM oder Document Object Model ist eine Anwendungsprogrammierschnittstelle (API) für die Arbeit mit HTML- und XML-Dokumenten. </font><font style="vertical-align: inherit;">Wenn der Browser das HTML-Dokument zum ersten Mal liest („analysiert“), bildet er ein großes Objekt, ein wirklich großes Objekt, das auf dem Dokument basiert - das DOM. </font><font style="vertical-align: inherit;">Das DOM ist eine Baumstruktur (Dokumentbaum). </font><font style="vertical-align: inherit;">Das DOM wird verwendet, um die Struktur des DOM selbst oder seiner einzelnen Elemente und Knoten zu interagieren und zu ändern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir haben diesen HTML-Code:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"ie=edge"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document Object Model<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das DOM dieses HTML sieht folgendermaßen aus: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ax/cg/id/axcgidsa8fghreeuyvbhfpga6yo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In JS wird das DOM durch ein Dokumentobjekt dargestellt. </font><font style="vertical-align: inherit;">Das Document-Objekt verfügt über eine Vielzahl von Methoden zum Arbeiten mit Elementen, deren Erstellung, Änderung, Löschung usw.</font></font><br>
<br>
<a name="6"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Was ist Ereignisausbreitung?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein Ereignis in einem DOM-Element auftritt, tritt es tatsächlich nicht nur darin auf. </font><font style="vertical-align: inherit;">Das Ereignis "propagiert" vom Window-Objekt zu dem Element, das es aufgerufen hat (event.target). </font><font style="vertical-align: inherit;">In diesem Fall durchdringt (beeinflusst) das Ereignis nacheinander alle Vorfahren des Zielelements. </font><font style="vertical-align: inherit;">Eine Ereignisausbreitung besteht aus drei Stufen oder Phasen:</font></font><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eintauchphase (Erfassung, Abfangen) - Ein Ereignis tritt im Fensterobjekt auf und steigt über alle seine Vorfahren zum Ereignisziel ab.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zielphase ist, wenn das Ereignis das Zielelement erreicht.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufsteigende Phase - Ein Ereignis steigt aus event.target auf, durchläuft nacheinander alle seine Vorfahren und erreicht das Window-Objekt.</font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/a3/9x/67/a39x67wkxdmcyzj-it5m2jmfxgg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lesen Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mehr über die Verteilung von Veranstaltungen </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="7"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Was ist ein Ereignis-Popup?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein Ereignis in einem DOM-Element auftritt, betrifft es nicht nur dieses Element. </font><font style="vertical-align: inherit;">Ein Ereignis „erscheint“ (wie eine Luftblase im Wasser), geht von dem Element, das das Ereignis verursacht hat (event.target), zu seinem übergeordneten Element und steigt dann noch höher zum übergeordneten Element des übergeordneten Elements des Elements, bis es das Fensterobjekt erreicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir haben dieses Markup:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grandparent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so ein JS:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEvent</span>(<span class="hljs-params">el, event, callback, isCapture = false</span>) </span>{
    <span class="hljs-keyword">if</span> (!el || !event || !callback || <span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">return</span><font></font>
<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> el === <span class="hljs-string">'string'</span>) {<font></font>
        el = <span class="hljs-built_in">document</span>.querySelector(el)<font></font>
    }<font></font>
    el.addEventListener(event, callback, isCapture)<font></font>
}<font></font>
<font></font>
addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'DOMContentLoaded'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.child'</span>)
    <span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.parent'</span>)
    <span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.grandparent'</span>)<font></font>
<font></font>
    addEvent(child, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(parent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(grandparent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'grandparent'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(<span class="hljs-string">'html'</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'html'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'document'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">window</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'window'</span>)<font></font>
    })<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die addEventListener-Methode verfügt über einen dritten optionalen Parameter - useCapture. </font><font style="vertical-align: inherit;">Wenn der Wert false ist (Standardeinstellung), beginnt das Ereignis mit der Aufstiegsphase. </font><font style="vertical-align: inherit;">Wenn sein Wert wahr ist, beginnt das Ereignis mit der Eintauchphase (für die "Zuhörer" von Ereignissen, die an das Ziel des Ereignisses angehängt sind, befindet sich das Ereignis in der Zielphase und nicht in der Eintauch- oder Aufstiegsphase. Ereignisse in der Zielphase werden von allen Zuhörern des Elements in der Reihenfolge ausgelöst in dem sie unabhängig vom Parameter useCapture registriert wurden - ca. </font><font style="vertical-align: inherit;">Wenn wir auf das untergeordnete Element klicken, wird in der Konsole Folgendes angezeigt: untergeordnetes Element, übergeordnetes Element, Großelternteil, HTML, Dokument, Fenster. </font><font style="vertical-align: inherit;">Hier ist, was ein Ereignis-Popup ist.</font></font><br>
<br>
<a name="8"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Was ist ein Immersionsereignis?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein Ereignis in einem DOM-Element auftritt, tritt es nicht nur darin auf. </font><font style="vertical-align: inherit;">In der Immersionsphase steigt das Ereignis durch alle seine Vorfahren vom Fensterobjekt zum Ereignisziel ab. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Markup:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grandparent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JS:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEvent</span>(<span class="hljs-params">el, event, callback, isCapture = false</span>) </span>{
    <span class="hljs-keyword">if</span> (!el || !event || !callback || <span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">return</span><font></font>
<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> el === <span class="hljs-string">'string'</span>) {<font></font>
        el = <span class="hljs-built_in">document</span>.querySelector(el);<font></font>
    }<font></font>
    el.addEventListener(event, callback, isCapture)<font></font>
}<font></font>
<font></font>
addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'DOMContentLoaded'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.child'</span>)
    <span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.parent'</span>)
    <span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.grandparent'</span>)<font></font>
<font></font>
    addEvent(child, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child'</span>);<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(parent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(grandparent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'grandparent'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(<span class="hljs-string">'html'</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'html'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'document'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">window</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'window'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die addEventListener-Methode verfügt über einen dritten optionalen Parameter - useCapture. </font><font style="vertical-align: inherit;">Wenn der Wert false ist (Standardeinstellung), beginnt das Ereignis mit der Aufstiegsphase. </font><font style="vertical-align: inherit;">Wenn sein Wert wahr ist, beginnt das Ereignis mit der Tauchphase. </font><font style="vertical-align: inherit;">Wenn wir auf das untergeordnete Element klicken, wird in der Konsole Folgendes angezeigt: Fenster, Dokument, HTML, Großeltern, Eltern, Kind. </font><font style="vertical-align: inherit;">Dies ist das Eintauchen des Ereignisses.</font></font><br>
<br>
<a name="9"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. Was ist der Unterschied zwischen den Methoden event.preventDefault () und event.stopPropagation ()?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Methode event.preventDefault () deaktiviert das Standardverhalten eines Elements. </font><font style="vertical-align: inherit;">Wenn Sie diese Methode im Formularelement verwenden, wird das Senden des Formulars verhindert. </font><font style="vertical-align: inherit;">Wenn Sie es im Kontextmenü verwenden, wird das Kontextmenü deaktiviert (diese Methode wird häufig im Keydown verwendet, um die Tastatur neu zu definieren, z. B. beim Erstellen eines Musik- / Videoplayers oder eines Texteditors - ca. </font><font style="vertical-align: inherit;">Die Methode event.stopPropagation () deaktiviert die Ereignisausbreitung (Aufstieg oder Eintauchen).</font></font><br>
<br>
<a name="10"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. Wie lerne ich die Verwendung der event.preventDefault () -Methode kennen?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu diesem Zweck können wir die Eigenschaft event.defaulPrevented verwenden, die einen Booleschen Wert zurückgibt, der als Indikator für die Anwendung auf das Element der Methode event.preventDefault dient.</font></font><br>
<br>
<a name="11"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. Warum führt obj.someprop.x zu einem Fehler?</font></font></h4><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj = {}
<span class="hljs-built_in">console</span>.log(obj.someprop.x)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Antwort liegt auf der Hand: Wir versuchen, auf die undefinierte Eigenschaft x der Eigenschaft someprop zuzugreifen. </font><font style="vertical-align: inherit;">obj .__ proto __.__ proto = null, daher wird undefined zurückgegeben, und undefined hat nicht die x-Eigenschaft.</font></font><br>
<br>
<a name="12"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12. Was ist ein Ereignisziel oder ein Zielelement (event.target)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einfachen Worten ist event.target das Element, in dem das Ereignis auftritt, oder das Element, das das Ereignis ausgelöst hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben das folgende Markup:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"clickFunc(event)"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align: center; margin: 15px;
border: 1px solid red; border-radius: 3px;"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 25px; border: 1px solid royalblue; border-radius: 3px;"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 25px; border: 1px solid skyblue; border-radius: 3px;"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 10px"</span>&gt;</span><font></font>
                Button<font></font>
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so ein einfacher JS:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickFunc</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-built_in">console</span>.log(event.target)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben dem äußeren Div einen „Zuhörer“ hinzugefügt. </font><font style="vertical-align: inherit;">Wenn wir jedoch auf die Schaltfläche klicken, erhalten wir das Layout dieser Schaltfläche in der Konsole. </font><font style="vertical-align: inherit;">Dies lässt den Schluss zu, dass das Element, das das Ereignis verursacht hat, die Schaltfläche selbst ist und nicht die externen oder internen Divs.</font></font><br>
<br>
<a name="13"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13. Was ist der aktuelle Zweck des Ereignisses (event.currentTarget)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Event.currentTarget ist das Element, an das der Ereignis-Listener angehängt ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ähnliches Markup:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"clickFunc(event)"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align: center;margin:15px;
border:1px solid red;border-radius:3px;"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 25px; border:1px solid royalblue;border-radius:3px;"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin:25px;border:1px solid skyblue;border-radius:3px;"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin:10px"</span>&gt;</span><font></font>
                Button<font></font>
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und ein leicht modifizierter JS:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickFunc</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-built_in">console</span>.log(event.currentTarget)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben den Hörer an die äußere Div angeschlossen. </font><font style="vertical-align: inherit;">Wo immer wir klicken, sei es eine Schaltfläche oder eine der internen Divs, in der Konsole erhalten wir immer das Layout der externen Divs. </font><font style="vertical-align: inherit;">Dies lässt den Schluss zu, dass event.currentTarget das Element ist, an das der Ereignis-Listener angehängt ist.</font></font><br>
<br>
<a name="14"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14. Was ist der Unterschied zwischen den Operatoren "==" und "==="?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Unterschied zwischen dem Operator == (abstrakte oder nicht strenge Gleichheit) und dem Operator === (strikte Gleichheit) besteht darin, dass der erste die Werte vergleicht, nachdem sie konvertiert oder in einen Typ umgewandelt wurden (Coersion), und der zweite - ohne eine solche Konvertierung . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns tiefer graben. </font><font style="vertical-align: inherit;">Und zuerst sprechen wir über die Transformation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Konvertierung ist ein Prozess, bei dem ein Wert in einen anderen Typ umgewandelt wird, oder vielmehr ein Prozess, bei dem die verglichenen Werte in einen Typ umgewandelt werden. </font><font style="vertical-align: inherit;">Beim Vergleich des Operators "==" wird der sogenannte implizite Vergleich erzeugt. </font><font style="vertical-align: inherit;">Der Operator "==" führt einige Operationen aus, bevor er zwei Werte vergleicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir vergleichen x und y. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Algorithmus ist wie folgt:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn x und y vom gleichen Typ sind, wird der Vergleich mit dem Operator "===" durchgeführt.</font></font></li>
<li> x = null  y = undefined  true.</li>
<li> x = undefined  y = null  true.</li>
<li> x = ,  y = ,  x == toNumber(y) ( y   ).</li>
<li> x = ,  y = ,  toNumber(x) == y ( x   ).</li>
<li> x =  ,  toNumber(x) == y.</li>
<li> y =  ,  x == toNumber(y).</li>
<li> x = ,   ,  y = ,  x == toPrimitive(y) ( y   ).</li>
<li> x = ,  y = ,   ,  toPrimitive(x) == y.</li>
<li> false.</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie daran: Um ein Objekt in ein "Grundelement" umzuwandeln, verwendet die toPrimitive-Methode zuerst die valueOf-Methode und dann die toString-Methode. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiele: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yd/xe/tn/ydxetnfghjtfuex_p-em8v4emck.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Beispiele geben true zurück. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste Beispiel ist die erste Bedingung des Algorithmus. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite Beispiel ist die vierte Bedingung. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der dritte ist der zweite. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der vierte ist der siebte. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fünfter - Achter. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und der letzte ist der zehnte. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t-/4k/ys/t-4kyszb4grfafbi7lazyyvq6dy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir den Operator "===" verwenden, geben alle Beispiele außer dem ersten false zurück, da die Werte in diesen Beispielen unterschiedlichen Typs sind.</font></font><br>
<br>
<a name="15"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15. Warum ist das Ergebnis des Vergleichs zweier ähnlicher Objekte falsch?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> a = {
    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><font></font>
}<font></font>
<span class="hljs-keyword">let</span> b = {
    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><font></font>
}<font></font>
<span class="hljs-keyword">let</span> c = a<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(a === b) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(a === c) <span class="hljs-comment">// true ...</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In JS werden Objekte und Grundelemente unterschiedlich verglichen. </font><font style="vertical-align: inherit;">Primitive werden nach Wert verglichen. </font><font style="vertical-align: inherit;">Objekte - nach Referenz oder Adresse im Speicher, in dem die Variable gespeichert ist. </font><font style="vertical-align: inherit;">Aus diesem Grund gibt das erste console.log false und das zweite true zurück. </font><font style="vertical-align: inherit;">Die Variablen "a" und "c" beziehen sich auf dasselbe Objekt, während sich die Variablen "a" und "b" auf verschiedene Objekte mit denselben Eigenschaften und Werten beziehen.</font></font><br>
<br>
<a name="16"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16. Wofür wird der Operator "!!" verwendet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Betreiber "!!" </font><font style="vertical-align: inherit;">(doppelte Negation) führt den Wert rechts von ihm zu einem logischen Wert.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-string">''</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-number">0</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-string">' '</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!!{}) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!![]) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!![].length) <span class="hljs-comment">// false</span>
</code></pre><br>
<a name="17"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17. Wie schreibe ich mehrere Ausdrücke in eine Zeile?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hierfür können wir den Operator "," (Komma) verwenden. </font><font style="vertical-align: inherit;">Dieser Operator "bewegt" sich von links nach rechts und gibt den Wert des letzten Ausdrucks oder Operanden zurück.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span><font></font>
<font></font>
x = (x++, x = addFive(x), x *= <span class="hljs-number">2</span>, x -= <span class="hljs-number">5</span>, x += <span class="hljs-number">10</span>)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addFive</span>(<span class="hljs-params">num</span>) </span>{
    <span class="hljs-keyword">return</span> num + <span class="hljs-number">5</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir den Wert von x auf die Konsole drucken, erhalten wir 27. Zuerst erhöhen wir den Wert von x um eins (x = 6). </font><font style="vertical-align: inherit;">Dann rufen wir die Funktion addFive () mit Parameter 6 auf, zu der wir 5 hinzufügen (x = 11). </font><font style="vertical-align: inherit;">Danach multiplizieren wir den Wert von x mit 2 (x = 22). </font><font style="vertical-align: inherit;">Dann subtrahiere 5 (x = 17). </font><font style="vertical-align: inherit;">Und schließlich addieren Sie 10 (x = 27).</font></font><br>
<br>
<a name="18"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18. Was ist Heben?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lift ist ein Begriff, der den Aufstieg einer Variablen oder Funktion in einem globalen oder funktionalen Bereich beschreibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu verstehen, was Heben ist, müssen Sie den Ausführungskontext verstehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Ausführungskontext ist die Umgebung, in der der Code ausgeführt wird. Der Ausführungskontext besteht aus zwei Phasen - Kompilierung und Ausführung selbst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusammenstellung. In dieser Phase werden funktionale Ausdrücke und Variablen, die mit dem Schlüsselwort "var" mit dem Wert undefined deklariert wurden, ganz oben im globalen (oder funktionalen) Bereich angezeigt (als würden wir an den Anfang unseres Codes gehen. Dies erklärt, warum wir Funktionen vor ihnen aufrufen können Ankündigungen - ca.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Performance. </font><font style="vertical-align: inherit;">In dieser Phase werden Variablen Werte zugewiesen und Funktionen (oder Methoden von Objekten) aufgerufen oder ausgeführt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie daran: Es werden nur funktionale Ausdrücke und Variablen ausgelöst, die mit dem Schlüsselwort "var" deklariert wurden. </font><font style="vertical-align: inherit;">Gewöhnliche Funktionen und Pfeilfunktionen sowie Variablen, die mit den Schlüsselwörtern "let" und "const" deklariert wurden, werden nicht ausgelöst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben folgenden Code:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(y)<font></font>
y = <span class="hljs-number">1</span>
<span class="hljs-built_in">console</span>.log(y)
<span class="hljs-built_in">console</span>.log(greet(<span class="hljs-string">'Mark'</span>))<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> y
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden undefiniert, 1 und 'Hallo Mark!'. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht die Kompilierungsphase aus:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> y <span class="hljs-comment">//  undefined</span><font></font>
<font></font>
<span class="hljs-comment">//    </span><font></font>
<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-comment">/*
console.log(y)
y = 1
console.log(y)
console.log(greet('Mark'))
*/</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach Abschluss der Kompilierungsphase beginnt die Ausführungsphase, wenn den Variablen Werte zugewiesen und Funktionen aufgerufen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mehr zum Heben finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="19"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19. Was ist ein Anwendungsbereich?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Bereich ist ein Ort, an dem (oder von wo aus) wir Zugriff auf Variablen oder Funktionen haben. </font><font style="vertical-align: inherit;">JS Wir haben drei Arten von Bereichen: global, funktional und block (ES6). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Globaler Bereich - Variablen und Funktionen, die im globalen Namespace deklariert sind, haben einen globalen Bereich und sind von überall im Code zugänglich.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> g = <span class="hljs-string">'global'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">globalFunc</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFunc</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(g) <span class="hljs-comment">//     g,    </span><font></font>
    }<font></font>
    innerFunc()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktionsumfang (Funktionsumfang) - Variablen, Funktionen und Parameter, die innerhalb einer Funktion deklariert sind, sind nur innerhalb dieser Funktion verfügbar.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFavouriteFunc</span>(<span class="hljs-params">a</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">var</span> b = <span class="hljs-string">'Hello '</span> + a<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> b<font></font>
}<font></font>
myFavouriteFunc(<span class="hljs-string">'World'</span>)<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// Uncaught ReferenceError: a is not defined</span>
<span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">//  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Blockbereich - Variablen (deklariert mit den Schlüsselwörtern "let" und "const") innerhalb des Blocks ({}) sind nur innerhalb des Blocks verfügbar.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testBlock</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">let</span> z = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> z<font></font>
}<font></font>
<font></font>
testBlock() <span class="hljs-comment">// Uncaught ReferenceError: z is not defined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Bereich ist auch ein Satz von Regeln, nach denen eine Variable durchsucht wird. </font><font style="vertical-align: inherit;">Wenn die Variable im aktuellen Bereich nicht vorhanden ist, wird ihre Suche in der externen Sichtbarkeit des aktuellen Bereichs höher ausgeführt. </font><font style="vertical-align: inherit;">Wenn der externe Bereich keine Variable enthält, wird die Suche bis zum globalen Bereich fortgesetzt. </font><font style="vertical-align: inherit;">Wenn eine Variable im globalen Bereich gefunden wird, wird die Suche gestoppt. Andernfalls wird eine Ausnahme ausgelöst. </font><font style="vertical-align: inherit;">Die Suche wird von denjenigen durchgeführt, die den aktuellen Sichtbarkeitsbereichen am nächsten liegen, und endet mit dem Auffinden der Variablen. </font><font style="vertical-align: inherit;">Dies wird als Scope Chain bezeichnet.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-comment">//    -&gt;    -&gt;   </span><font></font>
<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> variable1 = <span class="hljs-string">'Comrades'</span>
<span class="hljs-keyword">var</span> variable2 = <span class="hljs-string">'Sayonara'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">var</span> variable1 = <span class="hljs-string">'World'</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">//   </span>
        <span class="hljs-keyword">var</span> variable2 = <span class="hljs-string">'Hello'</span>
        <span class="hljs-built_in">console</span>.log(variable2 + <span class="hljs-string">' '</span> + variable1)<font></font>
    }<font></font>
    inner()<font></font>
}<font></font>
outer()<font></font>
<span class="hljs-comment">//    'Hello World',</span>
<span class="hljs-comment">//   variable2 = 'Hello'  variable1 = 'World'  </span>
<span class="hljs-comment">//     </span>
</code></pre><br>
<img src="https://habrastorage.org/webt/r6/07/q7/r607q7hehfjmuicf0_icntddk2s.png"><br>
<br>
<a name="20"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20. Was ist ein Verschluss (Closures)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist wahrscheinlich die schwierigste Frage aus der Liste. Ich werde versuchen zu erklären, wie ich Schließung verstehe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Tat ist das Schließen die Fähigkeit einer Funktion, Verknüpfungen zu Variablen und Parametern zu erstellen, die sich im aktuellen Bereich, im Bereich der übergeordneten Funktion, im Bereich des übergeordneten Bereichs der übergeordneten Funktion usw. zum globalen Bereich befinden, wobei die Kette der Bereiche zum Zeitpunkt der Erstellung verwendet wird. In der Regel wird der Umfang beim Erstellen einer Funktion festgelegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiele sind eine gute Möglichkeit, den Abschluss zu erklären:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">'abc'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-built_in">console</span>.log(globalVar)<font></font>
}<font></font>
<font></font>
a() <span class="hljs-comment">// 'abc'</span>
<span class="hljs-comment">//   </span>
<span class="hljs-comment">//    a -&gt;   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir in diesem Beispiel eine Funktion deklarieren, ist der globale Bereich Teil des Abschlusses. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/10/ke/qa/10keqaosrww0rntbyei1gx9f_k0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Variable „globalVar“ spielt im Bild keine Rolle, da sich ihr Wert abhängig davon ändern kann, wo und wann die Funktion aufgerufen wird. Im obigen Beispiel hat globalVar jedoch den Wert "abc". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ist das Beispiel komplizierter:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">'global'</span>
<span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">'outer'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outerFunc</span>(<span class="hljs-params">outerParam</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFunc</span>(<span class="hljs-params">innerParam</span>) </span>{
        <span class="hljs-built_in">console</span>.log(globalVar, outerParam, innerParam)<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> innerFunc<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> x = outerFunc(outerVar)<font></font>
outerVar = <span class="hljs-string">'outer-2'</span>
globalVar = <span class="hljs-string">'guess'</span>
x(<span class="hljs-string">'inner'</span>)
</code></pre><br>
<img src="https://habrastorage.org/webt/ms/dv/wx/msdvwxdxp5s3l4cquxnqgkdtyr0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis ist "erraten äußere innere". Die Erklärung lautet wie folgt: Wenn wir die OuterFunc-Funktion aufrufen und die Variable "x" auf den von der InnerFunc-Funktion zurückgegebenen Wert setzen, entspricht der Parameter "OuterParam" "Outer". Trotz der Tatsache, dass wir die Variable "OuterVar" "Outer-2" zugewiesen haben, geschah dies nach dem Aufruf der Funktion "OuterFunc", die es "geschafft" hat, den Wert der Variablen "OuterVar" in der Bereichskette zu finden. Dieser Wert war "Outer". Wenn wir "x" aufrufen, was sich auf innerFunc bezieht, ist der Wert von "innerParam" "inner", da wir diesen Wert als Parameter übergeben, wenn wir "x" aufrufen. globalVar hat den Wert "rate", da wir ihm diesen Wert zugewiesen haben, bevor wir "x" aufgerufen haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Beispiel für ein Missverständnis einer Schaltung.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> arrFunc = []
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {<font></font>
    arrFunc.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> i<font></font>
    })<font></font>
}<font></font>
<span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">// 5</span><font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arrFunc.length; i++) {
    <span class="hljs-built_in">console</span>.log(arrFunc[i]()) <span class="hljs-comment">//  5</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code funktioniert nicht wie erwartet. </font><font style="vertical-align: inherit;">Durch das Deklarieren einer Variablen mit dem Schlüsselwort var wird diese Variable global. </font><font style="vertical-align: inherit;">Nach dem Hinzufügen von Funktionen zum Array arrFunc wird der Wert der globalen Variablen "i" zu "5". </font><font style="vertical-align: inherit;">Wenn wir die Funktion aufrufen, gibt sie daher den Wert der globalen Variablen "i" zurück. </font><font style="vertical-align: inherit;">Ein Abschluss speichert einen Verweis auf eine Variable, nicht ihren Wert zum Zeitpunkt der Erstellung. </font><font style="vertical-align: inherit;">Dieses Problem kann durch Verwendung von IIFE oder durch Deklarieren einer Variablen mit dem Schlüsselwort "let" gelöst werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lesen Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mehr über die Schließung </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="21"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21. Welche Werte in JS sind falsch?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> falsyValues = [<span class="hljs-string">''</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-literal">false</span>]
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
False sind Werte, deren Konvertierung in einen Booleschen Wert false ist.</font></font><br>
<br>
<a name="22"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22. Wie überprüfe ich, ob ein Wert falsch ist?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie die Boolesche Funktion oder den Operator "!!" </font><font style="vertical-align: inherit;">(zweimal nein).</font></font><br>
<br>
<a name="23"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">23. Wofür wird die strikte Richtlinie verwendet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Use strict" ist eine ES5-Direktive, die den gesamten Code oder den Code einer einzelnen Funktion zur Ausführung im strengen Modus zwingt. </font><font style="vertical-align: inherit;">Der strikte Modus führt einige Einschränkungen beim Schreiben von Code ein, wodurch Fehler in den frühen Stadien vermieden werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sind die Einschränkungen des strengen Modus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können keine Werte zuweisen oder auf nicht deklarierte Variablen zugreifen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnY</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-string">'use strict'</span>
    y = <span class="hljs-number">123</span>
    <span class="hljs-keyword">return</span> y<font></font>
}<font></font>
returnY() <span class="hljs-comment">// Uncaught ReferenceError: y is not defined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist verboten, schreibgeschützten oder schreibgeschützten Variablen globale Werte zuzuweisen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span>
<span class="hljs-keyword">var</span> <span class="hljs-literal">NaN</span> = <span class="hljs-literal">NaN</span> <span class="hljs-comment">// Uncaught TypeError: Cannot assign to read only property 'NaN' of object '#&lt;Window&gt;'</span>
<span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-keyword">var</span> <span class="hljs-literal">Infinity</span> = <span class="hljs-string">'and beyond'</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können die Eigenschaft "nicht löschbar" eines Objekts nicht löschen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span>
<span class="hljs-keyword">const</span> obj = {}<font></font>
<font></font>
<span class="hljs-built_in">Object</span>.defineProperties(obj, <span class="hljs-string">'x'</span>, {
    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><font></font>
})<font></font>
<font></font>
<span class="hljs-keyword">delete</span> obj.x <span class="hljs-comment">// Uncaught TypeError: Property description must be an object: x</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Duplizieren von Parametern ist verboten:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someFunc</span>(<span class="hljs-params">a, b, b, c</span>) </span>{} <span class="hljs-comment">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der Funktion eval können Sie keine Funktionen erstellen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span><font></font>
<font></font>
<span class="hljs-built_in">eval</span>(<span class="hljs-string">'var x = 1'</span>)<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(x) <span class="hljs-comment">// Uncaught ReferenceError: x is not defined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Standardwert hierfür ist undefiniert:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMeThis</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><font></font>
}<font></font>
<font></font>
showMeThis() <span class="hljs-comment">// undefined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
… usw.</font></font><br>
<br>
<a name="24"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24. Was bedeutet das?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bezieht sich normalerweise auf den Wert des Objekts, das gerade die Funktion ausführt oder aufruft. </font><font style="vertical-align: inherit;">"Im Moment" bedeutet, dass der Wert davon abhängig vom Ausführungskontext variiert, in dem wir dies verwenden.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> carDetails = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Ford Mustang'</span>,
    <span class="hljs-attr">yearBought</span>: <span class="hljs-number">2005</span>,<font></font>
    getName() {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name<font></font>
    }<font></font>
    <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">true</span><font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(carDetails.getName()) <span class="hljs-comment">// Ford Mustang</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall gibt die Methode getName this.name zurück. Dies bezieht sich auf carDetails, das Objekt, in dem getName ausgeführt wird, und dessen "Eigentümer". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen Sie nach console.log drei Zeilen hinzu:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'Ford Ranger'</span>
<span class="hljs-keyword">var</span> getCarName = carDetails.getName<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(getCarName()) <span class="hljs-comment">// Ford Ranger</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite console.log produziert einen Ford Ranger, und das ist komisch. </font><font style="vertical-align: inherit;">Der Grund für dieses Verhalten ist, dass der "Eigentümer" von getCarName das Fensterobjekt ist. </font><font style="vertical-align: inherit;">Mit dem Schlüsselwort var im globalen Bereich deklarierte Variablen werden in die Eigenschaften des Fensterobjekts geschrieben. </font><font style="vertical-align: inherit;">Dies bezieht sich im globalen Bereich auf das Fensterobjekt (es sei denn, es handelt sich um einen strengen Modus).</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(getCarName === <span class="hljs-built_in">window</span>.getCarName) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(getCarName === <span class="hljs-keyword">this</span>.getCarName) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel beziehen sich dieses und das Fenster auf dasselbe Objekt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Möglichkeit, dieses Problem zu lösen, besteht darin, den Aufruf zu verwenden oder Methoden anzuwenden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(getCarName.apply(carDetails)) <span class="hljs-comment">// Ford Mustang</span>
<span class="hljs-built_in">console</span>.log(getCarName.call(carDetails)) <span class="hljs-comment">// Ford Mustang</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rufen Sie auf und wenden Sie als erstes Argument ein Objekt an, dessen Wert dies innerhalb der Funktion ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In IIFE sind Funktionen, die im globalen Bereich erstellt werden, anonyme Funktionen und interne Funktionen der Methoden eines Objekts. Der Standardwert hierfür ist das Fensterobjekt.</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)<font></font>
})() <span class="hljs-comment">// window</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iHateThis</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)<font></font>
}<font></font>
iHateThis() <span class="hljs-comment">// window</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> myFavouriteObj = {<font></font>
    guessThis() {<font></font>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<font></font>
        }<font></font>
        getName()<font></font>
    },<font></font>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span>,<font></font>
    thisIsAnnoying(callback) {<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
<font></font>
myFavouriteObj.guessThis() <span class="hljs-comment">// window</span>
myFavouriteObj.thisIsAnnoying(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// window</span><font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt zwei Möglichkeiten, um Marko Polo zu bekommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens können wir den Wert davon in einer Variablen speichern:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myFavoriteObj = {<font></font>
    guessThis() {<font></font>
        <span class="hljs-keyword">const</span> self = <span class="hljs-keyword">this</span> <span class="hljs-comment">//   this   self</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(self.name)<font></font>
        }<font></font>
        getName()<font></font>
    },<font></font>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span>,<font></font>
    thisIsAnnoying(callback) {<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens können wir die Pfeilfunktion verwenden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myFavoriteObj = {<font></font>
    guessThis() {<font></font>
        <span class="hljs-keyword">const</span> getName = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            <span class="hljs-comment">//   this   </span>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<font></font>
        }<font></font>
        getName()<font></font>
    },<font></font>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span>,<font></font>
    thisIsAnnoying(callback) {<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pfeilfunktionen haben diesen Eigenwert nicht. </font><font style="vertical-align: inherit;">Sie kopieren die Bedeutung davon aus der externen lexikalischen Umgebung.</font></font><br>
<br>
<a name="25"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25. Was ist ein Prototyp eines Objekts?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz gesagt, ein Prototyp ist ein Plan (Diagramm oder Projekt) eines Objekts. </font><font style="vertical-align: inherit;">Es wird als Fallback für die in diesem Objekt vorhandenen Eigenschaften und Methoden verwendet. </font><font style="vertical-align: inherit;">Dies ist auch eine der Möglichkeiten, Eigenschaften und Funktionen zwischen Objekten auszutauschen. </font><font style="vertical-align: inherit;">Dies ist das Grundkonzept der Prototypvererbung in JS.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o = {}
<span class="hljs-built_in">console</span>.log(o.toString()) <span class="hljs-comment">// [object Object]</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl das Objekt "o" nicht über die Eigenschaft toString verfügt, führt der Zugriff auf diese Eigenschaft nicht zu einem Fehler. </font><font style="vertical-align: inherit;">Befindet sich eine bestimmte Eigenschaft nicht im Objekt, wird ihre Suche zuerst im Prototyp des Objekts, dann im Prototyp des Prototyps des Objekts usw. ausgeführt, bis die Eigenschaft gefunden wird. </font><font style="vertical-align: inherit;">Dies wird als Prototypkette bezeichnet. </font><font style="vertical-align: inherit;">Am Anfang der Prototypenkette steht Object.prototype.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(o.toString === <span class="hljs-built_in">Object</span>.prototype.toString) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lesen Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mehr über Prototypen und Vererbung </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="26"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26. Was ist IIFE?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IIFE oder sofort aufgerufene Funktion Ausdruck ist eine Funktion, die unmittelbar nach der Erstellung oder Deklaration aufgerufen oder ausgeführt wird. </font><font style="vertical-align: inherit;">Um IIFE zu erstellen, müssen Sie die Funktion in Klammern (den Gruppierungsoperator) einschließen, in einen Ausdruck umwandeln und dann mit anderen Klammern aufrufen. </font><font style="vertical-align: inherit;">Es sieht so aus: (function () {}) ().</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> </span>) </span>{ }( ))<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> </span>) </span>{ })( )<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">named</span>(<span class="hljs-params">params</span>) </span>{ })( )<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-params">( )</span> =&gt;</span> { })<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">global</span>) </span>{ })(<span class="hljs-built_in">window</span>)<font></font>
<font></font>
<span class="hljs-keyword">const</span> utility = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> </span>) </span>{
    <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">// </span><font></font>
    }<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle diese Beispiele sind gültig. </font><font style="vertical-align: inherit;">Das vorletzte Beispiel zeigt, dass wir Parameter an IIFE übergeben können. </font><font style="vertical-align: inherit;">Das letzte Beispiel zeigt, dass wir das Ergebnis von IIFE in einer Variablen speichern können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die beste Verwendung von IIFE besteht darin, Konfigurationsfunktionen für die Initialisierung auszuführen und Namenskonflikte mit anderen Variablen im globalen Bereich (Verschmutzung des globalen Namespace) zu verhindern. </font><font style="vertical-align: inherit;">Wir geben ein Beispiel.</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script src=<span class="hljs-string">"https://cdnurl.com/somelibrary.js"</span>&gt;&lt;/script&gt;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben einen Link zur Bibliothek somelibrary.js, die einige globale Funktionen bereitstellt, die wir in unserem Code verwenden können. In dieser Bibliothek gibt es jedoch zwei Methoden, createGraph und drawGraph, die wir nicht verwenden, da sie Fehler enthalten. </font><font style="vertical-align: inherit;">Und wir wollen diese Funktionen selbst implementieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Möglichkeit, dieses Problem zu lösen, besteht darin, die Struktur unserer Skripte zu ändern:</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script src=<span class="hljs-string">"https://cdnurl.com/somelibrary.js"</span>&gt;&lt;/script&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher definieren wir die von der Bibliothek bereitgestellten Methoden neu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite Weg ist die Änderung der Namen unserer Funktionen:</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script src=<span class="hljs-string">"https://cdnurl.com/somelibrary.js"</span>&gt;&lt;/script&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCreateGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myDrawGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der dritte Weg ist die Verwendung von IIFE:</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script&gt;
    <span class="hljs-keyword">const</span> graphUtility = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createGraph</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">// </span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawGraph</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">// </span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> {<font></font>
            createGraph,<font></font>
            drawGraph<font></font>
        }<font></font>
    })<font></font>
&lt;/script&gt;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel erstellen wir eine Dienstprogrammvariable, die das IIFE-Ergebnis enthält und ein Objekt zurückgibt, das die Methoden createGraph und drawGraph enthält. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein weiteres Problem, das mit IIFE gelöst werden kann:</font></font><br>
<br>
<pre><code class="javascript hljs">val li = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.list-group &gt; li'</span>)
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i - <span class="hljs-number">0</span>, len = li.length; i &lt; len; i++) {<font></font>
    li[i].addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(i)<font></font>
    })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben ein ul-Element mit einer Listengruppenklasse, die 5 untergeordnete Elemente li enthält. </font><font style="vertical-align: inherit;">Und wir möchten den Wert "i" in der Konsole anzeigen, wenn wir auf ein separates "li" klicken. </font><font style="vertical-align: inherit;">Stattdessen zeigt die Konsole jedoch immer 5 an. Der Fehler ist der gesamte Fehler. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Lösung ist IIFE:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.list-group &gt; li'</span>)
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = li.length; i &lt; len; i++) {<font></font>
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentIndex</span>) </span>{<font></font>
        li[currentIndex].addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
            <span class="hljs-built_in">console</span>.log(currentIndex)<font></font>
        })<font></font>
    })(i)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Grund, warum dieser Code wie beabsichtigt funktioniert, ist, dass IIFE bei jeder Iteration einen neuen Bereich erstellt und wir den Wert "i" in currentIndex schreiben.</font></font><br>
<br>
<a name="27"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">27. Wofür wird die Function.prototype.apply-Methode verwendet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Apply wird ein bestimmtes Objekt an diesen Wert der aufgerufenen Funktion gebunden.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> details = {
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello World!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMessage</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.message<font></font>
}<font></font>
<font></font>
getMessage.apply(details) <span class="hljs-comment">// Hello World!</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Methode ähnelt Function.prototype.call. </font><font style="vertical-align: inherit;">Der einzige Unterschied besteht darin, dass in apply die Argumente als Array übergeben werden.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> person = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeting</span>(<span class="hljs-params">greetingMessage</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${greetingMessage}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
}<font></font>
<font></font>
greeting.apply(person, [<span class="hljs-string">'Hello'</span>]) <span class="hljs-comment">// Hello Marko Polo</span>
</code></pre><br>
<a name="28"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28. Wofür wird die Methode function.prototype.call verwendet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Call wird verwendet, um ein bestimmtes Objekt an den Wert dieser aufgerufenen Funktion zu binden.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> details = {
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello World!'</span><font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMessage</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.message;<font></font>
}<font></font>
<font></font>
getMessage.call(details); <span class="hljs-comment">// Hello World!</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Methode ähnelt Function.prototype.apply. </font><font style="vertical-align: inherit;">Der Unterschied besteht darin, dass beim Aufruf Argumente durch Kommas getrennt übergeben werden.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> person = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span><font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeting</span>(<span class="hljs-params">greetingMessage</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${greetingMessage}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span>;<font></font>
}<font></font>
<font></font>
greeting.call(person, <span class="hljs-string">'Hello'</span>); <span class="hljs-comment">// Hello Marko Polo</span>
</code></pre><br>
<a name="29"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">29. Was ist der Unterschied zwischen Aufruf- und Anwendungsmethoden?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Unterschied zwischen call und apply besteht darin, wie wir Argumente in der aufgerufenen Funktion übergeben. </font><font style="vertical-align: inherit;">In apply werden die Argumente als Array übergeben, in call, durch Kommas getrennt.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj1 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> obj2 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduceAdd</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) {<font></font>
        result += <span class="hljs-built_in">arguments</span>[i]<font></font>
    }<font></font>
    <span class="hljs-keyword">this</span>.result = result<font></font>
}<font></font>
<font></font>
reduceAdd.apply(obj1, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]) <span class="hljs-comment">// 15</span>
reduceAdd.call(obj2, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 15</span>
</code></pre><br>
<a name="30"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30. Wofür wird die Methode function.prototype.bind verwendet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bind gibt eine neue Funktion zurück, deren Wert das als erster Parameter angegebene Objekt ist. </font><font style="vertical-align: inherit;">Rufen Sie im Gegensatz zum Binden die Funktion auf und rufen Sie sie sofort auf.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props)
        <span class="hljs-keyword">this</span>.state = {
            <span class="hljs-attr">value</span>: <span class="hljs-string">''</span><font></font>
        }<font></font>
        <span class="hljs-keyword">this</span>.handleChange = <span class="hljs-keyword">this</span>.handleChange.bind(<span class="hljs-keyword">this</span>)
        <span class="hljs-comment">//   handleChange   MyComponent</span><font></font>
    }<font></font>
<font></font>
    handleChange(e) {<font></font>
        <span class="hljs-comment">// </span><font></font>
    }<font></font>
<font></font>
    render() {<font></font>
        <span class="hljs-keyword">return</span> ( &lt; &gt;<font></font>
            &lt;<font></font>
            input type = {<font></font>
                <span class="hljs-keyword">this</span>.props.type<font></font>
            }<font></font>
            value = {<font></font>
                <span class="hljs-keyword">this</span>.state.value<font></font>
            }<font></font>
            onChange = {<font></font>
                <span class="hljs-keyword">this</span>.handleChange<font></font>
            }<font></font>
            /&gt; &lt;/ &gt;<font></font>
        )<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<a name="31"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">31. Was ist funktionale Programmierung und welche Funktionen von JS ermöglichen es uns, darüber als funktionale Programmiersprache zu sprechen?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktionale Programmierung ist ein deklaratives Programmierkonzept oder ein Beispiel (Muster) dafür, wie Anwendungen erstellt werden und wie Funktionen verwendet werden, die Ausdrücke enthalten, die Werte berechnen, ohne die an sie übergebenen Argumente zu ändern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Array-Objekt enthält die Zuordnungs-, Filter- und Reduzierungsmethoden, die aufgrund ihrer Nützlichkeit und auch, weil sie das Array nicht ändern, die diese Funktionen „sauber“ machen, die bekanntesten Funktionen in der Welt der funktionalen Programmierung sind. </font><font style="vertical-align: inherit;">JS hat auch einen Abschluss und Funktionen höherer Ordnung, die Merkmale einer funktionalen Programmiersprache sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Map-Methode gibt ein neues Array mit Rückrufergebnissen für jedes Element des Arrays zurück:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> words = [<span class="hljs-string">'Functional'</span>, <span class="hljs-string">'Procedural'</span>, <span class="hljs-string">'Object-Oriented'</span>]<font></font>
<font></font>
<span class="hljs-keyword">const</span> wordsLength = words.map(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word.length)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Filtermethode erstellt ein neues Array mit allen Elementen, die die im Rückruf angegebene Bedingung erfüllen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> data = {<font></font>
    {<font></font>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Mark'</span>,
        <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">true</span><font></font>
    } {<font></font>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Mary'</span>,
        <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">false</span><font></font>
    } {<font></font>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Mae'</span>,
        <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">true</span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> registeredUsers = data.filter(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.isRegistered)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Reduktionsmethode führt einmalig einen Rückruf für jedes Element des Arrays aus, mit Ausnahme von Hohlräumen, wobei vier Argumente verwendet werden: der Anfangswert (oder der Wert aus dem vorherigen Rückruf), der Wert des aktuellen Elements, der aktuelle Index und das iterierte Array:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> strs = [<span class="hljs-string">'I'</span>, <span class="hljs-string">' '</span>, <span class="hljs-string">'am'</span>, <span class="hljs-string">' '</span>, <span class="hljs-string">'Iron'</span>, <span class="hljs-string">' '</span>, <span class="hljs-string">'Man'</span>]<font></font>
<font></font>
<span class="hljs-keyword">const</span> result = strs.reduce(<span class="hljs-function">(<span class="hljs-params">acc, currentStr</span>) =&gt;</span> acc + str, <span class="hljs-string">''</span>)
</code></pre><br>
<a name="32"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32. Was sind Funktionen höherer Ordnung?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Funktion höherer Ordnung ist eine Funktion, die eine andere Funktion zurückgibt oder eine andere Funktion als Argument akzeptiert.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">higherOrderFunction</span>(<span class="hljs-params">param, callback</span>) </span>{
    <span class="hljs-keyword">return</span> callback(param)<font></font>
}<font></font>
</code></pre><br>
<a name="33"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">33. Warum werden Funktionen in JS als erstklassige Objekte bezeichnet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktionen werden als erstklassige Objekte bezeichnet, da sie wie jeder andere Wert in JS verarbeitet werden. </font><font style="vertical-align: inherit;">Sie können Variablen zugewiesen werden, eine Eigenschaft eines Objekts (einer Methode), ein Element eines Arrays, ein Argument für eine andere Funktion und der von der Funktion zurückgegebene Wert sein. </font><font style="vertical-align: inherit;">Der einzige Unterschied zwischen einer Funktion und einem anderen Wert in JS besteht darin, dass die Funktion ausgeführt oder aufgerufen werden kann.</font></font><br>
<br>
<a name="34"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">34. Wie würden Sie die Array.prototype.map-Methode implementieren?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">arr, mapCallback</span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr) || !arr.length || <span class="hljs-keyword">typeof</span> mapCallback !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> []<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">let</span> result = []
        <span class="hljs-comment">//         </span>
        <span class="hljs-comment">//       </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) {<font></font>
            result.push(mapCallback(arr[i], i, arr))<font></font>
            <span class="hljs-comment">//   mapCallback  result</span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Map-Methode erstellt ein neues Array mit dem Ergebnis des Aufrufs der angegebenen Funktion für jedes Element des Arrays.</font></font><br>
<br>
<a name="35"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">35. Wie würden Sie die Array.prototype.filter-Methode implementieren?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span>(<span class="hljs-params">arr, filterCallback</span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr) || !arr.length || <span class="hljs-keyword">typeof</span> filterCallback !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> []<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">let</span> result = []
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) {
            <span class="hljs-comment">//      </span>
            <span class="hljs-keyword">if</span> (filterCallback(arr[i], i, arr)) {
                <span class="hljs-comment">//  ,  ,  result</span><font></font>
                result.push(arr[i])<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Filtermethode erstellt ein neues Array mit allen Elementen, die den in der übergebenen Funktion angegebenen Test bestanden haben.</font></font><br>
<br>
<a name="36"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">36. Wie würden Sie die Array.prototype.reduce-Methode implementieren?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduce</span>(<span class="hljs-params">arr, reduceCallbak, initialValue</span>) </span>{
    <span class="hljs-comment">// ..</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr) || !arr.length || <span class="hljs-keyword">typeof</span> filterCallback !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> []<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//        initialValue, </span>
        <span class="hljs-keyword">let</span> hasInitialValue = initialValue !== <span class="hljs-literal">undefined</span>
        <span class="hljs-keyword">let</span> value = hasInitialValue ? initialValue : arr[<span class="hljs-number">0</span>]
        <span class="hljs-comment">//      initialValue</span><font></font>
<font></font>
        <span class="hljs-comment">//    ,   1,       initialValue,   0,    </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = hasInitialValue ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>, len = arr.length; i &lt; len; i++) {
            <span class="hljs-comment">//         reduceCallback </span><font></font>
            value = reduceCallback(value, arr[i], i, arr)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> value<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Reduktionsmethode wendet die Reduzierungsfunktion auf jedes Element des Arrays an (von links nach rechts) und gibt einen resultierenden Wert zurück.</font></font><br>
<br>
<a name="37"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">37. Was ist ein Argumentobjekt?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Argumente ist eine Sammlung von Argumenten, die an eine Funktion übergeben werden. </font><font style="vertical-align: inherit;">Dies ist ein Array-ähnliches Objekt, es hat die Eigenschaft length, wir können mit Argumenten [i] auf einen bestimmten Wert zugreifen, aber es verfügt nicht über die Methoden forEach, redu, filter und map. </font><font style="vertical-align: inherit;">Hier können Sie die Anzahl der Funktionsparameter ermitteln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können Argumente mit Array.prototype.slice in ein Array konvertieren:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie daran: In Pfeilfunktionen funktioniert das Argumentobjekt nicht.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">one</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span><font></font>
}<font></font>
<span class="hljs-keyword">const</span> two = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span><font></font>
}<font></font>
<span class="hljs-keyword">const</span> three = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">three</span>(<span class="hljs-params">{
    return arguments
}</span>)
<span class="hljs-title">const</span> <span class="hljs-title">four</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title">arguments</span>

<span class="hljs-title">four</span>(<span class="hljs-params"></span>) // <span class="hljs-title">arguments</span> <span class="hljs-title">is</span> <span class="hljs-title">not</span> <span class="hljs-title">defined</span>
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Aufrufen der vier Funktionen führt zu einem ReferenceError: Argumente ist kein definierter Fehler. </font><font style="vertical-align: inherit;">Dieses Problem kann mit der rest-Anweisung gelöst werden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> four = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> args
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dadurch werden automatisch alle Parameter in ein Array eingefügt.</font></font><br>
<br>
<a name="38"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">38. Wie erstelle ich ein Objekt ohne Prototyp?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies kann mit Object.create erfolgen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o1 = {}
<span class="hljs-built_in">console</span>.log(o1.toString) <span class="hljs-comment">// [object Object]</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> o2 = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>) <span class="hljs-comment">//      Object-create  -</span>
<span class="hljs-comment">//    -,   null</span>
<span class="hljs-built_in">console</span>.log(o2.toString) <span class="hljs-comment">// o2.toString is not a function</span>
</code></pre><br>
<a name="39"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">39. Warum wird im dargestellten Code die Variable b global, wenn die Funktion aufgerufen wird?</font></font></h4><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> a = b = <span class="hljs-number">0</span><font></font>
}<font></font>
myFunc()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies geschieht, weil der Zuweisungsoperator ("=") eine rechtshändige Assoziativität aufweist, d. H. </font><font style="vertical-align: inherit;">weist Werte von rechts nach links zu. </font><font style="vertical-align: inherit;">Daher hat der Code die folgende Form:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> a = (b = <span class="hljs-number">0</span>)<font></font>
}<font></font>
myFunc()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst wird der Variablen "b" der Wert 0 zugewiesen, der nicht deklariert ist. </font><font style="vertical-align: inherit;">Die JS-Engine macht es global. </font><font style="vertical-align: inherit;">Der von b = 0 zurückgegebene Wert (0) wird dann der lokalen Variablen "a" zugewiesen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Problem kann gelöst werden, indem zuerst lokale Variablen deklariert und ihnen dann Werte zugewiesen werden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> a, b<font></font>
    a = b = <span class="hljs-number">0</span><font></font>
}<font></font>
myFunc()<font></font>
</code></pre><br>
<a name="40"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">40. Was ist ECMAScript?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ECMAScript ist eine Spezifikation, eine Standard-Programmiersprache für Skripte. Sie ist die Basis von JS, sodass alle Änderungen an ECMAScript in JS berücksichtigt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die neueste Version der ECMA-262-Spezifikation kann hier eingesehen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="41"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">41. Welche neuen Dinge brachte ES6 oder ECMAScript2015 zu JS?</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pfeilfunktionen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Template Strings.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweiterte Objektliterale</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Destrukturierung (Objektzerstörung).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versprechen Versprechen).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generatoren</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Module</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proxies</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sets.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Standardoptionen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruhe- und Verbreitungsoperatoren.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blockbereich (Schlüsselwörter "let" und "const").</font></font></li>
</ul><br>
<a name="42"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">42. Was ist der Unterschied zwischen den Schlüsselwörtern "var", "let" und "const"?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dem Schlüsselwort var deklarierte Variablen sind global. </font><font style="vertical-align: inherit;">Dies bedeutet, dass sie von überall im Code zugänglich sind:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeX</span>(<span class="hljs-params">showX</span>)</span>{
    <span class="hljs-keyword">if</span>(showX){
        <span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> x<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(giveMeX(<span class="hljs-literal">false</span>))
<span class="hljs-built_in">console</span>.log(giveMeX(<span class="hljs-literal">true</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis des ersten console.log ist undefiniert, das zweite - 5. Wir haben Zugriff auf die Variable "x", da sie in den globalen Bereich aufgenommen wird. </font><font style="vertical-align: inherit;">Der Code aus dem obigen Beispiel wird wie folgt interpretiert:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeX</span>(<span class="hljs-params">showX</span>)</span>{
    <span class="hljs-keyword">var</span> x <span class="hljs-comment">//   undefined</span>
    <span class="hljs-keyword">if</span>(showX){<font></font>
        x = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> x<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis der ersten console.log ist undefiniert, da deklarierte Variablen, denen kein Wert zugewiesen wurde, standardmäßig nicht definiert sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Variablen, die mit den Schlüsselwörtern "let" und "const" deklariert wurden, haben einen Blockbereich. </font><font style="vertical-align: inherit;">Dies bedeutet, dass sie nur innerhalb des Blocks ({}) verfügbar sind:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeX</span>(<span class="hljs-params">showX</span>)</span>{
    <span class="hljs-keyword">if</span>(showX){
        <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> x<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeY</span>(<span class="hljs-params">showY</span>)</span>{
    <span class="hljs-keyword">if</span>(showY){
        <span class="hljs-keyword">let</span> y = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> y<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Aufrufen dieser Funktionen mit dem Parameter false führt zu einem ReferenceError-Fehler, da auf die Variablen "x" und "y" außerhalb des Blocks nicht zugegriffen werden kann und ihre Werte nicht zurückgegeben werden (nicht auftauchen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Unterschied zwischen "let" und "const" besteht darin, dass wir im ersten Fall den Wert der Variablen ändern können und im zweiten - no (Konstante). </font><font style="vertical-align: inherit;">Gleichzeitig können wir den Wert der Eigenschaft eines mit const deklarierten Objekts ändern, nicht jedoch die Eigenschaft selbst (Variable).</font></font><br>
<br>
<a name="43"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">43. Was sind Pfeilfunktionen (Pfeilfunktionen)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Pfeilfunktion ist eine relativ neue Methode zum Erstellen von Funktionen in JS. </font><font style="vertical-align: inherit;">Pfeilfunktionen sind schneller und haben eine besser lesbare Syntax als funktionale Ausdrücke. </font><font style="vertical-align: inherit;">In Pfeilfunktionen wird das Wort "Funktion" weggelassen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> getCurrentDate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> getCurrentDate = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einem funktionalen Ausdruck verwenden wir das Schlüsselwort return, um einen Wert zurückzugeben. </font><font style="vertical-align: inherit;">In der Pfeilfunktion tun wir dies nicht, da Pfeilfunktionen implizit Werte zurückgeben, vorausgesetzt, wir geben einen einzelnen Ausdruck oder Wert zurück:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span> <font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> greet = <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>
<span class="hljs-keyword">const</span> greet2 = name = &gt; <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können auch Parameter an Pfeilfunktionen übergeben. </font><font style="vertical-align: inherit;">Wenn wir einen Parameter übergeben, müssen wir ihn nicht in Klammern setzen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> getArgs = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">arguments</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> getArgs2 = <span class="hljs-function">(<span class="hljs-params">...rest</span>) =&gt;</span> rest
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pfeilfunktionen haben keinen Zugriff auf das Argumentobjekt. </font><font style="vertical-align: inherit;">Daher führt der Aufruf der ersten Funktion zu einem Fehler. </font><font style="vertical-align: inherit;">Um die Parameter an die Funktion zu übergeben, können wir den Rest-Operator verwenden.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> data = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span>
    <span class="hljs-attr">nums</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<font></font>
    computeResult(){<font></font>
        <span class="hljs-comment">// this    data</span>
        <span class="hljs-keyword">const</span> addAll = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-comment">//     this   </span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nums.reduce(<span class="hljs-function">(<span class="hljs-params">total, cur</span>) =&gt;</span> total + cur, <span class="hljs-number">0</span>)<font></font>
        }<font></font>
    <span class="hljs-keyword">this</span>.result = addAll()<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<a name="44"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">44. Was sind Klassen?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Klassen sind eine relativ neue Art, Konstruktorfunktionen in JS zu schreiben. </font><font style="vertical-align: inherit;">Dies ist syntaktischer Zucker für Konstruktorfunktionen. </font><font style="vertical-align: inherit;">Klassen basieren auf denselben Prototypen und derselben Prototypenvererbung:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">firstName, lastName, age, address</span>)</span>{
    <span class="hljs-keyword">this</span>.firstName = firstName
    <span class="hljs-keyword">this</span>.lastName = lastName
    <span class="hljs-keyword">this</span>.age = age
    <span class="hljs-keyword">this</span>.address = address<font></font>
}<font></font>
<font></font>
Person.self = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><font></font>
}<font></font>
<font></font>
Person.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Person]'</span><font></font>
}<font></font>
<font></font>
Person.prototype.getFullName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.lastName<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>{
    <span class="hljs-keyword">constructor</span>(firstName, lastName, age, address){
        <span class="hljs-keyword">this</span>.firstName = firstName
        <span class="hljs-keyword">this</span>.lastName = lastName
        <span class="hljs-keyword">this</span>.age = age
        <span class="hljs-keyword">this</span>.address = address<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> self(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><font></font>
    }<font></font>
<font></font>
    toString(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Person]'</span><font></font>
    }<font></font>
<font></font>
    getFullName(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.firstName}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.lastName}</span>`</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Methodenüberschreibungen und Vererbung von einer anderen Klasse:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
Employee.prototype = <span class="hljs-built_in">Object</span>.create(Person.prototype)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">firstName, lastName, age, address, jobTitle, yearStarted</span>)</span>{<font></font>
    Person.call(<span class="hljs-keyword">this</span>, firstName, lastName, age, address)
    <span class="hljs-keyword">this</span>.jobTitle = jobTitle
    <span class="hljs-keyword">this</span>.yearStarted = yearStarted<font></font>
}<font></font>
<font></font>
Employee.prototype.describe = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`I am <span class="hljs-subst">${<span class="hljs-keyword">this</span>.getFullName()}</span> and I have a position of #{this.jobTitle} and I started at <span class="hljs-subst">${<span class="hljs-keyword">this</span>.yearStarted}</span>}`</span><font></font>
}<font></font>
<font></font>
Employee.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Employee]'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>{ <span class="hljs-comment">//   Person</span>
    <span class="hljs-keyword">constructor</span>(firstName, lastName, age, address, jobTitle, yearStarted){
        <span class="hljs-keyword">super</span>(firstName, lastName, age, address)
        <span class="hljs-keyword">this</span>.jobTitle = jobTitle
        <span class="hljs-keyword">this</span>.yearStarted = yearStarted<font></font>
    }<font></font>
<font></font>
    describe(){<font></font>
       <span class="hljs-keyword">return</span> <span class="hljs-string">`I am <span class="hljs-subst">${<span class="hljs-keyword">this</span>.getFullName()}</span> and I have a position of #{this.jobTitle} and I started at <span class="hljs-subst">${<span class="hljs-keyword">this</span>.yearStarted}</span>}`</span> <font></font>
    }<font></font>
<font></font>
    toString(){ <span class="hljs-comment">//   toString  Person</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Employee]'</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie lerne ich die Verwendung von Prototypen kennen?</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Something</span></span>{ }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AnotherSomething</span>(<span class="hljs-params"></span>)</span>{ }<font></font>
<font></font>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">as</span> = <span class="hljs-keyword">new</span> AnotherSomething()
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Something()<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> Something) <span class="hljs-comment">// function</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> AnotherSomething) <span class="hljs-comment">// function</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">as</span>.toString()) <span class="hljs-comment">// [object Object]</span>
<span class="hljs-built_in">console</span>.log(a.toString()) <span class="hljs-comment">// [object Object]</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">as</span>.toString === <span class="hljs-built_in">Object</span>.prototype.toString)
<span class="hljs-built_in">console</span>.log(a.toString === <span class="hljs-built_in">Object</span>.prototype.toString)
<span class="hljs-comment">//     true</span>
<span class="hljs-comment">// Object.prototype     </span>
<span class="hljs-comment">// Something  AnotherSomething   Object.prototype</span>
</code></pre><br>
<a name="45"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">45. Was sind Vorlagenliterale?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vorlagenliterale sind eine relativ neue Methode zum Erstellen von Zeichenfolgen in JS. </font><font style="vertical-align: inherit;">Vorlagenliterale werden mit doppelten Backticks (``) erstellt:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> greet = <span class="hljs-string">'Hi I\'m Mark'</span><font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">let</span> greet = <span class="hljs-string">`Hi I'm Mark`</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Vorlagenliteralen müssen wir uns nicht in einfache Anführungszeichen setzen.</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> lastWords = <span class="hljs-string">'\n'</span>
    + <span class="hljs-string">' I \n'</span>
    + <span class="hljs-string">' am \n'</span>
    + <span class="hljs-string">'Iron Man \n'</span><font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">let</span> lastWords = <span class="hljs-string">`
    I
    am
    Iron Man
`</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In ES6 müssen wir die Escape-Sequenz "\ n" nicht verwenden, um die Zeile zu speisen.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>!`</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In ES6 müssen wir keine Zeichenfolgenverkettung verwenden, um Text mit einer Variablen zu kombinieren. Wir können den Ausdruck $ {expr} verwenden, um den Wert der Variablen abzurufen.</font></font><br>
<br>
<a name="46"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">46. ​​Was ist Objektzerstörung?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Destrukturierung ist eine relativ neue Methode zum Abrufen (Abrufen) der Werte eines Objekts oder Arrays. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir haben ein Objekt wie dieses:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> employee = {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Marko'</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Polo'</span>,
    <span class="hljs-attr">position</span>: <span class="hljs-string">'Software Developer'</span>,
    <span class="hljs-attr">yearHired</span>: <span class="hljs-number">2017</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuvor haben wir zum Erstellen der Eigenschaften eines Objekts Variablen für jede Eigenschaft erstellt. </font><font style="vertical-align: inherit;">Es war sehr langweilig und sehr nervig:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> firstName = employee.firstName
<span class="hljs-keyword">var</span> lastName = employee.lastName
<span class="hljs-keyword">var</span> position = employee.position
<span class="hljs-keyword">var</span> yearHired = employee.yearHired
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch die Verwendung der Destrukturierung wird der Code sauberer und benötigt weniger Zeit. </font><font style="vertical-align: inherit;">Die Destrukturierungssyntax lautet wie folgt: Wir schließen die Objekteigenschaften, die wir erhalten möchten, in geschweifte Klammern ({}) und, wenn es sich um ein Array handelt, in eckige Klammern ([]) ein:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> { firstName, lastName, position, yearHired } = employee
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie "propertyName: newName", um den Variablennamen zu ändern:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> { <span class="hljs-attr">firstName</span>: fName, <span class="hljs-attr">lastName</span>: lName, position, yearHired } = employee
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie "propertyName = 'defaultValue'", um Variablen Standardwerte zuzuweisen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> { firstName = <span class="hljs-string">'Mark'</span>, <span class="hljs-attr">lastName</span>: lName, position, yearHired } = employee
</code></pre><br>
<a name="47"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">47. Was sind Module?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Modulen können Sie Code aus verschiedenen Dateien kombinieren (verwenden) und müssen nicht den gesamten Code in einer großen Datei speichern. </font><font style="vertical-align: inherit;">Bevor Module in JS erschienen, gab es zwei beliebte Modulsysteme zur Unterstützung von Code:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CommonJS - Nodejs</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMD (AsyncronousModuleDefinition) - Browser</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Syntax der Module ist sehr einfach: Wir verwenden den Import, um Funktionen oder Werte aus einer anderen Datei oder Dateien zu importieren, und den Export, um ihn zu exportieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exportfunktionalität in eine andere Datei (benannter Export):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - helpers.js</span>
exports.isNull = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span><font></font>
}<font></font>
<font></font>
exports.isUndefined = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span><font></font>
}<font></font>
<font></font>
exports.isNullOrUndefined = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> exports.isNull(val) || exports.isUndefined(val)<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNull</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUndefined</span>(<span class="hljs-params">val</span>) </span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNullOrUndefined</span>(<span class="hljs-params">val</span>) </span>{
    <span class="hljs-keyword">return</span> isNull(val) || isUndefined(val);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Importieren Sie Funktionen in eine andere Datei:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - index.js</span>
<span class="hljs-keyword">const</span> helpers = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>)
<span class="hljs-keyword">const</span> isNull = helpers.isNull
<span class="hljs-keyword">const</span> isUndefined = helpers.isUndefined
<span class="hljs-keyword">const</span> isNullOrUndefined = helpers.isNullOrUndefined<font></font>
<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> { isNull, isUndefined, isNullOrUndefined } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>)<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> helpers <span class="hljs-keyword">from</span> <span class="hljs-string">'./helpers.js'</span> <span class="hljs-comment">// helpers -  </span><font></font>
<font></font>
<span class="hljs-comment">// </span>
<span class="hljs-keyword">import</span> { isNull, isUndefined, isNullOrUndefined <span class="hljs-keyword">as</span> isValid} <span class="hljs-keyword">from</span> <span class="hljs-string">'./helpers.js'</span> <span class="hljs-comment">//  "as"  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Standardexport:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - index.js</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Helpers</span> </span>{
    <span class="hljs-keyword">static</span> isNull(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isUndefined(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isNullOrUndefined(val){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNull(val) || <span class="hljs-keyword">this</span>.isUndefined(val)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">module</span>.exports = Helpers<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Helpers</span> </span>{
    <span class="hljs-keyword">static</span> isNull(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isUndefined(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isNullOrUndefined(val){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNull(val) || <span class="hljs-keyword">this</span>.isUndefined(val)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Helpers
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Importieren:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - index.js</span>
<span class="hljs-keyword">const</span> Helpers = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>)
<span class="hljs-built_in">console</span>.log(Helpers.isNull(<span class="hljs-literal">null</span>))<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-keyword">import</span> Helpers <span class="hljs-keyword">from</span> <span class="hljs-string">'./helpers.js'</span>
<span class="hljs-built_in">console</span>.log(Helpers.isNull(<span class="hljs-literal">null</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist die grundlegende Verwendung von Modulen. </font><font style="vertical-align: inherit;">Ich bin nicht auf Details eingegangen, weil mein Beitrag bereits zu groß ist.</font></font><br>
<br>
<a name="48"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">48. Was ist ein Set-Objekt?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dem Set-Objekt können Sie eindeutige Werte, Grundelemente und Objektreferenzen speichern. </font><font style="vertical-align: inherit;">Noch einmal: Es können nur eindeutige Werte zu Set hinzugefügt werden. </font><font style="vertical-align: inherit;">Es überprüft die darin gespeicherten Werte mit dem SameZeroValue-Algorithmus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Set-Instanz wird mit dem Set-Konstruktor erstellt. </font><font style="vertical-align: inherit;">Wir können ihm auch einige Werte beim Erstellen übergeben:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()
<span class="hljs-keyword">const</span> set2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>]) <span class="hljs-comment">//  "d"  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können Set mit der add-Methode Werte hinzufügen. </font><font style="vertical-align: inherit;">Da die add-Methode zurückgegeben werden kann, können wir eine Kette von Aufrufen verwenden:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.add(<span class="hljs-string">'f'</span>)<font></font>
set2.add(<span class="hljs-string">'g'</span>).add(<span class="hljs-string">'h'</span>).add(<span class="hljs-string">'i'</span>).add(<span class="hljs-string">'j'</span>).add(<span class="hljs-string">'k'</span>).add(<span class="hljs-string">'k'</span>) <span class="hljs-comment">//  "k"  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können Werte aus Set mit der Löschmethode löschen:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.delete(<span class="hljs-string">'k'</span>) <span class="hljs-comment">// true</span>
set2.delete(<span class="hljs-string">'z'</span>) <span class="hljs-comment">// false,    set2   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können mit der Methode has nach einer Eigenschaft in Set suchen:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.has(<span class="hljs-string">'a'</span>) <span class="hljs-comment">// true</span>
set2.has(<span class="hljs-string">'z'</span>) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie die Größenmethode, um die Länge von Set zu ermitteln:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.size <span class="hljs-comment">// 10</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Löschmethode löscht Set:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.clear() <span class="hljs-comment">// </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können Set verwenden, um doppelte Werte in einem Array zu entfernen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>]
<span class="hljs-keyword">const</span> uniqNums = [...new <span class="hljs-built_in">Set</span>(nums)] <span class="hljs-comment">// [1,2,3,4,5,6,7,8]</span>
</code></pre><br>
<a name="49"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">49. Was ist eine Rückruffunktion?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Rückruffunktion ist eine Funktion, deren Aufruf für die Zukunft verschoben wird (tritt unter bestimmten Bedingungen auf, z. B. wenn ein Ereignis eintritt).</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> btnAdd = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btnAdd'</span>)<font></font>
<font></font>
btnAdd.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickCallback</span>(<span class="hljs-params">e</span>))</span>{
    <span class="hljs-comment">//   </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Beispiel warten wir auf ein "Klick" -Ereignis für ein Element mit der Kennung "btnAdd". </font><font style="vertical-align: inherit;">Durch Klicken wird die Funktion clickCallback aufgerufen. </font><font style="vertical-align: inherit;">Die Rückruffunktion fügt den Daten oder Ereignissen einige Funktionen hinzu. </font><font style="vertical-align: inherit;">Den Reduzierungs-, Filter- und Zuordnungsmethoden wird als zweites Argument eine Rückruffunktion übergeben. </font><font style="vertical-align: inherit;">Eine gute Analogie zum Rückruf ist die folgende Situation: Sie rufen jemanden an, er antwortet nicht, Sie hinterlassen ihm eine Nachricht und warten, bis er zurückruft. </font><font style="vertical-align: inherit;">Ein Anruf oder eine Nachricht ist ein Ereignis oder Daten, und ein Rückruf ist die Erwartung (Antizipation) eines Rückrufs.</font></font><br>
<br>
<a name="50"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">50. Was sind Versprechen?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versprechen sind eine Möglichkeit, mit asynchronem Code in JS zu arbeiten. </font><font style="vertical-align: inherit;">Sie geben das Ergebnis einer asynchronen Operation zurück. </font><font style="vertical-align: inherit;">Es wurden Versprechen erfunden, um das Problem der sogenannten Hölle der Rückruffunktionen zu lösen.</font></font><br>
<br>
<pre><code class="javascript hljs">fs.readFile(<span class="hljs-string">'somefile.txt'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, data</span>)</span>{
    <span class="hljs-keyword">if</span>(e){
        <span class="hljs-built_in">console</span>.log(e)<font></font>
    }<font></font>
    <span class="hljs-built_in">console</span>.log(data)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Probleme mit diesem Ansatz beginnen, wenn wir der ersten (innerhalb der ersten), dann einer weiteren usw. eine weitere asynchrone Operation hinzufügen müssen. </font><font style="vertical-align: inherit;">Als Ergebnis erhalten wir einen unordentlichen und unlesbaren Code:</font></font><br>
<br>
<pre><code class="javascript hljs">fs.readFile(<span class="hljs-string">'somefile.txt'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e,data</span>)</span>{
    <span class="hljs-comment">// </span>
    fs.readFile(<span class="hljs-string">'directory'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, files</span>)</span>{
        <span class="hljs-comment">// </span>
        fs.mkdir(<span class="hljs-string">'directory'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{
            <span class="hljs-comment">// </span><font></font>
        })<font></font>
    })<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so sieht es mit Versprechungen aus:</font></font><br>
<br>
<pre><code class="javascript hljs">promReadFile(<span class="hljs-string">'file/path'</span>)<font></font>
.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> promReaddir(<span class="hljs-string">'directory'</span>)<font></font>
})<font></font>
.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> promMkdir(<span class="hljs-string">'directory'</span>)<font></font>
})<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.error(e)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versprechen hat vier Bedingungen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten ist der Ausgangszustand eines Versprechens. </font><font style="vertical-align: inherit;">Das Ergebnis des Versprechens ist unbekannt, da der Vorgang nicht abgeschlossen ist.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertig - Asynchroner Vorgang abgeschlossen, es gibt ein Ergebnis.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abgelehnt - Asynchroner Vorgang fehlgeschlagen, es gibt einen Grund.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abgeschlossen - abgeschlossen oder abgelehnt.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Promise-Konstruktor akzeptiert das Auflösen und Ablehnen als Parameter. </font><font style="vertical-align: inherit;">Bei der Auflösung wird das Ergebnis der Operation aufgezeichnet, bei Ablehnung der Grund für den Fehler der Operation. </font><font style="vertical-align: inherit;">Das Ergebnis kann in der .then-Methode verarbeitet werden, der Fehler kann in der .catch-Methode verarbeitet werden. </font><font style="vertical-align: inherit;">Die .then-Methode gibt auch ein Versprechen zurück, sodass wir eine Kette verwenden können, die aus mehreren .then besteht.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myPromiseAsync = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {<font></font>
        doSomeAsync(...args, (error, data) =&gt; {<font></font>
            <span class="hljs-keyword">if</span>(error){<font></font>
                reject(error)<font></font>
            } <span class="hljs-keyword">else</span>{<font></font>
                resolve(data)<font></font>
            }<font></font>
        })<font></font>
    })<font></font>
}<font></font>
<font></font>
myPromiseAsync()<font></font>
.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(result)<font></font>
})<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.error(reason)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können eine Hilfsfunktion erstellen, um eine asynchrone Operation vom Rückruf in ein Versprechen umzuwandeln. </font><font style="vertical-align: inherit;">Es wird wie util von Node.js funktionieren ("Promisification"):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> toPromise = <span class="hljs-function">(<span class="hljs-params">asyncFuncWithCallback</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> {<font></font>
            asyncFuncWithCallback(...args, (e, result) =&gt; {<font></font>
                <span class="hljs-keyword">return</span> e ? rej(e) : res(result)<font></font>
            })<font></font>
        })<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> promiseReadFile = toPromise(fs.readFile)<font></font>
<font></font>
promiseReadFile(<span class="hljs-string">'file/path'</span>)<font></font>
.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(data)<font></font>
})<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(e))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mehr über Versprechen können Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="51"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">51. Was ist asynchron / warten?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Async / await ist eine relativ neue Methode zum Schreiben von asynchronem (nicht blockierendem) Code in JS. </font><font style="vertical-align: inherit;">Sie sind in ein Versprechen gehüllt. </font><font style="vertical-align: inherit;">Es macht Code lesbarer und sauberer als Versprechen und Rückruffunktionen. </font><font style="vertical-align: inherit;">Um jedoch async / await verwenden zu können, müssen Sie die Versprechen gut kennen.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callApi</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">'url/to/api/endpoint'</span>)<font></font>
    .then(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> resp.json())<font></font>
    .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-comment">//   </span>
    }).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
        <span class="hljs-comment">//   </span><font></font>
    })<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// async/await</span>
<span class="hljs-comment">//     try/catch</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callApi</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">const</span> resp = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'url/to/api/endpoint'</span>)
        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.json()
        <span class="hljs-comment">//   </span>
    } <span class="hljs-keyword">catch</span>(e){
        <span class="hljs-comment">//   </span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie daran: Wenn Sie das Schlüsselwort async verwenden, bevor eine Funktion es zwingt, ein Versprechen zurückzugeben:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> giveMeOne = <span class="hljs-keyword">async</span> () = <span class="hljs-number">1</span><font></font>
<font></font>
giveMeOne()<font></font>
.then(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(num) <span class="hljs-comment">// 1</span><font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Schlüsselwort await kann nur innerhalb einer asynchronen Funktion verwendet werden. </font><font style="vertical-align: inherit;">Die Verwendung von await in einer anderen Funktion führt zu einem Fehler. </font><font style="vertical-align: inherit;">Warten Sie, bis der Ausdruck rechts beendet ist, um seinen Wert vor der nächsten Codezeile zurückzugeben.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> giveMeOne = <span class="hljs-keyword">async</span>() =&gt; <span class="hljs-number">1</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOne</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">const</span> num = <span class="hljs-keyword">await</span> giveMeOne()
        <span class="hljs-built_in">console</span>.log(num)<font></font>
    } <span class="hljs-keyword">catch</span>(e){
        <span class="hljs-built_in">console</span>.log(e)<font></font>
    }<font></font>
}<font></font>
<span class="hljs-comment">// Uncaught SyntaxError: await is only valid in an async function</span><font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTwo</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">const</span> num1 = <span class="hljs-keyword">await</span> giveMeOne()
        <span class="hljs-keyword">const</span> nm2 = <span class="hljs-keyword">await</span> giveMeOne()
        <span class="hljs-keyword">return</span> num1 + num2<font></font>
    } <span class="hljs-keyword">catch</span>(e){
        <span class="hljs-built_in">console</span>.log(e)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">await</span> getTwo() <span class="hljs-comment">// 2</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lesen Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mehr über async / await </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="52"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">52. Was ist der Unterschied zwischen einem Spread-Operator und einem Rest-Operator?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anweisungenpread und rest haben dieselbe Syntax ("..."). </font><font style="vertical-align: inherit;">Der Unterschied liegt in der Tatsache, dass wir mit Hilfe von Spread die Daten des Arrays übertragen oder auf andere Daten verteilen und mit Hilfe von Rest alle Parameter der Funktion abrufen und in das Array einfügen (oder einige der Parameter extrahieren).</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>)</span>{
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> nums = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
<span class="hljs-keyword">const</span> sum = add(...nums)
<span class="hljs-built_in">console</span>.log(sum) <span class="hljs-comment">// 11</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel verwenden wir Spread, wenn wir die Add-Funktion mit den Nums-Array-Daten aufrufen. </font><font style="vertical-align: inherit;">Der Wert der Variablen "a" ist 5, b = 6, sum = 11.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">...rest</span>)</span>{
    <span class="hljs-keyword">return</span> rest.reduce(<span class="hljs-function">(<span class="hljs-params">total, current</span>) =&gt;</span> total + current)<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// 3</span>
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment">// 15</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier rufen wir die Funktion add mit einer beliebigen Anzahl von Argumenten auf. </font><font style="vertical-align: inherit;">Add gibt die Summe dieser Argumente zurück.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> [first, ...others] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-built_in">console</span>.log(first) <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.log(others) <span class="hljs-comment">// [2, 3, 4, 5]</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel verwenden wir rest, um eine beliebige Anzahl von Parametern außer dem ersten in das andere Array einzufügen.</font></font><br>
<br>
<a name="53"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">53. Was sind die Standardparameter?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist eine relativ neue Methode zum Definieren von Standardvariablenwerten.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>)</span>{<font></font>
    a = a || <span class="hljs-number">0</span>
    b = b || <span class="hljs-number">0</span>
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span></span>)</span>{
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<span class="hljs-comment">//      "a"  "b" - ,    0</span>
add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können Destrukturierung verwenden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFirst</span>(<span class="hljs-params">[first, ...rest] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</span>)</span>{
    <span class="hljs-keyword">return</span> first<font></font>
}<font></font>
<font></font>
getFirst() <span class="hljs-comment">// 0</span>
getFirst([<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]) <span class="hljs-comment">// 10</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArr</span>(<span class="hljs-params">{ nums } = { nums: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] }</span>)</span>{
    <span class="hljs-keyword">return</span> nums<font></font>
}<font></font>
<font></font>
getArr <span class="hljs-comment">// [1,2,3,4]</span>
getArr({<span class="hljs-attr">nums</span>:[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]}) <span class="hljs-comment">// [5,4,3,2,1]</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können sogar die Standardparameter verwenden, die an derselben Stelle deklariert wurden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomethingWithValue</span>(<span class="hljs-params">value = <span class="hljs-string">'Hello World'</span>, callback = (</span>) =&gt; </span>{ <span class="hljs-built_in">console</span>.log(value) }){<font></font>
    callback()<font></font>
}<font></font>
doSomethingWithValue() <span class="hljs-comment">// Hello World</span>
</code></pre><br>
<a name="54"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">54. Was ist ein Objekt-Wrapper (Wrapper-Objekte)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Grundelemente string, number und boolean haben Eigenschaften und Methoden, obwohl sie keine Objekte sind:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> name = <span class="hljs-string">'marko'</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> name) <span class="hljs-comment">// string</span>
<span class="hljs-built_in">console</span>.log(name.toUpperCase()) <span class="hljs-comment">// MARKO</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Name ist eine Zeichenfolge (primitiver Typ), die keine Eigenschaften und Methoden hat. Wenn wir jedoch die toUpperCase () -Methode aufrufen, führt dies nicht zu einem Fehler, sondern zu „MARKO“. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Grund für dieses Verhalten ist, dass der Name vorübergehend in ein Objekt konvertiert wird. </font><font style="vertical-align: inherit;">Jedes Grundelement außer null und undefiniert hat ein Wrapper-Objekt. </font><font style="vertical-align: inherit;">Solche Objekte sind String, Number, Boolean, Symbol und BigInt. </font><font style="vertical-align: inherit;">In unserem Fall hat der Code die folgende Form:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(name).toUpperCase()) <span class="hljs-comment">// MARKO</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein temporäres Objekt wird nach Abschluss der Arbeit mit einer Eigenschaft oder Methode verworfen.</font></font><br>
<br>
<a name="55"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">55. Was ist der Unterschied zwischen implizitem und explizitem Zwang?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implizite Konvertierung ist eine Möglichkeit, einen Wert ohne unser Wissen (Teilnahme) auf einen anderen Typ zu übertragen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben Folgendes:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-string">'6'</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> + <span class="hljs-literal">true</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span> * <span class="hljs-string">'2'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis der ersten console.log ist 16. In anderen Sprachen würde dies zu einem Fehler führen, aber in JS 1 wird es in eine Zeichenfolge konvertiert und von 6 verkettet (angehängt). Wir haben nichts getan, die Konvertierung erfolgte automatisch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis des zweiten console.log ist 1. False wurde in 0 konvertiert, true in 1. 0 + 1 = 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis des dritten console.log ist 12. Zeile 2 wurde vor dem Multiplizieren mit 6 in eine Zahl konvertiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Explizite Konvertierung impliziert unsere Teilnahme an Umwandeln des Werts in einen anderen Typ:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'6'</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel verwenden wir parseInt, um String 6 in eine Zahl umzuwandeln, addieren dann die beiden Zahlen und erhalten 7.</font></font><br>
<br>
<a name="56"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">56. Was ist NaN? </font><font style="vertical-align: inherit;">Wie überprüfe ich, ob der Wert NaN ist?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NaN oder nicht Eine Zahl (keine Zahl) ist der Wert, der als Ergebnis einer numerischen Operation für einen nicht numerischen Wert erhalten wird:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> a<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'abc'</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-literal">null</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-literal">undefined</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(++a))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>({} * <span class="hljs-number">10</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'abc'</span> - <span class="hljs-number">2</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0</span> / <span class="hljs-number">0</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'10a'</span> * <span class="hljs-number">10</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JS verfügt über eine integrierte isNaN-Methode, mit der Sie überprüfen können, ob der Wert NaN ist, die sich jedoch recht seltsam verhält:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>()) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>({})) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">String</span>(<span class="hljs-string">'a'</span>))) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { })) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis aller console.log ist wahr, obwohl keiner der Werte NaN ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ES6 empfiehlt die Verwendung der Number.isNaN-Methode, um zu überprüfen, ob der Wert NaN ist. </font><font style="vertical-align: inherit;">Wir können auch eine Hilfsfunktion schreiben, um das Problem der „NaN-Ungleichung für sich selbst“ zu lösen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkIsNan</span>(<span class="hljs-params">value</span>)</span>{
    <span class="hljs-keyword">return</span> value !== value<font></font>
}<font></font>
</code></pre><br>
<a name="57"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">57. Wie überprüfe ich, ob ein Wert ein Array ist?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie dazu die Array.isArray-Methode:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-number">5</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-string">''</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray()) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray( {<span class="hljs-attr">length</span>: <span class="hljs-number">5</span> })) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray([])) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Umgebung, in der Sie arbeiten, diese Methode nicht unterstützt, können Sie die folgende Polydatei verwenden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">value</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(value) === <span class="hljs-string">'[object Array]'</span><font></font>
}<font></font>
</code></pre><br>
<a name="58"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">58. Wie kann man überprüfen, ob eine Zahl gerade ist, ohne Modulo-Division oder Division mit Rest (Operator "%") zu verwenden?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dieses Problem zu lösen, können Sie den Operator "&amp;" (binär und) verwenden. </font><font style="vertical-align: inherit;">Der Operator &amp; vergleicht Operanden als Binärwerte.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEven</span>(<span class="hljs-params">num</span>)</span>{
    <span class="hljs-keyword">if</span>(num &amp; <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    } <span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 in der binären Notation ist 000 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 - dies ist 001 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 - 010 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3 - 011 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4 - 100 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5 - 101 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 - 110 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7 - 111 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
usw. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y8/zo/m2/y8zom220osynreetfh8fp-dkuog.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Console.log (5 &amp; 1) gibt 1 zurück. Zuerst konvertiert der Operator &amp; beide Zahlen in Binärwerte, 5 wird zu 101, 1 wird zu 001. Dann wird ein bitweiser Vergleich durchgeführt: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vy/4k/em/vy4kemefvzxgjlwdp3dmsh64ae8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergleichen Sie 1 und 0, wir erhalten 0. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergleichen Sie 0 und 0 , wir erhalten 0. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergleichen Sie 1 und 1, wir erhalten 1. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Konvertieren Sie den Binärwert in eine Ganzzahl, wir erhalten 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihnen diese Informationen zu kompliziert erscheinen, können wir das Problem mit der rekursiven Funktion lösen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEven</span>(<span class="hljs-params">num</span>)</span>{
    <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span> || num === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    <span class="hljs-keyword">return</span> isEven(num - <span class="hljs-number">2</span>)<font></font>
}<font></font>
</code></pre><br>
<a name="59"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">59. Wie kann das Vorhandensein einer Eigenschaft in einem Objekt festgestellt werden?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt drei Möglichkeiten, dies zu tun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste Weg ist die Verwendung des Operators in:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o = {
    <span class="hljs-string">'prop'</span>: <span class="hljs-string">'bwahahah'</span>,
    <span class="hljs-string">'prop2'</span>: <span class="hljs-string">'hweasa'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'prop'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'prop1'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite Möglichkeit ist die Verwendung der hasOwnProperty-Methode:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'prop2'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'prop1'</span>)) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die dritte ist die Indexnotation des Arrays:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(o[<span class="hljs-string">'prop'</span>]) <span class="hljs-comment">// bwahahah</span>
<span class="hljs-built_in">console</span>.log(o[<span class="hljs-string">'prop1'</span>]) <span class="hljs-comment">// undefined</span>
</code></pre><br>
<a name="60"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">60. Was ist AJAX?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AJAX oder Asyncronous JavaScript and XML ist eine Reihe miteinander verbundener Technologien, mit denen Sie im asynchronen Modus mit Daten arbeiten können. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir Daten an den Server senden und von diesem empfangen können, ohne die Webseite neu zu laden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AJAX verwendet die folgenden Technologien: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTML - Webseitenstruktur. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSS - Webseitenstile. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript - Seitenverhalten und Arbeit mit dem DOM. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XMLHttpRequest API - Senden und Empfangen von Daten vom Server. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHP, Python, Nodejs - eine Art Serversprache.</font></font><br>
<br>
<a name="61"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">61. Wie erstelle ich ein Objekt in JS?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objektliteral:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Mark'</span>,<font></font>
    greeting(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
    }<font></font>
}<font></font>
<font></font>
o.greeting <span class="hljs-comment">// Hi, I'm Mark</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Konstruktorfunktion:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">this</span>.name = name<font></font>
}<font></font>
<font></font>
Person.prototype.greeting = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> mark = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Mark'</span>)<font></font>
<font></font>
mark.greeting() <span class="hljs-comment">// Hi, I'm Mark</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Object.create-Methode:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> n = {<font></font>
    greeting(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> o = <span class="hljs-built_in">Object</span>.create(n)<font></font>
<font></font>
o.name = <span class="hljs-string">'Mark'</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(o.greeting) <span class="hljs-comment">// Hi, I'm Mark</span>
</code></pre><br>
<a name="62"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">62. Was ist der Unterschied zwischen den Methoden Object.freeze und Object.seal?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Unterschied besteht darin, dass wir bei Verwendung der Object.freeze-Methode die Eigenschaften des Objekts nicht ändern oder bearbeiten können und bei Verwendung von Object.seal eine solche Möglichkeit haben.</font></font><br>
<br>
<a name="63"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63. Was ist der Unterschied zwischen dem Operator in und der Methode hasOwnProperty?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Unterschied besteht darin, dass der Operator "in" nicht nur im Objekt selbst, sondern auch in seinen Prototypen und der Methode hasOwnProperty - nur im Objekt - nach dem Vorhandensein einer Eigenschaft sucht.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'prop'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'toString'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// true</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'prop'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'toString'</span>)) <span class="hljs-comment">// false</span>
</code></pre><br>
<a name="64"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64. Welche Techniken zum Arbeiten mit asynchronem Code in JS kennen Sie?</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rückrufe</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versprechen Versprechen).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async / warten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliotheken wie async.js, blueprint, q, co.</font></font></li>
</ul><br>
<a name="65"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65. Was ist der Unterschied zwischen einer normalen Funktion und einem funktionalen Ausdruck?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir haben Folgendes:</font></font><br>
<br>
<pre><code class="javascript hljs">hoistedFunc()<font></font>
notHoistedFunc()<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hoistedFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I am hoisted'</span>)<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> notHoistedFunc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I will not be hoisted!'</span>)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Aufruf von notHoistedFunc führt zu einem Fehler, ein Aufruf von hoistedFunc jedoch nicht, da hoistedFunc "auftaucht" und in den globalen Bereich aufsteigt, notHoistedFunc jedoch nicht.</font></font><br>
<br>
<a name="66"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">66. Wie rufe ich eine Funktion in JS auf?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In JS gibt es vier Möglichkeiten, eine Funktion aufzurufen. </font><font style="vertical-align: inherit;">Der Aufruf definiert den Wert dieser oder des "Eigentümers" der Funktion. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufruf als Funktion. </font><font style="vertical-align: inherit;">Wenn eine Funktion als Methode, Konstruktor oder unter Verwendung der Apply- oder Call-Methoden aufgerufen wird, wird sie als Funktion aufgerufen. </font><font style="vertical-align: inherit;">Der Eigentümer einer solchen Funktion ist das Fensterobjekt:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<font></font>
add(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">// window, 6</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> o = {<font></font>
    method(callback){<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
<font></font>
o.method(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// window</span><font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufruf als Methode. </font><font style="vertical-align: inherit;">Wenn eine Funktion eine Eigenschaft eines Objekts ist, nennen wir sie eine Methode. </font><font style="vertical-align: inherit;">Wenn eine Methode aufgerufen wird, wird dieses Objekt zum Objekt dieser Methode:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> details = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko'</span>,<font></font>
    getName(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name<font></font>
    }<font></font>
}<font></font>
<font></font>
details.getName() <span class="hljs-comment">// Marko,  this   details</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufruf als Konstruktor. </font><font style="vertical-align: inherit;">Wenn eine Funktion mit dem Schlüsselwort "new" aufgerufen wird, nennen wir diese Funktion einen Konstruktor. </font><font style="vertical-align: inherit;">Dadurch wird ein leeres Objekt erstellt, dessen Wert Folgendes ist:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">name, position, yearHired</span>)</span>{
    <span class="hljs-comment">//   ,   this</span>
    <span class="hljs-comment">// this = {}</span>
    <span class="hljs-keyword">this</span>.name = name
    <span class="hljs-keyword">this</span>.position = position
    <span class="hljs-keyword">this</span>.yearHired = yearHired
    <span class="hljs-comment">//   Employee.prototype   this,    </span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> emp = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">'Marko Polo'</span>, <span class="hljs-string">'Software Development'</span>, <span class="hljs-number">2017</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Aufruf mit den Methoden apply oder call. </font><font style="vertical-align: inherit;">Wir verwenden diese Methoden, wenn wir den Wert dieser oder des Eigentümers einer Funktion explizit bestimmen möchten:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj1 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> obj2 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduceAdd</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++){<font></font>
        result += <span class="hljs-built_in">arguments</span>[i]<font></font>
    }<font></font>
    <span class="hljs-keyword">this</span>.result = result<font></font>
}<font></font>
<font></font>
reduceAdd.apply(obj1, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]) <span class="hljs-comment">//  this  obj1</span>
reduceAdd.call(obj2, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">//  this  obj2</span>
</code></pre><br>
<a name="67"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">67. Was ist Auswendiglernen oder Auswendiglernen?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memoization ist die Technik zum Erstellen einer Funktion, die sich zuvor berechnete Ergebnisse oder Werte merken kann. </font><font style="vertical-align: inherit;">Der Vorteil der Memoisierung besteht darin, dass wir vermeiden, eine Funktion mit denselben Argumenten erneut auszuführen. </font><font style="vertical-align: inherit;">Der Nachteil ist, dass wir gezwungen sind, zusätzlichen Speicher zuzuweisen, um die Ergebnisse zu speichern.</font></font><br>
<br>
<a name="68"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68. Wie würden Sie die Hilfsfunktion des Auswendiglernen implementieren?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span>(<span class="hljs-params">fn</span>)</span>{
    <span class="hljs-keyword">const</span> cache = {}
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">param</span>)</span>{
        <span class="hljs-keyword">if</span>(cache[param]){
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'cached'</span>)
            <span class="hljs-keyword">return</span> cache[param]<font></font>
        } <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">let</span> result = fn(param)<font></font>
            cache[param] = result<font></font>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'not cached'</span>)
            <span class="hljs-keyword">return</span> result<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> toUpper = <span class="hljs-function">(<span class="hljs-params">str = <span class="hljs-string">''</span></span>) =&gt;</span> str.toUpperCase()<font></font>
<font></font>
<span class="hljs-keyword">const</span> toUpperMemoized = memoize(toUpper)<font></font>
<font></font>
toUpperMemoized(<span class="hljs-string">'abcdef'</span>)<font></font>
toUpperMemoized(<span class="hljs-string">'abcdef'</span>) <span class="hljs-comment">//  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben die Memoization-Funktion mit einem Argument implementiert. </font><font style="vertical-align: inherit;">Machen wir es "Multi-Argument":</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> slice = <span class="hljs-built_in">Array</span>.prototype.slice
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span>(<span class="hljs-params">fn</span>)</span>{
    <span class="hljs-keyword">const</span> cache = {}
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> params = slice.call(args)
        <span class="hljs-built_in">console</span>.log(params)
        <span class="hljs-keyword">if</span>(cache[params]){
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'cached'</span>)
            <span class="hljs-keyword">return</span> cache[params]<font></font>
        } <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">let</span> result = fn(...args)<font></font>
            cache[params] = result<font></font>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'not cached'</span>)
            <span class="hljs-keyword">return</span> result<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<span class="hljs-keyword">const</span> makeFullName = <span class="hljs-function">(<span class="hljs-params">fName, lName</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${fName}</span> <span class="hljs-subst">${lName}</span>`</span>
<span class="hljs-keyword">const</span> reduceAdd = <span class="hljs-function">(<span class="hljs-params">numbers, startValue = <span class="hljs-number">0</span></span>) =&gt;</span> numbers.reduce(<span class="hljs-function">(<span class="hljs-params">total, cur</span>) =&gt;</span> total + cur, startValue)<font></font>
<font></font>
<span class="hljs-keyword">const</span> memoizedFullName = memoize(makeFullName)
<span class="hljs-keyword">const</span> memoizeReduceAdd = memoize(reduceAdd)<font></font>
<font></font>
memoizedFullName(<span class="hljs-string">'Marko'</span>, <span class="hljs-string">'Polo'</span>)<font></font>
memoizedFullName(<span class="hljs-string">'Marko'</span>, <span class="hljs-string">'Polo'</span>) <span class="hljs-comment">//  </span><font></font>
<font></font>
memoizeReduceAdd([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<span class="hljs-number">5</span>)<font></font>
memoizeReduceAdd([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<span class="hljs-number">5</span>) <span class="hljs-comment">//  </span>
</code></pre><br>
<a name="69"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69. Warum gibt typeof null ein Objekt zurück? </font><font style="vertical-align: inherit;">Wie überprüfe ich, ob ein Wert null ist?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
typeof null == 'object' gibt aus historischen Gründen immer true zurück. </font><font style="vertical-align: inherit;">Es gab einen Vorschlag, diesen Fehler durch Ändern von typeof null = 'object' in typeof null = 'null' zu beheben, der jedoch im Interesse der Aufrechterhaltung der Abwärtskompatibilität abgelehnt wurde (eine solche Änderung würde eine große Anzahl von Fehlern mit sich bringen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu überprüfen, ob der Wert null ist, können Sie den strengen Gleichheitsoperator (===) verwenden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNull</span>(<span class="hljs-params">value</span>)</span>{
    <span class="hljs-keyword">return</span> value === <span class="hljs-literal">null</span><font></font>
}<font></font>
</code></pre><br>
<a name="70"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70. Wofür wird das Schlüsselwort "neu" verwendet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Schlüsselwort "new" wird in Konstruktorfunktionen verwendet, um ein neues Objekt (eine neue Instanz der Klasse) zu erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir haben einen Code wie diesen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">name, position, yearHired</span>)</span>{
    <span class="hljs-keyword">this</span>.name = name
    <span class="hljs-keyword">this</span>.position = position
    <span class="hljs-keyword">this</span>.yearHired = yearHired<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> emp = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">'Marko Polo'</span>, <span class="hljs-string">'Software Development'</span>, <span class="hljs-number">2017</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Schlüsselwort "neu" macht 4 Dinge:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellt ein leeres Objekt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bindet diesen Wert daran.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Funktion erbt von functionName.prototype.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt dies zurück, sofern nicht anders angegeben.</font></font></li>
</ol></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de486820/">https://habr.com/ru/post/de486820/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de486804/index.html">Globale Gesundheitsinformatik: Cloud-Technologien</a></li>
<li><a href="../de486808/index.html">Elektronischer Schwangerschaftstest aus einer Apotheke: wie es funktioniert</a></li>
<li><a href="../de486810/index.html">Neues Odnoklassniki-Frontend: React in Java starten. Teil II</a></li>
<li><a href="../de486814/index.html">Zabbix: Die Netzwerktopologie ist klar und automatisch</a></li>
<li><a href="../de486818/index.html">Portierung von Quake auf den iPod Classic</a></li>
<li><a href="../de486822/index.html">[An den Docks] Flattern. Teil 4. Für Webentwickler</a></li>
<li><a href="../de486824/index.html">Schlechter Rat bei der Arbeit mit ANTLR</a></li>
<li><a href="../de486826/index.html">Erstellen eines vollwertigen Viberbot auf Django 2 und der Viber REST-API. Erster Teil - Webhook</a></li>
<li><a href="../de486828/index.html">Food Design Digest, Januar 2020</a></li>
<li><a href="../de486832/index.html">Wie viele Jahre Taiga vergehen - verstehe nein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>