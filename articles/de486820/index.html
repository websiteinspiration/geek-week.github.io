<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèΩ üÜë üçπ 70 Fragen zum Javascript-Interview üåº ‚ìÇÔ∏è üë©üèΩ‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, Freunde! 
 
 Ich hoffe, dieser Artikel ist sowohl f√ºr Anf√§nger als auch f√ºr erfahrene Entwickler n√ºtzlich. 
 
 In Fragen, die mir schwierig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>70 Fragen zum Javascript-Interview</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486820/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guten Tag, Freunde! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, dieser Artikel ist sowohl f√ºr Anf√§nger als auch f√ºr erfahrene Entwickler n√ºtzlich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Fragen, die mir schwieriger erschienen als andere, wird auf zus√§tzliche Literatur verwiesen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr die ausf√ºhrlichen Kommentare w√§re ich dankbar. </font><font style="vertical-align: inherit;">Alle Kommentare werden bei der Bearbeitung des Artikels ber√ºcksichtigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So lass uns gehen.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70 Fragen zum Javascript-Interview</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fragen: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Was ist der Unterschied zwischen null und undefiniert? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Wof√ºr wird der Operator &amp;&amp; verwendet? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Wof√ºr wird der Operator "||" verwendet? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Ist die Verwendung des un√§ren Plus-Operators (+ Operator) der schnellste Weg, eine Zeichenfolge in eine Zahl umzuwandeln? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Was ist ein DOM? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Was ist Event Propogation? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Was ist Ereignisblasen? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Was ist Ereigniserfassung? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. Was ist der Unterschied zwischen den Methoden event.preventDefault () und event.stopPropagation ()? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. Wie lerne ich die Verwendung der event.preventDefault () -Methode kennen? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. Warum f√ºhrt obj.someprop.x zu einem Fehler? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12. Was ist ein Ereignisziel oder ein Zielelement (event.target)?</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">13.      (event.currentTarget)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">14.      "=="  "==="?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">15.        false?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">16.     "!!"?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">17.       ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">18.    (Hoisting)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">19.     (Scope)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">20.    (Closures)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">21.    JS  ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">22.  ,    ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">23.     ¬´use strict¬ª?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">24.    this?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">25.    ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">26.   IIFE?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">27.     Function.prototype.apply?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">28.     Function.prototype.call?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">29.      call  apply?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">30.     Function.prototype.bind?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">31.        JS         ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">32.      (Higher Order Functions)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">33.    JS     (First-class Objects)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">34.      Array.prototype.map?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">35.      Array.prototype.filter?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">36.      Array.prototype.reduce?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">37.    arguments?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">38.   ,   ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">39.      b     ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">40.   ECMAScript?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">41.     JS  ES6  ECMAScript2015?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">42.       ¬´var¬ª, ¬´let¬ª  ¬´const¬ª?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">43.     (Arrow Functions)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">44.    (Classes)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">45.     (Template Literals)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">46.     (Object Destructuring)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">47.    (Modules)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">48.    Set?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">49.      (Callback Function)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">50.    (Promises)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">51.   async/await?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">52.     spread-  rest-?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">53.      (Default Parameters)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">54.     (Wrapper Objects)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">55.             (Implicit and Explicit Coercion)?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">56.   NaN?  ,    NaN?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">57.  ,    ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">58.  ,    ,          ( "%")?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">59.      ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">60.   AJAX?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">61.   JS  ?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">62.      Object.freeze  Object.seal?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">63.      ¬´in¬ª   hasOwnProperty?</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64. Welche Techniken zum Arbeiten mit asynchronem Code in JS kennen Sie? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65. Was ist der Unterschied zwischen einer normalen Funktion und einem funktionalen Ausdruck? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">66. Wie rufe ich eine Funktion in JS auf? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">67. Was ist Auswendiglernen oder Auswendiglernen? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68. Wie w√ºrden Sie die Hilfsfunktion des Auswendiglernen implementieren? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69. Warum gibt typeof null ein Objekt zur√ºck? </font><font style="vertical-align: inherit;">Wie √ºberpr√ºfe ich, ob ein Wert null ist? </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70. Wof√ºr wird das Schl√ºsselwort "neu" verwendet?</font></font></a><br>
<br>
<a name="1"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Was ist der Unterschied zwischen null und undefiniert?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns zun√§chst dar√ºber sprechen, was sie gemeinsam haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens geh√∂ren sie zu 7 JS "Primitiven" (primitiven Typen):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> primitiveTypes = [<span class="hljs-string">'string'</span>, <span class="hljs-string">'number'</span>, <span class="hljs-string">'null'</span>, <span class="hljs-string">'undefined'</span>, <span class="hljs-string">'boolean'</span>, <span class="hljs-string">'symbol'</span>, <span class="hljs-string">'bigint'</span>]
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens sind sie falsche Werte, d.h. </font><font style="vertical-align: inherit;">das Ergebnis der Konvertierung in einen Booleschen Wert mit Boolean () oder dem Operator "!!" </font><font style="vertical-align: inherit;">ist falsch:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Okay, jetzt zu den Unterschieden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
undefiniert ist der Standardwert:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Variable, der kein Wert zugewiesen wurde, d.h. </font><font style="vertical-align: inherit;">eine deklarierte, aber nicht initialisierte Variable;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Funktion, die nichts explizit zur√ºckgibt, z. B. console.log (1);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht vorhandene Eigenschaft des Objekts.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesen F√§llen setzt die JS-Engine den Wert auf undefiniert.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> _thisIsUndefined
<span class="hljs-keyword">const</span> doNothing = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}
<span class="hljs-keyword">const</span> someObj = {
    <span class="hljs-attr">a</span>: <span class="hljs-string">'ay'</span>,
    <span class="hljs-attr">b</span>: <span class="hljs-string">'bee'</span>,
    <span class="hljs-attr">c</span>: <span class="hljs-string">'si'</span><font></font>
}<font></font>
<span class="hljs-built_in">console</span>.log(_thisIsUndefined) <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(doNothing()) <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(someObj[<span class="hljs-string">'d'</span>]) <span class="hljs-comment">// undefined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
null ist der "Wert ohne Wert". </font><font style="vertical-align: inherit;">null ist der Wert, der der Variablen explizit zugewiesen wird. </font><font style="vertical-align: inherit;">Im folgenden Beispiel erhalten wir null, wenn die Methode fs.readFile fehlerfrei funktioniert:</font></font><br>
<br>
<pre><code class="javascript hljs">fs.readFile(<span class="hljs-string">'path/to/file'</span>, (e, data) =&gt; {
    <span class="hljs-built_in">console</span>.log(e) <span class="hljs-comment">//    null</span>
<span class="hljs-keyword">if</span>(e) {
    <span class="hljs-built_in">console</span>.log(e)<font></font>
}<font></font>
    <span class="hljs-built_in">console</span>.log(data)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Vergleich von null und undefiniert erhalten wir true, wenn der Operator "==" verwendet wird, und false, wenn der Operator "===" verwendet wird. </font><font style="vertical-align: inherit;">Informationen dazu finden Sie weiter unten.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span>
</code></pre><br>
<a name="2"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Wof√ºr wird der Operator &amp;&amp; verwendet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Operator &amp;&amp; (logisch und) findet und gibt den ersten falschen Wert oder den letzten Operanden zur√ºck, wenn alle Werte wahr sind. </font><font style="vertical-align: inherit;">Es wird ein Kurzschluss verwendet, um unn√∂tige Kosten zu vermeiden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-number">1</span> &amp;&amp; []) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">' '</span> &amp;&amp; <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-number">5</span>) <span class="hljs-comment">// 5</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der if-Anweisung:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> router: Router = Router()<font></font>
<font></font>
router.get(<span class="hljs-string">'/endpoint'</span>, (req: Request, <span class="hljs-attr">res</span>: Response) =&gt; {
    <span class="hljs-keyword">let</span> conMobile: PoolConnection
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">//    </span>
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">if</span> (conMobile) {<font></font>
            conMobile.release()<font></font>
        }<font></font>
    }<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gleiches gilt f√ºr den Operator &amp;&amp;:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> router: Router = Router()<font></font>
<font></font>
router.get(<span class="hljs-string">'/endpoint'</span>, (req: Request, <span class="hljs-attr">res</span>: Response) =&gt; {
    <span class="hljs-keyword">let</span> conMobile: PoolConnection
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">//    </span>
    } <span class="hljs-keyword">catch</span> (e) {<font></font>
        conMobile &amp;&amp; conMobile.release()<font></font>
    }<font></font>
})<font></font>
</code></pre><br>
<a name="3"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Wof√ºr wird der Operator "||" verwendet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Operator "||" </font><font style="vertical-align: inherit;">(boolean oder) findet und gibt den ersten wahren Wert zur√ºck. </font><font style="vertical-align: inherit;">Es wird auch ein Kurzschluss verwendet. </font><font style="vertical-align: inherit;">Dieser Operator wurde verwendet, um Standardparameter in Funktionen zuzuweisen, bevor die Standardparameter in ES6 standardisiert wurden.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> || <span class="hljs-number">1</span> || <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// 1</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logName</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">let</span> n = name || Mark
    <span class="hljs-built_in">console</span>.log(n)<font></font>
}<font></font>
<font></font>
logName() <span class="hljs-comment">// Mark</span>
</code></pre><br>
<a name="4"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Ist die Verwendung des un√§ren Plus-Operators (+ Operator) der schnellste Weg, eine Zeichenfolge in eine Zahl umzuwandeln?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Laut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der Operator + in der Tat der schnellste Weg, eine Zeichenfolge in eine Zahl umzuwandeln, da er keine Operationen f√ºr einen Wert ausf√ºhrt, der eine Zahl ist.</font></font><br>
<br>
<a name="5"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Was ist ein DOM?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das DOM oder Document Object Model ist eine Anwendungsprogrammierschnittstelle (API) f√ºr die Arbeit mit HTML- und XML-Dokumenten. </font><font style="vertical-align: inherit;">Wenn der Browser das HTML-Dokument zum ersten Mal liest (‚Äûanalysiert‚Äú), bildet er ein gro√ües Objekt, ein wirklich gro√ües Objekt, das auf dem Dokument basiert - das DOM. </font><font style="vertical-align: inherit;">Das DOM ist eine Baumstruktur (Dokumentbaum). </font><font style="vertical-align: inherit;">Das DOM wird verwendet, um die Struktur des DOM selbst oder seiner einzelnen Elemente und Knoten zu interagieren und zu √§ndern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir haben diesen HTML-Code:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"ie=edge"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document Object Model<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das DOM dieses HTML sieht folgenderma√üen aus: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ax/cg/id/axcgidsa8fghreeuyvbhfpga6yo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In JS wird das DOM durch ein Dokumentobjekt dargestellt. </font><font style="vertical-align: inherit;">Das Document-Objekt verf√ºgt √ºber eine Vielzahl von Methoden zum Arbeiten mit Elementen, deren Erstellung, √Ñnderung, L√∂schung usw.</font></font><br>
<br>
<a name="6"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Was ist Ereignisausbreitung?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein Ereignis in einem DOM-Element auftritt, tritt es tats√§chlich nicht nur darin auf. </font><font style="vertical-align: inherit;">Das Ereignis "propagiert" vom Window-Objekt zu dem Element, das es aufgerufen hat (event.target). </font><font style="vertical-align: inherit;">In diesem Fall durchdringt (beeinflusst) das Ereignis nacheinander alle Vorfahren des Zielelements. </font><font style="vertical-align: inherit;">Eine Ereignisausbreitung besteht aus drei Stufen oder Phasen:</font></font><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eintauchphase (Erfassung, Abfangen) - Ein Ereignis tritt im Fensterobjekt auf und steigt √ºber alle seine Vorfahren zum Ereignisziel ab.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zielphase ist, wenn das Ereignis das Zielelement erreicht.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufsteigende Phase - Ein Ereignis steigt aus event.target auf, durchl√§uft nacheinander alle seine Vorfahren und erreicht das Window-Objekt.</font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/a3/9x/67/a39x67wkxdmcyzj-it5m2jmfxgg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lesen Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mehr √ºber die Verteilung von Veranstaltungen </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="7"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Was ist ein Ereignis-Popup?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein Ereignis in einem DOM-Element auftritt, betrifft es nicht nur dieses Element. </font><font style="vertical-align: inherit;">Ein Ereignis ‚Äûerscheint‚Äú (wie eine Luftblase im Wasser), geht von dem Element, das das Ereignis verursacht hat (event.target), zu seinem √ºbergeordneten Element und steigt dann noch h√∂her zum √ºbergeordneten Element des √ºbergeordneten Elements des Elements, bis es das Fensterobjekt erreicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir haben dieses Markup:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grandparent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so ein JS:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEvent</span>(<span class="hljs-params">el, event, callback, isCapture = false</span>) </span>{
    <span class="hljs-keyword">if</span> (!el || !event || !callback || <span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">return</span><font></font>
<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> el === <span class="hljs-string">'string'</span>) {<font></font>
        el = <span class="hljs-built_in">document</span>.querySelector(el)<font></font>
    }<font></font>
    el.addEventListener(event, callback, isCapture)<font></font>
}<font></font>
<font></font>
addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'DOMContentLoaded'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.child'</span>)
    <span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.parent'</span>)
    <span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.grandparent'</span>)<font></font>
<font></font>
    addEvent(child, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(parent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(grandparent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'grandparent'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(<span class="hljs-string">'html'</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'html'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'document'</span>)<font></font>
    })<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">window</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'window'</span>)<font></font>
    })<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die addEventListener-Methode verf√ºgt √ºber einen dritten optionalen Parameter - useCapture. </font><font style="vertical-align: inherit;">Wenn der Wert false ist (Standardeinstellung), beginnt das Ereignis mit der Aufstiegsphase. </font><font style="vertical-align: inherit;">Wenn sein Wert wahr ist, beginnt das Ereignis mit der Eintauchphase (f√ºr die "Zuh√∂rer" von Ereignissen, die an das Ziel des Ereignisses angeh√§ngt sind, befindet sich das Ereignis in der Zielphase und nicht in der Eintauch- oder Aufstiegsphase. Ereignisse in der Zielphase werden von allen Zuh√∂rern des Elements in der Reihenfolge ausgel√∂st in dem sie unabh√§ngig vom Parameter useCapture registriert wurden - ca. </font><font style="vertical-align: inherit;">Wenn wir auf das untergeordnete Element klicken, wird in der Konsole Folgendes angezeigt: untergeordnetes Element, √ºbergeordnetes Element, Gro√üelternteil, HTML, Dokument, Fenster. </font><font style="vertical-align: inherit;">Hier ist, was ein Ereignis-Popup ist.</font></font><br>
<br>
<a name="8"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Was ist ein Immersionsereignis?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein Ereignis in einem DOM-Element auftritt, tritt es nicht nur darin auf. </font><font style="vertical-align: inherit;">In der Immersionsphase steigt das Ereignis durch alle seine Vorfahren vom Fensterobjekt zum Ereignisziel ab. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Markup:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grandparent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JS:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEvent</span>(<span class="hljs-params">el, event, callback, isCapture = false</span>) </span>{
    <span class="hljs-keyword">if</span> (!el || !event || !callback || <span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">return</span><font></font>
<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> el === <span class="hljs-string">'string'</span>) {<font></font>
        el = <span class="hljs-built_in">document</span>.querySelector(el);<font></font>
    }<font></font>
    el.addEventListener(event, callback, isCapture)<font></font>
}<font></font>
<font></font>
addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'DOMContentLoaded'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.child'</span>)
    <span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.parent'</span>)
    <span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.grandparent'</span>)<font></font>
<font></font>
    addEvent(child, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child'</span>);<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(parent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(grandparent, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'grandparent'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(<span class="hljs-string">'html'</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'html'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'document'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
<font></font>
    addEvent(<span class="hljs-built_in">window</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'window'</span>)<font></font>
    }, <span class="hljs-literal">true</span>)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die addEventListener-Methode verf√ºgt √ºber einen dritten optionalen Parameter - useCapture. </font><font style="vertical-align: inherit;">Wenn der Wert false ist (Standardeinstellung), beginnt das Ereignis mit der Aufstiegsphase. </font><font style="vertical-align: inherit;">Wenn sein Wert wahr ist, beginnt das Ereignis mit der Tauchphase. </font><font style="vertical-align: inherit;">Wenn wir auf das untergeordnete Element klicken, wird in der Konsole Folgendes angezeigt: Fenster, Dokument, HTML, Gro√üeltern, Eltern, Kind. </font><font style="vertical-align: inherit;">Dies ist das Eintauchen des Ereignisses.</font></font><br>
<br>
<a name="9"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. Was ist der Unterschied zwischen den Methoden event.preventDefault () und event.stopPropagation ()?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Methode event.preventDefault () deaktiviert das Standardverhalten eines Elements. </font><font style="vertical-align: inherit;">Wenn Sie diese Methode im Formularelement verwenden, wird das Senden des Formulars verhindert. </font><font style="vertical-align: inherit;">Wenn Sie es im Kontextmen√º verwenden, wird das Kontextmen√º deaktiviert (diese Methode wird h√§ufig im Keydown verwendet, um die Tastatur neu zu definieren, z. B. beim Erstellen eines Musik- / Videoplayers oder eines Texteditors - ca. </font><font style="vertical-align: inherit;">Die Methode event.stopPropagation () deaktiviert die Ereignisausbreitung (Aufstieg oder Eintauchen).</font></font><br>
<br>
<a name="10"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. Wie lerne ich die Verwendung der event.preventDefault () -Methode kennen?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu diesem Zweck k√∂nnen wir die Eigenschaft event.defaulPrevented verwenden, die einen Booleschen Wert zur√ºckgibt, der als Indikator f√ºr die Anwendung auf das Element der Methode event.preventDefault dient.</font></font><br>
<br>
<a name="11"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. Warum f√ºhrt obj.someprop.x zu einem Fehler?</font></font></h4><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj = {}
<span class="hljs-built_in">console</span>.log(obj.someprop.x)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Antwort liegt auf der Hand: Wir versuchen, auf die undefinierte Eigenschaft x der Eigenschaft someprop zuzugreifen. </font><font style="vertical-align: inherit;">obj .__ proto __.__ proto = null, daher wird undefined zur√ºckgegeben, und undefined hat nicht die x-Eigenschaft.</font></font><br>
<br>
<a name="12"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12. Was ist ein Ereignisziel oder ein Zielelement (event.target)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einfachen Worten ist event.target das Element, in dem das Ereignis auftritt, oder das Element, das das Ereignis ausgel√∂st hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben das folgende Markup:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"clickFunc(event)"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align: center; margin: 15px;
border: 1px solid red; border-radius: 3px;"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 25px; border: 1px solid royalblue; border-radius: 3px;"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 25px; border: 1px solid skyblue; border-radius: 3px;"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 10px"</span>&gt;</span><font></font>
                Button<font></font>
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so ein einfacher JS:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickFunc</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-built_in">console</span>.log(event.target)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben dem √§u√üeren Div einen ‚ÄûZuh√∂rer‚Äú hinzugef√ºgt. </font><font style="vertical-align: inherit;">Wenn wir jedoch auf die Schaltfl√§che klicken, erhalten wir das Layout dieser Schaltfl√§che in der Konsole. </font><font style="vertical-align: inherit;">Dies l√§sst den Schluss zu, dass das Element, das das Ereignis verursacht hat, die Schaltfl√§che selbst ist und nicht die externen oder internen Divs.</font></font><br>
<br>
<a name="13"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13. Was ist der aktuelle Zweck des Ereignisses (event.currentTarget)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Event.currentTarget ist das Element, an das der Ereignis-Listener angeh√§ngt ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ñhnliches Markup:</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"clickFunc(event)"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align: center;margin:15px;
border:1px solid red;border-radius:3px;"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 25px; border:1px solid royalblue;border-radius:3px;"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin:25px;border:1px solid skyblue;border-radius:3px;"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin:10px"</span>&gt;</span><font></font>
                Button<font></font>
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und ein leicht modifizierter JS:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickFunc</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-built_in">console</span>.log(event.currentTarget)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben den H√∂rer an die √§u√üere Div angeschlossen. </font><font style="vertical-align: inherit;">Wo immer wir klicken, sei es eine Schaltfl√§che oder eine der internen Divs, in der Konsole erhalten wir immer das Layout der externen Divs. </font><font style="vertical-align: inherit;">Dies l√§sst den Schluss zu, dass event.currentTarget das Element ist, an das der Ereignis-Listener angeh√§ngt ist.</font></font><br>
<br>
<a name="14"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14. Was ist der Unterschied zwischen den Operatoren "==" und "==="?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Unterschied zwischen dem Operator == (abstrakte oder nicht strenge Gleichheit) und dem Operator === (strikte Gleichheit) besteht darin, dass der erste die Werte vergleicht, nachdem sie konvertiert oder in einen Typ umgewandelt wurden (Coersion), und der zweite - ohne eine solche Konvertierung . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns tiefer graben. </font><font style="vertical-align: inherit;">Und zuerst sprechen wir √ºber die Transformation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Konvertierung ist ein Prozess, bei dem ein Wert in einen anderen Typ umgewandelt wird, oder vielmehr ein Prozess, bei dem die verglichenen Werte in einen Typ umgewandelt werden. </font><font style="vertical-align: inherit;">Beim Vergleich des Operators "==" wird der sogenannte implizite Vergleich erzeugt. </font><font style="vertical-align: inherit;">Der Operator "==" f√ºhrt einige Operationen aus, bevor er zwei Werte vergleicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir vergleichen x und y. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Algorithmus ist wie folgt:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn x und y vom gleichen Typ sind, wird der Vergleich mit dem Operator "===" durchgef√ºhrt.</font></font></li>
<li> x = null  y = undefined  true.</li>
<li> x = undefined  y = null  true.</li>
<li> x = ,  y = ,  x == toNumber(y) ( y   ).</li>
<li> x = ,  y = ,  toNumber(x) == y ( x   ).</li>
<li> x =  ,  toNumber(x) == y.</li>
<li> y =  ,  x == toNumber(y).</li>
<li> x = ,   ,  y = ,  x == toPrimitive(y) ( y   ).</li>
<li> x = ,  y = ,   ,  toPrimitive(x) == y.</li>
<li> false.</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie daran: Um ein Objekt in ein "Grundelement" umzuwandeln, verwendet die toPrimitive-Methode zuerst die valueOf-Methode und dann die toString-Methode. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiele: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yd/xe/tn/ydxetnfghjtfuex_p-em8v4emck.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Beispiele geben true zur√ºck. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste Beispiel ist die erste Bedingung des Algorithmus. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite Beispiel ist die vierte Bedingung. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der dritte ist der zweite. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der vierte ist der siebte. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºnfter - Achter. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und der letzte ist der zehnte. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t-/4k/ys/t-4kyszb4grfafbi7lazyyvq6dy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir den Operator "===" verwenden, geben alle Beispiele au√üer dem ersten false zur√ºck, da die Werte in diesen Beispielen unterschiedlichen Typs sind.</font></font><br>
<br>
<a name="15"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15. Warum ist das Ergebnis des Vergleichs zweier √§hnlicher Objekte falsch?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> a = {
    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><font></font>
}<font></font>
<span class="hljs-keyword">let</span> b = {
    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><font></font>
}<font></font>
<span class="hljs-keyword">let</span> c = a<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(a === b) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(a === c) <span class="hljs-comment">// true ...</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In JS werden Objekte und Grundelemente unterschiedlich verglichen. </font><font style="vertical-align: inherit;">Primitive werden nach Wert verglichen. </font><font style="vertical-align: inherit;">Objekte - nach Referenz oder Adresse im Speicher, in dem die Variable gespeichert ist. </font><font style="vertical-align: inherit;">Aus diesem Grund gibt das erste console.log false und das zweite true zur√ºck. </font><font style="vertical-align: inherit;">Die Variablen "a" und "c" beziehen sich auf dasselbe Objekt, w√§hrend sich die Variablen "a" und "b" auf verschiedene Objekte mit denselben Eigenschaften und Werten beziehen.</font></font><br>
<br>
<a name="16"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16. Wof√ºr wird der Operator "!!" verwendet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Betreiber "!!" </font><font style="vertical-align: inherit;">(doppelte Negation) f√ºhrt den Wert rechts von ihm zu einem logischen Wert.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-string">''</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-number">0</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-string">' '</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!!{}) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!![]) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!!<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(!![].length) <span class="hljs-comment">// false</span>
</code></pre><br>
<a name="17"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17. Wie schreibe ich mehrere Ausdr√ºcke in eine Zeile?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hierf√ºr k√∂nnen wir den Operator "," (Komma) verwenden. </font><font style="vertical-align: inherit;">Dieser Operator "bewegt" sich von links nach rechts und gibt den Wert des letzten Ausdrucks oder Operanden zur√ºck.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span><font></font>
<font></font>
x = (x++, x = addFive(x), x *= <span class="hljs-number">2</span>, x -= <span class="hljs-number">5</span>, x += <span class="hljs-number">10</span>)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addFive</span>(<span class="hljs-params">num</span>) </span>{
    <span class="hljs-keyword">return</span> num + <span class="hljs-number">5</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir den Wert von x auf die Konsole drucken, erhalten wir 27. Zuerst erh√∂hen wir den Wert von x um eins (x = 6). </font><font style="vertical-align: inherit;">Dann rufen wir die Funktion addFive () mit Parameter 6 auf, zu der wir 5 hinzuf√ºgen (x = 11). </font><font style="vertical-align: inherit;">Danach multiplizieren wir den Wert von x mit 2 (x = 22). </font><font style="vertical-align: inherit;">Dann subtrahiere 5 (x = 17). </font><font style="vertical-align: inherit;">Und schlie√ülich addieren Sie 10 (x = 27).</font></font><br>
<br>
<a name="18"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18. Was ist Heben?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lift ist ein Begriff, der den Aufstieg einer Variablen oder Funktion in einem globalen oder funktionalen Bereich beschreibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu verstehen, was Heben ist, m√ºssen Sie den Ausf√ºhrungskontext verstehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Ausf√ºhrungskontext ist die Umgebung, in der der Code ausgef√ºhrt wird. Der Ausf√ºhrungskontext besteht aus zwei Phasen - Kompilierung und Ausf√ºhrung selbst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusammenstellung. In dieser Phase werden funktionale Ausdr√ºcke und Variablen, die mit dem Schl√ºsselwort "var" mit dem Wert undefined deklariert wurden, ganz oben im globalen (oder funktionalen) Bereich angezeigt (als w√ºrden wir an den Anfang unseres Codes gehen. Dies erkl√§rt, warum wir Funktionen vor ihnen aufrufen k√∂nnen Ank√ºndigungen - ca.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Performance. </font><font style="vertical-align: inherit;">In dieser Phase werden Variablen Werte zugewiesen und Funktionen (oder Methoden von Objekten) aufgerufen oder ausgef√ºhrt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie daran: Es werden nur funktionale Ausdr√ºcke und Variablen ausgel√∂st, die mit dem Schl√ºsselwort "var" deklariert wurden. </font><font style="vertical-align: inherit;">Gew√∂hnliche Funktionen und Pfeilfunktionen sowie Variablen, die mit den Schl√ºsselw√∂rtern "let" und "const" deklariert wurden, werden nicht ausgel√∂st. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben folgenden Code:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(y)<font></font>
y = <span class="hljs-number">1</span>
<span class="hljs-built_in">console</span>.log(y)
<span class="hljs-built_in">console</span>.log(greet(<span class="hljs-string">'Mark'</span>))<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> y
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden undefiniert, 1 und 'Hallo Mark!'. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht die Kompilierungsphase aus:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> y <span class="hljs-comment">//  undefined</span><font></font>
<font></font>
<span class="hljs-comment">//    </span><font></font>
<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-comment">/*
console.log(y)
y = 1
console.log(y)
console.log(greet('Mark'))
*/</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach Abschluss der Kompilierungsphase beginnt die Ausf√ºhrungsphase, wenn den Variablen Werte zugewiesen und Funktionen aufgerufen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mehr zum Heben finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="19"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19. Was ist ein Anwendungsbereich?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Bereich ist ein Ort, an dem (oder von wo aus) wir Zugriff auf Variablen oder Funktionen haben. </font><font style="vertical-align: inherit;">JS Wir haben drei Arten von Bereichen: global, funktional und block (ES6). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Globaler Bereich - Variablen und Funktionen, die im globalen Namespace deklariert sind, haben einen globalen Bereich und sind von √ºberall im Code zug√§nglich.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> g = <span class="hljs-string">'global'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">globalFunc</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFunc</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(g) <span class="hljs-comment">//     g,    </span><font></font>
    }<font></font>
    innerFunc()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktionsumfang (Funktionsumfang) - Variablen, Funktionen und Parameter, die innerhalb einer Funktion deklariert sind, sind nur innerhalb dieser Funktion verf√ºgbar.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFavouriteFunc</span>(<span class="hljs-params">a</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">var</span> b = <span class="hljs-string">'Hello '</span> + a<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> b<font></font>
}<font></font>
myFavouriteFunc(<span class="hljs-string">'World'</span>)<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// Uncaught ReferenceError: a is not defined</span>
<span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">//  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Blockbereich - Variablen (deklariert mit den Schl√ºsselw√∂rtern "let" und "const") innerhalb des Blocks ({}) sind nur innerhalb des Blocks verf√ºgbar.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testBlock</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">let</span> z = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> z<font></font>
}<font></font>
<font></font>
testBlock() <span class="hljs-comment">// Uncaught ReferenceError: z is not defined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Bereich ist auch ein Satz von Regeln, nach denen eine Variable durchsucht wird. </font><font style="vertical-align: inherit;">Wenn die Variable im aktuellen Bereich nicht vorhanden ist, wird ihre Suche in der externen Sichtbarkeit des aktuellen Bereichs h√∂her ausgef√ºhrt. </font><font style="vertical-align: inherit;">Wenn der externe Bereich keine Variable enth√§lt, wird die Suche bis zum globalen Bereich fortgesetzt. </font><font style="vertical-align: inherit;">Wenn eine Variable im globalen Bereich gefunden wird, wird die Suche gestoppt. Andernfalls wird eine Ausnahme ausgel√∂st. </font><font style="vertical-align: inherit;">Die Suche wird von denjenigen durchgef√ºhrt, die den aktuellen Sichtbarkeitsbereichen am n√§chsten liegen, und endet mit dem Auffinden der Variablen. </font><font style="vertical-align: inherit;">Dies wird als Scope Chain bezeichnet.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-comment">//    -&gt;    -&gt;   </span><font></font>
<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> variable1 = <span class="hljs-string">'Comrades'</span>
<span class="hljs-keyword">var</span> variable2 = <span class="hljs-string">'Sayonara'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">var</span> variable1 = <span class="hljs-string">'World'</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">//   </span>
        <span class="hljs-keyword">var</span> variable2 = <span class="hljs-string">'Hello'</span>
        <span class="hljs-built_in">console</span>.log(variable2 + <span class="hljs-string">' '</span> + variable1)<font></font>
    }<font></font>
    inner()<font></font>
}<font></font>
outer()<font></font>
<span class="hljs-comment">//    'Hello World',</span>
<span class="hljs-comment">//   variable2 = 'Hello'  variable1 = 'World'  </span>
<span class="hljs-comment">//     </span>
</code></pre><br>
<img src="https://habrastorage.org/webt/r6/07/q7/r607q7hehfjmuicf0_icntddk2s.png"><br>
<br>
<a name="20"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20. Was ist ein Verschluss (Closures)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist wahrscheinlich die schwierigste Frage aus der Liste. Ich werde versuchen zu erkl√§ren, wie ich Schlie√üung verstehe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Tat ist das Schlie√üen die F√§higkeit einer Funktion, Verkn√ºpfungen zu Variablen und Parametern zu erstellen, die sich im aktuellen Bereich, im Bereich der √ºbergeordneten Funktion, im Bereich des √ºbergeordneten Bereichs der √ºbergeordneten Funktion usw. zum globalen Bereich befinden, wobei die Kette der Bereiche zum Zeitpunkt der Erstellung verwendet wird. In der Regel wird der Umfang beim Erstellen einer Funktion festgelegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiele sind eine gute M√∂glichkeit, den Abschluss zu erkl√§ren:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">'abc'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-built_in">console</span>.log(globalVar)<font></font>
}<font></font>
<font></font>
a() <span class="hljs-comment">// 'abc'</span>
<span class="hljs-comment">//   </span>
<span class="hljs-comment">//    a -&gt;   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir in diesem Beispiel eine Funktion deklarieren, ist der globale Bereich Teil des Abschlusses. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/10/ke/qa/10keqaosrww0rntbyei1gx9f_k0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Variable ‚ÄûglobalVar‚Äú spielt im Bild keine Rolle, da sich ihr Wert abh√§ngig davon √§ndern kann, wo und wann die Funktion aufgerufen wird. Im obigen Beispiel hat globalVar jedoch den Wert "abc". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ist das Beispiel komplizierter:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">'global'</span>
<span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">'outer'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outerFunc</span>(<span class="hljs-params">outerParam</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFunc</span>(<span class="hljs-params">innerParam</span>) </span>{
        <span class="hljs-built_in">console</span>.log(globalVar, outerParam, innerParam)<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> innerFunc<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> x = outerFunc(outerVar)<font></font>
outerVar = <span class="hljs-string">'outer-2'</span>
globalVar = <span class="hljs-string">'guess'</span>
x(<span class="hljs-string">'inner'</span>)
</code></pre><br>
<img src="https://habrastorage.org/webt/ms/dv/wx/msdvwxdxp5s3l4cquxnqgkdtyr0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis ist "erraten √§u√üere innere". Die Erkl√§rung lautet wie folgt: Wenn wir die OuterFunc-Funktion aufrufen und die Variable "x" auf den von der InnerFunc-Funktion zur√ºckgegebenen Wert setzen, entspricht der Parameter "OuterParam" "Outer". Trotz der Tatsache, dass wir die Variable "OuterVar" "Outer-2" zugewiesen haben, geschah dies nach dem Aufruf der Funktion "OuterFunc", die es "geschafft" hat, den Wert der Variablen "OuterVar" in der Bereichskette zu finden. Dieser Wert war "Outer". Wenn wir "x" aufrufen, was sich auf innerFunc bezieht, ist der Wert von "innerParam" "inner", da wir diesen Wert als Parameter √ºbergeben, wenn wir "x" aufrufen. globalVar hat den Wert "rate", da wir ihm diesen Wert zugewiesen haben, bevor wir "x" aufgerufen haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Beispiel f√ºr ein Missverst√§ndnis einer Schaltung.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> arrFunc = []
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {<font></font>
    arrFunc.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> i<font></font>
    })<font></font>
}<font></font>
<span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">// 5</span><font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arrFunc.length; i++) {
    <span class="hljs-built_in">console</span>.log(arrFunc[i]()) <span class="hljs-comment">//  5</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code funktioniert nicht wie erwartet. </font><font style="vertical-align: inherit;">Durch das Deklarieren einer Variablen mit dem Schl√ºsselwort var wird diese Variable global. </font><font style="vertical-align: inherit;">Nach dem Hinzuf√ºgen von Funktionen zum Array arrFunc wird der Wert der globalen Variablen "i" zu "5". </font><font style="vertical-align: inherit;">Wenn wir die Funktion aufrufen, gibt sie daher den Wert der globalen Variablen "i" zur√ºck. </font><font style="vertical-align: inherit;">Ein Abschluss speichert einen Verweis auf eine Variable, nicht ihren Wert zum Zeitpunkt der Erstellung. </font><font style="vertical-align: inherit;">Dieses Problem kann durch Verwendung von IIFE oder durch Deklarieren einer Variablen mit dem Schl√ºsselwort "let" gel√∂st werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lesen Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mehr √ºber die Schlie√üung </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="21"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21. Welche Werte in JS sind falsch?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> falsyValues = [<span class="hljs-string">''</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-literal">false</span>]
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
False sind Werte, deren Konvertierung in einen Booleschen Wert false ist.</font></font><br>
<br>
<a name="22"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22. Wie √ºberpr√ºfe ich, ob ein Wert falsch ist?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie die Boolesche Funktion oder den Operator "!!" </font><font style="vertical-align: inherit;">(zweimal nein).</font></font><br>
<br>
<a name="23"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">23. Wof√ºr wird die strikte Richtlinie verwendet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Use strict" ist eine ES5-Direktive, die den gesamten Code oder den Code einer einzelnen Funktion zur Ausf√ºhrung im strengen Modus zwingt. </font><font style="vertical-align: inherit;">Der strikte Modus f√ºhrt einige Einschr√§nkungen beim Schreiben von Code ein, wodurch Fehler in den fr√ºhen Stadien vermieden werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sind die Einschr√§nkungen des strengen Modus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen keine Werte zuweisen oder auf nicht deklarierte Variablen zugreifen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnY</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-string">'use strict'</span>
    y = <span class="hljs-number">123</span>
    <span class="hljs-keyword">return</span> y<font></font>
}<font></font>
returnY() <span class="hljs-comment">// Uncaught ReferenceError: y is not defined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist verboten, schreibgesch√ºtzten oder schreibgesch√ºtzten Variablen globale Werte zuzuweisen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span>
<span class="hljs-keyword">var</span> <span class="hljs-literal">NaN</span> = <span class="hljs-literal">NaN</span> <span class="hljs-comment">// Uncaught TypeError: Cannot assign to read only property 'NaN' of object '#&lt;Window&gt;'</span>
<span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-keyword">var</span> <span class="hljs-literal">Infinity</span> = <span class="hljs-string">'and beyond'</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen die Eigenschaft "nicht l√∂schbar" eines Objekts nicht l√∂schen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span>
<span class="hljs-keyword">const</span> obj = {}<font></font>
<font></font>
<span class="hljs-built_in">Object</span>.defineProperties(obj, <span class="hljs-string">'x'</span>, {
    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><font></font>
})<font></font>
<font></font>
<span class="hljs-keyword">delete</span> obj.x <span class="hljs-comment">// Uncaught TypeError: Property description must be an object: x</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Duplizieren von Parametern ist verboten:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someFunc</span>(<span class="hljs-params">a, b, b, c</span>) </span>{} <span class="hljs-comment">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der Funktion eval k√∂nnen Sie keine Funktionen erstellen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span><font></font>
<font></font>
<span class="hljs-built_in">eval</span>(<span class="hljs-string">'var x = 1'</span>)<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(x) <span class="hljs-comment">// Uncaught ReferenceError: x is not defined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Standardwert hierf√ºr ist undefiniert:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-meta">'use strict'</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMeThis</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><font></font>
}<font></font>
<font></font>
showMeThis() <span class="hljs-comment">// undefined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Ä¶ usw.</font></font><br>
<br>
<a name="24"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24. Was bedeutet das?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bezieht sich normalerweise auf den Wert des Objekts, das gerade die Funktion ausf√ºhrt oder aufruft. </font><font style="vertical-align: inherit;">"Im Moment" bedeutet, dass der Wert davon abh√§ngig vom Ausf√ºhrungskontext variiert, in dem wir dies verwenden.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> carDetails = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Ford Mustang'</span>,
    <span class="hljs-attr">yearBought</span>: <span class="hljs-number">2005</span>,<font></font>
    getName() {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name<font></font>
    }<font></font>
    <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">true</span><font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(carDetails.getName()) <span class="hljs-comment">// Ford Mustang</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall gibt die Methode getName this.name zur√ºck. Dies bezieht sich auf carDetails, das Objekt, in dem getName ausgef√ºhrt wird, und dessen "Eigent√ºmer". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºgen Sie nach console.log drei Zeilen hinzu:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'Ford Ranger'</span>
<span class="hljs-keyword">var</span> getCarName = carDetails.getName<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(getCarName()) <span class="hljs-comment">// Ford Ranger</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite console.log produziert einen Ford Ranger, und das ist komisch. </font><font style="vertical-align: inherit;">Der Grund f√ºr dieses Verhalten ist, dass der "Eigent√ºmer" von getCarName das Fensterobjekt ist. </font><font style="vertical-align: inherit;">Mit dem Schl√ºsselwort var im globalen Bereich deklarierte Variablen werden in die Eigenschaften des Fensterobjekts geschrieben. </font><font style="vertical-align: inherit;">Dies bezieht sich im globalen Bereich auf das Fensterobjekt (es sei denn, es handelt sich um einen strengen Modus).</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(getCarName === <span class="hljs-built_in">window</span>.getCarName) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(getCarName === <span class="hljs-keyword">this</span>.getCarName) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel beziehen sich dieses und das Fenster auf dasselbe Objekt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine M√∂glichkeit, dieses Problem zu l√∂sen, besteht darin, den Aufruf zu verwenden oder Methoden anzuwenden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(getCarName.apply(carDetails)) <span class="hljs-comment">// Ford Mustang</span>
<span class="hljs-built_in">console</span>.log(getCarName.call(carDetails)) <span class="hljs-comment">// Ford Mustang</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rufen Sie auf und wenden Sie als erstes Argument ein Objekt an, dessen Wert dies innerhalb der Funktion ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In IIFE sind Funktionen, die im globalen Bereich erstellt werden, anonyme Funktionen und interne Funktionen der Methoden eines Objekts. Der Standardwert hierf√ºr ist das Fensterobjekt.</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)<font></font>
})() <span class="hljs-comment">// window</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iHateThis</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)<font></font>
}<font></font>
iHateThis() <span class="hljs-comment">// window</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> myFavouriteObj = {<font></font>
    guessThis() {<font></font>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<font></font>
        }<font></font>
        getName()<font></font>
    },<font></font>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span>,<font></font>
    thisIsAnnoying(callback) {<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
<font></font>
myFavouriteObj.guessThis() <span class="hljs-comment">// window</span>
myFavouriteObj.thisIsAnnoying(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// window</span><font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt zwei M√∂glichkeiten, um Marko Polo zu bekommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens k√∂nnen wir den Wert davon in einer Variablen speichern:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myFavoriteObj = {<font></font>
    guessThis() {<font></font>
        <span class="hljs-keyword">const</span> self = <span class="hljs-keyword">this</span> <span class="hljs-comment">//   this   self</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(self.name)<font></font>
        }<font></font>
        getName()<font></font>
    },<font></font>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span>,<font></font>
    thisIsAnnoying(callback) {<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens k√∂nnen wir die Pfeilfunktion verwenden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myFavoriteObj = {<font></font>
    guessThis() {<font></font>
        <span class="hljs-keyword">const</span> getName = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            <span class="hljs-comment">//   this   </span>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<font></font>
        }<font></font>
        getName()<font></font>
    },<font></font>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span>,<font></font>
    thisIsAnnoying(callback) {<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pfeilfunktionen haben diesen Eigenwert nicht. </font><font style="vertical-align: inherit;">Sie kopieren die Bedeutung davon aus der externen lexikalischen Umgebung.</font></font><br>
<br>
<a name="25"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25. Was ist ein Prototyp eines Objekts?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz gesagt, ein Prototyp ist ein Plan (Diagramm oder Projekt) eines Objekts. </font><font style="vertical-align: inherit;">Es wird als Fallback f√ºr die in diesem Objekt vorhandenen Eigenschaften und Methoden verwendet. </font><font style="vertical-align: inherit;">Dies ist auch eine der M√∂glichkeiten, Eigenschaften und Funktionen zwischen Objekten auszutauschen. </font><font style="vertical-align: inherit;">Dies ist das Grundkonzept der Prototypvererbung in JS.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o = {}
<span class="hljs-built_in">console</span>.log(o.toString()) <span class="hljs-comment">// [object Object]</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl das Objekt "o" nicht √ºber die Eigenschaft toString verf√ºgt, f√ºhrt der Zugriff auf diese Eigenschaft nicht zu einem Fehler. </font><font style="vertical-align: inherit;">Befindet sich eine bestimmte Eigenschaft nicht im Objekt, wird ihre Suche zuerst im Prototyp des Objekts, dann im Prototyp des Prototyps des Objekts usw. ausgef√ºhrt, bis die Eigenschaft gefunden wird. </font><font style="vertical-align: inherit;">Dies wird als Prototypkette bezeichnet. </font><font style="vertical-align: inherit;">Am Anfang der Prototypenkette steht Object.prototype.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(o.toString === <span class="hljs-built_in">Object</span>.prototype.toString) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lesen Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mehr √ºber Prototypen und Vererbung </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="26"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26. Was ist IIFE?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IIFE oder sofort aufgerufene Funktion Ausdruck ist eine Funktion, die unmittelbar nach der Erstellung oder Deklaration aufgerufen oder ausgef√ºhrt wird. </font><font style="vertical-align: inherit;">Um IIFE zu erstellen, m√ºssen Sie die Funktion in Klammern (den Gruppierungsoperator) einschlie√üen, in einen Ausdruck umwandeln und dann mit anderen Klammern aufrufen. </font><font style="vertical-align: inherit;">Es sieht so aus: (function () {}) ().</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> </span>) </span>{ }( ))<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> </span>) </span>{ })( )<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">named</span>(<span class="hljs-params">params</span>) </span>{ })( )<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-params">( )</span> =&gt;</span> { })<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">global</span>) </span>{ })(<span class="hljs-built_in">window</span>)<font></font>
<font></font>
<span class="hljs-keyword">const</span> utility = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> </span>) </span>{
    <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">// </span><font></font>
    }<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle diese Beispiele sind g√ºltig. </font><font style="vertical-align: inherit;">Das vorletzte Beispiel zeigt, dass wir Parameter an IIFE √ºbergeben k√∂nnen. </font><font style="vertical-align: inherit;">Das letzte Beispiel zeigt, dass wir das Ergebnis von IIFE in einer Variablen speichern k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die beste Verwendung von IIFE besteht darin, Konfigurationsfunktionen f√ºr die Initialisierung auszuf√ºhren und Namenskonflikte mit anderen Variablen im globalen Bereich (Verschmutzung des globalen Namespace) zu verhindern. </font><font style="vertical-align: inherit;">Wir geben ein Beispiel.</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script src=<span class="hljs-string">"https://cdnurl.com/somelibrary.js"</span>&gt;&lt;/script&gt;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben einen Link zur Bibliothek somelibrary.js, die einige globale Funktionen bereitstellt, die wir in unserem Code verwenden k√∂nnen. In dieser Bibliothek gibt es jedoch zwei Methoden, createGraph und drawGraph, die wir nicht verwenden, da sie Fehler enthalten. </font><font style="vertical-align: inherit;">Und wir wollen diese Funktionen selbst implementieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine M√∂glichkeit, dieses Problem zu l√∂sen, besteht darin, die Struktur unserer Skripte zu √§ndern:</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script src=<span class="hljs-string">"https://cdnurl.com/somelibrary.js"</span>&gt;&lt;/script&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher definieren wir die von der Bibliothek bereitgestellten Methoden neu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite Weg ist die √Ñnderung der Namen unserer Funktionen:</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script src=<span class="hljs-string">"https://cdnurl.com/somelibrary.js"</span>&gt;&lt;/script&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCreateGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myDrawGraph</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// </span>
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der dritte Weg ist die Verwendung von IIFE:</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script&gt;
    <span class="hljs-keyword">const</span> graphUtility = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createGraph</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">// </span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawGraph</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">// </span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> {<font></font>
            createGraph,<font></font>
            drawGraph<font></font>
        }<font></font>
    })<font></font>
&lt;/script&gt;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel erstellen wir eine Dienstprogrammvariable, die das IIFE-Ergebnis enth√§lt und ein Objekt zur√ºckgibt, das die Methoden createGraph und drawGraph enth√§lt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein weiteres Problem, das mit IIFE gel√∂st werden kann:</font></font><br>
<br>
<pre><code class="javascript hljs">val li = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.list-group &gt; li'</span>)
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i - <span class="hljs-number">0</span>, len = li.length; i &lt; len; i++) {<font></font>
    li[i].addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        <span class="hljs-built_in">console</span>.log(i)<font></font>
    })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben ein ul-Element mit einer Listengruppenklasse, die 5 untergeordnete Elemente li enth√§lt. </font><font style="vertical-align: inherit;">Und wir m√∂chten den Wert "i" in der Konsole anzeigen, wenn wir auf ein separates "li" klicken. </font><font style="vertical-align: inherit;">Stattdessen zeigt die Konsole jedoch immer 5 an. Der Fehler ist der gesamte Fehler. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine L√∂sung ist IIFE:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.list-group &gt; li'</span>)
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = li.length; i &lt; len; i++) {<font></font>
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentIndex</span>) </span>{<font></font>
        li[currentIndex].addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
            <span class="hljs-built_in">console</span>.log(currentIndex)<font></font>
        })<font></font>
    })(i)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Grund, warum dieser Code wie beabsichtigt funktioniert, ist, dass IIFE bei jeder Iteration einen neuen Bereich erstellt und wir den Wert "i" in currentIndex schreiben.</font></font><br>
<br>
<a name="27"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">27. Wof√ºr wird die Function.prototype.apply-Methode verwendet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Apply wird ein bestimmtes Objekt an diesen Wert der aufgerufenen Funktion gebunden.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> details = {
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello World!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMessage</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.message<font></font>
}<font></font>
<font></font>
getMessage.apply(details) <span class="hljs-comment">// Hello World!</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Methode √§hnelt Function.prototype.call. </font><font style="vertical-align: inherit;">Der einzige Unterschied besteht darin, dass in apply die Argumente als Array √ºbergeben werden.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> person = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeting</span>(<span class="hljs-params">greetingMessage</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${greetingMessage}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
}<font></font>
<font></font>
greeting.apply(person, [<span class="hljs-string">'Hello'</span>]) <span class="hljs-comment">// Hello Marko Polo</span>
</code></pre><br>
<a name="28"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28. Wof√ºr wird die Methode function.prototype.call verwendet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Call wird verwendet, um ein bestimmtes Objekt an den Wert dieser aufgerufenen Funktion zu binden.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> details = {
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello World!'</span><font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMessage</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.message;<font></font>
}<font></font>
<font></font>
getMessage.call(details); <span class="hljs-comment">// Hello World!</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Methode √§hnelt Function.prototype.apply. </font><font style="vertical-align: inherit;">Der Unterschied besteht darin, dass beim Aufruf Argumente durch Kommas getrennt √ºbergeben werden.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> person = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko Polo'</span><font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeting</span>(<span class="hljs-params">greetingMessage</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${greetingMessage}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span>;<font></font>
}<font></font>
<font></font>
greeting.call(person, <span class="hljs-string">'Hello'</span>); <span class="hljs-comment">// Hello Marko Polo</span>
</code></pre><br>
<a name="29"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">29. Was ist der Unterschied zwischen Aufruf- und Anwendungsmethoden?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Unterschied zwischen call und apply besteht darin, wie wir Argumente in der aufgerufenen Funktion √ºbergeben. </font><font style="vertical-align: inherit;">In apply werden die Argumente als Array √ºbergeben, in call, durch Kommas getrennt.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj1 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> obj2 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduceAdd</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) {<font></font>
        result += <span class="hljs-built_in">arguments</span>[i]<font></font>
    }<font></font>
    <span class="hljs-keyword">this</span>.result = result<font></font>
}<font></font>
<font></font>
reduceAdd.apply(obj1, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]) <span class="hljs-comment">// 15</span>
reduceAdd.call(obj2, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 15</span>
</code></pre><br>
<a name="30"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30. Wof√ºr wird die Methode function.prototype.bind verwendet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bind gibt eine neue Funktion zur√ºck, deren Wert das als erster Parameter angegebene Objekt ist. </font><font style="vertical-align: inherit;">Rufen Sie im Gegensatz zum Binden die Funktion auf und rufen Sie sie sofort auf.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props)
        <span class="hljs-keyword">this</span>.state = {
            <span class="hljs-attr">value</span>: <span class="hljs-string">''</span><font></font>
        }<font></font>
        <span class="hljs-keyword">this</span>.handleChange = <span class="hljs-keyword">this</span>.handleChange.bind(<span class="hljs-keyword">this</span>)
        <span class="hljs-comment">//   handleChange   MyComponent</span><font></font>
    }<font></font>
<font></font>
    handleChange(e) {<font></font>
        <span class="hljs-comment">// </span><font></font>
    }<font></font>
<font></font>
    render() {<font></font>
        <span class="hljs-keyword">return</span> ( &lt; &gt;<font></font>
            &lt;<font></font>
            input type = {<font></font>
                <span class="hljs-keyword">this</span>.props.type<font></font>
            }<font></font>
            value = {<font></font>
                <span class="hljs-keyword">this</span>.state.value<font></font>
            }<font></font>
            onChange = {<font></font>
                <span class="hljs-keyword">this</span>.handleChange<font></font>
            }<font></font>
            /&gt; &lt;/ &gt;<font></font>
        )<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<a name="31"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">31. Was ist funktionale Programmierung und welche Funktionen von JS erm√∂glichen es uns, dar√ºber als funktionale Programmiersprache zu sprechen?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktionale Programmierung ist ein deklaratives Programmierkonzept oder ein Beispiel (Muster) daf√ºr, wie Anwendungen erstellt werden und wie Funktionen verwendet werden, die Ausdr√ºcke enthalten, die Werte berechnen, ohne die an sie √ºbergebenen Argumente zu √§ndern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Array-Objekt enth√§lt die Zuordnungs-, Filter- und Reduzierungsmethoden, die aufgrund ihrer N√ºtzlichkeit und auch, weil sie das Array nicht √§ndern, die diese Funktionen ‚Äûsauber‚Äú machen, die bekanntesten Funktionen in der Welt der funktionalen Programmierung sind. </font><font style="vertical-align: inherit;">JS hat auch einen Abschluss und Funktionen h√∂herer Ordnung, die Merkmale einer funktionalen Programmiersprache sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Map-Methode gibt ein neues Array mit R√ºckrufergebnissen f√ºr jedes Element des Arrays zur√ºck:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> words = [<span class="hljs-string">'Functional'</span>, <span class="hljs-string">'Procedural'</span>, <span class="hljs-string">'Object-Oriented'</span>]<font></font>
<font></font>
<span class="hljs-keyword">const</span> wordsLength = words.map(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word.length)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Filtermethode erstellt ein neues Array mit allen Elementen, die die im R√ºckruf angegebene Bedingung erf√ºllen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> data = {<font></font>
    {<font></font>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Mark'</span>,
        <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">true</span><font></font>
    } {<font></font>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Mary'</span>,
        <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">false</span><font></font>
    } {<font></font>
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Mae'</span>,
        <span class="hljs-attr">isRegistered</span>: <span class="hljs-literal">true</span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> registeredUsers = data.filter(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.isRegistered)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Reduktionsmethode f√ºhrt einmalig einen R√ºckruf f√ºr jedes Element des Arrays aus, mit Ausnahme von Hohlr√§umen, wobei vier Argumente verwendet werden: der Anfangswert (oder der Wert aus dem vorherigen R√ºckruf), der Wert des aktuellen Elements, der aktuelle Index und das iterierte Array:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> strs = [<span class="hljs-string">'I'</span>, <span class="hljs-string">' '</span>, <span class="hljs-string">'am'</span>, <span class="hljs-string">' '</span>, <span class="hljs-string">'Iron'</span>, <span class="hljs-string">' '</span>, <span class="hljs-string">'Man'</span>]<font></font>
<font></font>
<span class="hljs-keyword">const</span> result = strs.reduce(<span class="hljs-function">(<span class="hljs-params">acc, currentStr</span>) =&gt;</span> acc + str, <span class="hljs-string">''</span>)
</code></pre><br>
<a name="32"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32. Was sind Funktionen h√∂herer Ordnung?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Funktion h√∂herer Ordnung ist eine Funktion, die eine andere Funktion zur√ºckgibt oder eine andere Funktion als Argument akzeptiert.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">higherOrderFunction</span>(<span class="hljs-params">param, callback</span>) </span>{
    <span class="hljs-keyword">return</span> callback(param)<font></font>
}<font></font>
</code></pre><br>
<a name="33"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">33. Warum werden Funktionen in JS als erstklassige Objekte bezeichnet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funktionen werden als erstklassige Objekte bezeichnet, da sie wie jeder andere Wert in JS verarbeitet werden. </font><font style="vertical-align: inherit;">Sie k√∂nnen Variablen zugewiesen werden, eine Eigenschaft eines Objekts (einer Methode), ein Element eines Arrays, ein Argument f√ºr eine andere Funktion und der von der Funktion zur√ºckgegebene Wert sein. </font><font style="vertical-align: inherit;">Der einzige Unterschied zwischen einer Funktion und einem anderen Wert in JS besteht darin, dass die Funktion ausgef√ºhrt oder aufgerufen werden kann.</font></font><br>
<br>
<a name="34"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">34. Wie w√ºrden Sie die Array.prototype.map-Methode implementieren?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">arr, mapCallback</span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr) || !arr.length || <span class="hljs-keyword">typeof</span> mapCallback !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> []<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">let</span> result = []
        <span class="hljs-comment">//         </span>
        <span class="hljs-comment">//       </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) {<font></font>
            result.push(mapCallback(arr[i], i, arr))<font></font>
            <span class="hljs-comment">//   mapCallback  result</span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Map-Methode erstellt ein neues Array mit dem Ergebnis des Aufrufs der angegebenen Funktion f√ºr jedes Element des Arrays.</font></font><br>
<br>
<a name="35"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">35. Wie w√ºrden Sie die Array.prototype.filter-Methode implementieren?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span>(<span class="hljs-params">arr, filterCallback</span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr) || !arr.length || <span class="hljs-keyword">typeof</span> filterCallback !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> []<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">let</span> result = []
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) {
            <span class="hljs-comment">//      </span>
            <span class="hljs-keyword">if</span> (filterCallback(arr[i], i, arr)) {
                <span class="hljs-comment">//  ,  ,  result</span><font></font>
                result.push(arr[i])<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Filtermethode erstellt ein neues Array mit allen Elementen, die den in der √ºbergebenen Funktion angegebenen Test bestanden haben.</font></font><br>
<br>
<a name="36"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">36. Wie w√ºrden Sie die Array.prototype.reduce-Methode implementieren?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduce</span>(<span class="hljs-params">arr, reduceCallbak, initialValue</span>) </span>{
    <span class="hljs-comment">// ..</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr) || !arr.length || <span class="hljs-keyword">typeof</span> filterCallback !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> []<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//        initialValue, </span>
        <span class="hljs-keyword">let</span> hasInitialValue = initialValue !== <span class="hljs-literal">undefined</span>
        <span class="hljs-keyword">let</span> value = hasInitialValue ? initialValue : arr[<span class="hljs-number">0</span>]
        <span class="hljs-comment">//      initialValue</span><font></font>
<font></font>
        <span class="hljs-comment">//    ,   1,       initialValue,   0,    </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = hasInitialValue ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>, len = arr.length; i &lt; len; i++) {
            <span class="hljs-comment">//         reduceCallback </span><font></font>
            value = reduceCallback(value, arr[i], i, arr)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> value<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Reduktionsmethode wendet die Reduzierungsfunktion auf jedes Element des Arrays an (von links nach rechts) und gibt einen resultierenden Wert zur√ºck.</font></font><br>
<br>
<a name="37"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">37. Was ist ein Argumentobjekt?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Argumente ist eine Sammlung von Argumenten, die an eine Funktion √ºbergeben werden. </font><font style="vertical-align: inherit;">Dies ist ein Array-√§hnliches Objekt, es hat die Eigenschaft length, wir k√∂nnen mit Argumenten [i] auf einen bestimmten Wert zugreifen, aber es verf√ºgt nicht √ºber die Methoden forEach, redu, filter und map. </font><font style="vertical-align: inherit;">Hier k√∂nnen Sie die Anzahl der Funktionsparameter ermitteln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen Argumente mit Array.prototype.slice in ein Array konvertieren:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie daran: In Pfeilfunktionen funktioniert das Argumentobjekt nicht.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">one</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span><font></font>
}<font></font>
<span class="hljs-keyword">const</span> two = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span><font></font>
}<font></font>
<span class="hljs-keyword">const</span> three = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">three</span>(<span class="hljs-params">{
    return arguments
}</span>)
<span class="hljs-title">const</span> <span class="hljs-title">four</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title">arguments</span>

<span class="hljs-title">four</span>(<span class="hljs-params"></span>) // <span class="hljs-title">arguments</span> <span class="hljs-title">is</span> <span class="hljs-title">not</span> <span class="hljs-title">defined</span>
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Aufrufen der vier Funktionen f√ºhrt zu einem ReferenceError: Argumente ist kein definierter Fehler. </font><font style="vertical-align: inherit;">Dieses Problem kann mit der rest-Anweisung gel√∂st werden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> four = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> args
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dadurch werden automatisch alle Parameter in ein Array eingef√ºgt.</font></font><br>
<br>
<a name="38"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">38. Wie erstelle ich ein Objekt ohne Prototyp?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies kann mit Object.create erfolgen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o1 = {}
<span class="hljs-built_in">console</span>.log(o1.toString) <span class="hljs-comment">// [object Object]</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> o2 = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>) <span class="hljs-comment">//      Object-create  -</span>
<span class="hljs-comment">//    -,   null</span>
<span class="hljs-built_in">console</span>.log(o2.toString) <span class="hljs-comment">// o2.toString is not a function</span>
</code></pre><br>
<a name="39"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">39. Warum wird im dargestellten Code die Variable b global, wenn die Funktion aufgerufen wird?</font></font></h4><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> a = b = <span class="hljs-number">0</span><font></font>
}<font></font>
myFunc()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies geschieht, weil der Zuweisungsoperator ("=") eine rechtsh√§ndige Assoziativit√§t aufweist, d. H. </font><font style="vertical-align: inherit;">weist Werte von rechts nach links zu. </font><font style="vertical-align: inherit;">Daher hat der Code die folgende Form:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> a = (b = <span class="hljs-number">0</span>)<font></font>
}<font></font>
myFunc()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst wird der Variablen "b" der Wert 0 zugewiesen, der nicht deklariert ist. </font><font style="vertical-align: inherit;">Die JS-Engine macht es global. </font><font style="vertical-align: inherit;">Der von b = 0 zur√ºckgegebene Wert (0) wird dann der lokalen Variablen "a" zugewiesen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Problem kann gel√∂st werden, indem zuerst lokale Variablen deklariert und ihnen dann Werte zugewiesen werden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> a, b<font></font>
    a = b = <span class="hljs-number">0</span><font></font>
}<font></font>
myFunc()<font></font>
</code></pre><br>
<a name="40"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">40. Was ist ECMAScript?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ECMAScript ist eine Spezifikation, eine Standard-Programmiersprache f√ºr Skripte. Sie ist die Basis von JS, sodass alle √Ñnderungen an ECMAScript in JS ber√ºcksichtigt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die neueste Version der ECMA-262-Spezifikation kann hier eingesehen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="41"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">41. Welche neuen Dinge brachte ES6 oder ECMAScript2015 zu JS?</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pfeilfunktionen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Template Strings.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweiterte Objektliterale</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Destrukturierung (Objektzerst√∂rung).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versprechen Versprechen).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generatoren</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Module</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proxies</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sets.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Standardoptionen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruhe- und Verbreitungsoperatoren.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blockbereich (Schl√ºsselw√∂rter "let" und "const").</font></font></li>
</ul><br>
<a name="42"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">42. Was ist der Unterschied zwischen den Schl√ºsselw√∂rtern "var", "let" und "const"?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dem Schl√ºsselwort var deklarierte Variablen sind global. </font><font style="vertical-align: inherit;">Dies bedeutet, dass sie von √ºberall im Code zug√§nglich sind:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeX</span>(<span class="hljs-params">showX</span>)</span>{
    <span class="hljs-keyword">if</span>(showX){
        <span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> x<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(giveMeX(<span class="hljs-literal">false</span>))
<span class="hljs-built_in">console</span>.log(giveMeX(<span class="hljs-literal">true</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis des ersten console.log ist undefiniert, das zweite - 5. Wir haben Zugriff auf die Variable "x", da sie in den globalen Bereich aufgenommen wird. </font><font style="vertical-align: inherit;">Der Code aus dem obigen Beispiel wird wie folgt interpretiert:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeX</span>(<span class="hljs-params">showX</span>)</span>{
    <span class="hljs-keyword">var</span> x <span class="hljs-comment">//   undefined</span>
    <span class="hljs-keyword">if</span>(showX){<font></font>
        x = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> x<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis der ersten console.log ist undefiniert, da deklarierte Variablen, denen kein Wert zugewiesen wurde, standardm√§√üig nicht definiert sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Variablen, die mit den Schl√ºsselw√∂rtern "let" und "const" deklariert wurden, haben einen Blockbereich. </font><font style="vertical-align: inherit;">Dies bedeutet, dass sie nur innerhalb des Blocks ({}) verf√ºgbar sind:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeX</span>(<span class="hljs-params">showX</span>)</span>{
    <span class="hljs-keyword">if</span>(showX){
        <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> x<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">giveMeY</span>(<span class="hljs-params">showY</span>)</span>{
    <span class="hljs-keyword">if</span>(showY){
        <span class="hljs-keyword">let</span> y = <span class="hljs-number">5</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> y<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Aufrufen dieser Funktionen mit dem Parameter false f√ºhrt zu einem ReferenceError-Fehler, da auf die Variablen "x" und "y" au√üerhalb des Blocks nicht zugegriffen werden kann und ihre Werte nicht zur√ºckgegeben werden (nicht auftauchen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Unterschied zwischen "let" und "const" besteht darin, dass wir im ersten Fall den Wert der Variablen √§ndern k√∂nnen und im zweiten - no (Konstante). </font><font style="vertical-align: inherit;">Gleichzeitig k√∂nnen wir den Wert der Eigenschaft eines mit const deklarierten Objekts √§ndern, nicht jedoch die Eigenschaft selbst (Variable).</font></font><br>
<br>
<a name="43"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">43. Was sind Pfeilfunktionen (Pfeilfunktionen)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Pfeilfunktion ist eine relativ neue Methode zum Erstellen von Funktionen in JS. </font><font style="vertical-align: inherit;">Pfeilfunktionen sind schneller und haben eine besser lesbare Syntax als funktionale Ausdr√ºcke. </font><font style="vertical-align: inherit;">In Pfeilfunktionen wird das Wort "Funktion" weggelassen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> getCurrentDate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> getCurrentDate = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einem funktionalen Ausdruck verwenden wir das Schl√ºsselwort return, um einen Wert zur√ºckzugeben. </font><font style="vertical-align: inherit;">In der Pfeilfunktion tun wir dies nicht, da Pfeilfunktionen implizit Werte zur√ºckgeben, vorausgesetzt, wir geben einen einzelnen Ausdruck oder Wert zur√ºck:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span> <font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> greet = <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>
<span class="hljs-keyword">const</span> greet2 = name = &gt; <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen auch Parameter an Pfeilfunktionen √ºbergeben. </font><font style="vertical-align: inherit;">Wenn wir einen Parameter √ºbergeben, m√ºssen wir ihn nicht in Klammern setzen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> getArgs = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">arguments</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> getArgs2 = <span class="hljs-function">(<span class="hljs-params">...rest</span>) =&gt;</span> rest
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pfeilfunktionen haben keinen Zugriff auf das Argumentobjekt. </font><font style="vertical-align: inherit;">Daher f√ºhrt der Aufruf der ersten Funktion zu einem Fehler. </font><font style="vertical-align: inherit;">Um die Parameter an die Funktion zu √ºbergeben, k√∂nnen wir den Rest-Operator verwenden.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> data = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span>
    <span class="hljs-attr">nums</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<font></font>
    computeResult(){<font></font>
        <span class="hljs-comment">// this    data</span>
        <span class="hljs-keyword">const</span> addAll = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-comment">//     this   </span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nums.reduce(<span class="hljs-function">(<span class="hljs-params">total, cur</span>) =&gt;</span> total + cur, <span class="hljs-number">0</span>)<font></font>
        }<font></font>
    <span class="hljs-keyword">this</span>.result = addAll()<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<a name="44"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">44. Was sind Klassen?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Klassen sind eine relativ neue Art, Konstruktorfunktionen in JS zu schreiben. </font><font style="vertical-align: inherit;">Dies ist syntaktischer Zucker f√ºr Konstruktorfunktionen. </font><font style="vertical-align: inherit;">Klassen basieren auf denselben Prototypen und derselben Prototypenvererbung:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">firstName, lastName, age, address</span>)</span>{
    <span class="hljs-keyword">this</span>.firstName = firstName
    <span class="hljs-keyword">this</span>.lastName = lastName
    <span class="hljs-keyword">this</span>.age = age
    <span class="hljs-keyword">this</span>.address = address<font></font>
}<font></font>
<font></font>
Person.self = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><font></font>
}<font></font>
<font></font>
Person.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Person]'</span><font></font>
}<font></font>
<font></font>
Person.prototype.getFullName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.lastName<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>{
    <span class="hljs-keyword">constructor</span>(firstName, lastName, age, address){
        <span class="hljs-keyword">this</span>.firstName = firstName
        <span class="hljs-keyword">this</span>.lastName = lastName
        <span class="hljs-keyword">this</span>.age = age
        <span class="hljs-keyword">this</span>.address = address<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> self(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><font></font>
    }<font></font>
<font></font>
    toString(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Person]'</span><font></font>
    }<font></font>
<font></font>
    getFullName(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.firstName}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.lastName}</span>`</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Methoden√ºberschreibungen und Vererbung von einer anderen Klasse:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
Employee.prototype = <span class="hljs-built_in">Object</span>.create(Person.prototype)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">firstName, lastName, age, address, jobTitle, yearStarted</span>)</span>{<font></font>
    Person.call(<span class="hljs-keyword">this</span>, firstName, lastName, age, address)
    <span class="hljs-keyword">this</span>.jobTitle = jobTitle
    <span class="hljs-keyword">this</span>.yearStarted = yearStarted<font></font>
}<font></font>
<font></font>
Employee.prototype.describe = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`I am <span class="hljs-subst">${<span class="hljs-keyword">this</span>.getFullName()}</span> and I have a position of #{this.jobTitle} and I started at <span class="hljs-subst">${<span class="hljs-keyword">this</span>.yearStarted}</span>}`</span><font></font>
}<font></font>
<font></font>
Employee.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Employee]'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>{ <span class="hljs-comment">//   Person</span>
    <span class="hljs-keyword">constructor</span>(firstName, lastName, age, address, jobTitle, yearStarted){
        <span class="hljs-keyword">super</span>(firstName, lastName, age, address)
        <span class="hljs-keyword">this</span>.jobTitle = jobTitle
        <span class="hljs-keyword">this</span>.yearStarted = yearStarted<font></font>
    }<font></font>
<font></font>
    describe(){<font></font>
       <span class="hljs-keyword">return</span> <span class="hljs-string">`I am <span class="hljs-subst">${<span class="hljs-keyword">this</span>.getFullName()}</span> and I have a position of #{this.jobTitle} and I started at <span class="hljs-subst">${<span class="hljs-keyword">this</span>.yearStarted}</span>}`</span> <font></font>
    }<font></font>
<font></font>
    toString(){ <span class="hljs-comment">//   toString  Person</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'[object Employee]'</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie lerne ich die Verwendung von Prototypen kennen?</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Something</span></span>{ }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AnotherSomething</span>(<span class="hljs-params"></span>)</span>{ }<font></font>
<font></font>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">as</span> = <span class="hljs-keyword">new</span> AnotherSomething()
<span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Something()<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> Something) <span class="hljs-comment">// function</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> AnotherSomething) <span class="hljs-comment">// function</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">as</span>.toString()) <span class="hljs-comment">// [object Object]</span>
<span class="hljs-built_in">console</span>.log(a.toString()) <span class="hljs-comment">// [object Object]</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">as</span>.toString === <span class="hljs-built_in">Object</span>.prototype.toString)
<span class="hljs-built_in">console</span>.log(a.toString === <span class="hljs-built_in">Object</span>.prototype.toString)
<span class="hljs-comment">//     true</span>
<span class="hljs-comment">// Object.prototype     </span>
<span class="hljs-comment">// Something  AnotherSomething   Object.prototype</span>
</code></pre><br>
<a name="45"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">45. Was sind Vorlagenliterale?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vorlagenliterale sind eine relativ neue Methode zum Erstellen von Zeichenfolgen in JS. </font><font style="vertical-align: inherit;">Vorlagenliterale werden mit doppelten Backticks (``) erstellt:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> greet = <span class="hljs-string">'Hi I\'m Mark'</span><font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">let</span> greet = <span class="hljs-string">`Hi I'm Mark`</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Vorlagenliteralen m√ºssen wir uns nicht in einfache Anf√ºhrungszeichen setzen.</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> lastWords = <span class="hljs-string">'\n'</span>
    + <span class="hljs-string">' I \n'</span>
    + <span class="hljs-string">' am \n'</span>
    + <span class="hljs-string">'Iron Man \n'</span><font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">let</span> lastWords = <span class="hljs-string">`
    I
    am
    Iron Man
`</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In ES6 m√ºssen wir die Escape-Sequenz "\ n" nicht verwenden, um die Zeile zu speisen.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + name + <span class="hljs-string">'!'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>!`</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In ES6 m√ºssen wir keine Zeichenfolgenverkettung verwenden, um Text mit einer Variablen zu kombinieren. Wir k√∂nnen den Ausdruck $ {expr} verwenden, um den Wert der Variablen abzurufen.</font></font><br>
<br>
<a name="46"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">46. ‚Äã‚ÄãWas ist Objektzerst√∂rung?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Destrukturierung ist eine relativ neue Methode zum Abrufen (Abrufen) der Werte eines Objekts oder Arrays. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir haben ein Objekt wie dieses:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> employee = {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Marko'</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Polo'</span>,
    <span class="hljs-attr">position</span>: <span class="hljs-string">'Software Developer'</span>,
    <span class="hljs-attr">yearHired</span>: <span class="hljs-number">2017</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuvor haben wir zum Erstellen der Eigenschaften eines Objekts Variablen f√ºr jede Eigenschaft erstellt. </font><font style="vertical-align: inherit;">Es war sehr langweilig und sehr nervig:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> firstName = employee.firstName
<span class="hljs-keyword">var</span> lastName = employee.lastName
<span class="hljs-keyword">var</span> position = employee.position
<span class="hljs-keyword">var</span> yearHired = employee.yearHired
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch die Verwendung der Destrukturierung wird der Code sauberer und ben√∂tigt weniger Zeit. </font><font style="vertical-align: inherit;">Die Destrukturierungssyntax lautet wie folgt: Wir schlie√üen die Objekteigenschaften, die wir erhalten m√∂chten, in geschweifte Klammern ({}) und, wenn es sich um ein Array handelt, in eckige Klammern ([]) ein:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> { firstName, lastName, position, yearHired } = employee
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie "propertyName: newName", um den Variablennamen zu √§ndern:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> { <span class="hljs-attr">firstName</span>: fName, <span class="hljs-attr">lastName</span>: lName, position, yearHired } = employee
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie "propertyName = 'defaultValue'", um Variablen Standardwerte zuzuweisen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> { firstName = <span class="hljs-string">'Mark'</span>, <span class="hljs-attr">lastName</span>: lName, position, yearHired } = employee
</code></pre><br>
<a name="47"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">47. Was sind Module?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Modulen k√∂nnen Sie Code aus verschiedenen Dateien kombinieren (verwenden) und m√ºssen nicht den gesamten Code in einer gro√üen Datei speichern. </font><font style="vertical-align: inherit;">Bevor Module in JS erschienen, gab es zwei beliebte Modulsysteme zur Unterst√ºtzung von Code:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CommonJS - Nodejs</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMD (AsyncronousModuleDefinition) - Browser</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Syntax der Module ist sehr einfach: Wir verwenden den Import, um Funktionen oder Werte aus einer anderen Datei oder Dateien zu importieren, und den Export, um ihn zu exportieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exportfunktionalit√§t in eine andere Datei (benannter Export):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - helpers.js</span>
exports.isNull = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span><font></font>
}<font></font>
<font></font>
exports.isUndefined = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span><font></font>
}<font></font>
<font></font>
exports.isNullOrUndefined = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> exports.isNull(val) || exports.isUndefined(val)<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNull</span>(<span class="hljs-params">val</span>)</span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUndefined</span>(<span class="hljs-params">val</span>) </span>{
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNullOrUndefined</span>(<span class="hljs-params">val</span>) </span>{
    <span class="hljs-keyword">return</span> isNull(val) || isUndefined(val);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Importieren Sie Funktionen in eine andere Datei:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - index.js</span>
<span class="hljs-keyword">const</span> helpers = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>)
<span class="hljs-keyword">const</span> isNull = helpers.isNull
<span class="hljs-keyword">const</span> isUndefined = helpers.isUndefined
<span class="hljs-keyword">const</span> isNullOrUndefined = helpers.isNullOrUndefined<font></font>
<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> { isNull, isUndefined, isNullOrUndefined } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>)<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> helpers <span class="hljs-keyword">from</span> <span class="hljs-string">'./helpers.js'</span> <span class="hljs-comment">// helpers -  </span><font></font>
<font></font>
<span class="hljs-comment">// </span>
<span class="hljs-keyword">import</span> { isNull, isUndefined, isNullOrUndefined <span class="hljs-keyword">as</span> isValid} <span class="hljs-keyword">from</span> <span class="hljs-string">'./helpers.js'</span> <span class="hljs-comment">//  "as"  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Standardexport:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - index.js</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Helpers</span> </span>{
    <span class="hljs-keyword">static</span> isNull(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isUndefined(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isNullOrUndefined(val){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNull(val) || <span class="hljs-keyword">this</span>.isUndefined(val)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">module</span>.exports = Helpers<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Helpers</span> </span>{
    <span class="hljs-keyword">static</span> isNull(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isUndefined(val){
        <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> isNullOrUndefined(val){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNull(val) || <span class="hljs-keyword">this</span>.isUndefined(val)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Helpers
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Importieren:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5 CommonJS - index.js</span>
<span class="hljs-keyword">const</span> Helpers = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>)
<span class="hljs-built_in">console</span>.log(Helpers.isNull(<span class="hljs-literal">null</span>))<font></font>
<font></font>
<span class="hljs-comment">// ES6 </span>
<span class="hljs-keyword">import</span> Helpers <span class="hljs-keyword">from</span> <span class="hljs-string">'./helpers.js'</span>
<span class="hljs-built_in">console</span>.log(Helpers.isNull(<span class="hljs-literal">null</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist die grundlegende Verwendung von Modulen. </font><font style="vertical-align: inherit;">Ich bin nicht auf Details eingegangen, weil mein Beitrag bereits zu gro√ü ist.</font></font><br>
<br>
<a name="48"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">48. Was ist ein Set-Objekt?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dem Set-Objekt k√∂nnen Sie eindeutige Werte, Grundelemente und Objektreferenzen speichern. </font><font style="vertical-align: inherit;">Noch einmal: Es k√∂nnen nur eindeutige Werte zu Set hinzugef√ºgt werden. </font><font style="vertical-align: inherit;">Es √ºberpr√ºft die darin gespeicherten Werte mit dem SameZeroValue-Algorithmus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Set-Instanz wird mit dem Set-Konstruktor erstellt. </font><font style="vertical-align: inherit;">Wir k√∂nnen ihm auch einige Werte beim Erstellen √ºbergeben:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()
<span class="hljs-keyword">const</span> set2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>]) <span class="hljs-comment">//  "d"  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen Set mit der add-Methode Werte hinzuf√ºgen. </font><font style="vertical-align: inherit;">Da die add-Methode zur√ºckgegeben werden kann, k√∂nnen wir eine Kette von Aufrufen verwenden:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.add(<span class="hljs-string">'f'</span>)<font></font>
set2.add(<span class="hljs-string">'g'</span>).add(<span class="hljs-string">'h'</span>).add(<span class="hljs-string">'i'</span>).add(<span class="hljs-string">'j'</span>).add(<span class="hljs-string">'k'</span>).add(<span class="hljs-string">'k'</span>) <span class="hljs-comment">//  "k"  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen Werte aus Set mit der L√∂schmethode l√∂schen:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.delete(<span class="hljs-string">'k'</span>) <span class="hljs-comment">// true</span>
set2.delete(<span class="hljs-string">'z'</span>) <span class="hljs-comment">// false,    set2   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen mit der Methode has nach einer Eigenschaft in Set suchen:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.has(<span class="hljs-string">'a'</span>) <span class="hljs-comment">// true</span>
set2.has(<span class="hljs-string">'z'</span>) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie die Gr√∂√üenmethode, um die L√§nge von Set zu ermitteln:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.size <span class="hljs-comment">// 10</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die L√∂schmethode l√∂scht Set:</font></font><br>
<br>
<pre><code class="javascript hljs">set2.clear() <span class="hljs-comment">// </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen Set verwenden, um doppelte Werte in einem Array zu entfernen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>]
<span class="hljs-keyword">const</span> uniqNums = [...new <span class="hljs-built_in">Set</span>(nums)] <span class="hljs-comment">// [1,2,3,4,5,6,7,8]</span>
</code></pre><br>
<a name="49"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">49. Was ist eine R√ºckruffunktion?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die R√ºckruffunktion ist eine Funktion, deren Aufruf f√ºr die Zukunft verschoben wird (tritt unter bestimmten Bedingungen auf, z. B. wenn ein Ereignis eintritt).</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> btnAdd = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btnAdd'</span>)<font></font>
<font></font>
btnAdd.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickCallback</span>(<span class="hljs-params">e</span>))</span>{
    <span class="hljs-comment">//   </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Beispiel warten wir auf ein "Klick" -Ereignis f√ºr ein Element mit der Kennung "btnAdd". </font><font style="vertical-align: inherit;">Durch Klicken wird die Funktion clickCallback aufgerufen. </font><font style="vertical-align: inherit;">Die R√ºckruffunktion f√ºgt den Daten oder Ereignissen einige Funktionen hinzu. </font><font style="vertical-align: inherit;">Den Reduzierungs-, Filter- und Zuordnungsmethoden wird als zweites Argument eine R√ºckruffunktion √ºbergeben. </font><font style="vertical-align: inherit;">Eine gute Analogie zum R√ºckruf ist die folgende Situation: Sie rufen jemanden an, er antwortet nicht, Sie hinterlassen ihm eine Nachricht und warten, bis er zur√ºckruft. </font><font style="vertical-align: inherit;">Ein Anruf oder eine Nachricht ist ein Ereignis oder Daten, und ein R√ºckruf ist die Erwartung (Antizipation) eines R√ºckrufs.</font></font><br>
<br>
<a name="50"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">50. Was sind Versprechen?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versprechen sind eine M√∂glichkeit, mit asynchronem Code in JS zu arbeiten. </font><font style="vertical-align: inherit;">Sie geben das Ergebnis einer asynchronen Operation zur√ºck. </font><font style="vertical-align: inherit;">Es wurden Versprechen erfunden, um das Problem der sogenannten H√∂lle der R√ºckruffunktionen zu l√∂sen.</font></font><br>
<br>
<pre><code class="javascript hljs">fs.readFile(<span class="hljs-string">'somefile.txt'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, data</span>)</span>{
    <span class="hljs-keyword">if</span>(e){
        <span class="hljs-built_in">console</span>.log(e)<font></font>
    }<font></font>
    <span class="hljs-built_in">console</span>.log(data)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Probleme mit diesem Ansatz beginnen, wenn wir der ersten (innerhalb der ersten), dann einer weiteren usw. eine weitere asynchrone Operation hinzuf√ºgen m√ºssen. </font><font style="vertical-align: inherit;">Als Ergebnis erhalten wir einen unordentlichen und unlesbaren Code:</font></font><br>
<br>
<pre><code class="javascript hljs">fs.readFile(<span class="hljs-string">'somefile.txt'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e,data</span>)</span>{
    <span class="hljs-comment">// </span>
    fs.readFile(<span class="hljs-string">'directory'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, files</span>)</span>{
        <span class="hljs-comment">// </span>
        fs.mkdir(<span class="hljs-string">'directory'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{
            <span class="hljs-comment">// </span><font></font>
        })<font></font>
    })<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so sieht es mit Versprechungen aus:</font></font><br>
<br>
<pre><code class="javascript hljs">promReadFile(<span class="hljs-string">'file/path'</span>)<font></font>
.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> promReaddir(<span class="hljs-string">'directory'</span>)<font></font>
})<font></font>
.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> promMkdir(<span class="hljs-string">'directory'</span>)<font></font>
})<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.error(e)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versprechen hat vier Bedingungen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten ist der Ausgangszustand eines Versprechens. </font><font style="vertical-align: inherit;">Das Ergebnis des Versprechens ist unbekannt, da der Vorgang nicht abgeschlossen ist.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertig - Asynchroner Vorgang abgeschlossen, es gibt ein Ergebnis.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abgelehnt - Asynchroner Vorgang fehlgeschlagen, es gibt einen Grund.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abgeschlossen - abgeschlossen oder abgelehnt.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Promise-Konstruktor akzeptiert das Aufl√∂sen und Ablehnen als Parameter. </font><font style="vertical-align: inherit;">Bei der Aufl√∂sung wird das Ergebnis der Operation aufgezeichnet, bei Ablehnung der Grund f√ºr den Fehler der Operation. </font><font style="vertical-align: inherit;">Das Ergebnis kann in der .then-Methode verarbeitet werden, der Fehler kann in der .catch-Methode verarbeitet werden. </font><font style="vertical-align: inherit;">Die .then-Methode gibt auch ein Versprechen zur√ºck, sodass wir eine Kette verwenden k√∂nnen, die aus mehreren .then besteht.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myPromiseAsync = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {<font></font>
        doSomeAsync(...args, (error, data) =&gt; {<font></font>
            <span class="hljs-keyword">if</span>(error){<font></font>
                reject(error)<font></font>
            } <span class="hljs-keyword">else</span>{<font></font>
                resolve(data)<font></font>
            }<font></font>
        })<font></font>
    })<font></font>
}<font></font>
<font></font>
myPromiseAsync()<font></font>
.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(result)<font></font>
})<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.error(reason)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen eine Hilfsfunktion erstellen, um eine asynchrone Operation vom R√ºckruf in ein Versprechen umzuwandeln. </font><font style="vertical-align: inherit;">Es wird wie util von Node.js funktionieren ("Promisification"):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> toPromise = <span class="hljs-function">(<span class="hljs-params">asyncFuncWithCallback</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> {<font></font>
            asyncFuncWithCallback(...args, (e, result) =&gt; {<font></font>
                <span class="hljs-keyword">return</span> e ? rej(e) : res(result)<font></font>
            })<font></font>
        })<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> promiseReadFile = toPromise(fs.readFile)<font></font>
<font></font>
promiseReadFile(<span class="hljs-string">'file/path'</span>)<font></font>
.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(data)<font></font>
})<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(e))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mehr √ºber Versprechen k√∂nnen Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="51"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">51. Was ist asynchron / warten?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Async / await ist eine relativ neue Methode zum Schreiben von asynchronem (nicht blockierendem) Code in JS. </font><font style="vertical-align: inherit;">Sie sind in ein Versprechen geh√ºllt. </font><font style="vertical-align: inherit;">Es macht Code lesbarer und sauberer als Versprechen und R√ºckruffunktionen. </font><font style="vertical-align: inherit;">Um jedoch async / await verwenden zu k√∂nnen, m√ºssen Sie die Versprechen gut kennen.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callApi</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">'url/to/api/endpoint'</span>)<font></font>
    .then(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> resp.json())<font></font>
    .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-comment">//   </span>
    }).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
        <span class="hljs-comment">//   </span><font></font>
    })<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// async/await</span>
<span class="hljs-comment">//     try/catch</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callApi</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">const</span> resp = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'url/to/api/endpoint'</span>)
        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.json()
        <span class="hljs-comment">//   </span>
    } <span class="hljs-keyword">catch</span>(e){
        <span class="hljs-comment">//   </span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie daran: Wenn Sie das Schl√ºsselwort async verwenden, bevor eine Funktion es zwingt, ein Versprechen zur√ºckzugeben:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> giveMeOne = <span class="hljs-keyword">async</span> () = <span class="hljs-number">1</span><font></font>
<font></font>
giveMeOne()<font></font>
.then(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(num) <span class="hljs-comment">// 1</span><font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Schl√ºsselwort await kann nur innerhalb einer asynchronen Funktion verwendet werden. </font><font style="vertical-align: inherit;">Die Verwendung von await in einer anderen Funktion f√ºhrt zu einem Fehler. </font><font style="vertical-align: inherit;">Warten Sie, bis der Ausdruck rechts beendet ist, um seinen Wert vor der n√§chsten Codezeile zur√ºckzugeben.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> giveMeOne = <span class="hljs-keyword">async</span>() =&gt; <span class="hljs-number">1</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOne</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">const</span> num = <span class="hljs-keyword">await</span> giveMeOne()
        <span class="hljs-built_in">console</span>.log(num)<font></font>
    } <span class="hljs-keyword">catch</span>(e){
        <span class="hljs-built_in">console</span>.log(e)<font></font>
    }<font></font>
}<font></font>
<span class="hljs-comment">// Uncaught SyntaxError: await is only valid in an async function</span><font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTwo</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">const</span> num1 = <span class="hljs-keyword">await</span> giveMeOne()
        <span class="hljs-keyword">const</span> nm2 = <span class="hljs-keyword">await</span> giveMeOne()
        <span class="hljs-keyword">return</span> num1 + num2<font></font>
    } <span class="hljs-keyword">catch</span>(e){
        <span class="hljs-built_in">console</span>.log(e)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">await</span> getTwo() <span class="hljs-comment">// 2</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lesen Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mehr √ºber async / await </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="52"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">52. Was ist der Unterschied zwischen einem Spread-Operator und einem Rest-Operator?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anweisungenpread und rest haben dieselbe Syntax ("..."). </font><font style="vertical-align: inherit;">Der Unterschied liegt in der Tatsache, dass wir mit Hilfe von Spread die Daten des Arrays √ºbertragen oder auf andere Daten verteilen und mit Hilfe von Rest alle Parameter der Funktion abrufen und in das Array einf√ºgen (oder einige der Parameter extrahieren).</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>)</span>{
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> nums = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
<span class="hljs-keyword">const</span> sum = add(...nums)
<span class="hljs-built_in">console</span>.log(sum) <span class="hljs-comment">// 11</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel verwenden wir Spread, wenn wir die Add-Funktion mit den Nums-Array-Daten aufrufen. </font><font style="vertical-align: inherit;">Der Wert der Variablen "a" ist 5, b = 6, sum = 11.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">...rest</span>)</span>{
    <span class="hljs-keyword">return</span> rest.reduce(<span class="hljs-function">(<span class="hljs-params">total, current</span>) =&gt;</span> total + current)<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// 3</span>
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment">// 15</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier rufen wir die Funktion add mit einer beliebigen Anzahl von Argumenten auf. </font><font style="vertical-align: inherit;">Add gibt die Summe dieser Argumente zur√ºck.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> [first, ...others] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-built_in">console</span>.log(first) <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.log(others) <span class="hljs-comment">// [2, 3, 4, 5]</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel verwenden wir rest, um eine beliebige Anzahl von Parametern au√üer dem ersten in das andere Array einzuf√ºgen.</font></font><br>
<br>
<a name="53"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">53. Was sind die Standardparameter?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist eine relativ neue Methode zum Definieren von Standardvariablenwerten.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>)</span>{<font></font>
    a = a || <span class="hljs-number">0</span>
    b = b || <span class="hljs-number">0</span>
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ES6</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span></span>)</span>{
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<span class="hljs-comment">//      "a"  "b" - ,    0</span>
add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen Destrukturierung verwenden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFirst</span>(<span class="hljs-params">[first, ...rest] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</span>)</span>{
    <span class="hljs-keyword">return</span> first<font></font>
}<font></font>
<font></font>
getFirst() <span class="hljs-comment">// 0</span>
getFirst([<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]) <span class="hljs-comment">// 10</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArr</span>(<span class="hljs-params">{ nums } = { nums: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] }</span>)</span>{
    <span class="hljs-keyword">return</span> nums<font></font>
}<font></font>
<font></font>
getArr <span class="hljs-comment">// [1,2,3,4]</span>
getArr({<span class="hljs-attr">nums</span>:[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]}) <span class="hljs-comment">// [5,4,3,2,1]</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen sogar die Standardparameter verwenden, die an derselben Stelle deklariert wurden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomethingWithValue</span>(<span class="hljs-params">value = <span class="hljs-string">'Hello World'</span>, callback = (</span>) =&gt; </span>{ <span class="hljs-built_in">console</span>.log(value) }){<font></font>
    callback()<font></font>
}<font></font>
doSomethingWithValue() <span class="hljs-comment">// Hello World</span>
</code></pre><br>
<a name="54"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">54. Was ist ein Objekt-Wrapper (Wrapper-Objekte)?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Grundelemente string, number und boolean haben Eigenschaften und Methoden, obwohl sie keine Objekte sind:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> name = <span class="hljs-string">'marko'</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> name) <span class="hljs-comment">// string</span>
<span class="hljs-built_in">console</span>.log(name.toUpperCase()) <span class="hljs-comment">// MARKO</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Name ist eine Zeichenfolge (primitiver Typ), die keine Eigenschaften und Methoden hat. Wenn wir jedoch die toUpperCase () -Methode aufrufen, f√ºhrt dies nicht zu einem Fehler, sondern zu ‚ÄûMARKO‚Äú. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Grund f√ºr dieses Verhalten ist, dass der Name vor√ºbergehend in ein Objekt konvertiert wird. </font><font style="vertical-align: inherit;">Jedes Grundelement au√üer null und undefiniert hat ein Wrapper-Objekt. </font><font style="vertical-align: inherit;">Solche Objekte sind String, Number, Boolean, Symbol und BigInt. </font><font style="vertical-align: inherit;">In unserem Fall hat der Code die folgende Form:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(name).toUpperCase()) <span class="hljs-comment">// MARKO</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein tempor√§res Objekt wird nach Abschluss der Arbeit mit einer Eigenschaft oder Methode verworfen.</font></font><br>
<br>
<a name="55"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">55. Was ist der Unterschied zwischen implizitem und explizitem Zwang?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implizite Konvertierung ist eine M√∂glichkeit, einen Wert ohne unser Wissen (Teilnahme) auf einen anderen Typ zu √ºbertragen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben Folgendes:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-string">'6'</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> + <span class="hljs-literal">true</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span> * <span class="hljs-string">'2'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis der ersten console.log ist 16. In anderen Sprachen w√ºrde dies zu einem Fehler f√ºhren, aber in JS 1 wird es in eine Zeichenfolge konvertiert und von 6 verkettet (angeh√§ngt). Wir haben nichts getan, die Konvertierung erfolgte automatisch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis des zweiten console.log ist 1. False wurde in 0 konvertiert, true in 1. 0 + 1 = 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis des dritten console.log ist 12. Zeile 2 wurde vor dem Multiplizieren mit 6 in eine Zahl konvertiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Explizite Konvertierung impliziert unsere Teilnahme an Umwandeln des Werts in einen anderen Typ:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'6'</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel verwenden wir parseInt, um String 6 in eine Zahl umzuwandeln, addieren dann die beiden Zahlen und erhalten 7.</font></font><br>
<br>
<a name="56"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">56. Was ist NaN? </font><font style="vertical-align: inherit;">Wie √ºberpr√ºfe ich, ob der Wert NaN ist?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NaN oder nicht Eine Zahl (keine Zahl) ist der Wert, der als Ergebnis einer numerischen Operation f√ºr einen nicht numerischen Wert erhalten wird:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> a<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'abc'</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-literal">null</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-literal">undefined</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(++a))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>({} * <span class="hljs-number">10</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'abc'</span> - <span class="hljs-number">2</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0</span> / <span class="hljs-number">0</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'10a'</span> * <span class="hljs-number">10</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JS verf√ºgt √ºber eine integrierte isNaN-Methode, mit der Sie √ºberpr√ºfen k√∂nnen, ob der Wert NaN ist, die sich jedoch recht seltsam verh√§lt:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>()) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>({})) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">String</span>(<span class="hljs-string">'a'</span>))) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { })) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis aller console.log ist wahr, obwohl keiner der Werte NaN ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ES6 empfiehlt die Verwendung der Number.isNaN-Methode, um zu √ºberpr√ºfen, ob der Wert NaN ist. </font><font style="vertical-align: inherit;">Wir k√∂nnen auch eine Hilfsfunktion schreiben, um das Problem der ‚ÄûNaN-Ungleichung f√ºr sich selbst‚Äú zu l√∂sen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkIsNan</span>(<span class="hljs-params">value</span>)</span>{
    <span class="hljs-keyword">return</span> value !== value<font></font>
}<font></font>
</code></pre><br>
<a name="57"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">57. Wie √ºberpr√ºfe ich, ob ein Wert ein Array ist?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie dazu die Array.isArray-Methode:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-number">5</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-string">''</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray()) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray( {<span class="hljs-attr">length</span>: <span class="hljs-number">5</span> })) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray([])) <span class="hljs-comment">// true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Umgebung, in der Sie arbeiten, diese Methode nicht unterst√ºtzt, k√∂nnen Sie die folgende Polydatei verwenden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">value</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(value) === <span class="hljs-string">'[object Array]'</span><font></font>
}<font></font>
</code></pre><br>
<a name="58"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">58. Wie kann man √ºberpr√ºfen, ob eine Zahl gerade ist, ohne Modulo-Division oder Division mit Rest (Operator "%") zu verwenden?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dieses Problem zu l√∂sen, k√∂nnen Sie den Operator "&amp;" (bin√§r und) verwenden. </font><font style="vertical-align: inherit;">Der Operator &amp; vergleicht Operanden als Bin√§rwerte.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEven</span>(<span class="hljs-params">num</span>)</span>{
    <span class="hljs-keyword">if</span>(num &amp; <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    } <span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 in der bin√§ren Notation ist 000 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 - dies ist 001 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 - 010 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3 - 011 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4 - 100 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5 - 101 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 - 110 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7 - 111 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
usw. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y8/zo/m2/y8zom220osynreetfh8fp-dkuog.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Console.log (5 &amp; 1) gibt 1 zur√ºck. Zuerst konvertiert der Operator &amp; beide Zahlen in Bin√§rwerte, 5 wird zu 101, 1 wird zu 001. Dann wird ein bitweiser Vergleich durchgef√ºhrt: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vy/4k/em/vy4kemefvzxgjlwdp3dmsh64ae8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergleichen Sie 1 und 0, wir erhalten 0. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergleichen Sie 0 und 0 , wir erhalten 0. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergleichen Sie 1 und 1, wir erhalten 1. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Konvertieren Sie den Bin√§rwert in eine Ganzzahl, wir erhalten 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihnen diese Informationen zu kompliziert erscheinen, k√∂nnen wir das Problem mit der rekursiven Funktion l√∂sen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEven</span>(<span class="hljs-params">num</span>)</span>{
    <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span> || num === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    <span class="hljs-keyword">return</span> isEven(num - <span class="hljs-number">2</span>)<font></font>
}<font></font>
</code></pre><br>
<a name="59"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">59. Wie kann das Vorhandensein einer Eigenschaft in einem Objekt festgestellt werden?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt drei M√∂glichkeiten, dies zu tun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste Weg ist die Verwendung des Operators in:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o = {
    <span class="hljs-string">'prop'</span>: <span class="hljs-string">'bwahahah'</span>,
    <span class="hljs-string">'prop2'</span>: <span class="hljs-string">'hweasa'</span><font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'prop'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'prop1'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite M√∂glichkeit ist die Verwendung der hasOwnProperty-Methode:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'prop2'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'prop1'</span>)) <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die dritte ist die Indexnotation des Arrays:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(o[<span class="hljs-string">'prop'</span>]) <span class="hljs-comment">// bwahahah</span>
<span class="hljs-built_in">console</span>.log(o[<span class="hljs-string">'prop1'</span>]) <span class="hljs-comment">// undefined</span>
</code></pre><br>
<a name="60"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">60. Was ist AJAX?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AJAX oder Asyncronous JavaScript and XML ist eine Reihe miteinander verbundener Technologien, mit denen Sie im asynchronen Modus mit Daten arbeiten k√∂nnen. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir Daten an den Server senden und von diesem empfangen k√∂nnen, ohne die Webseite neu zu laden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AJAX verwendet die folgenden Technologien: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTML - Webseitenstruktur. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSS - Webseitenstile. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript - Seitenverhalten und Arbeit mit dem DOM. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XMLHttpRequest API - Senden und Empfangen von Daten vom Server. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHP, Python, Nodejs - eine Art Serversprache.</font></font><br>
<br>
<a name="61"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">61. Wie erstelle ich ein Objekt in JS?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objektliteral:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> o = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Mark'</span>,<font></font>
    greeting(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
    }<font></font>
}<font></font>
<font></font>
o.greeting <span class="hljs-comment">// Hi, I'm Mark</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Konstruktorfunktion:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">this</span>.name = name<font></font>
}<font></font>
<font></font>
Person.prototype.greeting = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> mark = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Mark'</span>)<font></font>
<font></font>
mark.greeting() <span class="hljs-comment">// Hi, I'm Mark</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Object.create-Methode:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> n = {<font></font>
    greeting(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span><font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> o = <span class="hljs-built_in">Object</span>.create(n)<font></font>
<font></font>
o.name = <span class="hljs-string">'Mark'</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(o.greeting) <span class="hljs-comment">// Hi, I'm Mark</span>
</code></pre><br>
<a name="62"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">62. Was ist der Unterschied zwischen den Methoden Object.freeze und Object.seal?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Unterschied besteht darin, dass wir bei Verwendung der Object.freeze-Methode die Eigenschaften des Objekts nicht √§ndern oder bearbeiten k√∂nnen und bei Verwendung von Object.seal eine solche M√∂glichkeit haben.</font></font><br>
<br>
<a name="63"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">63. Was ist der Unterschied zwischen dem Operator in und der Methode hasOwnProperty?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Unterschied besteht darin, dass der Operator "in" nicht nur im Objekt selbst, sondern auch in seinen Prototypen und der Methode hasOwnProperty - nur im Objekt - nach dem Vorhandensein einer Eigenschaft sucht.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'prop'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'toString'</span> <span class="hljs-keyword">in</span> o) <span class="hljs-comment">// true</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'prop'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(o.hasOwnProperty(<span class="hljs-string">'toString'</span>)) <span class="hljs-comment">// false</span>
</code></pre><br>
<a name="64"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64. Welche Techniken zum Arbeiten mit asynchronem Code in JS kennen Sie?</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºckrufe</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versprechen Versprechen).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async / warten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliotheken wie async.js, blueprint, q, co.</font></font></li>
</ul><br>
<a name="65"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65. Was ist der Unterschied zwischen einer normalen Funktion und einem funktionalen Ausdruck?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir haben Folgendes:</font></font><br>
<br>
<pre><code class="javascript hljs">hoistedFunc()<font></font>
notHoistedFunc()<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hoistedFunc</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I am hoisted'</span>)<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> notHoistedFunc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I will not be hoisted!'</span>)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Aufruf von notHoistedFunc f√ºhrt zu einem Fehler, ein Aufruf von hoistedFunc jedoch nicht, da hoistedFunc "auftaucht" und in den globalen Bereich aufsteigt, notHoistedFunc jedoch nicht.</font></font><br>
<br>
<a name="66"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">66. Wie rufe ich eine Funktion in JS auf?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In JS gibt es vier M√∂glichkeiten, eine Funktion aufzurufen. </font><font style="vertical-align: inherit;">Der Aufruf definiert den Wert dieser oder des "Eigent√ºmers" der Funktion. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufruf als Funktion. </font><font style="vertical-align: inherit;">Wenn eine Funktion als Methode, Konstruktor oder unter Verwendung der Apply- oder Call-Methoden aufgerufen wird, wird sie als Funktion aufgerufen. </font><font style="vertical-align: inherit;">Der Eigent√ºmer einer solchen Funktion ist das Fensterobjekt:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)
    <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
<font></font>
add(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">// window, 6</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> o = {<font></font>
    method(callback){<font></font>
        callback()<font></font>
    }<font></font>
}<font></font>
<font></font>
o.method(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>) <span class="hljs-comment">// window</span><font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufruf als Methode. </font><font style="vertical-align: inherit;">Wenn eine Funktion eine Eigenschaft eines Objekts ist, nennen wir sie eine Methode. </font><font style="vertical-align: inherit;">Wenn eine Methode aufgerufen wird, wird dieses Objekt zum Objekt dieser Methode:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> details = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Marko'</span>,<font></font>
    getName(){<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name<font></font>
    }<font></font>
}<font></font>
<font></font>
details.getName() <span class="hljs-comment">// Marko,  this   details</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufruf als Konstruktor. </font><font style="vertical-align: inherit;">Wenn eine Funktion mit dem Schl√ºsselwort "new" aufgerufen wird, nennen wir diese Funktion einen Konstruktor. </font><font style="vertical-align: inherit;">Dadurch wird ein leeres Objekt erstellt, dessen Wert Folgendes ist:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">name, position, yearHired</span>)</span>{
    <span class="hljs-comment">//   ,   this</span>
    <span class="hljs-comment">// this = {}</span>
    <span class="hljs-keyword">this</span>.name = name
    <span class="hljs-keyword">this</span>.position = position
    <span class="hljs-keyword">this</span>.yearHired = yearHired
    <span class="hljs-comment">//   Employee.prototype   this,    </span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> emp = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">'Marko Polo'</span>, <span class="hljs-string">'Software Development'</span>, <span class="hljs-number">2017</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Aufruf mit den Methoden apply oder call. </font><font style="vertical-align: inherit;">Wir verwenden diese Methoden, wenn wir den Wert dieser oder des Eigent√ºmers einer Funktion explizit bestimmen m√∂chten:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj1 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> obj2 = {
    <span class="hljs-attr">result</span>: <span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduceAdd</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++){<font></font>
        result += <span class="hljs-built_in">arguments</span>[i]<font></font>
    }<font></font>
    <span class="hljs-keyword">this</span>.result = result<font></font>
}<font></font>
<font></font>
reduceAdd.apply(obj1, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]) <span class="hljs-comment">//  this  obj1</span>
reduceAdd.call(obj2, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">//  this  obj2</span>
</code></pre><br>
<a name="67"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">67. Was ist Auswendiglernen oder Auswendiglernen?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memoization ist die Technik zum Erstellen einer Funktion, die sich zuvor berechnete Ergebnisse oder Werte merken kann. </font><font style="vertical-align: inherit;">Der Vorteil der Memoisierung besteht darin, dass wir vermeiden, eine Funktion mit denselben Argumenten erneut auszuf√ºhren. </font><font style="vertical-align: inherit;">Der Nachteil ist, dass wir gezwungen sind, zus√§tzlichen Speicher zuzuweisen, um die Ergebnisse zu speichern.</font></font><br>
<br>
<a name="68"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68. Wie w√ºrden Sie die Hilfsfunktion des Auswendiglernen implementieren?</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span>(<span class="hljs-params">fn</span>)</span>{
    <span class="hljs-keyword">const</span> cache = {}
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">param</span>)</span>{
        <span class="hljs-keyword">if</span>(cache[param]){
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'cached'</span>)
            <span class="hljs-keyword">return</span> cache[param]<font></font>
        } <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">let</span> result = fn(param)<font></font>
            cache[param] = result<font></font>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'not cached'</span>)
            <span class="hljs-keyword">return</span> result<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> toUpper = <span class="hljs-function">(<span class="hljs-params">str = <span class="hljs-string">''</span></span>) =&gt;</span> str.toUpperCase()<font></font>
<font></font>
<span class="hljs-keyword">const</span> toUpperMemoized = memoize(toUpper)<font></font>
<font></font>
toUpperMemoized(<span class="hljs-string">'abcdef'</span>)<font></font>
toUpperMemoized(<span class="hljs-string">'abcdef'</span>) <span class="hljs-comment">//  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben die Memoization-Funktion mit einem Argument implementiert. </font><font style="vertical-align: inherit;">Machen wir es "Multi-Argument":</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> slice = <span class="hljs-built_in">Array</span>.prototype.slice
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span>(<span class="hljs-params">fn</span>)</span>{
    <span class="hljs-keyword">const</span> cache = {}
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> params = slice.call(args)
        <span class="hljs-built_in">console</span>.log(params)
        <span class="hljs-keyword">if</span>(cache[params]){
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'cached'</span>)
            <span class="hljs-keyword">return</span> cache[params]<font></font>
        } <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">let</span> result = fn(...args)<font></font>
            cache[params] = result<font></font>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'not cached'</span>)
            <span class="hljs-keyword">return</span> result<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<span class="hljs-keyword">const</span> makeFullName = <span class="hljs-function">(<span class="hljs-params">fName, lName</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${fName}</span> <span class="hljs-subst">${lName}</span>`</span>
<span class="hljs-keyword">const</span> reduceAdd = <span class="hljs-function">(<span class="hljs-params">numbers, startValue = <span class="hljs-number">0</span></span>) =&gt;</span> numbers.reduce(<span class="hljs-function">(<span class="hljs-params">total, cur</span>) =&gt;</span> total + cur, startValue)<font></font>
<font></font>
<span class="hljs-keyword">const</span> memoizedFullName = memoize(makeFullName)
<span class="hljs-keyword">const</span> memoizeReduceAdd = memoize(reduceAdd)<font></font>
<font></font>
memoizedFullName(<span class="hljs-string">'Marko'</span>, <span class="hljs-string">'Polo'</span>)<font></font>
memoizedFullName(<span class="hljs-string">'Marko'</span>, <span class="hljs-string">'Polo'</span>) <span class="hljs-comment">//  </span><font></font>
<font></font>
memoizeReduceAdd([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<span class="hljs-number">5</span>)<font></font>
memoizeReduceAdd([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<span class="hljs-number">5</span>) <span class="hljs-comment">//  </span>
</code></pre><br>
<a name="69"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69. Warum gibt typeof null ein Objekt zur√ºck? </font><font style="vertical-align: inherit;">Wie √ºberpr√ºfe ich, ob ein Wert null ist?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
typeof null == 'object' gibt aus historischen Gr√ºnden immer true zur√ºck. </font><font style="vertical-align: inherit;">Es gab einen Vorschlag, diesen Fehler durch √Ñndern von typeof null = 'object' in typeof null = 'null' zu beheben, der jedoch im Interesse der Aufrechterhaltung der Abw√§rtskompatibilit√§t abgelehnt wurde (eine solche √Ñnderung w√ºrde eine gro√üe Anzahl von Fehlern mit sich bringen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu √ºberpr√ºfen, ob der Wert null ist, k√∂nnen Sie den strengen Gleichheitsoperator (===) verwenden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNull</span>(<span class="hljs-params">value</span>)</span>{
    <span class="hljs-keyword">return</span> value === <span class="hljs-literal">null</span><font></font>
}<font></font>
</code></pre><br>
<a name="70"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70. Wof√ºr wird das Schl√ºsselwort "neu" verwendet?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Schl√ºsselwort "new" wird in Konstruktorfunktionen verwendet, um ein neues Objekt (eine neue Instanz der Klasse) zu erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir haben einen Code wie diesen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">name, position, yearHired</span>)</span>{
    <span class="hljs-keyword">this</span>.name = name
    <span class="hljs-keyword">this</span>.position = position
    <span class="hljs-keyword">this</span>.yearHired = yearHired<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> emp = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">'Marko Polo'</span>, <span class="hljs-string">'Software Development'</span>, <span class="hljs-number">2017</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Schl√ºsselwort "neu" macht 4 Dinge:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellt ein leeres Objekt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bindet diesen Wert daran.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Funktion erbt von functionName.prototype.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt dies zur√ºck, sofern nicht anders angegeben.</font></font></li>
</ol></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de486820/">https://habr.com/ru/post/de486820/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de486804/index.html">Globale Gesundheitsinformatik: Cloud-Technologien</a></li>
<li><a href="../de486808/index.html">Elektronischer Schwangerschaftstest aus einer Apotheke: wie es funktioniert</a></li>
<li><a href="../de486810/index.html">Neues Odnoklassniki-Frontend: React in Java starten. Teil II</a></li>
<li><a href="../de486814/index.html">Zabbix: Die Netzwerktopologie ist klar und automatisch</a></li>
<li><a href="../de486818/index.html">Portierung von Quake auf den iPod Classic</a></li>
<li><a href="../de486822/index.html">[An den Docks] Flattern. Teil 4. F√ºr Webentwickler</a></li>
<li><a href="../de486824/index.html">Schlechter Rat bei der Arbeit mit ANTLR</a></li>
<li><a href="../de486826/index.html">Erstellen eines vollwertigen Viberbot auf Django 2 und der Viber REST-API. Erster Teil - Webhook</a></li>
<li><a href="../de486828/index.html">Food Design Digest, Januar 2020</a></li>
<li><a href="../de486832/index.html">Wie viele Jahre Taiga vergehen - verstehe nein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>