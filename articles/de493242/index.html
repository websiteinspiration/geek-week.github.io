<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚¨õÔ∏è üóúÔ∏è üöæ Schnelle Verarbeitungsalgorithmen f√ºr HTTP-Zeichenfolgen üôÖüèº ‚õπüèæ ü§∑üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Komprimierung von Standardheadern wurde in HTTP / 2 angezeigt, aber der Hauptteil der URI-, Cookie- und User-Agent-Werte kann immer noch mehrere z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Schnelle Verarbeitungsalgorithmen f√ºr HTTP-Zeichenfolgen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/493242/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Komprimierung von Standardheadern wurde in HTTP / 2 angezeigt, aber der Hauptteil der URI-, Cookie- und User-Agent-Werte kann immer noch mehrere zehn Kilobyte betragen und erfordert Tokenisierung, Suche und Vergleich von Teilzeichenfolgen. </font><font style="vertical-align: inherit;">Die Aufgabe wird kritisch, wenn ein HTTP-Parser starken b√∂swilligen Datenverkehr verarbeiten muss. </font><font style="vertical-align: inherit;">Standardbibliotheken bieten umfangreiche Tools zur Verarbeitung von Zeichenfolgen, HTTP-Zeichenfolgen haben jedoch ihre eigenen Besonderheiten. </font><font style="vertical-align: inherit;">Aus diesem Grund wurde der HTTP-Parser Tempesta FW entwickelt. </font><font style="vertical-align: inherit;">Die Leistung ist im Vergleich zu modernen Open Source-L√∂sungen um ein Vielfaches h√∂her und √ºbertrifft die schnellste.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GcAJF4648JI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Krizhanovsky</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">krizhanovsky</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Gr√ºnder und Systemarchitekt Tempesta Technologies, Experte f√ºr Hochleistungsrechnen unter Linux / x86-64. Alexander wird √ºber die Besonderheiten der Struktur von HTTP-Strings sprechen, erkl√§ren, warum Standardbibliotheken f√ºr deren Verarbeitung schlecht geeignet sind, und die Tempesta FW-L√∂sung vorstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter der Katze: Wie verwandelt HTTP Flood Ihren HTTP-Parser in einen Engpass, x86-64-Probleme mit Verzweigungsfehlvorhersagen, Caching und Speichermangel bei typischen HTTP-Parser-Aufgaben, Vergleich von FSM mit direkten Spr√ºngen, GCC-Optimierung, Auto-Vektorisierung, strspn () - und strcasecmp () - √§hnliche Algorithmen f√ºr HTTP-Strings, SSE, AVX2 und Filterinjektionsangriffe mit AVX2.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Tempesta Technologies entwickeln wir kundenspezifische Software: Wir sind auf komplexe Bereiche im Zusammenhang mit hoher Leistung spezialisiert. </font><font style="vertical-align: inherit;">Wir sind besonders stolz auf die Entwicklung des Kerns der ersten Version von WAF von Positive Technologies. </font><font style="vertical-align: inherit;">Die Web Application Firewall (WAF) ist ein HTTP-Proxy: Sie befasst sich mit einer sehr gr√ºndlichen Analyse des HTTP-Verkehrs auf Angriffe (Web und DDoS). </font><font style="vertical-align: inherit;">Wir haben den ersten Kern daf√ºr geschrieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zus√§tzlich zur Beratung entwickeln wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta FW</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - dies ist Application Delivery Controller (ADC). </font><font style="vertical-align: inherit;">Wir werden √ºber ihn sprechen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application Delivery Controller</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Application Delivery Controller ist ein HTTP-Proxy mit erweiterten Funktionen. </font><font style="vertical-align: inherit;">Ich werde jedoch √ºber eine Funktion sprechen, die sich auf die Sicherheit bezieht - √ºber das Filtern von DDoS- und Web-Angriffen. </font><font style="vertical-align: inherit;">Ich werde auch die Einschr√§nkungen erw√§hnen und die Arbeit und Funktionen anhand von Codebeispielen zeigen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mg/gf/tw/mggftw9mux_ycaxzjbfqe6hpdc0.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempesta FW ist in den Linux TCP / IP Stack-Kernel integriert. </font><font style="vertical-align: inherit;">Dank dieser und einer Reihe anderer Optimierungen ist es sehr schnell - es kann 1,8 Millionen Anfragen pro Sekunde auf billiger Hardware verarbeiten. </font><font style="vertical-align: inherit;">Dies ist dreimal schneller als Nginx bei der h√∂chsten Last und auch im Vergleich zum </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kernel-Bypass-Ansatz</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schnell </font><strong><font style="vertical-align: inherit;">. </font></strong></font><br>
<br>
<img src="https://habrastorage.org/webt/te/md/pe/temdpec1gcgnm98ktgwr4gewn-8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf einer kleinen Anzahl von Kernen zeigt es eine √§hnliche Leistung wie das Seastar-Projekt, das in ScyllaDB (geschrieben in DPDK) verwendet wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problem</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Projekt wurde geboren, als wir 2013 mit der Arbeit an PT AF begannen. </font><font style="vertical-align: inherit;">Diese WAF basierte auf einem beliebten Open Source HTTP-Beschleuniger. </font><font style="vertical-align: inherit;">Nginx-, HAProxy-, Varnish- oder Apache-Verkehr sind gute HTTP-Beschleuniger: Sie liefern Inhalte in Ordnung, zwischenspeichern und √§ndern, aber keiner von ihnen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist f√ºr die Verarbeitung und Filterung von massivem Verkehr ausgelegt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher dachten wir, wenn es eine Firewall auf Netzwerkebene gibt, warum nicht diese Idee fortsetzen und als Firewall auf Anwendungsebene in den TCP / IP-Stack integrieren? </font><font style="vertical-align: inherit;">Tats√§chlich stellte sich heraus, dass Tempesta FW - eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mischung aus HTTP-Beschleuniger und Firewall</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Nginx wird als Beispiel im Bericht verwendet, da es sich um einen einfachen und beliebten Webserver handelt. </font><font style="vertical-align: inherit;">Stattdessen k√∂nnte es einen anderen Open Source HTTP-Server geben.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns unsere </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP-Anfrage an</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (HTTP / (1, ~ 2)). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_o/3z/tq/_o3ztqvtwrv-7epdryhdztg8wsq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen einen sehr gro√üen URI haben. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trennzeichen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die zum Zeitpunkt der HTTP-Analyse wichtig sind, sind </font><font style="vertical-align: inherit;">rot hervorgehoben </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich werde die Merkmale hervorheben: gro√üe Zeichenfolgen von mehreren Kilobyte sowie verschiedene Trennzeichen, zum Beispiel zus√§tzliche "Semikolons", die wir analysieren m√ºssen, oder die Sequenz "\ r \ n". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein bisschen √ºber HTTP / 2 muss auch gesagt werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2-Funktionen</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2 ist eine Mischung aus Zeichenfolgen und Bin√§rdaten</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Bei dieser Mischung geht es mehr um die Optimierung der Bandbreite einer Verbindung als um die Einsparung von Serverressourcen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2 in HPACK verwendet eine dynamische Tabelle</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die erste Anforderung vom Client ist nicht optimiert, sie befindet sich nicht in der Tabelle. Sie m√ºssen es analysieren, damit es der Tabelle hinzugef√ºgt wird. Wenn HTTP / 2 DDoS zu Ihnen kommt, ist dies genau der Fall. Im Normalfall ist HTTP / 2 ein Bin√§rprotokoll, Sie m√ºssen jedoch noch Text analysieren: Namen der Textheader, Daten. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman-Codierung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist eine einfache Codierung, aber Huffman ist f√ºr die Komprimierung unglaublich schwer schnell zu programmieren: Die Huffman-Codierung √ºberschreitet die Bytegrenze, Sie k√∂nnen keine Vektorerweiterungen verwenden und m√ºssen nach Bytes gehen. </font><font style="vertical-align: inherit;">Sie k√∂nnen Daten in 32 oder 16 Byte nicht schnell verarbeiten. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cookies, User-Agent, Referer, URIs k√∂nnen sehr gro√ü sein</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Entfernen Sie zuerst Huffman und senden Sie es dann an einen regul√§ren HTTP-Parser, genau wie in HTTP / 1. </font><font style="vertical-align: inherit;">Obwohl dies vom RFC zugelassen wird, wird nicht empfohlen, Cookies zu komprimieren, da es sich um vertrauliche Daten handelt. Sie sollten dem Angreifer keine Informationen √ºber deren Gr√∂√üe geben. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langsame HTTP-Verarbeitung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Alle HTTP-Server dekodieren zuerst HTTP / 2 und senden diese Zeilen dann an den HTTP / 1-Parser, den HTTP / 1 bereits verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist das Problem beim HTTP / 1-Parsing?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie m√ºssen die Zustandsmaschine schnell programmieren.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie m√ºssen schnell aufeinanderfolgende Zeilen verarbeiten.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
B√∂sartiger Datenverkehr zielt auf den langsamsten (schw√§chsten) Teil des Prozesses ab. </font><font style="vertical-align: inherit;">Wenn wir also einen Filter herstellen m√∂chten, m√ºssen wir auf die langsamen Teile achten, damit sie auch schnell funktionieren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx-Profil</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns das Nginx-Profil unter der HTTP-Flut an. </font><font style="vertical-align: inherit;">Deaktivieren Sie das Zugriffsprotokoll, damit das Dateisystem nicht langsamer wird. </font><font style="vertical-align: inherit;">Wenn sogar eine regul√§re Indexseite angefordert wird, wird der Parser oben angezeigt.</font></font><br>
<div class="scrollable-table"><table>
<tbody>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">%.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbolname</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,5719</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_http_parse_header_line</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.0303</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_vslprintf</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,6401</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5807</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recv</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5156</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_linux_sendfile_chain</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,4990</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_http_limit_req_handler</font></font></td>
</tr>
</tbody>
</table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links - "Flaches Profil". </font><font style="vertical-align: inherit;">Interessanterweise ist die hei√üeste Stelle nicht viel schwerer als die n√§chste, und danach f√§llt das Profil sanft ab. </font><font style="vertical-align: inherit;">Dies bedeutet zum Beispiel, dass eine zweimalige Optimierung der ersten Funktion nicht dazu beitr√§gt, die Leistung signifikant zu verbessern. </font><font style="vertical-align: inherit;">Aus diesem Grund haben wir nicht denselben Nginx optimiert, sondern ein neues Projekt erstellt, das die Leistung des gesamten Endes des Profils verbessert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie regul√§re HTTP-Parser codiert werden</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Normalerweise haben wir eine Schleife ( </font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), die entlang der Linie verl√§uft, und zwei Variablen: state ( </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) und current data ( </font></font><code>str_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir treten in den Zyklus (1) ein und betrachten den aktuellen Zustand (Pr√ºfzustand). Wir gehen zu den empfangenen Daten (Symbol </font></font><code><em>'b'</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) √ºber</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und implementieren eine Logik. Wir gehen zum zweiten Zustand √ºber (2). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hi/z7/s2/hiz7s2e3yw5bpqqz-qbir5hbteq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gehen Sie zum Ende </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3) - dies ist der zweite √úbergang relativ zum Anfang unseres Codes und m√∂glicherweise der zweite Fehler im Anweisungscache. Dann gehen wir zum Anfang </font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4), essen das n√§chste Zeichen ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gk/zs/17/gkzs17hdxtyfcaife8j1pms7wbi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... und suchen erneut nach dem Zustand in den Anweisungen darin </font></font><code>case 2:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn einer Variablen bereits ein </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert </font><font style="vertical-align: inherit;">zugewiesen wurde</font></font><code>2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnten einfach zur n√§chsten Anweisung gehen. </font><font style="vertical-align: inherit;">Aber stattdessen gingen sie wieder hoch und wieder runter. </font><font style="vertical-align: inherit;">Wir ‚Äûschneiden Kreise‚Äú nach Code, anstatt nur nach unten zu gehen. </font><font style="vertical-align: inherit;">Normale Parser generieren beispielsweise keinen Parser mit direkten √úberg√§ngen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mc/ba/3w/mcba3wgxqkflqjvq1mxytcy_kwo.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx HTTP Parser</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein paar Worte zum Nginx-Parser und seiner Umgebung. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx arbeitet mit der normalen Socket-API</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - die Daten, die an den Adapter gesendet werden, werden in den Benutzerbereich kopiert. </font><font style="vertical-align: inherit;">Als Ergebnis haben wir einen gro√üen Datenblock, in dem wir nach dem suchen, was wir brauchen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx verwendet einen Algorithmus, der in zwei Durchg√§ngen funktioniert: Zuerst wird nach der L√§nge gesucht, dann wird gepr√ºft. </font><font style="vertical-align: inherit;">Im ersten Schritt durchsucht er die Zeichenfolge nach Token und sucht nach dem ersten Token (‚ÄûTest‚Äú). </font><font style="vertical-align: inherit;">Beim zweiten Token wird das Ende der Anforderung ( </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">√ºberpr√ºft </font><font style="vertical-align: inherit;">und </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entsprechend der Gr√∂√üe des Tokens gestartet.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (p = b-&gt;pos; p &lt; b-&gt;last; p++) {<font></font>
    ...<font></font>
    <span class="hljs-keyword">switch</span> (state) {<font></font>
    ...<font></font>
    <span class="hljs-keyword">case</span> sw_method:
        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">' '</span>) {<font></font>
            m = r-&gt;request_start;<font></font>
            <span class="hljs-keyword">switch</span> (p - m) {         <span class="hljs-comment">// switch on token length!</span>
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                <span class="hljs-keyword">if</span> (ngx_str3_cmp(m, <span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>)) {<font></font>
                ...<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> ((ch &lt; <span class="hljs-string">'A'</span> || ch &gt; <span class="hljs-string">'Z'</span>) &amp;&amp; ch != <span class="hljs-string">'_'</span> &amp;&amp; ch != <span class="hljs-string">'-'</span>)
                <span class="hljs-keyword">return</span> NGX_HTTP_PARSE_INVALID_METHOD;
            <span class="hljs-keyword">break</span>;<font></font>
    ...</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Get" befindet sich immer im selben Datenblock</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tempesta FW arbeitet mit Nullkopie. </font><font style="vertical-align: inherit;">Dies bedeutet, dass Daten eine v√∂llig beliebige Gr√∂√üe haben k√∂nnen: jeweils 1 Byte oder 1000 Byte. </font><font style="vertical-align: inherit;">Dieser "Mechanismus" passt nicht zu uns. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie es </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in GCC </font><font style="vertical-align: inherit;">funktioniert </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gcc</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachschlagetabelle</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Links sehen Sie ein typisches Beispiel f√ºr eine Aufz√§hlung: Beginnen Sie mit 0, dann mit aufeinanderfolgenden Beschriftungen, 26 Konstanten und dann mit Code, der alles verarbeitet. Rechts ist der Code, den der Compiler generiert. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ac/1n/hh/ac1nhhz9jqe87hdqb6bxfv541vu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergleichen Sie zun√§chst die Variable </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im EAX-Register mit einer Konstanten. Als n√§chstes pr√§sentieren wir alle Beschriftungen in Form eines sequentiellen Arrays von Zeigern mit 8 Bytes (Nachschlagetabelle). Bei dieser Anweisung geben wir den Offset in diesem Array weiter - es handelt sich um eine doppelte Dereferenzierung von Zeigern. Unten rechts befindet sich der Code, zu dem wir aus dieser Tabelle gewechselt haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich eine doppelte Dereferenzierung des Speichers heraus: Wenn wir geheime Daten empfangen haben, finden wir durch Bytes die Adresse im Array und gehen zu diesem Zeiger. Es ist wichtig zu wissen, dass es im Leben immer noch schlimmer ist als im Beispiel - f√ºr die Nachschlagetabelle </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">generiert</font></a><font style="vertical-align: inherit;"> der Compiler</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Code ist im Fall eines </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skripts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr einen Spectre-Angriff </font><font style="vertical-align: inherit;">komplizierter </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bin√§re Suche</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Der n√§chste Fall betrifft </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht sequentielle Konstanten, sondern beliebige. Der Code ist der gleiche, aber jetzt kann GCC kein so gro√ües Array kompilieren und Konstanten als Index des Arrays verwenden. Er wechselt zur bin√§ren Suche. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/as/mo/7p/asmo7pb4lxsv7pchnafv-qjz7u4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rechts sehen wir einen sequentiellen Vergleich, den √úbergang zur Adresse und die Fortsetzung des Vergleichs - die bin√§re Suche erfolgt nach Code. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx HTTP-Parser.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mal sehen, was State Machine Nginx ist. Es verf√ºgt √ºber 9 Kilobyte Code - dies ist dreimal weniger als der Cache der ersten Ebene auf dem Computer, auf dem die Benchmarks gestartet wurden (wie bei den meisten x86-64-Prozessoren).</font></font><br>
<br>
<pre><code class="bash hljs">$ nm -S /opt/nginx-1.11.5/sbin/nginx<font></font>
| grep http_parse | cut -d<span class="hljs-string">' '</span> -f 2<font></font>
| perl -le <span class="hljs-string">'$a += hex($_) while (&lt;&gt;); print $a'</span><font></font>
9220<font></font>
<font></font>
$ getconf LEVEL1_ICACHE_SIZE<font></font>
32768<font></font>
<font></font>
$ grep -c <span class="hljs-string">'case sw_'</span> src/http/ngx_http_parse.c<font></font>
84</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Nginx-Header-Parser </font></font><code>ngx_http_parse_header_line ()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist ein einfacher Tokenizer. </font><font style="vertical-align: inherit;">Es macht nichts mit den Werten der Header und ihren Namen, sondern setzt einfach die Token der HTTP-Header in einen Hash. </font><font style="vertical-align: inherit;">Wenn Sie einen Header-Wert ben√∂tigen, scannen Sie die Header-Tabelle und wiederholen Sie die Analyse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir m√ºssen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Namen und Werte der Header</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus Sicherheitsgr√ºnden </font><strong><font style="vertical-align: inherit;">streng √ºberpr√ºfen </font></strong></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></strong><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta FW: String-Validierung von HTTP-Strings</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere Zustandsmaschine ist um eine Gr√∂√üenordnung leistungsf√§higer: Wir f√ºhren eine RFC-Header-Validierung durch und verarbeiten im Parser sofort fast alles. </font><font style="vertical-align: inherit;">Wenn Nginx 80 Zust√§nde hat, dann haben wir 520, und es gibt mehr davon. </font><font style="vertical-align: inherit;">Wenn wir weiterfahren </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w√ºrden, w√§re es zehnmal gr√∂√üer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zero-Copy-E / A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Bl√∂cke unterschiedlicher Gr√∂√üe k√∂nnen Daten an verschiedenen Stellen schneiden. </font><font style="vertical-align: inherit;">Verschiedene Chunks k√∂nnen unsere Daten schneiden. </font><font style="vertical-align: inherit;">In E / A mit Nullkopie kann "GET" beispielsweise (selten) als "GET", "GE" und "T" oder "G", "E" und "T" auftreten, sodass Sie den Status zwischen Datenelementen speichern m√ºssen . </font><font style="vertical-align: inherit;">Wir entfernen praktisch die Kosten f√ºr E / A, aber im Profil fliegt es hoch - alles ist schlecht. </font><font style="vertical-align: inherit;">Der gro√üe HTTP-Parser ist einer der kritischsten Stellen im Projekt.</font></font><br>
<br>
<pre><code class="bash hljs">$ grep -c <span class="hljs-string">'__FSM_STATE\|__FSM_TX\|__FSM_METH_MOVE\|__TFW_HTTP_PARSE_'</span> http_parser.c<font></font>
520<font></font>
    7.64% [tempesta_fw]     [k] tfw_http_parse_req<font></font>
    2.79% [e1000]           [k] e1000_xmit_frame<font></font>
    2.32% [tempesta_fw]     [k] __tfw_strspn_simd<font></font>
    2.31% [tempesta_fw]     [k] __tfw_http_msg_add_str_data<font></font>
    1.60% [tempesta_fw]     [k] __new_pgfrag<font></font>
    1.58% [kernel]          [k] skb_release_data<font></font>
    1.55% [tempesta_fw]     [k] __str_grow_tree<font></font>
    1.41% [kernel]          [k] __inet_lookup_established<font></font>
    1.35% [tempesta_fw]     [k] tfw_cache_do_action<font></font>
    1.35% [tempesta_fw]     [k] __tfw_strcmpspn</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was tun, um diese Situation zu verbessern?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSM Direct Referrals</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als erstes verwenden wir keine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schleife, sondern direkte √úberg√§nge durch Labels ( </font></font></strong><code>go to</code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Normale Parser-Generatoren wie Ragel tun dies. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bq/di/pr/bqdipr9bt6au4ifisfpvjli2p_e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir codieren jeden unserer Zust√§nde mit einem Label in </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und einem Label in C mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demselben Namen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jedes Mal, wenn wir gehen m√∂chten, finden wir eine Beschriftung in </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder greifen direkt √ºber den Code auf denselben Status zu. Das erste Mal, wenn wir durchgehen </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und dann drinnen gehen wir direkt zum gew√ºnschten Etikett. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachteil</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Wenn wir in den n√§chsten Status wechseln m√∂chten, m√ºssen wir sofort bewerten, ob noch Daten verf√ºgbar sind (da keine E / A-Kopien vorhanden sind). Zustand K√∂rper</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird in jeden Zustand kopiert: Anstelle einer Bedingung in einem regul√§ren schaltergesteuerten FSM haben wir 500 davon entsprechend der Anzahl der Zust√§nde. Das Generieren von Code f√ºr jeden Status ist nicht gro√üartig. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei gro√üen Zustandsautomaten </font><font style="vertical-align: inherit;">wiederholt die AGB </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bei einem gro√üen </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Innenraum die Bedingung auch </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mehrmals im Code. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch </font></font></strong><code><strong>switch</strong></code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direkte √úberg√§nge </font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">ersetzen </font></strong><strong><font style="vertical-align: inherit;">.</font></strong><font style="vertical-align: inherit;"> Die n√§chste Optimierung besteht darin, dass wir es nicht verwenden </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und zu direkten Spr√ºngen zu den gespeicherten Meta-Adressen wechseln. Wir wollen sofort zum gew√ºnschten Punkt gehen, sobald wir die Funktion betreten. Mit GCC k√∂nnen Sie dies tun. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/i3/x5/7m/i3x57mb0tahhz99szccnfdbxde0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GCC hat eine Standarderweiterung, die helfen kann. Wir nehmen den Markennamen (hier ist er </font></font><code>from</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) und weisen seine Adresse einer C-Variablen √ºber ein doppeltes kaufm√§nnisches Und (&amp;&amp;) zu. Jetzt k√∂nnen wir eine direkte Sprunganweisung machen</font></font><code>jmp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an die Adresse dieses Etiketts mit </font></font><code>goto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, was daraus wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direkte Konvertierungsleistung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einer kleinen Anzahl von Zust√§nden ist der Generator f√ºr den direkten √úbergangscode sogar etwas langsamer als normal </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bei gro√üen Zustandsautomaten verdoppelt sich jedoch die Produktivit√§t. </font><font style="vertical-align: inherit;">Wenn die Zustandsmaschine klein ist, ist es besser, die √ºbliche zu verwenden </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="bash hljs">$ grep -m 2 <span class="hljs-string">'model name\|bugs'</span> /proc/cpuinfo<font></font>
model name : Intel(R) Core(TM) i7-6500U CPU @ 2.50GHz<font></font>
bugs       : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf<font></font>
<font></font>
$ gcc --version|head -1<font></font>
gcc (GCC) 8.2.1 20181105 (Red Hat 8.2.1-5)<font></font>
<font></font>
States     Switch-driven automaton     Goto-driven automaton<font></font>
     7     header_line:      139ms     header_line:          156ms<font></font>
    27     request_line:     210ms     request_line:         186ms<font></font>
   406     big_header_line: 1406ms     goto_big_header_line: 727ms</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Tempesta-Code ist komplizierter als die Beispiele. </font><font style="vertical-align: inherit;">GitHub hat alle </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/tempesta-tech/blog/tree/master/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmarks,</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> so dass Sie alles im Detail sehen k√∂nnen. </font><font style="vertical-align: inherit;">Der urspr√ºngliche Parser-Code ist </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unter dem Link</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Haupt-HTTP-Parser) </font></font></em><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">verf√ºgbar </font></em><em><font style="vertical-align: inherit;">. </font></em><em><font style="vertical-align: inherit;">Dar√ºber hinaus gibt es in Tempesta FW </font></em></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kleinere Parser</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die FSM einfacher verwenden.</font></font></em><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum direkte √úberg√§nge langsamer sein k√∂nnen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Zustandsmaschine durchlaufen wir viel Code, so dass (erwartet) viele Fehlvorhersagen f√ºr Zweige auftreten werden. </font><font style="vertical-align: inherit;">Lassen Sie uns ein "Profiling" gem√§√ü der Vorhersage von Verzweigungsfehlern durchf√ºhren:</font></font><br>
<br>
<pre><code class="bash hljs">perf record -e branch-misses -g ./http_benchmark<font></font>
406 states:    switch       - 38% on switch(),<font></font>
               direct jumps - 13% on header value parsing<font></font>
			   <font></font>
7,27 states:   switch       - &lt;18% switch(), up to 40% <span class="hljs-keyword">for</span>()<font></font>
               direct jumps ‚Äì up to 46% on header &amp; URI parsing</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf einer gro√üen Zustandsmaschine mit 406 Zust√§nden verbringen wir 38% der Zeit mit der Verarbeitung von √úberg√§ngen in </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Auf einer Zustandsmaschine mit direkten √úberg√§ngen sind Hotspots Zeilenanalyse. </font><font style="vertical-align: inherit;">Das Parsen einer Zeichenfolge in jedem Status umfasst das √úberpr√ºfen der Bedingung am Ende der Zeichenfolge: Die Bedingung </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Statusmaschine ist aktiviert </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="bash hljs">perf <span class="hljs-built_in">stat</span> -e L1-icache-load-misses ./http_benchmark<font></font>
<font></font>
                       Switch-driven automaton  Goto-driven automaton<font></font>
big FSM code size:                       29156                  49202<font></font>
L1-icache-load-misses:                      4M                     2M</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als n√§chstes betrachten wir die Profilerstellung beider Arten von Zustandsmaschinen nach Ereignissen, bei denen der Befehls-Cache des L1-Befehls fehlschl√§gt - fast 30 Kilobyte f√ºr </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und 50 Kilobyte f√ºr direkte Spr√ºnge (mehr als der Cache der Befehle der ersten Ebene). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass, wenn wir nicht in den Cache passen, es f√ºr eine solche Zustandsmaschine viele Cache-Fehler geben sollte. </font><font style="vertical-align: inherit;">Aber nein, sie sind 2 mal weniger. </font><font style="vertical-align: inherit;">Das liegt daran, dass der Cache besser funktioniert: Wir arbeiten nacheinander mit dem Code und schaffen es, Daten aus den √§lteren Caches abzurufen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Compiler √§ndert die Reihenfolge des Codes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir den Code der Zustandsmaschine programmieren </font></font><code>go to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, haben wir zuerst die Zust√§nde, die zuerst aufgerufen werden, wenn die Daten empfangen werden: die HTTP-Methode, den URI und dann die HTTP-Header. Es erscheint logisch, dass der Code nacheinander von oben nach unten in den Prozessor-Cache geladen wird, w√§hrend wir die Daten durchgehen. Das ist aber v√∂llig falsch. Wenn Sie sich den Assembler-Code ansehen, werden Sie erstaunliche Dinge sehen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tg/uf/zr/tgufzrnfusabmvn1gg9ulzjgvgo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Links haben wir programmiert: Zuerst analysieren wir die Methoden </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dann irgendwo weit unterhalb der unwahrscheinlichen Methode </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Daher erwarten wir das Parsen </font></font><code> GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">am Anfang des Assemblers </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und dann </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Aber alles ist genau das Gegenteil: </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Mitte, </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am Ende und </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dar√ºber.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies liegt daran, dass der Compiler nicht versteht, wie Daten zu uns kommen. </font><font style="vertical-align: inherit;">Er verteilt den Code gem√§√ü seinem Bild von sch√∂nem Code. </font><font style="vertical-align: inherit;">Damit er den Code in der richtigen Reihenfolge anordnen kann, m√ºssen wir die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compiler-Barriere verwenden</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Compiler-Barriere ist ein Assembly-Dummy, √ºber den der Compiler nicht neu anordnet. </font><font style="vertical-align: inherit;">Durch die einfache Platzierung solcher Barrieren haben wir </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Produktivit√§t um 4% verbessert</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">STATE(sw_method) {<font></font>
    ... <span class="hljs-comment">// the most frequent states</span>
    MATCH(NGX_HTTP_GET, <span class="hljs-string">"GET "</span>);<font></font>
    MATCH(NGX_HTTP_POST, <span class="hljs-string">"POST"</span>);<font></font>
    <font></font>
    __asm__ __volatile__(<span class="hljs-string">""</span>: : :<span class="hljs-string">"memory"</span>);<font></font>
    ... <span class="hljs-comment">// many other states</span><font></font>
    <font></font>
    <span class="hljs-comment">// Improbable states</span>
    METH_MOVE(Req_MethU, <span class="hljs-string">'N'</span>, Req_MethUn);<font></font>
    METH_MOVE(Req_MethUn, <span class="hljs-string">'L'</span>, Req_MethUnl);<font></font>
    METH_MOVE(Req_MethUnl, <span class="hljs-string">'O'</span>, Req_MethUnlo);<font></font>
    METH_MOVE(Req_MethUnlo, <span class="hljs-string">'C'</span>, Req_MethUnloc);<font></font>
    METH_MOVE_finish(Req_MethUnloc, <span class="hljs-string">'K'</span>, NGX_HTTP_UNLOCK)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verfassen Sie den Code auf Ihre eigene Weise</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da der Compiler die Daten nicht wie gew√ºnscht anordnet, f√ºhren wir eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">profilergesteuerte Optimierung durch</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Optimierung unter der Kontrolle des Profilers). </font><font style="vertical-align: inherit;">Profiler Guided Optimization (PGO) ist die Gesamtzahl der Stichproben, keine Folge von Aufrufen. </font><font style="vertical-align: inherit;">Ein URI empf√§ngt beispielsweise mehr Stichproben als eine Methodenanalyse, sodass der URI-Verarbeitungscode vor der Verarbeitung der Methode positioniert wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie es funktioniert? </font><font style="vertical-align: inherit;">Wir werden den Code schreiben, Benchmarks ausf√ºhren, das Ergebnis der Profilerstellung an den Compiler weitergeben und den optimalen Code f√ºr unsere Ladevorg√§nge generieren. </font><font style="vertical-align: inherit;">Das Problem ist jedoch, dass einfach die hei√üesten Codeabschnitte kompiliert werden, die Zeitabh√§ngigkeit jedoch nicht verfolgt wird. </font><font style="vertical-align: inherit;">Wenn der gr√∂√üte URI in der Last ist, ist dies der hei√üeste Ort. </font><font style="vertical-align: inherit;">Der URI steigt an die Spitze der Funktion, und PGO zeigt nicht an, dass der Methodenname immer vor dem URI steht. </font><font style="vertical-align: inherit;">Dementsprechend funktioniert PGO nicht.</font></font><br>
<br>
<pre><code class="cpp hljs">Req_Method: {
    <span class="hljs-keyword">if</span> (likely(PI(p) == CHAR4_INT(<span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>))) {<font></font>
        ...<font></font>
        <span class="hljs-keyword">goto</span> Req_Uri;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (likely(PI(p) == CHAR4_INT(<span class="hljs-string">'P'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'T'</span>))) {<font></font>
        ...<font></font>
        <span class="hljs-keyword">goto</span> Req_UriSpace;<font></font>
    }<font></font>
    <span class="hljs-keyword">goto</span> Req_Meth_SlowPath;<font></font>
}<font></font>
... <span class="hljs-comment">// other methods: POST, PUT etc.</span><font></font>
Req_Uri:<font></font>
    ... <span class="hljs-comment">// URI processing</span><font></font>
Req_Meth_SlowPath:<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was funktioniert? </font></font><br>
<br>
<code><strong>likely</strong></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code><strong>unlikely</strong></code> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">macros</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (f√ºr Linux-Kernel-Code sind GCC-Intrinsics im Benutzerbereich verf√ºgbar </font></font><code>__builtin_expect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Sie sagen, welcher Code n√§her platziert werden soll. Beispielsweise wird wahrscheinlich berichtet, dass der Anforderungshauptteil unmittelbar dahinter sein sollte </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn Sie dann den Code vorab abrufen (indem Sie den Prozessor vorab abrufen), wird dieser Code ausgew√§hlt, und alles ist schnell. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7x/4u/05/7x4u057of2wmtq310wflcuyvlei.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Bild zeigt den Beginn der Parsing-Methode, das Ende und die Barriere. Wir hatten nicht erwartet, den Code hinter der Barriere zu sehen. Es scheint, dass dies nicht sein sollte - wir haben eine Barriere errichtet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber was passiert in der Realit√§t? Der Compiler sieht die </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bedingung - es ist sehr wahrscheinlich, dass wir in den Hauptteil der Bedingung eintreten und dort zu einem bedingungslosen Sprung zum Label wechseln</font></font><code>Req_Uri</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es stellt sich heraus, dass der Code, der nach unserem Zustand liegt, nicht im "Hot Path" verarbeitet wird. </font><font style="vertical-align: inherit;">Der Compiler verschiebt den Code </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trotz der Barriere </font><font style="vertical-align: inherit;">unter das Etikett dahinter </font><font style="vertical-align: inherit;">, da die Hot-Code-Bedingung erf√ºllt ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dazu hat GCC keine Erweiterung: die Attribute </font></font><code>hot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>cold</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr die Labels. </font><font style="vertical-align: inherit;">Sie sagen, welches Etikett hei√ü (am wahrscheinlichsten) und welches kalt (weniger wahrscheinlich) ist. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/ra/uh/bwrauhxesqvk_ke22cw67cqwuja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sind wir uns einig, was </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wahrscheinlicher ist </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und √ºberlassen es ihm </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Unter dieser Bedingung steigt die URI-Verarbeitung an und </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sinkt. </font><font style="vertical-align: inherit;">Alle anderen Codes f√ºr die Zustandsmaschine mit der geringsten Wahrscheinlichkeit bleiben unten, da das Etikett kalt ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehrdeutig -O3</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns die Compiler-Optimierung an. </font><font style="vertical-align: inherit;">Das erste, was mir in den Sinn kommt, ist, nicht O2, sondern O3 zu verwenden - es sollte schneller sein. </font><font style="vertical-align: inherit;">Dies ist jedoch nicht der Fall - O3 generiert manchmal schlechteren Code. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vc/-p/q8/vc-pq8a078kyofsx7cj1ukorbta.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O3 ist eine Sammlung einiger Optimierungen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn wir sie separat zu O2 hinzuf√ºgen, erhalten wir verschiedene Optionen: Einige Optimierungen helfen, andere st√∂ren. </font><font style="vertical-align: inherit;">F√ºr unseren spezifischen Code w√§hlen wir nur die Optimierungen aus, die den Code besser generieren. </font><font style="vertical-align: inherit;">Wir hinterlassen das beste Ergebnis - hier sind 1.820 Sekunden relativ zu 1.838 und 1.858. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Optionen sind gr√ºn hervorgehoben - dies ist die automatische Vektorisierung.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autovektorisierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Beispiel f√ºr einen Zyklus aus dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GCC-Handbuch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> a[<span class="hljs-number">256</span>], b[<span class="hljs-number">256</span>], c[<span class="hljs-number">256</span>];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<font></font>
        a[i] = b[i] + c[i];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir ein variables Array haben, das sich wiederholt, k√∂nnen wir den Zyklus optimieren - in Vektoren zerlegen. </font><font style="vertical-align: inherit;">Standardm√§√üig </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die automatische </font><strong><font style="vertical-align: inherit;">Vektorisierung</font></strong><font style="vertical-align: inherit;"> auf der dritten Optimierungsebene aktiviert. -O3 </font><font style="vertical-align: inherit;">: GCC generiert Vektorcode, wo dies m√∂glich ist. </font><font style="vertical-align: inherit;">Es kann jedoch </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht der gesamte Code</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> automatisch vektorisiert werden (auch wenn er im Prinzip vektorisiert ist). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen die GCC-Option aktivieren </font></font><code>-fopt-info-vec-all</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die zeigt, was vektorisiert wurde und was nicht. </font><font style="vertical-align: inherit;">Wir bekommen, dass f√ºr unseren Benchmark nichts vektorisiert ist, aber der Code immer noch schlechter generiert wird. </font><font style="vertical-align: inherit;">Daher funktioniert die Vektorisierung nicht immer: Manchmal verlangsamt sie den Code. </font><font style="vertical-align: inherit;">Aber wir k√∂nnen immer sehen, was vektorisiert wurde und was nicht, und die Vektorisierung gegebenenfalls deaktivieren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausrichtung: Wie vergleiche ich einen String mit GET?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir machen einen kleinen Hack wie in Nginx: Wir analysieren Zeilen nicht nach Bytes, sondern berechnen </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und vergleichen Zeilen mit ihnen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR4_INT(a, b, c, d)    ((d &lt;&lt; 24) | (c &lt;&lt; 16) | (b &lt;&lt; 8) | a)</span>
<span class="hljs-keyword">if</span> (p == CHAR4_INT(<span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>)))
    <span class="hljs-comment">// we have GET as method</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wissen, dass es </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2-3 Mal langsamer wird </font><font style="vertical-align: inherit;">, wenn es </font><font style="vertical-align: inherit;">nicht ausgerichtet ist. </font><font style="vertical-align: inherit;">Wir haben einen kleinen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmark geschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der dies beweist.</font></font><br>
<br>
<pre><code class="cpp hljs">$ ./int_align<font></font>
Unaligned access = <span class="hljs-number">6.20482</span>
Aligned access = <span class="hljs-number">2.87012</span>
Read four bytes = <span class="hljs-number">2.45249</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen Sie dann auszurichten </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden schauen, ob die Adresse </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ausgerichtet ist, und dann mit </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bytes </font><font style="vertical-align: inherit;">vergleichen </font><font style="vertical-align: inherit;">, wenn nicht.</font></font><br>
<br>
<pre><code class="cpp hljs"> (((<span class="hljs-keyword">long</span>)(p) &amp; <span class="hljs-number">3</span>)<font></font>
  ? ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">0</span>]) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span>)<font></font>
  | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span>) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">3</span>]) &lt;&lt; <span class="hljs-number">24</span>))<font></font>
  : *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)(p));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich jedoch heraus, dass dieser Ansatz schlechter funktioniert:</font></font><br>
<br>
<pre><code class="bash hljs">full request line:     no difference<font></font>
method only:           unaligned      - 214ms<font></font>
                       aligned        - 231ms<font></font>
                       bytes          - 216ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz gesagt: Es gibt einen Unterschied zwischen dem isolierten, nicht optimierbaren Benchmark-Code und dem Inline-Parser-Code, der aufgrund der gro√üen Codemenge seine Optimierung verliert. </font><font style="vertical-align: inherit;">Es gab keine Strafe bei der Profilerstellung. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Eine ausf√ºhrliche Beschreibung, warum dies in unserer Aufgabe geschieht, finden </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie auf GitHub</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum sind HTTP-Strings f√ºr uns wichtig?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist beispielsweise eine normale URI: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pw/_d/tw/pw_dtwjndt-xro47gvj3qehvpm4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie in Bezug auf das Hotel w√§hlerisch genug sind, gehen Sie zu Buchung und stellen Sie einige Filter ein. Erhalten Sie eine URI von mehr als einem Kilobyte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx hat eine ziemlich massive Parsing-Maschine auf </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es funktioniert nicht sehr schnell. </font><font style="vertical-align: inherit;">Dar√ºber hinaus m√ºssen wir im Fall von Tempesta FW den URI nicht nur analysieren, sondern auch auf Injektionen √ºberpr√ºfen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">case</span> sw_check_uri:
    <span class="hljs-keyword">if</span> (usual[ch &gt;&gt; <span class="hljs-number">5</span>] &amp; (<span class="hljs-number">1U</span> &lt;&lt; (ch &amp; <span class="hljs-number">0x1f</span>)))
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">switch</span> (ch) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:<font></font>
        r-&gt;uri_ext = <span class="hljs-literal">NULL</span>;<font></font>
        state = sw_after_slash_in_uri;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'.'</span>:<font></font>
        r-&gt;uri_ext = p + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">' '</span>:<font></font>
        r-&gt;uri_end = p;<font></font>
        state = sw_check_uri_http_09;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> CR:<font></font>
        r-&gt;uri_end = p;<font></font>
        r-&gt;http_minor = <span class="hljs-number">9</span>;<font></font>
        state = sw_almost_done;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LF:<font></font>
        r-&gt;uri_end = p;<font></font>
        r-&gt;http_minor = <span class="hljs-number">9</span>;
        <span class="hljs-keyword">goto</span> done;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'%'</span>:<font></font>
    r-&gt;quoted_uri = <span class="hljs-number">1</span>;<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer URI: /redir_lang.jsp?lang=foobar%0d%0aContent-Length:%200%0d% </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0a% 0d% 0aHTTP / 1.1% 20200% 20OK% 0d% 0aContent-Type:% 20text / </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
html% 0d% 0aContent -L√§nge:% 2019% 0d% 0a% 0d% 0aShazam &lt;/ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
html&gt;. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sieht aus wie das erste, hat aber eine Injektion. Sie m√ºssen tief genug graben, um dies zu verstehen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns einen Test durchf√ºhren</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Nehmen Sie den ersten URI, geben Sie wrk ein, setzen Sie ihn auf nginx und sehen Sie, dass das Parsen von nginx sehr hei√ü wird. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m-/y1/id/m-y1idxtawyq5rjayodyb_r2tgq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn bei der vorherigen regul√§ren Indexabfrage klar war, dass sich der Parser bereits oben befindet, wird es hier noch hei√üer.</font></font><br>
<br>
<pre><code class="bash hljs">8.62%  nginx         [.] ngx_http_parse_request_line<font></font>
2.52%  nginx         [.] ngx_http_parse_header_line<font></font>
1.42%  nginx         [.] ngx_palloc<font></font>
0.90%  [kernel]      [k] copy_user_enhanced_fast_string<font></font>
0.85%  nginx         [.] ngx_strstrn<font></font>
0.78%  libc-2.24.so  [.] _int_malloc<font></font>
0.69%  nginx         [.] ngx_hash_find<font></font>
0.66%  [kernel]      [k] tcp_recvmsg</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist das Besondere an HTTP-Strings? </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt verschiedene Trennzeichen </font></font><code>' : '</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>' , '</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sogar das Ende der Zeilen, die entweder Doppelbyte </font></font><code>\r\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder Einzelbyte sein k√∂nnen </font></font><code>\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was zu Beginn erl√§utert wurde. </font><font style="vertical-align: inherit;">Es gibt keine 0-Terminierung von C-Leitungen - aus Sicherheitsgr√ºnden m√∂chten wir genauer pr√ºfen, was zu uns kommt. </font><font style="vertical-align: inherit;">Wir haben zwei Standardfunktionen, die im Parser helfen.</font></font><br>
<br>
<ul>
<li><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: √úberpr√ºft das Alphabet, verf√ºgbare Zeichen in einer Zeichenfolge, kompiliert dynamisch ein g√ºltiges Alphabet, obwohl es zum Zeitpunkt der Kompilierung des Programms bekannt ist.</font></font></li>
<li><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es besteht keine Notwendigkeit zu konvertieren Fall zu vergleichen </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit </font></font><code>Foo:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In den meisten F√§llen </font></font><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist nur Compliance / Non-Compliance erforderlich, und Sie m√ºssen die Position in der Leitung nicht kennen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie arbeiten langsam. </font><font style="vertical-align: inherit;">Lassen Sie uns die Benchmarks sehen und verstehen, was mit ihnen nicht stimmt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schnelle Parser</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt mehrere Parser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx ist der einfachste Parser, Parser. Er √ºberpr√ºft streng die RFC-Konformit√§t. Es gibt auch PicoHTTPParser (H2O) - und Cloudflare-Parser. Sie verarbeiten Daten schneller, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://blog.cloudflare.com/improving-pico"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºberspringen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jedoch m√∂glicherweise </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://blog.cloudflare.com/improving-pico"><font style="vertical-align: inherit;">Zeichen</font></a><font style="vertical-align: inherit;"> , die vom RFC nicht zugelassen werden. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCMESTRI.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parser verwenden verschiedene Ans√§tze. Der erste ist der PCMESTRI-Befehl, der im Pico-Parser verwendet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir legen Bereiche in der Anleitung fest. Leider k√∂nnen wir entweder 16 Zeichen oder 8 Bereiche laden. Wenn der Bereich nur aus einem Zeichen besteht, wiederholen Sie einfach. Aufgrund dieser Einschr√§nkung kann der Pico-Parser die RFC-Konformit√§t nicht vollst√§ndig √ºberpr√ºfen, da der RFC an diesem Speicherort mehr als 8 Bereiche aufweist.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ks/x8/m_/ksx8m_ixc0oy3kzucdwzumppaus.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir laden das Alphabet in das Register, laden die Zeichenfolge und f√ºhren die Anweisung aus. Am Ausgang sehen wir schnell, ob es einen Zufall gibt oder nicht. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX2 - CloudFlare-Ansatz.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der CloudFlare-Parser verarbeitet mit AVX2 jeweils 32 Byte einer Zeichenfolge anstelle von 16 Byte mit einem Pico-Parser. Das Parsen ist bei CloudFlare besser, da es auf AVX2 √ºbertragen wurde. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/b8/3j/g1/b83jg1epzz6ec6dllxv1j4a-0lo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir √ºberpr√ºfen alle Zeichen auf ein Leerzeichen in der ASCII-Tabelle, alle Zeichen sind gr√∂√üer als 128 und nehmen den Bereich zwischen ihnen. Einfacher Code ist schnell. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergleichen Sie PCMESTRI und AVX2.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºr uns liegt das aktuelle Limit bei 1500. Dies ist die maximale Paketgr√∂√üe, die zu uns kommt. Wir sehen, dass der AVX2-Code f√ºr Big Data viel schneller ist als der Pico-Parser. Bei kleinen Datenmengen funktioniert es jedoch langsamer, da die Anweisungen in AVX2 schwerer sind. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/se/5t/c2/se5tc2npli1yed8ypqkdkk3z-pm.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergleichbar mit</font></font><code><strong>strspn</strong></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn wir uns f√ºr die Verwendung entscheiden, </font></font><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird es schlimmer, insbesondere bei Big Data. </font><font style="vertical-align: inherit;">Im "Kampf" kann der Parser nicht verwendet werden </font></font><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/08/vq/bf08vqlzni3dcjzxgiuj73zgszo.png"><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta Matcher ist schneller und genauer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Speed ‚Äã‚ÄãParser ist wie diese beiden. Bei kleinen Daten ist es so schnell wie ein Pico-Parser, bei gro√üen CloudFlare. Es werden jedoch keine ung√ºltigen Zeichen √ºbersprungen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5t/ns/lw/5tnslwsd-ywmrv1d4xaj5_ypwbw.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie ist der Parser angeordnet?</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir definieren als nginx ein Array von Bytes und √ºberpr√ºfen die Eingabedaten damit - dies ist der Prolog der Funktion. Hier arbeiten wir nur mit kurzen Begriffen, wir verwenden </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie, weil die Fehlvorhersage von Zweigen f√ºr kurze Zeilen schmerzhafter ist als f√ºr lange. Wir nehmen diesen Code auf. Wir haben wegen der letzten Zeile ein Limit von 4 - wir m√ºssen eine ziemlich starke Bedingung schreiben. Wenn wir mehr als 4 Bytes verarbeiten, ist die Bedingung schwieriger und der Code langsamer.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> uri_a[] __attribute__((aligned(<span class="hljs-number">64</span>))) = {
        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<font></font>
        ...<font></font>
        <span class="hljs-comment">// Branch misprediction is more crucial for short strings</span>
        <span class="hljs-keyword">if</span> (likely(len &lt;= <span class="hljs-number">4</span>)) {
                <span class="hljs-keyword">switch</span> (len) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<font></font>
                    c3 = uri_a[s[<span class="hljs-number">3</span>]];
                    <span class="hljs-comment">// fall through to process other chars</span>
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    c2 = uri_a[s[<span class="hljs-number">2</span>]];
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    c1 = uri_a[s[<span class="hljs-number">1</span>]];
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
                }<font></font>
                <span class="hljs-keyword">return</span> (c0 &amp; c1) == <span class="hljs-number">0</span> ? c0 : <span class="hljs-number">2</span> + (c2 ? c2 + c3 : <span class="hljs-number">0</span>);<font></font>
        }</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauptschleife und gro√üer Schwanz. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Hauptverarbeitungszyklus teilen wir die Daten auf: Wenn sie lang genug sind, verarbeiten wir jeweils 128, 64, 32 oder 16 Bytes. </font><font style="vertical-align: inherit;">Es ist sinnvoll, jeweils 128 zu verarbeiten: Parallel dazu verwenden wir mehrere Prozessorkan√§le (mehrere Pipelines) und einen superskalaren Prozessor.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> ( ; unlikely(s + <span class="hljs-number">128</span> &lt;= end); s += <span class="hljs-number">128</span>) {<font></font>
        n = match_symbols_mask128_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">128</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">64</span> &lt;= end)) {<font></font>
        n = match_symbols_mask64_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">64</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">64</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">32</span> &lt;= end)) {<font></font>
        n = match_symbols_mask32_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">32</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">32</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">16</span> &lt;= end)) {<font></font>
        n = match_symbols_mask16_c(__C.URI_BM128, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">16</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">16</span>;<font></font>
}</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwanz. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ende der Funktion √§hnelt dem Anfang. </font><font style="vertical-align: inherit;">Wenn wir weniger als 16 Bytes haben, verarbeiten wir 4 Bytes in einer Schleife und am Ende nicht mehr als 3 Bytes.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">while</span> (s + <span class="hljs-number">4</span> &lt;= end) {<font></font>
        c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
        c1 = uri_a[s[<span class="hljs-number">1</span>]];<font></font>
        c2 = uri_a[s[<span class="hljs-number">2</span>]];<font></font>
        c3 = uri_a[s[<span class="hljs-number">3</span>]];
        <span class="hljs-keyword">if</span> (!(c0 &amp; c1 &amp; c2 &amp; c3)) {<font></font>
                n = s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str;
                <span class="hljs-keyword">return</span> !(c0 &amp; c1) ? n + c0 : n + <span class="hljs-number">2</span> + (c2 ? c2 + c3 : <span class="hljs-number">0</span>);<font></font>
        }<font></font>
        s += <span class="hljs-number">4</span>;<font></font>
}<font></font>
<font></font>
c0 = c1 = c2 = <span class="hljs-number">0</span>;
<span class="hljs-keyword">switch</span> (end - s) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                c2 = uri_a[s[<span class="hljs-number">2</span>]];
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                c1 = uri_a[s[<span class="hljs-number">1</span>]];
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
}<font></font>
<font></font>
n = s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str;
<span class="hljs-keyword">return</span> !(c0 &amp; c1) ? n + c0 : n + <span class="hljs-number">2</span> + c2;</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir laden Bitmasken und Daten -</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dies ist der Hauptalgorithmus des Hauptteils der Funktion. Wir pr√§sentieren eine ASCII-Tabelle (wie im Bild) mit 16 Zeilen und 8 Spalten. Zuerst codieren wir unsere Tabellenzeilen im ersten Register des BM-URI: der ersten und zweiten Zeile. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9l/cv/k2/9lcvk2_wg7qs6svdibpx9m1b09c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die tats√§chlichen Symbole, die wir zulassen, sind </font></font><code>0 @ P p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>2 B R q R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie sind wie folgt codiert: </font></font><code>b8 = inv(1011 1000) = 0 @ P p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>f8 = inv(1111 1000) = 2 B R q R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir codieren in umgekehrter Reihenfolge: Wir beginnen bei 0, das erste Dienstzeichen ist nicht zul√§ssig, und dann sind Einheiten zul√§ssig. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legen Sie die ASCII-Bitmasken fest.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zum Beispiel kommt eine Zeile herein </font></font><code>"pr"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Das erste Zeichen aus der ersten Zeile ist ASCII, das zweite aus der zweiten Zeile. Wir f√ºhren die shuffle-Anweisung aus, die unsere codierten Tabellenzeilen in der Reihenfolge dieser Zeichen in der Eingabe mischt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_i/zr/ol/_izrolii19qo5olblx0zzjgq_iu.jpeg"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spalten-ID f√ºr die Eingabe.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Als n√§chstes platzieren wir die Spalten der ASCII-Tabelle in einem anderen Register. Dann ‚Äûkreuzen‚Äú wir die Register von Spalten und Zeilen und erhalten eine Entsprechung: unser Charakter oder nicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die Spalten die h√∂chstwertigen 4 Bits vom Byte sind, verschieben wir uns nach links. AVX hat einen Offset von nur 2 Bytes. Verschieben Sie also zuerst das Byte und dann n mit unserer Maske, um nur signifikante Bits zu erhalten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d9/xy/xr/d9xyxrmjyplbnhkpwrxbqblians.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anordnen von ASCII-Spalten</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºhren Sie den zweiten Shuffle aus und bewegen Sie die Spalte an die gew√ºnschten Positionen. In beiden F√§llen das Eingabebyte aus der letzten Spalte, sodass wir an der ersten und zweiten Position dieselbe Spalte erhalten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/g1/2s/hxg12sn4xw-qlt7miq97k0pnwgy.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schnittpunkt von Spalten und Zeilen von Masken</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wir tun dies </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">("kreuzen" die Spalten mit Spalten) und wir erhalten, dass die Eingabedaten g√ºltig sind - das Ergebnis</font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vom Schnittpunkt von Spalten und Zeilen ist nicht Null. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cd/oa/kw/cdoakwgjf-oipltg_xeyyglobn8.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z√§hlen Sie die Anzahl der Nullen am Ende. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sammeln alles aus dem Vektor in </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und geben es an die Ausgabe zur√ºck - ganz einfach. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/f9/ci/tl/f9citlkgsjvtxifi9qe3pdxu7su.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passen Sie die Alphabete an. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir mit der ASCII-Tabelle arbeiten, erhalten wir eine g√ºnstige Funktion: Wir verwenden statische Tabellen, aber nichts hindert uns daran, den Benutzer zu fragen, welches Alphabet f√ºr URIs, Namen und Werte verschiedener Header verf√ºgbar ist. </font><font style="vertical-align: inherit;">Die HTTP-URI-Anforderung und der Header verwenden 8 Alphabete (Plus oder Minus), um eine HTTP-Anforderung zu analysieren. </font><font style="vertical-align: inherit;">Diese Tabellen k√∂nnen in denselben Code geladen und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in einem vom Benutzer angegebenen Alphabet, einem</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> g√ºltigen URI, </font><strong><font style="vertical-align: inherit;">verglichen werden</font></strong><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn nicht, ist es anders.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anschl√§ge</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige F√§lle, in denen dies n√ºtzlich sein kann. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSRF-Angriff mit BlackHat'17</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (‚ÄûEine neue √Ñra der SSRF‚Äú): </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://foo@evil.com:80@google.com/</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ein unwahrscheinliches kaufm√§nnisches Und-Symbol. </font><font style="vertical-align: inherit;">In einigen Anwendungen wird es verwendet, in anderen nicht. </font><font style="vertical-align: inherit;">Wenn Sie es jedoch nicht verwenden, k√∂nnen Sie es vom g√ºltigen Alphabet ausschlie√üen, und der Angriff wird blockiert. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RCE-Angriff:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬´effektiv ist die Ausf√ºhrung von Befehlsinjektionsangriffen wie¬ª, BSides'16 : </font></font><code>User-Agent: ...;echo NAELBD$((26+58))$echo(echo NAELBD)NAELBD...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der User-Agent ist ein statischer Header, es gibt jedoch F√§lle eines RCE-Angriffs, wenn einige </font></font><code>shell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit atypischen Zeichen f√ºr den User-Agent versehen sind. </font><font style="vertical-align: inherit;">Wir sch√ºtzen uns bis auf das Dollarzeichen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relativer Pfad √ºberschreiben</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Der letzte Fall war der von Google im Jahr 2016. </font><font style="vertical-align: inherit;">Geschweifte Klammern, Doppelpunkte, kamen zur URI </font></font><code>.../gallery?q=%0a{}*{background:red}/..//apis/howto_guide.html</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies sind unwahrscheinliche Zeichen, die aus dem Alphabet ausgeschlossen werden k√∂nnen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strcasecmp ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein ziemlich trivialer Code. </font><font style="vertical-align: inherit;">Wir vergleichen auch Zeichenfolgen mit 32 Bytes, jeweils zwei Arrays.</font></font><br>
<br>
<pre><code class="cpp hljs">__m256i CASE = _mm256_set1_epi8(<span class="hljs-number">0x20</span>);<font></font>
<font></font>
<span class="hljs-comment">// Hacker‚Äôs Delight for signed comparison: -0x80 for both operands</span>
__m256i A = _mm256_set1_epi8(<span class="hljs-string">'A'</span> ‚Äì <span class="hljs-number">0x80</span>);<font></font>
__m256i D = _mm256_set1_epi8(<span class="hljs-string">'Z'</span> - <span class="hljs-string">'A'</span> + <span class="hljs-number">1</span> ‚Äì <span class="hljs-number">0x80</span>);<font></font>
<font></font>
<span class="hljs-comment">// Hacker‚Äôs Delight: 'a' &lt;= v &lt;= 'z' to</span>
<span class="hljs-comment">// v - ('a' ‚Äì 0x80) &lt; 'z' - 'a' + 1 - 0x80</span><font></font>
__m256i sub = _mm256_sub_epi8(str1, A);<font></font>
__m256i cmp_r = _mm256_cmpgt_epi8(D, sub);<font></font>
__m256i lc = _mm256_and_si256(cmp_r, CASE);<font></font>
__m256i vl = _mm256_or_si256(str1, lc);<font></font>
__m256i eq = _mm256_cmpeq_epi8(vl, str2);<font></font>
<span class="hljs-keyword">return</span> ~_mm256_movemask_epi8(eq);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir geben dem Register nur eine Zeile, weil wir in der zweiten die Konstanten in unserem Parser in Kleinbuchstaben programmiert haben. </font><font style="vertical-align: inherit;">Da wir signifikante Vergleiche haben, subtrahieren wir 128 von jedem Byte (ein Trick von Hacker's Delight). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir vergleichen auch den Bereich eines g√ºltigen Zeichens: Ob wir uns f√ºr diese Zeichenfolge registrieren k√∂nnen oder nicht, ist es ein Buchstabe oder nicht. </font><font style="vertical-align: inherit;">Zum Zeitpunkt der √úberpr√ºfung k√∂nnen wir anstelle von zwei Vergleichen von a bis z nur einen Vergleich verwenden (ein Trick von Hacker's Delight) und zu einer Konstanten wechseln.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leistung strcasecmp ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempesta ist viel schneller als GLIBC, sogar die neue Version (18 oder 19). </font><font style="vertical-align: inherit;">Der Code </font></font><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet auch AVX, jedoch nicht die zweite Version. </font><font style="vertical-align: inherit;">AVX2 ist schneller, daher verf√ºgt Tempesta √ºber schnelleren Code.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/zi/pb/wxzipbzdsbvge8u_abhsnok-gfa.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux-Kernel-FPU</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir verwenden </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vektorprozessor-Erweiterungen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - diese sind im Kernel verf√ºgbar. Vektoranweisungen werden vom FPU-Prozessormodul verarbeitet. Dies ist nicht das Hauptprozessormodul, nicht die Hauptregister, aber ziemlich umfangreich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher gibt es unter Linux eine Optimierung. Wenn wir vom Kernel in den Benutzerbereich und zur√ºck wechseln, speichern wir nicht den Kontext der FPU-Register (XMM, YMM, ZMM): Wir √§ndern nur den Kontext der Register des Hauptprozessormoduls. Es wird angenommen, dass der Betriebssystemkern nicht mit der Vektorerweiterung des Prozessors funktioniert. Wenn Sie es beispielsweise ben√∂tigen, kann die Kryptografie dies tun, muss jedoch </font><font style="vertical-align: inherit;">den Kontext des FPU-Registers </font><font style="vertical-align: inherit;">verwenden </font></font><code>fpu_begin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>fpu_end</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speichern und wiederherstellen:</font></font><br>
<br>
<pre><code class="cpp hljs">__kernel_fpu_begin_bh();<font></font>
memcpy_avx(dst, src, n);<font></font>
__kernel_fpu_end_bh();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hierbei handelt es sich um native Makros, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die den Status des Prozessormoduls speichern und wiederherstellen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das f√ºr Vektorregister verantwortlich ist. </font><font style="vertical-align: inherit;">Dies sind ziemlich langsame Ressourcen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX und SSE</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor den Benchmarks zum Speichern und Wiederherstellen des FPU-Kontexts einige Worte zu Vektoroperationen. </font><font style="vertical-align: inherit;">Warum ist es manchmal sinnvoll, mit Assembler zu arbeiten? </font><font style="vertical-align: inherit;">Manchmal generiert GCC suboptimalen Code. </font><font style="vertical-align: inherit;">Das Problem ist, dass bei √§lteren Prozessormodellen der √úbergang von SSE zu AVX erhebliche Nachteile mit sich bringt. </font><font style="vertical-align: inherit;">GCC hat einen neuen Schl√ºssel </font></font><code>vzeroupper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- verwenden Sie ihn, damit dieser Befehl nicht generiert wird </font></font><code>vzeroupper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wodurch die Register gel√∂scht und diese Strafe beseitigt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie m√ºssen diese Anweisung nur verwenden, wenn Sie mit altem Code arbeiten, der von einem Dritten f√ºr SSE kompiliert wurde. </font><font style="vertical-align: inherit;">Dies ist nicht unser Fall und wir k√∂nnen diese Anweisungen sicher wegwerfen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auto-Vektorisierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Prozessor. Dies bedeutet, dass in jedem Benutzerbereichscode Vektoroperationen vorhanden sind. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/n9/vy/0w/n9vy0wal4alh1eelo1rbdjabavc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zwei beliebige Prozesse im System verwenden Vektorprozessorerweiterungen. Wenn Ihr Prozess zum Kernel und zur√ºck wechselt, verschwenden Sie keine Zeit damit, den Vektorstatus des Prozessors zu sparen und wiederherzustellen. Wenn Sie jedoch von einem Benutzerbereich zu einem anderen wechseln (Kontextwechsel), funktioniert neben der Tatsache, dass dort Caches der ersten Ebene deaktiviert sind, auch das Kontextwechselmodul auf FPU begin / end schlecht. Die Operation ist ziemlich teuer - ein Mikrobenchmark.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Mikrobenchmarks ist immer alles dramatisch, aber die Operation ist sehr teuer. </font><font style="vertical-align: inherit;">Wechseln Sie daher im Benutzerbereich den Kontext f√ºr eine lange Zeit. </font><font style="vertical-align: inherit;">Im Kernel gibt es keine Kontextumschaltung, daher ist alles schnell. </font><font style="vertical-align: inherit;">Wir speichern und stellen den Vektorprozessor nur einmal f√ºr einen ausreichend gro√üen Satz von Paketen wieder her.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intelpocalypse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Anfang habe ich eine Nachschlagetabellenoption zur Optimierung des Switch-Codes gezeigt: Ein langer Prozess, enum, kompiliere die Switch-Tabelle in ein Array und folge der doppelten Dereferenzierung des Zeigers, der √ºber dieses Array springt. Dies ist ein Szenario f√ºr einen Spectre-Angriff, bei dem die spekulative Ausf√ºhrung ausgenutzt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google hat einen guten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dar√ºber, wie die doppelte Dereferenzierung von Zeigern in modernen Compilern derzeit (seit Anfang 2018) angeordnet ist. Es funktioniert nicht sehr gut. Wenn fr√ºher im Register eine Adresse gespeichert wurde und wir zu dieser Adresse gegangen sind, haben wir jetzt einen anderen Code.</font></font><br>
<br>
<pre><code class="cpp hljs">jmp *%r11 <font></font>
    call l1<font></font>
l0: pause<font></font>
    lfence<font></font>
    jmp l0<font></font>
l1: mov %r11, (%rsp)<font></font>
    ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie funktioniert es? Wir "rufen" die Funktion auf l1 auf, der Prozess geht zu diesem Label und wir machen einen Hack: als ob wir von einer Funktion zur√ºckkehren (was nicht der Fall ist), aber wir schreiben die R√ºcksprungadresse neu. Wenn wir den Befehl ausf√ºhren </font></font><code>call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, platzieren </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">die R√ºcksprungadresse, die aktuelle Adresse, auf dem Stapel, schreiben sie mit dem erforderlichen Inhalt des Registers neu und gehen zu l1. Aber der Prozessor sieht, wenn sein Prefetcher l√§uft, dass es eine Funktion und dann eine Barriere gibt. Dementsprechend wird alles langsam sein - es wirft das Prefetching aus und wir beseitigen die Spectre-Schwachstelle. Der Code ist langsam, die Leistung sinkt um 15%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der n√§chste relativ neue Angriff ist </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meltdown.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es ist nur f√ºr User-Space-Prozesse spezifisch. </font><font style="vertical-align: inherit;">Sehr schmerzhaft ist das Lesen des Kernelspeichers aus dem Benutzerbereich. </font><font style="vertical-align: inherit;">Der Angriff wird durch die Kernel Pate Table Isolation (KPTI) verhindert, die standardm√§√üig in neuen Kerneln kompiliert wird. </font><font style="vertical-align: inherit;">KPTI ist jedoch sehr teuer und f√ºhrt zu einer Leistungsverschlechterung von bis zu 30-40% ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gemessen von MariaDB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies liegt an der Tatsache, dass Sie keine verz√∂gerte TLB-Optimierung mehr haben: Der Adressraum des Kernels und des Prozessors ist vollst√§ndig in verschiedenen Seitentabellen getrennt (zuvor hat der verz√∂gerte TLB den Kernelraum der Seitentabelle jedes Prozesses zugeordnet). </font><font style="vertical-align: inherit;">Dies ist schmerzhaft f√ºr den Benutzerbereich, nicht jedoch f√ºr Tempesta FW, das vollst√§ndig im Kernel funktioniert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige n√ºtzliche Links:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://natsys-lab.blogspot.com/2014/11/the-fast-finite-state-machine-for-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schnelle Finite-State-Maschine f√ºr die HTTP-Analyse</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://natsys-lab.blogspot.com/2016/10/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verarbeitung von HTTP-Strings mit C, SSE4.2 und AVX2</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hackers Freude</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meltdown und Spectre greifen Dokumente an</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intelpocalypse: goodbye fast system calls</a></li>
</ul><br>
<blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Saint HighLoad++</a>        .       , 6   -- (  ,      Saint HighLoad++)  ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> web </a>. <br>
<br>
     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHP Russia</a>: 13   ,  .       ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KnowledgeConf</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">++</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TechLead Conf</a> ‚Äî     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  , ,    .<br>
</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de493226/index.html">Lesen und Korrigieren von 100.000 Codezeilen pro Woche</a></li>
<li><a href="../de493230/index.html">Neue Google PageSpeed ‚Äã‚ÄãInsights mit Lighthouse 6 (Beta): √úberpr√ºfen Sie die Leistung Ihrer Website</a></li>
<li><a href="../de493232/index.html">Die Geschichte meiner Arbeit bei Open Product LLC</a></li>
<li><a href="../de493234/index.html">ING bringt Lion auf den Markt: Eine Bibliothek mit produktiven, erschwinglichen und flexiblen Webkomponenten</a></li>
<li><a href="../de493236/index.html">Sternchen: Externe Amtsleitungen im Status "Anfrage gesendet"</a></li>
<li><a href="../de493244/index.html">Was kann ein Quantencomputer?</a></li>
<li><a href="../de493248/index.html">Webinar "Winnum Opportunities for Industrial Analytics"</a></li>
<li><a href="../de493250/index.html">Was passiert gerade mit Reisen - und wie Sie sich beim Transport sch√ºtzen k√∂nnen</a></li>
<li><a href="../de493252/index.html">Unterrichtserfahrung an einer Entwicklungsschule oder warum Sie nach dem Studium zur Schule gehen m√ºssen</a></li>
<li><a href="../de493254/index.html">Das System des Massenabh√∂rens der Bev√∂lkerung war f√ºr das FBI praktisch nutzlos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>