<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍒 🔔 💂🏼 Weitere Informationen zu Coroutinen in C ++ 👨🏻‍⚕️ ✊🏽 👏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Kollegen. 
 
 Im Rahmen der Entwicklung des C ++ 20-Themas stießen wir einmal auf einen ziemlich alten Artikel (September 2018) aus dem Yandex-H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Weitere Informationen zu Coroutinen in C ++</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/491996/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Kollegen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Rahmen der Entwicklung des C ++ 20-Themas stießen wir einmal auf einen ziemlich alten Artikel (September 2018) aus dem Yandex-Hublog mit dem Titel „ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorbereitung auf C ++ 20. Coroutines TS mit einem echten Beispiel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “. Es endet mit der folgenden sehr ausdrucksstarken Abstimmung: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/a-/m4/xn/a-m4xn5j3yjfy-yl2et7aeek7sc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
„Warum nicht?“ Wir haben einen Artikel von David Pilarski unter dem Titel „Coroutines Introduction“ beschlossen und übersetzt. Der Artikel wurde vor etwas mehr als einem Jahr veröffentlicht, aber hoffentlich finden Sie ihn trotzdem sehr interessant.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So ist es passiert. Nach vielen Zweifeln, Debatten und Vorbereitungen zu diesem Feature kam WG21 zu einer gemeinsamen Meinung darüber, wie Coroutinen in C ++ aussehen sollten - und es ist sehr wahrscheinlich, dass sie in C ++ 20 enthalten sein werden. Da dies ein wichtiges Feature ist, denke ich, ist es Zeit, es bereits vorzubereiten und zu studieren Jetzt (wie Sie sich erinnern, gibt es noch mehr Module, Konzepte, Bereiche zu lernen ...) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele sind immer noch gegen Coroutine. Oft beschweren sie sich über die Komplexität ihrer Entwicklung, viele Anpassungspunkte und möglicherweise eine suboptimale Leistung aufgrund einer möglicherweise nicht optimierten Zuweisung des dynamischen Speichers (möglicherweise;)).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parallel zur Entwicklung genehmigter (offiziell veröffentlichter) technischer Spezifikationen (TS) wurden sogar Versuche unternommen, einen anderen Corutin-Mechanismus parallel zu entwickeln. </font><font style="vertical-align: inherit;">Hier werden wir über die Coroutinen sprechen, die in TS ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">technische Spezifikation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) beschrieben sind. </font><font style="vertical-align: inherit;">Ein alternativer Ansatz gehört wiederum zu Google. </font><font style="vertical-align: inherit;">Infolgedessen stellte sich heraus, dass der Google-Ansatz unter zahlreichen Problemen leidet, deren Lösung häufig seltsame zusätzliche Funktionen von C ++ erfordert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende wurde beschlossen, eine von Microsoft entwickelte Version von Corutin (gesponsert von TS) zu übernehmen. </font><font style="vertical-align: inherit;">Es geht um solche Coroutinen, die in diesem Artikel behandelt werden. </font><font style="vertical-align: inherit;">Beginnen wir also mit der Frage ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was sind Coroutinen?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Coroutinen gibt es bereits in vielen Programmiersprachen, beispielsweise in Python oder C #. </font><font style="vertical-align: inherit;">Coroutinen sind eine weitere Möglichkeit, asynchronen Code zu erstellen. </font><font style="vertical-align: inherit;">Wie sie sich von Flows unterscheiden, warum Coroutinen als dedizierte Sprachfunktion implementiert werden sollten und schließlich, wie sie verwendet werden, wird in diesem Abschnitt erläutert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt ein ernstes Missverständnis darüber, was Coroutinen sind. </font><font style="vertical-align: inherit;">Abhängig von der Umgebung, in der sie verwendet werden, können sie wie folgt bezeichnet werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stapellose Coroutinen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutinen stapeln</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grüne Bäche</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fasern</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gorutins</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die gute Nachricht: Stapelkorutine, grüne Ströme, Fasern und Gorutine sind ein und dasselbe (aber sie werden manchmal auf unterschiedliche Weise verwendet). Wir werden später in diesem Artikel darüber sprechen und sie Fasern oder Stapelkoroutinen nennen. Die stapellose Coroutine weist jedoch einige Funktionen auf, die separat behandelt werden müssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um Coroutinen zu verstehen, auch auf einer intuitiven Ebene, lernen wir kurz die Funktionen und (sagen wir es so) „ihre API“ kennen. Die Standardmethode für die Arbeit mit ihnen besteht darin, anzurufen und zu warten, bis der Vorgang abgeschlossen ist:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>{
     <span class="hljs-keyword">return</span>; <span class="hljs-comment">//     </span><font></font>
}	<font></font>
foo(); <span class="hljs-comment">//   / </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Aufruf der Funktion ist es bereits unmöglich, die Arbeit anzuhalten oder fortzusetzen. Sie können nur zwei Operationen an Funktionen ausführen: </font></font><code>start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn die Funktion gestartet wird, müssen Sie warten, bis sie abgeschlossen ist. Wenn die Funktion erneut aufgerufen wird, erfolgt ihre Ausführung von Anfang an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Coroutinen ist die Situation anders. Sie können sie nicht nur starten und stoppen, sondern auch anhalten und fortsetzen. Sie unterscheiden sich immer noch von Kernflüssen, da sich die Coroutinen selbst nicht verdrängen (andererseits beziehen sich Coroutinen normalerweise auf den Fluss, und der Fluss verdrängt sich). Um dies zu verstehen, betrachten Sie einen in Python definierten Generator. Lassen Sie so etwas in Python als Generator bezeichnen, in C ++ als Coroutine. Ein Beispiel stammt von dieser </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Site</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_nums</span>():</span>
     num = <span class="hljs-number">0</span>
     <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
          <span class="hljs-keyword">yield</span> num<font></font>
          num = num + <span class="hljs-number">1</span>	<font></font>
<font></font>
nums = generate_nums()<font></font>
	<font></font>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<font></font>
     print(x)<font></font>
	<font></font>
     <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">9</span>:
          <span class="hljs-keyword">break</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So funktioniert dieser Code: Ein Funktionsaufruf </font></font><code>generate_nums</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">führt zur Erstellung eines Coroutine-Objekts. </font><font style="vertical-align: inherit;">Bei jedem Schritt der Aufzählung eines Coroutine-Objekts nimmt Coroutine selbst die Arbeit wieder auf und hält sie erst nach einem Schlüsselwort </font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Code an. </font><font style="vertical-align: inherit;">dann wird die nächste Ganzzahl aus der Sequenz zurückgegeben (die for-Schleife ist syntaktischer Zucker zum Aufrufen einer Funktion </font></font><code>next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die Coroutine wieder aufnimmt). </font><font style="vertical-align: inherit;">Der Code beendet die Schleife, indem er auf eine break-Anweisung stößt. </font><font style="vertical-align: inherit;">In diesem Fall endet Corutin nie, aber es ist leicht vorstellbar, dass Corutin das Ende erreicht und endet. </font><font style="vertical-align: inherit;">Wie wir sehen können, auf ein korutine anwendbaren </font></font><code>start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>suspend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>resume</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und schließlich,</font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">[Hinweis: C ++ bietet auch Erstellungs- und Zerstörungsvorgänge, die jedoch im Kontext eines intuitiven Verständnisses von Coroutine nicht wichtig sind].</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutinen als Bibliothek</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ist ungefähr klar, was Coroutinen sind. </font><font style="vertical-align: inherit;">Möglicherweise wissen Sie, dass es Bibliotheken zum Erstellen von Glasfaserobjekten gibt. </font><font style="vertical-align: inherit;">Die Frage ist, warum wir Coroutinen in Form einer speziellen Sprachfunktion benötigen und nicht nur eine Bibliothek, die mit Coroutinen funktioniert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier versuchen wir, diese Frage zu beantworten und den Unterschied zwischen gestapelten und stapellosen Coroutinen zu demonstrieren. </font><font style="vertical-align: inherit;">Dieser Unterschied ist der Schlüssel zum Verständnis von Corutin als Teil der Sprache.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutinen stapeln</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns zunächst diskutieren, was Stack-Coroutinen sind, wie sie funktionieren und warum sie als Bibliothek implementiert werden können. </font><font style="vertical-align: inherit;">Ihre Erklärung ist relativ einfach, da sie in Bezug auf das Design Streams ähneln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fiber- oder Stack-Corutin verfügt über einen separaten Stack, mit dem Funktionsaufrufe verarbeitet werden können. </font><font style="vertical-align: inherit;">Um genau zu verstehen, wie Coroutinen dieser Art funktionieren, betrachten wir Funktionsrahmen und Funktionsaufrufe kurz aus einer untergeordneten Perspektive. </font><font style="vertical-align: inherit;">Aber zuerst sprechen wir über die Eigenschaften von Fasern.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie haben ihren eigenen Stapel,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Lebensdauer der Fasern hängt nicht von dem Code ab, der sie aufruft (normalerweise haben sie einen benutzerdefinierten Scheduler).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fasern können von einem Faden gelöst und an einem anderen befestigt werden.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kooperative Planung (die Glasfaser muss sich entscheiden, zu einer anderen Glasfaser / einem anderen Planer zu wechseln),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kann nicht gleichzeitig im selben Thread arbeiten.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgenden Effekte ergeben sich aus den obigen Eigenschaften:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Umschalten des Kontexts der Fasern sollte vom Benutzer der Fasern und nicht vom Betriebssystem durchgeführt werden (außerdem kann das Betriebssystem die Faser freigeben und den Thread freigeben, in dem es funktioniert).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt kein echtes Datenrennen zwischen den beiden Fasern, da zu einem bestimmten Zeitpunkt nur eine von ihnen aktiv sein kann.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Glasfaserdesigner muss in der Lage sein, den richtigen Ort und die richtige Zeit auszuwählen, wo und wann es angebracht ist, die Rechenleistung an einen möglichen Planer oder Anrufer zurückzugeben.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Eingabe- / Ausgabeoperationen in der Faser müssen asynchron sein, damit andere Fasern ihre Aufgaben ausführen können, ohne sich gegenseitig zu blockieren.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns nun die Funktionsweise der Fasern genauer an und erklären zunächst, wie der Stapel an Funktionsaufrufen teilnimmt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Stapel ist also ein kontinuierlicher Speicherblock, der zum Speichern lokaler Variablen und Funktionsargumente benötigt wird. Noch wichtiger ist jedoch, dass nach jedem Funktionsaufruf (mit wenigen Ausnahmen) zusätzliche Informationen auf den Stapel übertragen werden, die der aufgerufenen Funktion mitteilen, wie sie zum Aufrufer zurückkehren und Prozessorregister wiederherstellen soll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige dieser Register haben spezielle Zuweisungen, und beim Aufrufen von Funktionen werden sie auf dem Stapel gespeichert. Dies sind die Register (im Fall der ARM-Architektur): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SP - Stapelzeiger </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LR - Kommunikationsregister </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PC - Programmzähler </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stapelzeiger</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(SP) ist ein Register, das die Adresse des Stapelanfangs in Bezug auf den aktuellen Funktionsaufruf enthält. Dank des vorhandenen Werts können Sie leicht auf Argumente und lokale Variablen verweisen, die auf dem Stapel gespeichert sind. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Kommunikationsregister</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (LR) ist beim Aufrufen von Funktionen sehr wichtig. Es speichert die Absenderadresse (die Adresse des anrufenden Teilnehmers), an der der Code ausgeführt wird, nachdem die Ausführung der aktuellen Funktion abgeschlossen ist. Beim Aufruf der Funktion wird der PC in LR gespeichert. Wenn die Funktion zurückkehrt, wird der PC mit LR wiederhergestellt. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Programmzähler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (PC) ist die Adresse des aktuell ausgeführten Befehls. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei jedem Aufruf einer Funktion wird die Liste der Links gespeichert, damit die Funktion weiß, wohin das Programm nach Abschluss zurückkehren soll.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/r2/yk/njr2ykw0o6hrsww5-uq3ybjjddg.png"><br>
 <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Verhalten der PC- und LR-Register beim Aufrufen und Zurückgeben einer Funktion</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Bei der Ausführung einer Stapelkoroutine verwenden die aufgerufenen Funktionen den zuvor zugewiesenen Stapel, um ihre Argumente und lokalen Variablen zu speichern. </font><font style="vertical-align: inherit;">Da alle Informationen zu jeder Funktion, die auf dem Stapel-Corutin aufgerufen wird, auf dem Stapel gespeichert sind, kann die Faser jede Funktion innerhalb dieses Corutins aussetzen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/r2/yk/njr2ykw0o6hrsww5-uq3ybjjddg.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, was auf diesem Bild passiert. </font><font style="vertical-align: inherit;">Erstens hat jede Faser und jeder Faden einen eigenen Stapel. </font><font style="vertical-align: inherit;">Die grüne Farbe zeigt Seriennummern an, die die Reihenfolge der Aktionen angeben.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein regulärer Funktionsaufruf innerhalb eines Threads. </font><font style="vertical-align: inherit;">Der Speicher wird auf dem Stapel zugewiesen.</font></font></li>
<li><b>   </b>.      .     ,      .    .       ,              . </li>
<li>  .</li>
<li><b> </b>.       .</li>
<li>    .</li>
<li>    .</li>
<li><b> </b>.    ,    , ,      .</li>
<li>    .</li>
<li>    .</li>
<li><b> </b> –     ,     . </li>
<li>        ,      .</li>
<li>    .      . </li>
<li>       .    :   ,    . ,          (  ) .</li>
<li>  ,   .</li>
<li>  .</li>
<li><b> </b>.   .     .    ,      .</li>
<li>     .</li>
<li>      , ,     .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Arbeit mit Stack-Coroutinen ist keine spezielle Sprachfunktion erforderlich, die deren Verwendung sicherstellt. </font><font style="vertical-align: inherit;">Die gesamte Stapelkorutiny kann mithilfe von Bibliotheken implementiert werden, und es gibt bereits Bibliotheken, die speziell für diesen Zweck entwickelt wurden: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swtch.com/libtask </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code.google.com/archive/p/libconcurrency </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.boost.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boost.Fiber </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.boost.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the Boost .Coroutine </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von all diesen Bibliotheken ist nur Boost C ++ und alle anderen sind C. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine ausführliche Beschreibung der Funktionsweise dieser Bibliotheken finden </font><font style="vertical-align: inherit;">Sie in der </font><font style="vertical-align: inherit;">Dokumentation. </font><font style="vertical-align: inherit;">Im Allgemeinen können Sie mit all diesen Bibliotheken einen separaten Stapel für Glasfaser erstellen und die Coroutine (auf Initiative des Anrufers) wieder aufnehmen und anhalten (von innen).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie ein Beispiel </font></font><code>Boost.Fiber</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><font></font>
	<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/intrusive_ptr.hpp&gt;</span></span><font></font>
	<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/fiber/all.hpp&gt;</span></span><font></font>
	<font></font>
<span class="hljs-function"><span class="hljs-keyword">inline</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">fn</span><span class="hljs-params">( <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-keyword">const</span>&amp; str, <span class="hljs-keyword">int</span> n)</span> </span>{
     <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; str &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
               boost::this_fiber::yield();<font></font>
     }<font></font>
}<font></font>
	<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
     <span class="hljs-keyword">try</span> {<font></font>
          boost::<span class="hljs-function">fibers::fiber <span class="hljs-title">f1</span><span class="hljs-params">( fn, <span class="hljs-string">"abc"</span>, <span class="hljs-number">5</span>)</span></span>;
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"f1 : "</span> &lt;&lt; f1.get_id() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
          f1.join();<font></font>
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"done."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
	<font></font>
          <span class="hljs-keyword">return</span> EXIT_SUCCESS;<font></font>
     } <span class="hljs-keyword">catch</span> ( <span class="hljs-built_in">std</span>::exception <span class="hljs-keyword">const</span>&amp; e) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"exception: "</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
     } <span class="hljs-keyword">catch</span> (...) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"unhandled exception"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
     }<font></font>
     <span class="hljs-keyword">return</span> EXIT_FAILURE;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Fall von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boost.Fiber</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verfügt die Bibliothek über einen integrierten Scheduler für Coroutine. </font><font style="vertical-align: inherit;">Alle Fasern laufen im gleichen Faden. </font><font style="vertical-align: inherit;">Da die Corutin-Planung kooperativ ist, muss die Faser zuerst entscheiden, wann die Steuerung an den Scheduler zurückgegeben werden soll. </font><font style="vertical-align: inherit;">In diesem Beispiel geschieht dies, wenn die Ertragsfunktion aufgerufen wird, wodurch die Coroutine angehalten wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da es keine andere Faser gibt, beschließt der Faserplaner immer, die Coroutine wieder aufzunehmen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stapellose Coroutinen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stapellose Coroutinen unterscheiden sich geringfügig in ihren Eigenschaften von stapelbaren. </font><font style="vertical-align: inherit;">Sie haben jedoch die gleichen grundlegenden Eigenschaften, da die nicht gestapelten Coroutinen ebenfalls gestartet und nach ihrer Suspendierung wieder aufgenommen werden können. </font><font style="vertical-align: inherit;">Coroutinen dieses Typs finden wir wahrscheinlich in C ++ 20. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir über die ähnlichen Eigenschaften von Corutin sprechen, können Coroutinen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corutin ist eng mit ihrem Anrufer verbunden: Wenn eine Coroutine aufgerufen wird, wird die Ausführung an sie übertragen und das Ergebnis der Coroutine wird zurück an den Anrufer übertragen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Lebensdauer eines Stapelkorutins entspricht der Lebensdauer seines Stapels. </font><font style="vertical-align: inherit;">Die Lebensdauer einer stapellosen Coroutine entspricht der Lebensdauer ihres Objekts.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei stapellosen Coroutinen ist es jedoch nicht erforderlich, einen ganzen Stapel zuzuweisen. Sie verbrauchen viel weniger Speicher als Stapelspeicher, aber dies liegt genau an einigen ihrer Einschränkungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie funktionieren sie, wenn sie dem Stapel keinen Speicher zuweisen? Wo in ihrem Fall alle Daten abgelegt werden, die auf dem Stapel gespeichert werden sollten, wenn mit Stapelkoroutinen gearbeitet wird. Antwort: auf dem Stapel des Anrufers.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Geheimnis stapelloser Coroutinen ist, dass sie sich nur an der obersten Funktion aufhängen können. Bei allen anderen Funktionen befinden sich ihre Daten auf dem Stapel der aufgerufenen Seite, sodass alle von Corutin aufgerufenen Funktionen ausgeführt werden müssen, bevor die Arbeit des Corutins unterbrochen wird. Alle Daten, die Coroutine benötigt, um seinen Status aufrechtzuerhalten, werden dynamisch auf dem Heap zugeordnet. Dies erfordert normalerweise einige lokale Variablen und Argumente, die viel kompakter sind als ein ganzer Stapel, der im Voraus zugewiesen werden müsste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich an, wie stapellose Corutine funktionieren: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ow/vc/nw/owvcnwldgczpxdmjorsjlrh3yvm.png"><br>
 <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fordern Sie ein stapelloses Corutin heraus</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, gibt es jetzt nur noch einen Stapel - dies ist der Hauptstapel des Threads. </font><font style="vertical-align: inherit;">Schauen wir uns Schritt für Schritt an, was in diesem Bild gezeigt wird (der Coroutine-Aktivierungsrahmen hier ist zweifarbig - Schwarz zeigt an, was auf dem Stapel gespeichert ist, und Blau - was auf dem Heap gespeichert ist).</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein regulärer Funktionsaufruf, dessen Frame auf dem Stapel gespeichert ist</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion erstellt eine Coroutine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Das heißt, es wird irgendwo auf dem Heap ein Aktivierungsrahmen dafür zugewiesen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normaler Funktionsaufruf.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rufen Sie Corutin an</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Corutins Körper sticht in einem regelmäßigen Stapel hervor. </font><font style="vertical-align: inherit;">Das Programm wird wie bei einer regulären Funktion ausgeführt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein regelmäßiger Funktionsaufruf von Coroutine. </font><font style="vertical-align: inherit;">Auch hier passiert immer noch alles auf dem Stapel [Hinweis: Sie können die Coroutine von diesem Punkt aus nicht anhalten, da dies nicht die oberste Funktion in der Coroutine ist]</font></font></li>
<li>       [:     .]</li>
<li>  –  ,        ,     .</li>
<li>  </li>
<li><b>  </b> –      ,        +     .</li>
<li>     5.</li>
<li>     6.</li>
<li><b> </b>.        .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist also offensichtlich, dass im zweiten Fall viel weniger Daten für alle Vorgänge zum Unterbrechen und Wiederaufnehmen der Arbeit von Coroutine gespeichert werden müssen. Coroutine kann jedoch nur sich selbst und nur von der obersten Funktion aus wieder aufnehmen und aussetzen. Alle Funktionsaufrufe und Coroutine erfolgen auf die gleiche Weise. Zwischen den Aufrufen müssen jedoch einige zusätzliche Daten gespeichert werden, und die Funktion muss in der Lage sein, zum Suspendierungspunkt zu springen und den Status lokaler Variablen wiederherzustellen. Es gibt keine weiteren Unterschiede zwischen dem Coroutine-Frame und dem Funktionsframe.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Corutin kann auch andere Coroutinen verursachen (in diesem Beispiel nicht gezeigt). </font><font style="vertical-align: inherit;">Bei stapellosen Coroutinen führt jeder Aufruf zur Zuweisung eines neuen Speicherplatzes für neue Coroutinendaten (bei einem wiederholten Aufruf von Coroutine kann der dynamische Speicher auch mehrmals zugewiesen werden). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Grund, warum Coroutinen eine dedizierte Sprachfunktion bereitstellen müssen, liegt darin, dass der Compiler entscheiden muss, welche Variablen den Status der Coroutine beschreiben, und stereotypen Code erstellen muss, um zu den Suspendierungspunkten zu springen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Praktische Anwendung von Corutin</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Coroutinen in C ++ können auf die gleiche Weise wie in anderen Sprachen verwendet werden. </font><font style="vertical-align: inherit;">Coroutinen vereinfachen die Rechtschreibung:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generatoren</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asynchroner Eingabe- / Ausgabecode </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lazy Computing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ereignisgesteuerte Anwendungen</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, dass Sie durch das Lesen dieses Artikels Folgendes herausfinden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum müssen Sie in C ++ Coroutinen als dedizierte Sprachfunktion implementieren?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist der Unterschied zwischen gestapelten und stapellosen Coroutinen?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">warum Coroutinen benötigt werden</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de491986/index.html">RemoteLoRa - Mehr als EIN / AUS</a></li>
<li><a href="../de491988/index.html">Was ist neu in Red Hat OpenShift 4.2 und 4.3?</a></li>
<li><a href="../de491990/index.html">Arbeit mit dem chinesischen Chip ADC Hx711 (Fazit)</a></li>
<li><a href="../de491992/index.html">Analystenentwicklung</a></li>
<li><a href="../de491994/index.html">Migration von Cocoapods zu Swift Package Manager</a></li>
<li><a href="../de492000/index.html">Produkt zuerst. Ausbrennen</a></li>
<li><a href="../de492002/index.html">Lichtabsorbierende Flügel: Das Geheimnis der Super Black Butterflies</a></li>
<li><a href="../de492004/index.html">Wie man vom Programmierer zum Manager heranwächst („Ich möchte die Herrin des Meeres sein“)</a></li>
<li><a href="../de492006/index.html">Die Leistung von PWA: Ein Videoüberwachungssystem mit einem JS-Code für ein neuronales Netzwerk mit 300 Leitungen</a></li>
<li><a href="../de492008/index.html">Ergebnisse der IT-Motivationsforschung: Sind Entwickler mit ihrer Arbeit zufrieden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>