<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçí üîî üíÇüèº Weitere Informationen zu Coroutinen in C ++ üë®üèª‚Äç‚öïÔ∏è ‚úäüèΩ üëè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Kollegen. 
 
 Im Rahmen der Entwicklung des C ++ 20-Themas stie√üen wir einmal auf einen ziemlich alten Artikel (September 2018) aus dem Yandex-H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Weitere Informationen zu Coroutinen in C ++</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/491996/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Kollegen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Rahmen der Entwicklung des C ++ 20-Themas stie√üen wir einmal auf einen ziemlich alten Artikel (September 2018) aus dem Yandex-Hublog mit dem Titel ‚Äû </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorbereitung auf C ++ 20. Coroutines TS mit einem echten Beispiel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äú. Es endet mit der folgenden sehr ausdrucksstarken Abstimmung: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/a-/m4/xn/a-m4xn5j3yjfy-yl2et7aeek7sc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚ÄûWarum nicht?‚Äú Wir haben einen Artikel von David Pilarski unter dem Titel ‚ÄûCoroutines Introduction‚Äú beschlossen und √ºbersetzt. Der Artikel wurde vor etwas mehr als einem Jahr ver√∂ffentlicht, aber hoffentlich finden Sie ihn trotzdem sehr interessant.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So ist es passiert. Nach vielen Zweifeln, Debatten und Vorbereitungen zu diesem Feature kam WG21 zu einer gemeinsamen Meinung dar√ºber, wie Coroutinen in C ++ aussehen sollten - und es ist sehr wahrscheinlich, dass sie in C ++ 20 enthalten sein werden. Da dies ein wichtiges Feature ist, denke ich, ist es Zeit, es bereits vorzubereiten und zu studieren Jetzt (wie Sie sich erinnern, gibt es noch mehr Module, Konzepte, Bereiche zu lernen ...) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele sind immer noch gegen Coroutine. Oft beschweren sie sich √ºber die Komplexit√§t ihrer Entwicklung, viele Anpassungspunkte und m√∂glicherweise eine suboptimale Leistung aufgrund einer m√∂glicherweise nicht optimierten Zuweisung des dynamischen Speichers (m√∂glicherweise;)).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parallel zur Entwicklung genehmigter (offiziell ver√∂ffentlichter) technischer Spezifikationen (TS) wurden sogar Versuche unternommen, einen anderen Corutin-Mechanismus parallel zu entwickeln. </font><font style="vertical-align: inherit;">Hier werden wir √ºber die Coroutinen sprechen, die in TS ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">technische Spezifikation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) beschrieben sind. </font><font style="vertical-align: inherit;">Ein alternativer Ansatz geh√∂rt wiederum zu Google. </font><font style="vertical-align: inherit;">Infolgedessen stellte sich heraus, dass der Google-Ansatz unter zahlreichen Problemen leidet, deren L√∂sung h√§ufig seltsame zus√§tzliche Funktionen von C ++ erfordert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende wurde beschlossen, eine von Microsoft entwickelte Version von Corutin (gesponsert von TS) zu √ºbernehmen. </font><font style="vertical-align: inherit;">Es geht um solche Coroutinen, die in diesem Artikel behandelt werden. </font><font style="vertical-align: inherit;">Beginnen wir also mit der Frage ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was sind Coroutinen?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Coroutinen gibt es bereits in vielen Programmiersprachen, beispielsweise in Python oder C #. </font><font style="vertical-align: inherit;">Coroutinen sind eine weitere M√∂glichkeit, asynchronen Code zu erstellen. </font><font style="vertical-align: inherit;">Wie sie sich von Flows unterscheiden, warum Coroutinen als dedizierte Sprachfunktion implementiert werden sollten und schlie√ülich, wie sie verwendet werden, wird in diesem Abschnitt erl√§utert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt ein ernstes Missverst√§ndnis dar√ºber, was Coroutinen sind. </font><font style="vertical-align: inherit;">Abh√§ngig von der Umgebung, in der sie verwendet werden, k√∂nnen sie wie folgt bezeichnet werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stapellose Coroutinen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutinen stapeln</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gr√ºne B√§che</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fasern</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gorutins</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die gute Nachricht: Stapelkorutine, gr√ºne Str√∂me, Fasern und Gorutine sind ein und dasselbe (aber sie werden manchmal auf unterschiedliche Weise verwendet). Wir werden sp√§ter in diesem Artikel dar√ºber sprechen und sie Fasern oder Stapelkoroutinen nennen. Die stapellose Coroutine weist jedoch einige Funktionen auf, die separat behandelt werden m√ºssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um Coroutinen zu verstehen, auch auf einer intuitiven Ebene, lernen wir kurz die Funktionen und (sagen wir es so) ‚Äûihre API‚Äú kennen. Die Standardmethode f√ºr die Arbeit mit ihnen besteht darin, anzurufen und zu warten, bis der Vorgang abgeschlossen ist:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>{
     <span class="hljs-keyword">return</span>; <span class="hljs-comment">//     </span><font></font>
}	<font></font>
foo(); <span class="hljs-comment">//   / </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Aufruf der Funktion ist es bereits unm√∂glich, die Arbeit anzuhalten oder fortzusetzen. Sie k√∂nnen nur zwei Operationen an Funktionen ausf√ºhren: </font></font><code>start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn die Funktion gestartet wird, m√ºssen Sie warten, bis sie abgeschlossen ist. Wenn die Funktion erneut aufgerufen wird, erfolgt ihre Ausf√ºhrung von Anfang an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Coroutinen ist die Situation anders. Sie k√∂nnen sie nicht nur starten und stoppen, sondern auch anhalten und fortsetzen. Sie unterscheiden sich immer noch von Kernfl√ºssen, da sich die Coroutinen selbst nicht verdr√§ngen (andererseits beziehen sich Coroutinen normalerweise auf den Fluss, und der Fluss verdr√§ngt sich). Um dies zu verstehen, betrachten Sie einen in Python definierten Generator. Lassen Sie so etwas in Python als Generator bezeichnen, in C ++ als Coroutine. Ein Beispiel stammt von dieser </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Site</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_nums</span>():</span>
     num = <span class="hljs-number">0</span>
     <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
          <span class="hljs-keyword">yield</span> num<font></font>
          num = num + <span class="hljs-number">1</span>	<font></font>
<font></font>
nums = generate_nums()<font></font>
	<font></font>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<font></font>
     print(x)<font></font>
	<font></font>
     <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">9</span>:
          <span class="hljs-keyword">break</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So funktioniert dieser Code: Ein Funktionsaufruf </font></font><code>generate_nums</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºhrt zur Erstellung eines Coroutine-Objekts. </font><font style="vertical-align: inherit;">Bei jedem Schritt der Aufz√§hlung eines Coroutine-Objekts nimmt Coroutine selbst die Arbeit wieder auf und h√§lt sie erst nach einem Schl√ºsselwort </font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Code an. </font><font style="vertical-align: inherit;">dann wird die n√§chste Ganzzahl aus der Sequenz zur√ºckgegeben (die for-Schleife ist syntaktischer Zucker zum Aufrufen einer Funktion </font></font><code>next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die Coroutine wieder aufnimmt). </font><font style="vertical-align: inherit;">Der Code beendet die Schleife, indem er auf eine break-Anweisung st√∂√üt. </font><font style="vertical-align: inherit;">In diesem Fall endet Corutin nie, aber es ist leicht vorstellbar, dass Corutin das Ende erreicht und endet. </font><font style="vertical-align: inherit;">Wie wir sehen k√∂nnen, auf ein korutine anwendbaren </font></font><code>start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>suspend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>resume</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und schlie√ülich,</font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">[Hinweis: C ++ bietet auch Erstellungs- und Zerst√∂rungsvorg√§nge, die jedoch im Kontext eines intuitiven Verst√§ndnisses von Coroutine nicht wichtig sind].</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutinen als Bibliothek</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ist ungef√§hr klar, was Coroutinen sind. </font><font style="vertical-align: inherit;">M√∂glicherweise wissen Sie, dass es Bibliotheken zum Erstellen von Glasfaserobjekten gibt. </font><font style="vertical-align: inherit;">Die Frage ist, warum wir Coroutinen in Form einer speziellen Sprachfunktion ben√∂tigen und nicht nur eine Bibliothek, die mit Coroutinen funktioniert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier versuchen wir, diese Frage zu beantworten und den Unterschied zwischen gestapelten und stapellosen Coroutinen zu demonstrieren. </font><font style="vertical-align: inherit;">Dieser Unterschied ist der Schl√ºssel zum Verst√§ndnis von Corutin als Teil der Sprache.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutinen stapeln</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns zun√§chst diskutieren, was Stack-Coroutinen sind, wie sie funktionieren und warum sie als Bibliothek implementiert werden k√∂nnen. </font><font style="vertical-align: inherit;">Ihre Erkl√§rung ist relativ einfach, da sie in Bezug auf das Design Streams √§hneln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fiber- oder Stack-Corutin verf√ºgt √ºber einen separaten Stack, mit dem Funktionsaufrufe verarbeitet werden k√∂nnen. </font><font style="vertical-align: inherit;">Um genau zu verstehen, wie Coroutinen dieser Art funktionieren, betrachten wir Funktionsrahmen und Funktionsaufrufe kurz aus einer untergeordneten Perspektive. </font><font style="vertical-align: inherit;">Aber zuerst sprechen wir √ºber die Eigenschaften von Fasern.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie haben ihren eigenen Stapel,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Lebensdauer der Fasern h√§ngt nicht von dem Code ab, der sie aufruft (normalerweise haben sie einen benutzerdefinierten Scheduler).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fasern k√∂nnen von einem Faden gel√∂st und an einem anderen befestigt werden.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kooperative Planung (die Glasfaser muss sich entscheiden, zu einer anderen Glasfaser / einem anderen Planer zu wechseln),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kann nicht gleichzeitig im selben Thread arbeiten.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgenden Effekte ergeben sich aus den obigen Eigenschaften:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Umschalten des Kontexts der Fasern sollte vom Benutzer der Fasern und nicht vom Betriebssystem durchgef√ºhrt werden (au√üerdem kann das Betriebssystem die Faser freigeben und den Thread freigeben, in dem es funktioniert).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt kein echtes Datenrennen zwischen den beiden Fasern, da zu einem bestimmten Zeitpunkt nur eine von ihnen aktiv sein kann.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Glasfaserdesigner muss in der Lage sein, den richtigen Ort und die richtige Zeit auszuw√§hlen, wo und wann es angebracht ist, die Rechenleistung an einen m√∂glichen Planer oder Anrufer zur√ºckzugeben.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Eingabe- / Ausgabeoperationen in der Faser m√ºssen asynchron sein, damit andere Fasern ihre Aufgaben ausf√ºhren k√∂nnen, ohne sich gegenseitig zu blockieren.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns nun die Funktionsweise der Fasern genauer an und erkl√§ren zun√§chst, wie der Stapel an Funktionsaufrufen teilnimmt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Stapel ist also ein kontinuierlicher Speicherblock, der zum Speichern lokaler Variablen und Funktionsargumente ben√∂tigt wird. Noch wichtiger ist jedoch, dass nach jedem Funktionsaufruf (mit wenigen Ausnahmen) zus√§tzliche Informationen auf den Stapel √ºbertragen werden, die der aufgerufenen Funktion mitteilen, wie sie zum Aufrufer zur√ºckkehren und Prozessorregister wiederherstellen soll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige dieser Register haben spezielle Zuweisungen, und beim Aufrufen von Funktionen werden sie auf dem Stapel gespeichert. Dies sind die Register (im Fall der ARM-Architektur): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SP - Stapelzeiger </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LR - Kommunikationsregister </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PC - Programmz√§hler </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stapelzeiger</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(SP) ist ein Register, das die Adresse des Stapelanfangs in Bezug auf den aktuellen Funktionsaufruf enth√§lt. Dank des vorhandenen Werts k√∂nnen Sie leicht auf Argumente und lokale Variablen verweisen, die auf dem Stapel gespeichert sind. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Kommunikationsregister</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (LR) ist beim Aufrufen von Funktionen sehr wichtig. Es speichert die Absenderadresse (die Adresse des anrufenden Teilnehmers), an der der Code ausgef√ºhrt wird, nachdem die Ausf√ºhrung der aktuellen Funktion abgeschlossen ist. Beim Aufruf der Funktion wird der PC in LR gespeichert. Wenn die Funktion zur√ºckkehrt, wird der PC mit LR wiederhergestellt. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Programmz√§hler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (PC) ist die Adresse des aktuell ausgef√ºhrten Befehls. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei jedem Aufruf einer Funktion wird die Liste der Links gespeichert, damit die Funktion wei√ü, wohin das Programm nach Abschluss zur√ºckkehren soll.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/r2/yk/njr2ykw0o6hrsww5-uq3ybjjddg.png"><br>
 <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Verhalten der PC- und LR-Register beim Aufrufen und Zur√ºckgeben einer Funktion</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Bei der Ausf√ºhrung einer Stapelkoroutine verwenden die aufgerufenen Funktionen den zuvor zugewiesenen Stapel, um ihre Argumente und lokalen Variablen zu speichern. </font><font style="vertical-align: inherit;">Da alle Informationen zu jeder Funktion, die auf dem Stapel-Corutin aufgerufen wird, auf dem Stapel gespeichert sind, kann die Faser jede Funktion innerhalb dieses Corutins aussetzen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/r2/yk/njr2ykw0o6hrsww5-uq3ybjjddg.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, was auf diesem Bild passiert. </font><font style="vertical-align: inherit;">Erstens hat jede Faser und jeder Faden einen eigenen Stapel. </font><font style="vertical-align: inherit;">Die gr√ºne Farbe zeigt Seriennummern an, die die Reihenfolge der Aktionen angeben.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein regul√§rer Funktionsaufruf innerhalb eines Threads. </font><font style="vertical-align: inherit;">Der Speicher wird auf dem Stapel zugewiesen.</font></font></li>
<li><b>   </b>.      .     ,      .    .       ,              . </li>
<li>  .</li>
<li><b> </b>.       .</li>
<li>    .</li>
<li>    .</li>
<li><b> </b>.    ,    , ,      .</li>
<li>    .</li>
<li>    .</li>
<li><b> </b> ‚Äì     ,     . </li>
<li>        ,      .</li>
<li>    .      . </li>
<li>       .    :   ,    . ,          (  ) .</li>
<li>  ,   .</li>
<li>  .</li>
<li><b> </b>.   .     .    ,      .</li>
<li>     .</li>
<li>      , ,     .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Arbeit mit Stack-Coroutinen ist keine spezielle Sprachfunktion erforderlich, die deren Verwendung sicherstellt. </font><font style="vertical-align: inherit;">Die gesamte Stapelkorutiny kann mithilfe von Bibliotheken implementiert werden, und es gibt bereits Bibliotheken, die speziell f√ºr diesen Zweck entwickelt wurden: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swtch.com/libtask </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code.google.com/archive/p/libconcurrency </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.boost.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boost.Fiber </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.boost.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the Boost .Coroutine </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von all diesen Bibliotheken ist nur Boost C ++ und alle anderen sind C. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine ausf√ºhrliche Beschreibung der Funktionsweise dieser Bibliotheken finden </font><font style="vertical-align: inherit;">Sie in der </font><font style="vertical-align: inherit;">Dokumentation. </font><font style="vertical-align: inherit;">Im Allgemeinen k√∂nnen Sie mit all diesen Bibliotheken einen separaten Stapel f√ºr Glasfaser erstellen und die Coroutine (auf Initiative des Anrufers) wieder aufnehmen und anhalten (von innen).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie ein Beispiel </font></font><code>Boost.Fiber</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><font></font>
	<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/intrusive_ptr.hpp&gt;</span></span><font></font>
	<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/fiber/all.hpp&gt;</span></span><font></font>
	<font></font>
<span class="hljs-function"><span class="hljs-keyword">inline</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">fn</span><span class="hljs-params">( <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-keyword">const</span>&amp; str, <span class="hljs-keyword">int</span> n)</span> </span>{
     <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; str &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
               boost::this_fiber::yield();<font></font>
     }<font></font>
}<font></font>
	<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
     <span class="hljs-keyword">try</span> {<font></font>
          boost::<span class="hljs-function">fibers::fiber <span class="hljs-title">f1</span><span class="hljs-params">( fn, <span class="hljs-string">"abc"</span>, <span class="hljs-number">5</span>)</span></span>;
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"f1 : "</span> &lt;&lt; f1.get_id() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
          f1.join();<font></font>
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"done."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
	<font></font>
          <span class="hljs-keyword">return</span> EXIT_SUCCESS;<font></font>
     } <span class="hljs-keyword">catch</span> ( <span class="hljs-built_in">std</span>::exception <span class="hljs-keyword">const</span>&amp; e) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"exception: "</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
     } <span class="hljs-keyword">catch</span> (...) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"unhandled exception"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
     }<font></font>
     <span class="hljs-keyword">return</span> EXIT_FAILURE;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Fall von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boost.Fiber</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verf√ºgt die Bibliothek √ºber einen integrierten Scheduler f√ºr Coroutine. </font><font style="vertical-align: inherit;">Alle Fasern laufen im gleichen Faden. </font><font style="vertical-align: inherit;">Da die Corutin-Planung kooperativ ist, muss die Faser zuerst entscheiden, wann die Steuerung an den Scheduler zur√ºckgegeben werden soll. </font><font style="vertical-align: inherit;">In diesem Beispiel geschieht dies, wenn die Ertragsfunktion aufgerufen wird, wodurch die Coroutine angehalten wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da es keine andere Faser gibt, beschlie√üt der Faserplaner immer, die Coroutine wieder aufzunehmen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stapellose Coroutinen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stapellose Coroutinen unterscheiden sich geringf√ºgig in ihren Eigenschaften von stapelbaren. </font><font style="vertical-align: inherit;">Sie haben jedoch die gleichen grundlegenden Eigenschaften, da die nicht gestapelten Coroutinen ebenfalls gestartet und nach ihrer Suspendierung wieder aufgenommen werden k√∂nnen. </font><font style="vertical-align: inherit;">Coroutinen dieses Typs finden wir wahrscheinlich in C ++ 20. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir √ºber die √§hnlichen Eigenschaften von Corutin sprechen, k√∂nnen Coroutinen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corutin ist eng mit ihrem Anrufer verbunden: Wenn eine Coroutine aufgerufen wird, wird die Ausf√ºhrung an sie √ºbertragen und das Ergebnis der Coroutine wird zur√ºck an den Anrufer √ºbertragen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Lebensdauer eines Stapelkorutins entspricht der Lebensdauer seines Stapels. </font><font style="vertical-align: inherit;">Die Lebensdauer einer stapellosen Coroutine entspricht der Lebensdauer ihres Objekts.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei stapellosen Coroutinen ist es jedoch nicht erforderlich, einen ganzen Stapel zuzuweisen. Sie verbrauchen viel weniger Speicher als Stapelspeicher, aber dies liegt genau an einigen ihrer Einschr√§nkungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie funktionieren sie, wenn sie dem Stapel keinen Speicher zuweisen? Wo in ihrem Fall alle Daten abgelegt werden, die auf dem Stapel gespeichert werden sollten, wenn mit Stapelkoroutinen gearbeitet wird. Antwort: auf dem Stapel des Anrufers.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Geheimnis stapelloser Coroutinen ist, dass sie sich nur an der obersten Funktion aufh√§ngen k√∂nnen. Bei allen anderen Funktionen befinden sich ihre Daten auf dem Stapel der aufgerufenen Seite, sodass alle von Corutin aufgerufenen Funktionen ausgef√ºhrt werden m√ºssen, bevor die Arbeit des Corutins unterbrochen wird. Alle Daten, die Coroutine ben√∂tigt, um seinen Status aufrechtzuerhalten, werden dynamisch auf dem Heap zugeordnet. Dies erfordert normalerweise einige lokale Variablen und Argumente, die viel kompakter sind als ein ganzer Stapel, der im Voraus zugewiesen werden m√ºsste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich an, wie stapellose Corutine funktionieren: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ow/vc/nw/owvcnwldgczpxdmjorsjlrh3yvm.png"><br>
 <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fordern Sie ein stapelloses Corutin heraus</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, gibt es jetzt nur noch einen Stapel - dies ist der Hauptstapel des Threads. </font><font style="vertical-align: inherit;">Schauen wir uns Schritt f√ºr Schritt an, was in diesem Bild gezeigt wird (der Coroutine-Aktivierungsrahmen hier ist zweifarbig - Schwarz zeigt an, was auf dem Stapel gespeichert ist, und Blau - was auf dem Heap gespeichert ist).</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein regul√§rer Funktionsaufruf, dessen Frame auf dem Stapel gespeichert ist</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion erstellt eine Coroutine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Das hei√üt, es wird irgendwo auf dem Heap ein Aktivierungsrahmen daf√ºr zugewiesen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normaler Funktionsaufruf.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rufen Sie Corutin an</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Corutins K√∂rper sticht in einem regelm√§√üigen Stapel hervor. </font><font style="vertical-align: inherit;">Das Programm wird wie bei einer regul√§ren Funktion ausgef√ºhrt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein regelm√§√üiger Funktionsaufruf von Coroutine. </font><font style="vertical-align: inherit;">Auch hier passiert immer noch alles auf dem Stapel [Hinweis: Sie k√∂nnen die Coroutine von diesem Punkt aus nicht anhalten, da dies nicht die oberste Funktion in der Coroutine ist]</font></font></li>
<li>       [:     .]</li>
<li>  ‚Äì  ,        ,     .</li>
<li>  </li>
<li><b>  </b> ‚Äì      ,        +     .</li>
<li>     5.</li>
<li>     6.</li>
<li><b> </b>.        .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist also offensichtlich, dass im zweiten Fall viel weniger Daten f√ºr alle Vorg√§nge zum Unterbrechen und Wiederaufnehmen der Arbeit von Coroutine gespeichert werden m√ºssen. Coroutine kann jedoch nur sich selbst und nur von der obersten Funktion aus wieder aufnehmen und aussetzen. Alle Funktionsaufrufe und Coroutine erfolgen auf die gleiche Weise. Zwischen den Aufrufen m√ºssen jedoch einige zus√§tzliche Daten gespeichert werden, und die Funktion muss in der Lage sein, zum Suspendierungspunkt zu springen und den Status lokaler Variablen wiederherzustellen. Es gibt keine weiteren Unterschiede zwischen dem Coroutine-Frame und dem Funktionsframe.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Corutin kann auch andere Coroutinen verursachen (in diesem Beispiel nicht gezeigt). </font><font style="vertical-align: inherit;">Bei stapellosen Coroutinen f√ºhrt jeder Aufruf zur Zuweisung eines neuen Speicherplatzes f√ºr neue Coroutinendaten (bei einem wiederholten Aufruf von Coroutine kann der dynamische Speicher auch mehrmals zugewiesen werden). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Grund, warum Coroutinen eine dedizierte Sprachfunktion bereitstellen m√ºssen, liegt darin, dass der Compiler entscheiden muss, welche Variablen den Status der Coroutine beschreiben, und stereotypen Code erstellen muss, um zu den Suspendierungspunkten zu springen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Praktische Anwendung von Corutin</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Coroutinen in C ++ k√∂nnen auf die gleiche Weise wie in anderen Sprachen verwendet werden. </font><font style="vertical-align: inherit;">Coroutinen vereinfachen die Rechtschreibung:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generatoren</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asynchroner Eingabe- / Ausgabecode </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lazy Computing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ereignisgesteuerte Anwendungen</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, dass Sie durch das Lesen dieses Artikels Folgendes herausfinden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum m√ºssen Sie in C ++ Coroutinen als dedizierte Sprachfunktion implementieren?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist der Unterschied zwischen gestapelten und stapellosen Coroutinen?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">warum Coroutinen ben√∂tigt werden</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de491986/index.html">RemoteLoRa - Mehr als EIN / AUS</a></li>
<li><a href="../de491988/index.html">Was ist neu in Red Hat OpenShift 4.2 und 4.3?</a></li>
<li><a href="../de491990/index.html">Arbeit mit dem chinesischen Chip ADC Hx711 (Fazit)</a></li>
<li><a href="../de491992/index.html">Analystenentwicklung</a></li>
<li><a href="../de491994/index.html">Migration von Cocoapods zu Swift Package Manager</a></li>
<li><a href="../de492000/index.html">Produkt zuerst. Ausbrennen</a></li>
<li><a href="../de492002/index.html">Lichtabsorbierende Fl√ºgel: Das Geheimnis der Super Black Butterflies</a></li>
<li><a href="../de492004/index.html">Wie man vom Programmierer zum Manager heranw√§chst (‚ÄûIch m√∂chte die Herrin des Meeres sein‚Äú)</a></li>
<li><a href="../de492006/index.html">Die Leistung von PWA: Ein Video√ºberwachungssystem mit einem JS-Code f√ºr ein neuronales Netzwerk mit 300 Leitungen</a></li>
<li><a href="../de492008/index.html">Ergebnisse der IT-Motivationsforschung: Sind Entwickler mit ihrer Arbeit zufrieden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>