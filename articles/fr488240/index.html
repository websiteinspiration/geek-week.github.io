<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👫 👩‍👩‍👦 ✋🏼 Un cycle sans fin qui n'était pas: l'histoire du bug du Saint Graal 🚩 👨🏾‍🏭 😊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il était une fois un jeu pour GBA appelé Hello Kitty Collection: Miracle Fashion Maker. C'était un jeu mignon basé sur la célèbre franchise Sanrio Hel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Un cycle sans fin qui n'était pas: l'histoire du bug du Saint Graal</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488240/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il était une fois un jeu pour GBA appelé Hello Kitty Collection: Miracle Fashion Maker. C'était un jeu mignon basé sur la célèbre franchise Sanrio Hello Kitty et développé par Imagineer. Mais sous le couvert d'un nom apparemment innocent était un problème insidieux. Pour une raison quelconque, ce jeu simple ne fonctionnait sur aucun émulateur GBA. Mais cela ne suffirait pas à lui seul à qualifier le problème d'insecte du Saint Graal. Comme tous les bogues du Saint Graal, ce bogue lui-même était complètement déroutant. L'explication était simple: à un moment donné de la séquence de lancement du jeu, il est tombé dans un cycle dont il n'est jamais </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sorti</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en attendant qu'une certaine valeur soit lue dans une mémoire qui </font><em><font style="vertical-align: inherit;">n'existe pas</font></em><font style="vertical-align: inherit;"> . Bien qu'il existe des bogues similaires dans de nombreux jeux, par exemple, dans l'intro populaire</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Legend of Zelda: The Minish Cap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ils s'appuient sur un comportement spécial causé par la lecture d'adresses mémoire non valides. </font><font style="vertical-align: inherit;">Mais ce cycle semblait violer un tel comportement. </font><font style="vertical-align: inherit;">Néanmoins, le jeu a fonctionné sur un équipement réel. </font><font style="vertical-align: inherit;">De plus, le même bug s'est produit lors du chargement d'une sauvegarde dans Sonic Pinball Party après un redémarrage à froid. </font><font style="vertical-align: inherit;">L'attente de ces adresses de mémoire invalides pourrait-elle être en quelque sorte erronée? </font><font style="vertical-align: inherit;">Mais si oui, comment?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/c85/547/1b0c8554787a8e54e1ac5c21c78d639c.png"></div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais c'est illégal, non?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Attendez une minute - si vous essayez d'accéder à une mémoire invalide, alors le jeu a juste besoin de planter, non? Une opération non résolue, </font><font style="vertical-align: inherit;">une erreur de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segmentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou une autre erreur </font><font style="vertical-align: inherit;">devrait se produire </font><font style="vertical-align: inherit;">. Droite? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, c'est plus comme Oui. Mais pas vraiment. Du moins pas sur la GBA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'architecture des processeurs ARM utilisés dans GBA, cet état erroné est appelé abandon de données et se produit uniquement lorsque vous essayez d'accéder à la mémoire pour laquelle le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gestionnaire de mémoire n'a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas attribué l'autorisation de lecture </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lorsque l'abandon des données se produit, le processeur termine ce qu'il faisait et passe au </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vecteur d'exception</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">affecté aux exceptions d'abandon des données. Ensuite, le système d'exploitation peut choisir l'une des solutions: tuer le processus en cours, affecter </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mémoire de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">défauts de page</font></a><font style="vertical-align: inherit;"> , laisser le processus gérer la situation, comme certains émulateurs JIT le font avec «fastmem», ou effectuer d'autres actions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment la GBA gère-t-elle les abandons de données? L'entrée du vecteur d'exception pour l'abandon des données se trouve dans la ROM de démarrage de la console GBA (ou, comme on l'appelle également, dans le BIOS). Si le GBA rencontre des données abandonnées, il essaie alors d'aller au gestionnaire DACS </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s'il existe, sinon le blocage se produit. </font><font style="vertical-align: inherit;">Aucun jeu commercial ne dispose de gestionnaires DACS. </font><font style="vertical-align: inherit;">Alors pourquoi ce jeu ne gèle-t-il pas? </font><font style="vertical-align: inherit;">Tout est très simple - GBA ne génère jamais d'abandon de données. </font><font style="vertical-align: inherit;">Il ne dispose pas d'un gestionnaire de mémoire (MMU) (ni même d'une unité de protection de la mémoire, comme dans DS), il continue donc de fonctionner et lit la mémoire invalide.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le bus mémoire entre en scène.</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f75/dd9/55f/f75dd955f33d3a974b417f401fe054a6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qu'est-ce que la mémoire invalide en général? Elle ressemble à quoi? C'est le principal problème. C'est une situation difficile: ce que le code lit dépend fortement de ce que le CPU a fait récemment, ou, plus précisément, de ce que le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bus mémoire a</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fait récemment </font><font style="vertical-align: inherit;">. En bref, lors de l'accès à une mémoire invalide, le CPU lit ce qui était le dernier sur le bus mémoire. Pour comprendre ce qui en découle, vous devez en apprendre un peu plus sur le bus mémoire et son fonctionnement.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un bus mémoire fait partie d'un circuit électronique qui connecte le CPU à tous les composants mémoire de la plateforme. Sur la GBA, plusieurs périphériques sont connectés au bus mémoire: RAM de travail, mémoire vidéo et bus de cartouches. Lorsque le CPU essaie d'accéder à la mémoire, il indique au bus mémoire à quelle adresse il doit accéder, puis le composant correspondant à cette adresse est activé. Ensuite, le composant place la valeur à cette adresse sur le bus, ce qui peut prendre plusieurs </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cycles </font><font style="vertical-align: inherit;">, puis la CPU peut enfin lire la valeur sur le bus. Dans le cas de la GBA, si aucun équipement n'est associé à l'adresse, aucune valeur n'est écrite sur le bus et la CPU lit toute valeur placée en </font><em><font style="vertical-align: inherit;">dernier</font></em><font style="vertical-align: inherit;"> sur le bus</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La situation peut varier de différentes manières, par exemple, si la lecture était de 16 bits et que le CPU essaie d'effectuer une lecture de 32 bits, mais en général, ce sera toujours une valeur provenant du bus. </font><font style="vertical-align: inherit;">Les développeurs appellent cette fonctionnalité «bus ouvert». </font><font style="vertical-align: inherit;">Plus tôt, j'ai écrit comment cela affecte les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">autres jeux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, il semble que tout ne soit pas si mal ... non?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez donc simplement mettre en cache le dernier accès à la mémoire? Et puis le ramener à nouveau? Dans le cas général, cette approche fonctionnera, mais il y a certaines difficultés. Tout d'abord, vous devez vous assurer que toutes les opérations d'accès à la mémoire sont dans le bon ordre. C'est plus compliqué qu'il n'y paraît, car le CPU accède à la mémoire avec chaque instruction pour obtenir l'instruction suivante dans le pipeline. Et en fait, dans le cas général *, la mémoire coincée dans le bus est la dernière instruction reçue. Cela simplifie le processus, car vous devez obtenir uniquement cette dernière valeur présélectionnée. Mais puisque la dernière valeur présélectionnée ne dépend que de l'endroit où nous exécutons actuellement à partir de la mémoire, elle devrait toujours être la même. Même si l'adresse reçue change alors qu'elle n'est pas valide,vous obtiendrez toujours la même mémoire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Euh ... Arrête. </font><font style="vertical-align: inherit;">Mais ce cycle existe et il ne peut pas être quitté si cette valeur est présélectionnée. </font><font style="vertical-align: inherit;">Alors, quoi de neuf? </font><font style="vertical-align: inherit;">S'il reçoit constamment l'instruction suivante, que se passe-t-il entre ces opérations? </font><font style="vertical-align: inherit;">J'ai essayé d'exécuter de telles boucles sans fin sur des ROM de test pour vérifier si, par exemple, la valeur pouvait mal tourner. </font><font style="vertical-align: inherit;">Cela peut certainement se produire si la valeur n'a pas été mise à jour récemment, mais la valeur est mise à jour dans chaque instruction, de sorte qu'elle n'a pas le temps d'être corrompue. </font><font style="vertical-align: inherit;">Mes tests n'ont jamais quitté la boucle. </font><font style="vertical-align: inherit;">J'ai fait quelque chose de différent que dans ces jeux, même si j'ai recréé le cycle exactement. </font><font style="vertical-align: inherit;">Qu'ai-je fait de mal?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pokémon Emerald et ACE, apparaissant uniquement sur le fer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avance rapide dans le temps, en janvier 2020. Le rapport de bogue à la Sonic Pinball Party à l'époque avait environ trois ans et demi. Dans d'autres émulateurs, il était connu depuis de nombreuses années. Je n'ai plus de théories de travail. A la fin de ce mois, un utilisateur avec le pseudo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merrp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a rejoint la communauté Discord de l'émulateur mGBA et a déclaré que Pokémon Emerald a un nouveau problème d'exécution de code arbitraire (ACE) qui ne fonctionne que sur le matériel. De plus, ce problème sera très probablement utilisé par les speedrunners, qui voudront peut-être pratiquer l'émulateur. De toute évidence, ce bogue est devenu une cible attrayante pour corriger l'erreur, mais il serait préférable que je le découvre avant la version 0.8.0. J'ai commencé à rechercher le problème et confirmé l'observation de merrp qu'il ne fonctionne que sur le matériel. Dans tous les émulateurs que j'ai essayés, le jeu était suspendu à un écran noir. Mais merrp m'a informé qu'il se bloque sur la lecture de la mémoire invalide dans une boucle, et j'ai réalisé que je ne pourrais probablement pas corriger l'erreur dans un proche avenir. C'est encore </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le même</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bug.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette fois, l'apprentissage des fonctions de bouclage m'a donné un avantage. Grâce au </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projet de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> décompilation </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">pokeemerald,</font></a><font style="vertical-align: inherit;"> j'ai pu facilement apporter des modifications ciblées à la fonction pour essayer de comprendre comment elle a réussi à sortir de la boucle. Une version simplifiée de cette boucle ressemble à ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint16_t</span> type = <span class="hljs-comment">/* ... */</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int32_t</span> i = <span class="hljs-number">0</span>; table[type][i] != <span class="hljs-number">0xFFFF</span>; ++i) {
	<span class="hljs-keyword">uint16_t</span> value = table[type][i] &amp; <span class="hljs-number">0xFE00</span>;
	<span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">0x7E00</span>) {
		<span class="hljs-keyword">break</span>;<font></font>
	}<font></font>
	<span class="hljs-comment">/* ... */</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La boucle effectue une tâche assez simple. Il existe un tableau de valeurs bidimensionnel. Sur chaque ligne de cette table de colonnes, la </font></font><code>type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boucle essaie d'abord de déterminer si la valeur est une certaine valeur sentinelle. Si c'est le cas, la boucle se termine. Sinon, il applique un masque à la valeur et vérifie si elle est supérieure à la valeur vérifiée. Sinon, ça descend le cycle. Dans un cas particulier de problème, la valeur </font></font><code>type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dépasse les limites du tableau, ce qui entraîne l'apparition d'un pointeur non valide. Cela signifie que lorsque vous essayez d'accéder à</font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cet élément de cette colonne inexistante, nous accèderons toujours à la mémoire invalide. Bien que le décalage de la table augmente à chaque itération de la boucle avant de revenir à la mémoire réelle, il peut nécessiter des centaines de millions de répétitions. Par conséquent, il est évident qu'il ne le fait pas. Alors, comment un programme sort-il d'une boucle?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour enquêter sur cela, j'ai changé le cycle et regardé ce qui se passerait si je sortais instantanément du cycle. </font><font style="vertical-align: inherit;">Tout s'est avéré assez simple: à ce moment, ACE a travaillé à la fois sur le matériel et l'émulateur, et rien ne s'est arrêté. </font><font style="vertical-align: inherit;">Au lieu de cela, j'ai essayé de définir la couleur de l'écran à la valeur que le programme lit lorsqu'il quitte la boucle et se fige afin que la couleur ne change pas. </font><font style="vertical-align: inherit;">J'ai recompilé le code et l'ai exécuté sur un vrai GBA. </font><font style="vertical-align: inherit;">Après quelques secondes de gel sur un écran noir, il est devenu une magnifique teinte bleue.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/eq/e_/md/eqe_md60cly8igmztq2_kd2yigc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TRÈS BLEU</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Mais l'émulateur était toujours accroché sur un écran noir. </font><font style="vertical-align: inherit;">Quelle valeur lira-t-il s'il lit la valeur reçue précédemment? </font><font style="vertical-align: inherit;">Au lieu de cela, il est devenu une turquoise sombre.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/sh/hf/6j/shhf6jyqkem0ulhbpzjuhc9hmi4.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fu.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
C'est, le programme, avant qu'il a </font><font style="vertical-align: inherit;">réussi à sortir du cycle, certainement passé au moins une fois. </font><font style="vertical-align: inherit;">Il s'est également avéré que le temps nécessaire pour s'échapper du cycle sur le fer varie. </font><font style="vertical-align: inherit;">Cela prenait généralement de 2 à 30 secondes. </font><font style="vertical-align: inherit;">Que se passe-t-il?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nouvelle théorie de travail</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, j'ai remarqué la différence entre ma ROM de test et le Pokémon Emerald lorsqu'elle était suspendue. Pokémon jouait de la musique. Sonic Pinball Party a également joué de la musique. Bonjour Kitty n'a pas joué de musique, mais ça m'a donné une idée. Que se passe-t-il si une interruption se produit entre la prélecture et le chargement des données? Le programme commence-t-il à extraire le vecteur d'interruption avant d'accéder à la mémoire invalide? J'ai rapidement créé une disposition pour cette situation dans mGBA, activé les interruptions dans la ROM de test et bien sûr, il est sorti de la boucle. Ensuite, j'ai essayé le même ROM de test sur le matériel et ... il n'est pas sorti de la boucle. Et donc la théorie est venue. Finalement, j'ai réalisé quelque chose. Je suis sûr que vous avez remarqué un astérisque ci-dessus, donc oui, il peut y avoir un événement entre la prélecture et l'accès à la mémoire,mais seulement si, entre la prélecture et l'accès à la mémoire invalide, le bus mémoire envoie une requête non pas au CPU, mais à autre chose.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai dit que le bus mémoire est contrôlé par le CPU. Pour la plupart, cela est vrai, mais il existe d'autres équipements importants qui ont également accès au bus mémoire contournant le processeur. Ce processus est appelé </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accès direct à la mémoire</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . J'ai parlé de DMA dans un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article précédent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , alors maintenant je ne vais pas entrer dans les principes de son travail. Si vous relisez l'article, vous remarquerez peut-être que j'ai dit que le processeur principal se met en pause pendant l'exécution de DMA. Cela signifie que lorsque DMA est en cours d'exécution, la valeur sur le bus sera désormais le dernier accès à la mémoire DMA. Ceci est principalement important si le DMA va au-delà de la mémoire réelle vers une région invalide; cependant, il duplique la dernière bonne valeur.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On sait depuis longtemps que si vous chargez une mémoire invalide dans DMA, vous obtiendrez la dernière valeur DMA, mais je l'ai implémentée depuis longtemps dans mGBA et je l'ai déjà oubliée. Quand j'ai vu cela dans le code d'accès pour une mémoire invalide lors de l'étude du bug, quelque chose a cliqué dans ma tête. Que faire si la valeur DMA persiste sur le bus pour une instruction? Si la première instruction après que DMA a fini de charger la mémoire invalide avant qu'elle n'obtienne la valeur suivante, alors en théorie, cela devrait conduire à recharger la valeur DMA. De plus, la lecture de musique en GBA utilise généralement le DMA pour transmettre la sortie audio. Pour une implémentation correcte de cela, un émulateur tact-précis est nécessaire qui peut bloquer le CPU au milieu de l'exécution de l'instruction, entre le début de l'instruction et l'accès à la mémoire, et l'émulation de la console GBA dans l'émulateur mGBA n'est pas précise.Et c'est quelque chose pour moi.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rappelle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Heureusement, j'ai réussi à contourner ce problème. </font><font style="vertical-align: inherit;">La solution est imparfaite, mais je peux maintenant comparer l'adresse CPU attendue pour l'instruction après DMA avec l'adresse CPU actuelle pour une charge non valide et utiliser une seule adresse au lieu de la valeur présélectionnée pour cette valeur DMA.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La décision tant attendue</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai activé les opérations DMA pour H-blank dans la ROM de test et les ai synchronisées avec V-blank afin que les synchronisations soient stables, l'ai exécuté sur le matériel, et ... cette fois cela a fonctionné! La ROM de test quitte constamment la boucle après le même nombre d'itérations lorsque la valeur DMA est lue sur le bus. J'avais raison! Pour une implémentation correcte de ceci dans mGBA, plusieurs tentatives ont été nécessaires, mais maintenant le programme quitte le cycle avec les mêmes résultats que sur le matériel. J'ai finalement obtenu une nuance de bleu sur mGBA. Hello Kitty a démarré. Enregistrer à la Sonic Pinball Party a gagné. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je l'ai fait.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce fut probablement le plus long temps que j'ai passé sur un seul bug. En trois ans, j'ai investi tellement de temps dans le débogage que j'ai perdu le compte, et je suis sûr que d'autres développeurs ont également fait face à des situations similaires dans leurs émulateurs. Sans cette perspicacité, cela aurait pu me prendre une autre année, voire plus, mais l'écran noir, sur lequel rien ne s'est passé, sauf pour jouer de la musique, est devenu cette tuile domino qui a conduit à l'effondrement de tout le problème. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant que la solution est trouvée, elle peut être implémentée dans d'autres émulateurs GBA, mettant fin à ce bogue. Le bogue sera corrigé dans mGBA 0.9.0, qui, je l'espère, sortira cette année et a déjà été corrigé dans les versions de test. Vous pouvez enfin jouer à Hello Kitty Collection: Miracle Fashion Maker. A moins, bien sûr, que vous ne le souhaitiez, il ne m'appartient pas de vous juger.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34c/74c/fce/34c74cfce5ebbb092c5a55c9293ec0cb.png" alt="image"></div><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous essayez d'exécuter de la mémoire qui n'a pas d'autorisations d'exécution, cela s'appelle abandon de la pré-lecture.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DACS (abréviation de Debugging and Communication System) fait partie du kit de développement GBA.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces cycles inactifs lors de la lecture du bus sont parfois appelés états d'attente.</font></font></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr488224/index.html">Ancien rédacteur en chef de TJ à propos des lettres du FSB: il y aura une histoire de "Durov 2.0", mais Habr deviendra la tête d'affiche</a></li>
<li><a href="../fr488228/index.html">TOP 10 des lieux et des idées pour un rendez-vous geek le 14 février</a></li>
<li><a href="../fr488230/index.html">Introduction au SSD. Partie 3. Facteur de forme</a></li>
<li><a href="../fr488232/index.html">technologie approximative: QATOK # 2</a></li>
<li><a href="../fr488234/index.html">Utilisation de QubesOS pour Windows 7</a></li>
<li><a href="../fr488242/index.html">Intégration du projet VueJS + TS avec SonarQube</a></li>
<li><a href="../fr488244/index.html">Comment réduire la surcharge lors de la gestion des exceptions en C ++</a></li>
<li><a href="../fr488246/index.html">VoiceOver sur iOS: chaque contrôle se comporte différemment</a></li>
<li><a href="../fr488250/index.html">À la question de Linux (L)</a></li>
<li><a href="../fr488252/index.html">Comment réduire le coût de développement de nouveaux produits à l'aide de SLS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>