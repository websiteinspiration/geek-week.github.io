<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏼 📮 ☕️ Python pour le testeur: comment les petits scripts pandas c aident à tester de grands ensembles de données 👩🏾‍🤝‍👩🏻 🔲 ♓️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je travaille en tant que testeur sur un projet dont l'essentiel est la collecte et le stockage de diverses données et la formation de divers rapports ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Python pour le testeur: comment les petits scripts pandas c aident à tester de grands ensembles de données</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486756/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je travaille en tant que testeur sur un projet dont l'essentiel est la collecte et le stockage de diverses données et la formation de divers rapports et téléchargements de fichiers sur leur base. </font><font style="vertical-align: inherit;">Lors de la génération de tels rapports, un grand nombre de conditions de sélection des données sont prises en compte et, par conséquent, lors des tests, vous devez beaucoup travailler avec les requêtes SQL dans la base de données. </font><font style="vertical-align: inherit;">Mais pour vérifier la sélection correcte des données et rechercher les données excédentaires / manquantes, cela ne suffit souvent pas, j'ai donc dû chercher des outils supplémentaires pour cela. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme j'avais déjà quelques connaissances de base en python, j'ai décidé d'essayer d'écrire de petits scripts qui nous permettraient de faire quelque chose avec les données existantes et ainsi de faciliter et d'accélérer le processus de test. </font><font style="vertical-align: inherit;">Dans cet article, je vais vous dire ce qui en est sorti.</font></font><br>
<a name="habracut"></a><br>
<b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conception d'un script de script</font></font></h3></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour écrire un script, vous devez comprendre exactement ce que le script doit faire, quelles données doivent être entrées et quelles données devraient être sorties. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exemples d'étapes pour le scénario:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous obtenons un fichier avec des données dans un certain format (ou plusieurs fichiers)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenir des données à partir d'un fichier / fichiers</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous sélectionnons les données nécessaires</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous effectuons certaines opérations sur les données</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous téléchargeons les données dans un fichier Excel, si nécessaire (généralement ce format est le plus pratique pour une analyse et un stockage approfondis)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, vous devez réfléchir à comment et où vous pouvez obtenir des informations. </font><font style="vertical-align: inherit;">Cela peut être un fichier créé manuellement avec des données, le téléchargement de données vers une interface utilisateur dans un fichier en tenant compte des filtres, un fichier avec des données d'analyse à l'aide d'un autre script, un fichier pour télécharger les résultats d'une requête SQL dans la base de données (vous pouvez rapidement télécharger des données vers un fichier csv à partir de la base de données), json -fichier ou fichier xml avec les données de la réponse à une demande à l'API, etc.</font></font><br>
<br>
<b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous écrivons des scripts en python en utilisant des pandas et d'autres bibliothèques</font></font></h3></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour écrire des scripts en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">python,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous devez installer un interpréteur et un IDE approprié. </font><font style="vertical-align: inherit;">Il est également préférable de créer un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">environnement virtuel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> distinct </font><font style="vertical-align: inherit;">pour ce projet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'utilise différentes bibliothèques pour les scripts, certaines d'entre elles sont des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bibliothèques python intégrées</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , certaines doivent être installées en plus:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pandas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une bibliothèque d'analyse de données. </font><font style="vertical-align: inherit;">Il vous permet de travailler avec des données de fichiers de différents formats, ainsi que de recevoir des données directement de la base de données à l'aide d'une requête SQL. </font><font style="vertical-align: inherit;">Les données des fichiers sont chargées dans des blocs de données (visuellement les mêmes tableaux que dans Excel), avec des données dans lesquelles vous pouvez déjà effectuer différentes opérations: combiner des données de différents blocs de données par analogie avec jointure / union en SQL, sélectionnez les données dont vous avez besoin sous certaines conditions, comparer les données dans différentes colonnes de la trame de données, etc.</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">openpyxl, xlrd</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - bibliothèques pour travailler avec Excel.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le cadre de script le plus simple pour travailler avec des données à partir de fichiers csv, json, Excel est le suivant:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#   pandas</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<font></font>
<font></font>
<span class="hljs-comment">#    csv-  -</span>
<span class="hljs-comment"># (        )</span>
<span class="hljs-comment">#       csv-     ";"</span>
df = pd.read_csv(<span class="hljs-string">'./csv_file.csv'</span>, sep=<span class="hljs-string">';'</span>, encoding=<span class="hljs-string">'utf-8'</span>)<font></font>
<font></font>
<span class="hljs-comment"># </span>
<span class="hljs-comment">#    json-  -</span>
<span class="hljs-comment"># (        )</span>
<span class="hljs-comment"># df = pd.read_json('./json_file.json', encoding='utf-8')</span><font></font>
<font></font>
<span class="hljs-comment"># </span>
<span class="hljs-comment">#    Excel-  -,     </span>
<span class="hljs-comment"># (        )</span>
<span class="hljs-comment"># file_excel = 'Excel_file.xlsx'</span>
<span class="hljs-comment"># df = pd.ExcelFile(file_excel).parse('1')</span><font></font>
<font></font>
<font></font>
<span class="hljs-comment">#  -     -  </span>
<span class="hljs-comment">#    - final_df</span><font></font>
<font></font>
<font></font>
<span class="hljs-comment">#    Excel-,  </span>
<span class="hljs-comment">#          </span>
<span class="hljs-comment"># (      )</span>
writer = pd.ExcelWriter(<span class="hljs-string">'.xlsx'</span>)<font></font>
final_df.to_excel(writer, <span class="hljs-string">'1'</span>)<font></font>
writer.save()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce script, les données d'un fichier du format souhaité sont chargées dans une trame de données, les données nécessaires sont sélectionnées et certaines opérations sont effectuées sur elles, puis les données sont écrites dans un nouveau fichier Excel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous devez travailler avec des données obtenues à la suite d'une requête SQL dans la base de données, vous ne pouvez pas les exporter vers un fichier csv, mais les placer immédiatement dans un bloc de données en exécutant une requête SQL dans la base de données dans le script lui-même:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#   pandas</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-comment">#      ,     PostgreSQL</span>
<span class="hljs-comment"># (   -    )</span>
<span class="hljs-keyword">import</span> psycopg2<font></font>
<font></font>
<span class="hljs-comment">#    </span>
conn = psycopg2.connect(dbname=<span class="hljs-string">'_'</span>, host=<span class="hljs-string">''</span>, port=<span class="hljs-string">''</span>,<font></font>
                        user=<span class="hljs-string">''</span>, password=<span class="hljs-string">''</span>)<font></font>
<font></font>
<span class="hljs-comment">#   SQL-</span>
q = <span class="hljs-string">"""select ... 
    from ... 
    where ..."""</span><font></font>
<font></font>
<span class="hljs-comment">#    -,  SQL-</span><font></font>
df = pd.read_sql_query(q, conn)<font></font>
<font></font>
<font></font>
<span class="hljs-comment">#  -     -  </span>
<span class="hljs-comment">#    - final_df</span><font></font>
<font></font>
<font></font>
<span class="hljs-comment">#    Excel-,  </span>
<span class="hljs-comment">#          </span>
<span class="hljs-comment"># (      )</span>
writer = pd.ExcelWriter(<span class="hljs-string">'.xlsx'</span>)<font></font>
final_df.to_excel(writer, <span class="hljs-string">'1'</span>)<font></font>
writer.save()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous devez obtenir des données à partir d'un fichier xml, vous pouvez utiliser les bibliothèques conçues à cet effet. </font><font style="vertical-align: inherit;">J'utilise la bibliothèque </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">intégrée ElementTree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque les données sont reçues dans une trame de données, vous pouvez immédiatement les combiner avec des données d'une autre trame de données (analogues de jointure ou d'union dans SQL) ou effectuer certaines opérations sur celles-ci, par exemple, supprimer les doublons, supprimer les lignes avec des valeurs vides dans certaines cellules , comparez les données dans plusieurs colonnes, sélectionnez les lignes / colonnes souhaitées, etc. </font><font style="vertical-align: inherit;">En savoir plus dans la documentation pour les pandas.</font></font><br>
<br>
<b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Options d'utilisation des scripts</font></font></h3></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant, nous activons l'outil principal du testeur et sélectionnons les données / fonctionnalités de notre projet, pour vérifier quels scripts seraient utiles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Des fichiers contenant une petite quantité de données de test générées à l'aide des données </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">générées</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ont été créés pour les scripts </font><font style="vertical-align: inherit;">. En réalité, les fichiers de données contiennent des dizaines de milliers de lignes et un grand nombre de colonnes. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scénario # 1</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Il y a trois fichiers au format csv avec des données. Pour chaque ligne de données, il existe un champ avec un identifiant unique. Les données de ces fichiers sont sélectionnées en tenant compte de certaines conditions et saisies dans un tableau de la base de données, puis ces données sont affichées dans un rapport sous la forme d'un tableau sur l'interface utilisateur. Il est possible de télécharger des données sur une interface utilisateur vers un fichier Excel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que les conditions de sélection des données pour un rapport à partir de fichiers source soient les suivantes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les fichiers peuvent avoir des doublons par identifiant, dans un rapport, un enregistrement avec le même identifiant ne doit être pris en compte qu'une seule fois (dans ce cas, nous sélectionnons simplement l'une des lignes avec cet identifiant dans les données).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les lignes avec des données manquantes dans la cellule de la colonne reg_date ne doivent pas être comptées.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, il peut y avoir plus de conditions de sélection, les données peuvent également être comparées aux données déjà présentes dans le système et seules les données entrecroisées par id seront affichées dans le rapport, mais par exemple nous ne prendrons en compte que les deux conditions indiquées ci-dessus.</font></font></li>
</ul><br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tâche du testeur:</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vérifier que les lignes avec les objets nécessaires sont correctement sélectionnées dans les fichiers source et que tous ces objets sont affichés dans le rapport sur l'interface utilisateur. </font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous composons un script pour le script:</font></font></u><br>
<br>
<ul>
<li>  -      csv-,     - (   union  SQL),      id,       reg_date.</li>
<li>  UI     Excel-,   ,       -.</li>
<li> (merge)   -   (   outer join  SQL)          Excel-   .</li>
<li>              ,   ,   -   ,      ,   UI.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le fichier final, les données ne contiendront qu'une seule colonne avec id, si les noms des colonnes dans des trames de données différentes coïncident, et il peut ne pas être clair quelles colonnes / lignes de quel fichier provenaient. </font><font style="vertical-align: inherit;">Par conséquent, soit je nomme les colonnes avec un identifiant unique par des noms différents dans les fichiers, soit j'ajoute une colonne distincte «Lignes d'un fichier de tel ou tel» à chaque fichier et y ajoute «Oui» - puis, lors de l'analyse du fichier Excel résultant, il est pratique de filtrer par cette colonne parce que </font><font style="vertical-align: inherit;">ils contiennent toujours une valeur et, en les filtrant, vous pouvez déjà comprendre quelles données divergent dans les colonnes correspondantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exemple de </font><font style="vertical-align: inherit;">données de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">example1_csv_1.csv</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fichier </font><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/of/5j/_u/of5j_us3u07uset3ljspbbwtrr4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exemple de </font><font style="vertical-align: inherit;">données de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">report_UI.xlsx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fichier </font><font style="vertical-align: inherit;">: A </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uh/xy/1s/uhxy1sygvioxbbhlksppdpsar_e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ressemble ce script python:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#   pandas</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<font></font>
<font></font>
<span class="hljs-comment">#     csv-    -</span>
<span class="hljs-comment"># (        )</span>
df_from_file1 = pd.read_csv(<span class="hljs-string">'./example1_csv_1.csv'</span>, sep=<span class="hljs-string">';'</span>, encoding=<span class="hljs-string">'utf-8'</span>,<font></font>
                            usecols=[<span class="hljs-string">'id'</span>, <span class="hljs-string">'name'</span>, <span class="hljs-string">'email'</span>, <span class="hljs-string">'reg_date'</span>])<font></font>
df_from_file2 = pd.read_csv(<span class="hljs-string">'./example1_csv_2.csv'</span>, sep=<span class="hljs-string">';'</span>, encoding=<span class="hljs-string">'utf-8'</span>,<font></font>
                            usecols=[<span class="hljs-string">'id'</span>, <span class="hljs-string">'name'</span>, <span class="hljs-string">'email'</span>,<span class="hljs-string">'reg_date'</span>])<font></font>
df_from_file3 = pd.read_csv(<span class="hljs-string">'./example1_csv_3.csv'</span>, sep=<span class="hljs-string">';'</span>, encoding=<span class="hljs-string">'utf-8'</span>,<font></font>
                            usecols=[<span class="hljs-string">'id'</span>, <span class="hljs-string">'name'</span>, <span class="hljs-string">'email'</span>, <span class="hljs-string">'reg_date'</span>])<font></font>
<font></font>
<span class="hljs-comment">#    -    - </span>
<span class="hljs-comment"># (   union  SQL)</span><font></font>
df_from_csv = pd.concat([df_from_file1, df_from_file2, df_from_file3]).\<font></font>
    reset_index(drop=<span class="hljs-literal">True</span>)<font></font>
print(df_from_csv)<font></font>
<font></font>
<span class="hljs-comment">#       </span>
df_from_csv.drop_duplicates(subset=<span class="hljs-string">'id'</span>, keep=<span class="hljs-string">'first'</span>, inplace=<span class="hljs-literal">True</span>)<font></font>
print(df_from_csv)<font></font>
<font></font>
<span class="hljs-comment">#     NaN ( )   reg_date</span><font></font>
df_from_csv = df_from_csv.dropna()<font></font>
print(df_from_csv)<font></font>
<font></font>
<span class="hljs-comment">#    Excel-   UI  -,</span>
<span class="hljs-comment">#       </span>
<span class="hljs-comment"># (        )</span>
file_excel = <span class="hljs-string">'report_UI.xlsx'</span>
df_from_excel = pd.ExcelFile(file_excel).parse(<span class="hljs-string">'1'</span>)<font></font>
print(df_from_excel)<font></font>
<font></font>
<span class="hljs-comment">#  -     - </span>
<span class="hljs-comment"># -       UI</span>
<span class="hljs-comment"># (   outer join  SQL)</span>
df = df_from_csv.merge(df_from_excel, left_on=<span class="hljs-string">'id'</span>, right_on=<span class="hljs-string">""</span>, how=<span class="hljs-string">'outer'</span>)<font></font>
print(df)<font></font>
<font></font>
<span class="hljs-comment">#     Excel-</span>
writer = pd.ExcelWriter(<span class="hljs-string">'.xlsx'</span>)<font></font>
df.to_excel(writer, <span class="hljs-string">'1'</span>)<font></font>
writer.save()<font></font>
</code></pre><br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limites:</font></font></u><br>
<br>
<ul>
<li>               (  ,       30 000 ).</li>
<li>   (  Excel)  /           ,            .</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scénario n ° 2</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
La section contient des données sous forme de tableau pour certains objets à partir d'une seule source. Le système recevra les données d'une deuxième source (intégration) et mettra à jour les données de table existantes avec ces données. Chaque enregistrement de la table correspond aux données d'un objet doté d'un identifiant unique. Si à partir d'une nouvelle source les données d'objet par identifiant coïncident avec les données d'un objet existant, alors tous les champs de l'enregistrement existant sont mis à jour avec les données de la nouvelle source (confirmées). Si la table n'a pas encore d'objet avec un identifiant de la deuxième source, un nouvel enregistrement est créé dans la table avec les données de la nouvelle source. Les données du deuxième système peuvent être téléchargées à l'avance dans un fichier json. </font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tâche du testeur:</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Préparez à l'avance un fichier contenant des données pour le test, afin qu'après la fin de l'implémentation, vérifiez que les enregistrements existants sont correctement mis à jour et qu'ils soient apposés avec un signe de confirmation dans la base de données, s'il y a correspondance par identifiant, et que de nouveaux enregistrements sont correctement créés et qu'ils sont marqués avec le signe de l'ajout à la base de données, si les enregistrements avec tels l'identifiant n'était pas encore. </font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous composons un script pour le script:</font></font></u><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous téléchargeons les données de la table de partition dans le fichier Excel sur l'interface utilisateur (si cela n'est pas possible, vous pouvez toujours exporter les données du résultat de la requête SQL utilisée dans le code pour sortir les données vers cette table sur l'interface utilisateur) et remplir les données de celui-ci dans le premier bloc de données .</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous obtenons le fichier json avec des données de la deuxième source et le chargeons dans la deuxième trame de données.</font></font></li>
<li>  (merge —    outer join  SQL)    -    -          Excel-,        .      ,        ,      .</li>
</ul><br>
<u>:</u><br>
<br>
<ul>
<li>               (  ,       30 000 ).</li>
<li>  json-     /  –           /,    -   json-   pandas        /.</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scénario 3</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Une demande est adressée à l'API système, en réponse à laquelle les données sur les objets au format json sont reçues. </font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tâche du testeur:</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comparer les données de la réponse à la demande à l'API avec les données du résultat de la requête SQL dans la base de données. </font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous composons un script pour le script:</font></font></u><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous exécutons la requête SQL dans la base de données, exportons les données du résultat de la requête vers un fichier csv, chargeons ces données dans le premier bloc de données.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous sauvegardons les données de la réponse à la demande à l'API dans le fichier json, chargeons les données du fichier dans la deuxième trame de données.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous combinons les données (fusion - par analogie avec la jointure externe en SQL) de deux trames de données reçues dans une nouvelle trame de données par un identifiant unique et en déchargeons les données dans un fichier Excel, dans lequel nous comparerons déjà les données par colonnes en utilisant les fonctions de Exceller</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou les données sur les colonnes dans le bloc de données générales peuvent être comparées à l'aide de pandas, tout en déchargeant les lignes avec les mêmes données / des données différentes dans les colonnes dans un nouveau bloc de données / fichier Excel pour analyse.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exemples de données du fichier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">example3_csv.csv</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zx/e6/xz/zxe6xzjff9vbfwgntsfqb-qyykc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exemples de données du fichier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">example3_json.json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="json hljs">[<font></font>
    {<font></font>
        <span class="hljs-attr">"id"</span>: <span class="hljs-string">"16421118-4116"</span>,
        <span class="hljs-attr">"name_json"</span>: <span class="hljs-string">"Tempor Consulting"</span>,
        <span class="hljs-attr">"email_json"</span>: <span class="hljs-string">"Nullam.lobortis.quam@***"</span>,
        <span class="hljs-attr">"tel_json"</span>: <span class="hljs-string">"1-821-805-****"</span>,
        <span class="hljs-attr">"reg_date_json"</span>: <span class="hljs-string">"12-11-16"</span>,
        <span class="hljs-attr">"city_json"</span>: <span class="hljs-string">"Natales"</span><font></font>
    },<font></font>
    {<font></font>
        <span class="hljs-attr">"id"</span>: <span class="hljs-string">"16040210-2206"</span>,
        <span class="hljs-attr">"name_json"</span>: <span class="hljs-string">"Odio Etiam Incorporated"</span>,
        <span class="hljs-attr">"email_json"</span>: <span class="hljs-string">"arcu@***"</span>,
        <span class="hljs-attr">"tel_json"</span>: <span class="hljs-string">"1-730-291-****"</span>,
        <span class="hljs-attr">"reg_date_json"</span>: <span class="hljs-string">"26-06-05"</span>,
        <span class="hljs-attr">"city_json"</span>: <span class="hljs-string">"Viddalba"</span><font></font>
    },<font></font>
...<font></font>
]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le script python ressemble à ceci:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#   pandas</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<font></font>
<font></font>
<span class="hljs-comment">#    csv-  -</span>
<span class="hljs-comment"># (        )</span>
<span class="hljs-comment">#       csv-     ";"</span>
df_from_csv = pd.read_csv(<span class="hljs-string">'./example3_csv.csv'</span>, sep=<span class="hljs-string">';'</span>, encoding=<span class="hljs-string">'utf-8'</span>)<font></font>
print(df_from_csv)<font></font>
<font></font>
<span class="hljs-comment">#    json-  -</span>
<span class="hljs-comment"># (        )</span>
df_from_json = pd.read_json(<span class="hljs-string">'./example3_json.json'</span>, encoding=<span class="hljs-string">'utf-8'</span>)<font></font>
print(df_from_json)<font></font>
<font></font>
<span class="hljs-comment">#  -    -</span>
<span class="hljs-comment"># (   outer join  SQL)</span>
df_csv_json = df_from_csv.merge(df_from_json, left_on=<span class="hljs-string">'id'</span>, <font></font>
                                right_on=<span class="hljs-string">"id"</span>, how=<span class="hljs-string">'outer'</span>)<font></font>
print(df_csv_json)<font></font>
<font></font>
<span class="hljs-comment">#    Excel-,   ,</span>
<span class="hljs-comment">#      -   ,</span>
<span class="hljs-comment">#          </span>
<span class="hljs-comment"># (      )</span>
<span class="hljs-comment"># writer = pd.ExcelWriter('.xlsx')</span>
<span class="hljs-comment"># df_csv_json.to_excel(writer, '1')</span>
<span class="hljs-comment"># writer.save()</span><font></font>
<font></font>
<span class="hljs-comment">#       </span>
<span class="hljs-comment"># (, name_csv  name_json) </span>
<span class="hljs-comment">#       Excel-  </span>
<span class="hljs-comment"># (        )</span>
unequal_data_df = df_csv_json.loc[df_csv_json[<span class="hljs-string">'name_csv'</span>] != <font></font>
                                  df_csv_json[<span class="hljs-string">'name_json'</span>]]<font></font>
unequal_data_df = unequal_data_df[[<span class="hljs-string">'id'</span>, <span class="hljs-string">'name_csv'</span>, <span class="hljs-string">'name_json'</span>]]<font></font>
print(unequal_data_df)<font></font>
<font></font>
writer = pd.ExcelWriter(<span class="hljs-string">'_name.xlsx'</span>)<font></font>
unequal_data_df.to_excel(writer, <span class="hljs-string">'1'</span>)<font></font>
writer.save()<font></font>
<font></font>
</code></pre><br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limites:</font></font></u><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous travaillez avec des fichiers avec un très grand nombre de lignes, vous devrez les diviser en fichiers séparés (ici, vous devez essayer, j'ai rarement des fichiers de plus de 30 000 lignes).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le fichier json a plusieurs niveaux d'imbrication d'objets / tableaux de données, alors à partir des niveaux internes, ils seront chargés dans la cellule en tant qu'objet / tableau, donc travailler avec des fichiers json avec pandas n'est pratique que pour les données sans imbrication excessive d'objets / tableaux.</font></font></li>
<li>       API         SQL-  ,             SQL-   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si la réponse à la demande adressée à l'API est au format xml, vous devrez d'abord analyser les données nécessaires à partir du fichier xml à l'aide d'ElementTree ou d'une autre bibliothèque, puis les charger dans le bloc de données. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scénario n ° 4</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sur l'interface utilisateur, un fichier xml contenant des données sur les objets est téléchargé, qui est généré à la volée à partir des données de la base de données sous certaines conditions (par exemple, les statuts, les dates, les années ou d'autres valeurs de paramètres pour les objets sont pris en compte). </font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tâche du testeur:</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comparer l'ID unique des identifiants des objets du fichier xml qui se trouvent dans l'attribut de la balise de société avec les identifiants des objets du résultat de la requête SQL dans la base de données. </font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous composons un script pour le script:</font></font></u><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous sauvegardons les données de la réponse à la demande à l'API dans le fichier xml, obtenons les données nécessaires à partir de ce fichier en utilisant la bibliothèque ElementTree, chargeons les données dans le premier bloc de données.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous exécutons la requête SQL dans la base de données, exportons les données du résultat de la requête vers le fichier csv, chargeons ces données dans le deuxième bloc de données.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous combinons les données (fusion - par analogie avec la jointure externe en SQL) de deux trames de données reçues dans une nouvelle trame de données par un identifiant unique et déchargeons les données de celui-ci dans un fichier Excel.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, ouvrez le fichier résultant et analysez les lignes de données.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exemples de données du fichier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">example4_csv.csv</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gb/zk/ou/gbzkou2bivh2gsnk6do0lthh1_g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exemples de données du fichier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">example4_xml.xml</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Un </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zh/x4/no/zhx4noe3virrsagqnaduwpqyp_w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
script python ressemble à ceci:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#   ElementTree</span>
<span class="hljs-keyword">from</span> xml.etree <span class="hljs-keyword">import</span> ElementTree
<span class="hljs-comment">#   pandas</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<font></font>
<font></font>
<span class="hljs-comment">#    xml-   </span>
<span class="hljs-comment"># (        )</span>
tree = ElementTree.parse(<span class="hljs-string">"example4_xml.xml"</span>)<font></font>
<font></font>
<span class="hljs-comment">#   </span><font></font>
root = tree.getroot()<font></font>
<font></font>
<span class="hljs-comment">#  ,     </span><font></font>
data_list = []<font></font>
i = <span class="hljs-number">1</span><font></font>
<font></font>
<span class="hljs-comment">#    -   id_type1  id_type2</span>
<span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> root.iter(<span class="hljs-string">"companies"</span>):
    <span class="hljs-keyword">for</span> child_1 <span class="hljs-keyword">in</span> child.iter(<span class="hljs-string">"company"</span>):<font></font>
            data_list.append({<span class="hljs-string">""</span>: i, <span class="hljs-string">"id"</span>: child_1.get(<span class="hljs-string">"id_type1"</span>)
                                                <span class="hljs-keyword">or</span> child_1.get(<span class="hljs-string">"id_type2"</span>), 
                              <span class="hljs-string">"  xml"</span>: <span class="hljs-string">""</span>})<font></font>
            i += <span class="hljs-number">1</span><font></font>
<font></font>
<span class="hljs-comment">#     data_list  -</span>
df_from_xml = pd.DataFrame.from_dict(data_list, orient=<span class="hljs-string">'columns'</span>)<font></font>
print(df_from_xml)<font></font>
<font></font>
<span class="hljs-comment">#    csv-  -</span>
df_from_csv = pd.read_csv(<span class="hljs-string">'./example4_csv.csv'</span>, sep=<span class="hljs-string">';'</span>, encoding=<span class="hljs-string">'utf-8'</span>)<font></font>
print(df_from_csv)<font></font>
<font></font>
<span class="hljs-comment">#  -   -</span>
<span class="hljs-comment"># (   outer join  SQL)</span>
df = df_from_csv.merge(df_from_xml, left_on=<span class="hljs-string">'id'</span>, right_on=<span class="hljs-string">"id"</span>, how=<span class="hljs-string">'outer'</span>)<font></font>
print(df)<font></font>
<font></font>
<span class="hljs-comment">#    Excel-</span>
<span class="hljs-comment">#          </span>
<span class="hljs-comment"># (      )</span>
writer = pd.ExcelWriter(<span class="hljs-string">'.xlsx'</span>)<font></font>
df.to_excel(writer, <span class="hljs-string">'1'</span>)<font></font>
writer.save()<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scénario 5</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dans l'interface utilisateur, la section affiche des données sur les objets sous la forme d'un tableau. </font><font style="vertical-align: inherit;">Il est possible de télécharger des données dans un fichier Excel. </font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tâche du testeur:</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comparer les données de la table de partition avec les données téléchargées dans le fichier Excel. </font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous composons un script pour le script:</font></font></u><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous demandons aux développeurs une requête SQL dans la base de données à partir du code qui est responsable de la sortie des données vers la table de partition sur l'interface utilisateur.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous exécutons cette requête SQL dans la base de données, téléchargeons les données dans un fichier csv, chargeons les données de celui-ci dans la première trame de données.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous téléchargeons les données de la table de partition vers le fichier Excel sur l'interface utilisateur et chargeons les données de celle-ci dans le deuxième bloc de données.</font></font></li>
<li>  (merge —    outer join  SQL)    -    -          Excel-,             Excel.</li>
<li>      -     pandas,      /      -/Excel-  .</li>
</ul><br>
<u>:</u><br>
<br>
<ul>
<li>    ,     Excel-  UI, ,         ,          .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Des scripts similaires peuvent également être utilisés simplement pour transférer des données de fichiers json ou de fichiers csv vers des fichiers Excel. </font><font style="vertical-align: inherit;">Ou, vous pouvez combiner les données de plusieurs fichiers Excel dans certaines colonnes et les télécharger dans un nouveau fichier Excel.</font></font><br>
<br>
<b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h3></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce ne sont que quelques exemples de la façon dont vous pouvez utiliser python + pandas pour accélérer le processus de test et trouver des bogues. </font><font style="vertical-align: inherit;">En fait, les pandas ont beaucoup plus de possibilités de travailler avec des données, vous pouvez en savoir plus à ce sujet dans la documentation de cette bibliothèque. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peut-être que votre projet a d'autres options pour utiliser de tels scripts et cet article vous aidera à commencer à les utiliser dans le travail des testeurs.</font></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr486744/index.html">Un correcteur de posture intelligent fabriqué au pays a été mis en vente. Nous avons regardé le nouveau produit - IBACK</a></li>
<li><a href="../fr486746/index.html">Écrivez, ne coupez pas. Ce que j'ai commencé à manquer dans les publications de Habr</a></li>
<li><a href="../fr486750/index.html">La série "For All Mankind": d'une histoire alternative à la poubelle</a></li>
<li><a href="../fr486752/index.html">Serveur Web WSGI unique utilisant ESP8266. Partie 1</a></li>
<li><a href="../fr486754/index.html">JIRA: règles pour la préparation en temps opportun de délicieux logiciels. TLDR 2: gestion des exigences</a></li>
<li><a href="../fr486760/index.html">Security Week 06: trackers publicitaires dans les applications mobiles</a></li>
<li><a href="../fr486762/index.html">Hébergement de chevet: la pratique effrayante de l'hébergement à domicile</a></li>
<li><a href="../fr486764/index.html">Bricolage Schema.org: personnalisation de la micro-mise en page sans programmeur</a></li>
<li><a href="../fr486766/index.html">Comment transférer toutes les transactions en ligne sur le marché de l'affacturage archaïque? Expérience de l'affacturage Sberbank</a></li>
<li><a href="../fr486768/index.html">Révision du panneau d'administration Webasyst</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>