<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐 🤾🏼 🚻 Otimização massiva de consultas no PostgreSQL. Kirill Borovikov (tensor) 👌🏿 🕜 🙋🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O relatório apresenta algumas abordagens que permitem monitorar o desempenho das consultas SQL quando existem milhões por dia e centenas de servidores...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Otimização massiva de consultas no PostgreSQL. Kirill Borovikov (tensor)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/487380/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O relatório apresenta algumas abordagens que permitem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">monitorar o desempenho das consultas SQL quando existem milhões por dia</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e centenas de servidores PostgreSQL controlados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quais soluções técnicas nos permitem processar com eficiência esse volume de informações e como facilita a vida de um desenvolvedor comum.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/5XKbFb-l5Do" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quem está interessado em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analisar problemas específicos e várias técnicas para otimizar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> consultas SQL e resolver problemas típicos de DBA no PostgreSQL </font><font style="vertical-align: inherit;">? Você </font><font style="vertical-align: inherit;">também pode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ler uma série de artigos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre este tópico.</font></font><br>
<a name="habracut"></a><br>
<img src="https://habrastorage.org/webt/rj/lq/ao/rjlqaolzkdl1dwerrz6q1f41exs.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meu nome é Kirill Borovikov, represento a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">empresa "Tensor"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Especificamente, sou especialista em trabalhar com bancos de dados em nossa empresa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hoje vou lhe dizer como estamos envolvidos na otimização de consultas, quando você não precisa "captar" o desempenho de uma única solicitação, mas sim resolver o problema em massa. Quando existem milhões de solicitações, e você precisa encontrar algumas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abordagens para resolver</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> esse grande problema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, o “tensor” para nossos milhões de clientes é o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VLSI - nosso aplicativo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : uma rede social corporativa, soluções de comunicação por vídeo, para gerenciamento interno e externo de documentos, sistemas de contabilidade para contabilidade e armazenamento ... Ou seja, uma “mega combinação” para gerenciamento de negócios integrado, que são mais de 100 projetos internos diferentes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para garantir que todos funcionem e se desenvolvam normalmente, temos 10 centros de desenvolvimento em todo o país, eles têm mais de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000 desenvolvedores</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trabalhamos com o PostgreSQL desde 2008 e acumulamos uma grande quantidade do que processamos - dados de clientes, estatísticos, analíticos, dados de sistemas externos de informação - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais de 400 TB</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Somente "em produção" existem cerca de 250 servidores e, no total, os servidores de banco de dados que monitoramos são cerca de 1000. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dx/sb/ej/dxsbejtgor4d4qc7u1cpkmxptx8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQL é uma linguagem declarativa. Você descreve não "como" algo deve funcionar, mas "o que" você deseja receber. O DBMS sabe como criar o JOIN - como conectar seus tablets, quais condições impor, o que será indexado, o que não ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alguns DBMSs aceitam dicas: "Não, conecte esses dois tablets em tal e qual fila", mas o PostgreSQL não. Esta é a posição consciente dos principais desenvolvedores: "Melhor terminarmos o otimizador de consultas do que permitir que os desenvolvedores usem algum tipo de dica". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas, apesar do PostgreSQL não permitir que "fora" se controle, ele perfeitamente permite que você </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">veja o que acontece "dentro"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quando você executa sua consulta e onde ela apresenta problemas. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/k_/wc/q0/k_wcq0dayliwb4tturtbl3dmyre.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, com quais problemas clássicos o desenvolvedor [chega ao DBA] normalmente? "Aqui nós cumprimos a solicitação, e </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tudo é lento</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tudo trava, algo acontece ... Algum tipo de problema!" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os motivos são quase sempre os mesmos:</font></font><br>
<br>
<ul>
<li><b>  </b><br>
: «   SQL  10   JOIN...» —  ,       «»,     .    ,       (10    FROM)   - . [<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>]</li>
<li><b> </b><br>
     PostgreSQL,     «»  ,   —     «»  .       10 ,   10 ,  PostgreSQL      ,      . [<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>]</li>
<li><b>«»  </b><br>
          ,     , ,   .  … -   ,       .</li>
<li><b></b><br>
 ,         (INSERT, UPDATE, DELETE) —    .</li>
</ul><br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... E para todo o resto, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">precisamos de um plano</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! Precisamos ver o que está acontecendo dentro do servidor. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c8/ni/rt/c8nirti-tkun1t6z4sxgpnwfwbw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O plano de execução de consultas para o PostgreSQL é uma árvore do algoritmo de execução de consultas em uma representação textual. É o algoritmo que, como resultado da análise do planejador, foi reconhecido como o mais eficaz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada nó da árvore é uma operação: extração de dados de uma tabela ou índice, construção de um bitmap, união de duas tabelas, união, interseção ou eliminação de amostras. O cumprimento da solicitação é uma passagem pelos nós desta árvore. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para obter um plano de consulta, a maneira mais fácil é executar a instrução </font></font><code>EXPLAIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Para obter todos os atributos reais, ou seja, execute uma consulta baseada em - </font></font><code>EXPLAIN (ANALYZE, BUFFERS) SELECT ...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O ponto negativo: quando você o executa, acontece "aqui e agora", portanto é adequado apenas para depuração local. Se você pegar um servidor com muita carga, que está sob um forte fluxo de alterações de dados, e você vê: “Sim! Aqui, somos mais lentos com o </font><font style="vertical-align: inherit;">pedido de </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xia</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . " Meia hora, uma hora atrás - enquanto você estava executando e recebendo essa solicitação dos logs, transportando-a novamente para o servidor, todos os dados e estatísticas foram alterados. Você o executa para depurar - e corre rapidamente! E você não pode entender o porquê, porque </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foi</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lento. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y9/-t/fu/y9-tfu3qhvhayjt86xoy02qy4ju.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para entender o que era exatamente no momento em que a solicitação é executada no servidor, as pessoas inteligentes escreveram o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">módulo auto_explain</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Está presente em quase todas as distribuições mais comuns do PostgreSQL, e você pode simplesmente ativá-lo no arquivo de configuração. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se ele entender que uma solicitação está sendo executada por mais tempo do que a borda que você lhe disse, ele tira um </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instantâneo do plano dessa solicitação e os grava juntos em um log</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qh/cs/c1/qhcsc15sgsaruhdj6ghcjggfz7c.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo parece estar bem agora, vamos ao log e vemos lá ... [passo de texto]. Mas não podemos dizer nada sobre ele, exceto pelo fato de esse ser um excelente plano, porque foram necessários 11ms para ser concluído. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo parece estar bem - mas nada está claro sobre o que realmente aconteceu. Além do tempo total, não vemos muito. Porque olhar para um texto simples como esse "latuha" é geralmente amado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas mesmo que seja amado, embora desconfortável, mas há mais problemas importantes:</font></font><br>
<br>
<ul>
<li>   <b>    </b>  .     ,       Index Scan    — ,     -  .    ,    «»   , CTE —     « ».</li>
<li> : ,    , —  <b>   </b>.      , ,    ,  ,      loops —   .         .    ,  ,        ,      — - « ».</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nessas circunstâncias, entenda "Quem é o elo mais fraco?" </font><font style="vertical-align: inherit;">quase irrealista. </font><font style="vertical-align: inherit;">Portanto, até os próprios desenvolvedores no "manual" escrevem que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Entender o plano é uma arte que precisa ser aprendida, experimentada ..."</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas temos 1000 desenvolvedores e cada um deles não passará essa experiência à cabeça. </font><font style="vertical-align: inherit;">Eu, você, ele - eles sabem, e alguém ali - não está mais lá. </font><font style="vertical-align: inherit;">Talvez ele aprenda, ou talvez não, mas ele precisa trabalhar agora - e onde ele conseguiria essa experiência.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planejar visualização</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, percebemos que, para lidar com esses problemas, precisamos de uma </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boa visualização do plano</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[artigo]</font></font></a><br>
<br>
<img src="https://habrastorage.org/webt/ev/nz/3g/evnz3gitzrva603ckfpd42ilzas.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Fomos os primeiros a “dar uma volta no mercado” - vamos procurar na Internet o que existe em geral. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Porém, descobriu-se que soluções relativamente "vivas" que são mais ou menos desenvolvidas, existem muito poucas - literalmente, uma coisa: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explica.depesz.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de Hubert Lubaczewski. </font><font style="vertical-align: inherit;">Na entrada do campo "feed", uma representação textual do plano mostra uma placa com os dados analisados:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tempo de trabalho do nó adequado</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tempo total em toda a subárvore</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o número de registros recuperados e que era estatisticamente esperado</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o próprio corpo do nó</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este serviço também tem a capacidade de compartilhar o arquivo de links. Você jogou seu plano lá e disse: "Ei, Vasya, aqui está um link para você, algo está errado aí". </font></font><br>
<br>
<img src="https://habrastorage.org/webt/od/td/ik/odtdikeo22jwnlaxmizq2jodns0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas existem alguns problemas menores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em primeiro lugar, uma enorme quantidade de copiar e colar. Você pega um pedaço do log, coloca-o lá e de novo e de novo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em segundo lugar, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não há análise da quantidade de dados lidos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - os próprios buffers que são exibidos </font></font><code>EXPLAIN (ANALYZE, BUFFERS)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aqui não vemos. Ele simplesmente não sabe como desmontar, entender e trabalhar com eles. Quando você lê muitos dados e entende que pode "decompor" incorretamente em um disco e armazenar em cache na memória, essas informações são muito importantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O terceiro ponto negativo é o desenvolvimento muito fraco deste projeto. Os commits são muito pequenos, é bom a cada seis meses e o código em Perl.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d9/zu/o6/d9zuo6g5etaeqqdpfsozjtzv09c.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas isso é tudo "letra", alguém poderia de alguma forma viver com ela, mas há uma coisa que nos afastou desse serviço. Estes são erros de análise Common Table Expression (CTE) e vários nós dinâmicos como InitPlan / SubPlan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você acredita nessa imagem, temos o tempo total de execução de cada nó individual maior que o tempo total de execução de toda a solicitação. É simples - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o tempo de geração deste CTE não foi subtraído do nó CTE Scan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Portanto, não sabemos mais a resposta correta, quanto a própria digitalização CTE levou. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uj/gt/8a/ujgt8auhv331ek_visf6ew7jslq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então percebemos que era hora de escrever a nossa - viva! Cada desenvolvedor diz: "Agora vamos escrever nossos próprios, será apenas super!"</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eles usaram uma pilha típica de serviços da Web: o núcleo do Node.js + Express, puxaram o Bootstrap e para belos diagramas - D3.js. </font><font style="vertical-align: inherit;">E nossas expectativas foram justificadas - recebemos o primeiro protótipo em duas semanas:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analisador de plano próprio</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ou seja, agora geralmente podemos analisar qualquer plano daqueles gerados pelo PostgreSQL.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">análise correta de nós dinâmicos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - CTE Scan, InitPlan, SubPlan</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">análise da distribuição de buffers</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - onde são lidas páginas de dados da memória, onde do cache local, onde do disco</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">visibilidade recebida</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Para que não esteja "no registro" que está "cavando", mas que você veja o "link mais fraco" imediatamente na imagem.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/ou/gb/jf/ougbjf30wnktdmvhpqtjj6feqto.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Temos algo parecido com isto - imediatamente com destaque de sintaxe. Mas geralmente nossos desenvolvedores não estão mais trabalhando com uma apresentação completa do plano, mas com uma apresentação mais curta. Afinal, já analisamos todos os dígitos e os jogamos para a esquerda e para a direita e deixamos apenas a primeira linha no meio, que tipo de nó é: geração CTE Scan, CTE ou Seq Scan por algum tipo de etiqueta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa visão abreviada é o que chamamos de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modelo de plano</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zg/do/j_/zgdoj_caxmbjnyiq_gkiy0cfniw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que mais seria conveniente? Seria conveniente ver qual a proporção de qual nó do tempo total é alocado para nós - e apenas "travar" o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gráfico de pizza</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao lado </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apontamos para o nó e vemos - conosco, verifica-se que o Seq Scan levou menos de um quarto do tempo todo e os restantes 3/4 fizeram o CTE Scan. Horror! Esta é uma pequena observação sobre a "taxa de incêndio" do CTE Scan, se você os usar ativamente em suas consultas. Eles não são muito rápidos - eles perdem mesmo para a varredura de tabela usual. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[artigo] </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[artigo]</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Mas, geralmente, esses diagramas são mais interessantes, mais complicados quando apontamos imediatamente para um segmento e vemos, por exemplo, que mais da metade do tempo todo, algumas Seq Scan “comiam”. Além disso, havia algum tipo de filtro dentro, vários registros foram lançados nele ... Você pode enviar essa foto diretamente para o desenvolvedor e dizer: “Vasya, tudo está ruim com você aqui! Entenda, olhe - algo está errado! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ul/4i/2q/ul4i2q_4iasvokxfdcwp7jd9tj0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Naturalmente, houve um "ancinho".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira coisa em que "pisaram" é o problema do arredondamento. O tempo do nó de cada indivíduo no plano é indicado com uma precisão de 1 μs. E quando o número de ciclos de nós excede, por exemplo, 1000 - após a execução, o PostgreSQL o dividiu "até", então, no cálculo reverso, obtemos o tempo total "em algum lugar entre 0,95 ms e 1,05 ms". Quando a conta é gasta em microssegundos - nada ainda, mas já há [mili] segundos - é necessário levar essas informações em consideração ao "desatar" recursos nos nós do plano "quem consumiu quem consumiu quem". </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fp/ds/f9/fpdsf9qkt6t_0q810uqhmrivc-k.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O segundo ponto, mais complexo, é a distribuição de recursos (esses mesmos buffers) entre nós dinâmicos. Isso nos custou as primeiras 2 semanas no protótipo mais o plus da semana 4.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conseguir esse problema é bastante simples - criamos um CTE e supostamente estamos lendo algo nele. De fato, o PostgreSQL é inteligente e não lê nada aqui. Então pegamos o primeiro registro dele, e os primeiros cem do mesmo CTE. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s5/fv/rg/s5fvrgut9bky4uqjgmawpm97ks4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nós olhamos para o plano e entendemos - estranho, temos 3 buffers (páginas de dados) "consumidos" no Seq Scan, outro 1 no CTE Scan e mais 2 no segundo CTE Scan. Ou seja, se tudo é simplesmente resumido, obtemos 6, mas da placa lemos apenas 3! O CTE Scan não lê nada de qualquer lugar, mas trabalha diretamente com a memória do processo. Ou seja, há claramente algo errado aqui! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, verifica-se que aqui todas as 3 páginas de dados solicitadas à Seq Scan, primeiro 1 solicitou a 1ª CTE Scan e, em seguida, a 2ª, e elas leram outras 2. Ou seja, 3 páginas foram lidas no total dados, não 6.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3q/5q/nh/3q5qnhygdtg3fh1os2fa-1kixhg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E essa imagem nos levou a entender que a implementação do plano não é mais uma árvore, mas apenas algum tipo de gráfico acíclico. </font><font style="vertical-align: inherit;">E nós temos um gráfico como este para entendermos "de onde ele veio". </font><font style="vertical-align: inherit;">Ou seja, aqui criamos um CTE a partir de pg_class e o solicitamos duas vezes, e quase o tempo todo nos levou ao ramo quando solicitamos pela segunda vez. </font><font style="vertical-align: inherit;">É claro que ler o 101º registro é muito mais caro do que apenas o 1º do tablet. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yg/kx/3o/ygkx3o3reytihnn6mkhyys3j7l8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nós expiramos por um tempo. </font><font style="vertical-align: inherit;">Eles disseram: “Agora, Neo, você sabe kung fu! </font><font style="vertical-align: inherit;">Agora nossa experiência está na sua tela. </font><font style="vertical-align: inherit;">Agora você pode usá-lo. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[artigo]</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consolidação de log</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nossos 1000 desenvolvedores deram um suspiro de alívio. Mas entendemos que só temos centenas de servidores de "batalha" e toda essa "copiar e colar" pelos desenvolvedores não é de todo conveniente. Percebemos que precisávamos coletá-lo nós mesmos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jl/1t/od/jl1todhk17wci0h_ekudinbrruw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, existe um módulo regular que pode coletar estatísticas; no entanto, ele também precisa ser ativado na configuração - este </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é o módulo pg_stat_statements</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mas ele não nos convinha. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em primeiro lugar, ele atribui </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueryId diferente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> às mesmas consultas em diferentes esquemas no mesmo banco de dados </font><font style="vertical-align: inherit;">. Ou seja, se você fizer primeiro </font></font><code>SET search_path = '01'; SELECT * FROM user LIMIT 1;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e depois </font></font><code>SET search_path = '02';</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a mesma solicitação, as estatísticas deste módulo terão entradas diferentes e não poderei coletar estatísticas gerais precisamente no contexto desse perfil de solicitação, sem levar em consideração os esquemas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O segundo ponto que nos impediu de usá-lo é a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falta de planos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ou seja, não há plano, apenas a solicitação em si. Vemos o que estava desacelerando, mas não entendemos o porquê. E aqui voltamos ao problema de um conjunto de dados que muda rapidamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E o último ponto é a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falta de "fatos"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ou seja, é impossível resolver uma instância específica de execução de consulta - ela não existe, existem apenas estatísticas agregadas. Embora seja possível trabalhar com isso, é simplesmente muito difícil. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7x/sr/ij/7xsrijw56i20-dz5oiw0hurx9aq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por isso, decidimos combater o “copiar e colar” e começamos a escrever um </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">colecionador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O coletor é conectado via SSH, "puxa" uma conexão segura para o servidor com o banco de dados usando o certificado e </font></font><code>tail -F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"se apega" ao arquivo de log. Então nesta sessão</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obtemos um "espelho" completo de todo o arquivo de log</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que o servidor gera. A carga no próprio servidor é mínima, porque não analisamos nada lá, simplesmente espelhamos o tráfego. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como já começamos a escrever a interface no Node.js, continuamos a escrever o coletor. E essa tecnologia valeu a pena, porque é muito conveniente usar JavaScript para trabalhar com dados de texto mal formatados, que é o log. E a própria infraestrutura do Node.js. como plataforma de back-end permite que você trabalhe fácil e convenientemente com conexões de rede e, de fato, com algum tipo de fluxo de dados.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dessa forma, "puxamos" duas conexões: a primeira é "ouvir" o próprio log e levá-lo para nós mesmos, e a segunda é perguntar periodicamente ao banco de dados. "Mas no log chegou que a placa com oid 123 estava bloqueada", mas não diz nada ao desenvolvedor, e seria bom perguntar ao banco de dados "afinal, o que é OID = 123?" Por isso, solicitamos periodicamente à base algo que ainda não sabemos em casa. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gt/vi/ft/gtviftgv1xepi43a7dayhn5-kxy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Você simplesmente não levou em consideração, existe uma espécie de abelha parecida com um elefante!" Começamos a desenvolver esse sistema quando queríamos monitorar 10 servidores. O mais crítico em nosso entendimento, sobre o qual houve alguns problemas difíceis de lidar. Porém, durante o primeiro trimestre, conseguimos cem para monitorar - porque o sistema "entrou", todo mundo queria, todo mundo estava confortável.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo isso deve ser adicionado, o fluxo de dados é grande, ativo. Na verdade, monitoramos com o que somos capazes de lidar - depois usamos. Também usamos o PostgreSQL como um data warehouse. Mas nada é mais rápido para "derramar" dados nele do que </font></font><code>COPY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ainda não há </font><font style="vertical-align: inherit;">operador </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas apenas "derramar" os dados não é realmente a nossa tecnologia. Como se você tiver cerca de 50 mil solicitações por segundo em uma centena de servidores, isso gerará 100-150 GB de logs por dia para você. Portanto, tivemos que "serrar" cuidadosamente a base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, fizemos o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">particionamento todos os dias</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , porque, em geral, ninguém está interessado na correlação entre os dias. Qual é a diferença que você teve ontem, se hoje à noite você lançou uma nova versão do aplicativo - e já algumas novas estatísticas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em segundo lugar, aprendemos (fomos forçados) </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a escrever muito, muito rapidamente usando</font></font><code>COPY</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ou seja, não apenas </font></font><code>COPY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">porque é mais rápido que </font></font><code>INSERT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas ainda mais rápido. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rm/ik/nj/rmiknjdu2ydi-yrbk7v369qe8eu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O terceiro ponto - tive </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que abandonar os gatilhos, respectivamente, e da Foreign Keys</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ou seja, não temos integridade absolutamente referencial. Porque se você possui uma tabela na qual existe um par de FK e diz na estrutura do banco de dados que “aqui está uma entrada de log refere-se a FK, por exemplo, um grupo de registros”, quando você a insere, o PostgreSQL não tem nada a fazer, exceto como tomar e executar honestamente </font></font><code>SELECT 1 FROM master_fk1_table WHERE ...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com o identificador que você está tentando inserir - apenas para verificar se essa entrada existe, se você não está "interrompendo" essa chave estrangeira com sua inserção.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em vez de um registro na tabela de destino e seus índices, obtemos mais uma leitura de todas as tabelas às quais ele se refere. E não precisamos disso: nossa tarefa é escrever o máximo possível e o mais rápido possível, com o mínimo de carga. Então FK - baixo! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O próximo ponto é agregação e hash. Inicialmente, eles foram implementados em nosso banco de dados - afinal, é conveniente, imediatamente, quando uma gravação chegar, fazer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"mais um"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em algum tipo de placa </font><b><font style="vertical-align: inherit;">diretamente no gatilho</font></b><font style="vertical-align: inherit;"> . É bom, conveniente, mas a mesma coisa é ruim - insira um registro, mas você é obrigado a ler e escrever outra coisa de outra tabela. Além disso, não apenas isso, leia e escreva - e também faça isso sempre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora imagine que você tem uma placa na qual simplesmente conta o número de solicitações que passaram em um host específico:</font></font><code>+1, +1, +1, ..., +1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. E você, em princípio, não precisa disso - tudo isso pode ser </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resumido na memória do coletor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e enviado ao banco de dados de cada vez </font></font><code>+10</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sim, sua integridade lógica pode "desmoronar" no caso de alguns problemas, mas esse é um caso quase irreal - porque você tem um servidor normal, ele possui uma bateria no controlador, um log de transações, um log no sistema de arquivos ... Em geral, não Vale a pena. Não vale a pena a perda de produtividade que você obtém devido ao trabalho de gatilhos / FK, os custos incorridos ao mesmo tempo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A mesma coisa com hash. Uma certa solicitação voa para você, você calcula um determinado identificador do banco de dados, escreve no banco de dados e depois diz a todos. Tudo está bem, até que, no momento da gravação, uma segunda pessoa chega até você que deseja gravá-la - e você tem uma trava, e isso já é ruim. Portanto, se você pode remover a geração de alguns IDs no cliente (em relação ao banco de dados), é melhor fazer isso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Éramos apenas ideais para usar o MD5 a partir do texto - uma solicitação, plano, modelo, ... Calculamos no lado do coletor e “despejamos” o ID já preparado no banco de dados. O comprimento do MD5 e o particionamento diário nos permitem não se preocupar com possíveis colisões. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/3c/yz/uz/3cyzuzpcxxmshllydd9cjcclc9i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas, para gravar tudo isso rapidamente, precisávamos modificar o próprio procedimento de gravação.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você costuma escrever dados? Temos algum tipo de conjunto de dados, decompomos-o em várias tabelas e depois COPY - primeiro na primeira, depois na segunda, na terceira ... É inconveniente, porque meio que escrevemos um fluxo de dados em três etapas seqüencialmente. Desagradável. É possível fazer mais rápido? Pode! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para fazer isso, basta decompor esses fluxos em paralelo. Acontece que temos erros, solicitações, modelos, bloqueios, voando em fluxos separados ... - e escrevemos tudo em paralelo. Para fazer isso, basta </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manter o canal COPY permanentemente aberto em cada tabela de destino individual</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/v_/0z/vvv_0zw3lqqoqoznvaaqpvm19wq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou seja, o coletor </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sempre tem um fluxo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em que posso escrever os dados necessários. Mas para que o banco de dados veja esses dados e alguém não fique travado nos bloqueios, aguardando a gravação desses dados, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COPY deve ser interrompido em uma determinada frequência</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Para nós, um período da ordem de 100ms acabou sendo o mais eficaz - feche e abra-o imediatamente novamente na mesma mesa. E se não temos um fluxo em alguns picos, fazemos o pool para um determinado limite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, descobrimos que, para esse perfil de carga, qualquer agregação quando os registros são coletados em pacotes é ruim. O mal clássico está </font></font><code>INSERT ... VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">além de 1000 registros. Porque neste momento você tem um pico de gravação na mídia, e todos os outros que estão tentando gravar algo no disco aguardam.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para se livrar de tais anomalias, simplesmente não agregue nada, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não faça buffer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">E se ocorrer buffer no disco (felizmente, a API Stream no Node.js permite que você descubra) - adie essa conexão. </font><font style="vertical-align: inherit;">É quando o evento chega até você, que é gratuito novamente - escreva para ele a partir da fila acumulada. </font><font style="vertical-align: inherit;">Enquanto isso, está ocupado - pegue o próximo de graça da piscina e escreva para ele. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de implementar essa abordagem para a gravação de dados, tínhamos aproximadamente operações de gravação em 4K e, dessa forma, reduzimos a carga em 4 vezes. </font><font style="vertical-align: inherit;">Agora eles cresceram mais 6 vezes devido a novas bases observáveis ​​- até 100 MB / s. </font><font style="vertical-align: inherit;">E agora armazenamos logs nos últimos 3 meses no valor de 10 a 15 TB, esperando que em apenas três meses qualquer desenvolvedor possa resolver qualquer problema.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entendemos os problemas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas apenas a coleta de todos esses dados é bom, útil, apropriado, mas não suficiente - é preciso entendê-los. </font><font style="vertical-align: inherit;">Porque são milhões de planos diferentes por dia. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/j6/kw/jg/j6kwjgsvci1xw-p_vgxpnq6ynag.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas milhões são incontroláveis, você deve primeiro fazer "menos". </font><font style="vertical-align: inherit;">E, antes de tudo, é necessário decidir como você organizará esse "menor". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Identificamos para nós três pontos-chave:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quem</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enviou essa solicitação, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ou seja, de qual aplicativo ele "voou": interface da web, back-end, sistema de pagamento ou algo mais.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onde</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> isso aconteceu </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em qual servidor específico. </font><font style="vertical-align: inherit;">Como se você tiver vários servidores em um aplicativo e, de repente, um "embotado" (porque o "disco apodreceu", "a memória vazou", outros problemas), será necessário abordar especificamente o servidor.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> problema se manifestou de uma maneira ou de outra</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para entender “quem” nos enviou a solicitação, usamos uma ferramenta regular - definindo uma variável de sessão: </font></font><code>SET application_name = '{bl-host}:{bl-method}';</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- envie o nome do host da lógica de negócios a partir da qual a solicitação é feita e o nome do método ou aplicativo que a iniciou. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de passarmos o "proprietário" da solicitação, ela deve ser exibida no log - para isso, configuramos a variável </font></font><code>log_line_prefix = ' %m [%p:%v] [%d] %r %a'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Qualquer pessoa interessada pode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ver no manual o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que isso tudo significa. </font><font style="vertical-align: inherit;">Acontece que vemos no log:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempo</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">identificadores de processo e transação</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nome base</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP da pessoa que enviou esta solicitação</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e nome do método</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/9d/ms/_c/9dms_cgsmfbpgjiyndalqfyadf8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então percebemos que não é muito interessante observar a correlação de uma solicitação entre servidores diferentes. Isso acontece com pouca frequência quando você tem um aplicativo que craps igualmente aqui e ali. Mas, mesmo que seja o mesmo, observe qualquer um desses servidores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, a seção </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“um servidor - um dia”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> acabou sendo suficiente para qualquer análise. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira seção analítica é o próprio </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"modelo"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - uma forma abreviada de apresentação do plano, livre de todos os indicadores numéricos. A segunda seção é o aplicativo ou método, e a terceira é o nó específico do plano que nos causou problemas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando passamos de instâncias específicas para modelos, recebemos imediatamente duas vantagens:</font></font><br>
<br>
<ul>
<li><b>     </b><br>
         ,    .</li>
<li><b></b><br>
 ,  «»   - ,       .     ,     -  , ,   ,    —   ,  ,     —     , ,      .    ,  ,  .</li>
</ul><br>
<br>
<img src="https://habrastorage.org/webt/_1/gb/is/_1gbissbzxhnibnhpb5kb5ebuuu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O restante dos métodos se baseia nos indicadores que extraímos do plano: quantas vezes esse padrão ocorreu, o tempo total e médio, quantos dados foram lidos no disco e quanto da memória ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você, por exemplo, acessa a página de análise por host, consulte - algo demais no disco para ler o começo. O disco no servidor não lida - e quem lê a partir dele? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E você pode classificar por qualquer coluna e decidir com o que irá lidar agora - com a carga no processador ou no disco ou com o número total de solicitações ... Classificadas, com aparência de "superior", reparadas - lançaram uma nova versão do aplicativo. </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[vídeo aula]</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
E imediatamente você pode ver diferentes aplicativos que vêm com o mesmo modelo de uma solicitação como</font></font><code>SELECT * FROM users WHERE login = 'Vasya'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Front-end, back-end, processamento ... E você se pergunta por que o usuário deve ler o processamento se não interagir com ele. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O caminho oposto é ver imediatamente a partir do aplicativo o que está fazendo. Por exemplo, um frontend é isso, isso, isso e isso uma vez por hora (apenas a linha do tempo ajuda). E imediatamente surge a pergunta - parece que não é da conta do front-end fazer algo uma vez por hora ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z7/z-/4n/z7z-4nvcqjd8xktjpl1ilja63eo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de algum tempo, percebemos que não tínhamos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estatísticas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> agregadas </font><b><font style="vertical-align: inherit;">em termos de nós do plano</font></b><font style="vertical-align: inherit;"> . Isolamos dos planos apenas os nós que fazem algo com os dados das próprias tabelas (os lê / escreve por índice ou não). De fato, em relação à figura anterior, apenas um aspecto é adicionado - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quantos registros esse nó trouxe para nós</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e quantos foram descartados (linhas removidas pelo filtro).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você não tem um índice adequado na placa, faz um pedido, ele passa além do índice, cai na Seq Scan ... você filtrou todos os registros, exceto um. E por que você precisa de 100 milhões de registros filtrados por dia, é melhor rolar o índice? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tk/bw/j9/tkbwj9b2v1gmeifbmblipiya86q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de examinar todos os planos por nós, percebemos que existem algumas estruturas típicas nos planos que provavelmente parecerão suspeitas. E seria bom dizer ao desenvolvedor: “Amigo, aqui você primeiro lê por índice, depois classifica e depois corta” - como regra, há um registro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo mundo que escreveu consultas com esse padrão provavelmente se deparou com: "Dê-me a última ordem para Vasya, a data dele". E se você não tiver um índice por data ou o índice usado não tiver uma data, siga exatamente esse "rake" e prossiga. .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas sabemos que esse é um "rake" - então por que não dizer imediatamente ao desenvolvedor o que ele deve fazer? </font><font style="vertical-align: inherit;">Assim, abrindo o plano agora, nosso desenvolvedor imediatamente vê uma bela imagem com avisos, onde é imediatamente informado: "Você tem problemas aqui e aqui, mas eles são resolvidos dessa maneira". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, a quantidade de experiência necessária para resolver problemas no início e agora caiu significativamente. </font><font style="vertical-align: inherit;">Aqui nós temos essa ferramenta.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/1g/g6/si1gg6ffbtpgsb3q2ew_cgudqa4.jpeg"></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt487380/">https://habr.com/ru/post/pt487380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt487370/index.html">Análise do mercado imobiliário com base em dados de msgr.ru</a></li>
<li><a href="../pt487372/index.html">Certificado IBM Data Science Professional certificado</a></li>
<li><a href="../pt487374/index.html">Paul Graham: Problemas na moda</a></li>
<li><a href="../pt487376/index.html">10 recursos angulares úteis que você perdeu</a></li>
<li><a href="../pt487378/index.html">Melhores servidores para pequenas empresas em 2020</a></li>
<li><a href="../pt487384/index.html">Profissão: desenvolvedor front-end</a></li>
<li><a href="../pt487386/index.html">Lista de verificação de adaptação como uma ferramenta de entrada suave</a></li>
<li><a href="../pt487388/index.html">Desenvolvimento natural: como passar do e-learning para a gestão do conhecimento</a></li>
<li><a href="../pt487390/index.html">Componentes da Web sem Shadow DOM</a></li>
<li><a href="../pt487392/index.html">O que a Magnet deseja saber sobre seus clientes?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>