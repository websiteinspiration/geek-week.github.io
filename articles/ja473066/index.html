<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚀 👩🏿‍🚀 🤛🏿 象限ツリーと衝突認識 🕵🏼 👷 👵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今週は短く、月曜日と火曜日は2D照明システムの開発を続けました。ツリーの象限（quadtree）の実装に費やした残りの時間。
 
 この記事では、設計の過程で生じた私の実装と考えを共有します。
 
 最初に、象限ツリーを実装することにした理由を述べる必要があります。
 
 Quadtreeは、スペー...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>象限ツリーと衝突認識</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473066/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59e/237/20a/59e23720a19b3109d80e62c6d2d539a0.gif" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今週は短く、月曜日と火曜日</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は2D照明システムの開発</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を続けました</font><font style="vertical-align: inherit;">。ツリーの象限（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quadtree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">の実装に費やした残りの時間</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、設計の過程で生じた私の実装と考えを共有します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、象限ツリーを実装することにした理由を述べる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quadtreeは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スペースパーティションデータ構造</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。他のデータ構造に対するその主な利点は、その適応性です。挿入、削除、検索時に優れたパフォーマンスを提供します。つまり、データが頻繁に変更される動的なコンテキストでこのツリーを使用できます。さらに、この構造は理解と実装が非常に簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スペースの分割が新しいトピックである場合は、</font><font style="vertical-align: inherit;">Robert Nistrom </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">による</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">記事を</font></a><font style="vertical-align: inherit;">読むことをお勧めします</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">あなたは象限の木についての詳細を知りたい場合は、読んで</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事を。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のゲームには、quadtreeを使用すると即座に成果が得られる領域があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">衝突を認識する場合、象限ツリーはブルートフォースメソッドよりもはるかに効率的です（すべてのペアをテストします）。</font><font style="vertical-align: inherit;">しかし、これは最も効果的なアプローチではありません。さまざまな手法とベンチマークの概要を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で検討できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、私の物理エンジンの最初のバージョンでは、それを使用しています。</font><font style="vertical-align: inherit;">おそらく後で、必要に応じて、より専門的なアルゴリズムを選択します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーングラフ、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クリッピングを行う場合、私はすべての可視のノードを検索する四分木を使用することができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">照明システム、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたは、光源の可視性のポリゴンを横断壁を見つけるために、四分木を使用することができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AIシステムでは、四分木を使用して、本質に近いすべてのオブジェクトまたは敵を検索できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、象限ツリーはかなり用途が広いです。</font><font style="vertical-align: inherit;">彼らはあなたのツールキットの良い補充になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事に示されているすべてのコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHubにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予備準備</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
四分木コードの詳細を説明する前に、幾何プリミティブ用の小さなクラスが必要</font><font style="vertical-align: inherit;">です。</font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポイントを定義する</font></font><code>Box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため</font><font style="vertical-align: inherit;">のクラスと、</font><font style="vertical-align: inherit;">長方形を指定するため</font><font style="vertical-align: inherit;">のクラス</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">どちらも定型になります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vector2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><code>Vector2</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ミニマルです。</font><font style="vertical-align: inherit;">含まれているのはコンストラクター</font></font><code>+</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">演算子だけ</font></font><code>/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">それだけで十分です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vector2</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
    T x;<font></font>
    T y;<font></font>
<font></font>
    <span class="hljs-keyword">constexpr</span> Vector2&lt;T&gt;(T X = <span class="hljs-number">0</span>, T Y = <span class="hljs-number">0</span>) <span class="hljs-keyword">noexcept</span> : x(X), y(Y)<font></font>
    {<font></font>
<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">constexpr</span> Vector2&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> Vector2&lt;T&gt;&amp; other) <span class="hljs-keyword">noexcept</span><font></font>
    {<font></font>
        x += other.x;<font></font>
        y += other.y;<font></font>
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">constexpr</span> Vector2&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>/=(T t) <span class="hljs-keyword">noexcept</span><font></font>
    {<font></font>
        x /= t;<font></font>
        y /= t;<font></font>
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> Vector2&lt;T&gt; <span class="hljs-keyword">operator</span>+(Vector2&lt;T&gt; lhs, <span class="hljs-keyword">const</span> Vector2&lt;T&gt;&amp; rhs) <span class="hljs-keyword">noexcept</span><font></font>
{<font></font>
    lhs += rhs;<font></font>
    <span class="hljs-keyword">return</span> lhs;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> Vector2&lt;T&gt; <span class="hljs-keyword">operator</span>/(Vector2&lt;T&gt; vec, T t) <span class="hljs-keyword">noexcept</span><font></font>
{<font></font>
    vec /= t;<font></font>
    <span class="hljs-keyword">return</span> vec;<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボックス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><code>Box</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それほど複雑で</font><font style="vertical-align: inherit;">はあり</font><font style="vertical-align: inherit;">ません。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
    T left;<font></font>
    T top;<font></font>
    T width; <span class="hljs-comment">// Must be positive</span>
    T height; <span class="hljs-comment">// Must be positive</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Box</span><span class="hljs-params">(T Left = <span class="hljs-number">0</span>, T Top = <span class="hljs-number">0</span>, T Width = <span class="hljs-number">0</span>, T Height = <span class="hljs-number">0</span>)</span> <span class="hljs-keyword">noexcept</span> :
        <span class="hljs-title">left</span><span class="hljs-params">(Left)</span>, <span class="hljs-title">top</span><span class="hljs-params">(Top)</span>, <span class="hljs-title">width</span><span class="hljs-params">(Width)</span>, <span class="hljs-title">height</span><span class="hljs-params">(Height)</span>
    </span>{<font></font>
<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Box</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Vector2&lt;T&gt;&amp; position, <span class="hljs-keyword">const</span> Vector2&lt;T&gt;&amp; size)</span> <span class="hljs-keyword">noexcept</span> :
        <span class="hljs-title">left</span><span class="hljs-params">(position.x)</span>, <span class="hljs-title">top</span><span class="hljs-params">(position.y)</span>, <span class="hljs-title">width</span><span class="hljs-params">(size.x)</span>, <span class="hljs-title">height</span><span class="hljs-params">(size.y)</span>
    </span>{<font></font>
<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">getRight</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
    </span>{
        <span class="hljs-keyword">return</span> left + width;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">getBottom</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
    </span>{
        <span class="hljs-keyword">return</span> top + height;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> Vector2&lt;T&gt; <span class="hljs-title">getTopLeft</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
    </span>{
        <span class="hljs-keyword">return</span> Vector2&lt;T&gt;(left, top);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> Vector2&lt;T&gt; <span class="hljs-title">getCenter</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
    </span>{
        <span class="hljs-keyword">return</span> Vector2&lt;T&gt;(left + width / <span class="hljs-number">2</span>, top + height / <span class="hljs-number">2</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> Vector2&lt;T&gt; <span class="hljs-title">getSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
    </span>{
        <span class="hljs-keyword">return</span> Vector2&lt;T&gt;(width, height);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Box&lt;T&gt;&amp; box)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
    </span>{
        <span class="hljs-keyword">return</span> left &lt;= box.left &amp;&amp; box.getRight() &lt;= getRight() &amp;&amp;<font></font>
            top &lt;= box.top &amp;&amp; box.getBottom() &lt;= getBottom();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">intersects</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Box&lt;T&gt;&amp; box)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
    </span>{
        <span class="hljs-keyword">return</span> !(left &gt;= box.getRight() || getRight() &lt;= box.left ||<font></font>
            top &gt;= box.getBottom() || getBottom() &lt;= box.top);<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの便利なゲッターが含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに興味深いのは</font></font><code>contains</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、長方形が別の長方形の内側にあるかどうかをチェック</font><font style="vertical-align: inherit;">するメソッド</font><font style="vertical-align: inherit;">と、長方形が別</font></font><code>intersects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の長方形と交差するかどうか</font><font style="vertical-align: inherit;">をチェック</font><font style="vertical-align: inherit;">するメソッド</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">含まれていること</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">挿入や削除の</font><font style="vertical-align: inherit;">際</font><font style="vertical-align: inherit;">、および</font><font style="vertical-align: inherit;">交差点を認識</font><font style="vertical-align: inherit;">する際に</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用し</font><font style="vertical-align: inherit;">ます。</font></font><code>contains</code><font style="vertical-align: inherit;"></font><code>intersects</code><font style="vertical-align: inherit;"></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クワッドツリー</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがクラスのスケルトン</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><code>Quadtree</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> GetBox, <span class="hljs-keyword">typename</span> Equal = <span class="hljs-built_in">std</span>::equal_to&lt;T&gt;, <span class="hljs-keyword">typename</span> Float = <span class="hljs-keyword">float</span>&gt;<font></font>
class Quadtree<font></font>
{<font></font>
    <span class="hljs-keyword">static_assert</span>(<span class="hljs-built_in">std</span>::is_convertible_v&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">invoke_result_t</span>&lt;GetBox, <span class="hljs-keyword">const</span> T&amp;&gt;, Box&lt;Float&gt;&gt;,
        <span class="hljs-string">"GetBox must be a callable of signature Box&lt;Float&gt;(const T&amp;)"</span>);
    <span class="hljs-keyword">static_assert</span>(<span class="hljs-built_in">std</span>::is_convertible_v&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">invoke_result_t</span>&lt;Equal, <span class="hljs-keyword">const</span> T&amp;, <span class="hljs-keyword">const</span> T&amp;&gt;, <span class="hljs-keyword">bool</span>&gt;,
        <span class="hljs-string">"Equal must be a callable of signature bool(const T&amp;, const T&amp;)"</span>);
    <span class="hljs-keyword">static_assert</span>(<span class="hljs-built_in">std</span>::is_arithmetic_v&lt;Float&gt;);<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    Quadtree(<span class="hljs-keyword">const</span> Box&lt;Float&gt;&amp; box, <span class="hljs-keyword">const</span> GetBox&amp; getBox = GetBox(),
        <span class="hljs-keyword">const</span> Equal&amp; equal = Equal()) :<font></font>
        mBox(box), mRoot(<span class="hljs-built_in">std</span>::make_unique&lt;Node&gt;()), mGetBox(getBox), mEqual(equal)<font></font>
    {<font></font>
<font></font>
    }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> Threshold = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>(<span class="hljs-number">16</span>);
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> MaxDepth = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>(<span class="hljs-number">8</span>);<font></font>
<font></font>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
    {</span>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Node&gt;, <span class="hljs-number">4</span>&gt; children;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; values;<font></font>
    };<font></font>
<font></font>
    Box&lt;Float&gt; mBox;<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Node&gt; mRoot;<font></font>
    GetBox mGetBox;<font></font>
    Equal mEqual;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLeaf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Node* node)</span> <span class="hljs-keyword">const</span>
    </span>{
        <span class="hljs-keyword">return</span> !<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">bool</span>&gt;(node-&gt;children[<span class="hljs-number">0</span>]);<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、</font></font><code>Quadtree</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはテンプレートクラスです。</font><font style="vertical-align: inherit;">これにより、最初に説明したように、クラスをさまざまな目的に使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テンプレートオプション：</font></font><br>
<br>
<ul>
<li><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：quadtreeに含まれる値のタイプ。</font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quadtree内に格納されるため、簡単なクラスである必要があります。</font><font style="vertical-align: inherit;">理想的には、これはポインターまたは小さな単純なデータ構造（POD）である必要があります。</font></font></li>
<li><code>GetBox</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：入力値を受け取り、長方形を返す、呼び出すオブジェクトのタイプ。</font></font></li>
<li><code>Equal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：2つの値が等しいかどうかを確認するために呼び出されるオブジェクトのタイプ。</font><font style="vertical-align: inherit;">デフォルトでは、標準の等価演算子を使用します。</font></font></li>
<li><code>Float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：計算で使用される算術型。</font><font style="vertical-align: inherit;">デフォルトではを使用します</font></font><code>float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラス定義の最初に、テンプレートパラメータの有効性をチェックするための3つの静的アサーションがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノードの定義を見てみましょう。ノードは、その4つの子ノードへのポインターとそれに含まれる値のリストを格納するだけです。バウンディングボックスや深度は格納しません。それらはその場で計算されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は両方のアプローチのベンチマークを実行し（奥行きのある長方形を保持し、保持せずに）、それらをその場で計算するときにパフォーマンスの低下を発見しませんでした。また、メモリの節約にもなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部ノードとシートを区別できるようにする方法があります</font></font><code>isLeaf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最初の子がnullでないことを確認するだけです。</font><font style="vertical-align: inherit;">nullはすべて子ノードであるか、どれもないため、最初のノードのみをチェックするだけで十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、メンバー変数を検討できます</font></font><code>Quadtree</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ul>
<li><code>mBox</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバルバウンディングボックスです。</font><font style="vertical-align: inherit;">クワッドツリーに挿入されたすべての値は、その中に含まれている必要があります。</font></font></li>
<li><code>mRoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -ルート四分木。</font></font></li>
<li><code>mGetBox</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -呼び出されたオブジェクト。値から長方形を取得するために使用します。</font></font></li>
<li><code>mEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -呼び出されたオブジェクト。2つの値が等しいかどうかを確認するために使用します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンストラクタは単に設定</font></font><code>mBox</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>mGetBox</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>mEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ルート・ノードを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まだ説明していない最後の2つのパラメーターは</font></font><code>Threshold</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>MaxDepth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><code>Threshold</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-ノードを分割する前にノードに含めることができる値の最大数。</font></font><code>MaxDepth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これはノードの最大の深さです。オン</font></font><code>MaxDepth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">になっ</font><font style="vertical-align: inherit;">ているノードを分割しようとするのをやめ</font><font style="vertical-align: inherit;">ます。分割しすぎると、パフォーマンスが低下する可能性があるためです。</font><font style="vertical-align: inherit;">ほとんどの場合に適したこれらの定数に適切な値を与えました。</font><font style="vertical-align: inherit;">構成に合わせてそれらを最適化してみることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、より興味深い操作を開始する準備ができました。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">挿入および削除</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
挿入コードを示す前に、どのノードに値が含まれるかについて説明する必要があります。</font><font style="vertical-align: inherit;">2つの戦略があります。</font></font><br>
<br>
<ul>
<li>    .          ,       .</li>
<li>     .      ,      .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外接する四角形が小さく、ほぼ同じサイズの場合、交差を探すときに最初の方法がより効果的です。ただし、大きな長方形が存在する場合、パフォーマンスが非常に低下する縮退したケースが発生する可能性があります。たとえば、四角形がグローバルバウンディングボックスにある値を挿入すると、すべてのリーフに追加されます。そして</font></font><code>Threshold</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そのような値</font><font style="vertical-align: inherit;">を挿入</font><font style="vertical-align: inherit;">する</font></font><code>MaxDepth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、</font><font style="vertical-align: inherit;">到達するまですべてのノードが分割され</font><font style="vertical-align: inherit;">、値がすべての葉にあるわけではありません。したがって、四分木には</font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値、そしてそれは...</font><font style="vertical-align: inherit;">
さらに、最初の戦略では、値と交差するすべてのノードを挿入（または削除）する必要があるため、挿入と削除は少し遅くなります。</font><font style="vertical-align: inherit;">
したがって、縮退したケースがない2番目の戦略を使用します。 quadtreeをさまざまなコンテキストで使用する予定なので、より便利になります。さらに、この戦略は、エンティティが移動される物理エンジンなどで、値を更新するために多くの挿入と削除が実行される動的コンテキストに適しています。</font><font style="vertical-align: inherit;">
値を挿入または削除するノードを見つけるために、2つの補助関数を使用します。</font><font style="vertical-align: inherit;">
最初の1つ</font></font><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext mathvariant=&quot;monospace&quot;>Threshold</mtext></mrow><mo>&amp;#x00D7;</mo><msup><mn>4</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext mathvariant=&quot;monospace&quot;>MaxDepth</mtext></mrow></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="22.124ex" height="2.384ex" viewBox="0 -916.9 9525.6 1026.6" role="img" focusable="false" style="vertical-align: -0.255ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJTT-54"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJTT-68" x="525" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJTT-72" x="1051" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJTT-65" x="1576" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJTT-73" x="2102" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJTT-68" x="2627" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJTT-6F" x="3153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJTT-6C" x="3678" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJTT-64" x="4204" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJMAIN-D7" x="4951" y="0"></use><g transform="translate(5952,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJMAIN-34" x="0" y="0"></use><g transform="translate(500,404)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJTT-4D"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJTT-61" x="525" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJTT-78" x="1051" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJTT-44" x="1576" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJTT-65" x="2102" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJTT-70" x="2627" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJTT-74" x="3153" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg1cjBOrOe3f7ASl4B_UsgafWdKtg#MJTT-68" x="3678" y="0"></use></g></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="monospace"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敷居</font></font></mtext></mrow><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">×</font></font></mo><msup><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></mn><mrow class="MJX-TeXAtom-ORD"><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="monospace"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大深度</font></font></mtext></mrow></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1">\texttt{Threshold} \times 4^{\texttt{MaxDepth}}</script><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>computeBox</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、親ノードの四角形とその象限のインデックスによって子ノードの四角形を計算します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">Box&lt;Float&gt; <span class="hljs-title">computeBox</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Box&lt;Float&gt;&amp; box, <span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">const</span>
</span>{
    <span class="hljs-keyword">auto</span> origin = box.getTopLeft();
    <span class="hljs-keyword">auto</span> childSize = box.getSize() / <span class="hljs-keyword">static_cast</span>&lt;Float&gt;(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">switch</span> (i)<font></font>
    {<font></font>
        <span class="hljs-comment">// North West</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> Box&lt;Float&gt;(origin, childSize);
        <span class="hljs-comment">// Norst East</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> Box&lt;Float&gt;(Vector2&lt;Float&gt;(origin.x + childSize.x, origin.y), childSize);
        <span class="hljs-comment">// South West</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            <span class="hljs-keyword">return</span> Box&lt;Float&gt;(Vector2&lt;Float&gt;(origin.x, origin.y + childSize.y), childSize);
        <span class="hljs-comment">// South East</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
            <span class="hljs-keyword">return</span> Box&lt;Float&gt;(origin + childSize, childSize);
        <span class="hljs-keyword">default</span>:<font></font>
            assert(<span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-string">"Invalid child index"</span>);
            <span class="hljs-keyword">return</span> Box&lt;Float&gt;();<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の</font></font><code>getQuadrant</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、値が配置されている象限を返します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getQuadrant</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Box&lt;Float&gt;&amp; nodeBox, <span class="hljs-keyword">const</span> Box&lt;Float&gt;&amp; valueBox)</span> <span class="hljs-keyword">const</span>
</span>{
    <span class="hljs-keyword">auto</span> center = nodeBox.getCenter();
    <span class="hljs-comment">// West</span>
    <span class="hljs-keyword">if</span> (valueBox.getRight() &lt; center.x)<font></font>
    {<font></font>
        <span class="hljs-comment">// North West</span>
        <span class="hljs-keyword">if</span> (valueBox.getBottom() &lt; center.y)
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-comment">// South West</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valueBox.top &gt;= center.y)
            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
        <span class="hljs-comment">// Not contained in any quadrant</span>
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// East</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valueBox.left &gt;= center.x)<font></font>
    {<font></font>
        <span class="hljs-comment">// North East</span>
        <span class="hljs-keyword">if</span> (valueBox.getBottom() &lt; center.y)
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        <span class="hljs-comment">// South East</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valueBox.top &gt;= center.y)
            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
        <span class="hljs-comment">// Not contained in any quadrant</span>
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// Not contained in any quadrant</span>
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それが</font></font><code>-1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どの象限にも含まれていない場合は、</font><font style="vertical-align: inherit;">戻ります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、挿入メソッドと削除メソッドを検討する準備ができました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インサート</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッド</font></font><code>add</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、プライベートヘルパーメソッドを呼び出すだけです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; value)</span>
</span>{<font></font>
    add(mRoot.get(), <span class="hljs-number">0</span>, mBox, value);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヘルパーメソッドコードは次のとおりです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node* node, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> depth, <span class="hljs-keyword">const</span> Box&lt;Float&gt;&amp; box, <span class="hljs-keyword">const</span> T&amp; value)</span>
</span>{<font></font>
    assert(node != <span class="hljs-literal">nullptr</span>);<font></font>
    assert(box.contains(mGetBox(value)));<font></font>
    <span class="hljs-keyword">if</span> (isLeaf(node))<font></font>
    {<font></font>
        <span class="hljs-comment">// Insert the value in this node if possible</span>
        <span class="hljs-keyword">if</span> (depth &gt;= MaxDepth || node-&gt;values.size() &lt; Threshold)<font></font>
            node-&gt;values.push_back(value);<font></font>
        <span class="hljs-comment">// Otherwise, we split and we try again</span>
        <span class="hljs-keyword">else</span><font></font>
        {<font></font>
            split(node, box);<font></font>
            add(node, depth, box, value);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
        <span class="hljs-keyword">auto</span> i = getQuadrant(box, mGetBox(value));
        <span class="hljs-comment">// Add the value in a child if the value is entirely contained in it</span>
        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">-1</span>)<font></font>
            add(node-&gt;children[<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt;(i)].get(), depth + <span class="hljs-number">1</span>, computeBox(box, i), value);
        <span class="hljs-comment">// Otherwise, we add the value in the current node</span>
        <span class="hljs-keyword">else</span><font></font>
            node-&gt;values.push_back(value);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、非論理的なことは何もしていないことを確認するいくつかの仮定があります。たとえば、バウンディングボックスを含まないノードに値を挿入していないことなどです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ノードがシートで、それに新しい値を挿入できる場合、つまり </font></font><code>MaxDepth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>Threshold</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">到達しなかったため</font><font style="vertical-align: inherit;">、挿入を実行しています。</font><font style="vertical-align: inherit;">それ以外の場合は、このノードを共有して再試行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノードが内部にある場合、値の境界ボックスを含む象限を計算します。</font><font style="vertical-align: inherit;">完全に子ノードに含まれている場合は、再帰呼び出しを行います。</font><font style="vertical-align: inherit;">それ以外の場合は、このノードに挿入します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分離手順は次のとおりです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(Node* node, <span class="hljs-keyword">const</span> Box&lt;Float&gt;&amp; box)</span>
</span>{<font></font>
    assert(node != <span class="hljs-literal">nullptr</span>);<font></font>
    assert(isLeaf(node) &amp;&amp; <span class="hljs-string">"Only leaves can be split"</span>);
    <span class="hljs-comment">// Create children</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; child : node-&gt;children)<font></font>
        child = <span class="hljs-built_in">std</span>::make_unique&lt;Node&gt;();
    <span class="hljs-comment">// Assign values to children</span>
    <span class="hljs-keyword">auto</span> newValues = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt;(); <span class="hljs-comment">// New values for this node</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; value : node-&gt;values)<font></font>
    {<font></font>
        <span class="hljs-keyword">auto</span> i = getQuadrant(box, mGetBox(value));
        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">-1</span>)<font></font>
            node-&gt;children[<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt;(i)]-&gt;values.push_back(value);
        <span class="hljs-keyword">else</span><font></font>
            newValues.push_back(value);<font></font>
    }<font></font>
    node-&gt;values = <span class="hljs-built_in">std</span>::move(newValues);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4つの子ノードを作成し、親ノードの値ごとに、値を格納するノード（子または親）を決定します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">削除する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッド</font></font><code>remove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はヘルパー</font><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">も呼び出すだけです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; value)</span>
</span>{<font></font>
    remove(mRoot.get(), <span class="hljs-literal">nullptr</span>, mBox, value);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヘルパーメソッドコードは次のとおりです。挿入コードと非常に似ています。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node* node, Node* parent, <span class="hljs-keyword">const</span> Box&lt;Float&gt;&amp; box, <span class="hljs-keyword">const</span> T&amp; value)</span>
</span>{<font></font>
    assert(node != <span class="hljs-literal">nullptr</span>);<font></font>
    assert(box.contains(mGetBox(value)));<font></font>
    <span class="hljs-keyword">if</span> (isLeaf(node))<font></font>
    {<font></font>
        <span class="hljs-comment">// Remove the value from node</span><font></font>
        removeValue(node, value);<font></font>
        <span class="hljs-comment">// Try to merge the parent</span>
        <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">nullptr</span>)<font></font>
            tryMerge(parent);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
        <span class="hljs-comment">// Remove the value in a child if the value is entirely contained in it</span>
        <span class="hljs-keyword">auto</span> i = getQuadrant(box, mGetBox(value));
        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">-1</span>)<font></font>
            remove(node-&gt;children[<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt;(i)].get(), node, computeBox(box, i), value);
        <span class="hljs-comment">// Otherwise, we remove the value from the current node</span>
        <span class="hljs-keyword">else</span><font></font>
            removeValue(node, value);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在のノードが葉である場合、現在のノードの値のリストから値を削除し、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このノードを姉妹ノードおよびその親とマージしようとします。</font><font style="vertical-align: inherit;">それ以外の場合は、値の境界ボックスがどの象限にあるかを決定します。</font><font style="vertical-align: inherit;">完全に子ノードに含まれている場合は、再帰呼び出しを行います。</font><font style="vertical-align: inherit;">それ以外の場合は、現在のノードの値から削除します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノードに保存されている値の順序は関係ないため、削除するときは少し最適化を行います。消去した値を最後の値で変更して削除します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeValue</span><span class="hljs-params">(Node* node, <span class="hljs-keyword">const</span> T&amp; value)</span>
</span>{
    <span class="hljs-comment">// Find the value in node-&gt;values</span>
    <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">std</span>::find_if(<span class="hljs-built_in">std</span>::begin(node-&gt;values), <span class="hljs-built_in">std</span>::end(node-&gt;values),<font></font>
        [<span class="hljs-keyword">this</span>, &amp;value](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; rhs){ <span class="hljs-keyword">return</span> mEqual(value, rhs); });<font></font>
    assert(it != <span class="hljs-built_in">std</span>::end(node-&gt;values) &amp;&amp; <span class="hljs-string">"Trying to remove a value that is not present in the node"</span>);
    <span class="hljs-comment">// Swap with the last element and pop back</span>
    *it = <span class="hljs-built_in">std</span>::move(node-&gt;values.back());<font></font>
    node-&gt;values.pop_back();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、次のことも確認する必要があります</font></font><code>tryMerge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tryMerge</span><span class="hljs-params">(Node* node)</span>
</span>{<font></font>
    assert(node != <span class="hljs-literal">nullptr</span>);<font></font>
    assert(!isLeaf(node) &amp;&amp; <span class="hljs-string">"Only interior nodes can be merged"</span>);
    <span class="hljs-keyword">auto</span> nbValues = node-&gt;values.size();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; child : node-&gt;children)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (!isLeaf(child.get()))
            <span class="hljs-keyword">return</span>;<font></font>
        nbValues += child-&gt;values.size();<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (nbValues &lt;= Threshold)<font></font>
    {<font></font>
        node-&gt;values.reserve(nbValues);<font></font>
        <span class="hljs-comment">// Merge the values of all the children</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; child : node-&gt;children)<font></font>
        {<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; value : child-&gt;values)<font></font>
                node-&gt;values.push_back(value);<font></font>
        }<font></font>
        <span class="hljs-comment">// Remove the children</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; child : node-&gt;children)<font></font>
            child.reset();<font></font>
    }<font></font>
}</code></pre><br>
<code>tryMerge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての子ノードが葉であり、その値と子ノードの値の総数がしきい値未満であることを確認します。</font><font style="vertical-align: inherit;">その場合、すべての値を子ノードから現在のノードにコピーし、子ノードを削除します。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交差点検索</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長方形との交差</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、最も興味深いのは交差点の検索です。</font><font style="vertical-align: inherit;">これを使用する最初の方法は、特定の長方形と交差するすべての値を取得することです。</font><font style="vertical-align: inherit;">たとえば、これはクリッピングを実行するために必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは以下を扱い</font></font><code>query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Box&lt;Float&gt;&amp; box)</span> <span class="hljs-keyword">const</span>
</span>{
    <span class="hljs-keyword">auto</span> values = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt;();<font></font>
    query(mRoot.get(), mBox, box, values);<font></font>
    <span class="hljs-keyword">return</span> values;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドでは</font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、境界矩形を横切る値を含むものを</font><font style="vertical-align: inherit;">選択</font><font style="vertical-align: inherit;">し、ヘルパーメソッドを呼び出すだけです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">(Node* node, <span class="hljs-keyword">const</span> Box&lt;Float&gt;&amp; box, <span class="hljs-keyword">const</span> Box&lt;Float&gt;&amp; queryBox, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt;&amp; values)</span> <span class="hljs-keyword">const</span>
</span>{<font></font>
    assert(node != <span class="hljs-literal">nullptr</span>);<font></font>
    assert(queryBox.intersects(box));<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; value : node-&gt;values)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (queryBox.intersects(mGetBox(value)))<font></font>
            values.push_back(value);<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (!isLeaf(node))<font></font>
    {<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>(<span class="hljs-number">0</span>); i &lt; node-&gt;children.size(); ++i)<font></font>
        {<font></font>
            <span class="hljs-keyword">auto</span> childBox = computeBox(box, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(i));
            <span class="hljs-keyword">if</span> (queryBox.intersects(childBox))<font></font>
                query(node-&gt;children[i].get(), childBox, queryBox, values);<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、現在のノードに格納されている、要求された四角形と交差するすべての値を合計します。</font><font style="vertical-align: inherit;">次に、現在のノードが内部ノードである場合、境界の四角形が要求された四角形と交差する子ノードごとに再帰呼び出しを行います。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのペアワイズ交差</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目にサポートされる使用例は、交差する象限ツリーに格納されているすべての値のペアを検索することです。</font><font style="vertical-align: inherit;">これは、物理エンジンを作成するときに特に役立ちます。</font><font style="vertical-align: inherit;">この問題は、メソッドを使用して解決できます</font></font><code>query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そして実際、</font></font><code>query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バウンディングボックスのすべての値を</font><font style="vertical-align: inherit;">呼び出すことができ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">ただし、これはペアに1つの交差のみを追加することでより効率的に行うことができます（</font></font><code>query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2度見つけられるようにするため）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを実現するには、交差が発生する可能性があることを考慮する必要があります</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのノードに格納されている2つの値の間</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノードに格納されている値と、このノードの子孫に格納されている別の値の間。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このため、以下の交差のみをチェックする必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じノードに格納されている値と以下の値</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子孫に保存されている値と値。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、同じ交差を2回報告することは絶対にありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここにコードがあります</font></font><code>findAllIntersections</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::pair&lt;T, T&gt;&gt; <span class="hljs-title">findAllIntersections</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
</span>{
    <span class="hljs-keyword">auto</span> intersections = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::pair&lt;T, T&gt;&gt;();<font></font>
    findAllIntersections(mRoot.get(), intersections);<font></font>
    <span class="hljs-keyword">return</span> intersections;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでも、</font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交差点をストレージに</font><font style="vertical-align: inherit;">割り当て</font><font style="vertical-align: inherit;">、ヘルパー関数を呼び出す</font><font style="vertical-align: inherit;">だけ</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findAllIntersections</span><span class="hljs-params">(Node* node, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::pair&lt;T, T&gt;&gt;&amp; intersections)</span> <span class="hljs-keyword">const</span>
</span>{
    <span class="hljs-comment">// Find intersections between values stored in this node</span>
    <span class="hljs-comment">// Make sure to not report the same intersection twice</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>(<span class="hljs-number">0</span>); i &lt; node-&gt;values.size(); ++i)<font></font>
    {<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>(<span class="hljs-number">0</span>); j &lt; i; ++j)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (mGetBox(node-&gt;values[i]).intersects(mGetBox(node-&gt;values[j])))<font></font>
                intersections.emplace_back(node-&gt;values[i], node-&gt;values[j]);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (!isLeaf(node))<font></font>
    {<font></font>
        <span class="hljs-comment">// Values in this node can intersect values in descendants</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; child : node-&gt;children)<font></font>
        {<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; value : node-&gt;values)<font></font>
                findIntersectionsInDescendants(child.get(), value, intersections);<font></font>
        }<font></font>
        <span class="hljs-comment">// Find intersections in children</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; child : node-&gt;children)<font></font>
            findAllIntersections(child.get(), intersections);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の段階では、現在のノードに格納されている値の間の交差がチェックされます。</font><font style="vertical-align: inherit;">次に、現在のノードが内部ノードである場合、</font></font><code>findIntersectionInDescendants</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このノードに格納されている値とその子孫に格納されている値</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">交差が</font><font style="vertical-align: inherit;">を使用し</font><font style="vertical-align: inherit;">てチェックされます。</font><font style="vertical-align: inherit;">最後に、再帰呼び出しを行います。</font></font><br>
<br>
<code>findIntersectionsInDescendants</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定された値とサブツリーに格納されているすべての値の間の交差を再帰的に検索します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findIntersectionsInDescendants</span><span class="hljs-params">(Node* node, <span class="hljs-keyword">const</span> T&amp; value, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::pair&lt;T, T&gt;&gt;&amp; intersections)</span> <span class="hljs-keyword">const</span>
</span>{
    <span class="hljs-comment">// Test against the values stored in this node</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; other : node-&gt;values)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (mGetBox(value).intersects(mGetBox(other)))<font></font>
            intersections.emplace_back(value, other);<font></font>
    }<font></font>
    <span class="hljs-comment">// Test against values stored into descendants of this node</span>
    <span class="hljs-keyword">if</span> (!isLeaf(node))<font></font>
    {<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; child : node-&gt;children)<font></font>
            findIntersectionsInDescendants(child.get(), value, intersections);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで全部です！</font><font style="vertical-align: inherit;">繰り返しますが、すべてのコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHubに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投稿され</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ています</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">役立つリソース</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
衝突認識と空間分割のデータ構造について詳しく知りたい場合は、Christer Erickson </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Real-Time Collision Detectionの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本を読むことをお勧めし</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">その中で多くのトピックが深く明らかにされていると同時に、本は非常に理解できる言語で書かれています。</font><font style="vertical-align: inherit;">さらに、章は別々に読むことができます。</font><font style="vertical-align: inherit;">これは優れたリファレンスソースです。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、衝突認識の作業が完了しました。</font><font style="vertical-align: inherit;">ただし、これは物理エンジンの半分にすぎません。</font><font style="vertical-align: inherit;">後半は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">衝突</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">解決です</font></a><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja473056/index.html">アリスが写真から国を認識する方法。Yandexリサーチ</a></li>
<li><a href="../ja473058/index.html">Sergey Sinitsyn：「OSMは単に家や線路を描くだけではありません。これらはより多くの物語です！」</a></li>
<li><a href="../ja473060/index.html">チーム内の非公式な関係：なぜ、どのように管理するか</a></li>
<li><a href="../ja473062/index.html">Mozilla Firefox用の主観的なuser.jsだけでなく</a></li>
<li><a href="../ja473064/index.html">バタヴィアの涙、車、ゴリラグラス：強化ガラスの種類について</a></li>
<li><a href="../ja473070/index.html">Redux-不要！ReactでuseContextおよびuseReducerに置き換えますか？</a></li>
<li><a href="../ja473072/index.html">Gazpromneftが企業クライアントのデジタルパスを作成する方法</a></li>
<li><a href="../ja473074/index.html">APSとは何か、なぜそれが「私たちが望む方法で生産計画を立てない」のか...</a></li>
<li><a href="../ja473078/index.html">microconfig.ioでマイクロサービス構成を簡単に管理</a></li>
<li><a href="../ja473082/index.html">マイクロサービスの作成方法と、迅速に作成しない理由</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>