<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👿 🙌🏻 🧗🏾 C ++ 17の滑りやすい場所 👩‍🍳 ⬜️ 💊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="近年、C ++は飛躍的な進歩を遂げており、言語のすべての巧妙さと複雑さについていくことは非常に困難です。新しい標準はそれほど遠くないですが、新鮮なトレンドの導入は最速で簡単なプロセスではありません。したがって、C ++ 20の前に少し時間があり、現在の標準の特に「滑りやすい」場所を更新または発見する...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C ++ 17の滑りやすい場所</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/465181/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/fp/nd/-g/fpnd-ggxjx4-xafw3sb7rx2keca.png" alt="画像"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
近年、C ++は飛躍的な進歩を遂げており、言語のすべての巧妙さと複雑さについていくことは非常に困難です。</font><font style="vertical-align: inherit;">新しい標準はそれほど遠くないですが、新鮮なトレンドの導入は最速で簡単なプロセスではありません。したがって、C ++ 20の前に少し時間があり、現在の標準の特に「滑りやすい」場所を更新または発見することをお勧めします言語。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日、なぜconstexprがマクロの代わりにならないのか、構造化バインディングの「内部」とその「落とし穴」は何か、そしてコピー省略が常に機能し、ためらうことなく戻り値を記述できることは事実です。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手を汚すことを恐れないなら、舌の「内側」を掘り下げて、猫へようこそ。</font></font><br>
<a name="habracut"></a><br>
<hr><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexprの場合</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、最も単純なものから始めましょう。</font></font><code>if constexpr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これにより、コンパイル段階でも、目的の条件が満たされていない条件式ブランチを削除できます。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは</font></font><code>#if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、「余分な」ロジックをオフにする</font><font style="vertical-align: inherit;">マクロの代わりと思われ</font><font style="vertical-align: inherit;">ますか？番号。どういたしまして。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、これに</font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はマクロからアクセスできないプロパティがあります。内部で</font></font><code>constexpr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、に還元可能な</font><font style="vertical-align: inherit;">任意の</font><font style="vertical-align: inherit;">式を</font><font style="vertical-align: inherit;">カウントできます</font></font><code>bool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。しかし、第二に、破棄されたブランチの内容は構文的にも意味的にも正しいはずです。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の要件により</font></font><code>if constexpr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、たとえば、存在しない関数（このようにして、プラットフォームに依存するコードを明示的に分離することはできません）や、構成言語の観点からは不正な関数（たとえば、 " </font></font><code> void T = 0;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"）</font><font style="vertical-align: inherit;">を使用する</font><font style="vertical-align: inherit;">ことは</font><font style="vertical-align: inherit;">できません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、使用のポイントは何</font></font><code>if constexpr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですか？</font><font style="vertical-align: inherit;">要点はテンプレートにあります。</font><font style="vertical-align: inherit;">それらには特別なルールがあります。テンプレートがインスタンス化されても、破棄されたブランチはインスタンス化されません。</font><font style="vertical-align: inherit;">これにより、テンプレートタイプのプロパティに依存するコードを簡単に記述できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、テンプレートでは、ブランチ内のコードがインスタンス化の少なくとも一部の（純粋に潜在的な）インスタンスに対して正しい必要があることを忘れないでください。したがって、たとえば、</font></font><code>static_assert(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブランチの1つ内</font><font style="vertical-align: inherit;">に書き込むことは単に</font><font style="vertical-align: inherit;">不可能</font><font style="vertical-align: inherit;">です</font><font style="vertical-align: inherit;">（これは</font></font><code>static_assert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかに依存する</font><font style="vertical-align: inherit;">必要があることが必要です）</font><font style="vertical-align: inherit;">またはテンプレート依存のパラメーター）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>
</span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//    ,   </span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">( os == OS::win )</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;win_api_call(); <span class="hljs-comment">//     </span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">else</span> {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;some_other_os_call(); <span class="hljs-comment">//  win  </span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>
</span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//    ,    T  </span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">( os == OS::win )</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T::win_api_call(); <span class="hljs-comment">//  T   ,    win</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">else</span> {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T::some_other_os_call(); <span class="hljs-comment">//  T   ,     </span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>
</span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(condition1)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">constexpr</span> (condition2) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">else</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// static_assert(false); //  </span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">static_assert</span>(trait&lt;T&gt;::value); <span class="hljs-comment">// ,   ,  trait&lt;T&gt;::value   false</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">覚えておくべきこと</font></font></h2><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのブランチのコードは正しい必要があります。&nbsp;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テンプレート内では、破棄されたブランチのコンテンツはインスタンス化されません。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブランチ内のコードは、テンプレートのインスタンス化の純粋に潜在的な1つ以上のバリアントに対して正しい必要があります。</font></font><br>
</li>
</ol><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造化バインディング</font></font></h1><br>
<img src="https://habrastorage.org/webt/0v/jl/x4/0vjlx42it96fu5j20yz-m-pvhpq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 17では、さまざまなタプルのようなオブジェクトを分解するためのかなり便利なメカニズムが登場し、内部要素を名前付き変数に便利かつ簡潔にバインドできるようになりました。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//     —    :</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : <span class="hljs-built_in">map</span>) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; key &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タプルのようなオブジェクトとは、コンパイル時に利用可能な内部要素の数がわかっているオブジェクトを意味します（「タプル」-要素（ベクトル）の数が固定された順序付きリスト）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この定義は、このようなタイプを含む：</font></font><code>std::pair</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>std::tuple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>std::array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、フォーム「の配列</font></font><code>T a[N]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」、ならびに種々 samopisnye構造とクラス。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストップ...構造バインディングで独自の構造を使用できますか？</font><font style="vertical-align: inherit;">スポイラー：できます（ただし、懸命に作業する必要がある場合もあります（ただし、以下で詳しく説明します））。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのように機能しますか</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造リンクの作業は別の記事に値しますが、ここでは「滑りやすい」場所について話しているので、すべてがどのように機能するかを簡単に説明しようと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準では、バインディングを定義するための次の構文が提供されています</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。attr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（オプション）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cv-auto </font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ref-operator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（オプション）[ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">identifier-list</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expression</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font><br>
<br>
<ul>
<li><code>attr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -オプションの属性リスト。</font></font><br>
</li>
<li><code>cv-auto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -可能なconst / volatile修飾子付きのauto;</font></font><br>
</li>
<li><code>ref-operator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -オプションの参照指定子（＆または&amp;&amp;）;</font></font><br>
</li>
<li><code>identifier-list</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -新しい変数の名前のリスト。</font></font><br>
</li>
<li><code>expression</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-バインディングに使用されるタプルのようなオブジェクトを生成する式（式は、 " </font></font><code>= expr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"、 " </font></font><code> {expr}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"、または " </font></font><code>(expr)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font><font style="vertical-align: inherit;">の形式にすることができます</font><font style="vertical-align: inherit;">）。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
の名前</font></font><code>identifier-list</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の数は、実行結果のオブジェクトの要素の数と一致する必要</font><font style="vertical-align: inherit;">があることに注意してください</font></font><code>expression</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、フォームの構造を記述できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">auto</span> &amp;&amp; [a,b,c] = Foo{};
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ここで最初の「滑りやすい」場所に到達します。「</font></font><code>auto a = expr;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」</font><font style="vertical-align: inherit;">という形の式に出会ったとき</font><font style="vertical-align: inherit;">、通常は「</font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」</font><font style="vertical-align: inherit;">という型が「</font><font style="vertical-align: inherit;">」という式によって計算され、「</font></font><code>expr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」</font></font><code>const auto&amp; [a,b,c] = expr;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の型のみが同じ</font><font style="vertical-align: inherit;">「</font><font style="vertical-align: inherit;">」で行われること</font><font style="vertical-align: inherit;">を期待し</font><font style="vertical-align: inherit;">てい</font><font style="vertical-align: inherit;">ます</font></font><code>a,b,c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>const&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素</font><font style="vertical-align: inherit;">の対応する</font><font style="vertical-align: inherit;">タイプになります " </font></font><code>expr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" ...&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
真実は異なります。指定子 " </font></font><code>cv-auto ref-operator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"は、exprの計算結果が割り当てられる非表示の変数のタイプを計算するために使用されます（つまり、コンパイラーは " </font></font><code>const auto&amp; [a,b,c] = expr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"を " </font></font><code>const auto&amp; e = expr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"で</font><font style="vertical-align: inherit;">置き換えます</font><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、新しい非表示のエンティティが表示されます（以下、これを{e}と呼びます）。ただし、エンティティは非常に便利です。たとえば、一時オブジェクトを具体化できます（したがって、それらを安全に接続できます“ </font></font><code>const auto&amp; [a,b,c] = Foo {};</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">”）。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の滑りやすい場所は、コンパイラーが行う置換の直後に続きます。{e}で推定された型が参照でない場合、結果</font></font><code>expr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は{e}にコピーされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数にはどのようなタイプがあります</font></font><code>identifier-list</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か？</font><font style="vertical-align: inherit;">まず、これらは実際には変数ではありません。</font><font style="vertical-align: inherit;">はい、それらは実際の通常の変数のように動作しますが、内部ではそれらに関連付けられたエンティティを参照するという違いのみがあり</font></font><code>decltype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そのような「参照」変数から、この変数が参照するエンティティのタイプが返されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-built_in">std</span>::tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2.f</span>)</span></span>;
<span class="hljs-keyword">auto</span>&amp; [a, b] = t; <span class="hljs-comment">// decltype(a) — int, decltype(b) — float</span>
++a; <span class="hljs-comment">// ,  « »,   t</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">0</span>&gt;(t); <span class="hljs-comment">//  2</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプ自体は次のように定義されています。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{E}は</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（配列である</font></font><code>T a[N]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、次いでタイプは、一つになり- T、CV-改質剤は、配列のものと一致します。&nbsp;</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{E}は</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプEであり、タプルインタフェースをサポートする、構造が定義されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">std::tuple_size&lt;E&gt;</code></pre><br>
<pre><code class="plaintext hljs">std::tuple_element&lt;i, E&gt;</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして機能：</font></font><br>
<br>
<pre><code class="plaintext hljs">get&lt;i&gt;({e}); //  {e}.get&lt;i&gt;()</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各変数の型は型になります </font></font><code>std::tuple_element_t&lt;i, E&gt;</code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他の場合では、変数のタイプは、バインディングが実行される構造要素のタイプに対応します。&nbsp;</font></font><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、非常に簡単に言えば、構造リンクで次の手順が実行されます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプ</font></font><code>expr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>cv-ref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">修飾子に</font><font style="vertical-align: inherit;">基づいた非表示エンティティ{e}のタイプと初期化の計算</font><font style="vertical-align: inherit;">。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">疑似変数を作成し、それらを{e}要素にバインドします。</font></font><br>
</li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス/構造を構造的にリンクする</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらの構造をリンクすることの主な障害は、C ++でのリフレクションの欠如です。</font><font style="vertical-align: inherit;">コンパイラでさえ、これまたはその構造が内部でどのように配置されているかを確実に知っている必要があります。アクセス修飾子（パブリック/プライベート/保護）と継承が非常に複雑な問題です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような困難のため、クラスの使用に関する制限は非常に厳しくなっています（少なくとも</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現時点</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">は：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">P1061</font></a><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1096</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスのすべての内部非静的フィールドは、同じ基本クラスからのものでなければならず、使用時に利用可能でなければなりません。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または、クラスは「リフレクション」を実装する必要があります（タプルインターフェイスをサポート）。</font></font><br>
</li>
</ol><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  «» </span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> {</span> <span class="hljs-keyword">int</span> a; };&nbsp;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span> :</span> A {};&nbsp;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span> :</span> A { <span class="hljs-keyword">int</span> c; };&nbsp;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> {</span> <span class="hljs-keyword">int</span> d; };<font></font>
<font></font>
<span class="hljs-keyword">auto</span> [a] = A{}; <span class="hljs-comment">//  (a -&gt; A::a)&nbsp;</span>
<span class="hljs-keyword">auto</span> [a] = B{}; <span class="hljs-comment">//  (a -&gt; B::A::a)</span>
<span class="hljs-keyword">auto</span> [a, c] = C{}; <span class="hljs-comment">// : a  c   </span>
<span class="hljs-keyword">auto</span> [d] = D{}; <span class="hljs-comment">// : d — private</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">D::foo</span><span class="hljs-params">()</span>
</span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">auto</span> [d] = *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//  (d   )</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タプルインターフェイスの実装では、任意のクラスをバインドに使用できますが、少し面倒であり、別の落とし穴があります。</font><font style="vertical-align: inherit;">すぐに例を使用してみましょう：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  ,      int  </span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>;</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">std</span>:</span>:tuple_size&lt;Foo&gt; : <span class="hljs-built_in">std</span>::integral_constant&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>, <span class="hljs-number">1</span>&gt; {};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">std</span>:</span>:tuple_element&lt;<span class="hljs-number">0</span>, Foo&gt;<font></font>
{<font></font>
    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">int</span>&amp;;<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> i&gt;
    <span class="hljs-built_in">std</span>::<span class="hljs-keyword">tuple_element_t</span>&lt;i, Foo&gt; <span class="hljs-keyword">const</span>&amp; <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> i&gt;
    <span class="hljs-built_in">std</span>::<span class="hljs-keyword">tuple_element_t</span>&lt;i, Foo&gt; &amp; <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> _foo = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span>&amp; _bar = _foo;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">tuple_element_t</span>&lt;<span class="hljs-number">0</span>, Foo&gt; <span class="hljs-keyword">const</span>&amp; Foo::get&lt;<span class="hljs-number">0</span>&gt;() <span class="hljs-keyword">const</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _bar;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">tuple_element_t</span>&lt;<span class="hljs-number">0</span>, Foo&gt; &amp; Foo::get&lt;<span class="hljs-number">0</span>&gt;()<font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _bar;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今バインドします：</font></font><br>
<br>
<pre><code class="cpp hljs">Foo foo;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; [f1] = foo;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&nbsp; [f2] = foo;
<span class="hljs-keyword">auto</span>&amp; [f3] = foo;
<span class="hljs-keyword">auto</span>&nbsp; [f4] = foo;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、それは私たちがどんなタイプを得たかについて考える時間です？</font><font style="vertical-align: inherit;">（すぐに答えることができる人はおいしい甘い人に値する。）</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">decltype</span>(f1);
<span class="hljs-keyword">decltype</span>(f2);
<span class="hljs-keyword">decltype</span>(f3);
<span class="hljs-keyword">decltype</span>(f4);
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正解</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword">decltype</span>(f1); <span class="hljs-comment">// int&amp;</span>
<span class="hljs-keyword">decltype</span>(f2); <span class="hljs-comment">// int&amp;</span>
<span class="hljs-keyword">decltype</span>(f3); <span class="hljs-comment">// int&amp;</span>
<span class="hljs-keyword">decltype</span>(f4); <span class="hljs-comment">// int&amp;	</span>
++f1; <span class="hljs-comment">//     foo._foo,  {e}    const</span>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこれが起こったのですか？</font><font style="vertical-align: inherit;">答えは、デフォルトの特殊化にあります</font></font><code>std::tuple_element</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> i, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">std</span>:</span>:tuple_element&lt;i, <span class="hljs-keyword">const</span> T&gt;<font></font>
{<font></font>
    <span class="hljs-keyword">using</span> type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_const_t</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">tuple_element_t</span>&lt;i, T&gt;&gt;;<font></font>
};<font></font>
</code></pre><br>
<code>std::add_const </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照型に</font><font style="vertical-align: inherit;">追加さ</font><font style="vertical-align: inherit;">れ</font><font style="vertical-align: inherit;">ない</font><font style="vertical-align: inherit;">ため、型</font></font><code>Foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は常にになります</font></font><code>int&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを勝ち取るには？</font><font style="vertical-align: inherit;">のために特化を追加するだけです</font></font><code>const Foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">std</span>:</span>:tuple_element&lt;<span class="hljs-number">0</span>, <span class="hljs-keyword">const</span> Foo&gt;<font></font>
{<font></font>
    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、すべてのタイプが期待されます：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">decltype</span>(f1); <span class="hljs-comment">// const int&amp;</span>
<span class="hljs-keyword">decltype</span>(f2); <span class="hljs-comment">// const int&amp;</span>
<span class="hljs-keyword">decltype</span>(f3); <span class="hljs-comment">// int&amp;</span>
<span class="hljs-keyword">decltype</span>(f4); <span class="hljs-comment">// int&amp;</span>
++f1; <span class="hljs-comment">//    </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、たとえば、</font></font><code>std::tuple&lt;T&amp;&gt;</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 オブジェクト自体は定数であっても、内部要素への非定数参照を取得できます。&nbsp;</font></font><br>
<br>
<h2>   </h2><br>
<ol>
<li>«<code>cv-auto ref</code>»  «<code>cv-auto ref [a1..an] = expr</code>»     {e}.<br>
</li>
<li>   {e}   , {e}    (  «» ).<br>
</li>
<li>  — «»  (    ,  <code>decltype</code>      (  ,     )).<br>
</li>
<li>        .<br>
</li>
</ol><br>
<h1>   (rvo, copy elision)</h1><br>
<img src="https://habrastorage.org/webt/gt/0i/ln/gt0iln8n664yvitfqfpkjk9vuds.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらくこれは、C ++ 17標準の最も話題になっている機能の1つだったのかもしれません（少なくとも私の友人のサークルでは）。そして確かに：C ++ 11は、「内部」オブジェクトの転送とさまざまなファクトリの作成を大幅に簡略化する動きのセマンティクスをもたらし、C ++ 17は一般に、いくつかのファクトリーメソッドからオブジェクトを返す方法を考えないようにしたようです、-すべてはコピーせず、一般に「すべてが火星ですぐに咲く」... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、少し現実的にしましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">戻り値を最適化することは、実装するのが最も簡単なことではありません。私は非常にcppcon2018からこのプレゼンテーションを見てお勧めします：アーサーO'Dwyer「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">戻り値の最適化：ハーダー見た目より</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」、それが困難である理由を著者が伝えています。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ショートスポイラー：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「戻り値のスロット」というものがあります。</font><font style="vertical-align: inherit;">このスロットは基本的に、呼び出して呼び出し先に渡す人によって割り当てられるスタック上の単なる場所です。</font><font style="vertical-align: inherit;">呼び出されたコードが、返される単一のオブジェクトを正確に知っている場合は、このオブジェクトを直接このスロットに直接作成できます（オブジェクトとスロットのサイズとタイプが同じ場合）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これから何が続きますか？</font><font style="vertical-align: inherit;">例でそれを分解してみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここですべてがうまくいきます-NRVOは機能し、オブジェクトは「スロット」にすぐに構築されます：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">Base <span class="hljs-title">foo1</span><span class="hljs-params">()</span>
</span>{<font></font>
    Base a;	<font></font>
    <span class="hljs-keyword">return</span> a;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、結果となるオブジェクトを明確に決定することはできなくなったため、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移動コンストラクター</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（c ++ 11）</font><font style="vertical-align: inherit;">が</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">暗黙的に呼び出され</font></a><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">Base <span class="hljs-title">foo2</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> c)</span>
</span>{<font></font>
    Base a,b;	<font></font>
    <span class="hljs-keyword">if</span> (c) {	
        <span class="hljs-keyword">return</span> a;	<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> b;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは少し複雑です。戻り値の型は宣言された型とは異なる</font></font><code>move</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、</font><font style="vertical-align: inherit;">暗黙的に</font><font style="vertical-align: inherit;">呼び出すことはできないため、デフォルトでコピーコンストラクターが呼び出されます。</font><font style="vertical-align: inherit;">これを回避するには、明示的に次を呼び出す必要があります</font></font><code>move</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">Base <span class="hljs-title">foo3</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> c)</span>
</span>{<font></font>
    Derived a,b;	<font></font>
    <span class="hljs-keyword">if</span> (c) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::move(a);<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::move(b);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはと同じように見えるかもしれ</font></font><code>foo2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ませんが、三項演算子は非常に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独特のもの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です...</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">Base <span class="hljs-title">foo4</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> c)</span>
</span>{<font></font>
    Base a, b;<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::move(c ? a : b);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に</font></font><code>foo4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ただし、タイプも異なるため、</font></font><code>move</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正確に次のもの</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">必要です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">Base <span class="hljs-title">foo5</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> c)</span>
</span>{<font></font>
    Derived a, b;	<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::move(c ? a : b);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例からわかるように、一見些細な場合でも意味を返す方法を考える必要があります...人生を少し簡略化する方法はありますか？</font><font style="vertical-align: inherit;">clangはしばらくの間</font><font style="vertical-align: inherit;">、明示的な呼び出しの必要性</font><font style="vertical-align: inherit;">の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">診断を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サポートしてきました。また</font><font style="vertical-align: inherit;">、新しい標準には、明示的</font><font style="vertical-align: inherit;">な必要性を少なくする</font></font><code>move</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかの提案（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1155</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P0527</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）が</font></font><code>move</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">覚えておくべきこと</font></font></h2><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO / NRVOは次の場合にのみ機能します。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「戻り値スロット」に作成する必要がある単一のオブジェクトが明確にわかっている。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">戻りオブジェクトと関数のタイプは同じです。</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">戻り値があいまいな場合は、次のようになります。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返されたオブジェクトと関数のタイプが同じ場合、moveは暗黙的に呼び出されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それ以外の場合は、明示的にmoveを呼び出す必要があります。</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三項演算子に関する注意：簡潔ですが、明示的な移動が必要になる場合があります。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有用な診断機能を持つコンパイラー（または少なくとも静的アナライザー）を使用することをお勧めします。</font></font><br>
</li>
</ol><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでも私はC ++が大好きです;）&nbsp;</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja465167/index.html">リソースプランニング。なぜ動作しないのですか？パート1</a></li>
<li><a href="../ja465169/index.html">PVS-StudioのDIY：実績のゲーミフィケーション</a></li>
<li><a href="../ja465173/index.html">アプリケーションで作成されたサブスクリプションのコストを変更する方法。App Store ConnectとGoogle Play Console</a></li>
<li><a href="../ja465177/index.html">New Relicのものではない：DatadogとAtatusの考察</a></li>
<li><a href="../ja465179/index.html">自動化は手動テストに取って代わりますか？</a></li>
<li><a href="../ja465185/index.html">新しいビデオ監視規格：夜間のカラー、ノイズ対策、ePoE</a></li>
<li><a href="../ja465187/index.html">外国企業との給与交渉に使える6つの英フレーズ</a></li>
<li><a href="../ja465189/index.html">Workflow One Sprint開発チーム</a></li>
<li><a href="../ja465191/index.html">Cisco 200-125 CCNA v3.0のトレーニング。25日目。IPv6の詳細な調査</a></li>
<li><a href="../ja465193/index.html">DockerコンテナーでのAndroidプロジェクトの構築</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>