<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏻 👌🏻 👆🏼 Blending和Unity Terrain：如何摆脱交叉点并停止使眼睛受伤 👩‍🎨 🎀 👨🏼‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="为了在游戏中获得逼真的世界，有必要考虑各种地形相互之间以及与其他模型之间的相互作用。而且，如果3D模型之间的可见相交线破坏了图像的完整性，则值得考虑如何消除它们。这种线条最常见的情况（可能为许多人所熟悉）是具有不透明几何形状的粒子的广告牌的交集。
 
 
 
 另一个例子是在“室外”场景中，岩石和植...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Blending和Unity Terrain：如何摆脱交叉点并停止使眼睛受伤</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/490226/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了在游戏中获得逼真的世界，有必要考虑各种地形相互之间以及与其他模型之间的相互作用。</font><font style="vertical-align: inherit;">而且，如果3D模型之间的可见相交线破坏了图像的完整性，则值得考虑如何消除它们。</font><font style="vertical-align: inherit;">这种线条最常见的情况（可能为许多人所熟悉）是具有不透明几何形状的粒子的广告牌的交集。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ja/va/g2/javag2i9gc9lhkwohebgbyklsjc.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一个例子是在“室外”场景中，岩石和植被与景观表面的交汇处令人不安的自然成分。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v0/k6/s9/v0k6s98hdon17qotuaryat0vogs.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了各种平滑方法（SSAA，MSAA，CSAA，FXAA，NFAA，CMAA，DLAA，TAA等），这些方法虽然可以缓解这种相交线的反感，但不能完全纠正这种情况，但还有更有效的技术。</font><font style="vertical-align: inherit;">我们将考虑它们。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">深度融合</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unity有一个内置解决方案，可以消除透明粒子和称为软粒子的不透明几何之间的可见相交。</font><font style="vertical-align: inherit;">支持此效果的着色器进一步提高了粒子的透明度，具体取决于粒子片段的深度与不透明几何体的深度之间的差异有多小。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mz/wx/9k/mzwx9kecz9hkjps0laijveek-54.png" alt="图片"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">软粒子的操作原理</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
显然，为了正确操作软粒子，需要深度缓冲区。</font><font style="vertical-align: inherit;">在延迟着色的情况下，深度缓冲区是在渲染全屏缓冲区的阶段形成的，并且考虑到MRT（多个渲染目标，而不是磁共振断层扫描），其存在没有用额外的计算成本来表示。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在前向阴影和使用Unity Legacy Pipeline的情况下，需要额外的遍历才能将不透明的几何体呈现到深度缓冲区</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">通过将适当的值分配给Camera.depthTextureMode属性来激活此过程。</font><font style="vertical-align: inherit;">该属性在检查器窗口中不可用，但在API </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2]中</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可用</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，您可以使用正向阴影实现自己的Scriptable Render Pipeline版本，借助MRT，它可以同时渲染深度缓冲区和颜色缓冲区。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7z/-b/1l/7z-b1lg9zs8xbsywe6evbmanfiw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消除支持软粒子的着色器中的相交线</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
通常，使用深度融合方法消除3D模型与景观的可见相交没有技术障碍：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看代码</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Blending</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">depth</span> <span class="hljs-selector-tag">buffer</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendStart</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendEnd</span>;
<span class="hljs-selector-tag">UNITY_DECLARE_DEPTH_TEXTURE</span>(_<span class="hljs-selector-tag">CameraDepthTexture</span>);<font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
    // ...<font></font>
<font></font>
    half4 <span class="hljs-attribute">projPos </span>: TEXCOORD0;<font></font>
};<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
<font></font>
    // ...<font></font>
<font></font>
    o.projPos = ComputeScreenPos(o.pos);<font></font>
    COMPUTE_EYEDEPTH(o.projPos.z);<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">fixed4</span> <span class="hljs-selector-tag">frag</span>(<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">i</span>) : <span class="hljs-selector-tag">COLOR</span><font></font>
{     <font></font>
    fixed4 result = 0;<font></font>
      <font></font>
    // ... <font></font>
<font></font>
    float depth = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.projPos));<font></font>
    float sceneZ = LinearEyeDepth(depth);<font></font>
    float partZ = i.projPos.z;<font></font>
    float fade = saturate( sceneZ - partZ );<font></font>
    result.a = smoothstep( BlendStart, BlendEnd, fade );<font></font>
<font></font>
    // ... <font></font>
       <font></font>
    return result; <font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，这种方法有几个缺点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一个缺点与性能有关。深度混合在硬件管道混合阶段即片段着色器的栅格化和计算之后立即起作用。在此阶段，</font><font style="vertical-align: inherit;">根据对API </font><sup><font style="vertical-align: inherit;">[6] [7] [8] [9]</font></sup><font style="vertical-align: inherit;">的调用预定义的公式</font><font style="vertical-align: inherit;">，将片段着色器的执行结果与记录在输出缓冲区</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] [4] [5]中</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的结果混合</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
从某种意义上说，它的工作方式完全像其20年前的工作一样，这是所有硬件管道中进展最少的部分。 GPU从内存读取值，将其与片段着色器的值混合，然后将其写回内存。</font></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于完全透明或部分透明的3D模型，使用深度融合还是有区别的。透明-例如，粒子广告牌-即使没有深度融合，整个渲染也是透明的。对于不透明的3D模型，在深度融合时，真实，有形，可见的透明度将只具有非常少量的片段，而大多数片段将保持不透明。但是后者完全不意味着混合将不会用于渲染-它将只是闲置工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个缺点与如何选择用于混合的颜色有关。简而言之，然后混合在特定屏幕像素中的所有片段都位于从相机的世界位置发出并穿过此屏幕像素的世界位置的一条光线上。反过来，这意味着在相机位置或方向发生任何变化时，都将观察到视差：靠近相机的3D模型片段的移动速度将比距离相机较远的景观片段的移动速度更快</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[10] [11]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。从近距离观看时，摄像机的横向位移恒定，这一点尤其明显。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hz/sc/78/hzsc78n3vvddbvvlgrb3hqkfwxc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移动相机时的横向视差：与景观片段相比，3D模型的片段移动的距离更大</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/5v/zf/wj/5vzfwjmabznaiprchenxb9eqy3q.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移动相机时的横向视差：将相机固定在景观片段上时，模型片段的移动速度非常明显</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
；旋转相机时，会沿屏幕坐标的两个轴立即观察到视差。但是，在动力学中，这不如横向视差明显。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qs/ew/jn/qsewjnfucpdriai47zh9032fwcm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相机移动时的方位角视差：当碎片沿两个</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
轴</font><i><font style="vertical-align: inherit;">移动时，大脑更难识别视差模式，但</font></i><font style="vertical-align: inherit;">最值得注意的是，深度混合的外观取决于观察者观察风景的角度而变化。当视线方向垂直于风景表面的法线时，融合区域几乎变得不可见，但是如果您向下倾斜相机，则该区域的大小会迅速增加。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hd/r8/gs/hdr8gs_ha63gspkr_eaxowjosna.png"><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在深度</font><i><font style="vertical-align: inherit;">倾斜摄影机的同时更改混合区域的宽度</font></i><font style="vertical-align: inherit;">如果不是因为3D模型与景观的相交过多，混合可能是消除3D模型与景观的相交线的好选择。</font><font style="vertical-align: inherit;">此方法更适合于非静态的粒子效果，并且通常不包含高度详细的纹理，因此，在这种情况下不会观察到视差效果。</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高度图融合</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实施景观融合的另一种方法是使用高度图，Unity提供了通过TerrainData API </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[12]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问的高度图</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
知道Terrain对象的位置和TerrainData中指示的地形尺寸，并且手头有一个“高度图”，您可以计算在世界坐标中指定的任何点的地形高度。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ga/69/za/ga69zap3c3xnluhjfm68g4_roto.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">采样高度图所需的地形参数</font></font></i><br>
<br>
<pre><code class="css hljs">// <span class="hljs-selector-tag">Setting</span> <span class="hljs-selector-tag">up</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">heightmap</span> <span class="hljs-selector-tag">and</span> <span class="hljs-selector-tag">uniforms</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">use</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">shaders</span>... <font></font>
<font></font>
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalTexture</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.TerrainHeightmap</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.terrainData</span><span class="hljs-selector-class">.heightmapTexture</span>);
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalVector</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.HeightmapScale</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.terrainData</span><span class="hljs-selector-class">.heightmapScale</span>);
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalVector</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.TerrainSize</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.terrainData</span><span class="hljs-selector-class">.size</span>);
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalVector</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.TerrainPos</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.transform</span><span class="hljs-selector-class">.position</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好了，现在，在计算了景观的高度之后，您还可以在着色器中计算uv坐标，以在世界坐标中采样景观的高度图。</font></font><br>
<br>
<pre><code class="css hljs">// <span class="hljs-selector-tag">Computes</span> <span class="hljs-selector-tag">UV</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">sampling</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">heightmap</span>... <font></font>
<font></font>
<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">TerrainUV</span>(<span class="hljs-selector-tag">float3</span> <span class="hljs-selector-tag">worldPos</span>)<font></font>
{<font></font>
    return (worldPos.xz - TerrainPos.xz) / TerrainSize.xz;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了能够在片段着色器和顶点着色器中使用相同的代码，将tex2Dlod函数用于采样。</font><font style="vertical-align: inherit;">此外，高度图没有Mip级别，因此使用自动计算Mip级别的tex2D函数对其进行采样基本上是没有意义的。</font></font><br>
<br>
<pre><code class="css hljs">// <span class="hljs-selector-tag">Returns</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">height</span> <span class="hljs-selector-tag">of</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">given</span> <span class="hljs-selector-tag">position</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">world</span> <span class="hljs-selector-tag">space</span>... <font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">TerrainHeight</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">terrainUV</span>)<font></font>
{<font></font>
    float heightmapSample = tex2Dlod(TerrainHeightmap, float4(terrainUV,0,0));<font></font>
    return TerrainPos.y + UnpackHeightmap(heightmapSample) * HeightmapScale.y * 2;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以尝试通过透明度重现消除交集的功能，而无需使用深度缓冲区。</font><font style="vertical-align: inherit;">这不能解决与该方法相关的其他问题，但是可以使用高度图验证混合的可操作性。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看代码</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Blending</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">heightmap</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendStart</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendEnd</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainHeightmap</span>; 
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">HeightmapScale</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainSize</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainPos</span>;        <font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
   // ...<font></font>
<font></font>
   float3 <span class="hljs-attribute">worldPos </span>: TEXCOORD0;<font></font>
   float2 <span class="hljs-attribute">heightMapUV </span>: TEXCOORD1;<font></font>
<font></font>
   // ...<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
   <font></font>
    // ...<font></font>
    <font></font>
    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<font></font>
    o.heightMapUV = TerrainUV(o.worldPos);<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">fixed4</span> <span class="hljs-selector-tag">frag</span>(<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">i</span>) : <span class="hljs-selector-tag">COLOR</span><font></font>
{<font></font>
    fixed4 result = 0;<font></font>
<font></font>
    // ... <font></font>
<font></font>
    half height = TerrainHeight(i.heightMapUV);<font></font>
    half deltaHeight = i.worldPos.y - height;<font></font>
    result.a = smoothstep( BlendStart, BlendEnd, deltaHeight );<font></font>
<font></font>
    // ... <font></font>
       <font></font>
    return result; <font></font>
}</code></pre><br>
</div></div><br>
<br>
<img src="https://habrastorage.org/webt/zl/fl/nz/zlflnzwmh3tl6z_dhlvxowot4he.png"><br>
<img src="https://habrastorage.org/webt/-k/qc/f8/-kqcf8fgcmkjj7kt3gxmfpz31zu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">深度混合和高程混合。</font><font style="vertical-align: inherit;">相同的着色器参数会导致混合区域的宽度不同，</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
两种方法的插图使用相同的混合参数。</font><font style="vertical-align: inherit;">融合区域的宽度在视觉上有所不同，因为与高度图的融合并不取决于观察者的视线与景观法线之间的角度。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与高度图进行混合至少比在深度上进行混合更好：它校正了肉眼可见的混合对相机注视风景的依赖关系。</font><font style="vertical-align: inherit;">不幸的是，仍然会观察到视差效果。</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">园林绿化改造</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要消除视差，您需要将3D模型的一部分与垂直下方的风景部分混合在一起（在这种情况下，用于混合的颜色选择不取决于相机的位置和方向）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h8/en/8t/h8en8tgwnrmjvhnunm0wkgcr3cu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何修复视差：选择用于混合的景观片段</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
当然，我们在这里更多地讨论虚拟景观片段。根据相机的位置，有可能需要将3D模型的片段混合在一起的风景片段甚至都不会落入相机的视野中。在屏幕空间（SSLR）中渲染局部反射时也存在类似的问题。它包含以下事实：不可能渲染不在屏幕上的片段的反射</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[13]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在景观的情况下，可以使用Unity API提供的辅助纹理高精度地重建虚拟片段的颜色：法线贴图</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[14]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，光贴图</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[15]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，用于混合图层的加权纹理</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[16]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及包含在其中的纹理层的组成</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[17]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ff/hu/zr/ffhuzriatn-pfjxf-nendtckscm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重建景观片段</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
根据与高度图相同的UV </font><i><font style="vertical-align: inherit;">对构成景观的</font></i><font style="vertical-align: inherit;">所有纹理进行采样。</font><font style="vertical-align: inherit;">在图层的情况下，采样坐标通过为特定图层</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[18] [19]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定的平铺参数进行调整</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看代码</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Blending</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">reconstructed</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">fragments</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendStart</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendEnd</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainHeightmapTexture</span>;
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainNormalTexture</span>;
<span class="hljs-selector-tag">sampler2D</span> <span class="hljs-selector-tag">TerrainAlphaMap</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">HeightmapScale</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainSize</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainPos</span>;
<span class="hljs-selector-tag">Float4</span> <span class="hljs-selector-tag">TerrainLightmap_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap0</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap0</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap0_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap1</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap1</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap1_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap2</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap2</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap2_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap3</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap3</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap3_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
   // ...<font></font>
<font></font>
   float3 <span class="hljs-attribute">worldPos </span>: TEXCOORD0;<font></font>
   float2 <span class="hljs-attribute">heightMapUV </span>: TEXCOORD1;<font></font>
#if defined(LIGHTMAP_ON)<font></font>
   float2 <span class="hljs-attribute">modelLightMapUV </span>: TEXCOORD2;<font></font>
   float2 <span class="hljs-attribute">terrainLightMapUV </span>: TEXCOORD3;<font></font>
#endif<font></font>
<font></font>
   // ...<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
   <font></font>
    // ...<font></font>
    <font></font>
    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<font></font>
    o.heightMapUV = TerrainUV(o.worldPos);<font></font>
<font></font>
#if defined(LIGHTMAP_ON)<font></font>
    o.modelLightMapUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;<font></font>
    o.terrainLightMapUV = o.heightMapUV * TerrainLightmap_ST.xy + TerrainLightmap_ST.zw;<font></font>
#endif<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}<font></font>
<span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">TerrainNormal</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">terrainUV</span>)<font></font>
{<font></font>
    return tex2Dlod( TerrainNormalTexture, float4(terrainUV,0,0) ).xyz * 2.0 - 1.0;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv0</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv1</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv2</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv3</span>, <span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">control</span>)<font></font>
{<font></font>
    half4 splat0 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap0, TerrainSplatMap0, uv0);<font></font>
    half4 splat1 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap1, TerrainSplatMap1, uv1);<font></font>
    half4 splat2 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap2, TerrainSplatMap2, uv2);<font></font>
    half4 splat3 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap3, TerrainSplatMap3, uv3);         <font></font>
    half4 result = splat0 * control.r + <font></font>
                   splat1 * control.g + <font></font>
                   splat2 * control.b + <font></font>
                   splat3 * control.a;<font></font>
    return result;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">TerrainNormalMap</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv0</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv1</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv2</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv3</span>, <span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">control</span>)<font></font>
{<font></font>
    half4 n0 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap0, TerrainSplatMap0, uv0);<font></font>
    half4 n1 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap1, TerrainSplatMap1, uv1);<font></font>
    half4 n2 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap2, TerrainSplatMap2, uv2);<font></font>
    half4 n3 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap3, TerrainSplatMap3, uv3);<font></font>
    half3 result = UnpackNormalWithScale(n0, 1.0) * control.r +<font></font>
                   UnpackNormalWithScale(n1, 1.0) * control.g +<font></font>
                   UnpackNormalWithScale(n2, 1.0) * control.b +<font></font>
                   UnpackNormalWithScale(n3, 1.0) * control.a;<font></font>
    result.z += 1e-5;<font></font>
    return result;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">TerrainLightmap</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv</span>, <span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">normal</span>)<font></font>
{<font></font>
#if defined(LIGHTMAP_ON)<font></font>
#if defined(DIRLIGHTMAP_COMBINED)<font></font>
    half4 lm = UNITY_SAMPLE_TEX2D(unity_Lightmap, uv);<font></font>
    half4 lmd = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, uv);<font></font>
    half3 result = DecodeLightmapRGBM(lm, unity_Lightmap_HDR);<font></font>
    result = DecodeDirectionalLightmap(result, lmd, normal);<font></font>
#else<font></font>
    half4 lm = UNITY_SAMPLE_TEX2D(unity_Lightmap, uv);<font></font>
    half3 result = DecodeLightmapRGBM(lm, unity_Lightmap_HDR);<font></font>
#endif                <font></font>
#else<font></font>
    half3 result = UNITY_LIGHTMODEL_AMBIENT.rgb;<font></font>
#endif<font></font>
    return result;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">fixed4</span> <span class="hljs-selector-tag">frag</span>(<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">i</span>) : <span class="hljs-selector-tag">COLOR</span><font></font>
{<font></font>
    fixed4 result = 0;<font></font>
<font></font>
    // ...<font></font>
<font></font>
    // compute model color and put it to the result<font></font>
<font></font>
    // ... <font></font>
<font></font>
    // reconstruction of terrain fragment<font></font>
<font></font>
    float2 splatUV0 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap0);<font></font>
    float2 splatUV1 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap1);<font></font>
    float2 splatUV2 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap2);<font></font>
    float2 splatUV3 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap3);<font></font>
<font></font>
    half4 control = tex2D(_TerrainAlphaMap, i.heightMapUV);<font></font>
    half4 terrainColor = TerrainSplatMap(splatUV0, splatUV1, splatUV2, splatUV3, control);<font></font>
<font></font>
    half3 terrainSurfaceNormal = TerrainNormal(i.heightMapUV);<font></font>
    half3 terrainSurfaceTangent = cross(terrainSurfaceNormal, float3(0,0,1));<font></font>
    half3 terrainSurfaceBitangent = cross(terrainSurfaceTangent, terrainSurfaceNormal);<font></font>
<font></font>
    half3 terrainNormal = TerrainNormalMap(splatUV0, splatUV1, splatUV2, splatUV3, control);<font></font>
    terrainNormal = terrainNormal.x * terrainSurfaceTangent + <font></font>
                    terrainNormal.y * terrainSurfaceBitangent + <font></font>
                    terrainNormal.z * terrainSurfaceNormal;<font></font>
    <font></font>
    half3 terrainLightmapColor = TerrainLightmap(i.heightMapUV, terrainNormal);<font></font>
    terrainColor *= terrainLightmapColor;<font></font>
<font></font>
    // blend model color &amp; terrain color<font></font>
<font></font>
    half height = TerrainHeight(i.heightMapUV);<font></font>
    half deltaHeight = i.worldPos.y - height;<font></font>
    half blendingWeight = smoothstep(BlendStart, BlendEnd, deltaHeight);<font></font>
<font></font>
    result.rgb = lerp(result.rgb, terrainColor, blendingFactor);<font></font>
       <font></font>
    return result; <font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，与景观碎片的重建融合解决了深度融合和与高度图（包括视差）融合的所有典型问题。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mf/pb/0s/mfpb0sfkav-hj-i5xhpll305drc.png"><br>
<img src="https://habrastorage.org/webt/ba/-z/x6/ba-zx6icghn-mnbreobdnekbjay.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">园林绿化改造</font></font></i><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地形碎片重建性能</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，该问问题了，这种妥协的价值是什么？乍一看，重建景观碎片的资源强度远远超过了alpha混合的资源强度。为了进行重建，有必要从内存中执行许多其他读取操作。对于Alpha混合，您只需要从内存进行一次读取操作，而对内存进行一次写入操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，一切都将取决于硬件平台的功能。纹理压缩，mip映射，GPU核心处理能力和特定的硬件管道优化（早期深度抑制）支持片段重建。与alpha混合相反，上面已经提到的事实将发挥作用，它是所有GPU中最不先进的部分。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，总会有优化的空间。</font><font style="vertical-align: inherit;">例如，在重建风景的颜色的情况下，仅对于位于不高于风景表面上方一定高度的3D模型的狭窄片段条带进行此重建的需要。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
着色器中的动态分支可能会导致可预测的性能结果，但是应注意两点：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果在大多数情况下不满足此条件，则应按条件跳过不必要的计算。</font></font></li>
<li>       .   ,             ( ,  ),      GPU.    ―   (branch granularity),  , , ,          ,      .         ,    ,       .  ,   GPU  ,     ,       . ,      GPU,   ,  1 (PowerVR SGX).</li>
</ol><br>
<img src="https://habrastorage.org/webt/i7/8y/x9/i78yx9mn7egjmojcmxl67crz1kc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可视化不同程度的连贯性</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在重建片段的情况下，要考虑以下两个方面：在大多数情况下，分支条件将允许中断资源密集型操作以重建景观的颜色，并且该条件是一致的，除了极少数的片段（在这些示例中，这些片段是在“红色”和“绿色”区域之间的边界上）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k3/do/ic/k3doicnobaqmuv82xbdfvq_kgas.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">景观碎片重建的连贯性</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
关于这种混合方法</font><i><font style="vertical-align: inherit;">，</font></i><font style="vertical-align: inherit;">仍然需要添加一些注释：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅当景观启用了</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绘制实例化”模式时，Unity才会提供所有必要的纹理</font><sup><font style="vertical-align: inherit;">[20]</font></sup><font style="vertical-align: inherit;">，否则法线贴图将不可用，从而使您无法正确地重构景观照明以进行混合。</font></font></li>
<li> Unity API    ,      (base map)         . -          .</li>
<li>         ,   API          (, Metal   16  ). </li>
<li>    3D-  ,     Terrain,     SRP.</li>
<li> 3D-      ,       3D-    . </li>
<li>,   «» ,     «»  .    ,  «»      ,             .  «»          .</li>
</ol><br>
<img src="https://habrastorage.org/webt/9z/yi/y-/9zyiy-6z47y7pxyonhwrl31zyoc.png"><br>
<i>    </i><br>
<br>
<br>
<h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在设计3D模型时，不可能考虑到应该使用这些模型的各种地形浮雕。通常，3D模型必须在景观中深深“下沉”或旋转以隐藏突出的零件，反之亦然-以便显示应该可见的隐藏零件。 “预热”模型限制了它们的适用性，如果3D模型的绘制早于景观，则还会导致透支效果。反过来，转弯也远非适用于所有3D模型（例如，不适用于房屋和树木）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ue/tg/8y/uetg8yx5ctdsn80stvnnezplgh4.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要隐藏3D模型的突出元素，必须将其“淹没”在景观中</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
捕捉是图形编辑器用户熟悉的一个术语。此功能允许控制点“粘贴”到空间网格的节点，并在3D编辑器中粘贴到其他对象的面和表面。在顶点着色器中捕捉到景观高度的地图可以大大简化场景的设计。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4w/1t/xw/4w1txwi3vaczzpne7ewajozlymo.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有捕捉的3D模型。具有顶点捕捉功能的3D模型。具有顶点捕捉和融合功能的3D模型。具有顶点捕捉，混合和静态照明的3D模型</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实施捕捉的主要困难是，您需要确定3D模型的哪些顶点需要捕捉到高度图，哪些顶点不值得。</font><font style="vertical-align: inherit;">顶点仅包含有关表面局部性质的信息（这还不够），不包含有关其拓扑结构的任何信息（这是必需的）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与在其他应用程序中一样，通过在顶点中直接实现必要的参数，最容易在建模阶段解决此问题。</font><font style="vertical-align: inherit;">作为这样的参数，您应该选择一个直观的属性-例如，捕捉的权重因子（而不是我们想要的灵活性，而不是到开放曲面边界的距离）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7b/gq/2b/7bgq2bdhdlr13qgeqpgcocvo0q8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">捕捉的加权编码</font></font></i><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看代码</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Per-vertex</span> <span class="hljs-selector-tag">snapping</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">heightmap</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainHeightmapTexture</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">HeightmapScale</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainSize</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainPos</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
<font></font>
   // ...<font></font>
<font></font>
   float3 <span class="hljs-attribute">worldPos </span>: TEXCOORD0;<font></font>
   float2 <span class="hljs-attribute">heightMapUV </span>: TEXCOORD1;<font></font>
<font></font>
   // ...<font></font>
<font></font>
};<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
   <font></font>
    // ...<font></font>
    <font></font>
    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<font></font>
    o.heightMapUV = TerrainUV(o.worldPos);<font></font>
    float snappingWeight = v.color.r;                <font></font>
    half height = TerrainHeight( o.heightMapUV );                <font></font>
    o.worldPos.y = lerp( o.worldPos.y, height, snappingWeight );<font></font>
    o.pos = UnityWorldToClipPos( half4( o.worldPos, 1 ) );<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顶点捕捉的适用性受到地形和3D模型表面之间的一般对应关系的限制。</font><font style="vertical-align: inherit;">为了弥补它们之间的显着差异，有必要使用其他更占用资源的方法-例如，使用带有蒙皮的3D模型。</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文的主要思想是：任何足够复杂且具有潜在可伸缩性的着色器都需要基本数据。</font><font style="vertical-align: inherit;">开发人员的任务是了解图形系统的操作方式：它提供什么数据，如何将它们彼此组合以及如何在着色器中使用它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在一般情况下，我们可以得出结论，克服限制图形效果可能性的框架的唯一选择是组合各种着色器的结果。</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看连结</font></font></b><div class="spoiler_text"><sup>[1]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.unity3d.com/Manual/SL-CameraDepthTexture.html</a><br>
<sup>[2]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.unity3d.com/ScriptReference/Camera-depthTextureMode.html</a><br>
<sup>[3]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.unity3d.com/ScriptReference/RenderTexture.html</a><br>
<sup>[4]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.khronos.org/opengl/wiki/Framebuffer_Object</a><br>
<sup>[5]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.microsoft.com/en-us/windows/win32/api/d3d11/nf-d3d11-id3d11device-createrendertargetview</a><br>
<sup>[6]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.unity3d.com/ScriptReference/Rendering.BlendMode.html</a><br>
<sup>[7]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.unity3d.com/ScriptReference/Rendering.BlendOp.html</a><br>
<sup>[8]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.khronos.org/opengl/wiki/Blending</a><br>
<sup>[9]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.microsoft.com/en-us/windows/win32/direct3d11/d3d10-graphics-programming-guide-blend-state</a><br>
<sup>[10]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">en.wikipedia.org/wiki/Parallax</a><br>
<sup>[11]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">en.wikipedia.org/wiki/Parallax_scrolling</a><br>
<sup>[12]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainData-heightmapTexture.html</a><br>
<sup>[13]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pdfs.semanticscholar.org/ce6c/fcafe3581a7e4d7184a9727cc504bdc6b295.pdf</a><br>
<sup>[14]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/Terrain-normalmapTexture.html</a><br>
<sup>[15]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/Terrain-lightmapIndex.html</a><br>
<sup>[16]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainData-alphamapTextures.html</a><br>
<sup>[17]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainData-terrainLayers.html</a><br>
<sup>[18]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainLayer-tileSize.html</a><br>
<sup>[19]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainLayer-tileOffset.html</a><br>
<sup>[20]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/Terrain-drawInstanced.html</a><br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN490204/index.html">2020年3月HR和IT招聘人员的事件摘要</a></li>
<li><a href="../zh-CN490208/index.html">DUMP2020的后端部分：戏ter，迷，失败</a></li>
<li><a href="../zh-CN490210/index.html">加快前端速度。当许多服务器请求都很好时</a></li>
<li><a href="../zh-CN490222/index.html">死亡日标准图书馆</a></li>
<li><a href="../zh-CN490224/index.html">时尚的隐形</a></li>
<li><a href="../zh-CN490232/index.html">使用AWS ELB进行负载平衡</a></li>
<li><a href="../zh-CN490242/index.html">SIM800x模块的GSM定位服务及其与Yandex.Locator API的配合</a></li>
<li><a href="../zh-CN490244/index.html">使用ctypes的Python代码优化</a></li>
<li><a href="../zh-CN490246/index.html">九头蛇拥抱克里姆林宫塔：九头蛇2020并行和分布式计算会议</a></li>
<li><a href="../zh-CN490248/index.html">网络研讨会“ Winnum CNC：有效的监控”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>