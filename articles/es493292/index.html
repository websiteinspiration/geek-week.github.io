<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏽 📈 💝 ¿Responsivo o receptivo? Estructura de componentes de análisis de reacción 🚶🏾 ✋🏾 🧕🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este artículo, entenderemos la complejidad de escribir componentes adaptativos, hablaremos sobre la división del código, consideraremos varias form...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>¿Responsivo o receptivo? Estructura de componentes de análisis de reacción</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/youla/blog/493292/"><img src="https://habrastorage.org/webt/86/uj/wu/86ujwufflu-omcpppq0p9s0nnng.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este artículo, entenderemos la complejidad de escribir componentes adaptativos, hablaremos sobre la división del código, consideraremos varias formas de organizar la estructura del código, evaluaremos sus ventajas y desventajas e intentaremos elegir el mejor (pero esto no es exacto).</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, tratemos con la terminología. A menudo escuchamos los términos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adaptativo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">receptivo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . ¿Qué quieren decir? ¿Cuál es la diferencia? ¿Cómo se relaciona esto con nuestros componentes? </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adaptativo</font></font></strong></a><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (adaptativo)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un complejo de interfaces visuales creadas para tamaños de pantalla específicos. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Responsive</font></font></strong></a><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Responsive)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es una interfaz única que se adapta a cualquier tamaño de pantalla. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, cuando la interfaz se descompone en pequeños fragmentos, la diferencia entre adaptativa y sensible se vuelve cada vez más borrosa, hasta que desaparece por completo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al desarrollar diseños, nuestros diseñadores, así como los desarrolladores, a menudo no comparten estos conceptos y combinan lógica adaptativa y receptiva.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, llamaré a los componentes que contienen lógica adaptativa y receptiva como </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplemente adaptativos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En primer lugar, porque me gusta más esta palabra que "receptivo" o, perdóname, "receptivo". Y en segundo lugar, me parece más común. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me centraré en dos áreas de interfaces de pantalla: móvil y de escritorio. Por pantalla móvil queremos decir ancho, por ejemplo, ≤ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">991 píxeles</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(el número en sí mismo no es importante, es solo una constante, que depende de su sistema de diseño y su aplicación), y debajo de la pantalla del escritorio, el ancho es mayor que el umbral seleccionado. </font><font style="vertical-align: inherit;">Extrañaré intencionalmente pantallas para tabletas y monitores de pantalla ancha, porque, en primer lugar, no todos los necesitan, y en segundo lugar, será más fácil decirlo de esta manera. </font><font style="vertical-align: inherit;">Pero los patrones de los que vamos a hablar se expanden igualmente para cualquier número de "mapeos". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, casi no hablaré sobre </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CSS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , principalmente hablaremos sobre la lógica de componentes.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frontend @youla </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hablaré brevemente sobre nuestra pila en Yulia para que quede claro en qué condiciones creamos nuestros componentes. Usamos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React / Redux</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , trabajamos en monorep, usamos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typecript</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y escribimos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CSS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">componentes</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con </font><strong><font style="vertical-align: inherit;">estilo</font></strong><font style="vertical-align: inherit;"> . Como ejemplo, veamos nuestros tres paquetes (los paquetes en el concepto de monoreps son paquetes NPM que están interconectados, que pueden ser aplicaciones, bibliotecas, utilidades o componentes separados; usted elige el grado de descomposición). Analizaremos dos aplicaciones y una biblioteca de IU. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@ youla / ui</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- biblioteca de componentes. Son utilizados no solo por nosotros, sino también por otros equipos que necesitan interfaces "Yulian". La biblioteca tiene muchas cosas, comenzando con botones y campos de entrada, y terminando, por ejemplo, con un encabezado o un formulario de autorización (más precisamente, su parte de la interfaz de usuario). Consideramos que esta biblioteca es una dependencia externa de nuestra aplicación. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@ youla-web / app-Classified</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : la aplicación responsable de las secciones del catálogo / producto / autorización. De acuerdo con los requisitos comerciales, todas las interfaces aquí deben ser </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adaptativas</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@ youla-web / app-b2b</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es la aplicación responsable de las secciones de su cuenta personal para usuarios profesionales. Las interfaces de esta aplicación son exclusivamente de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escritorio</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además consideraremos escribir componentes adaptativos usando el ejemplo de estos paquetes. </font><font style="vertical-align: inherit;">Pero primero debes lidiar con eso </font></font><code>isMobile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definición de movilidad isMobile &amp;&amp; &lt;Component /&gt;</font></font></h2><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> App = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
 <span class="hljs-keyword">const</span> { isMobile } = props<font></font>
<font></font>
 <span class="hljs-keyword">return</span> (
   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Layout</span>&gt;</span>
     {isMobile &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">HeaderMobile</span> /&gt;</span>}
     <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> /&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">Footer</span> /&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">Layout</span>&gt;</span></span><font></font>
 )<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de comenzar a escribir componentes adaptativos, debe aprender a definir "movilidad". </font><font style="vertical-align: inherit;">Hay muchas formas de implementar la definición de movilidad. </font><font style="vertical-align: inherit;">Quiero detenerme en algunos puntos clave.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Determinación de la movilidad por ancho de pantalla y agente de usuario </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mayoría de ustedes saben bien cómo implementar ambas opciones, pero repasemos brevemente los puntos principales nuevamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando se trabaja con el ancho de la pantalla, se acostumbra establecer puntos de límite, después de lo cual la aplicación debe comportarse como móvil o de escritorio. </font><font style="vertical-align: inherit;">El procedimiento es el siguiente:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cree constantes con puntos de límite y guárdelos en el asunto (si su solución CSS lo permite). </font><font style="vertical-align: inherit;">Los valores en sí pueden ser lo que sus diseñadores encuentran más apropiados para su </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistema de IU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
<li><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guardamos el</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tamaño de pantalla actual en una </font><font style="vertical-align: inherit;">fuente de datos </font><strong><font style="vertical-align: inherit;">redux / mobx / context / any</font></strong><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En cualquier lugar, si solo los componentes y, preferiblemente, la lógica de la aplicación tuvieran acceso a estos datos.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos suscribimos al evento de cambio de tamaño y actualizamos el valor del ancho de la pantalla al que activará la cadena de actualizaciones del árbol de componentes.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creamos funciones auxiliares simples que, utilizando anchos de pantalla y constantes, calculan el estado actual ( </font></font><code>isMobile</code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font></strong><code>isDesktop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí está el pseudocódigo que implementa este modelo de trabajo:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> breakpoints = {
 <span class="hljs-attr">mobile</span>: <span class="hljs-number">991</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> state = {
 <span class="hljs-attr">ui</span>: {
   <span class="hljs-attr">width</span>: <span class="hljs-literal">null</span><font></font>
 }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> handleSubscribe = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
 state.ui.width = <span class="hljs-built_in">window</span>.innerWidth<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> onSubscribe = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
 <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'resize'</span>, handleSubscribe)<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> offSubscribe = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
 <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'resize'</span>, handleSubscribe)<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getIsMobile = <span class="hljs-function">(<span class="hljs-params">state: any</span>) =&gt;</span> {
 <span class="hljs-keyword">if</span> (state.ui.width &lt;= breakpoints.mobile) {
   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
 }<font></font>
<font></font>
 <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getIsDesktop = <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> !getIsMobile(state)<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
 React.useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
   onSubscribe()<font></font>
<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> offSubscribe()<font></font>
 }, [])<font></font>
<font></font>
 <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponentMounted</span> /&gt;</span></span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> MyComponent = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
 <span class="hljs-keyword">const</span> { isMobile } = props<font></font>
<font></font>
 <span class="hljs-keyword">return</span> isMobile ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MobileComponent</span> /&gt;</span></span> : <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">DesktopComponent</span> /&gt;</span></span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> MyComponentMounted = anyHocToConnectComponentWithState(
 <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({
   <span class="hljs-attr">isMobile</span>: getIsMobile(state)<font></font>
 })<font></font>
)(MyComponent)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando la pantalla cambia, los valores </font></font><code>props</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para el componente se actualizarán y se redibujarán correctamente. Hay muchas bibliotecas que implementan esta funcionalidad. Será más conveniente para alguien usar una solución preparada, por ejemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">react-media</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">react-responsive</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , etc., y para alguien es más fácil escribir la </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">suya</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A diferencia del tamaño de la pantalla, </font></font><code>user-agent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no puede cambiar dinámicamente mientras la aplicación se está ejecutando (estrictamente hablando, tal vez a través de las herramientas del desarrollador, pero este no es un escenario de usuario). En este caso, no necesitamos usar una lógica compleja con el almacenamiento del valor y el recuento, solo analice la cadena una vez </font></font><code>window.navigator.userAgent,</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para guardar el valor y listo. Hay un montón de bibliotecas para ayudarlo con esto, por ejemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">detección móvil</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">react-device-detect</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El enfoque es </font></font><code>user-agent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">más simple, pero solo usarlo no es suficiente. Cualquiera que haya desarrollado seriamente interfaces adaptativas sabe sobre el "giro mágico" de los iPads y dispositivos similares, que en la posición vertical entran en la definición de móvil, y en el escritorio horizontal, pero al mismo tiempo tienen un </font></font><code>user-agent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dispositivo móvil. También vale la pena señalar que en una aplicación totalmente adaptativa / receptiva, </font></font><code>user-agent </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es imposible determinar la movilidad </font><font style="vertical-align: inherit;">basada en información sobre uno solo </font><font style="vertical-align: inherit;">si el usuario usa, por ejemplo, un navegador de escritorio, pero comprime la ventana al tamaño "móvil". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, no descuide la información sobre </font></font><code>user-agent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Muy a menudo en el código puede encontrar constantes como </font></font><code>isSafari</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font><code>isIE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etc. que manejan las "características" de estos dispositivos y navegadores. Es mejor combinar ambos enfoques. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestra base de código, utilizamos una constante </font></font><code>isCheesySafari</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que, como su nombre lo indica, define la pertenencia </font></font><code>user-agent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la familia del navegador Safari. Pero además de esto, tenemos una constante </font></font><code>isSuperCheesySafari</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo que implica un Safari móvil correspondiente a la versión 11 de iOS, que se ha hecho famoso por muchos errores como este: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://hackernoon.com/how-to-fix-the-ios-11-input-element -in-fixed-modals-bug-aaf66c7ba3f8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> isMobileUA = <span class="hljs-function">(<span class="hljs-params">(</span>) =&gt;</span> magicParser(<span class="hljs-built_in">window</span>.navigator.userAgent))()<font></font>
<font></font>
<span class="hljs-keyword">import</span> isMobileUA <span class="hljs-keyword">from</span> <span class="hljs-string">'./isMobileUA'</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> MyComponent = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
 <span class="hljs-keyword">const</span> { isMobile } = props<font></font>
<font></font>
 <span class="hljs-keyword">return</span> (isMobile || isMobileUA) ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MobileComponent</span> /&gt;</span></span> : <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">DesktopComponent</span> /&gt;</span></span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué pasa con las consultas de los medios? </font><font style="vertical-align: inherit;">Sí, de hecho, CSS tiene herramientas integradas para trabajar con adaptabilidad: consultas de medios y su método analógico </font></font><code>window.matchMedia</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se pueden usar, pero la lógica de "actualizar" los componentes al cambiar el tamaño aún tendrá que implementarse. </font><font style="vertical-align: inherit;">Aunque para mí personalmente, usar la sintaxis de las consultas de medios en lugar de las operaciones de comparación habituales en JS para la lógica y los componentes de la aplicación es una ventaja dudosa.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Organización de la estructura de los componentes.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hemos descubierto la definición de movilidad, ahora reflexionemos sobre el uso de los datos que hemos obtenido y la organización de la estructura del código del componente. En nuestro código, como regla, prevalecen dos tipos de componentes. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El primer tipo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son los componentes, afilados debajo del teléfono celular o debajo del escritorio. En dichos componentes, los nombres a menudo contienen las palabras Mobile / Desktop, que indican claramente que el componente pertenece a uno de los tipos. Como un ejemplo de dicho componente puede considerarse </font></font><code>&lt;MobileList /&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde </font></font><code>@youla/ui</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { Panel, Cell, Content, afterBorder } <span class="hljs-keyword">from</span> <span class="hljs-string">'./styled'</span>
<span class="hljs-keyword">import</span> Group <span class="hljs-keyword">from</span> <span class="hljs-string">'./Group'</span>
<span class="hljs-keyword">import</span> Button, { IMobileListButtonProps } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Button'</span>
<span class="hljs-keyword">import</span> ContentOrButton, { IMobileListContentOrButton } <span class="hljs-keyword">from</span> <span class="hljs-string">'./ContentOrButton'</span>
<span class="hljs-keyword">import</span> Action, { IMobileListActionProps } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Action'</span><font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> { Panel, Group, Cell, Content, Button, ContentOrButton, Action }
<span class="hljs-keyword">export</span> {<font></font>
 afterBorder,<font></font>
 IMobileListButtonProps,<font></font>
 IMobileListContentOrButton,<font></font>
 IMobileListActionProps<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este componente, además de la exportación muy detallada, es una lista con datos, separadores, agrupaciones por bloques, etc. Nuestros diseñadores son muy aficionados a este componente y en todas partes lo usan en las interfaces de Ula. Por ejemplo, en la descripción en la página del producto o en nuestra nueva funcionalidad de tarifas: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/e5/m_/p-/e5m_p-fw1vefwo2330gmeh21kbw.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y en N lugares alrededor del sitio. También tenemos un componente similar </font></font><code>&lt;DesktopList /&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que implementa esta funcionalidad de lista para la resolución de escritorio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los componentes del </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segundo tipo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contienen la lógica tanto del escritorio como del móvil. Veamos una versión simplificada de la representación de nuestro componente </font></font><code>&lt;HeaderBoard /&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que se encuentra en @ youla / app-Classified.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hemos encontrado para mí es muy conveniente para hacer todos los componentes de estilo para un componente en un solo archivo y la importación en virtud de los espacios de nombres S, para separar el código de los otros componentes: </font></font><code>import * as S from ‘./styled’</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En consecuencia, "S" es un objeto cuyas claves son los nombres de los componentes con estilo, y los valores son los propios componentes.</font></font><br>
<br>
<pre><code class="javascript hljs"> <span class="hljs-keyword">return</span> (
   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">HeaderWrapper</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">Logo</span> /&gt;</span>
     {isMobile &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">S.Arrow</span> /&gt;</span>}
     <span class="hljs-tag">&lt;<span class="hljs-name">S.Wraper</span> <span class="hljs-attr">isMobile</span>=<span class="hljs-string">{isMobile}</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">Video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{bgVideo}</span> /&gt;</span>
       {!isMobile &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">Header</span>&gt;</span>{headerContent}<span class="hljs-tag">&lt;/<span class="hljs-name">Header</span>&gt;</span>}
       <span class="hljs-tag">&lt;<span class="hljs-name">S.WaveWrapper</span> /&gt;</span>
     <span class="hljs-tag">&lt;/<span class="hljs-name">S.Wraper</span>&gt;</span>
     {isMobile &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">S.MobileHeader</span>&gt;</span>{headerContent}<span class="hljs-tag">&lt;/<span class="hljs-name">S.MobileHeader</span>&gt;</span>}
     <span class="hljs-tag">&lt;<span class="hljs-name">Info</span> <span class="hljs-attr">link</span>=<span class="hljs-string">{link}</span> /&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">PaintingInfo</span> <span class="hljs-attr">isMobile</span>=<span class="hljs-string">{isMobile}</span> /&gt;</span>
     {isMobile ? <span class="hljs-tag">&lt;<span class="hljs-name">CardsMobile</span> /&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">CardsDesktop</span> /&gt;</span>}
     {isMobile ? <span class="hljs-tag">&lt;<span class="hljs-name">UserNavigation</span> /&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">UserInfoModal</span> /&gt;</span>}
   <span class="hljs-tag">&lt;/<span class="hljs-name">HeaderWrapper</span>&gt;</span></span><font></font>
 )<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí </font></font><code>isMobile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es la dependencia del componente, sobre la base de la cual el componente mismo decidirá qué interfaz renderizar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para una escala más conveniente, a menudo usamos el patrón de inversión de control en las partes reutilizadas de nuestro código, pero tenga cuidado de no sobrecargar las abstracciones de nivel superior con lógica innecesaria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora vamos a abstraernos un poco de los componentes "Yulian" y echemos un vistazo más de cerca a estos dos componentes:</font></font><br>
<br>
<ul>
<li><code>&lt;ComponentA /&gt;</code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Con una estricta separación de la lógica de escritorio y móvil.</font></font></li>
<li><code>&lt;ComponentB /&gt;</code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> combinado.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;Componente A /&gt; vs &lt;Componente B /&gt;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estructura de carpetas y archivo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">index.ts</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> raíz </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs">./ComponentA<font></font>
- ComponentA.tsx<font></font>
- ComponentADesktop.tsx<font></font>
- ComponentAMobile.tsx<font></font>
- index.ts<font></font>
- styled.desktop.ts<font></font>
- styled.mobile.ts<font></font>
</code></pre><br>
<pre><code class="javascript hljs">
<span class="hljs-keyword">import</span> ComponentA  <span class="hljs-keyword">from</span> <span class="hljs-string">'./ComponentA'</span>
<span class="hljs-keyword">import</span> ComponentAMobile  <span class="hljs-keyword">from</span> <span class="hljs-string">'./ComponentAMobile'</span>
<span class="hljs-keyword">import</span> ComponentADesktop  <span class="hljs-keyword">from</span> <span class="hljs-string">'./ComponentADesktop'</span><font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
 <span class="hljs-attr">ComponentACombined</span>: ComponentA,<font></font>
 ComponentAMobile,<font></font>
 ComponentADesktop<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gracias a la nueva tecnología web-shaking webpack (o al uso de cualquier otro recopilador), puede descartar los módulos no utilizados ( </font></font><code>ComponentADesktop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ComponentACombined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), incluso con esta reexportación a través del archivo raíz:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> ComponentA <span class="hljs-keyword">from</span> ‘@youla/ui’<font></font>
&lt;ComponentA.ComponentAMobile /&gt;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solo el código del archivo ./ComponentAMobile ingresa al paquete final. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El componente </font></font><code>&lt;ComponentA /&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contiene importaciones asincrónicas utilizando una </font></font><code>React.Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versión específica del componente </font></font><code>&lt;ComponentAMobile /&gt; || &lt;ComponentADesktop /&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para una situación específica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Yule intentamos adherirnos al patrón de un único punto de entrada en el componente a través del archivo de índice. Esto facilita la búsqueda y refactorización de componentes. Si el contenido del componente no se reexporta a través del archivo raíz, entonces podemos editarlo con seguridad, ya que sabemos que no se usa fuera del contexto de este componente. Bueno, Typecript se cubrirá en caso de necesidad. La carpeta con el componente tiene su propia "interfaz": exporta a nivel de módulo en el archivo raíz, y sus detalles de implementación no se revelan. Como resultado, al refactorizar, no puede temer guardar la interfaz.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> ComponentADesktopLazy = React.lazy(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./ComponentADesktop'</span>))
<span class="hljs-keyword">const</span> ComponentAMobileLazy = React.lazy(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./ComponentAMobile'</span>))<font></font>
<font></font>
<span class="hljs-keyword">const</span> ComponentA = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
 <span class="hljs-keyword">const</span> { isMobile } = props<font></font>
<font></font>
<span class="hljs-comment">//    </span><font></font>
<font></font>
 <span class="hljs-keyword">return</span> (
   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{props.fallback}</span>&gt;</span>
     {isMobile ? (
       <span class="hljs-tag">&lt;<span class="hljs-name">ComponentAMobileLazy</span> {<span class="hljs-attr">...props</span>} /&gt;</span>
     ) : (
       <span class="hljs-tag">&lt;<span class="hljs-name">ComponentADesktopLazy</span> {<span class="hljs-attr">...props</span>} /&gt;</span>
     )}
   <span class="hljs-tag">&lt;/<span class="hljs-name">React.Suspense</span>&gt;</span></span><font></font>
 )<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ComponentA
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, el componente </font></font><code>&lt;ComponentADesktop /&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contiene la importación de componentes de escritorio:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><font></font>
<font></font>
<span class="hljs-keyword">import</span> { DesktopList, UserAuthDesktop, UserInfo } <span class="hljs-keyword">from</span> <span class="hljs-string">'@youla/ui'</span><font></font>
<font></font>
<span class="hljs-keyword">import</span> Banner <span class="hljs-keyword">from</span> <span class="hljs-string">'../Banner'</span><font></font>
<font></font>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> S <span class="hljs-keyword">from</span> <span class="hljs-string">'./styled.desktop'</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> ComponentADesktop = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
 <span class="hljs-keyword">const</span> { user, items } = props<font></font>
<font></font>
 <span class="hljs-keyword">return</span> (
   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">S.Wrapper</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">S.Main</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">Banner</span> /&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">DesktopList</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span> /&gt;</span>
     <span class="hljs-tag">&lt;/<span class="hljs-name">S.Main</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">S.SideBar</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">UserAuthDesktop</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{user}</span> /&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">UserInfo</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{user}</span> /&gt;</span>
     <span class="hljs-tag">&lt;/<span class="hljs-name">S.SideBar</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">S.Wrapper</span>&gt;</span></span><font></font>
 )<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ComponentADesktop
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un componente </font></font><code>&lt;ComponentAMobile /&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contiene la importación de componentes móviles:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><font></font>
<font></font>
<span class="hljs-keyword">import</span> { MobileList, MobileTabs, UserAuthMobile } <span class="hljs-keyword">from</span> <span class="hljs-string">'@youla/ui'</span><font></font>
<font></font>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> S <span class="hljs-keyword">from</span> <span class="hljs-string">'./styled.mobile'</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> ComponentAMobile = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
 <span class="hljs-keyword">const</span> { user, items, tabs } = props<font></font>
<font></font>
 <span class="hljs-keyword">return</span> (
   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">S.Wrapper</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">S.Main</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">UserAuthMobile</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{user}</span> /&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">MobileList</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span> /&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">MobileTabs</span> <span class="hljs-attr">tabs</span>=<span class="hljs-string">{tabs}</span> /&gt;</span>
     <span class="hljs-tag">&lt;/<span class="hljs-name">S.Main</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">S.Wrapper</span>&gt;</span></span><font></font>
 )<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ComponentAMobile
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El componente es </font></font><code>&lt;ComponentA /&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adaptable: según el indicador, </font></font><code>isMobile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede decidir qué versión dibujar, solo puede descargar los archivos necesarios de forma asincrónica, es decir, las versiones móvil y de escritorio se pueden usar por separado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos el componente ahora </font></font><code>&lt;ComponentB /&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En él, no descompondremos profundamente la lógica móvil y de escritorio, dejaremos todas las condiciones dentro del marco de una función. </font><font style="vertical-align: inherit;">Del mismo modo, no separaremos los componentes de los estilos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí está la estructura de carpetas. </font><font style="vertical-align: inherit;">El archivo root index.ts simplemente reexporta </font></font><code>./ComponentB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs">./ComponentB<font></font>
- ComponentB.tsx<font></font>
- index.ts<font></font>
- styled.ts<font></font>
</code></pre><br>
<pre><code class="javascript hljs">
<span class="hljs-keyword">export</span> { <span class="hljs-keyword">default</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./ComponentB'</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El archivo ./ComponentB con el componente en sí:</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span><font></font>
<font></font>
<span class="hljs-keyword">import</span> {<font></font>
 DesktopList,<font></font>
 UserAuthDesktop,<font></font>
 UserInfo,<font></font>
 MobileList,<font></font>
 MobileTabs,<font></font>
 UserAuthMobile<font></font>
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@youla/ui'</span><font></font>
<font></font>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> S <span class="hljs-keyword">from</span> <span class="hljs-string">'./styled'</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> ComponentB = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
 <span class="hljs-keyword">const</span> { user, items, tabs, isMobile } = props<font></font>
<font></font>
 <span class="hljs-keyword">if</span> (isMobile) {
   <span class="hljs-keyword">return</span> (
     <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">S.Wrapper</span> <span class="hljs-attr">isMobile</span>=<span class="hljs-string">{isMobile}</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">S.Main</span> <span class="hljs-attr">isMobile</span>=<span class="hljs-string">{isMobile}</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">UserAuthMobile</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{user}</span> /&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">MobileList</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span> /&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">MobileTabs</span> <span class="hljs-attr">tabs</span>=<span class="hljs-string">{tabs}</span> /&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">S.Main</span>&gt;</span>
     <span class="hljs-tag">&lt;/<span class="hljs-name">S.Wrapper</span>&gt;</span></span><font></font>
   )<font></font>
 }<font></font>
<font></font>
 <span class="hljs-keyword">return</span> (
   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">S.Wrapper</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">S.Main</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">Banner</span> /&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">DesktopList</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span> /&gt;</span>
     <span class="hljs-tag">&lt;/<span class="hljs-name">S.Main</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">S.SideBar</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">UserAuthDesktop</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{user}</span> /&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">UserInfo</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{user}</span> /&gt;</span>
     <span class="hljs-tag">&lt;/<span class="hljs-name">S.SideBar</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">S.Wrapper</span>&gt;</span></span><font></font>
 )<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ComponentB
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tratemos de estimar las ventajas y desventajas de estos componentes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ji/l-/px/jil-pxa15xccew0cgnm6zeauch8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Total de tres pros y contras argumentos extraídos del dedo para cada uno de ellos. </font><font style="vertical-align: inherit;">Sí, noté que algunos criterios se mencionan inmediatamente tanto en ventajas como en desventajas: esto se hizo a propósito, todos los eliminarán del grupo equivocado.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestra experiencia con @youla</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestra biblioteca de componentes @ youla / ui intentamos no mezclar componentes de escritorio y móviles, ya que esta es una dependencia externa para muchos de nuestros paquetes y otros. El ciclo de vida de estos componentes es lo más largo posible, quiero mantenerlos lo más delgados y livianos posible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos puntos importantes</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a tener en cuenta </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, cuanto más pequeño sea el archivo JS ensamblado, más rápido se entregará al usuario, esto es obvio y todos lo saben. Pero esta característica es importante solo para la primera descarga del archivo, durante </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">las visitas repetidas, el</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> archivo se entregará desde el caché y no habrá ningún problema de entrega de código.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí pasamos a la razón número dos, que pronto puede convertirse, o ya se ha convertido, en el principal problema de las grandes aplicaciones web. Muchos ya lo han adivinado: sí, estamos hablando de la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">duración del análisis.</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Los motores modernos como V8 pueden almacenar en caché y el resultado del análisis, pero hasta ahora no funciona de manera muy eficiente. Eddie Osmani tiene un excelente artículo sobre este tema: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://v8.dev/blog/cost-of-javascript-2019 </font></font></a><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> También puede suscribirse al blog V8: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://twitter.com/v8js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es la duración del análisis lo que reduciremos significativamente, esto es especialmente importante para </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dispositivos móviles con procesadores débiles</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los paquetes de aplicación @ youla-web / app- *, ​​el desarrollo está más "orientado a los negocios". Y en aras de la velocidad / simplicidad / preferencias personales, se elige la decisión que el desarrollador mismo considere la más correcta en esta situación. A menudo sucede que cuando se desarrollan funciones MVP pequeñas, es mejor escribir primero una versión más simple y rápida (&lt;ComponentB /&gt;), en dicho componente hay la mitad del número de líneas. Y, como sabemos, cuanto más código, más errores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de verificar la relevancia de la característica, será posible reemplazar el componente con una versión más optimizada y productiva &lt;ComponentA /&gt;, si es necesario.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También le aconsejo que eche un vistazo al componente. </font><font style="vertical-align: inherit;">Si las IU de las versiones móvil y de escritorio son muy diferentes, entonces quizás deberían estar separadas, manteniendo una lógica común en un solo lugar. </font><font style="vertical-align: inherit;">Esto le permitirá deshacerse del dolor al escribir CSS complejos, problemas con errores en una de las pantallas al refactorizar o cambiar otra. </font><font style="vertical-align: inherit;">Y viceversa, si la interfaz de usuario está lo más cerca posible, ¿por qué hacer el trabajo extra?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusión</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para resumir. </font><font style="vertical-align: inherit;">Entendimos la terminología de la interfaz adaptativa / sensible, examinamos varias formas de determinar la movilidad y varias opciones para organizar la estructura de código del componente adaptativo, e identificamos las ventajas y desventajas de cada una. </font><font style="vertical-align: inherit;">Seguramente ya conocías mucho de lo anterior, pero la repetición es la mejor manera de consolidar. </font><font style="vertical-align: inherit;">Espero que hayas aprendido algo nuevo por ti mismo. </font><font style="vertical-align: inherit;">La próxima vez queremos publicar una colección de recomendaciones para escribir aplicaciones web progresivas, con consejos para organizar, reutilizar y mantener el código.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es493274/index.html">Más de 30 recomendaciones profesionales concisas para desarrolladores de Android</a></li>
<li><a href="../es493278/index.html">¿Debo fumar para protegerme contra el SARS-CoV-2?</a></li>
<li><a href="../es493282/index.html">Comprender las políticas de red con Calico</a></li>
<li><a href="../es493284/index.html">Kubernetes 1.18: Resumen de las innovaciones clave</a></li>
<li><a href="../es493288/index.html">Cinco citas de programación explicadas famosas</a></li>
<li><a href="../es493294/index.html">Miramos dentro del circuito integrado soviético con TTL</a></li>
<li><a href="../es493298/index.html">C ++, registros de metaprogramación y microcontroladores</a></li>
<li><a href="../es493300/index.html">Cálculo del centro de masa para O (1) utilizando imágenes integradas</a></li>
<li><a href="../es493302/index.html">¿Qué tecnologías ya se han solicitado para luchar contra el coronavirus?</a></li>
<li><a href="../es493304/index.html">Desarrollar un hexápodo desde cero (parte 8): movimiento matemático mejorado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>