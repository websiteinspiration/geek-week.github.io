<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💆🏼 🤙🏻 😥 増分ベクトル要素 👨‍👩‍👦 🔁 🛥️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="どの場合、std ::ベクトル要素のインクリメントはより速くなります-それらがuint8_tまたはuint32_t型である場合？
 
 抽象的に推論しないために、2つの特定の実装を検討します。
 
 

void vector8_inc(std::vector<uint8_t>& v) { for ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>増分ベクトル要素</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/475636/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どの場合、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std ::ベクトル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素のインクリメントは</font><font style="vertical-align: inherit;">より速くなります-それらが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint32_t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型である場合</font><font style="vertical-align: inherit;">？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
抽象的に推論しないために、2つの特定の実装を検討します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector8_inc</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint8_t</span>&gt;&amp; v)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; v.size(); i++)<font></font>
  {<font></font>
    v[i]++;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector32_inc</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;&amp; v)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; v.size(); i++)<font></font>
  {<font></font>
    v[i]++;<font></font>
  }<font></font>
}</code></pre><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推測してみましょう</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この質問は、ベンチマークを使用して簡単に答えることができますが、少し後でそれを行いますが、最初に推測を試みます（これは、「基本的な原則に基づく推論」と呼ばれます-シンチラのように聞こえます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、質問する価値</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があり</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><i><font style="vertical-align: inherit;">これらのベクトルのサイズは</font></i><font style="vertical-align: inherit;">どれ</font><i><font style="vertical-align: inherit;">くらい</font></i><font style="vertical-align: inherit;">ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、いくつかの番号を選んでみましょう。それぞれに20,000個の要素があるとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、Intel Skylakeプロセッサでテストすることがわかっています</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-8ビット</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">32 </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ビットの</font></a><font style="vertical-align: inherit;">追加コマンドの特性を確認し</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接アドレッシングのオペランド。主な指標は同じであることがわかります。1サイクルあたり1オペレーション、メモリアクセスごとに4サイクルの遅延（1）。この場合、各加算演算は独立して実行されるため、計算された速度は1サイクルあたり1要素になるため、遅延は問題になりません。ただし、ループ上の残りのすべての作業は並列に実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、20,000アイテムは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用するバージョンでは20 </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイトのデータセットに対応し、</font><i><font style="vertical-align: inherit;">uint32_t</font></i><font style="vertical-align: inherit;">を使用するバージョンでは</font><i><font style="vertical-align: inherit;">最大</font></i><font style="vertical-align: inherit;"> 80 </font><i><font style="vertical-align: inherit;">K</font></i><font style="vertical-align: inherit;">バイトに</font><font style="vertical-align: inherit;">対応することにも注意し</font><font style="vertical-align: inherit;">て</font><i><font style="vertical-align: inherit;">ください</font></i><font style="vertical-align: inherit;">。最初のケースでは、それらは現代のx86ベースのコンピューターのL1レベルのキャッシュに理想的に適合し、2番目のケースには適合しません-いいえ。効率的なキャッシングにより、8ビットバージョンは有利なスタートを切ることがわかりましたか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、私たちのタスクは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動ベクトル化の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古典的なケースと非常に似ていることに注意してください。</font><font style="vertical-align: inherit;">既知の反復回数を持つループでは、メモリに順次配置された要素に対して算術演算が実行されます。</font><font style="vertical-align: inherit;">この場合、1つのベクトル演算は4倍の数の要素を処理し、一般にIntelプロセッサは32バイト版と同じ速度でシングルバイト要素に対してベクトル演算を実行するため、8ビット版は32ビット版よりもはるかに優れています。ビット要素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
話をやめて。</font><font style="vertical-align: inherit;">今度はテストに取り掛かります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基準</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適化レベルが異なる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gcc </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8コンパイラー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><i><font style="vertical-align: inherit;">clang 8コンパイラー</font></i><font style="vertical-align: inherit;"> 
で20,000要素のベクトルの次のタイミングを取得しました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/l_/6r/k7/l_6rk7tnbeguzjnreatqtggsopg.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはを除いて、ということが判明し</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-O1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レベル</font><font style="vertical-align: inherit;">、とのバージョン</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のuint32_tが</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速いとのバージョンよりも</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レベルでのGCCの5.4倍：、いくつかのケースでは、それは重要である</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-O3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と正確に両方のレベルで打ち鳴らすの8回、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-O2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- O3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">はい、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std ::ベクトル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の32ビット整数</font><font style="vertical-align: inherit;">の増分は、標準的な最適化設定を使用する一般的なコンパイラーの8ビット整数の増分よりも最大8倍高速です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いつものように、何が起こっているのかが明らかになることを期待して、アセンブラーのリストを見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-O2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レベルでのgcc 8のリストです。8 </font><font style="vertical-align: inherit;">ビットバージョンは、32ビットバージョンよりも1.5倍「遅い」だけです（2）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8ビット：</font></font></b><br>
<br>
<pre><code class="cpp hljs">.L3:<font></font>
    inc     BYTE PTR [rdx+rax]<font></font>
    mov     rdx, QWORD PTR [rdi]<font></font>
    inc     rax<font></font>
    mov     rcx, QWORD PTR [rdi+<span class="hljs-number">8</span>]<font></font>
    sub     rcx, rdx<font></font>
    cmp     rax, rcx<font></font>
    jb      .L3</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32ビット：</font></font></b><br>
<pre><code class="cpp hljs">.L9:<font></font>
    inc     DWORD PTR [rax]<font></font>
    add     rax, <span class="hljs-number">4</span><font></font>
    cmp     rax, rdx<font></font>
    jne     .L9</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
32ビットバージョンは、デプロイされていない（3）ループから期待したとおりに見えます。アドレスを持つインクリメント（4）、次に3つのループ制御コマンド：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raxを追加</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">誘導変数のインクリメント（5）と2つの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jne</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンド</font><font style="vertical-align: inherit;">ループからの終了条件と条件付きジャンプの条件をチェックします。すべてが素晴らしく見えます-デプロイメントはカウンターをインクリメントして状態をチェックするコストを補償し、コードはクロックサイクルごとに1要素の最大可能速度にほぼ達します（6）が、オープンソースアプリケーションの場合はそれで十分です。そして、8ビットバージョンはどうですか？</font><font style="vertical-align: inherit;">アドレスを含む</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンドに加えて</font><font style="vertical-align: inherit;">、2つの追加のメモリ読み取りコマンド、および</font><i><font style="vertical-align: inherit;">サブ</font></i><font style="vertical-align: inherit;">コマンドが実行されます</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どこからともなく。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがコメント付きのリストです：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8ビット：</font></font></b><br>
<br>
<pre><code class="cpp hljs">.L3:<font></font>
    inc     BYTE PTR [rdx+rax]     ;    v[i]<font></font>
    mov     rdx, QWORD PTR [rdi]   ;  v.begin<font></font>
    inc     rax                    ; i++<font></font>
    mov     rcx, QWORD PTR [rdi+<span class="hljs-number">8</span>] ;  v.end<font></font>
    sub     rcx, rdx               ; end - start (.. <span class="hljs-built_in">vector</span>.size())<font></font>
    cmp     rax, rcx               ; i &lt; size()<font></font>
    jb      .L3                    ; .   i &lt; size()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector :: begin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector :: end</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font><font style="vertical-align: inherit;">選択された領域内に含まれる要素のシーケンスの開始と終了を示すために使用する</font><font style="vertical-align: inherit;">内部</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std ::ベクトル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインター</font><font style="vertical-align: inherit;">です（7）。これらは基本的に同じ値です</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector :: begin（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector :: end（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を実装するために使用され</font><i><font style="vertical-align: inherit;">ます（</font></i><font style="vertical-align: inherit;">タイプは異なります）。追加のコマンドはすべて</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector.size（）の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算の結果であることが</font><i><font style="vertical-align: inherit;">わかり</font></i><font style="vertical-align: inherit;">ます。それは珍しいことではないようですか？しかし、結局のところ、32ビットバージョンでは、当然、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズ（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も計算され</font><font style="vertical-align: inherit;">ますが、これらのコマンドはそのリストに含まれていませんでした。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズ（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の計算は</font><font style="vertical-align: inherit;">、ループの外で一度だけ行われました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで、契約は何ですか？</font><font style="vertical-align: inherit;">簡単に言えば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインタのエイリアシング</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">以下に詳細な回答をさせていただきます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">詳細な対応</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ベクトル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、参照によって関数に渡されます。これは、実際には、マスクされたポインターです。コンパイラー</font><i><font style="vertical-align: inherit;">は、</font></i><font style="vertical-align: inherit;">ベクトル</font><font style="vertical-align: inherit;">のメンバー</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v :: begin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v :: endを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照して、</font><font style="vertical-align: inherit;">そのサイズ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size（）を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算</font><i><font style="vertical-align: inherit;">する必要が</font></i><font style="vertical-align: inherit;">あります。</font><font style="vertical-align: inherit;">この例では、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズ（）は</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各反復で</font><font style="vertical-align: inherit;">計算さ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。しかし、コンパイラはソースコードを盲目的に遵守する義務はありません。</font><font style="vertical-align: inherit;">ループの外で</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を呼び出した結果を運ぶ可能性があります</font><font style="vertical-align: inherit;">が、プログラムのセマンティクスが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更されない</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことが確実にわかっている場合のみです</font><font style="vertical-align: inherit;">。この観点から見ると、ループ内の問題のある場所はインクリメント</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v [i] ++だけ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。記録は不明なアドレスで行われます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そのような操作でサイズ（）の値を変更できますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レコードが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: vector &lt;uint32_t&gt;にある場合</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（つまり、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint32_t *</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインターによって</font><font style="vertical-align: inherit;">）、いいえ、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズ（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値を変更できません</font><font style="vertical-align: inherit;">。型のオブジェクトへの書き込み</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のuint32_tする</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のみ型のオブジェクト修正することができる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のuint32_t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算に関与し、ポインタ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のサイズを（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なるタイプ（8）を持っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、の場合に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、少なくとも人気コンパイラ（9）に、答えはこのようになります。はい、理論的値</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の大きさ（</font></font></i></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変化させることができる</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ので、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_tは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の別名で</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char型</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、および型の配列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned char</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、他のタイプのエイリアスにする</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことができます</font><font style="vertical-align: inherit;">。これは、コンパイラーによれば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_tポインター</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">への書き込みは</font><font style="vertical-align: inherit;">、任意のアドレス（10）で不明な発信​​元のメモリーの内容を変更できることを意味します。したがって、各インクリメント操作</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v [i] ++</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size（）の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値を変更できる</font><font style="vertical-align: inherit;">と想定している</font><font style="vertical-align: inherit;">ため、ループの各反復で強制的に再計算されます。</font><i><font style="vertical-align: inherit;">std :: vector</font></i><font style="vertical-align: inherit;">が</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指すメモリへの書き込みは、</font><font style="vertical-align: inherit;">それ自体の</font><i><font style="vertical-align: inherit;">サイズ（）を</font></i><font style="vertical-align: inherit;">変更しないことは</font><font style="vertical-align: inherit;">誰でも知っています</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結局のところ、これはベクター自体が何らかの方法で自身のヒープ内に分離されたことを意味します。これはほとんど不可能であり、鶏と卵の問題に似ています（11）。</font><font style="vertical-align: inherit;">しかし、残念ながら、これはコンパイラにはわかりません！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">残りの結果はどうですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、なぜ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のバージョンが</font><i><font style="vertical-align: inherit;">-O2</font></i><font style="vertical-align: inherit;">レベルでgcc </font><font style="vertical-align: inherit;">の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint32_t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のバージョンよりも少し遅いの</font><font style="vertical-align: inherit;">かがわかりました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、clangまたは</font><i><font style="vertical-align: inherit;">-O3の</font></i><font style="vertical-align: inherit;">同じgccで最大8回までの大きな違いを説明するのはなぜ</font><font style="vertical-align: inherit;">ですか。</font><font style="vertical-align: inherit;">
ここではすべてが単純です</font><i><font style="vertical-align: inherit;">。uint32_t</font></i><font style="vertical-align: inherit;">の場合</font><i><font style="vertical-align: inherit;">、</font></i><font style="vertical-align: inherit;"> clangはループの自動ベクトル化を実行できます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs">.LBB1_6:                ; =&gt;This Inner Loop Header: Depth=<span class="hljs-number">1</span>
    vmovdqu ymm1, ymmword ptr [rax + <span class="hljs-number">4</span>*rdi]<font></font>
    vmovdqu ymm2, ymmword ptr [rax + <span class="hljs-number">4</span>*rdi + <span class="hljs-number">32</span>]<font></font>
    vmovdqu ymm3, ymmword ptr [rax + <span class="hljs-number">4</span>*rdi + <span class="hljs-number">64</span>]<font></font>
    vmovdqu ymm4, ymmword ptr [rax + <span class="hljs-number">4</span>*rdi + <span class="hljs-number">96</span>]<font></font>
    vpsubd  ymm1, ymm1, ymm0<font></font>
    vpsubd  ymm2, ymm2, ymm0<font></font>
    vpsubd  ymm3, ymm3, ymm0<font></font>
    vpsubd  ymm4, ymm4, ymm0<font></font>
    vmovdqu ymmword ptr [rax + <span class="hljs-number">4</span>*rdi], ymm1<font></font>
    vmovdqu ymmword ptr [rax + <span class="hljs-number">4</span>*rdi + <span class="hljs-number">32</span>], ymm2<font></font>
    vmovdqu ymmword ptr [rax + <span class="hljs-number">4</span>*rdi + <span class="hljs-number">64</span>], ymm3<font></font>
    vmovdqu ymmword ptr [rax + <span class="hljs-number">4</span>*rdi + <span class="hljs-number">96</span>], ymm4<font></font>
    vmovdqu ymm1, ymmword ptr [rax + <span class="hljs-number">4</span>*rdi + <span class="hljs-number">128</span>]<font></font>
    vmovdqu ymm2, ymmword ptr [rax + <span class="hljs-number">4</span>*rdi + <span class="hljs-number">160</span>]<font></font>
    vmovdqu ymm3, ymmword ptr [rax + <span class="hljs-number">4</span>*rdi + <span class="hljs-number">192</span>]<font></font>
    vmovdqu ymm4, ymmword ptr [rax + <span class="hljs-number">4</span>*rdi + <span class="hljs-number">224</span>]<font></font>
    vpsubd  ymm1, ymm1, ymm0<font></font>
    vpsubd  ymm2, ymm2, ymm0<font></font>
    vpsubd  ymm3, ymm3, ymm0<font></font>
    vpsubd  ymm4, ymm4, ymm0<font></font>
    vmovdqu ymmword ptr [rax + <span class="hljs-number">4</span>*rdi + <span class="hljs-number">128</span>], ymm1<font></font>
    vmovdqu ymmword ptr [rax + <span class="hljs-number">4</span>*rdi + <span class="hljs-number">160</span>], ymm2<font></font>
    vmovdqu ymmword ptr [rax + <span class="hljs-number">4</span>*rdi + <span class="hljs-number">192</span>], ymm3<font></font>
    vmovdqu ymmword ptr [rax + <span class="hljs-number">4</span>*rdi + <span class="hljs-number">224</span>], ymm4<font></font>
    add     rdi, <span class="hljs-number">64</span>
    add     rsi, <span class="hljs-number">2</span>
    jne     .LBB1_6</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サイクルは8回展開されました。これは一般に、L1キャッシュのクロックサイクルごとに1つのベクター（8要素）を取得できる最大のパフォーマンスです（これは、クロックサイクルごとに1つの書き込み操作の制限があるため機能しなくなります（12））。</font><i><font style="vertical-align: inherit;">uint8_t</font></i><font style="vertical-align: inherit;">では</font><i><font style="vertical-align: inherit;">ベクトル化は</font></i><font style="vertical-align: inherit;">実行さ</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
れ</font><font style="vertical-align: inherit;">ません。これは</font><font style="vertical-align: inherit;">、各反復でループ条件をチェックするために</font><i><font style="vertical-align: inherit;">サイズ（）</font></i><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">計算する必要があるために妨げられるためです</font><font style="vertical-align: inherit;">。ラグの理由は同じですが、ラグ自体ははるかに大きいです。</font><font style="vertical-align: inherit;">
最低のタイミングは自動ベクトル化によって説明され</font><i><font style="vertical-align: inherit;">ます。gcc</font></i><font style="vertical-align: inherit;">は</font><i><font style="vertical-align: inherit;">-O3</font></i><font style="vertical-align: inherit;">レベルでのみ適用され、</font><font style="vertical-align: inherit;">clang </font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">デフォルト</font><font style="vertical-align: inherit;">で</font><i><font style="vertical-align: inherit;">-O2</font></i><font style="vertical-align: inherit;">レベル</font><font style="vertical-align: inherit;">と</font><i><font style="vertical-align: inherit;">-O3</font></i><font style="vertical-align: inherit;">レベルの</font><font style="vertical-align: inherit;">両方で</font><font style="vertical-align: inherit;">適用さ</font><font style="vertical-align: inherit;">れます。</font><i><font style="vertical-align: inherit;">-O3</font></i><font style="vertical-align: inherit;">レベルのGccコンパイラー</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 自動ベクトル化されたループを拡張しないため、clangよりも少し遅いコードを生成します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状況を修正する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは問題が何であるかを知りました-どのようにそれを修正できますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、機能しない1つの方法を試してみましょう。つまり、イテレータに基づいてより慣用的なサイクルを記述します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i =  v.begin(); i != v.end(); ++i)<font></font>
{<font></font>
  (*i)++;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gcc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-O2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レベルで</font><font style="vertical-align: inherit;">
生成するコード</font><font style="vertical-align: inherit;">は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズ（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプションよりもわずかに優れています</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">.L17:<font></font>
    add     BYTE PTR [rax], <span class="hljs-number">1</span>
    add     rax, <span class="hljs-number">1</span>
    cmp     QWORD PTR [rdi+<span class="hljs-number">8</span>], rax<font></font>
    jne     .L17</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの余分な読み取り操作があるため、一つになって</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、私は</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今、私たちはと比較</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンド</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のポインタ</font><font style="vertical-align: inherit;">ベクトル、およびない再計算</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズ（） </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">エンドポインタからのベクトルの先頭へのポインタを差し引きます。コマンドの数に関しては、</font><font style="vertical-align: inherit;">追加の読み取り操作が比較操作とマージされたため</font><font style="vertical-align: inherit;">、このコードは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint32_t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">追いつきました</font><font style="vertical-align: inherit;">。ただし、問題は解消されておらず、自動ベクトル化はまだ利用できません。そのため、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint32_t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よりも</font><font style="vertical-align: inherit;">大幅に遅れ</font><font style="vertical-align: inherit;">ています。自動ベクトル化が提供されるレベルでは、gccとclangの両方で5回以上です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のことを試してみましょう。私たちは再び失敗するでしょう、あるいは、私たちは</font><i><font style="vertical-align: inherit;">別のもの</font></i><font style="vertical-align: inherit;">を見つけるでしょう</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アイドルウェイ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このバージョンでは</font><font style="vertical-align: inherit;">、ループの前に一度だけ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズ（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を計算し</font><font style="vertical-align: inherit;">、結果をローカル変数に入れます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>, s = v.size(); i &lt; s; i++)<font></font>
{<font></font>
  v[i]++;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはうまくいくように見えるべきですか？</font><font style="vertical-align: inherit;">問題となった</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズを（） </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">そして今、私たちは結果コミットするコンパイラを命じ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズ（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローカル変数へ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたは、知っている他のデータと交差しないように、ループの最初、およびローカル変数で。</font><font style="vertical-align: inherit;">コンパイラーができないことを実際に行いました。</font><font style="vertical-align: inherit;">そして、それが生成するコードは、実際には（元のコードと比較して）優れています。</font></font><br>
<br>
<pre><code class="cpp hljs">.L9:<font></font>
        mov     rdx, QWORD PTR [rdi]<font></font>
        add     BYTE PTR [rdx+rax], <span class="hljs-number">1</span>
        add     rax, <span class="hljs-number">1</span><font></font>
        cmp     rax, rcx<font></font>
        jne     .L9</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
追加の読み取り操作は1つだけあり、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンドはありません</font><font style="vertical-align: inherit;">。しかし、この追加コマンド（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rdx、QWORD PTR [rdi]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は、サイズの計算に関与していない場合はどうなりますか？</font><i><font style="vertical-align: inherit;">v</font></i><font style="vertical-align: inherit;">から</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインターを読み取ります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
式</font><i><font style="vertical-align: inherit;">v [i]</font></i><font style="vertical-align: inherit;">は</font><i><font style="vertical-align: inherit;">*（v.data（）+ i）</font></i><font style="vertical-align: inherit;">として実装され</font><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">data（）</font></i><font style="vertical-align: inherit;">（および実際には、通常の</font><i><font style="vertical-align: inherit;">開始</font></i><font style="vertical-align: inherit;">ポインター</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">によって返されるメンバーは</font><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">サイズ（）</font></i><font style="vertical-align: inherit;">と同じ問題を引き起こし</font><font style="vertical-align: inherit;">ます。確かに、元のバージョンではこの操作に気付きませんでした。サイズを計算するために実行する必要があったため、「無料」でした。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう少し我慢して、ほとんど解決策を見つけました。</font><i><font style="vertical-align: inherit;">std :: vectorの</font></i><font style="vertical-align: inherit;">コンテンツへの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存関係を</font><font style="vertical-align: inherit;">ループから削除する必要があるだけです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これを行う最も簡単な方法は、イテレーターを少しイテレーターで変更することです。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = v.begin(), e = v.end(); i != e; ++i)<font></font>
{<font></font>
  (*i)++;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これですべてが劇的に変化しました（ここでは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_tの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バージョンのみを比較します</font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">ループの</font><i><font style="vertical-align: inherit;">前に</font></i><font style="vertical-align: inherit;">ローカル変数</font><i><font style="vertical-align: inherit;">に</font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">終了</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反復子を保存し、もう1 </font><i><font style="vertical-align: inherit;">つでは</font></i><font style="vertical-align: inherit;"> -いいえ）：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/lp/pe/xj/lppexj0vgqumpzvblxctc7xkkoa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この小さな変更により、自動ベクトル化を使用したレベルで速度が20倍向上しました。さらに、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_tを使用</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したコードは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint32_tを使用</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したコードに追いついていないだけでなく</font><font style="vertical-align: inherit;">、gcc </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-O3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とclang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-O2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-O3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によってほぼ正確に4回</font><i><font style="vertical-align: inherit;">オーバークロックし</font></i><font style="vertical-align: inherit;">ました。要素はベクトル演算で処理でき、必要な帯域幅はキャッシュレベルに関係なく4分の1になります（13）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここまで読んだら、いつも自分に向かって宣言しているはずです。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし</font><font style="vertical-align: inherit;">、C ++ 11に登場した</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、範囲のバイパスを備えたforループは</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どうでしょうか。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はあなたを喜ばせようと急いでいます：それはうまくいきます！これは実際には構文上のシュガーであり、イテレータを使用したバージョン</font><font style="vertical-align: inherit;">は、ループの開始前にローカル変数の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンド</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインタを修正したほぼ同じ形式で隠されて</font><font style="vertical-align: inherit;">います。だから彼の速度は同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
突然洞窟時代に戻ってCのような関数を書くことにした場合、そのようなコードも同様に機能します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">array_inc</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span>* a, <span class="hljs-keyword">size_t</span> size)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<font></font>
  {<font></font>
    a[i]++;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、配列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">へのポインター</font><font style="vertical-align: inherit;">と変数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が値によって関数に渡されるため、</font><font style="vertical-align: inherit;">ローカル変数と同様</font><font style="vertical-align: inherit;">に、ポインター</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（14）</font><font style="vertical-align: inherit;">への書き込みの結果としてそれらを変更することはできません</font><font style="vertical-align: inherit;">。このコードのパフォーマンスは、前のオプションのパフォーマンスと同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、このオプションを使用できるコンパイラでは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__ restrict</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（15）</font><font style="vertical-align: inherit;">を使用してベクトルを宣言できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector8_inc_restrict</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint8_t</span>&gt;&amp; __restrict v)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; v.size(); i++)<font></font>
  {<font></font>
    v[i]++;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__restrictキーワードは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C ++標準の一部が、の一部ではない</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">C99ので</font></a><font style="vertical-align: inherit;">（AS </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制限します</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。コンパイラーでC ++拡張機能として実装されている場合は、Cのセマンティクスに従う可能性が高いです。もちろん、Cにはリンクがないため、ベクターリンクをベクターポインターで頭の中で置き換えることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
restrictには推移的な</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がないことに注意してください</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。std </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:: vector</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">へのリンク</font><i><font style="vertical-align: inherit;">が</font></i><font style="vertical-align: inherit;">宣言</font><font style="vertical-align: inherit;">される</font><i><font style="vertical-align: inherit;">__restrict</font></i><font style="vertical-align: inherit;">指定子のアクション</font><font style="vertical-align: inherit;">は、ベクター自体のメンバーにのみ適用され、</font><i><font style="vertical-align: inherit;">v.data（）</font></i><font style="vertical-align: inherit;">によって参照されるヒープ領域には適用されません。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">（ローカル変数の場合と同様に）ベクトルの最初と最後を指す項自体が何とも交差しないことをコンパイラーに納得させるので、私たちの場合、これ以上は必要ありません。</font><font style="vertical-align: inherit;">ただし、</font><i><font style="vertical-align: inherit;">v.data（）</font></i><font style="vertical-align: inherit;">を介して書き込む</font><font style="vertical-align: inherit;">と、エイリアスによって関数内の他のオブジェクトが変更される可能</font><font style="vertical-align: inherit;">性があるため、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">restrict</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に関する句</font><font style="vertical-align: inherit;">は依然として関連</font><font style="vertical-align: inherit;">しています。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">失望</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、最後の-そして非常に残念な-結論に至ります。実際、ベクトルが理論上それ自体を妨害する可能性がある場合、上記のすべてのソリューションはこの特定のケースにのみ適用できます。解決策は、ループから抜けるか</font><i><font style="vertical-align: inherit;">、</font></i><font style="vertical-align: inherit;">ベクトル</font><font style="vertical-align: inherit;">の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズ（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">終了（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を呼び出した結果を分離</font><font style="vertical-align: inherit;">し、ベクトルのデータへの書き込みが他のデータに影響しないことをコンパイラーに伝え</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ない</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こと</font><i><font style="vertical-align: inherit;">でし</font></i><font style="vertical-align: inherit;">た。このようなコードは、関数が大きくなるにつれて拡張が困難になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エイリアシングの問題は解消されておらず、書き込みコマンドは「どこでも」実行できます。この関数には、影響を受ける可能性のある他のデータはありません...現時点では。新しいコードがその中に現れるとすぐに、すべてが繰り返されます。これは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オフハンドの例です</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">小さなループで</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型の要素の配列に書き込む場合</font><font style="vertical-align: inherit;">、最後までコンパイラーと戦わ</font><font style="vertical-align: inherit;">なければなりません</font><font style="vertical-align: inherit;">（16）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コメント</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はどんなフィードバックでも喜んでいます。</font><font style="vertical-align: inherit;">私はまだコメントシステム（17）を持っていないので、いつものように、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このHackerNewsのスレッドで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">議論し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ol>
<li>     ,      :              ,      (       (STLF),     ).   <i>add </i>         , ,   ,      . </li>
<li>    ;   ,    .    , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   godbolt</a>. </li>
<li> ,     «»?     ,  gcc        <i>-O2</i>  <i>-O3</i>    ,      <i>   </i>. -  gcc          clang,        .  gcc   ,       <i>-funroll-loops</i>. </li>
<li>    <i>inc DWORD PTR [rax]</i>  gcc –   :      <i>add [rax], 1</i>,        2    3  <i>inc</i>.         6%, ,       – ,     , –    (      ,        1    ,       ). </li>
<li>    <i></i>,    <i>i</i>,    ,        <i>i </i>  4-  ,    <i>rax</i>,       .        ,       /,      <i>  </i>. </li>
<li>  ,   <i>-funroll-loops</i>,  gcc   1,08     8- .       <i> </i>      8- ,        ! </li>
<li>    <i>private</i>,      ,   stdlibc++       <i>start </i> <i>finish</i>,   gcc.    <i>_Vector_base::_Vector_impl::_M_start</i>  <i>_Vector_base::_Vector_impl::_M_finish</i>, ..    <i>_Vector_impl</i>,    <i>_M_impl</i> ( )  <i>_Vector_base</i>,  ,   ,     <i>std::vector</i>.   !  ,       . </li>
<li>  ,       <i>std::vector</i>,    libstdc++     <i>Alloc::pointer</i> ( <i>Alloc </i>–    ),       <i>std::allocated</i>      <i>T*</i>, ..     –    <i>uint32_t *</i>. </li>
<li>      .  ,  <i>uint8_t</i>    ,   <i>char</i>, <i>signed char</i>  <i>unsigned char</i>.     <i> </i>,       <i>uint8_t</i>          .          :    <i>typedef </i> <i>uint8_t</i>   <i>unsigned char</i>,        ,       . </li>
<li> « »     ,    ,        .    ,   ,      .  , ,            ,  ,   ,     (    -     ). ,     <i>malloc </i>  <i>new</i>,   <i></i>    ,      ,   ,        :  ,      ,       . ,       <i>malloc </i> <i>new</i>. </li>
<li> ,   <i>std::vector</i>  - <i></i>? ,    <i>std::vector&lt;uint8_t&gt; a </i>    <i> </i>  <i>a.data()</i>    <i>placement new</i>       <i>b</i>.   <i>std::swap(a, b)</i>,       – ,  <i>b </i>      ?       ,     <i>b</i>.       :          -  (,       ),      ,       . </li>
<li>       8 , ..  32 .     ,   <i>std::vector</i>      . </li>
<li>-        4 :     ,        ,   – .       : 8-      L1,  32-        –   L2    ,      . </li>
<li>       ,  –  :        .      ,      ,    «». </li>
<li>       <i>v[i]</i>,           . </li>
<li>    . ,   «» ,          <i>uint8_t</i>.      , ,       ,  <i>uint8_t</i>,          . ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   clang,      gcc</a>,     ,    <i>uint8_t</i>. -     <i>gcc </i>          ,   .     ,     , -     <i>__restrict</i>. </li>
<li> -  ,       ,      (   Disqus),           (        ),    . </li>
</ol><br>
<i>     .  : Travis Downs. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Incrementing vectors</a>.</i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja475618/index.html">OntologyネットワークでスマートPythonコントラクトを作成する方法。パート2：ストレージAPI</a></li>
<li><a href="../ja475622/index.html">Unreal Engine 4でUObjectを拡張する</a></li>
<li><a href="../ja475624/index.html">PHP-Watcher：長寿命のアプリケーションの開発を簡素化するツール</a></li>
<li><a href="../ja475626/index.html">脆弱性を探す人を自動テストで置き換えることができますか：Alexandra Svatikovaへのインタビュー</a></li>
<li><a href="../ja475630/index.html">Knative-サーバーレスサポートを備えたサービスとしてのk8sベースのプラットフォーム</a></li>
<li><a href="../ja475640/index.html">何かを作成する場合は、マネージャーのスケジュールを避けてください。</a></li>
<li><a href="../ja475642/index.html">PostgreSQLのヒープのみのタプルメカニズム</a></li>
<li><a href="../ja475646/index.html">ユーリ・リャブセフ：「弾道ミサイルの最初の迎撃は、ガガーリンの飛行とほぼ等しいイベントです」</a></li>
<li><a href="../ja475652/index.html">Aurora OS（Sailfish Mobile OS RUS）でモバイルアプリケーションを開発した方法</a></li>
<li><a href="../ja475654/index.html">「最初の1か月で、3人の健康な男性がタービンをオンにすることを恐れました」-アレクセイスタッセンコがジェットパックをゼロから構築する方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>