<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📙 🌽 ⚜️ So funktioniert das Rendern von 3D-Spielen: Texturierung und Texturfilterung 👨🏿‍🏭 🙎 🤪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im dritten Artikel zum Rendern in 3D-Spielen werden wir herausfinden, was mit der 3D-Welt passiert, nachdem die Vertex-Verarbeitung verarbeitet und di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>So funktioniert das Rendern von 3D-Spielen: Texturierung und Texturfilterung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499540/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a4/fee/0c7/2a4fee0c701c2b2200faf2b8c6929832.jpg" alt="Bild"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im dritten Artikel zum Rendern in 3D-Spielen werden wir herausfinden, was mit der 3D-Welt passiert, nachdem die Vertex-Verarbeitung verarbeitet und die Szene gerastert wurde. </font><font style="vertical-align: inherit;">Die Texturierung ist eine der wichtigsten Stufen des Renderns, obwohl nur die Farben eines zweidimensionalen Gitters aus mehrfarbigen Blöcken berechnet und geändert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die meisten visuellen Effekte in modernen Spielen beschränken sich auf den bewussten Einsatz von Texturen - ohne sie würden Spiele langweilig und leblos erscheinen. </font><font style="vertical-align: inherit;">Also mal sehen, wie das alles funktioniert! </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1: Vertex-Verarbeitung </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 2: Rasterisierung und Raytracing</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit einem einfachen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können alle dreidimensionalen Bestseller-Spiele verwenden, die im letzten Jahr veröffentlicht wurden, und mit Zuversicht sagen, dass sie alle etwas gemeinsam haben: Sie verwenden </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textur-Maps</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (oder nur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texturen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Dies ist ein so gebräuchlicher Begriff, dass die meisten Menschen beim Nachdenken über Texturen dasselbe Bild präsentieren: ein einfaches flaches Quadrat oder Rechteck, das ein Bild einer Oberfläche (Gras, Stein, Metall, Stoff, Gesicht usw.) enthält. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Verwendung und Kombination komplexer Berechnungen können solche einfachen Bilder in einer 3D-Szene jedoch erstaunlich realistische Bilder erzeugen. Um zu verstehen, wie dies möglich ist, schalten wir sie vollständig aus und sehen, wie die Objekte der 3D-Welt ohne Texturen aussehen.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie wir aus früheren Artikeln gesehen haben, besteht die 3D-Welt aus Eckpunkten - einfachen Formen, die sich bewegen und dann kolorieren. Sie werden dann verwendet, um Grundelemente zu erstellen, die wiederum zu einem zweidimensionalen Pixelraster komprimiert werden. Da wir keine Texturen verwenden, müssen wir diese Pixel einfärben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine der Methoden, die angewendet werden kann, heißt </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flache Schattierung</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die Farbe des ersten Scheitelpunkts des Grundelements wird übernommen, und diese Farbe wird dann auf alle Pixel angewendet, die von der Figur im Raster abgedeckt werden. Es sieht ungefähr so ​​aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/f5c/61b/a0bf5c61be539c776d00fa1b11177ced.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Offensichtlich sieht der Wasserkocher unrealistisch aus, nicht zuletzt wegen unregelmäßiger Oberflächenfarben. Farben springen von einer Ebene zur anderen, es gibt keine glatten Übergänge. Eine Lösung für das Problem könnte die Verwendung der </font></font><em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gouraud-Schattierung sein</font></font></a></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Prozess werden die Farben der Eckpunkte genommen, wonach die Farbänderung entlang der Oberfläche des Dreiecks berechnet wird. Hierzu wird eine </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lineare Interpolation verwendet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es klingt kompliziert, aber in Wirklichkeit bedeutet dies, dass wenn beispielsweise eine Seite des Grundelements eine Farbe von 0,2 Rot und die andere eine Farbe von 0,8 Rot hat, die Mitte der Figur eine Farbe in der Mitte zwischen 0,2 und 0,8 (d. H. 0,5) hat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Prozess ist einfach genug, und dies ist sein Hauptvorteil, weil Einfachheit Geschwindigkeit bedeutet. Viele ältere 3D-Spiele verwendeten diese Technik, da die Fähigkeiten der Computerausrüstung eingeschränkt waren.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/128/447/3c8/1284473c8e1e2ce7d32dbf2202065afe.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barrett und Cloud in all der Größe der Gouraud-Schattierung (Final Fantasy VII, 1997)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Aber selbst eine solche Lösung hat Probleme - wenn das Licht genau in die Mitte des Dreiecks fällt, können seine Ecken (und Eckpunkte) diese Eigenschaft möglicherweise nicht vermitteln. </font><font style="vertical-align: inherit;">Dies bedeutet, dass die durch Licht erzeugte Blendung vollständig verloren gehen kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl Gourauds flache Schattierung und Schattierung ihren rechtmäßigen Platz in den Rendering-Werkzeugen eingenommen haben, sind die oben gezeigten Beispiele klare Kandidaten für eine Texturverbesserung. </font><font style="vertical-align: inherit;">Und um gut zu verstehen, was passiert, wenn die Textur der Oberfläche überlagert wird, werden wir in die Vergangenheit reisen ... bereits 1996.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spiel- und GPU-Geschichte in Kürze</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor ungefähr 23 Jahren veröffentlichte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">id Software</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quake und es wurde ein wichtiger Meilenstein. </font><font style="vertical-align: inherit;">Obwohl dies nicht das erste Spiel war, das 3D-Polygone und -Texturen zum Rendern von Umgebungen verwendete, war es definitiv eines der ersten, das sie effektiv nutzte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber sie hat noch etwas anderes gemacht - sie hat gezeigt, was mit OpenGL gemacht werden kann (diese Grafik-API befand sich damals im ersten Versionszustand) und auch der ersten Generation von Grafikkarten wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendition Verite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3Dfx Voodoo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wirklich geholfen </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a86/9a9/667/a869a966718cfc8ddf4b6d7618b2fdbf.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lichtspitzen und einfache Texturen. </font><font style="vertical-align: inherit;">Sauber 1996, sauberes Beben. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für moderne Verhältnisse war Voodoo extrem einfach: keine Unterstützung für 2D-Grafiken, keine Scheitelpunktverarbeitung, nur die einfachste Pixelverarbeitung. </font><font style="vertical-align: inherit;">Sie war jedoch wunderschön:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66c/509/911/66c5099113c9b08098b73ce31436ecb8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bild: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VGA Museum</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sie hatte einen ganzen Chip (TMU), um ein Pixel aus der Textur zu erhalten, und einen weiteren Chip (FBI), um es später mit einem Rasterpixel zu mischen. Die Karte könnte einige zusätzliche Prozesse ausführen, zum Beispiel die Implementierung von Nebel- oder Transparenzeffekten, aber dies beendete im Wesentlichen ihre Fähigkeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir uns die Architektur ansehen, die der Struktur und dem Betrieb der Grafikkarte zugrunde liegt, werden wir sehen, wie diese Prozesse funktionieren.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/c83/ee4/064c83ee4f63da2be0d5a968c33df0d5.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3Dfx-Spezifikation. Quelle: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falconfly Central</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Der FBI-Chip erhielt zwei Farbwerte und mischte sie; Einer von ihnen könnte ein Wert aus einer Textur sein. Der Mischvorgang ist mathematisch recht einfach, variiert jedoch geringfügig, je nachdem, was gemischt wird und welche API zum Ausführen der Anweisungen verwendet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich ansehen, was </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direct3D uns</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Bezug auf Funktionen und Mischvorgänge </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">bietet</font></a><font style="vertical-align: inherit;"> , werden Sie feststellen, dass jedes Pixel zuerst mit einer Zahl von 0,0 bis 1,0 multipliziert wird. Dies bestimmt, wie stark die Farbe des Pixels das Endergebnis beeinflusst. Dann werden zwei geänderte Pixelfarben addiert, subtrahiert oder multipliziert; In einigen Funktionen wird eine logische Operation ausgeführt, bei der beispielsweise immer das hellste Pixel ausgewählt wird.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/c8b/c8a/aa1c8bc8a2e35a1867c5f6028d958fa8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bild: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tech-Blog der Initiative nehmen</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Das obige Bild zeigt, wie dies in der Praxis funktioniert. Beachten Sie, dass der Pixel- </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alpha-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wert als Koeffizient für das linke </font><font style="vertical-align: inherit;">Pixel verwendet wird. Diese Zahl gibt den Grad der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transparenz des</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixels an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In anderen Phasen wird der Nebelwert angewendet (er wird aus der vom Programmierer erstellten Tabelle entnommen und anschließend werden dieselben Mischungsberechnungen durchgeführt). Durchführung von Überprüfungen und Änderungen der Sichtbarkeit und Transparenz; Am Ende wird die Pixelfarbe in den Speicher der Grafikkarte geschrieben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum brauchen Sie diesen Ausflug in die Geschichte? </font><font style="vertical-align: inherit;">Nun, trotz der relativen Einfachheit des Designs (insbesondere im Vergleich zu modernen Monstern) beschreibt dieser Prozess die Grundprinzipien der Texturierung: Wir nehmen die Werte der Farben und mischen sie so, dass die Modelle und Umgebungen in einer bestimmten Situation so aussehen, wie sie sollten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Moderne Spiele machen dasselbe, der einzige Unterschied ist die Anzahl der verwendeten Texturen und die Komplexität der Mischungsberechnungen. </font><font style="vertical-align: inherit;">Zusammen simulieren sie die visuellen Effekte von Filmen oder die Interaktion von Licht mit verschiedenen Materialien und Oberflächen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texturierungsgrundlagen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für uns ist eine Textur ein flaches 2D-Bild, das den Polygonen überlagert ist, aus denen die 3D-Struktur im Rahmen besteht. Für einen Computer ist dies jedoch nur ein kleiner Speicherblock in Form eines 2D-Arrays. Jedes Element des Arrays bezeichnet den Farbwert eines der Pixel im Texturbild (üblicherweise als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Texturpixel bezeichnet). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder Scheitelpunkt des Polygons hat einen Satz von zwei Koordinaten (normalerweise als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v bezeichnet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), die dem Computer mitteilen, welches Pixel der Textur ihm zugeordnet ist. Der Scheitelpunkt selbst hat einen Satz von drei Koordinaten ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x, y, z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), und das Verknüpfen von Texeln mit den Scheitelpunkten wird als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texturabbildung bezeichnet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu sehen, wie dies geschieht, wenden wir uns dem Tool zu, das wir bereits mehrmals in dieser Artikelserie verwendet haben - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Real Time Rendering WebGL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Im Moment verwerfen wir auch die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinate der </font><font style="vertical-align: inherit;">Eckpunkte und betrachten alles auf einer flachen Ebene.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/d20/fbb/8e1d20fbb308d78a19a2e54d5da96900.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Von links nach rechts: die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinaten der </font><font style="vertical-align: inherit;">Textur, die direkt mit den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x, y-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinaten </font><font style="vertical-align: inherit;">der </font><font style="vertical-align: inherit;">Eckscheitelpunkte verknüpft sind </font><font style="vertical-align: inherit;">. Im zweiten Bild werden die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinaten an den oberen Eckpunkten erhöht </font><font style="vertical-align: inherit;">, aber da die Textur immer noch an ihnen befestigt ist, wird sie vertikal gestreckt. Die Textur wurde bereits im rechten Bild geändert: Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werte </font><font style="vertical-align: inherit;">haben zugenommen, aber infolgedessen wurde die Textur komprimiert und dann wiederholt.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dies geschah, weil trotz der Tatsache, dass die Textur aufgrund des erhöhten Wertes von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tatsächlich höher geworden ist </font><font style="vertical-align: inherit;">, sie immer noch in das Grundelement passen sollte - tatsächlich wiederholte sich die Textur teilweise. Dies ist eine Möglichkeit, den in 3D-Spielen häufig vorkommenden Effekt zu implementieren: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederholen von Texturen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Beispiele für diesen Effekt sind Szenen mit steinigen oder grasbewachsenen Landschaften sowie mit Backsteinmauern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ändern wir nun die Szene, sodass mehr Grundelemente vorhanden sind, und geben die Tiefe der Szene erneut zurück. Die klassische Landschaftsansicht wird unten gezeigt, aber jetzt wird die Box-Textur kopiert und für alle Grundelemente wiederholt.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/9e1/0cb/a9e9e10cb533b78330f90fd7eaea3891.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Box-Textur im ursprünglichen GIF-Format hat eine Größe von 66 KB und eine Auflösung von 256 x 256 Pixel. Die anfängliche Auflösung des Teils des Rahmens, der von den Box-Texturen abgedeckt wird, beträgt 1900 x 680, dh aus Sicht des Pixel-Bereichs sollte ein solcher Bereich nur 20 Box-Texturen anzeigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist jedoch offensichtlich, dass wir viel mehr als zwanzig Kästchen sehen. Dies bedeutet, dass die Textur des Kästchens in der Ferne </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">viel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kleiner als 256 x 256 Pixel sein sollte. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Tat</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> haben sie einen Prozess namens </font><em><font style="vertical-align: inherit;">"Texturminimierung"</font></em><font style="vertical-align: inherit;"> durchlaufen </font><font style="vertical-align: inherit;">(ja, ein solches Wort existiert auf Englisch!). Wiederholen wir dies jetzt, aber diesmal bringen Sie die Kamera näher an eine der Schubladen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/404/c02/f70/404c02f70291916245ec931642c79860.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergessen Sie nicht, dass die Textur nur 256 x 256 Pixel groß ist, aber hier sehen wir eine Textur, die größer als die Hälfte des Bildes ist und eine Breite von 1900 Pixel hat. </font><font style="vertical-align: inherit;">Diese Textur wurde einer </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Texturvergrößerung"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unterzogen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese beiden Texturprozesse treten in 3D-Spielen ständig auf, denn wenn sich die Kamera in der Szene bewegt, nähern sich die Modelle oder bewegen sich weg, und alle auf die Grundelemente angewendeten Texturen müssen zusammen mit den Polygonen skaliert werden. </font><font style="vertical-align: inherit;">Aus mathematischer Sicht ist dies ein kleines Problem. Selbst die einfachsten integrierten Grafikchips können einen solchen Job problemlos ausführen. </font><font style="vertical-align: inherit;">Das Verkleinern und Vergrößern von Texturen ist jedoch eine neue Herausforderung, die auf irgendeine Weise angegangen werden muss.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mini-Kopien von Texturen erscheinen in der Szene</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste Problem, das für Texturen gelöst werden muss, ist die Entfernung. Wenn wir zum ersten Bild mit einer Landschaft aus Kästchen zurückkehren, haben die Kästchen in der Nähe des Horizonts tatsächlich nur eine Größe von wenigen Pixeln. Daher ist der Versuch, ein Bild mit 256 x 256 Pixel auf so kleinem Raum zu komprimieren, aus zwei Gründen sinnlos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens nimmt die kleinere Textur weniger Speicherplatz auf der Grafikkarte ein, was praktisch ist, da Sie versuchen können, sie in einen kleineren Cache einzupassen. Dies bedeutet, dass es weniger wahrscheinlich ist, dass es aus dem Cache gelöscht wird, dh, die wiederholte Verwendung dieser Textur führt zu einer höheren Leistung, da sich die Daten im engen Speicher befinden. Aus dem zweiten Grund werden wir bald zurückkehren, da dies mit demselben Problem verbunden ist, das bei Texturen in der Nähe der Kamera auftritt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Standardlösung für das Problem der Notwendigkeit, große Texturen in kleine </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundelemente</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu komprimieren, ist die Verwendung von </font><em><font style="vertical-align: inherit;">Mip-Texturen (Mipmaps)</font></em><font style="vertical-align: inherit;"> . Dies sind verkleinerte Versionen der ursprünglichen Textur. Sie können von der Engine selbst (mithilfe der entsprechenden API-Befehle) generiert oder von Spieledesignern vorab erstellt werden. Jede nachfolgende Ebene der Mip-Textur hat eine halbe Größe im Vergleich zur vorherigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, für die Box-Textur betragen die Abmessungen: 256 x 256 → 128 x 128 → 64 x 64 → 32 x 32 → 16 x 16 → 8 x 8 → 4 x 4 → 2 x 2 → 1 x 1.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/074/973/1ea/0749731eae53d112d545c0297ac14584.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Mip-Texturen sind zusammen gepackt, sodass die Textur denselben Dateinamen hat, jedoch größer wird. Die Textur ist so gepackt, dass die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinaten </font><font style="vertical-align: inherit;">nicht nur bestimmen, welches Texel dem Pixel im Rahmen überlagert ist, sondern auch mit welcher Mip-Textur. Dann schreiben die Programmierer einen Renderer, der auf dem Wert der Pixeltiefe des Rahmens basiert und bestimmt, welche Mip-Textur verwendet werden soll. Wenn der Wert beispielsweise sehr hoch ist, ist das Pixel weit entfernt, was bedeutet, dass Sie eine kleine Mip-Textur verwenden können.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufmerksame Leser konnten das Fehlen von Mip-Texturen bemerken - sie müssen dafür bezahlen, indem sie die Größe der Texturen erhöhen. Die ursprüngliche Textur der Box war 256 x 256 Pixel, aber wie Sie im obigen Bild sehen können, hat die Textur mit Mip-Texturen jetzt eine Größe von 384 x 256. Ja, sie hat viel leeren Raum, aber egal wie wir kleinere Texturen im Allgemeinen verpacken Die Größe der Textur auf einer Seite erhöht sich um mindestens 50%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies gilt jedoch nur für zuvor erstellte Mip-Texturen. Wenn die Spiel-Engine so programmiert ist, dass sie korrekt generiert wird, beträgt die Erhöhung nicht mehr als 33% der ursprünglichen Texturgröße. Aufgrund einer geringfügigen Erhöhung des Speicherplatzes zum Speichern von Mip-Texturen erhalten wir daher einen Gewinn an Leistung und visueller Qualität.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unten finden Sie einen Vergleich von Bildern mit deaktivierten / aktivierten Mip-Texturen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e96/b67/e71/e96b67e71c3f41aed3ce09ed728f98ea.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der linken Seite des Bildes wurden die Texturen der Boxen "wie sie sind" verwendet, was zum Auftreten von Granularität und dem sogenannten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moiré</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der Ferne führte. </font><font style="vertical-align: inherit;">Rechts ermöglichte die Verwendung von Mip-Texturen glattere Übergänge, und am Horizont wird die Textur der Box in eine einheitliche Farbe verwischt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wer möchte jedoch, dass verschwommene Texturen die Hintergründe seines Lieblingsspiels verderben?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bilinear, trilinear, anisotrop - das alles ist für mich ein chinesischer Buchstabe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Auswählen eines Pixels aus einer Textur, um es einem Pixel in einem Frame zu überlagern, wird als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abtasttexturen bezeichnet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In einer idealen Welt würde es eine Textur geben, die ideal zu dem Grundelement passt, für das es entworfen wurde, unabhängig von Größe, Position, Richtung usw. </font><font style="vertical-align: inherit;">Mit anderen Worten, das Abtasten der Textur wäre eine einfache Eins-zu-Eins-Texel-Pixelabbildung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da dies jedoch nicht der Fall ist, müssen beim Abtasten von Texturen mehrere Faktoren berücksichtigt werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wurde die Textur verkleinert oder vergrößert?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist die Textur eine Quell- oder Mip-Textur?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In welchem ​​Winkel wird die Textur angezeigt?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns sie der Reihe nach analysieren. Der erste Faktor ist ziemlich offensichtlich: Wenn die Textur erhöht wurde, gibt es im Grundelement mehr Texel, die das Pixel im Grundelement bedecken, als erforderlich; Beim Verringern ist das Gegenteil der Fall - jedes Texel sollte jetzt mehrere Pixel abdecken. Und das ist ein Problem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite Faktor verursacht keine Probleme, da Mip-Texturen verwendet werden, um das Problem der Abtastung der Texturen weit entfernter Grundelemente zu umgehen. Die einzige Aufgabe besteht darin, die Texturen in einem Winkel anzuzeigen. Und ja, das ist auch ein Problem. Warum? Weil alle Texturen Bilder sind, die für die Anzeige „streng vor“ generiert wurden. In mathematischer Sprache entspricht die normale Oberflächentextur dem Nennwert der Oberfläche, auf dem die Textur aktuell angezeigt wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn daher zu wenige oder zu viele Texel vorhanden sind oder sich in einem Winkel befinden, ist ein zusätzlicher Prozess erforderlich, der als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Texturfilterung" bezeichnet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn dieser Prozess nicht verwendet wird, erhalten wir Folgendes:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/792/a12/552/792a125529b7f3baa79c072fdf42acba.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier haben wir die Textur der Box durch eine Textur mit dem Buchstaben R ersetzt, um deutlicher zu zeigen, in welches Chaos das Bild gerät, ohne Texturen zu filtern! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grafik-APIs wie Direct3D, OpenGL und Vulkan bieten dieselben Filtertypen, verwenden jedoch unterschiedliche Namen. </font><font style="vertical-align: inherit;">Tatsächlich laufen sie alle auf Folgendes hinaus:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Near Point Sampling</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lineare Texturfilterung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anisotrope Texturfilterung</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich ist das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abtasten der nächsten Punktabtastung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kein Filter, da damit nur das nächste Texel des erforderlichen Texturpixels abgetastet wird (z. B. aus dem Speicher kopiert) und dann mit der ursprünglichen Farbe des Pixels gemischt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier hilft uns die lineare Filterung. Die erforderlichen </font><font style="vertical-align: inherit;">Texelkoordinaten </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden an die Abtastausrüstung übertragen, aber anstatt das diesen Koordinaten am nächsten liegende Texel zu nehmen, nimmt der </font><font style="vertical-align: inherit;">Abtastgerät </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vier</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texel. Hierbei handelt es sich um Texel, die sich oberhalb, unterhalb, links und rechts des Texels befinden, das durch Abtasten der nächstgelegenen Punkte ausgewählt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese vier Texel werden dann unter Verwendung einer Formel mit Gewichten gemischt. In Vulkan sieht die Formel beispielsweise folgendermaßen aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/9bb/63c/57b9bb63cc81fa5721b007717f6b200a.png"></div><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bezeichnet die Texelfarbe, wobei </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das Ergebnis der Filtration ist und 1-4 die Farbe von vier abgetasteten Texeln ist. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alpha-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beta-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werte </font><font style="vertical-align: inherit;">werden abhängig davon genommen, wie weit der Punkt mit den Koordinaten </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von der Mitte der Textur entfernt ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Glück für diejenigen, die mit 3D-Grafiken zu tun haben, geschieht dies automatisch im Grafikchip. Genau das hat der TMU-Chip der 3dfx Voodoo-Karte getan: Er hat vier Texel abgetastet und sie dann zusammengemischt. In Direct3D hat dieser Prozess einen seltsamen Namen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für die bilineare Filterung.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber seit den Tagen von Quake und dem TMU-Chip haben Grafikkarten bereits gelernt, wie man eine bilineare Filterung in nur einem Taktzyklus durchführt (natürlich, wenn sich die Textur bereits im nächsten Speicher befindet). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die lineare Filterung kann zusammen mit Mip-Texturen verwendet werden. Wenn Sie die Filterung komplizieren möchten, können Sie vier Texel aus der Textur und vier weitere aus der nächsten Ebene der Mip-Textur entnehmen und alle mischen. Und wie heißt es in Direct3D? </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trilineare</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Filterung. Woher kamen die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„drei“</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in diesem Prozess </font><font style="vertical-align: inherit;">? Wir wissen es also nicht ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die letzte erwähnenswerte Filtermethode ist </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anisotrop</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tatsächlich ist es eine Verbesserung des Prozesses, der durch bilineare oder trilineare Filterung durchgeführt wird. Zunächst wird berechnet</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Grad der Anisotropie</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der primitiven Oberfläche (und dies ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein überraschend komplexer Prozess</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - dieser Wert erhöht die Änderung des Seitenverhältnisses des primitiven aufgrund seiner Orientierung:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/247/dfe/e60/247dfee60846988a5e94a1020d9ecef6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die obige Abbildung zeigt dasselbe quadratische Grundelement mit gleichen Seitenlängen. aber allmählich dreht es sich in ein Rechteck, und seine Breite ändert sich mehr als seine Höhe. Daher hat das Grundelement rechts einen höheren Anisotropiegrad als links (und im Fall eines Quadrats ist der Grad Null). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In vielen modernen 3D-Spielen können Sie die anisotrope Filterung aktivieren und dann ihre Stufe ändern (von 1x auf 16x). Aber was ändert sich wirklich? Dieser Parameter steuert die maximale Anzahl zusätzlicher Texel-Samples, die in jedem anfänglichen linearen Sample entnommen werden. Angenommen, eine anisotrope bilineare Filterung von 8x ist im Spiel aktiviert. Dies bedeutet, dass anstelle von vier Texelwerten 32 Werte erhalten werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Unterschied bei der Verwendung der anisotropen Filterung ist deutlich zu erkennen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/302/372/df7302372c6dc0d34730ba572f695063.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gehen Sie einfach zum obigen Bild und vergleichen Sie die Abtastung der nächstgelegenen Punkte mit einer maximal 16-fachen anisotropen trilinearen Filterung. Erstaunlich glatt! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für diese glatte Schönheit von Texturen müssen Sie jedoch mit Leistung bezahlen: Bei maximalen Einstellungen erhält die anisotrope trilineare Filterung 128 Abtastwerte aus der Textur für jedes Pixel des Renderings. Selbst mit den besten modernen GPUs kann dies nicht in einem Taktzyklus erreicht werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie zum Beispiel AMD </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Radeon RX 5700 XT nehmen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann kann jeder der Texturierungsblöcke im Prozessor bis zu 32 Texeladressen in einem Taktzyklus verwenden und dann im nächsten Taktzyklus 32 Texelwerte aus dem Speicher laden (von denen jeder eine Größe von 32 Bit hat) und dann vier davon in einem weiteren mischen Takt. Das heißt, um 128 Texel-Samples zu einem zu mischen, sind mindestens 16 Taktzyklen erforderlich.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/abf/cf4/fa4abfcf4411b6cc2622c8e77986ab3c.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU AMD RDNA Radeon RX 5700 mit 7-Nanometer-Prozesstechnologie</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn die Taktrate des 5700 XT 1605 MHz beträgt, dauern 16 Zyklen nur 10 </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nanosekunden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das Ausführen dieser Zyklen für jedes Pixel in einem 4K-Frame mit nur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Textureinheit dauert nur 70 Millisekunden. Großartig, es sieht so aus, als wäre Leistung keine große Sache! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bereits 1996 kamen 3Dfx Voodoo und ähnliche Karten schnell mit Texturen zurecht. Sie konnten höchstens 1 Texel mit bilinearer Filterung pro Zyklus ausgeben, und mit einer TMU-Chipfrequenz von 50 MHz konnten 50 Millionen Texel pro Sekunde verarbeitet werden. Ein Spiel mit 800 x 600 und 30 fps benötigt nur 14 Millionen Texel mit bilinearer Filterung pro Sekunde.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies gilt jedoch nur unter der Annahme, dass sich alle Texturen im nächsten Speicher befinden und nur ein Texel jedem Pixel entspricht. </font><font style="vertical-align: inherit;">Vor zwanzig Jahren war die Idee, mehrere Texturen auf ein Primitiv zu legen, völlig fremd, aber heute ist es ein Standard. </font><font style="vertical-align: inherit;">Mal sehen, warum sich das alles ändert.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beleuchtung hinzufügen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu verstehen, warum Texturierung so wichtig geworden ist, schauen Sie sich diese Szene aus Quake an:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/dcf/ee4/bdadcfee4354ea561b9239e1ca5a143b.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein dunkles Bild, weil Dunkelheit die Atmosphäre des Spiels war, aber wir sehen, dass die Dunkelheit nicht überall gleich ist - einige Fragmente von Wänden und Böden sind heller als andere, was in diesen Bereichen ein Gefühl von Helligkeit erzeugt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Grundelemente, aus denen die Wände und der Boden bestehen, werden mit denselben Texturen überlagert. Es gibt jedoch eine andere Textur, die als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Lichtkarte“ bezeichnet wird</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und mit den Werten der Texel gemischt wird, bevor sie auf die Rahmenpixel angewendet werden. In Bebenzeiten wurden Beleuchtungskarten im Voraus berechnet und von der Spiel-Engine erstellt. Sie wurden verwendet, um statische und dynamische Beleuchtungsstärken zu erzeugen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Vorteil ihrer Verwendung besteht darin, dass komplexe Beleuchtungsberechnungen eher mit Texturen als mit Scheitelpunkten durchgeführt wurden, was das Erscheinungsbild der Szene auf Kosten niedriger Geschwindigkeitskosten erheblich verbesserte. Offensichtlich ist das Bild nicht perfekt: Auf dem Boden fällt auf, dass die Grenze zwischen den beleuchteten Bereichen und den Schatten sehr scharf ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In vielerlei Hinsicht ist eine Lightmap nur eine andere Textur (vergessen Sie nicht, dass es sich bei allen um reguläre 2D-Datensätze handelt). Daher ist diese Szene eines der ersten Beispiele für die Verwendung von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multitexturing</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wie der Name schon sagt, ist dies ein Prozess, bei dem zwei oder mehr Texturen einem Grundelement überlagert werden. Die Verwendung von Beleuchtungskarten in Quake ist zu einer Möglichkeit geworden, die Einschränkungen der Gouraud-Schattierung zu überwinden. Mit der Erweiterung des Funktionsumfangs von Grafikkarten wurden jedoch auch die Möglichkeiten zur Anwendung von Multitexturing erweitert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3Dfx Voodoo war, wie viele andere Karten dieser Zeit, in der Anzahl der Operationen begrenzt, die es in einem einzigen </font><font style="vertical-align: inherit;">Rendering- </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durchgang</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausführen konnte </font><font style="vertical-align: inherit;">. Tatsächlich ist ein Durchlauf ein vollständiger Renderzyklus: von der Verarbeitung von Scheitelpunkten bis zur Rasterung des Frames, dem anschließenden Ändern der Pixel und dem Schreiben in den fertigen Frame-Puffer. Vor zwanzig Jahren verwendeten Spiele fast immer One-Pass-Rendering.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a55/0b6/bc9/a550b6bc98c07f1c90276e1aa3721819.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nvidia GeForce 2 Ultra, gegen Ende 2000. Bild: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikimedia</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dies geschah, weil die zweite Vertex-Verarbeitung nur zum Anwenden zusätzlicher Texturen in Bezug auf die Leistung zu kostspielig war. Nach Voodoo mussten wir einige Jahre warten, bis die Grafikkarten ATI Radeon und Nvidia GeForce 2 erschienen, die in einem Durchgang multitexturiert werden konnten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese GPUs hatten mehrere Textureinheiten im Pixelverarbeitungsbereich ( </font><font style="vertical-align: inherit;">dh </font><font style="vertical-align: inherit;">in der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipeline</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), so dass das Erhalten eines Texels mit bilinearer Filterung aus zwei getrennten Texturen die einfachste Aufgabe wurde. Dies erhöhte die Beliebtheit von Beleuchtungskarten weiter und ermöglichte es den Spielen, sie vollständig dynamisch zu gestalten und die Beleuchtungswerte abhängig von den Bedingungen der Spielumgebung zu ändern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit ein paar Texturen könnte jedoch noch viel mehr getan werden. Lassen Sie uns also ihre Fähigkeiten untersuchen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ändern der Höhe ist normal</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dieser Artikelserie über 3D-Rendering haben wir nicht darüber gesprochen, wie sich die Rolle der GPU auf den gesamten Prozess auswirkt (wir werden darüber sprechen, aber nicht jetzt!). Wenn Sie jedoch zu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1 zurückkehren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und den gesamten komplexen Prozess der Verarbeitung von Scheitelpunkten lesen, denken Sie möglicherweise, dass dies der schwierigste Teil aller Arbeiten ist, die die GPU ausführen muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lange Zeit war es so, und Spielprogrammierer haben alles getan, um diese Last zu reduzieren. Sie mussten alle möglichen Tricks anwenden, um die gleiche Bildqualität wie bei der Verwendung mehrerer Scheitelpunkte sicherzustellen, diese jedoch nicht verarbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die meisten dieser Tricks verwendeten Texturen, die als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Höhenkarten</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normale Karten bezeichnet werden.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese beiden Konzepte sind durch die Tatsache verbunden, dass das letztere aus dem ersteren erstellt werden kann. Betrachten wir jedoch zunächst nur eine Technik namens </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Bump Mapping“</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/db2/5b6/1e3db25b6ecefc0dd3f75c84f767800c.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bilder, die in einem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo-Rendering von Emil Persson erstellt wurden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die geprägte Texturierung ist deaktiviert / aktiviert. Bei der geprägten Texturierung</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
wird ein 2D-Array verwendet, das als „Höhenkarte“ bezeichnet wird und wie eine seltsame Version der ursprünglichen Textur aussieht. </font><font style="vertical-align: inherit;">Das obige Bild zeigt beispielsweise eine realistische Ziegelstruktur, die auf zwei ebenen Flächen liegt. </font><font style="vertical-align: inherit;">Die Textur und ihre Höhenkarte sehen folgendermaßen aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/87f/221/7a187f2215bcf0723bd4d4f820350858.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Farben der Höhenkarte geben die Normalen der Oberfläche der Steine ​​an (wir haben in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1 einer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Artikelserie </font><font style="vertical-align: inherit;">über die Normalen gesprochen </font><font style="vertical-align: inherit;">). Wenn der Rendervorgang das Stadium des Aufbringens der Ziegelstruktur auf die Oberfläche erreicht, wird eine Reihe von Berechnungen durchgeführt, um die Farbe der Ziegelstruktur basierend auf ihren Normalen zu ändern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen sehen die Steine ​​selbst dreidimensionaler aus, obwohl sie weiterhin vollständig flach bleiben. Wenn Sie genau hinschauen, insbesondere an den Rändern der Steine, können Sie die Einschränkungen dieser Technik erkennen: Die Textur sieht leicht verzerrt aus. Dies ist jedoch ein schneller Trick, mit dem Sie mehr Oberflächendetails hinzufügen können. Daher ist die geprägte Texturierung sehr beliebt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine normale Karte ähnelt einer Höhenkarte, nur die Texturfarben sind die Normalen selbst. Mit anderen Worten, Berechnungen zum Konvertieren der Höhenkarte in Normal sind nicht erforderlich. Sie können eine Frage stellen: Wie können Farben einen Vektor im Raum beschreiben? Die Antwort ist einfach: Jedes Texel hat eine Menge von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r-, g-, b-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werten </font><font style="vertical-align: inherit;">(rot, grün, blau) und diese Werte entsprechen direkt den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x-, y- und z-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werten </font><font style="vertical-align: inherit;">des Normalenvektors.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1f/105/c3b/c1f105c3b93c455ba7661489770172c9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das linke Diagramm zeigt die Richtungsänderung der Normalen auf einer unebenen Oberfläche. Um dieselben Normalen mit einer flachen Textur (mittlerer Umriss) zu beschreiben, weisen wir ihnen Farben zu. In diesem Fall haben wir die Werte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r, g, b</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (0,255,0) für den Vektor verwendet, der gerade nach oben gerichtet ist, und dann den Wert von Rot für die Neigung nach links und Blau für die Neigung nach rechts erhöht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass diese Farbe nicht mit dem Originalpixel gemischt wird. Sie teilt dem Prozessor lediglich mit, in welche Richtung die Normalen zeigt, damit die Winkel zwischen Kamera, Lichtquellen und strukturierter Oberfläche korrekt berechnet werden können.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Vorteile von geprägten Texturen und normalen Karten liegen voll auf der Hand, wenn dynamische Beleuchtung in der Szene verwendet wird und wenn der Renderprozess den Effekt der Beleuchtungsänderung Pixel für Pixel berechnet und nicht für jeden Scheitelpunkt. Heutzutage verwenden moderne Spiele eine Reihe von Texturen, um die Qualität dieses Tricks zu verbessern.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ef/d59/660/3efd596604528593b16923297f10f044.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bild: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ryan Benno</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Überraschenderweise ist diese realistisch aussehende Wand nur eine flache Oberfläche. Die Details von Ziegeln und Mauerzement werden nicht aus Millionen von Polygonen hergestellt. Stattdessen reichen nur fünf Texturen und der durchdachte Einsatz von Berechnungen aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Höhenkarte wurde verwendet, um Schattenwurf mit Ziegeln zu erzeugen, und eine normale Karte wurde verwendet, um alle geringfügigen Oberflächenänderungen zu simulieren. Die Rauheitstextur wurde verwendet, um die Art und Weise zu ändern, in der Licht von verschiedenen Elementen der Wand reflektiert wird (zum Beispiel reflektiert glatter Ziegel das Licht gleichmäßiger als rauer Zement).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die letzte Karte, die im AO-Bild benannt ist, erzeugt einen Teil des Prozesses, der als Umgebungsokklusion bezeichnet wird: Wir werden diese Technik in den folgenden Artikeln genauer untersuchen, aber nehmen wir zunächst an, dass sie dazu beiträgt, den Realismus von Schatten zu erhöhen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture Mapping ist ein kritischer Prozess.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Texturierung ist bei der Entwicklung von Spielen unbedingt erforderlich. Nehmen wir zum Beispiel das Spiel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kingdom Come: Deliverance aus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dem Jahr 2019 </font><font style="vertical-align: inherit;">, ein Rollenspiel aus der ersten Person, das im 15. Jahrhundert in Böhmen spielt. Designer wollten die realistischste Welt dieser Zeit schaffen. Und um den Spieler in das Leben vor Hunderten von Jahren einzutauchen, ist es am besten, eine historisch korrekte Landschaft, Gebäude, Kleidung, Frisuren, Alltagsgegenstände und vieles mehr zu implementieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede Textur in diesem Bild aus dem Spiel wurde manuell von Künstlern erstellt und auch dank einer von Programmierern gesteuerten Rendering-Engine. Einige von ihnen sind klein, mit einfachen Details und werden daher leicht gefiltert oder mit anderen Texturen (z. B. Hühnerflügeln) verarbeitet.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2e/7d0/24a/e2e7d024ad0c700d26390940caf339ed.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Andere haben eine hohe Auflösung und viele kleine Details; </font><font style="vertical-align: inherit;">Sie werden anisotrop gefiltert und mit normalen Karten und anderen Texturen gemischt. Schauen Sie sich einfach das Gesicht der Person im Vordergrund an. </font><font style="vertical-align: inherit;">Der Unterschied in den Texturierungsanforderungen jedes Szenenobjekts wird von Programmierern berücksichtigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All dies geschieht heute in vielen Spielen, weil die Spieler immer mehr Details und Realismus erwarten. </font><font style="vertical-align: inherit;">Texturen werden größer und immer mehr von ihnen überlagern die Oberfläche, aber der Prozess des Abtastens von Texeln und des Überlagerns von Pixeln bleibt im Wesentlichen der gleiche wie in den Tagen von Quake. </font><font style="vertical-align: inherit;">Die besten Technologien sterben nie, egal wie alt sie sind!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de499524/index.html">Quarkus: Anwendungs-Upgrades anhand des Beispiels helloworld von JBoss EAP Quickstart</a></li>
<li><a href="../de499528/index.html">Eine "atemberaubende" mathematische Brücke, die über Fermats großen Satz hinausgeht</a></li>
<li><a href="../de499532/index.html">Wörter in Zahlen: kostenlose Blog-Analyse habravebinary mit Yandex.Metrica</a></li>
<li><a href="../de499534/index.html">Entwicklungshandbuch für Python-Backend-Dienste</a></li>
<li><a href="../de499536/index.html">Growbox als Methode, sich selbst zu kennen</a></li>
<li><a href="../de499542/index.html">Top Fakapov Cyan</a></li>
<li><a href="../de499544/index.html">Lernen Sie neuronale Netze in Google Sheets</a></li>
<li><a href="../de499546/index.html">Firmware-Entwicklung für eine analoge Videokamera EVR-Y2022F</a></li>
<li><a href="../de499548/index.html">Maske - Fürsorge für andere oder eine Illusion von Sicherheit?</a></li>
<li><a href="../de499550/index.html">Low-Code-Lösungen für Ökosysteme</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>