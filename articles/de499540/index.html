<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìô üåΩ ‚öúÔ∏è So funktioniert das Rendern von 3D-Spielen: Texturierung und Texturfilterung üë®üèø‚Äçüè≠ üôé ü§™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im dritten Artikel zum Rendern in 3D-Spielen werden wir herausfinden, was mit der 3D-Welt passiert, nachdem die Vertex-Verarbeitung verarbeitet und di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>So funktioniert das Rendern von 3D-Spielen: Texturierung und Texturfilterung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499540/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a4/fee/0c7/2a4fee0c701c2b2200faf2b8c6929832.jpg" alt="Bild"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im dritten Artikel zum Rendern in 3D-Spielen werden wir herausfinden, was mit der 3D-Welt passiert, nachdem die Vertex-Verarbeitung verarbeitet und die Szene gerastert wurde. </font><font style="vertical-align: inherit;">Die Texturierung ist eine der wichtigsten Stufen des Renderns, obwohl nur die Farben eines zweidimensionalen Gitters aus mehrfarbigen Bl√∂cken berechnet und ge√§ndert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die meisten visuellen Effekte in modernen Spielen beschr√§nken sich auf den bewussten Einsatz von Texturen - ohne sie w√ºrden Spiele langweilig und leblos erscheinen. </font><font style="vertical-align: inherit;">Also mal sehen, wie das alles funktioniert! </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1: Vertex-Verarbeitung </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 2: Rasterisierung und Raytracing</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit einem einfachen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen alle dreidimensionalen Bestseller-Spiele verwenden, die im letzten Jahr ver√∂ffentlicht wurden, und mit Zuversicht sagen, dass sie alle etwas gemeinsam haben: Sie verwenden </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textur-Maps</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (oder nur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texturen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Dies ist ein so gebr√§uchlicher Begriff, dass die meisten Menschen beim Nachdenken √ºber Texturen dasselbe Bild pr√§sentieren: ein einfaches flaches Quadrat oder Rechteck, das ein Bild einer Oberfl√§che (Gras, Stein, Metall, Stoff, Gesicht usw.) enth√§lt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Verwendung und Kombination komplexer Berechnungen k√∂nnen solche einfachen Bilder in einer 3D-Szene jedoch erstaunlich realistische Bilder erzeugen. Um zu verstehen, wie dies m√∂glich ist, schalten wir sie vollst√§ndig aus und sehen, wie die Objekte der 3D-Welt ohne Texturen aussehen.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie wir aus fr√ºheren Artikeln gesehen haben, besteht die 3D-Welt aus Eckpunkten - einfachen Formen, die sich bewegen und dann kolorieren. Sie werden dann verwendet, um Grundelemente zu erstellen, die wiederum zu einem zweidimensionalen Pixelraster komprimiert werden. Da wir keine Texturen verwenden, m√ºssen wir diese Pixel einf√§rben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine der Methoden, die angewendet werden kann, hei√üt </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flache Schattierung</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die Farbe des ersten Scheitelpunkts des Grundelements wird √ºbernommen, und diese Farbe wird dann auf alle Pixel angewendet, die von der Figur im Raster abgedeckt werden. Es sieht ungef√§hr so ‚Äã‚Äãaus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/f5c/61b/a0bf5c61be539c776d00fa1b11177ced.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Offensichtlich sieht der Wasserkocher unrealistisch aus, nicht zuletzt wegen unregelm√§√üiger Oberfl√§chenfarben. Farben springen von einer Ebene zur anderen, es gibt keine glatten √úberg√§nge. Eine L√∂sung f√ºr das Problem k√∂nnte die Verwendung der </font></font><em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gouraud-Schattierung sein</font></font></a></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Prozess werden die Farben der Eckpunkte genommen, wonach die Farb√§nderung entlang der Oberfl√§che des Dreiecks berechnet wird. Hierzu wird eine </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lineare Interpolation verwendet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es klingt kompliziert, aber in Wirklichkeit bedeutet dies, dass wenn beispielsweise eine Seite des Grundelements eine Farbe von 0,2 Rot und die andere eine Farbe von 0,8 Rot hat, die Mitte der Figur eine Farbe in der Mitte zwischen 0,2 und 0,8 (d. H. 0,5) hat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Prozess ist einfach genug, und dies ist sein Hauptvorteil, weil Einfachheit Geschwindigkeit bedeutet. Viele √§ltere 3D-Spiele verwendeten diese Technik, da die F√§higkeiten der Computerausr√ºstung eingeschr√§nkt waren.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/128/447/3c8/1284473c8e1e2ce7d32dbf2202065afe.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barrett und Cloud in all der Gr√∂√üe der Gouraud-Schattierung (Final Fantasy VII, 1997)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Aber selbst eine solche L√∂sung hat Probleme - wenn das Licht genau in die Mitte des Dreiecks f√§llt, k√∂nnen seine Ecken (und Eckpunkte) diese Eigenschaft m√∂glicherweise nicht vermitteln. </font><font style="vertical-align: inherit;">Dies bedeutet, dass die durch Licht erzeugte Blendung vollst√§ndig verloren gehen kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl Gourauds flache Schattierung und Schattierung ihren rechtm√§√üigen Platz in den Rendering-Werkzeugen eingenommen haben, sind die oben gezeigten Beispiele klare Kandidaten f√ºr eine Texturverbesserung. </font><font style="vertical-align: inherit;">Und um gut zu verstehen, was passiert, wenn die Textur der Oberfl√§che √ºberlagert wird, werden wir in die Vergangenheit reisen ... bereits 1996.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spiel- und GPU-Geschichte in K√ºrze</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor ungef√§hr 23 Jahren ver√∂ffentlichte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">id Software</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quake und es wurde ein wichtiger Meilenstein. </font><font style="vertical-align: inherit;">Obwohl dies nicht das erste Spiel war, das 3D-Polygone und -Texturen zum Rendern von Umgebungen verwendete, war es definitiv eines der ersten, das sie effektiv nutzte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber sie hat noch etwas anderes gemacht - sie hat gezeigt, was mit OpenGL gemacht werden kann (diese Grafik-API befand sich damals im ersten Versionszustand) und auch der ersten Generation von Grafikkarten wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendition Verite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3Dfx Voodoo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wirklich geholfen </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a86/9a9/667/a869a966718cfc8ddf4b6d7618b2fdbf.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lichtspitzen und einfache Texturen. </font><font style="vertical-align: inherit;">Sauber 1996, sauberes Beben. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr moderne Verh√§ltnisse war Voodoo extrem einfach: keine Unterst√ºtzung f√ºr 2D-Grafiken, keine Scheitelpunktverarbeitung, nur die einfachste Pixelverarbeitung. </font><font style="vertical-align: inherit;">Sie war jedoch wundersch√∂n:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66c/509/911/66c5099113c9b08098b73ce31436ecb8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bild: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VGA Museum</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sie hatte einen ganzen Chip (TMU), um ein Pixel aus der Textur zu erhalten, und einen weiteren Chip (FBI), um es sp√§ter mit einem Rasterpixel zu mischen. Die Karte k√∂nnte einige zus√§tzliche Prozesse ausf√ºhren, zum Beispiel die Implementierung von Nebel- oder Transparenzeffekten, aber dies beendete im Wesentlichen ihre F√§higkeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir uns die Architektur ansehen, die der Struktur und dem Betrieb der Grafikkarte zugrunde liegt, werden wir sehen, wie diese Prozesse funktionieren.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/c83/ee4/064c83ee4f63da2be0d5a968c33df0d5.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3Dfx-Spezifikation. Quelle: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falconfly Central</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Der FBI-Chip erhielt zwei Farbwerte und mischte sie; Einer von ihnen k√∂nnte ein Wert aus einer Textur sein. Der Mischvorgang ist mathematisch recht einfach, variiert jedoch geringf√ºgig, je nachdem, was gemischt wird und welche API zum Ausf√ºhren der Anweisungen verwendet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich ansehen, was </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direct3D uns</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Bezug auf Funktionen und Mischvorg√§nge </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">bietet</font></a><font style="vertical-align: inherit;"> , werden Sie feststellen, dass jedes Pixel zuerst mit einer Zahl von 0,0 bis 1,0 multipliziert wird. Dies bestimmt, wie stark die Farbe des Pixels das Endergebnis beeinflusst. Dann werden zwei ge√§nderte Pixelfarben addiert, subtrahiert oder multipliziert; In einigen Funktionen wird eine logische Operation ausgef√ºhrt, bei der beispielsweise immer das hellste Pixel ausgew√§hlt wird.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/c8b/c8a/aa1c8bc8a2e35a1867c5f6028d958fa8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bild: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tech-Blog der Initiative nehmen</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Das obige Bild zeigt, wie dies in der Praxis funktioniert. Beachten Sie, dass der Pixel- </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alpha-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wert als Koeffizient f√ºr das linke </font><font style="vertical-align: inherit;">Pixel verwendet wird. Diese Zahl gibt den Grad der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transparenz des</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixels an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In anderen Phasen wird der Nebelwert angewendet (er wird aus der vom Programmierer erstellten Tabelle entnommen und anschlie√üend werden dieselben Mischungsberechnungen durchgef√ºhrt). Durchf√ºhrung von √úberpr√ºfungen und √Ñnderungen der Sichtbarkeit und Transparenz; Am Ende wird die Pixelfarbe in den Speicher der Grafikkarte geschrieben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum brauchen Sie diesen Ausflug in die Geschichte? </font><font style="vertical-align: inherit;">Nun, trotz der relativen Einfachheit des Designs (insbesondere im Vergleich zu modernen Monstern) beschreibt dieser Prozess die Grundprinzipien der Texturierung: Wir nehmen die Werte der Farben und mischen sie so, dass die Modelle und Umgebungen in einer bestimmten Situation so aussehen, wie sie sollten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Moderne Spiele machen dasselbe, der einzige Unterschied ist die Anzahl der verwendeten Texturen und die Komplexit√§t der Mischungsberechnungen. </font><font style="vertical-align: inherit;">Zusammen simulieren sie die visuellen Effekte von Filmen oder die Interaktion von Licht mit verschiedenen Materialien und Oberfl√§chen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texturierungsgrundlagen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr uns ist eine Textur ein flaches 2D-Bild, das den Polygonen √ºberlagert ist, aus denen die 3D-Struktur im Rahmen besteht. F√ºr einen Computer ist dies jedoch nur ein kleiner Speicherblock in Form eines 2D-Arrays. Jedes Element des Arrays bezeichnet den Farbwert eines der Pixel im Texturbild (√ºblicherweise als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Texturpixel bezeichnet). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder Scheitelpunkt des Polygons hat einen Satz von zwei Koordinaten (normalerweise als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v bezeichnet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), die dem Computer mitteilen, welches Pixel der Textur ihm zugeordnet ist. Der Scheitelpunkt selbst hat einen Satz von drei Koordinaten ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x, y, z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), und das Verkn√ºpfen von Texeln mit den Scheitelpunkten wird als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texturabbildung bezeichnet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu sehen, wie dies geschieht, wenden wir uns dem Tool zu, das wir bereits mehrmals in dieser Artikelserie verwendet haben - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Real Time Rendering WebGL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Im Moment verwerfen wir auch die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinate der </font><font style="vertical-align: inherit;">Eckpunkte und betrachten alles auf einer flachen Ebene.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/d20/fbb/8e1d20fbb308d78a19a2e54d5da96900.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Von links nach rechts: die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinaten der </font><font style="vertical-align: inherit;">Textur, die direkt mit den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x, y-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinaten </font><font style="vertical-align: inherit;">der </font><font style="vertical-align: inherit;">Eckscheitelpunkte verkn√ºpft sind </font><font style="vertical-align: inherit;">. Im zweiten Bild werden die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinaten an den oberen Eckpunkten erh√∂ht </font><font style="vertical-align: inherit;">, aber da die Textur immer noch an ihnen befestigt ist, wird sie vertikal gestreckt. Die Textur wurde bereits im rechten Bild ge√§ndert: Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werte </font><font style="vertical-align: inherit;">haben zugenommen, aber infolgedessen wurde die Textur komprimiert und dann wiederholt.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dies geschah, weil trotz der Tatsache, dass die Textur aufgrund des erh√∂hten Wertes von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tats√§chlich h√∂her geworden ist </font><font style="vertical-align: inherit;">, sie immer noch in das Grundelement passen sollte - tats√§chlich wiederholte sich die Textur teilweise. Dies ist eine M√∂glichkeit, den in 3D-Spielen h√§ufig vorkommenden Effekt zu implementieren: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederholen von Texturen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Beispiele f√ºr diesen Effekt sind Szenen mit steinigen oder grasbewachsenen Landschaften sowie mit Backsteinmauern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ñndern wir nun die Szene, sodass mehr Grundelemente vorhanden sind, und geben die Tiefe der Szene erneut zur√ºck. Die klassische Landschaftsansicht wird unten gezeigt, aber jetzt wird die Box-Textur kopiert und f√ºr alle Grundelemente wiederholt.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/9e1/0cb/a9e9e10cb533b78330f90fd7eaea3891.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Box-Textur im urspr√ºnglichen GIF-Format hat eine Gr√∂√üe von 66 KB und eine Aufl√∂sung von 256 x 256 Pixel. Die anf√§ngliche Aufl√∂sung des Teils des Rahmens, der von den Box-Texturen abgedeckt wird, betr√§gt 1900 x 680, dh aus Sicht des Pixel-Bereichs sollte ein solcher Bereich nur 20 Box-Texturen anzeigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist jedoch offensichtlich, dass wir viel mehr als zwanzig K√§stchen sehen. Dies bedeutet, dass die Textur des K√§stchens in der Ferne </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">viel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kleiner als 256 x 256 Pixel sein sollte. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Tat</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> haben sie einen Prozess namens </font><em><font style="vertical-align: inherit;">"Texturminimierung"</font></em><font style="vertical-align: inherit;"> durchlaufen </font><font style="vertical-align: inherit;">(ja, ein solches Wort existiert auf Englisch!). Wiederholen wir dies jetzt, aber diesmal bringen Sie die Kamera n√§her an eine der Schubladen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/404/c02/f70/404c02f70291916245ec931642c79860.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergessen Sie nicht, dass die Textur nur 256 x 256 Pixel gro√ü ist, aber hier sehen wir eine Textur, die gr√∂√üer als die H√§lfte des Bildes ist und eine Breite von 1900 Pixel hat. </font><font style="vertical-align: inherit;">Diese Textur wurde einer </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Texturvergr√∂√üerung"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unterzogen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese beiden Texturprozesse treten in 3D-Spielen st√§ndig auf, denn wenn sich die Kamera in der Szene bewegt, n√§hern sich die Modelle oder bewegen sich weg, und alle auf die Grundelemente angewendeten Texturen m√ºssen zusammen mit den Polygonen skaliert werden. </font><font style="vertical-align: inherit;">Aus mathematischer Sicht ist dies ein kleines Problem. Selbst die einfachsten integrierten Grafikchips k√∂nnen einen solchen Job problemlos ausf√ºhren. </font><font style="vertical-align: inherit;">Das Verkleinern und Vergr√∂√üern von Texturen ist jedoch eine neue Herausforderung, die auf irgendeine Weise angegangen werden muss.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mini-Kopien von Texturen erscheinen in der Szene</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste Problem, das f√ºr Texturen gel√∂st werden muss, ist die Entfernung. Wenn wir zum ersten Bild mit einer Landschaft aus K√§stchen zur√ºckkehren, haben die K√§stchen in der N√§he des Horizonts tats√§chlich nur eine Gr√∂√üe von wenigen Pixeln. Daher ist der Versuch, ein Bild mit 256 x 256 Pixel auf so kleinem Raum zu komprimieren, aus zwei Gr√ºnden sinnlos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens nimmt die kleinere Textur weniger Speicherplatz auf der Grafikkarte ein, was praktisch ist, da Sie versuchen k√∂nnen, sie in einen kleineren Cache einzupassen. Dies bedeutet, dass es weniger wahrscheinlich ist, dass es aus dem Cache gel√∂scht wird, dh, die wiederholte Verwendung dieser Textur f√ºhrt zu einer h√∂heren Leistung, da sich die Daten im engen Speicher befinden. Aus dem zweiten Grund werden wir bald zur√ºckkehren, da dies mit demselben Problem verbunden ist, das bei Texturen in der N√§he der Kamera auftritt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Standardl√∂sung f√ºr das Problem der Notwendigkeit, gro√üe Texturen in kleine </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundelemente</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu komprimieren, ist die Verwendung von </font><em><font style="vertical-align: inherit;">Mip-Texturen (Mipmaps)</font></em><font style="vertical-align: inherit;"> . Dies sind verkleinerte Versionen der urspr√ºnglichen Textur. Sie k√∂nnen von der Engine selbst (mithilfe der entsprechenden API-Befehle) generiert oder von Spieledesignern vorab erstellt werden. Jede nachfolgende Ebene der Mip-Textur hat eine halbe Gr√∂√üe im Vergleich zur vorherigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das hei√üt, f√ºr die Box-Textur betragen die Abmessungen: 256 x 256 ‚Üí 128 x 128 ‚Üí 64 x 64 ‚Üí 32 x 32 ‚Üí 16 x 16 ‚Üí 8 x 8 ‚Üí 4 x 4 ‚Üí 2 x 2 ‚Üí 1 x 1.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/074/973/1ea/0749731eae53d112d545c0297ac14584.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Mip-Texturen sind zusammen gepackt, sodass die Textur denselben Dateinamen hat, jedoch gr√∂√üer wird. Die Textur ist so gepackt, dass die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinaten </font><font style="vertical-align: inherit;">nicht nur bestimmen, welches Texel dem Pixel im Rahmen √ºberlagert ist, sondern auch mit welcher Mip-Textur. Dann schreiben die Programmierer einen Renderer, der auf dem Wert der Pixeltiefe des Rahmens basiert und bestimmt, welche Mip-Textur verwendet werden soll. Wenn der Wert beispielsweise sehr hoch ist, ist das Pixel weit entfernt, was bedeutet, dass Sie eine kleine Mip-Textur verwenden k√∂nnen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufmerksame Leser konnten das Fehlen von Mip-Texturen bemerken - sie m√ºssen daf√ºr bezahlen, indem sie die Gr√∂√üe der Texturen erh√∂hen. Die urspr√ºngliche Textur der Box war 256 x 256 Pixel, aber wie Sie im obigen Bild sehen k√∂nnen, hat die Textur mit Mip-Texturen jetzt eine Gr√∂√üe von 384 x 256. Ja, sie hat viel leeren Raum, aber egal wie wir kleinere Texturen im Allgemeinen verpacken Die Gr√∂√üe der Textur auf einer Seite erh√∂ht sich um mindestens 50%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies gilt jedoch nur f√ºr zuvor erstellte Mip-Texturen. Wenn die Spiel-Engine so programmiert ist, dass sie korrekt generiert wird, betr√§gt die Erh√∂hung nicht mehr als 33% der urspr√ºnglichen Texturgr√∂√üe. Aufgrund einer geringf√ºgigen Erh√∂hung des Speicherplatzes zum Speichern von Mip-Texturen erhalten wir daher einen Gewinn an Leistung und visueller Qualit√§t.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unten finden Sie einen Vergleich von Bildern mit deaktivierten / aktivierten Mip-Texturen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e96/b67/e71/e96b67e71c3f41aed3ce09ed728f98ea.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der linken Seite des Bildes wurden die Texturen der Boxen "wie sie sind" verwendet, was zum Auftreten von Granularit√§t und dem sogenannten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moir√©</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der Ferne f√ºhrte. </font><font style="vertical-align: inherit;">Rechts erm√∂glichte die Verwendung von Mip-Texturen glattere √úberg√§nge, und am Horizont wird die Textur der Box in eine einheitliche Farbe verwischt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wer m√∂chte jedoch, dass verschwommene Texturen die Hintergr√ºnde seines Lieblingsspiels verderben?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bilinear, trilinear, anisotrop - das alles ist f√ºr mich ein chinesischer Buchstabe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ausw√§hlen eines Pixels aus einer Textur, um es einem Pixel in einem Frame zu √ºberlagern, wird als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abtasttexturen bezeichnet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In einer idealen Welt w√ºrde es eine Textur geben, die ideal zu dem Grundelement passt, f√ºr das es entworfen wurde, unabh√§ngig von Gr√∂√üe, Position, Richtung usw. </font><font style="vertical-align: inherit;">Mit anderen Worten, das Abtasten der Textur w√§re eine einfache Eins-zu-Eins-Texel-Pixelabbildung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da dies jedoch nicht der Fall ist, m√ºssen beim Abtasten von Texturen mehrere Faktoren ber√ºcksichtigt werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wurde die Textur verkleinert oder vergr√∂√üert?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist die Textur eine Quell- oder Mip-Textur?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In welchem ‚Äã‚ÄãWinkel wird die Textur angezeigt?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns sie der Reihe nach analysieren. Der erste Faktor ist ziemlich offensichtlich: Wenn die Textur erh√∂ht wurde, gibt es im Grundelement mehr Texel, die das Pixel im Grundelement bedecken, als erforderlich; Beim Verringern ist das Gegenteil der Fall - jedes Texel sollte jetzt mehrere Pixel abdecken. Und das ist ein Problem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite Faktor verursacht keine Probleme, da Mip-Texturen verwendet werden, um das Problem der Abtastung der Texturen weit entfernter Grundelemente zu umgehen. Die einzige Aufgabe besteht darin, die Texturen in einem Winkel anzuzeigen. Und ja, das ist auch ein Problem. Warum? Weil alle Texturen Bilder sind, die f√ºr die Anzeige ‚Äûstreng vor‚Äú generiert wurden. In mathematischer Sprache entspricht die normale Oberfl√§chentextur dem Nennwert der Oberfl√§che, auf dem die Textur aktuell angezeigt wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn daher zu wenige oder zu viele Texel vorhanden sind oder sich in einem Winkel befinden, ist ein zus√§tzlicher Prozess erforderlich, der als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Texturfilterung" bezeichnet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn dieser Prozess nicht verwendet wird, erhalten wir Folgendes:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/792/a12/552/792a125529b7f3baa79c072fdf42acba.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier haben wir die Textur der Box durch eine Textur mit dem Buchstaben R ersetzt, um deutlicher zu zeigen, in welches Chaos das Bild ger√§t, ohne Texturen zu filtern! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grafik-APIs wie Direct3D, OpenGL und Vulkan bieten dieselben Filtertypen, verwenden jedoch unterschiedliche Namen. </font><font style="vertical-align: inherit;">Tats√§chlich laufen sie alle auf Folgendes hinaus:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Near Point Sampling</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lineare Texturfilterung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anisotrope Texturfilterung</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich ist das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abtasten der n√§chsten Punktabtastung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kein Filter, da damit nur das n√§chste Texel des erforderlichen Texturpixels abgetastet wird (z. B. aus dem Speicher kopiert) und dann mit der urspr√ºnglichen Farbe des Pixels gemischt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier hilft uns die lineare Filterung. Die erforderlichen </font><font style="vertical-align: inherit;">Texelkoordinaten </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden an die Abtastausr√ºstung √ºbertragen, aber anstatt das diesen Koordinaten am n√§chsten liegende Texel zu nehmen, nimmt der </font><font style="vertical-align: inherit;">Abtastger√§t </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vier</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texel. Hierbei handelt es sich um Texel, die sich oberhalb, unterhalb, links und rechts des Texels befinden, das durch Abtasten der n√§chstgelegenen Punkte ausgew√§hlt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese vier Texel werden dann unter Verwendung einer Formel mit Gewichten gemischt. In Vulkan sieht die Formel beispielsweise folgenderma√üen aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/9bb/63c/57b9bb63cc81fa5721b007717f6b200a.png"></div><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bezeichnet die Texelfarbe, wobei </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das Ergebnis der Filtration ist und 1-4 die Farbe von vier abgetasteten Texeln ist. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alpha-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beta-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werte </font><font style="vertical-align: inherit;">werden abh√§ngig davon genommen, wie weit der Punkt mit den Koordinaten </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von der Mitte der Textur entfernt ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Gl√ºck f√ºr diejenigen, die mit 3D-Grafiken zu tun haben, geschieht dies automatisch im Grafikchip. Genau das hat der TMU-Chip der 3dfx Voodoo-Karte getan: Er hat vier Texel abgetastet und sie dann zusammengemischt. In Direct3D hat dieser Prozess einen seltsamen Namen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr die bilineare Filterung.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber seit den Tagen von Quake und dem TMU-Chip haben Grafikkarten bereits gelernt, wie man eine bilineare Filterung in nur einem Taktzyklus durchf√ºhrt (nat√ºrlich, wenn sich die Textur bereits im n√§chsten Speicher befindet). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die lineare Filterung kann zusammen mit Mip-Texturen verwendet werden. Wenn Sie die Filterung komplizieren m√∂chten, k√∂nnen Sie vier Texel aus der Textur und vier weitere aus der n√§chsten Ebene der Mip-Textur entnehmen und alle mischen. Und wie hei√üt es in Direct3D? </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trilineare</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Filterung. Woher kamen die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äûdrei‚Äú</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in diesem Prozess </font><font style="vertical-align: inherit;">? Wir wissen es also nicht ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die letzte erw√§hnenswerte Filtermethode ist </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anisotrop</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tats√§chlich ist es eine Verbesserung des Prozesses, der durch bilineare oder trilineare Filterung durchgef√ºhrt wird. Zun√§chst wird berechnet</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Grad der Anisotropie</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der primitiven Oberfl√§che (und dies ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein √ºberraschend komplexer Prozess</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - dieser Wert erh√∂ht die √Ñnderung des Seitenverh√§ltnisses des primitiven aufgrund seiner Orientierung:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/247/dfe/e60/247dfee60846988a5e94a1020d9ecef6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die obige Abbildung zeigt dasselbe quadratische Grundelement mit gleichen Seitenl√§ngen. aber allm√§hlich dreht es sich in ein Rechteck, und seine Breite √§ndert sich mehr als seine H√∂he. Daher hat das Grundelement rechts einen h√∂heren Anisotropiegrad als links (und im Fall eines Quadrats ist der Grad Null). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In vielen modernen 3D-Spielen k√∂nnen Sie die anisotrope Filterung aktivieren und dann ihre Stufe √§ndern (von 1x auf 16x). Aber was √§ndert sich wirklich? Dieser Parameter steuert die maximale Anzahl zus√§tzlicher Texel-Samples, die in jedem anf√§nglichen linearen Sample entnommen werden. Angenommen, eine anisotrope bilineare Filterung von 8x ist im Spiel aktiviert. Dies bedeutet, dass anstelle von vier Texelwerten 32 Werte erhalten werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Unterschied bei der Verwendung der anisotropen Filterung ist deutlich zu erkennen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/302/372/df7302372c6dc0d34730ba572f695063.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gehen Sie einfach zum obigen Bild und vergleichen Sie die Abtastung der n√§chstgelegenen Punkte mit einer maximal 16-fachen anisotropen trilinearen Filterung. Erstaunlich glatt! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr diese glatte Sch√∂nheit von Texturen m√ºssen Sie jedoch mit Leistung bezahlen: Bei maximalen Einstellungen erh√§lt die anisotrope trilineare Filterung 128 Abtastwerte aus der Textur f√ºr jedes Pixel des Renderings. Selbst mit den besten modernen GPUs kann dies nicht in einem Taktzyklus erreicht werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie zum Beispiel AMD </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Radeon RX 5700 XT nehmen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann kann jeder der Texturierungsbl√∂cke im Prozessor bis zu 32 Texeladressen in einem Taktzyklus verwenden und dann im n√§chsten Taktzyklus 32 Texelwerte aus dem Speicher laden (von denen jeder eine Gr√∂√üe von 32 Bit hat) und dann vier davon in einem weiteren mischen Takt. Das hei√üt, um 128 Texel-Samples zu einem zu mischen, sind mindestens 16 Taktzyklen erforderlich.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/abf/cf4/fa4abfcf4411b6cc2622c8e77986ab3c.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU AMD RDNA Radeon RX 5700 mit 7-Nanometer-Prozesstechnologie</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn die Taktrate des 5700 XT 1605 MHz betr√§gt, dauern 16 Zyklen nur 10 </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nanosekunden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das Ausf√ºhren dieser Zyklen f√ºr jedes Pixel in einem 4K-Frame mit nur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Textureinheit dauert nur 70 Millisekunden. Gro√üartig, es sieht so aus, als w√§re Leistung keine gro√üe Sache! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bereits 1996 kamen 3Dfx Voodoo und √§hnliche Karten schnell mit Texturen zurecht. Sie konnten h√∂chstens 1 Texel mit bilinearer Filterung pro Zyklus ausgeben, und mit einer TMU-Chipfrequenz von 50 MHz konnten 50 Millionen Texel pro Sekunde verarbeitet werden. Ein Spiel mit 800 x 600 und 30 fps ben√∂tigt nur 14 Millionen Texel mit bilinearer Filterung pro Sekunde.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies gilt jedoch nur unter der Annahme, dass sich alle Texturen im n√§chsten Speicher befinden und nur ein Texel jedem Pixel entspricht. </font><font style="vertical-align: inherit;">Vor zwanzig Jahren war die Idee, mehrere Texturen auf ein Primitiv zu legen, v√∂llig fremd, aber heute ist es ein Standard. </font><font style="vertical-align: inherit;">Mal sehen, warum sich das alles √§ndert.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beleuchtung hinzuf√ºgen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu verstehen, warum Texturierung so wichtig geworden ist, schauen Sie sich diese Szene aus Quake an:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/dcf/ee4/bdadcfee4354ea561b9239e1ca5a143b.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein dunkles Bild, weil Dunkelheit die Atmosph√§re des Spiels war, aber wir sehen, dass die Dunkelheit nicht √ºberall gleich ist - einige Fragmente von W√§nden und B√∂den sind heller als andere, was in diesen Bereichen ein Gef√ºhl von Helligkeit erzeugt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Grundelemente, aus denen die W√§nde und der Boden bestehen, werden mit denselben Texturen √ºberlagert. Es gibt jedoch eine andere Textur, die als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄûLichtkarte‚Äú bezeichnet wird</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und mit den Werten der Texel gemischt wird, bevor sie auf die Rahmenpixel angewendet werden. In Bebenzeiten wurden Beleuchtungskarten im Voraus berechnet und von der Spiel-Engine erstellt. Sie wurden verwendet, um statische und dynamische Beleuchtungsst√§rken zu erzeugen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Vorteil ihrer Verwendung besteht darin, dass komplexe Beleuchtungsberechnungen eher mit Texturen als mit Scheitelpunkten durchgef√ºhrt wurden, was das Erscheinungsbild der Szene auf Kosten niedriger Geschwindigkeitskosten erheblich verbesserte. Offensichtlich ist das Bild nicht perfekt: Auf dem Boden f√§llt auf, dass die Grenze zwischen den beleuchteten Bereichen und den Schatten sehr scharf ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In vielerlei Hinsicht ist eine Lightmap nur eine andere Textur (vergessen Sie nicht, dass es sich bei allen um regul√§re 2D-Datens√§tze handelt). Daher ist diese Szene eines der ersten Beispiele f√ºr die Verwendung von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multitexturing</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wie der Name schon sagt, ist dies ein Prozess, bei dem zwei oder mehr Texturen einem Grundelement √ºberlagert werden. Die Verwendung von Beleuchtungskarten in Quake ist zu einer M√∂glichkeit geworden, die Einschr√§nkungen der Gouraud-Schattierung zu √ºberwinden. Mit der Erweiterung des Funktionsumfangs von Grafikkarten wurden jedoch auch die M√∂glichkeiten zur Anwendung von Multitexturing erweitert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3Dfx Voodoo war, wie viele andere Karten dieser Zeit, in der Anzahl der Operationen begrenzt, die es in einem einzigen </font><font style="vertical-align: inherit;">Rendering- </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durchgang</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausf√ºhren konnte </font><font style="vertical-align: inherit;">. Tats√§chlich ist ein Durchlauf ein vollst√§ndiger Renderzyklus: von der Verarbeitung von Scheitelpunkten bis zur Rasterung des Frames, dem anschlie√üenden √Ñndern der Pixel und dem Schreiben in den fertigen Frame-Puffer. Vor zwanzig Jahren verwendeten Spiele fast immer One-Pass-Rendering.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a55/0b6/bc9/a550b6bc98c07f1c90276e1aa3721819.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nvidia GeForce 2 Ultra, gegen Ende 2000. Bild: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikimedia</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dies geschah, weil die zweite Vertex-Verarbeitung nur zum Anwenden zus√§tzlicher Texturen in Bezug auf die Leistung zu kostspielig war. Nach Voodoo mussten wir einige Jahre warten, bis die Grafikkarten ATI Radeon und Nvidia GeForce 2 erschienen, die in einem Durchgang multitexturiert werden konnten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese GPUs hatten mehrere Textureinheiten im Pixelverarbeitungsbereich ( </font><font style="vertical-align: inherit;">dh </font><font style="vertical-align: inherit;">in der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipeline</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), so dass das Erhalten eines Texels mit bilinearer Filterung aus zwei getrennten Texturen die einfachste Aufgabe wurde. Dies erh√∂hte die Beliebtheit von Beleuchtungskarten weiter und erm√∂glichte es den Spielen, sie vollst√§ndig dynamisch zu gestalten und die Beleuchtungswerte abh√§ngig von den Bedingungen der Spielumgebung zu √§ndern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit ein paar Texturen k√∂nnte jedoch noch viel mehr getan werden. Lassen Sie uns also ihre F√§higkeiten untersuchen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das √Ñndern der H√∂he ist normal</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dieser Artikelserie √ºber 3D-Rendering haben wir nicht dar√ºber gesprochen, wie sich die Rolle der GPU auf den gesamten Prozess auswirkt (wir werden dar√ºber sprechen, aber nicht jetzt!). Wenn Sie jedoch zu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1 zur√ºckkehren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und den gesamten komplexen Prozess der Verarbeitung von Scheitelpunkten lesen, denken Sie m√∂glicherweise, dass dies der schwierigste Teil aller Arbeiten ist, die die GPU ausf√ºhren muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lange Zeit war es so, und Spielprogrammierer haben alles getan, um diese Last zu reduzieren. Sie mussten alle m√∂glichen Tricks anwenden, um die gleiche Bildqualit√§t wie bei der Verwendung mehrerer Scheitelpunkte sicherzustellen, diese jedoch nicht verarbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die meisten dieser Tricks verwendeten Texturen, die als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√∂henkarten</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normale Karten bezeichnet werden.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese beiden Konzepte sind durch die Tatsache verbunden, dass das letztere aus dem ersteren erstellt werden kann. Betrachten wir jedoch zun√§chst nur eine Technik namens </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄûBump Mapping‚Äú</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/db2/5b6/1e3db25b6ecefc0dd3f75c84f767800c.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bilder, die in einem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo-Rendering von Emil Persson erstellt wurden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die gepr√§gte Texturierung ist deaktiviert / aktiviert. Bei der gepr√§gten Texturierung</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
wird ein 2D-Array verwendet, das als ‚ÄûH√∂henkarte‚Äú bezeichnet wird und wie eine seltsame Version der urspr√ºnglichen Textur aussieht. </font><font style="vertical-align: inherit;">Das obige Bild zeigt beispielsweise eine realistische Ziegelstruktur, die auf zwei ebenen Fl√§chen liegt. </font><font style="vertical-align: inherit;">Die Textur und ihre H√∂henkarte sehen folgenderma√üen aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/87f/221/7a187f2215bcf0723bd4d4f820350858.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Farben der H√∂henkarte geben die Normalen der Oberfl√§che der Steine ‚Äã‚Äãan (wir haben in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1 einer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Artikelserie </font><font style="vertical-align: inherit;">√ºber die Normalen gesprochen </font><font style="vertical-align: inherit;">). Wenn der Rendervorgang das Stadium des Aufbringens der Ziegelstruktur auf die Oberfl√§che erreicht, wird eine Reihe von Berechnungen durchgef√ºhrt, um die Farbe der Ziegelstruktur basierend auf ihren Normalen zu √§ndern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen sehen die Steine ‚Äã‚Äãselbst dreidimensionaler aus, obwohl sie weiterhin vollst√§ndig flach bleiben. Wenn Sie genau hinschauen, insbesondere an den R√§ndern der Steine, k√∂nnen Sie die Einschr√§nkungen dieser Technik erkennen: Die Textur sieht leicht verzerrt aus. Dies ist jedoch ein schneller Trick, mit dem Sie mehr Oberfl√§chendetails hinzuf√ºgen k√∂nnen. Daher ist die gepr√§gte Texturierung sehr beliebt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine normale Karte √§hnelt einer H√∂henkarte, nur die Texturfarben sind die Normalen selbst. Mit anderen Worten, Berechnungen zum Konvertieren der H√∂henkarte in Normal sind nicht erforderlich. Sie k√∂nnen eine Frage stellen: Wie k√∂nnen Farben einen Vektor im Raum beschreiben? Die Antwort ist einfach: Jedes Texel hat eine Menge von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r-, g-, b-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werten </font><font style="vertical-align: inherit;">(rot, gr√ºn, blau) und diese Werte entsprechen direkt den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x-, y- und z-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werten </font><font style="vertical-align: inherit;">des Normalenvektors.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1f/105/c3b/c1f105c3b93c455ba7661489770172c9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das linke Diagramm zeigt die Richtungs√§nderung der Normalen auf einer unebenen Oberfl√§che. Um dieselben Normalen mit einer flachen Textur (mittlerer Umriss) zu beschreiben, weisen wir ihnen Farben zu. In diesem Fall haben wir die Werte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r, g, b</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (0,255,0) f√ºr den Vektor verwendet, der gerade nach oben gerichtet ist, und dann den Wert von Rot f√ºr die Neigung nach links und Blau f√ºr die Neigung nach rechts erh√∂ht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass diese Farbe nicht mit dem Originalpixel gemischt wird. Sie teilt dem Prozessor lediglich mit, in welche Richtung die Normalen zeigt, damit die Winkel zwischen Kamera, Lichtquellen und strukturierter Oberfl√§che korrekt berechnet werden k√∂nnen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Vorteile von gepr√§gten Texturen und normalen Karten liegen voll auf der Hand, wenn dynamische Beleuchtung in der Szene verwendet wird und wenn der Renderprozess den Effekt der Beleuchtungs√§nderung Pixel f√ºr Pixel berechnet und nicht f√ºr jeden Scheitelpunkt. Heutzutage verwenden moderne Spiele eine Reihe von Texturen, um die Qualit√§t dieses Tricks zu verbessern.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ef/d59/660/3efd596604528593b16923297f10f044.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bild: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ryan Benno</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
√úberraschenderweise ist diese realistisch aussehende Wand nur eine flache Oberfl√§che. Die Details von Ziegeln und Mauerzement werden nicht aus Millionen von Polygonen hergestellt. Stattdessen reichen nur f√ºnf Texturen und der durchdachte Einsatz von Berechnungen aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine H√∂henkarte wurde verwendet, um Schattenwurf mit Ziegeln zu erzeugen, und eine normale Karte wurde verwendet, um alle geringf√ºgigen Oberfl√§chen√§nderungen zu simulieren. Die Rauheitstextur wurde verwendet, um die Art und Weise zu √§ndern, in der Licht von verschiedenen Elementen der Wand reflektiert wird (zum Beispiel reflektiert glatter Ziegel das Licht gleichm√§√üiger als rauer Zement).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die letzte Karte, die im AO-Bild benannt ist, erzeugt einen Teil des Prozesses, der als Umgebungsokklusion bezeichnet wird: Wir werden diese Technik in den folgenden Artikeln genauer untersuchen, aber nehmen wir zun√§chst an, dass sie dazu beitr√§gt, den Realismus von Schatten zu erh√∂hen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture Mapping ist ein kritischer Prozess.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Texturierung ist bei der Entwicklung von Spielen unbedingt erforderlich. Nehmen wir zum Beispiel das Spiel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kingdom Come: Deliverance aus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dem Jahr 2019 </font><font style="vertical-align: inherit;">, ein Rollenspiel aus der ersten Person, das im 15. Jahrhundert in B√∂hmen spielt. Designer wollten die realistischste Welt dieser Zeit schaffen. Und um den Spieler in das Leben vor Hunderten von Jahren einzutauchen, ist es am besten, eine historisch korrekte Landschaft, Geb√§ude, Kleidung, Frisuren, Alltagsgegenst√§nde und vieles mehr zu implementieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede Textur in diesem Bild aus dem Spiel wurde manuell von K√ºnstlern erstellt und auch dank einer von Programmierern gesteuerten Rendering-Engine. Einige von ihnen sind klein, mit einfachen Details und werden daher leicht gefiltert oder mit anderen Texturen (z. B. H√ºhnerfl√ºgeln) verarbeitet.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2e/7d0/24a/e2e7d024ad0c700d26390940caf339ed.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Andere haben eine hohe Aufl√∂sung und viele kleine Details; </font><font style="vertical-align: inherit;">Sie werden anisotrop gefiltert und mit normalen Karten und anderen Texturen gemischt. Schauen Sie sich einfach das Gesicht der Person im Vordergrund an. </font><font style="vertical-align: inherit;">Der Unterschied in den Texturierungsanforderungen jedes Szenenobjekts wird von Programmierern ber√ºcksichtigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All dies geschieht heute in vielen Spielen, weil die Spieler immer mehr Details und Realismus erwarten. </font><font style="vertical-align: inherit;">Texturen werden gr√∂√üer und immer mehr von ihnen √ºberlagern die Oberfl√§che, aber der Prozess des Abtastens von Texeln und des √úberlagerns von Pixeln bleibt im Wesentlichen der gleiche wie in den Tagen von Quake. </font><font style="vertical-align: inherit;">Die besten Technologien sterben nie, egal wie alt sie sind!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de499524/index.html">Quarkus: Anwendungs-Upgrades anhand des Beispiels helloworld von JBoss EAP Quickstart</a></li>
<li><a href="../de499528/index.html">Eine "atemberaubende" mathematische Br√ºcke, die √ºber Fermats gro√üen Satz hinausgeht</a></li>
<li><a href="../de499532/index.html">W√∂rter in Zahlen: kostenlose Blog-Analyse habravebinary mit Yandex.Metrica</a></li>
<li><a href="../de499534/index.html">Entwicklungshandbuch f√ºr Python-Backend-Dienste</a></li>
<li><a href="../de499536/index.html">Growbox als Methode, sich selbst zu kennen</a></li>
<li><a href="../de499542/index.html">Top Fakapov Cyan</a></li>
<li><a href="../de499544/index.html">Lernen Sie neuronale Netze in Google Sheets</a></li>
<li><a href="../de499546/index.html">Firmware-Entwicklung f√ºr eine analoge Videokamera EVR-Y2022F</a></li>
<li><a href="../de499548/index.html">Maske - F√ºrsorge f√ºr andere oder eine Illusion von Sicherheit?</a></li>
<li><a href="../de499550/index.html">Low-Code-L√∂sungen f√ºr √ñkosysteme</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>