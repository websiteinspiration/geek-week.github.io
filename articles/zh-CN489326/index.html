<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😏 🕚 👏🏿 关于有效企业测试的思考 🧘🏾 🤯 🧝🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！
 
 最近，我们回到了对测试主题的彻底研究，并且在可预见的计划中，我们甚至还拥有关于单元测试的出色书籍。同时，我们认为上下文在该主题中无处不在，因此，今天，我们提供了两个著名Java EE专家Sebastian Dashner 博客上发表的出版物（合二为一）的译文-即系列1/6和2/6，关...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>关于有效企业测试的思考</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/489326/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈Ha！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近，我们回到了对测试主题的彻底研究，并且在可预见的计划中，我们甚至还拥有关于单元测试的出色书籍。</font><font style="vertical-align: inherit;">同时，我们认为上下文在该主题中无处不在，因此，今天，我们提供了两个</font><font style="vertical-align: inherit;">著名</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java EE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">专家</font><font style="vertical-align: inherit;">Sebastian Dashner </font><font style="vertical-align: inherit;">博客上发表的出版物（合二为一）的</font><font style="vertical-align: inherit;">译文-即系列1/6和2/6，关于有效的企业测试的想法。”</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
企业测试是一个尚未像我们希望的那样详细地研究过的主题。</font><font style="vertical-align: inherit;">编写尤其是支持测试需要花费大量时间和精力，但是，通过放弃测试来节省时间并不是一种选择。</font><font style="vertical-align: inherit;">为了提高测试的有效性，应探索多少量的任务，方法和测试技术？</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介绍</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不管测试的类型和范围如何，准备一组测试的目的都是要确保在这种材料上，我们的应用程序在生产中将完全按预期运行。</font><font style="vertical-align: inherit;">如果我们从用户的角度考虑该系统，那么这种动机应该是检查系统是否完成任务时的主要​​动机。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于注意力范围和上下文切换是不容忽视的事情，因此我们必须确保测试不会长时间运行和测试，并且测试结果是可预测的。</font><font style="vertical-align: inherit;">在编写代码时，快速验证代码（在一秒钟之内可行）至关重要-这可确保高生产率和工作重点。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一方面，我们必须确保测试支持。软件更改非常频繁，并且在功能测试中覆盖了大量代码，因此，生产代码中的每个功能更改都需要在测试级别进行更改。理想情况下，仅当功能（即业务逻辑）发生更改时，测试代码才应更改，而清理不必要的代码并进行重构时则不应更改。通常，测试方案应包括非功能性结构更改的可能性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我们考虑测试的不同应用领域时，就会出现一个问题：这些领域中哪些值得花费时间和精力？</font><font style="vertical-align: inherit;">例如，在微服务应用程序以及在代码分配和集成方面提供大量工作的任何系统中，集成测试尤其重要，有助于扩大系统边界。</font><font style="vertical-align: inherit;">因此，我们需要一种有效的方法来在本地开发过程中对整个应用程序进行整体测试，同时以尽可能接近生产的形式维护该应用程序的环境和结构。</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原则和局限性</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
无论选择哪种解决方案，我们都为测试套件定义以下原则和限制：</font></font><br>
<br>
<ul>
<li>     ,      .          ,           .    ,      ,       .</li>
<li>        ,   ,    .   ,     ,   ,    . ,       ,           .</li>
<li>     -       .    ,      ,        .</li>
<li>   ,      ,         . : «     HTTP-  gRPC,   JSON  -      enterprise-, ..?”.</li>
<li>           ,     ,   -.        API,   DSL    .</li>
<li>    « »,  ,    ,          , , ,  “dev”  debug ()  ,  dev  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Quarkus'</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Telepresence</a>,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">watch-and-deploy</a> («  »)  .</li>
<li>              .  ,             , ,    ,          .                .</li>
<li>        , ,   -,        ,  ,         .     ,          , ,       .</li>
</ul><br>
<h4> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
单元测试检查单个模块（通常是类）的行为，而所有与模块结构无关的外部因素都将被忽略或模拟。单元测试应验证各个模块的业务逻辑，而不检查其进一步的集成或配置。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据我的经验，大多数企业开发人员对单元测试的编译方式有很好的了解。为此，您可以在我的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">咖啡测试</font></a><font style="vertical-align: inherit;">项目中看到此示例。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在大多数项目中，JUnit与Mockito结合使用以模拟依赖关系，理想情况下，与AssertJ结合使用以有效地定义可读语句。我一直强调，无需特殊的扩展程序或启动程序即可执行单元测试，也就是说，可以使用常规的JUnit进行此测试。解释很简单：这全都与运行时有关，因为我们需要能够在几毫秒内运行数百个测试的功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，单元测试运行非常快，并且易于组装复杂的测试套件或特殊的工作流，因为它们易于执行，并且对测试的生命周期没有任何限制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，当您有许多模拟被测类的依赖关系的单元测试时，存在一个缺点：它们与实现紧密相关（这尤其适用于类和方法），这就是为什么我们的代码难以重构的原因。换句话说，对于生产代码中的每个重构操作，还需要更改测试代码。在最坏的情况下，开发人员甚至会开始部分拒绝重构，这仅仅是因为它太繁琐，并且项目中代码的质量正在迅速下降。理想情况下，开发人员应该能够重构和重新排列元素，前提是因此，在应用程序中没有引起用户注意的更改。单元测试决不总是简化重构生产代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是经验表明，单元测试对于检查用简洁的逻辑密集填充的代码或描述特定功能（例如算法）的实现的代码非常有效，并且同时不会与其他组件非常活跃地交互。特定类中的代码复杂度或密度越小，其循环复杂性越小，或者与其他组件的交互越活跃，则测试该类时单元测试的效果就越差。特别是在微服务的情况下，其中包含相对较少的业务逻辑，但提供了与外部系统的广泛集成，因此几乎不需要使用单元测试。在这样的系统中，单个模块（很少有例外）通常包含很少的专用逻辑。在决定时应考虑这一点花时间和精力更合适。</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试应用程序情况</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了解决将测试与实现紧密链接的问题，您可以尝试一种略有不同的方法来扩展测试的范围。</font><font style="vertical-align: inherit;">在我的书中，我写了关于组件测试的文章，因为找不到更好的术语。</font><font style="vertical-align: inherit;">但是，从本质上讲，在这种情况下，我们谈论的是测试应用情况。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
应用程序状况测试是在代码级别进行的集成测试，不使用内置容器-为加快启动速度而将其废弃。</font><font style="vertical-align: inherit;">他们测试了协调良好的组件的业务逻辑，这些组件通常在特定的实际案例中使用，从边界方法开始，然后一直到与之关联的所有组件。</font><font style="vertical-align: inherit;">使用模拟模仿与外部系统（例如与数据库）的集成。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在不使用会自动连接组件的更先进技术的情况下构建此类方案似乎是一项艰巨的工作。但是，我们定义了可重用的测试组件，它们也是通过模拟，连接以及添加测试配置来扩展组件的测试对象。所有这些都是为了最大程度地减少重构所需的工作量。目标是创建唯一的职责，以将更改的影响程度限制在测试领域中的单个类别（或多个类别）中。为了重复使用而进行此类工作，我们减少了必要的工作总量，并且随着项目的发展，这种策略是合理的，但是每个组件只需要进行少量维修，这项工作就会迅速摊销。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了更好地想象所有这一切，假设我们正在测试一个描述咖啡顺序的类。此类包括另外两个类别：</font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>OrderProcessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gp/xj/tb/gpxjtb-txbhrd0hzssooxzh1lw0.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
测试双打的类，</font></font><code>CoffeeShopTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且</font></font><code>OrderProcessorTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它们</font></font><code>*TD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都位于项目，他们继承了部件的试验区</font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>OrderProcessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位于该方案的主要区域。测试对象可以设置必要的仿真和连接逻辑，并有可能使用此应用程序中需要的仿真方法或验证方法来扩展类的公共接口。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下面显示了该组件的测试double类</font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeShopTestDouble</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CoffeeShop</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CoffeeShopTestDouble</span><span class="hljs-params">(OrderProcessorTestDouble orderProcessorTestDouble)</span> </span>{<font></font>
        entityManager = mock(EntityManager.class);<font></font>
        orderProcessor = orderProcessorTestDouble;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyCreateOrder</span><span class="hljs-params">(Order order)</span> </span>{<font></font>
        verify(entityManager).merge(order);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyProcessUnfinishedOrders</span><span class="hljs-params">()</span> </span>{<font></font>
        verify(entityManager).createNamedQuery(Order.FIND_UNFINISHED, Order.class);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">answerForUnfinishedOrders</span><span class="hljs-params">(List&lt;Order&gt; orders)</span> </span>{
        <span class="hljs-comment">//     </span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
测试double类可以访问CoffeeShop基类的字段和构造函数以建立依赖关系。在此，也以测试双胞胎的形式使用其他组件的变体，特别</font></font><code> OrderProcessorTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是需要它们来调用其他模拟或验证方法，这是实际情况的一部分。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
测试双精度类是可重用的组件，每个组件针对每个项目的作用域编写一次，然后在许多实际情况下使用：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeShopTest</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">private</span> CoffeeShopTestDouble coffeeShop;
    <span class="hljs-keyword">private</span> OrderProcessorTestDouble orderProcessor;<font></font>
<font></font>
    <span class="hljs-meta">@BeforeEach</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{<font></font>
        orderProcessor = <span class="hljs-keyword">new</span> OrderProcessorTestDouble();<font></font>
        coffeeShop = <span class="hljs-keyword">new</span> CoffeeShopTestDouble(orderProcessor);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testCreateOrder</span><span class="hljs-params">()</span> </span>{<font></font>
        Order order = <span class="hljs-keyword">new</span> Order();<font></font>
        coffeeShop.createOrder(order);<font></font>
        coffeeShop.verifyCreateOrder(order);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testProcessUnfinishedOrders</span><span class="hljs-params">()</span> </span>{<font></font>
        List&lt;Order&gt; orders = Arrays.asList(...);<font></font>
        coffeeShop.answerForUnfinishedOrders(orders);<font></font>
<font></font>
        coffeeShop.processUnfinishedOrders();<font></font>
<font></font>
        coffeeShop.verifyProcessUnfinishedOrders();<font></font>
        orderProcessor.verifyProcessOrders(orders);<font></font>
    }<font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
组件测试验证在入口点（在本例中为）调用的业务逻辑的特定情况</font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。由于所有连接和仿真都是在单独的测试对中进行的，因此此类测试简洁明了，并且以后可以使用高度专业的筛选技术，例如</font></font><code>verifyProcessOrders()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，测试类扩展了生产类的范围，允许您安装mokee并使用验证行为的方法。尽管事实上似乎在建立这样的系统上花费了很多精力，但是如果在整个项目的框架内，我们有许多可以重用组件的实际案例，那么这些成本就会迅速摊销。我们的项目越发展，这种方法就越有用-特别是如果您注意完成测试所花费的时间。我们所有的测试用例仍然使用JUnit运行，并且在最短的时间内，它们可以成百上千次执行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是此方法的主要优点：组件测试的运行速度与常规单元测试一样快，但是，由于需要对单个组件或仅对几个组件进行更改，因此它们刺激了生产代码的重构。</font><font style="vertical-align: inherit;">此外，通过使用针对我们主题领域的富有表现力的调优和验证方法来改进测试对象，我们提高了代码的可读性，便利了代码的使用并摆脱了测试脚本中的定型代码。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN489302/index.html">第31期：IT培训-领先公司的当前问题和挑战</a></li>
<li><a href="../zh-CN489304/index.html">ChIP-seq数据分析：从组蛋白到计算机任务</a></li>
<li><a href="../zh-CN489306/index.html">[哈伯]：甜甜圈</a></li>
<li><a href="../zh-CN489310/index.html">十大：Heisenbug 2019莫斯科的最佳报道</a></li>
<li><a href="../zh-CN489314/index.html">以太网四重奏：旧的速度，新的功能</a></li>
<li><a href="../zh-CN489328/index.html">Null悄悄溜走：使用Java破坏Scala Option</a></li>
<li><a href="../zh-CN489332/index.html">世界上最有效的情报服务情报中的基本助手（第3部分）</a></li>
<li><a href="../zh-CN489336/index.html">接口自行车有毒的祖父。“再次学习，学习和研究”（s1 e3）</a></li>
<li><a href="../zh-CN489340/index.html">由于在Internet上传输信息的最大单位变为1500字节</a></li>
<li><a href="../zh-CN489342/index.html">创建容错IT基础架构。第4部分。部署Cisco 3850交换机进行网关路由</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>