<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ü ‚úãüèº üö∂üèº The book "Bash and cybersecurity: attack, defense and analysis from the Linux command line" üë®üèΩ‚Äçüç≥ üïµüèª üöÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, habrozhiteli! The command line can be an ideal tool for cybersecurity. Incredible flexibility and absolute availability turn the standard comma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>The book "Bash and cybersecurity: attack, defense and analysis from the Linux command line"</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/501528/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/webt/xx/ml/ir/xxmlirxciwbxahmteiy-9cslfxg.jpeg" align="left" alt="image"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, habrozhiteli! </font><font style="vertical-align: inherit;">The command line can be an ideal tool for cybersecurity. </font><font style="vertical-align: inherit;">Incredible flexibility and absolute availability turn the standard command line interface (CLI) into a fundamental solution if you have the appropriate experience. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Authors Paul Tronkon and Karl Albing talk about tools and tricks of the command line that help to collect data with proactive protection, analyze logs and monitor network status. </font><font style="vertical-align: inherit;">Pentesters will learn how to conduct attacks using colossal functionality built into almost any version of Linux.</font></font><br>
<a name="habracut"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Who is this book for?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The book "Bash and cybersecurity" is intended for those who wish to learn how to work with the command line in the context of computer security. </font><font style="vertical-align: inherit;">Our goal is not to replace existing tools with command-line scripts, but rather to teach you how to effectively use the command line to improve existing functionality. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Throughout the book, we provide examples of security methods such as data collection, analysis and penetration testing. </font><font style="vertical-align: inherit;">The purpose of these examples is to demonstrate command line capabilities and introduce you to some of the fundamental methods used in higher-level tools. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This book is not an introduction to programming, although some general concepts are covered in Part I.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Real-time log monitoring</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The ability to analyze a magazine after an event has occurred is an important skill. </font><font style="vertical-align: inherit;">But it is equally important to be able to extract information from the log file in real time in order to detect malicious or suspicious actions at the time they occur. </font><font style="vertical-align: inherit;">In this chapter, we will consider methods for reading journal entries as they are created and formatted to display analytics and generate alerts based on known threat indicators for the operation of a system or network (indicators of compromise).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Text Log Monitoring</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The easiest way to monitor the log in real time is to use the tail command with the ‚Äìf parameter - it continuously reads the file and displays them in stdout as new lines are added. As in previous chapters, for examples we will use the Apache web server access log, but the described methods are relevant for any text log. To track the Apache access log using the tail command, enter the following: </font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The output from the tail command can be passed to the grep command, so only records matching certain criteria will be displayed. The following example tracks the Apache access log and displays entries corresponding to a specific IP address:</font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log | grep '10.0.0.152'<br>
</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can also use regular expressions. In this example, only records returning the HTTP 404 status code ‚ÄúPage not found‚Äù will be displayed; the -i option is added to ignore the case of characters: </font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log | egrep -i 'HTTP/.*" 404'</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To clear from extraneous information, the output should be passed to the cut command. This example monitors the access log for queries leading to status code 404, and then uses the cut method to display only the date / time and the requested page: </font><font style="vertical-align: inherit;">
Next, to remove the square brackets and double quotes, you can direct the output to tr -d ' [] "'.</font></font><br>
<br>
<code>$ tail -f access.log | egrep --line-buffered 'HTTP/.*" 404' | cut -d' ' -f4-7<br>
[29/Jul/2018:13:10:05 -0400] "GET /test<br>
[29/Jul/2018:13:16:17 -0400] "GET /test.txt<br>
[29/Jul/2018:13:17:37 -0400] "GET /favicon.ico</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note: the --line-buffering option of the egrep command is used here. </font><font style="vertical-align: inherit;">This forces egrep to print to stdout every time a line break occurs. </font><font style="vertical-align: inherit;">Without this parameter, buffering will occur and the output will not be sent to the cut command until the buffer is full. </font><font style="vertical-align: inherit;">We do not want to wait so long. </font><font style="vertical-align: inherit;">This option allows the egrep command to write each line as it is found.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COMMAND LINE BUFFERS </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What happens during buffering? </font><font style="vertical-align: inherit;">Imagine egrep finds a lot of strings matching the specified pattern. </font><font style="vertical-align: inherit;">In this case, egrep will have a lot of output. </font><font style="vertical-align: inherit;">But the output (in fact, any input or output) is much more expensive (takes more time) than data processing (text search). </font><font style="vertical-align: inherit;">Thus, the fewer I / O calls, the more efficient the program will be.</font></font><br>
<br>
     grep       ,  ,          .         .  grep       .   ,  grep   50    .   ,     50  ,     ,     .   50  !<br>
<br>
       egrep, ,             .  egrep       ,     ,     .    ,    ,   ,      ,      .      ,     .<br>
<br>
    ,    ,  tail -f        (    ),       . ,       ¬´ ¬ª,      .     .          .<br>
<br>
   ,        egrep     ,     .        ,   .</blockquote><br>
<h3>    </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can use the tail and egrep commands to monitor the log and display any entries that correspond to known patterns of suspicious or malicious activity, often called IOCs. You can create a simple intrusion detection system (IDS). First, create a file containing the regular expression patterns for the IOC, as shown in Example 8.1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Example 8.1. ioc.txt </font><b><font style="vertical-align: inherit;">(1)</font></b><font style="vertical-align: inherit;"> This template (../) is an indicator of a roundabout directory attack: an attacker tries to exit the current working directory and get to files that are not accessible to him. </font><b><font style="vertical-align: inherit;">(2)</font></b><font style="vertical-align: inherit;"> Linux etc / passwd and etc / shadow files are used for system authentication and should never be accessed through a web server. </font><b><font style="vertical-align: inherit;">(3)</font></b></font><br>
<br>
<code>\.\./ <b>(1)</b><br>
etc/passwd <b>(2)</b><br>
etc/shadow<br>
cmd\.exe <b>(3)</b><br>
/bin/sh<br>
/bin/bash<br>
</code><br>
<b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serving the cmd.exe, / bin / sh, or / bin / bash files is an indication of the reverse connection returned by the web server. A reverse connection often indicates a successful operation attempt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note that IOCs must be in regex format, as they will be used later by the egrep command. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The ioc.txt file can be used with the egrep -f option. This parameter tells egrep to search the regular expression patterns from the specified file. This allows you to use the tail command to monitor the log file, and as each record is added, the read line will be compared with all the templates in the IOC file, displaying any corresponding record. Here is an example:</font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log | egrep -i -f ioc.txt</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, the tee command can be used to simultaneously display warnings on the screen and save them for later processing in its own file: </font><font style="vertical-align: inherit;">
Again, the --line-buffered option is needed to ensure that there are no problems caused by buffering the output of the command.</font></font><br>
<br>
<code>tail -f /var/logs/apache2/access.log | egrep --line-buffered -i -f ioc.txt |<br>
tee -a interesting.txt</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows Log Monitoring</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As already mentioned, you must use the wevtutil command to access Windows events. </font><font style="vertical-align: inherit;">Although this command is universal, it does not have such functionality as tail, which can be used to extract new incoming records. </font><font style="vertical-align: inherit;">But there is a way out - use a simple bash script that can provide the same functionality (Example 8.2). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Example 8.2. </font><font style="vertical-align: inherit;">wintail.sh</font></font><br>
<br>
<pre><code class="java hljs">#!/bin/bash -<font></font>
#<font></font>
# Bash  <font></font>
# wintail.sh<font></font>
#<font></font>
# :<font></font>
#    tail   Windows<font></font>
#<font></font>
# : ./wintail.sh<font></font>
#<font></font>
<font></font>
WINLOG=<span class="hljs-string">"Application"</span> (<span class="hljs-number">1</span>)<font></font>
<font></font>
LASTLOG=$(wevtutil qe <span class="hljs-string">"$WINLOG"</span> <span class="hljs-comment">//c:1 //rd:true //f:text) (2)</span><font></font>
<font></font>
<span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span>
<span class="hljs-keyword">do</span>
      CURRENTLOG=$(wevtutil qe <span class="hljs-string">"$WINLOG"</span> <span class="hljs-comment">//c:1 //rd:true //f:text) (3)</span>
      <span class="hljs-keyword">if</span> [[ <span class="hljs-string">"$CURRENTLOG"</span> != <span class="hljs-string">"$LASTLOG"</span> ]]<font></font>
      then<font></font>
            echo <span class="hljs-string">"$CURRENTLOG"</span>
            echo <span class="hljs-string">"----------------------------------"</span>
            LASTLOG=<span class="hljs-string">"$CURRENTLOG"</span><font></font>
      fi<font></font>
done</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This variable defines the Windows log that you want to track. For a list of the logs currently available on the system, you can use the wevtutil el command. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here, wevtutil is executed to request the specified log file. The c: 1 parameter returns only one log entry. The rd: true parameter allows the command to read the most recent log entry. Finally, f: text returns the result in plain text, not in XML format, which makes it easy to read the result from the screen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next few lines run the wevtutil command again and the newly received log entry is compared to the last one printed on the screen. </font><font style="vertical-align: inherit;">If they differ from each other, this means that there have been changes in the log. </font><font style="vertical-align: inherit;">In this case, a new entry is displayed. </font><font style="vertical-align: inherit;">If the compared entries are the same, nothing happens and the wevtutil command goes back and starts searching and comparing again.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Real-time histogram creation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The tail -f command provides the current data stream. </font><font style="vertical-align: inherit;">But what if you want to count the number of lines that were added to the file for a certain period of time? </font><font style="vertical-align: inherit;">You can observe this data stream, start a timer and perform counting over a specified period of time; </font><font style="vertical-align: inherit;">then the counting should be stopped and the results reported.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This work can be divided into two script processes: one script will read the lines, and the other will watch the time. The timer notifies the line counter using a standard POSIX interprocess communication mechanism called a signal. A signal is a software interrupt, and there are various kinds of signals. Some of them are fatal - they lead to the end of the process (for example, an exception in a floating point operation). Most of these signals can be either ignored or caught. Action is taken when a signal is caught. Many of these signals have a predefined purpose in the operating system. We will use one of two signals available to users. This is the signal SIGUSR1 (the other is SIGUSR2).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Shell scripts can catch interrupts using the built-in trap command. Using it, you can select a command that determines what action you want to perform when a signal is received, and a list of signals that trigger a call to this command. For example: </font></font><br>
<br>
<code>trap warnmsg SIGINT</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This causes the warnmsg command (our own script or function) to be called whenever the shell script receives a SIGINT signal, for example, when you press Ctrl + C to interrupt a running process. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Example 8.3 shows a script that performs a count. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Example 8.3 looper.sh</font></font><br>
<br>
<pre><code class="java hljs">#!/bin/bash -<font></font>
#<font></font>
# Bash  <font></font>
# looper.sh<font></font>
#<font></font>
# :<font></font>
#    <font></font>
#<font></font>
# : ./looper.sh [filename]<font></font>
# filename ‚Äî  ,   ,<font></font>
#  : log.file<font></font>
#<font></font>
<font></font>
<span class="hljs-function">function <span class="hljs-title">interval</span> <span class="hljs-params">()</span>                                           <span class="hljs-params">(<span class="hljs-number">1</span>)</span>
</span>{<font></font>
      echo $(date <span class="hljs-string">'+%y%m%d %H%M%S'</span>) $cnt                       (<span class="hljs-number">2</span>)<font></font>
      cnt=<span class="hljs-number">0</span><font></font>
}<font></font>
<font></font>
declare -i cnt=<span class="hljs-number">0</span>
<span class="hljs-function">trap interval <span class="hljs-title">SIGUSR1</span>                                          <span class="hljs-params">(<span class="hljs-number">3</span>)</span>

shopt -s <span class="hljs-title">lastpipe</span>                                              <span class="hljs-params">(<span class="hljs-number">4</span>)</span>

tail -f --pid</span>=$$ ${<span class="hljs-number">1</span>:-log.file} | <span class="hljs-function"><span class="hljs-keyword">while</span> read <span class="hljs-title">aline</span>             <span class="hljs-params">(<span class="hljs-number">5</span>)</span>
<span class="hljs-keyword">do</span>
     let cnt++
done</span></code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The interval function will be called upon receipt of each signal. Of course, the interval must be defined before we can name it and use trap in our expression. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The date command is invoked to provide a timestamp for the value of the cnt variable that we are printing. After the counter is displayed, we reset this value to 0 to begin the countdown of the next interval. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now that the interval is defined, we can indicate that the function is called whenever our process receives the signal SIGUSR1. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a very important step. Usually, when there is a pipeline of commands (for example, ls-l | grep rwx | wc), parts of the pipeline (each command) are executed on subnets and each process ends with its own process identifier. This could be a problem for this scenario, because the while loop will be in a subshell with a different process identifier. Whatever process starts, the looper.sh script will not know the identifier of the while loop process to send a signal to it. In addition, changing the value of the variable cnt in the subshell does not change the value of cnt in the main process, so the signal for the main process will each time set the value to 0. To solve this problem, use the shopt command, which sets the -p parameter to lastpipe. It tells the shell not to create a subshell for the last command in the pipeline,and run this command in the same process as the script itself. In our case, this means that the tail command will be executed in a subshell (that is, in another process), and the while loop will become part of the main script process. Note: this shell option is available only in bash version 4.x and higher and only for non-interactive shells (i.e. scripts).</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(5)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is the tail -f command with another --pid parameter. We indicate the identifier of the process, which, upon completion of this process, will terminate the tail command. We specify the process ID of the current shell script $$ to be viewed. This action allows you to clean processes and not leave the tail command executed in the background (if, say, this script runs in the background; Example 8.4). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The tailcount.sh script starts and stops the script with a stopwatch (timer) and counts the time intervals. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Example 8.4. tailcount.sh</font></font><br>
<br>
<pre><code class="java hljs">#!/bin/bash -<font></font>
#<font></font>
# Bash  <font></font>
# tailcount.sh<font></font>
#<font></font>
# :<font></font>
#    n <font></font>
#<font></font>
# : ./tailcount.sh [filename]<font></font>
#     filename:  looper.sh<font></font>
#<font></font>
<font></font>
#  ‚Äî    <font></font>
<span class="hljs-function">function <span class="hljs-title">cleanup</span> <span class="hljs-params">()</span>
</span>{<font></font>
      [[ -n $LOPID ]] &amp;&amp; kill $LOPID          (<span class="hljs-number">1</span>)<font></font>
}<font></font>
<font></font>
<span class="hljs-function">trap cleanup <span class="hljs-title">EXIT</span>                             <span class="hljs-params">(<span class="hljs-number">2</span>)</span>
bash looper.sh $1 &amp;                           <span class="hljs-params">(<span class="hljs-number">3</span>)</span>
LOPID</span>=$!                                      (<span class="hljs-number">4</span>)<font></font>
#   <font></font>
sleep <span class="hljs-number">3</span><font></font>
<font></font>
<span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span>
<span class="hljs-keyword">do</span><font></font>
      kill -SIGUSR1 $LOPID<font></font>
      sleep <span class="hljs-number">5</span>
done &gt;&amp;<span class="hljs-number">2</span>                                      (<span class="hljs-number">5</span>)</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since this script will run other scripts, it should clean up after work. If the process identifier was stored in LOPID, the variable will store the value, therefore the function will send a signal to this process using the kill command. If you do not specify a specific signal in the kill command, then the SIGTERM signal will be sent by default. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The EXIT command is not a signal. This is a special case when the trap statement tells the shell to call this function (in this case cleanup) if the shell executing this script is about to shut down. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the real work begins. The looper.sh script is launched, which will run in the background: for this script to work throughout the cycle (without waiting for the command to complete the work), it is disconnected from the keyboard. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here, the identifier of the script process that we just started in the background is stored. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(5)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This redirect is simply a precaution. All output coming from a while loop or from kill / sleep statements (although we do not expect them) should not be mixed with any output from the looper.sh function, which, although it works in the background, sends them to stdout anyway. Therefore, we redirect data from stdout to stderr.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To summarize, we see that although the looper.sh function was placed in the background, its process identifier is stored in a shell variable. Every five seconds, the tailcount.sh script sends a signal SIGUSR1 to this process (which is executed in the looper.sh function), which, in turn, calls the looper.sh script to print the current number of lines fixed in it and restart the count. After exiting, the tailcount.sh script will be cleared by sending a SIGTERM signal to the looper.sh function to interrupt it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With the help of two scripts - a script that performs line counting, and a script with a stopwatch (timer) that controls the first script - you can get the output (the number of lines for a certain period), based on which the next script will build a histogram. It is called like this:</font></font><br>
<br>
<code>bash tailcount.sh | bash livebar.sh</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The livebar.sh script reads data from stdin and prints the output to stdout, one line for each input line (Example 8.5). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Example 8.5 </font><font style="vertical-align: inherit;">livebar.sh</font></font><br>
<br>
<pre><code class="java hljs">#!/bin/bash -<font></font>
#<font></font>
# Bash  <font></font>
# livebar.sh<font></font>
#<font></font>
# :<font></font>
#    ¬´¬ª <font></font>
#<font></font>
# :<font></font>
# &lt;output from other script or program&gt; | bash livebar.sh<font></font>
#<font></font>
<font></font>
<span class="hljs-function">function <span class="hljs-title">pr_bar</span> <span class="hljs-params">()</span>                                         <span class="hljs-params">(<span class="hljs-number">1</span>)</span>
</span>{<font></font>
      local raw maxraw scaled<font></font>
      raw=$<span class="hljs-number">1</span>
      maxraw=$<span class="hljs-number">2</span><font></font>
      ((scaled=(maxbar*raw)/maxraw))<font></font>
      ((scaled == <span class="hljs-number">0</span>)) &amp;&amp; scaled=<span class="hljs-number">1</span> #   
      <span class="hljs-keyword">for</span>((i=<span class="hljs-number">0</span>; i&lt;scaled; i++)) ; <span class="hljs-keyword">do</span> printf <span class="hljs-string">'#'</span> ; done<font></font>
      printf <span class="hljs-string">'\n'</span><font></font>
<font></font>
} # pr_bar<font></font>
<font></font>
maxbar=<span class="hljs-number">60</span>     #         (<span class="hljs-number">2</span>)<font></font>
MAX=<span class="hljs-number">60</span>
<span class="hljs-function"><span class="hljs-keyword">while</span> read dayst timst qty
<span class="hljs-keyword">do</span>
      <span class="hljs-title">if</span> <span class="hljs-params">(( qty &gt; MAX )</span>)                                   <span class="hljs-params">(<span class="hljs-number">3</span>)</span>
      then
           let MAX</span>=$qty+$qty/<span class="hljs-number">4</span>    #   <font></font>
           echo <span class="hljs-string">"                      **** rescaling: MAX=$MAX"</span><font></font>
      fi<font></font>
      printf <span class="hljs-string">'%6.6s %6.6s %4d:'</span> $dayst $timst $qty         (<span class="hljs-number">4</span>)<font></font>
      pr_bar $qty $MAX<font></font>
done<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The pr_bar function displays a string of hashtags that are scaled based on the provided parameters to the maximum size. </font><font style="vertical-align: inherit;">This feature may seem familiar, as we previously used it in the histogram.sh script. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is the longest hashtag line size that we can allow (to do without line wrapping). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How large will the values ‚Äã‚Äãto be displayed be? Without knowing this in advance (although this data can be provided to the script as an argument), the script will track the maximum. If this maximum is exceeded, the value will begin to ‚Äúscale‚Äù and the lines that are now displayed, and future lines will also be scaled to a new maximum. The script adds 25% to the maximum value, so it does not have to scale the value if the next new value each time increases by only 1-2%. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf defines the minimum and maximum width of the first two fields to be printed. </font><font style="vertical-align: inherit;">These are date and time stamps that will be truncated if the width values ‚Äã‚Äãare exceeded. </font><font style="vertical-align: inherit;">To display the entire value, specify its width of four characters. </font><font style="vertical-align: inherit;">In this case, despite the restrictions, all values ‚Äã‚Äãwill be printed. </font><font style="vertical-align: inherit;">If the number of characters in the values ‚Äã‚Äãis less than four, the missing ones will be supplemented with spaces. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since this script is read from stdin, you can run it yourself to see how it behaves. </font><font style="vertical-align: inherit;">Here is an example:</font></font><br>
<br>
<pre><code class="java hljs">$ bash  livebar.sh
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">20</span>
<span class="hljs-number">201010</span>     <span class="hljs-number">1020</span> <span class="hljs-number">20</span>:####################
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">70</span>
                       **** rescaling: MAX=<span class="hljs-number">87</span>
<span class="hljs-number">201010</span>     <span class="hljs-number">1020</span> <span class="hljs-number">70</span>:################################################
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">75</span>
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">75</span>:###################################################<font></font>
^C</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this example, input is mixed with output. </font><font style="vertical-align: inherit;">You can also put input in a file and redirect it to a script to see only the output:</font></font><br>
<br>
<pre><code class="java hljs">$ bash livebar.sh &lt; testdata.txt<font></font>
bash livebar.sh &lt; x.data<font></font>
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">20</span>:####################<font></font>
                 **** rescaling: MAX=<span class="hljs-number">87</span>
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">70</span>:################################################
<span class="hljs-number">201010</span> <span class="hljs-number">1020</span> <span class="hljs-number">75</span>:###################################################<font></font>
$</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬ªMore information on the book can be found on </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the publisher‚Äôs website</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
¬ª </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contents</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
¬ª </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excerpt</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
For Khabrozhiteley 25% discount on the coupon - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bash</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Upon payment of the paper version of the book, an electronic book is sent by e-mail.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en501516/index.html">Let's turn off the vacuum ?! Alexey Lesovsky</a></li>
<li><a href="../en501520/index.html">C # 8 and null validity. How do we live with this</a></li>
<li><a href="../en501522/index.html">Free Skillbox Webinars: Writing Games in PHP, Unity and Unreal Engine</a></li>
<li><a href="../en501524/index.html">Secrets of synchronizing the electromagnetic fields of the Earth and a living organism</a></li>
<li><a href="../en501526/index.html">Why Canadian English is considered "dirty" and what does Keanu Reeves have to do with it?</a></li>
<li><a href="../en501534/index.html">Now with COVID-19 there is also a rash</a></li>
<li><a href="../en501536/index.html">Custom-made: a story about how a line of code turned into kilotons of coal</a></li>
<li><a href="../en501538/index.html">Indentation in Python - Solution Option</a></li>
<li><a href="../en501544/index.html">Perfect smartphone</a></li>
<li><a href="../en501546/index.html">‚ÄúWhy am I going through this?‚Äù - psychologists explain how to find meaning in isolation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>