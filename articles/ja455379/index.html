<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎈 🥢 🛠️ （静的）C ++プログラムでの最適なコンテナーの選択 🧞 🏆 🧙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは。今日は静的解析についてもう一度お話ししたいと思います。そして再びC ++について。PVS-Studioとは異なり、プログラムでエラーを探すことはありません（ただし、エラーを探すだけではありません）が、最適に記述されていない場所を探します。そして、これらの場所の1つは、プログラム内のデータ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>（静的）C ++プログラムでの最適なコンテナーの選択</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455379/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは。</font><font style="vertical-align: inherit;">今日は静的解析についてもう一度お話ししたいと思います。</font><font style="vertical-align: inherit;">そして再びC ++について。</font><font style="vertical-align: inherit;">PVS-Studioとは異なり、プログラムでエラーを探すことはありません（ただし、エラーを探すだけではありません）が、最適に記述されていない場所を探します。</font><font style="vertical-align: inherit;">そして、これらの場所の1つは、プログラム内のデータのコンテナーを選択することです。</font><font style="vertical-align: inherit;">私があなたに興味があるなら、猫へようこそ！</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CoreHard 2018 Autumn（非常に良い会議です）で、C ++コンパイラーが現時点で最適化されない方法について話しました。そして</font><font style="vertical-align: inherit;">、私の不満の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、コンパイラーがプログラムでのコンテナーの使用を最適化できないことでした。いくつかのコード例を見てみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような単純なケースでは、コンパイラーはこの関数を最適化し、std ::ベクトル型の変数宣言を単純にスローできるはずです。C++ 14以降では、コンパイラーは動的メモリ割り当てを削除できるためです。これは、現時点では、動的割り当てを削除するための最適化を実装しているのは1つのC ++コンパイラ（Clang）のみであるためです。これまでのところ、他のすべてのコンパイラはこれを行う方法を知りません。しかし、Clangでさえ、限られた数のケースでこれを行うことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、選択したベクターのサイズが大きすぎないことを条件に、std ::ベクトルをstd ::配列に置き換えることができます。そのような置換に十分なスタックがない可能性があるためです。このような置換により、ヒープへのかなり高価なメモリ割り当てが削除されます。さらに、std ::配列を使用する場合、コンパイラは関数からstd ::配列を完全にスローできるという利点があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パフォーマンスの最適化について話している場合は、次の例を検討することをお勧めします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">42</span>; ++i) {<font></font>
        v.insert(v.begin(), <span class="hljs-number">42</span>);<font></font>
    }<font></font>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> val : v) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">' '</span>;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、std :: vector-コンテナーの先頭への挿入の場合、非常に非効率的な操作が使用されています。すべてのC ++プログラマーは、すべての要素が毎回シフトするため、コピー/移動に多大なコストがかかるため、これが非常に悪いことを知っています。この場合、挿入がどこで行われるかを考慮しないstd :: listまたはstd :: deque（この場合は挿入を使用する必要がないだけであることがはっきりとわかりますが）に置き換える方がはるかに優れています。ただし、これは単なる例であり、単なる挿入ではありません。 more :) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のコード例を見てみましょう：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; v;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) {<font></font>
        v.push_front(i);<font></font>
    }<font></font>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> val : v) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">' '</span>;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、std ::リスト（そう、私はめったに誰もそれを使用しないことを知っています）をstd :: forward_listに簡単に置き換えることができることがわかります。この場合、この場合、絶対に何も失うことはありませんが、メモリを節約できます。もちろん、コンパイラーはそのような最適化を今は行いません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の例でも同様のトリックを実行できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; v;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) {<font></font>
        v.push_back(i);<font></font>
    }<font></font>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; v.back() &lt;&lt; <span class="hljs-string">' '</span>;<font></font>
        v.pop_back();<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、本当に必要なのはstd :: dequeではなく、std ::スタックであることがわかります。</font><font style="vertical-align: inherit;">std ::スタックはアダプターであり、デフォルトではstd :: dequeの内部で使用されるため、これは最適化とは言えません（ユーザーが指定しない限り）。</font><font style="vertical-align: inherit;">ここでは、セマンティック最適化について詳しく説明します。</font><font style="vertical-align: inherit;">コードを単純化して理解します。</font><font style="vertical-align: inherit;">私の観点からは、これも重要です。</font><font style="vertical-align: inherit;">「このような置き換えでもパフォーマンスが向上するのではないか」と質問した場合、「たぶんそうだろう。</font><font style="vertical-align: inherit;">標準ライブラリのバージョンの実装の詳細を参照してください。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、十分な例があると思います。</font><font style="vertical-align: inherit;">一人一人がそれらの多くを思いつくこともできます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中古工具</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静的アナライザーを実装するために、LLVMパッケージの一部であるClang Static Analzyer（CSA）とClang Tidyを使用しました。これらのツールを選択したのは、静的分析用のオープンツールの中で最も有望であると考えているためです。さらに、Clangは、他の静的アナライザーが誇ることができない最高品質のC ++パーサーの1つを提供します（もちろん、libclangを使用する場合を除きます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSAとClang Tidyはどちらも静的アナライザーで、どちらもLLVMの一部です。違いはなんですか？違いは、Clang Tidyは単純なチェックを作成するように設計されていることです。これは基本的に、抽象構文ツリーで何らかのパターンを見つけ、何らかの警告を表示し、おそらく別の警告に自動的に置き換えることで構成されます。 Clang Tidyについて詳しくは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらをご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSAは、より「深刻」でリソースを大量に消費する（実装の観点からも、実行時間/消費メモリの観点からも）チェックを書き込むように設計されています。そこでは、例えば、シンボリック実行メカニズムが利用可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSAに検証を実装することにしました。これは私には当たり前のことではないようです。さらに、将来的にはますます難しくなります。</font><font style="vertical-align: inherit;">そして、この静的アナライザーは</font><font style="vertical-align: inherit;">さまざまなIDEとの統合</font><font style="vertical-align: inherit;">が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多数あるため</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Clang Tidyを介して実行することが決定されました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題を解決する方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、かなり強力な制限をいくつか導入する価値があります。これは主に、これがこれまでのプロトタイプにすぎないという事実に関連しています。</font></font><br>
<br>
<ul>
<li>    ;   ,       ,     .                            ,      .           CSA,     (    );</li>
<li>    .             .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象構文のツリーのみを分析に使用します。</font><font style="vertical-align: inherit;">プロトタイピングのために、これは最も単純なタイプの分析です。</font><font style="vertical-align: inherit;">もちろん、より正確な結果を得るには、少なくともシンボリック実行を使用してみることができますが、この方法には欠点があります。</font><font style="vertical-align: inherit;">メソッドの詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらをご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、プロトタイプは次の単純なアルゴリズムを実装します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まず、抽象構文ツリーで、サポートするコンテナタイプ変数の宣言を担当する頂点を見つけます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、これらのコンテナーに関連する操作を見つけて分類し、この情報を一時キャッシュに保存します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数の最後に達した後、収集された統計を分析し、事前定義されたルールに基づいて、コンテナーの使用に関する推奨を発行します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在のコンテナ事業の分類は以下の通りです（今後拡大予定）。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナの上部にアイテムを追加します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナーの中央にアイテムを追加します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナの最後にアイテムを追加します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナーの先頭からアイテムを削除します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナーの中央からアイテムを削除します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナの端からアイテムを削除します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現時点での分類は不完全であり、このリストに載っていても正しく機能しません。</font><font style="vertical-align: inherit;">たとえば、挿入操作は、最初に実行されたとしても、実際にはまったく挿入されていませんが、途中で挿入として分類されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">誤検知との戦い</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静的分析では、誤検知が主な頭痛の種です。それらが多すぎると、有用なメッセージがゴミとして失われます。したがって、この場合は、非常に慎重に行動し、診断に本当に自信があり、コードのどこかで何かが本当に間違っているとかなり言える場合にのみ警告を発行する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラの最適化について言えば、それはまだ悲しいことです。適切な最適化では、C ++標準に従ってプログラムの動作を変更することはできません（それ以外の場合、そのようなオプティマイザは価値がありません）。そして、最適化も悲観化をもたらすべきではありません:)ですから、ここであなたはあなたの決定においてもっと注意深くなければなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアナライザーでは、この闘争の結果、サポートされていない操作が現在実行されていることがアナライザーで確認されると、このコンテナーの分析がオフになります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">短所と可能な解決策</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法にはいくつかの問題があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の問題は、現時点でのアナライザーの場合、コードのすべての分岐の確率が同じであるということです。</font><font style="vertical-align: inherit;">より正確には、彼はコード実行の異なるブランチのようなことについてさえ知りません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、次のコードのようなものの分析に関する問題に変換されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* ptr, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; v)</span> </span>{
    <span class="hljs-keyword">if</span>(ptr == <span class="hljs-literal">nullptr</span>) {<font></font>
        v.insert(v.begin(), <span class="hljs-number">42</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        v.push_back(<span class="hljs-number">84</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、アプリケーションコードでは、これらのブランチは実行の確率が等しくありません。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">現実の世界</font><b><font style="vertical-align: inherit;">では</font></b><font style="vertical-align: inherit;">、ポインター</font><b><font style="vertical-align: inherit;">は通常</font></b><font style="vertical-align: inherit;">、nullptrではなく正常なものを指しているためです。同じLLVMでは、このスコアに静的なヒューリスティックがあります。たとえば、nullptrを使用してポインターを比較し、浮動小数点を使用して2つの変数の値が等しいかどうかを比較する上記のケースと、他のいくつかの興味深いケースを考慮します。しかし、これはますます松葉杖に似ており、私の観点からは、この問題の本当の解決策は動的分析または計測を追加することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の問題は、カスタムコンテナーのサポートの欠如です。私たちはC ++の世界に住んでいるので、コンテナを含め、すべてがここに乗るのが好きです（これが必ずしも悪い現象ではない理由については、この記事の範囲外に置いておきます）。例には、同じLLVM、LibreOffice、および他の多くが含まれます。これに関して、疑問が生じます-STLライブラリからではなくコンテナをどのように分析するのですか？結局、できるだけ多くのコンテナの分析を含めたいと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題を解決するにはさまざまな方法があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つ目は、ユーザーが何らかの方法でコンテナに注釈を付けることです（特別な種類のコメント、C ++属性など）。この方法の問題は、一般的な注釈方法、定性分析に必要な情報を理解する必要があることです。別の問題は、コンテナ自体のコード変更である可能性がありますが、これは常に可能とは限りません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の方法は、ユーザーに独自のルールを作成するためのメカニズムを提供します。</font><font style="vertical-align: inherit;">現時点では、アナライザーのルールはアナライザー自体のソースコードに組み込まれており、ユーザーが独自のルールを追加したい場合は、アナライザーのソースコードをダウンロードしてアセンブルし、チェックの記述方法、書き込み、再構築などを理解する必要があります。</font><font style="vertical-align: inherit;">一部のDSLにチェックを設定する方法をユーザーに提供できます。この場合、ユーザーはコンテナーのチェックのみを書き込み、アナライザーはルーチン全体に関与します。</font><font style="vertical-align: inherit;">この方法は前の方法よりも有望だと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、この機能はCSA（ただしClang Tidy）にはないため、自動コンテナー置換はサポートされていません。</font><font style="vertical-align: inherit;">ただし、困難な場合には、オートコレクトの実行は必ずしも簡単な作業ではありません。アナライザーは、半手動モードで動作する可能性が高くなります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能な用途</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタイプの分析にはいくつかの用途があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的アナライザーのようです。</font><font style="vertical-align: inherit;">ここではすべてがシンプルです-静的分析の別のテスト（心臓を必要に応じて（手で、開発中にIDEで自動的に、CIなどで）実行します）。コンテナとより良いを拾います。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラーの最適化のように。</font><font style="vertical-align: inherit;">場合によっては、コンテナーの交換がパフォーマンスに悪影響を及ぼさないことが保証されます。</font><font style="vertical-align: inherit;">たとえば、コンパイル時に既知の小さなサイズのstd ::ベクトルをstd ::配列に置き換えるか、相互接続性が不要でリストからサイズを取得しない場合、std ::リストをstd :: forward_listに置き換えます。</font><font style="vertical-align: inherit;">コンパイラは、非常に多くのことをすでに行っているので、私たちの知識がなくてもコンテナをより最適なコンテナに置き換えることができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的アナライザーのようです。</font><font style="vertical-align: inherit;">これは、私にとってこのタイプの分析で最も有望と思われる方向です。</font><font style="vertical-align: inherit;">実際、プログラムの実行プロファイルに関する知識を活用することで、たとえば、各コードブランチの実行確率などの重要な情報を取得できます。</font><font style="vertical-align: inherit;">そして、これはより正確な評価のために必要です。</font><font style="vertical-align: inherit;">そして、そのような分析により、PGOとの統合の方向性をすでに考えることができます...</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、この方法はC ++プログラムだけに適用できるわけではありません。</font><font style="vertical-align: inherit;">コンパイラや他のプログラミング言語でこの種の静的分析/最適化を実際に見たいです。</font><font style="vertical-align: inherit;">たとえば、ABAPのSAP静的アナライザーは、基本レベルで静的最適性分析を実行する方法をすでに知っています。これは朗報です。</font><font style="vertical-align: inherit;">他のプログラミング言語の同様のプロジェクトを知っている場合はコメントに書き込んでください。記事に追加します！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同様の方向で働く</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++の世界では、そのようなアナライザーはどこにもありません。</font><font style="vertical-align: inherit;">ABAPの世界では、標準のコンテナーの一部に対して非効率的な操作が見つかる可能性がある上記のアナライザーについて説明しましたが、私の知る限り、非常に単純な静的分析がそこで実装されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに興味深い作業は</font><font style="vertical-align: inherit;">、Javaの動的アナライザーである</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chameleon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。これは非常に巧妙に行われます。</font><font style="vertical-align: inherit;">彼らはJVMを少し調整し、操作中にコンテナの使用に関するさまざまな統計を収集し、現在の負荷プロファイルに応じて、特定のコンテナを選択し、操作中にそれらを自動的に置き換えます。</font><font style="vertical-align: inherit;">残念ながら、ソースは閉じられており、入手する機会はありません（私は試しました）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">SETLの</font></a><font style="vertical-align: inherit;">さまざまな作品（たくさんあります）を見るのもお勧めします</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それらの中で、著者はしばしばコンテナの自動選択についての質問も出しました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h3><br>
<ol>
<li><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">githubでの</font></a><font style="vertical-align: inherit;">現在の実装</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ Russia 2017：Yuri Efimochev、clang-tidy：C ++ Abstract Syntax Tree内の旅</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カメレオン：コレクションの適応選択</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clang静的アナライザーガイド</font></font></a></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Telegramでのコンパイラーの開発に関する</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ロシア語のチャット</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">興味があれば是非お越しください。</font><font style="vertical-align: inherit;">洪水に注意してください-彼らはすぐに彼を罰します:)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論ではなく、これはプロトタイプにすぎず、実装に「穴」が多すぎるという事実に焦点を当てたいと思います。</font><font style="vertical-align: inherit;">この記事では、そのような分析とその普及のアイデアを皆さんと共有したいと思います。</font><font style="vertical-align: inherit;">まあ、多分誰かがこのトピックに興味を持って、プロジェクトに接続したい願望があるでしょう-私だけが幸せになります！</font><font style="vertical-align: inherit;">さらに、いつでもこのアナライザーを自分の場所に集めて、テスト例で試すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
資料を補足する何かがある場合、同様の問題が発生した場合、またはこのトピックに役立つ可能性がある情報がある場合は、コメントでこの情報を共有してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご清聴ありがとうございました！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja455369/index.html">記念日DevConfX（6月21〜22日、モスクワ）でのデータベース管理者などの認定</a></li>
<li><a href="../ja455371/index.html">5μAから20 mAまでの安定した電流源</a></li>
<li><a href="../ja455373/index.html">小規模なプロバイダー向けに昇格するように春の法則を調整する方法は？キャンセルする</a></li>
<li><a href="../ja455375/index.html">PascalでのUDRの記述</a></li>
<li><a href="../ja455377/index.html">IoTアーキテクチャ</a></li>
<li><a href="../ja455381/index.html">3CXテクニカルサポートの応答：PBXサーバーでのSIPトラフィックのキャプチャ</a></li>
<li><a href="../ja455387/index.html">Elastic Stackでの機械学習の理解（Elasticsearch、別名ELK）</a></li>
<li><a href="../ja455389/index.html">Haxe 4：新機能</a></li>
<li><a href="../ja455391/index.html">パート1：不自然な生息地におけるRISC-V / RocketChip</a></li>
<li><a href="../ja455393/index.html">レーダーにおけるスペクトル推定のパラメトリック法の使用について-MUSIC法。記事への追加</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>