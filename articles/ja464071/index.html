<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👬 👶🏽 🤠 革命か痛みか？Yandex React Hooksレポート 👨‍🔬 👰🏿 ✋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私の名前はArtyom Berezinです。私はいくつかのYandex内部サービスの開発者です。過去6か月間、React Hooksを積極的に使用しています。その過程で、戦わなければならないいくつかの困難がありました。この経験を皆さんと共有したいと思います。レポートでは、React Hook API...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>革命か痛みか？Yandex React Hooksレポート</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/464071/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私の名前はArtyom Berezinです。私はいくつかのYandex内部サービスの開発者です。過去6か月間、React Hooksを積極的に使用しています。その過程で、戦わなければならないいくつかの困難がありました。この経験を皆さんと共有したいと思います。レポートでは、React Hook APIを実用的な観点から検討しました-なぜフックが必要なのか、切り替える価値があるのか​​、移植するときに検討するのが良いでしょう。移行中に間違いを犯すことは簡単ですが、それを回避することもそれほど難しくありません。</font><font style="vertical-align: inherit;">
-フックは、コンポーネントのロジックを記述するもう1つの方法です。これにより、以前はクラスのコンポーネントにのみ固有であったいくつかの機能を機能コンポーネントに追加できます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/xm/xa/7n/xmxa7ngpjx3l902ndjcetpyhsp0.jpeg"></a><br>
 <br><font style="vertical-align: inherit;"></font><br>
<br>
<a name="habracut"></a><img src="https://habrastorage.org/webt/hd/r8/4b/hdr84b-fmfibqz-gwcb0k8feny8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず第一に、それは内部状態のサポートであり、次に-副作用のサポートです。たとえば、ネットワーク要求またはWebSocketへの要求：サブスクリプション、一部のチャネルからのサブスクリプション解除。または、おそらく、他の非同期または同期ブラウザAPIへのリクエストについて話しています。また、フックを使用すると、コンポーネントのライフサイクル、ライフの始まり、つまりマウント、小道具の更新、死にアクセスできます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9d/f4/lk/9df4lk5afueo28ftgmebxggxuw0.jpeg"> <br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、比較する最も簡単な方法です。以下は、クラスのコンポーネントでのみ使用できる最も単純なコードです。コンポーネントが何かを変更しています。これは通常のカウンタであり、状態を1つだけ増やしたり減らしたりできます。一般的に、Reactに精通していれば、コードは完全に明らかだと思います。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/iy/ms/2_/iyms2_hexuxc_nx5cnxwux8crva.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まったく同じ機能を実行しますが、フックで記述された同様のコンポーネントは、はるかにコンパクトに見えます。私の計算によると、平均して、クラスのコンポーネントからフックのコンポーネントに移植する場合、コードは約1.5倍に減少し、満足しています。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フックのしくみについて一言。フックは、React内で宣言され、コンポーネントがレンダリングされるたびに呼び出されるグローバル関数です。 Reactはこれらの関数の呼び出しを追跡し、その動作を変更したり、何を返すかを決定したりできます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yy/wy/xf/yywyxfylah95eiqs8saijtqbf-a.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常の関数と区別するフックの使用にはいくつかの制限があります。まず第一に、それらはクラスのコンポーネントでは使用できません。それらはそれらのためではなく、機能コンポーネントのために作成されるため、このような制限が適用されます。フックは、内部関数内、ループ内、条件内で呼び出すことはできません。コンポーネント関数内で、ネストの最初のレベルでのみ。この制限は、どのフックが呼び出されたかを追跡できるようにするために、React自体によって課されます。そして彼は彼の脳の中でそれらを特定の順序で積み重ねます。次に、この順序が突然変更されたり、一部が消えたりすると、複雑で、とらえどころのない、デバッグが難しいエラーが発生する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、かなり複雑なロジックがあり、たとえばフック内のフックを使用したい場合、これはおそらくフックを作成する必要があるという兆候です。複数のフックを別々のカスタムフックで相互に接続するとします。その中で、他のカスタムフックを使用して、フックの階層を構築し、そこで一般的なロジックを強調表示できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wr/av/h_/wravh_lbocryqocrjlnwqs8rrr4.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フックは、クラスに比べていくつかの利点があります。まず第一に、前のものから次のように、カスタムフックを使用すると、ロジックをはるかに簡単に探すことができます。以前は、高次コンポーネントでのアプローチを使用して、ある種の共有ロジックをレイアウトしましたが、これはコンポーネントのラッパーでした。次に、このロジックをフック内に配置します。したがって、コンポーネントツリーが削減されます。そのネストが削減され、Reactによるコンポーネントの変更の追跡、ツリーの再計算、仮想DOMの再計算などが容易になります。これにより、いわゆるラッパー地獄の問題が解決されます。 Reduxを使用する人は、これに精通していると思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フックを使用して記述されたコードは、Terserや古いUglifyJSなどの最新の最小化機能を使用すると、最小化がはるかに簡単になります。実際には、メソッドの名前を保存する必要はなく、プロトタイプについて考える必要もありません。トランスパイレーション後、ターゲットがES3またはES5の場合、通常はパッチを当てた一連のプロトタイプを取得します。ここでは、これをすべて実行する必要はないため、最小化する方が簡単です。また、クラスを使用しないため、これについて考える必要はありません。初心者にとって、これはしばしば大きな問題であり、おそらくバグの主な理由の1つです。これはウィンドウである可能性があることを忘れており、たとえば、コンストラクターまたはその他の方法でメソッドをバインドする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、フックを使用すると、1つの副作用を制御するロジックを強調表示できます。以前は、このロジックは、特にコンポーネントにいくつかの副作用がある場合、コンポーネントのライフサイクルのさまざまなメソッドに分割する必要がありました。また、最小化フックが登場し、React.memoが登場したため、機能コンポーネントはメモ化に向いています。つまり、小道具が変更されていない場合、このコンポーネントは再作成または更新されません。これは以前は不可能でしたが、今では可能です。すべての機能コンポーネントはメモでラップできます。また、useMemoフックの内部が表示されました。これを使用して、重い値を計算したり、ユーティリティクラスを1回だけインスタンス化したりできます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的なフックについて話さないとレポートは不完全になります。まず、これらは状態管理フックです。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/ud/wg/vl/udwgvlovxonthzvnknxeewerxea.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず第一に-useState。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0c/xb/pk/0cxbpky3iayxkvaxutbik_ohbcw.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例は、レポートの冒頭の例と似ています。 useStateは初期値を取り、現在の値とその値を変更する関数からタプルを返す関数です。すべての魔法は内部的にReactによって提供されます。この値を読み取るか、変更するだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスとは異なり、必要に応じていくつでも状態オブジェクトを使用でき、クラスのように1つのオブジェクトに混ざらないように状態を論理的な断片に分割します。そして、これらの部分は互いに完全に分離されます：互いに独立して変更できます。たとえば、このコードの結果：2つの変数を変更し、結果を計算して、最初の変数をfroに、2番目の変数をfroに変更できるボタンを表示します。この例を覚えておいてください。後で同じことをしますが、はるかに複雑になるからです。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/qh/cb/7r/qhcb7rezzu2hu5ymyqw8nw1bl9e.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redux愛好家のためのステロイドには、そのようなuseStateがあります。リデューサーを使用して、より一貫して状態を変更できます。 Reduxに慣れている人は説明さえできないと思いますが、不慣れな人には教えてあげます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レデューサーは、状態をとる関数であり、通常はアクションと呼ばれるオブジェクトで、この状態がどのように変化するかを記述します。より正確には、いくつかのパラメーターを渡し、レデューサー内で、パラメーターに応じて、状態がどのように変化するかを決定し、その結果、新しい状態を返し、更新する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k6/5x/gd/k65xgdpidy6wnhmuxabw3sqqtk0.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほぼこのようにして、コンポーネントコードで使用されます。 useReducerフックがあり、レデューサー関数を使用します。2番目のパラメーターは状態の初期値です。 useStateと同様に、現在の状態と、それを変更する関数がディスパッチされます。ディスパッチするアクションオブジェクトを渡すと、状態変更が呼び出されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/un/sl/ng/unslngsedmksssjrthxjmzhn7bu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非常に重要なuseEffectフック。コンポーネントに副作用を追加して、ライフサイクルの代替手段を提供できます。この例では、useEffectを使用した単純なメソッドを使用しています。これは、たとえばAPIを使用してサーバーからデータを要求し、このデータをページに表示するだけです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bb/tc/gf/bbtcgfyw89tgu_jarnwwaagxmnq.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UseEffectには拡張モードがあります。これは、useEffectに渡された関数が他の関数を返す場合であり、この関数は、次のサイクルでこのuseEffectが適用されるときに呼び出されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変更をDOMに適用した直後、useEffectは非同期に呼び出されました。つまり、コンポーネントがレンダリングされた後に実行されることが保証され、一部の値が変更された場合に次のレンダリングにつながる可能性があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gl/yd/cj/glydcjxiui-c60mgjzhnfobsqcm.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、依存関係などの概念で初めて会います。一部のフック-useEffect、useCallback、useMemo-値の配列を2番目の引数として受け取ります。これにより、追跡する対象を指定できます。この配列の変更は、ある種の影響をもたらします。たとえば、ここでは、仮説的に、リストから著者を選択するための何らかのコンポーネントがあります。そして、この著者による本が入ったプレート。そして、作成者が変更されると、useEffectが呼び出されます。このauthorIdが変更されると、リクエストが呼び出され、書籍が読み込まれます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、useRefなどのフックを渡す際に言及します。これは、React.createRefの代替であり、useStateに似ていますが、refへの変更はレンダリングにつながりません。いくつかのハックには時々便利です。 useImperativeHandleを使用すると、コンポーネントで特定の「パブリックメソッド」を宣言できます。親コンポーネントでuseRefを使用すると、これらのメソッドをプルできます。正直なところ、教育目的で一度試してみましたが、実際には役に立ちませんでした。 useContextは本当に良いことです。プロバイダーが階層レベルのどこかでこの値を定義している場合、コンテキストから現在の値を取得できます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フックでReactアプリケーションを最適化する方法の1つは、メモ化です。メモ化は、内部と外部に分けることができます。まず外側について。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ao/wq/-e/aowq-evnbye1bnr6lspo9sthw9y.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、React.PureComponentクラスの実質的な代替であるReact.memoです。これは、小道具または状態が変更されたときにのみ、小道具および変更されたコンポーネントの変更を追跡しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状態はありませんが、ここでは似ています。また、小道具の変更を監視し、小道具が変更された場合、レンダラーが発生します。小道具が変更されていない場合、コンポーネントは更新されないため、これを保存します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lk/0l/dn/lk0ldneyzriaeesmzxfnvvkl1h4.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部最適化の方法。まず第一に、これはかなり低レベルなものです-useMemo、めったに使用されません。これにより、いくつかの値を計算し、依存関係で指定された値が変更された場合にのみ再計算できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ve/fs/ml/vefsmlmbjqbg6-1lejt5_qofoow.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
useCallbackという関数には、useMemoの特別なケースがあります。これは主に、子コンポーネントに渡されるイベントハンドラー関数の値をメモして、子コンポーネントを再度レンダリングできないようにするために使用されます。単純に使用されます。特定の関数を記述し、それをuseCallbackでラップし、どの変数が依存しているかを示します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの人が質問をしますが、私たちはそれを必要としますか？フックは必要ですか？以前と同じように移動したり、とどまったりしますか？単一の答えはありません、それはすべて好みに依存します。まず、オブジェクト指向プログラミングに直接固執している場合、コンポーネントにクラスに慣れている場合は、プルできるメソッドがあり、おそらくこれは不必要に思えるかもしれません。原則として、フックについて最初に聞いたとき、どういうわけか複雑すぎて、何らかの魔法が追加されていて、その理由は明らかではなかったように思えました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フックは関数であり、関数型プログラミング技法がそれらに適用できるため、機能性愛好家にとって、これは、たとえば、持っている必要があります。例えば、それらは、例えば、Ramdaなどのライブラリーを使用して、組み合わせるか、または一般的に何でも行うことができる。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/du/k4/n7/duk4n7l_1_are_xjgrkf4vvbccy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスを削除したので、このコンテキストをメソッドにバインドする必要がなくなりました。これらのメソッドをコールバックとして使用する場合。通常、これは問題でした。コンストラクタでそれらをバインドするか、プロパティのような矢印関数など、言語構文の非公式な拡張機能を使用することを忘れないようにする必要があったからです。かなり一般的な習慣。私はデコレータを使用しましたが、これも原則として実験的にメソッドに使用されています。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/pn/ew/fi/pnewfifb1wwktxkbddh1zqqk-os.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライフサイクルのしくみ、管理方法には違いがあります。フックは、ほぼすべてのライフサイクルアクションをuseEffectフックに関連付けます。これにより、コンポーネントの生成と更新、およびその死の両方をサブスクライブできます。クラスでは、このために、componentDidMount、componentDidUpdate、componentWillUnmountなどのいくつかのメソッドを再定義する必要がありました。また、shouldComponentUpdateメソッドをReact.memoに置き換えることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7d/ae/qy/7daeqyxv0yh0on4i1wcdsraoaws.jpeg"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状態の処理方法にはかなり小さな違いがあります。まず、クラスには1つの状態オブジェクトがあります。私たちはそこに何でも詰め込まなければなりませんでした。フックでは、論理状態をいくつかの部分に分割できます。これは、個別に操作するのに便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状態パッチを指定できるクラスのコンポーネントのsetState（）により、状態の1つ以上のフィールドを変更します。フックでは、全体として状態全体を変更する必要があります。これは、あらゆる種類の不変のものを使用し、オブジェクトが変化することを決して期待しないことがファッショナブルであるためです。彼らは私たちにとって常に新しいものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フックにないクラスの主な機能：状態の変更をサブスクライブできます。つまり、状態を変更し、すぐにその変更をサブスクライブし、変更が適用された直後に何かを強制的に処理します。フックでは、これは機能しません。これは非常に興味深い方法で行う必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、更新の機能的な方法について少し。状態変更関数が別の関数を受け入れる場合、この状態は変更されずに作成されるので、あちらこちらで機能します。また、クラスコンポーネントの場合に何らかのパッチを返すことができる場合は、フックで新しい値全体を返す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、移動するかどうかにかかわらず、回答を得ることはほとんどありません。しかし、少なくとも新しいコードについては、それを感じるように試みることをお勧めします。フックを使い始めたばかりの頃、自分のプロジェクトに便利なカスタムフックがいくつか見つかりました。基本的に、私は高次コンポーネントを介して実装した機能の一部を置き換えようとしました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d6/cs/1-/d6cs1-ebiop8wbrdgnrr93wskqm.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
useDismount-RxJSに精通している場合は、1つのコンポーネント内または1つの関数内で、各Observableを特別なオブジェクトSubjectにサブスクライブすることにより、すべてのObservableを大量にサブスクライブ解除する可能性があります。これは、コンポーネントが複雑な場合に非常に便利です。Observable内に多くの非同期操作がある場合、個別にではなく、一度にすべてサブスクライブ解除するのが便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
useObservableは、Observableから新しい値が出現したときに、Observableから値を返します。同様のuseBehaviourSubjectフックがBehaviourSubjectから返されます。 Observableとの違いは、最初はいくつかの意味があるということです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
便利なカスタムフックuseDebouncedValueを使用すると、たとえば検索文字列の候補を整理できるため、キーを押すたびにサーバーに何かを送信するのではなく、ユーザーが入力を完了するまで待機できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの類似したフック。 useWindowResizeは、ウィンドウサイズの現在の実際の値を返します。スクロール位置の次のフックはuseWindowScrollです。 CSSで実行できない複雑な処理がある場合は、ポップアップまたはモーダルウィンドウを再集計するために使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ホットキーを実装するためのこのような小さなフックは、コンポーネントがページに存在する場合、いくつかのホットキーにサブスクライブされます。彼が死亡すると、自動的に登録解除が行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのカスタムフックは何に便利ですか？フック内で登録解除を詰め込むことができ、このフックが使用されているコンポーネントのどこかで手動で登録解除することを考える必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少し前までに、反応使用ライブラリへのリンクが表示されましたが、これらのカスタムフックのほとんどがすでにそこに実装されていることがわかりました。そして私は自転車を書きました。これは時々役に立ちますが、将来的にはおそらくそれらを捨てて、react-useを使用するでしょう。また、フックを使用するかどうかも確認することをお勧めします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/03/ls/_r/03ls_rryjcv9gax_wky56kv0hye.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、レポートの主な目的は、誤った記述方法、問題の種類、およびそれらを回避する方法を示すことです。最初のこと、おそらくこれらのフックを研究して何かを書こうとしている人は、useEffectを誤って使用することです。これは、100％全員がフックを試した場合に記述したのと同様のコードです。これは、useEffectが当初、componentDidMountの代わりとして精神的に認識されているためです。ただし、1回だけ呼び出されるcomponentDidMountとは異なり、useEffectはすべてのレンダリングで呼び出されます。ここでのエラーは、たとえばデータ変数が変更され、同時に変更されるとコンポーネントレンダラーにつながり、その結果、効果が再要求されることです。したがって、サーバーに無限の一連のAJAXリクエストが送信され、コンポーネント自体が常に更新、更新、更新されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ds/jw/cl/dsjwclnhk6kvmnmkxjw04vdrqd8.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
修正は非常に簡単です。依存する依存関係の空の配列を追加する必要があり、変更を加えると効果が再開されます。ここで指定された依存関係の空のリストがある場合、それに応じて効果は再開されません。これは一種のハックではなく、useEffectを使用する基本的な機能です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tx/bw/it/txbwitnnldk_y5r-bf0f4pss7eg.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
修正したとしましょう。少し複雑になりました。サーバーから何らかのIDを取得するために必要なものをレンダリングするコンポーネントがあります。この場合、原則として、親のentityIdを変更するまですべてが正常に機能します。おそらくこれはコンポーネントには関係ありません。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/2e/pl/tx/2epltxjdup5yia7c6gsepl-o7xo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、ほとんどの場合、変更するか、変更する必要があり、ページに古いコンポーネントがあり、更新されていないことが判明した場合は、ここにentityIdを依存関係として追加し、更新を引き起こして、データを更新することをお勧めします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rd/lc/ep/rdlcepf4e8lzq8ersyffn8ydqgs.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
useCallbackを使用したより複雑な例。ここでは、一見、すべてが順調です。ある種のカウントダウンタイマー、または逆にティックするタイマーがあるページがあります。そして、たとえば、ホストのリスト、およびこのホストのリストをフィルタリングするためのトップフィルター。まあ、レンダラーに変換される頻繁に変化する値を示すために、ここにメンテナンスが追加されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、問題は、フィルターがonChangeをサブスクライブするため、メンテナンス内の変更がフィルターオブジェクトを含むレンダラーにつながることです。そこでは、レンダリングごとに毎回新しくなるonChange関数を渡します。したがって、たとえばHostFiltersがなんらかの理由で複雑である場合、この例では、データが内部にロードされる一連のドロップダウンです。また、再度レンダリングすると、パフォーマンスが低下する可能性があります。遅れ、またはもう一度、無限の一連の要求があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bb/08/q1/bb08q1gwb5jzadcu0-bl1w0xsy0.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、このonChangeをuseCallbackでラップする必要があります。この例では、何にも依存しないため、最後に空の配列を示します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が強調したいくつかのより多くの困難があります。彼らはおそらく私のものです。つまり、FacebookはReactの作成者としてこれらの困難を拒否します。彼らは、すべてが大丈夫で、すべてが大丈夫だと言っています。しかし、それでも、ある種の恥ずかしさや混乱が起こります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xw/lv/et/xwlvetymaukrlaxd7t5cctegg-8.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すぐに目を引くのは何ですか？これで機能コンポーネントができたので、これは単なるレンダリングではなく、ある種のロジックと、場合によってはすべての種類の関数の束が内部に示されます。これらのすべての関数とオブジェクトは、変更されたときに1回だけまたはほとんど使用されません。ただし、同時に、レンダリングごとに初期化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、ここでは黄色で強調表示されており、レンダリングのたびにメモリに読み込まれます。つまり、関数が作成され、必要がないため使用されません。そして、ガベージコレクターは、レンダリングするたびに、または必要に応じて、強制的にクリーンアップすることがわかっています。そして、おそらくこれがフックに関する私の主な不満であり、私はそれを根本的に解決する方法を知りません。たとえば、外部関数のようなレデューサーでのロジックの削除が非常に役立つ場合がある特定のハックがあり、状態を変更するためのロジックのほとんどをそこに置くことができます。でも、とにかく原則は決めていません。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まだそのような問題があり、とても緊張したり、イライラしたりします。たとえば、ある値のsetValueなど、ある種の値を変更する場合、この値の変更をフックで直接サブスクライブすることはできません。これは、前の2番目の引数でsetStateを使用した場合と同様です。 useEffectの依存関係の変更を通じて、なんとか宣言的にサブスクライブする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じuseEffectが他の何らかの影響を引き起こしたり、他のいくつかの変数を変更したりして、別のuseEffectを引き起こす可能性があります。そして、この相互接続されたuseEffectのチェーンを頭に入れるのは非常に難しく、デバッグするのが困難です。そして、バックボーンのような古いフレームワークでサインアップしなければならない状況をよく思い出します。たとえば、モデルクラス、コレクションクラスがあり、それらは常に異なるイベントをスローしてそれらの一部を変更します。そして、これらのイベントをサブスクライブし、それらを組み合わせて、よりグローバルな他のイベントをスローすることができます。それはすでに別の場所で別のイベントをトリガーします。そして、一般的に、イベント内で別のイベントをトリガーするイベントを取得しますが、キャッチすることも非常に困難です。そして、それはコンポーネントが変更されたようで、どの銀河が言う、それが引き起こす他の変化、それは明確ではありません。ここでも同じ問題が解決しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、そのような面白いものであり、主張すらされていませんが、発言です。ロジックをカスタムフックに入れるときに、このロジックを再利用したい場合があります。しかし、クラスの古いコンポーネントではフックをサポートしていないため、これを行うことはできません。私の場合、それはデータを駆動できるかなり複雑なコンポーネントでした。彼は見ていました、とても複雑なドロップダウンのように、彼は選ぶことができました。教室で長く書いてありました。私は自動的にuseWindowScroll、useWindowResizeフックを使用する別のドロップダウンのポップアップを作成し、画面の高さに応じてサイズを数え直したので、非常に便利です。私はこのコンポーネントに同じロジックを使用したかったのですが、これはクラスでは難しいので、うまくいきませんでした。書き直さなければなりませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、コンポーネントを毎回書き直す必要があるため、特定の複雑さなどが発生します。書き直しには技術的な負債を払っていますが、一方で食料品の機能を扱いたいのですが、空から空に移行する必要があります。しかし、おそらく、これはかなりプラスです。これにより、よりクリーンでより統一されたコードが得られ、古いコードを新しいコードに移植する必要が高まるからです。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/-r/tu/f_/-rtuf_bbscg5l9i4-oaeh-xpu80.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まだ時間があり、フックに関連する小さな「ボーナス」セクションがあります。私は、Yandexの多くの人と同様に、TypeScriptで記述し、強い型付けを使用しています。レデューサーの使用には明確な問題があります。 Reduxのレデューサーは、アクションオブジェクトを取得するときです。そのため、このアクションの構造は、アクションのタイプによって完全に異なる場合があります。また、オートコンプリートやその他の静的型付けバンズを機能させることは非常に困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は次の方法を見つけました。まず、すべてのタイプのアクションを持つすべての列挙を宣言します。それを非常に単純にすることができ、それは単純に数値になります。IncrementAは0、次に1、2というようになります。デバッグの便宜上、これらを文字列として指定できます。当然、それらは交差すべきではありませんが、原則として、コンパイラーは同じ行を作成させません。次に、アクションのタイプごとに、このアクションの構造を説明します。いくつかのフィールドでアクションを展開し、タイプを必ず示します。次に、そこに追加されたすべてのデータ型、アクションが何であるかを縦棒でリストするUnionType「アクション」を作成します。これが最初のトリックです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のトリックは、値に基づいてタイプを計算することです。たとえば、initialStateは単なるオブジェクトです。そして理論的には、このオブジェクトの構造を他のインターフェースで記述する必要があります。ただし、このタスクをTypeScriptにシフトできます。彼は値を計算する方法を知っています。たとえば、ここでは、initialStateから計算された読み取り専用のtypeStateを定義しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_i/fg/79/_ifg793-qpfaiwittpdhffve_zw.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、これらのタイプはレデューサーで簡単に使用できます。 State、Actionを渡すと、魔法が起こります。action.typeによってスイッチを使用します。 TypeScriptには、UnionTypeを使用する場合にこのような機能があります。これらの型が、あるフィールドの値（ここではケース型）で異なる場合、ケース内の有効な型を計算できます。そして、必要なタイプのこのアクションのフィールドにアクセスする機会を得ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然、これは便利です。まず、タイプの検証、オートコンプリートプロンプトなどです。そしてリファクタリング。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/6r/8v/or/6r8vordbm6xpl9og288kzvrgewk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それをどのように適用しますか？原則として、使用上大きな違いはありません。小さな計算機を使った前の例がありました。ここでは、レデューサーを介してのみ同じことを行います。より正確には、必要なタイプでアクションクリエーターを定義し、それらをディスパッチに送信します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/tg/aw/vgtgawewmkwgpr5su4c24n7hgo8.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、公式の事後対応型開発ツールの拡張機能の使用を促進したいと考えています。彼らはフックのサポートを追加し、フックのツリー全体を表示することをとてもクールにしています。カスタムに特に役立ちます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
右側は例、彼がそれをどのように見せるかのスクリーンショットです。これは小さなコンポーネントで、フックの単純なツリーがありますが、より複雑なツリーがあります。カスタムフックでこのDev Toolに署名を追加できるように、これに必要な特別なuseDebugValueフックが必要です。この場合は、useConstantsフックがあり、その中に、ある種のラベル、loadedを定義できます。これは、辞書などの定数がサーバーから読み込まれたかどうかを決定します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rt/cc/sg/rtccsggw9kekwpt75gmvnwd_w2u.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論として、いくつかの結論。まず第一に、フックは非常に大きな機会を与えます。大きな可能性には責任が伴いますので、注意して使用することをお勧めします。それらがどのように機能するか、特に値をどのようにメモするかを十分に理解する必要があります。メモ化を行わない場合は最適化され、ここでは非常にハードに撮影できます。不適切にメモした場合、不適切な値が保存されたり、その逆の場合もあり、再レンダリングされる頻度が高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非常に重要な推奨事項。 FacebookにはESLint用の特別なプラグインがあり、リストされている問題のほとんどを回避できます。フックの適切な使用を追跡し、何よりも役立ちます。フックの依存関係を設定するためのオプションも提供します。彼自身がそれらを処方することができ、これは非常に便利です。リンターが誓うことに常に注意を払う必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一連の関数を使用しているので、それらをメモしてください。特に階層のより低いレベルで、値が内部でロックされる状況に遭遇する可能性があります。そしてここでは、クロージャーとは何か、それらがどのように機能するか、関数が自由変数を処理する方法などを明確に理解する必要があります。この知識がないと、フックを使用しない方がよいでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、フックを使用してコンポーネントを作成するアプローチには、おそらく何らかの哲学が定められています。</font><font style="vertical-align: inherit;">それは人々がパラダイムを通して考えたことを明確に感じ、そしてそれは理解されなければならない。</font><font style="vertical-align: inherit;">そして、これは経験だけであるので、いくつかの結論を導き、徐々にそれらに慣れる必要があります。</font><font style="vertical-align: inherit;">おそらく将来的には、Zenを学び、フックにすでに非常に効率的なクールなコードを書くことができます。</font><font style="vertical-align: inherit;">しかし、これまでのところそれほど単純ではありません。</font><font style="vertical-align: inherit;">役立つリンク：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reactフック-勝利か敗北か？</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事は私の報告に非常によく似ています。</font><font style="vertical-align: inherit;">レポートの準備ができてから知りましたが、私の考えが私のものと一致しているという理由だけで追加しました。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">useEffectの完全なガイド</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">翻訳された記事も、Habréで、棚のすぐ上に配置されています。それがどのように機能するか、どのように使用するか、どのように間違いをしないかなどです。</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">«useReducer vs useState in React»</a> ,    useReducer,      useState. :     ,  ,    ,    useReducer.    - ,   useState   .</li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">React Hooks CheatSheets</a> c      .</li>
<li>  . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Usehooks.com</a> —   , .     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">react-use</a> — ,       ,     .</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja464045/index.html">1997年のほぼリアルタイムのレーストレイル</a></li>
<li><a href="../ja464053/index.html">注意：トラックの選択と回転アルゴリズム</a></li>
<li><a href="../ja464055/index.html">Xiaomi Mi Bandが年間に収集したデータを調査します</a></li>
<li><a href="../ja464057/index.html">ヒルベルト、ルベーグ...そしてボイド</a></li>
<li><a href="../ja464063/index.html">2019年にケーブルを切断する</a></li>
<li><a href="../ja464075/index.html">Cの紹介 前世紀からのメッセージ</a></li>
<li><a href="../ja464077/index.html">いいえ、50 km / sのデルタveは必要ありません。付加技術が必要（パート1）</a></li>
<li><a href="../ja464079/index.html">ミラクルテクノロジーなしで水平離着陸宇宙船を作る方法</a></li>
<li><a href="../ja464083/index.html">ITSMがどのように役立ち、誰がこの方法論を適用するか</a></li>
<li><a href="../ja464089/index.html">SpringのコンテキストでのHTTPリクエストの自動化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>