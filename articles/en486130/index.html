<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥨 🌸 👨🏻‍🔬 GSoC 2019: Checking Bipartite Counts and Monad Transformers 👨🏻‍🎤 🧔🏾 💸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last summer, I participated in Google Summer of Code , Google’s student program. Every year, organizers select several Open Source projects, including...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>GSoC 2019: Checking Bipartite Counts and Monad Transformers</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/486130/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Last summer, I participated in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Summer of Code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Google’s student program. Every year, organizers select several Open Source projects, including from such well-known organizations as </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boost.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Linux Foundation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Google invites students from all over the world to work on these projects.&nbsp; </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a Google Summer of Code 2019 participant, I did a project in the framework of the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alga</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">with the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haskell.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> organization </font><font style="vertical-align: inherit;">, which develops the Haskell language, one of the most famous functional programming languages. Alga is a library representing a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type-safe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> representation for graphs in Haskell. It is used, for example, in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semantic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- The Github library, which builds semantic trees by code, graphs of calls and dependencies, and knows how to compare them. </font><font style="vertical-align: inherit;">My project was to add there a type-safe representation for bipartite graphs and algorithms for this representation.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In a post I will talk about my implementation of the algorithm for checking a graph for bipartite on Haskell. </font><font style="vertical-align: inherit;">Despite the fact that the algorithm is one of the most basic, its beautiful implementation in a functional style took me several iterations and required a lot of work. </font><font style="vertical-align: inherit;">As a result, I settled on the implementation with monad transformers.&nbsp;</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ou/tb/pj/outbpjiwfptbq5wsjnzzn4wbh3o.png"><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About myself</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My name is Vasily Alferov, I am a fourth-year student at the St. Petersburg HSE. </font><font style="vertical-align: inherit;">Earlier in the blog, I wrote </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">about my project about parameterized algorithms</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">about a trip to ZuriHac</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Right now I am on an internship at </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the University of Bergen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Norway, where I deal with the approaches to the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List Coloring</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> task </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">My interests include parameterized algorithms and functional programming.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About the implementation of the algorithm</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foreword</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Students participating in the program are strongly encouraged to blog. </font><font style="vertical-align: inherit;">I was provided with the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summer of Haskell</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> site for the blog </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This article is a translation of an </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I wrote there in July in English, with a short introduction.&nbsp;</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pull Request with the code in question can be found </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can read about the results of my work (in English) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The post assumes that the reader is familiar with the basic concepts in functional programming, although I will try to recall all the terms used when they reach the point.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Checking graphs for bipartite&nbsp;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A bipartite graph check algorithm is usually given in the course of algorithms as one of the simplest graph algorithms. His idea is straightforward: first, we somehow put the vertices in the left or right lobe, and when a conflicting edge is detected, we claim that the graph is not bipartite. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A little more: first we put some kind of top in the left lobe. Obviously, all the neighbors of this peak should lie in the right lobe. Further, all the neighbors of the neighbors of this peak should lie in the left lobe, and so on. We continue to assign shares to the vertices until there are still vertices in the connected component of the vertex with which we started that we have not assigned neighbors to. Then we repeat this action for all connected components.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If there is an edge between the vertices that fall into the same share, it is easy to find an odd cycle in the graph, as is widely known (and quite obvious) impossible in a bipartite graph. Otherwise, we have the correct division into parts, which means that the graph is bipartite. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typically, this algorithm is implemented using </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a breadth</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -first </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">search</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">depth-deep search</font></a><font style="vertical-align: inherit;"> . Imperative languages ​​usually use deep search, as a little more simple and not requiring additional data structures. I also chose a deep search as more traditional.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, we have arrived at the following scheme. </font><font style="vertical-align: inherit;">We go around the vertices of the graph by searching in depth and assign them shares, changing the number of the shares when moving along the edge. </font><font style="vertical-align: inherit;">If we try to assign a share to a vertex for which a share has already been assigned, we can safely say that the graph is not bipartite. </font><font style="vertical-align: inherit;">At the moment when all the vertices are assigned a share and we looked at all the edges, we have a good split.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clean Computing</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At Haskell, we assume that all calculations are </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clean.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> However, if this were indeed the case, we would not be able to print anything onto the screen. In general, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pure</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> computing is so lazy that there is not a single </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pure</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reason to calculate anything. All calculations occurring in the program are forced in one way or another in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“unclean”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IO monad. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Monads are a way of representing calculations with </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effects</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Haskell. An explanation of how they work is beyond the scope of this post. A good and clear description can be read in English </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here I want to note that while some monads, such as IO, are implemented through the magic of the compiler, almost all the others are implemented programmatically and all calculations in them are clean. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are a lot of effects and each one has its own monad. </font><font style="vertical-align: inherit;">This is a very strong and beautiful theory: all monads implement the same interface. </font><font style="vertical-align: inherit;">We will talk about the following three monads:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Either ea is a calculation returning a value of type a or throwing an exception of type e. </font><font style="vertical-align: inherit;">The behavior of this monad is very similar to working with exceptions in imperative languages: errors can be caught or passed on. </font><font style="vertical-align: inherit;">The main difference is that the monad is completely logically implemented in a standard library in the same Haskell, while imperative languages ​​usually use operating system mechanisms.</font></font><br>
</li>
<li>State s a — ,    a        s.<br>
</li>
<li>Maybe a.  Maybe  ,         Nothing.        MonadPlus   Maybe,   :  ,          .<br>
</li>
</ul><br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have two types of data, Graph a and Bigraph ab, the first of which represents graphs with vertices labeled with values ​​of type a, and the second represents bipartite graphs with vertices of the left side labeled with values ​​of a type and vertices of the right part labeled with values ​​of type b. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These are not types from the Alga library. Alga has no representation for undirected bipartite graphs. Types I made so for clarity. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will also need auxiliary functions with the following signatures:</font></font><br>
<br>
<pre><code class="haskell hljs"><span class="hljs-comment">--    .</span>
<span class="hljs-title">neighbours</span> :: <span class="hljs-type">Ord</span> a =&gt; a -&gt; <span class="hljs-type">Graph</span> a -&gt; [a]<font></font>
<font></font>
<span class="hljs-comment">--       ,   </span>
<span class="hljs-comment">--        ,   .</span>
<span class="hljs-title">toBipartiteWith</span> :: (<span class="hljs-type">Ord</span> a, <span class="hljs-type">Ord</span> b, <span class="hljs-type">Ord</span> c) =&gt; (a -&gt; <span class="hljs-type">Either</span> b c)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="hljs-type">Graph</span> a<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="hljs-type">Bigraph</span> b c<font></font>
<font></font>
<span class="hljs-comment">--    </span>
<span class="hljs-title">vertexList</span> :: <span class="hljs-type">Ord</span> a =&gt; <span class="hljs-type">Graph</span> a -&gt; [a]<font></font>
 ,    ,  :<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">OddCycle</span> a = [a]</span>
<span class="hljs-title">detectParts</span> :: <span class="hljs-type">Ord</span> a =&gt; <span class="hljs-type">Graph</span> a -&gt; <span class="hljs-type">Either</span> (<span class="hljs-type">OddCycle</span> a) (<span class="hljs-type">Bigraph</span> a a)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It’s easy to see that if we find a conflicting edge in the depth search, the odd loop lies on top of the recursion stack. </font><font style="vertical-align: inherit;">Thus, in order to restore it, we need to cut off everything from the recursion stack until the first occurrence of the last vertex. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We implement a depth search, maintaining an associative array of fraction numbers for each vertex. </font><font style="vertical-align: inherit;">The recursion stack will be automatically supported through the implementation of the Functor class of the selected monad: you only need to put all the vertices from the path into the result returned from the recursive function.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My first idea was to use the Either monad, which seems to implement just those effects that we need. </font><font style="vertical-align: inherit;">The first implementation I wrote was very close to this option. </font><font style="vertical-align: inherit;">In fact, I had five different implementations at some point, and I ended up focusing on another.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, we need to maintain an associative array of share identifiers - this is something about State. Secondly, we need to be able to stop in case of conflict. It can be either Monad for Either, or MonadPlus for Maybe. The main difference is that Either can return a value if the calculation was not stopped, and Maybe returns only information about it in this case. Since we do not need a separate value in case of success (it is already stored in State), we select Maybe. And at that moment when we need to combine the effects of two monads, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transformers of monads</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> come out </font><font style="vertical-align: inherit;">, which just combine these effects.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why did I choose such a complex type? </font><font style="vertical-align: inherit;">Two reasons. </font><font style="vertical-align: inherit;">First, the implementation is very similar to imperative. </font><font style="vertical-align: inherit;">Secondly, we need to manipulate the value returned in the event of a conflict when returning from recursion to restore an odd loop, and this is much easier to do in the Maybe monad. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, we get such an implementation.</font></font><br>
<br>
<pre><code class="haskell hljs"><span class="hljs-meta">{-# LANGUAGE ExplicitForAll #-}</span>
<span class="hljs-meta">{-# LANGUAGE ScopedTypeVariables #-}</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Part</span> = <span class="hljs-type">LeftPart</span> | <span class="hljs-type">RightPart</span></span><font></font>
<font></font>
<span class="hljs-title">otherPart</span> :: <span class="hljs-type">Part</span> -&gt; <span class="hljs-type">Part</span>
<span class="hljs-title">otherPart</span> <span class="hljs-type">LeftPart</span>&nbsp; = <span class="hljs-type">RightPart</span>
<span class="hljs-title">otherPart</span> <span class="hljs-type">RightPart</span> = <span class="hljs-type">LeftPart</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">PartMap</span> a = <span class="hljs-type">Map</span>.<span class="hljs-type">Map</span> a <span class="hljs-type">Part</span></span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">OddCycle</span> a = [a]</span><font></font>
<font></font>
<span class="hljs-title">toEither</span> :: <span class="hljs-type">Ord</span> a =&gt; <span class="hljs-type">PartMap</span> a -&gt; a -&gt; <span class="hljs-type">Either</span> a a
<span class="hljs-title">toEither</span> m v = <span class="hljs-keyword">case</span> fromJust (v `<span class="hljs-type">Map</span>.lookup` m) <span class="hljs-keyword">of</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">LeftPart</span>&nbsp; -&gt; <span class="hljs-type">Left</span>&nbsp; v
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">RightPart</span> -&gt; <span class="hljs-type">Right</span> v<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">PartMonad</span> a = <span class="hljs-type">MaybeT</span> (<span class="hljs-type">State</span> (<span class="hljs-type">PartMap</span> <span class="hljs-title">a</span>)) [a]</span><font></font>
<font></font>
<span class="hljs-title">detectParts</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">Ord</span> a =&gt; <span class="hljs-type">Graph</span> a -&gt; <span class="hljs-type">Either</span> (<span class="hljs-type">OddCycle</span> a) (<span class="hljs-type">Bigraph</span> a a)
<span class="hljs-title">detectParts</span> g = <span class="hljs-keyword">case</span> runState (runMaybeT dfs) <span class="hljs-type">Map</span>.empty <span class="hljs-keyword">of</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="hljs-type">Just</span> c, _)&nbsp; -&gt; <span class="hljs-type">Left</span>&nbsp; $ oddCycle c<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="hljs-type">Nothing</span>, m) -&gt; <span class="hljs-type">Right</span> $ toBipartiteWith (toEither m) g
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">where</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inVertex :: <span class="hljs-type">Part</span> -&gt; a -&gt; <span class="hljs-type">PartMonad</span> a<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inVertex p v = ((:) v) &lt;$&gt; <span class="hljs-keyword">do</span> modify $ <span class="hljs-type">Map</span>.insert v p
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span> q = otherPart p<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msum [ onEdge q u | u &lt;- neigbours v g ]<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-meta">{-# INLINE onEdge #-}</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onEdge :: <span class="hljs-type">Part</span> -&gt; a -&gt; <span class="hljs-type">PartMonad</span> a<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onEdge p v = <span class="hljs-keyword">do</span> m &lt;- get
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">case</span> v `<span class="hljs-type">Map</span>.lookup` m <span class="hljs-keyword">of</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">Nothing</span> -&gt; inVertex p v
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">Just</span> q&nbsp; -&gt; <span class="hljs-keyword">do</span> guard (q /= p)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return [v]<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processVertex :: a -&gt; <span class="hljs-type">PartMonad</span> a<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processVertex v = <span class="hljs-keyword">do</span> m &lt;- get<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guard (v `<span class="hljs-type">Map</span>.notMember` m)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inVertex <span class="hljs-type">LeftPart</span> v<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dfs :: <span class="hljs-type">PartMonad</span> a<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dfs = msum [ processVertex v | v &lt;- vertexList g ]<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oddCycle :: [a] -&gt; [a]<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oddCycle c = tail (dropWhile ((/=) last c) c)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The where block is the core of the algorithm. </font><font style="vertical-align: inherit;">I will try to explain what is happening inside him.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inVertex is part of the depth search, where we visit the top for the first time. </font><font style="vertical-align: inherit;">Here we assign the number of the vertex to the vertex and run onEdge for all neighbors. </font><font style="vertical-align: inherit;">This is also the place where we restore the call stack: if msum returned the value, we hang vertex v there.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onEdge is the part in which we visit the rib. </font><font style="vertical-align: inherit;">It is called twice for each edge. </font><font style="vertical-align: inherit;">Here we check if the peak has been visited on the other side, and visit it if not. </font><font style="vertical-align: inherit;">If visited, check if the edge is in conflict. </font><font style="vertical-align: inherit;">If it is, we return the value - the very top of the recursion stack, where then all the other vertices will be hung upon return.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">processVertex checks for each vertex whether it has been visited, and runs inVertex on it if not.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dfs runs processVertex on all vertices.</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's all.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The history of the word INLINE</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The word INLINE was not in the first implementation of the algorithm, it appeared later. When I tried to find a better implementation, I found that on some graphs the version without INLINE is noticeably slower. Considering that semantically functions should work the same way, it surprised me a lot. Even stranger, on another machine with a different version of GHC, there was no noticeable difference. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After spending a week reading the output of GHC Core, I was able to fix the problem with one line with explicit INLINE. At some point between the GHC 8.4.4 and the GHC 8.6.5, the optimizer stopped doing this on its own.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I did not expect to encounter such filth in Haskell programming. </font><font style="vertical-align: inherit;">However, optimizers still make mistakes sometimes even today, and giving them hints is our task. </font><font style="vertical-align: inherit;">For example, here we know that a function must be inlined, since it is inlined in the imperative version, and this is an occasion to give the compiler a hint.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What happened next?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then I implemented the Hopcroft-Karp algorithm with other monads, and the program ended on this. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thanks to the Google Summer of Code, I gained practical experience in functional programming, which not only helped me get an internship in Jane Street next summer (I'm not sure how much this place is known even among the knowledgeable audience of Habr, but it is one of the few where you can summer to engage in functional programming), but also introduced to the amazing world of applying this paradigm in practice, significantly different from my experience in traditional languages.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/en486130/">https://habr.com/ru/post/en486130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en486120/index.html">Normalization of deviance. How bad practices are becoming the norm in our industry</a></li>
<li><a href="../en486122/index.html">Child ReactJS with 135 lines of code</a></li>
<li><a href="../en486124/index.html">Impala vs Hive vs Spark SQL: Choosing the right SQL engine to work properly in the Cloudera Data Warehouse</a></li>
<li><a href="../en486126/index.html">Microservices with Spring Boot. Part 5. Using the Eureka name server</a></li>
<li><a href="../en486128/index.html">Quality Architect: who is it and when is it needed</a></li>
<li><a href="../en486136/index.html">Imitating network problems in Linux</a></li>
<li><a href="../en486138/index.html">“Do you have personal data?” And if I find it? ” Webinar on the localization of personal data in Russia - February 12, 2020</a></li>
<li><a href="../en486142/index.html">When code becomes legacy and how to live with it</a></li>
<li><a href="../en486144/index.html">Why do altcoins die and what can happen to cryptocurrency in the near future?</a></li>
<li><a href="../en486146/index.html">How to rewrite the front end of a loaded project and not lose the main thing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>