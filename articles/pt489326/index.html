<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐑 👩‍❤️‍💋‍👨 👨🏾 Reflexões sobre testes corporativos eficazes 🤸🏾 🥝 🤵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! 
 
 Recentemente, voltamos a um estudo aprofundado do tópico de teste e, nos planos previsíveis, temos até um excelente livro sobre Teste de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Reflexões sobre testes corporativos eficazes</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/489326/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Olá Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recentemente, voltamos a um estudo aprofundado do tópico de teste e, nos planos previsíveis, temos até um excelente livro sobre Teste de Unidade. </font><font style="vertical-align: inherit;">Ao mesmo tempo, acreditamos que o contexto é importante neste tópico e em nenhum outro lugar; portanto, hoje oferecemos uma tradução de duas publicações (combinadas em uma) publicadas no blog de um destacado especialista em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java EE,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sebastian Dashner - ou seja, 1/6 e 2/6 da série " Pensamentos sobre testes empresariais eficientes ".</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O teste corporativo é um tópico que ainda não foi examinado com tantos detalhes quanto gostaríamos. </font><font style="vertical-align: inherit;">Leva muito tempo e esforço para escrever e, especialmente, para suportar testes, no entanto, tentar economizar tempo abandonando os testes não é uma opção. </font><font style="vertical-align: inherit;">Quais volumes de tarefas, abordagens e tecnologias de teste valem a pena explorar para aumentar a eficácia dos testes?</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introdução</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Independentemente dos diferentes tipos de testes e de seu escopo, o objetivo de preparar um conjunto de testes é garantir neste material que, em produção, nosso aplicativo funcionará exatamente como o esperado. </font><font style="vertical-align: inherit;">Essa motivação deve ser a principal quando se verifica se o sistema cumpre a tarefa, se considerarmos esse sistema do ponto de vista do usuário. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como o tempo de atenção e a alternância de contexto são coisas a serem consideradas, devemos garantir que nossos testes não sejam executados e testados por um longo tempo e que os resultados sejam previsíveis. </font><font style="vertical-align: inherit;">Ao escrever um código, a verificação rápida do código (possível em um segundo) é crucial - isso garante alta produtividade e foco durante o trabalho.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por outro lado, devemos garantir o suporte ao teste. O software muda com muita frequência e, com uma cobertura substancial do código com testes funcionais, cada alteração funcional no código de produção exigirá uma alteração no nível do teste. Idealmente, o código de teste deve mudar apenas quando a funcionalidade, ou seja, lógica de negócios, mudar, e não ao limpar código e refatoração desnecessários. Em geral, os cenários de teste devem incluir a possibilidade de alterações estruturais não funcionais.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando consideramos as diferentes áreas de aplicação dos testes, surge a pergunta: quais dessas áreas valem tempo e esforço? </font><font style="vertical-align: inherit;">Por exemplo, em aplicativos de microsserviço, bem como em qualquer sistema que forneça trabalho significativo na distribuição e integração de código, os testes de integração são especialmente importantes, ajudando a tatear os limites do sistema. </font><font style="vertical-align: inherit;">Portanto, precisamos de uma maneira eficaz de testar todo o aplicativo como um todo durante o desenvolvimento local, mantendo o ambiente e a estrutura desse aplicativo na forma mais próxima possível da produção.</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Princípios e Limitações</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Independentemente das soluções que serão selecionadas, vamos definir os seguintes princípios e limitações para nosso conjunto de testes:</font></font><br>
<br>
<ul>
<li>     ,      .          ,           .    ,      ,       .</li>
<li>        ,   ,    .   ,     ,   ,    . ,       ,           .</li>
<li>     -       .    ,      ,        .</li>
<li>   ,      ,         . : «     HTTP-  gRPC,   JSON  -      enterprise-, ..?”.</li>
<li>           ,     ,   -.        API,   DSL    .</li>
<li>    « »,  ,    ,          , , ,  “dev”  debug ()  ,  dev  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quarkus'</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Telepresence</a>,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">watch-and-deploy</a> («  »)  .</li>
<li>              .  ,             , ,    ,          .                .</li>
<li>        , ,   -,        ,  ,         .     ,          , ,       .</li>
</ul><br>
<h4> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O teste de unidade verifica o comportamento de um único módulo, geralmente uma classe, enquanto todos os fatores externos que não estão relacionados à estrutura do módulo são ignorados ou simulados. Os testes de unidade devem verificar a lógica de negócios dos módulos individuais, sem verificar sua integração ou configuração. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na minha experiência, a maioria dos desenvolvedores corporativos tem uma boa idéia de como os testes de unidade são compilados. Para impressionar, você pode ver este exemplo no meu projeto de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">teste de café</font></a><font style="vertical-align: inherit;"> .</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Na maioria dos projetos, o JUnit é usado em combinação com o Mockito para simular dependências e, idealmente, com o AssertJ para definir com eficiência instruções legíveis. Eu sempre enfatizo que os testes de unidade podem ser executados sem extensões ou entradas especiais, ou seja, para fazer isso com o JUnit usual. A explicação é simples: é tudo sobre tempo de execução, porque precisamos da capacidade de executar centenas de testes em questão de milissegundos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como regra, os testes de unidade são executados com muita rapidez e é fácil montar conjuntos de testes complexos ou fluxos de trabalho especiais a partir deles, pois são simples de executar e não impõem restrições ao ciclo de vida do teste.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, quando você tem muitos testes de unidade simulando as dependências da classe testada, há uma desvantagem: eles estão intimamente relacionados à implementação (isso se aplica especialmente a classes e métodos), e é por isso que nosso código é difícil de refatorar. Em outras palavras, para cada ato de refatoração no código de produção, ele também requer alterações no código de teste. Na pior das hipóteses, os desenvolvedores começam a recusar parcialmente a refatoração, simplesmente porque é muito onerosa e a qualidade do código no projeto está diminuindo rapidamente. Idealmente, o desenvolvedor deve poder refatorar e reorganizar os elementos, desde que, por isso, não haja alterações no aplicativo que sejam perceptíveis para o usuário. Os testes de unidade nunca simplificam sempre o código de produção da refatoração.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas a experiência sugere que os testes de unidade são muito eficazes na verificação de códigos densamente preenchidos com lógica concisa ou descrevem a implementação de uma função específica, por exemplo, um algoritmo e, ao mesmo tempo, não interagem muito ativamente com outros componentes. Quanto menos complexo ou denso o código em uma classe específica, menor a sua complexidade ciclomática ou mais ele interage ativamente com outros componentes, menos testes de unidade eficazes serão ao testar essa classe. Especialmente nos casos com microsserviços, nos quais comparativamente pouca lógica de negócios está incluída, mas é fornecida uma ampla integração com sistemas externos, talvez haja pouca necessidade de usar testes de unidade em muitos. Em tais sistemas, os módulos individuais (com raras exceções) geralmente contêm pouca lógica especializada. Isso deve ser considerado ao decidiro que é mais apropriado para gastar tempo e esforço.</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testando situações de aplicativo</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para lidar com o problema de vincular fortemente os testes à implementação, você pode tentar uma abordagem ligeiramente diferente para expandir o escopo dos testes. </font><font style="vertical-align: inherit;">No meu livro, escrevi sobre testes de componentes, porque não consegui encontrar um termo melhor; </font><font style="vertical-align: inherit;">mas, em essência, neste caso, estamos falando sobre o teste de situações aplicadas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Testes de situação de aplicativo são testes de integração que operam no nível do código, que não usam contêineres internos - eles são abandonados para acelerar o lançamento. </font><font style="vertical-align: inherit;">Eles testam a lógica de negócios de componentes bem coordenados, que geralmente são usados ​​em um caso prático específico, desde o método de limite - e depois até todos os componentes associados a eles. </font><font style="vertical-align: inherit;">A integração com sistemas externos, por exemplo, com bancos de dados, é imitada usando zombarias.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Construir esses cenários sem o uso de tecnologias mais avançadas que conectariam componentes automaticamente parece um grande trabalho. No entanto, definimos componentes de teste reutilizáveis, eles também são contrapartes de teste que estendem componentes simulando, conectando e adicionando configurações de teste; tudo isso é feito para minimizar a quantidade total de esforço necessária para a refatoração. O objetivo é criar as únicas responsabilidades que limitam o grau de influência das alterações em uma única classe (ou várias classes) no campo de teste. Realizando esse trabalho com o objetivo de reutilizá-lo, reduzimos a quantidade total de trabalho necessário, e essa estratégia é justificada quando o projeto cresce, mas cada componente requer apenas pequenos reparos e esse trabalho é rapidamente amortizado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para melhor imaginar tudo isso, suponha que estamos testando uma classe que descreve a ordem do café. Esta classe inclui duas outras classes: </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>OrderProcessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gp/xj/tb/gpxjtb-txbhrd0hzssooxzh1lw0.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Classes de duplas de teste, </font></font><code>CoffeeShopTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>OrderProcessorTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eles </font></font><code>*TD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estão localizados na área de teste do projeto, onde eles herdam os componentes </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>OrderProcessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">localizado na área principal do programa. Os colegas de teste podem definir a lógica de simulação e conexão necessária e potencialmente expandir a interface pública da classe usando os métodos de simulação necessários neste aplicativo ou métodos de verificação. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A seguir, mostra a classe dupla de teste para o componente </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeShopTestDouble</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CoffeeShop</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CoffeeShopTestDouble</span><span class="hljs-params">(OrderProcessorTestDouble orderProcessorTestDouble)</span> </span>{<font></font>
        entityManager = mock(EntityManager.class);<font></font>
        orderProcessor = orderProcessorTestDouble;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyCreateOrder</span><span class="hljs-params">(Order order)</span> </span>{<font></font>
        verify(entityManager).merge(order);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyProcessUnfinishedOrders</span><span class="hljs-params">()</span> </span>{<font></font>
        verify(entityManager).createNamedQuery(Order.FIND_UNFINISHED, Order.class);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">answerForUnfinishedOrders</span><span class="hljs-params">(List&lt;Order&gt; orders)</span> </span>{
        <span class="hljs-comment">//     </span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A classe dupla de teste pode acessar os campos e construtores da classe base do CoffeeShop para estabelecer dependências. Aqui, na forma de gêmeos de teste, também são usadas variantes de outros componentes, em particular, </font></font><code> OrderProcessorTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elas são necessárias para chamar métodos adicionais de simulação ou verificação, que fazem parte do caso prático. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Classes de teste duplo são componentes reutilizáveis, cada um dos quais é escrito uma vez por escopo de cada projeto e, em seguida, é usado em muitos casos práticos:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeShopTest</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">private</span> CoffeeShopTestDouble coffeeShop;
    <span class="hljs-keyword">private</span> OrderProcessorTestDouble orderProcessor;<font></font>
<font></font>
    <span class="hljs-meta">@BeforeEach</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{<font></font>
        orderProcessor = <span class="hljs-keyword">new</span> OrderProcessorTestDouble();<font></font>
        coffeeShop = <span class="hljs-keyword">new</span> CoffeeShopTestDouble(orderProcessor);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testCreateOrder</span><span class="hljs-params">()</span> </span>{<font></font>
        Order order = <span class="hljs-keyword">new</span> Order();<font></font>
        coffeeShop.createOrder(order);<font></font>
        coffeeShop.verifyCreateOrder(order);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testProcessUnfinishedOrders</span><span class="hljs-params">()</span> </span>{<font></font>
        List&lt;Order&gt; orders = Arrays.asList(...);<font></font>
        coffeeShop.answerForUnfinishedOrders(orders);<font></font>
<font></font>
        coffeeShop.processUnfinishedOrders();<font></font>
<font></font>
        coffeeShop.verifyProcessUnfinishedOrders();<font></font>
        orderProcessor.verifyProcessOrders(orders);<font></font>
    }<font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O teste de componente verifica o caso específico da lógica de negócios que é chamada no ponto de entrada, neste caso </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esses testes são obtidos de forma concisa e legível, uma vez que todas as conexões e simulações são realizadas em gêmeos de teste separados e, posteriormente, eles podem usar técnicas de triagem altamente especializadas, como </font></font><code>verifyProcessOrders()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você pode ver, a classe de teste expande o escopo da classe de produção, permitindo instalar o mokee e usar métodos que verificam o comportamento. Apesar de parecer que a instalação de um sistema desse tipo exige muito esforço, esses custos são rapidamente amortizados se, no âmbito de todo o projeto, tivermos muitos casos práticos em que os componentes podem ser reutilizados. Quanto mais nosso projeto cresce, mais útil essa abordagem se torna - especialmente se você prestar atenção ao tempo necessário para concluir os testes. Todos os nossos casos de teste ainda são executados usando JUnit e, no menor tempo possível, são executados em centenas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse é o principal benefício dessa abordagem: os testes de componentes são executados tão rapidamente quanto os testes de unidade regulares, no entanto, estimulam a refatoração do código de produção, pois é necessário fazer alterações em um único componente ou em apenas alguns componentes. </font><font style="vertical-align: inherit;">Além disso, melhorando as contrapartes de teste com métodos expressivos de ajuste e verificação específicos para nossa área de assunto, aumentamos a legibilidade de nosso código, facilitamos seu uso e nos livramos do código estereotipado nos scripts de teste.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt489298/index.html">Entrevista informal com Maria Dolgusheva (RH do Vale do Silício)</a></li>
<li><a href="../pt489302/index.html">Edição nº 31: Treinamento em TI - problemas e desafios atuais das principais empresas</a></li>
<li><a href="../pt489304/index.html">Análise de dados ChIP-seq: das histonas às tarefas do computador</a></li>
<li><a href="../pt489306/index.html">[Habr]: Rosquinhas</a></li>
<li><a href="../pt489310/index.html">Top 10: os melhores relatórios de Heisenbug 2019 Moscou</a></li>
<li><a href="../pt489328/index.html">Nulo se esgueirou: quebrando a opção Scala usando Java</a></li>
<li><a href="../pt489332/index.html">Assistentes essenciais na inteligência do serviço de inteligência mais eficaz do mundo (parte 3)</a></li>
<li><a href="../pt489336/index.html">Interface Bikes Toxic Grandfather. “Aprenda, estude e estude novamente” (s1 e3)</a></li>
<li><a href="../pt489340/index.html">Como a unidade máxima de transmissão de informações na Internet se tornou 1500 bytes</a></li>
<li><a href="../pt489342/index.html">Criação de infraestrutura de TI tolerante a falhas. Parte 4. Implantando switches Cisco 3850 para roteamento de gateway</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>