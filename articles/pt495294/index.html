<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵 👨🏼‍🏭 ♦️ Macros para um pythonist. Relatório Yandex 🆗 ✍🏼 🌡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como posso estender a sintaxe do Python e adicionar os recursos necessários? No verão passado, na PyCon, tentei entender esse tópico. No relatório, vo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Macros para um pythonist. Relatório Yandex</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/495294/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como posso estender a sintaxe do Python e adicionar os recursos necessários? </font><font style="vertical-align: inherit;">No verão passado, na PyCon, tentei entender esse tópico. </font><font style="vertical-align: inherit;">No relatório, você pode descobrir como as bibliotecas pytest, macropy e padrões são organizadas e como elas alcançam resultados tão interessantes. </font><font style="vertical-align: inherit;">No final, há um exemplo de geração de código usando macros no HyLang, uma linguagem semelhante ao Lisp executando no Python.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/IMkvg45Vw70" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
- Oi pessoal. </font><font style="vertical-align: inherit;">Antes de tudo, quero agradecer aos organizadores da PyCon. </font><font style="vertical-align: inherit;">Sou desenvolvedor da Yandex. </font><font style="vertical-align: inherit;">O relatório não será sobre trabalho, mas sobre coisas experimentais. </font><font style="vertical-align: inherit;">Talvez eles levem um de vocês à idéia de que, em Python, você pode fazer coisas legais que você nem sabia antes, que não pensavam nessa direção.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um pouco para quem não está ciente do que são macros: esse é um método de geração de código quando alguma expressão na linguagem é expandida para um código mais complexo. </font><font style="vertical-align: inherit;">Quais são os presentes para você? </font><font style="vertical-align: inherit;">Para você, o registro macro é conciso, expressa alguma abstração, mas faz muito trabalho para você e você não precisa escrever todo esse código com as mãos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pytest</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Provavelmente, você se deparou com uma estrutura de teste pytest, muitos aqui quase certamente a usam. Eu não sei se você já reparou, mas sob o capô ele também faz alguma mágica. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/al/o6/qv/alo6qvpzofmabtejvqqojenx31a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, você tem um teste tão simples. Se você executá-lo sem pytest, ele lançará um AssertionError simplesmente. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ih/an/ck/ihanckzzqzelb5o87nfx9olt2vw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infelizmente, meu exemplo é um pouco degenerado, e aqui é imediatamente óbvio que len é retirado de uma lista de três elementos. Mas se alguma função fosse chamada, você nunca saberia de um AssertionError que a função retornou. Ela retornou apenas algo que não é igual a cem. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cu/ko/sa/cukosarqifegg5uvzo14xneczkc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, se isso for executado no pytest, ele exibirá informações adicionais de depuração. Como ele faz isso por dentro?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6h/g9/vr/6hg9vr5nedvvkvzxlsupjqor71a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa mágica funciona de maneira muito simples. O Pytest cria seu próprio gancho especial que é acionado quando o módulo com o teste é carregado. Depois disso, o pytest analisa independentemente esse arquivo Python e, como resultado da análise, é obtida sua representação intermediária, denominada árvore AST. A árvore AST é um conceito básico que permite alterar o código Python rapidamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de receber essa árvore, o pytest impõe uma transformação nela, que procura todas as expressões chamadas assert. Ele as altera de uma certa maneira, compila a nova árvore AST resultante e obtém um módulo com testes, que são executados em uma máquina virtual Python comum.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t3/fj/x-/t3fjx-trld3abinbaqxioiizptg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É assim que a árvore AST original não convertida em pytest se parece. </font><font style="vertical-align: inherit;">A área vermelha destacada é a nossa afirmação. </font><font style="vertical-align: inherit;">Se você olhar atentamente, verá as partes esquerda e direita, a própria lista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando o pytest converte isso e gera um novo ano, a árvore começa a ficar assim. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yv/xh/qb/yvxhqbjsokha_vdwfn9-ksm0isi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem cerca de cem linhas de código que o pytest gerou para você. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cu/fc/zi/cufczioilng0zfzx05nbrtwgl8g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você converter essa árvore AST novamente em Python, será algo parecido com isto. </font><font style="vertical-align: inherit;">As áreas destacadas em vermelho aqui são onde pytest calcula as partes esquerda e direita da expressão, gera uma mensagem de erro e gera um AssertionError se algo der errado com essa mensagem de erro.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correspondência de padrões</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que mais você pode fazer com uma coisa dessas? Você pode converter qualquer código Python. E há uma biblioteca maravilhosa que eu encontrei por acidente no PyPI, é interessante cavar lá. Ela faz a correspondência de padrões. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/3k/yb/eq/3kybeqrilpfpqnvj4bmeon62ibm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Talvez esse código seja familiar para alguém. Ele considera fatorial recursivamente. Vamos ver como ele pode ser gravado usando a correspondência de padrões.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xy/cv/as/xycvassi6jwpp9getvm4sy4bbmm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para fazer isso, basta pendurar o decorador na função. Atenção: dentro do corpo, a função já funciona de maneira diferente. Cada um desses ifs é uma regra para correspondência de padrões, que analisa a expressão que é inserida na função e a transforma de alguma forma. Além disso, não há retornos explícitos do resultado. Como a biblioteca de padrões, quando transforma o corpo da função, verifica primeiro se ela contém apenas se, e segundo, adiciona retornos implícitos do resultado, alterando assim a semântica da linguagem. Ou seja, ela cria uma nova DSL, que funciona um pouco diferente. E, graças a isso, você pode escrever algumas coisas declarativamente. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/3k/yb/eq/3kybeqrilpfpqnvj4bmeon62ibm.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A função anterior é como se estivesse escrita em três linhas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xy/cv/as/xycvassi6jwpp9getvm4sy4bbmm.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/pj/fm/ux/pjfmuxf4zsl_zpppzidv9oirkim.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E o restante das linhas adiciona funcionalidade adicional que permite, por exemplo, ler fatorial de uma lista de valores ou passá-lo por uma função arbitrária. </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como escrever conversões você mesmo? </font><font style="vertical-align: inherit;">macropy!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora você provavelmente está se perguntando, mas como pode aplicá-lo você mesmo? Como é tedioso, como pytest: analisar manualmente os arquivos, procure o código que precisa ser convertido. No pytest, isso é feito por um módulo separado para mil ou mais linhas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para não fazer isso por conta própria, alguns caras inteligentes já criaram um módulo para nós chamado macropy. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta versão do módulo é para o segundo Python e o terceiro. Eles escreveram de volta no tempo do segundo Python. Então os caras fizeram uma piada para descobrir o que pode ser feito com o Python, e a biblioteca inclui vários exemplos. Vamos olhar para eles, eles vão te dar uma idéia do que você pode fazer com esta técnica. A primeira coisa interessante que eles descreveram no tutorial é uma macro que implementa seqüências de formato para o segundo Python, como no terceiro.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/er/3h/vv/er3hvvz7g-0edq1spxz5bukrk3q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A expressão destacada em vermelho é apenas a sintaxe da chamada de macro. A letra S é o nome da macro e, entre colchetes, é a expressão que ela converte. Como resultado, as variáveis ​​são substituídas aqui. Isso funciona no segundo Python, mas o terceiro não é mais necessário em uma macro. Assim, por exemplo, você pode criar sua própria macro, que implementa semânticas mais complexas e faz coisas mais divertidas do que as seqüências de formato padrão.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jw/bf/hx/jwbfhxtuxzzrbjd-vvu3rhdsok8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando uma macro se expande, e isso acontece no momento do carregamento do módulo, ela simplesmente se converte nesse código. Os espaços reservados são inseridos na cadeia de formatação e o procedimento de substituição é aplicado a ela. Além disso, o Python, de maneira padrão, já compila tudo isso. No tempo de execução, nenhuma expansão de macro ocorre. Todos eles ocorrem quando o módulo é carregado. Portanto, é possível fazer otimizações ou cálculos que ocorrerão no momento do carregamento do módulo e gerar um bytecode mais ideal. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2i/gz/9t/2igz9tsitqjebyuxpln51mhknra.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O segundo exemplo também é interessante. Esta é uma notação abreviada para escrever lambdas. A macro f pega uma série de argumentos e retorna uma função. Cada expressão que começa com o nome da macro “f”, colchetes e, em seguida, absolutamente qualquer expressão é convertida em um lambda.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/l5/vq/ym/l5vqym-i-69vtjohomf2nsxfsj0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na minha opinião, isso também é legal, especialmente para quem gosta de desenvolver e escrever código em um estilo funcional e usar o MapReduce. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/0j/fx/xc/0jfxxcdmblyze8e4bcxqrqrgaoy.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está outro exemplo familiar. Esta função considera fatorial, o código é destacado em vermelho. O que acontecerá quando ela for chamada? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ov/gj/v0/ovgjv0vqgcbzx0wxy5q-kuvozzg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Irá gerar um erro no Python, porque será executado no limite da pilha e haverá um RecursionError tão feio. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wi/zz/1h/wizz1haarmzw9is0q0k3n_r6mji.jpeg" width="600"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como isso pode ser consertado? Usando macropy, corrigir o problema é muito simples. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wc/ej/-n/wcej-na40treik2p0hkdp1jfbns.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pendura o decorador, pega o corpo da função e a transforma de alguma maneira mágica. Você não precisa alterar nada na função em si, a macropy fará tudo por você. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xc/c8/ld/xcc8ldcmcykmbaxjceek4xsgrka.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E a função retornará a si mesma um resultado bastante normal, indo muito para o subterrâneo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ek/uq/mi/ekuqmigu-x5hhmdyyy8q04wob5c.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como é a macropia?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fz/1r/5f/fz1r5ff8_v-egywcvufzvw-zsec.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele substitui todas as chamadas para a própria função por um objeto TailCall especial, que é chamado em um loop pelo decorador TCO. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dg/25/5b/dg255bb2t_mzo9ku4ucwq-uz31o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O circuito se parece com isso. O decorador no loop chama a função até retornar algum resultado normal em vez de TailCall. E se ela voltou, então devolve. E isso é tudo. Essas coisas legais podem ser feitas com macros! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Macropy também inclui outros exemplos. Espero que aqueles que têm curiosidade de você os vejam sozinhos. Digamos que há coisas úteis para depuração.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wd/hg/rq/wdhgrqonz6lfdcicgdynvnfipfs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vou falar sobre outra coisa legal. Um exemplo é essa macro de consulta. O que ele está fazendo? Dentro dele, você escreve código Python regular, que pode ser usado como resultado regular da execução dessa expressão. Mas por dentro, a macropy transforma esse código e o transforma no código da linguagem de consulta SQL Alchemy. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/qb/jk/agqbjkyzfbun_tbdnjxww5lutms.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele reescreve para você, faz essa expressão terrível. Pode ser reescrito à mão, depois será mais curto. Eu fiz isso. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/4k/ts/5w/4kts5wogftqmpcceukufkib56be.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está a expressão original. Depois de expandir a macro, assume algo parecido com isto. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/du/i0/uv/dui0uvfpouzuuioj2tmirtfyg5c.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Talvez alguém esteja interessado em escrever código mais parecido com o Python, e não forçar seus desenvolvedores a escrever consultas no DSL SQL Alchemy.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da mesma maneira, você pode gerar qualquer coisa a partir do Python - SQL puro, JavaScript - e salvá-lo em algum lugar próximo ao arquivo e, em seguida, usá-lo no frontend. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kk/s3/j3/kks3j3s2wwep0vejhof8-3fw-oq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos ver como fazer sua própria macro. Com macropy, é muito simples. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma macro é uma função que pega uma árvore AST na entrada e, de alguma forma, a transforma, retorna uma nova. Aqui está um exemplo de macro que adiciona uma descrição à chamada de declaração que contém a expressão de origem, para que possamos entender por que ocorreu o erro AssertionError. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui, a função replace_assert interna é auxiliar. Ela faz uma descida recursiva em uma árvore para você. Dentro do replace_assert, o elemento da subárvore é passado.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3u/qn/wa/3uqnwavrca79l0wumgmnfxfcm58.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Devido a isso, você pode verificar seu tipo e? se for uma chamada de afirmação, faça algo com ela. Aqui darei um exemplo sintético simples que pega a parte esquerda, a parte direita, envia uma mensagem de erro e grava tudo no atributo msg. Esta é a mensagem que precisará ser retornada. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rf/re/hn/rfrehnypphthxdzqbjwehtj3fas.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/va/ak/jm/vaakjmq4tpgqjwttqmi8nepgtym.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/x7/hq/cs/x7hqcswjuj59uhp5thatiojofja.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao usá-lo, você anexa essa macro a um bloco de código usando o gerenciador de contexto with, e todo o código que entra no gerenciador de contexto passa por essa transformação. É visto abaixo que nossa mensagem de erro foi adicionada ao AssertionError, que formamos a partir da expressão len ([1, 2, 3]).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yo/zo/zc/yozozclanvtdlinutuvnl58puve.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, este método tem uma limitação que me deixa pessoalmente triste. </font><font style="vertical-align: inherit;">Tentei, como experimento, criar novos designs que funcionem na linguagem. </font><font style="vertical-align: inherit;">Por exemplo, algumas pessoas gostam de switch ou construções condicionais como a menos que. </font><font style="vertical-align: inherit;">Infelizmente, isso não é possível: a macropia e outras ferramentas que funcionam com a árvore AST são usadas quando o código-fonte já está lido e dividido em tokens. </font><font style="vertical-align: inherit;">O código é lido pelo analisador Python, cuja gramática é fixada no intérprete. </font><font style="vertical-align: inherit;">Para alterá-lo, você precisa recompilar o Python. </font><font style="vertical-align: inherit;">Obviamente, você pode fazer isso, mas já será um fork do Python, e não uma biblioteca que pode ser definida no PyPI. </font><font style="vertical-align: inherit;">Portanto, é impossível criar esses desenhos usando macropy.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyLang</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Felizmente, durante toda a minha vida, escrevi não apenas em Python e estava interessado em várias outras linguagens alternativas. Há uma sintaxe que muitos não gostam, mas mais simples e flexível. Essas são expressões s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Felizmente para nós, existe um suplemento Python chamado HyLang. Isso lembra um pouco o Clojure, apenas o Clojure é executado em cima da JVM e o HyLang é executado em cima da Máquina Virtual Python. Ou seja, ele fornece uma nova sintaxe para escrever código. Mas, ao mesmo tempo, todo o código que você escrever será totalmente compatível com as bibliotecas Python existentes e poderá ser usado nas bibliotecas Python. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/54/sc/rr/54scrrucaeden67utnbyx3jva0i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece algo assim.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qo/vr/w7/qovrw7a-mivofegxjhx61jtlky0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A parte à esquerda escrita em Python, à direita - no HyLang. E de baixo para os dois existe um bytecode, que é o resultado. Você provavelmente notou que é exatamente o mesmo, apenas a sintaxe muda. Expressões HyLang, das quais muitos não gostam. Os opositores dos "colchetes" não entendem que essa sintaxe confere ao idioma um tremendo poder, pois uniformiza as construções do idioma. E a uniformidade permite usar macros para implementar qualquer design. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é alcançado devido ao fato de que dentro de cada expressão o primeiro elemento é sempre algum tipo de ação. E então seus argumentos vão.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E todo o código é composto de expressões aninhadas que são fáceis de converter e abrir macros lá. Devido a isso, absolutamente nenhuma construção pode ser feita no HyLang, nova, de forma alguma indistinguível no código dos recursos padrão da linguagem. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/o5/-u/rw/o5-urwww9tzewkt4ufq7krycxj8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver como uma macro simples funciona no HyLang. Para fazer o mesmo que fizemos com o Assert usando macropy, você só precisa deste código. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nossa macro HyLang recebe entrada, que é código. Além disso, uma macro pode facilmente usar qualquer parte desse código para criar um novo código. A principal diferença entre macros e funções: expressões são de entrada, não de valores. Se chamarmos nossa macro como (é (= 1 2)), ela receberá uma expressão (= 1 2) em vez de Falso.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uc/5b/az/uc5bazq37xtwjlsbaf54_kpe8zu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que possamos gerar uma mensagem de erro informando que algo deu errado. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hn/a9/cm/hna9cmzwxvf87k5e4i0py87cs84.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E então basta retornar o novo código. Essa sintaxe backtick e til significa algo como o seguinte. A citação anterior diz: pegue esta expressão como está e retorne como está. E o til diz: substitua o valor da variável aqui. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pi/qn/en/piqnenjm28v8jm0i-hfsdx3ib18.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, quando escrevemos isso, a macro após a expansão retornará para nós uma nova expressão, que será assim afirmada com uma mensagem de erro adicional.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HyLang é uma coisa legal. </font><font style="vertical-align: inherit;">É verdade que enquanto não o usamos. </font><font style="vertical-align: inherit;">Talvez nós nunca iremos. </font><font style="vertical-align: inherit;">Todos esses itens são experimentais. </font><font style="vertical-align: inherit;">Quero que você saia daqui com a sensação de que, em Python, você pode fazer algumas coisas que talvez nem tenha pensado antes. </font><font style="vertical-align: inherit;">E talvez alguns deles encontrem aplicação prática em seu trabalho contínuo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é tudo para mim. </font><font style="vertical-align: inherit;">Você pode ver os links:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padrões</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MacroPy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyLang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O livro OnLisp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - para um estudo avançado dos recursos das macros. </font><font style="vertical-align: inherit;">Isto é para aqueles especialmente interessados. </font><font style="vertical-align: inherit;">É verdade que o livro não é inteiramente baseado em Python, mas em Common Lisp. </font><font style="vertical-align: inherit;">Mas, para um estudo mais aprofundado, isso será até interessante.</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt495278/index.html">Bancos de dados, cartões, listas de verificação ou Por que um gerente de conhecimento comercial</a></li>
<li><a href="../pt495280/index.html">Patrulha máxima SIEM. Visão geral do sistema de gerenciamento de eventos de segurança da informação</a></li>
<li><a href="../pt495282/index.html">Validação de XML usando XSD, JAXB e Spring Framework</a></li>
<li><a href="../pt495290/index.html">Explorando a qualidade do código do sistema operacional Zephyr</a></li>
<li><a href="../pt495292/index.html">Versão InterSystems IRIS 2020.1</a></li>
<li><a href="../pt495296/index.html">Forense, injeção de SQL e gato sofredor: análise da tarefa nº 3 do estágio online NeoQUEST-2020</a></li>
<li><a href="../pt495298/index.html">Avalie as opções de Monte Carlo Clojure</a></li>
<li><a href="../pt495302/index.html">Como aumentar as vendas 2,5 vezes em 4 meses em uma loja online - um caso de promoção de SEO</a></li>
<li><a href="../pt495304/index.html">Rejuvenescimento das células humanas devido à sua reprogramação</a></li>
<li><a href="../pt495308/index.html">Rake no caminho para se manter vivo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>