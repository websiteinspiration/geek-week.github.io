<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕷️ 🍮 🕴🏼 Patroniによるクラッシュストーリー、またはPostgreSQLクラスターを削除する方法 🍪 🔚 🍙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PostgreSQLには、高可用性はありません。 HAを実現するには、何かを入れてセットアップする必要があります。 PostgreSQLの可用性を高めるのに役立つツールがいくつかあり、そのうちの1つがPatroniです。
 
 一見すると、Patroniをテスト環境に置くと、それがすばらしいツールで...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Patroniによるクラッシュストーリー、またはPostgreSQLクラスターを削除する方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/489206/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQLには、高可用性はありません。 HAを実現するには、何かを入れてセットアップする必要があります。 PostgreSQLの可用性を高めるのに役立つツールがいくつかあり、そのうちの1つがPatroniです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見すると、Patroniをテスト環境に置くと、それがすばらしいツールであり、クラスターを分割しようとする私たちの試みを簡単に処理する方法がわかります。しかし、実際には、本番環境では、すべてが必ずしも美しくエレガントに行われるわけではありません。 Data Egretは、2018年の終わりにPatroniの使用を開始し、それを診断、構成する方法、オートファイラーにまったく依存しない場合の経験を積んでいます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HighLoad ++では、Alexei Lesovskyが、例とログ分析を使用して、Patroniで作業するときに発生する一般的な問題と、それらを克服するためのベストプラクティスを詳細に説明しました。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/lqh1eJwVPtk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、次のことは行いません。Patroniのインストール手順と構成例。</font><font style="vertical-align: inherit;">PatroniおよびPostgreSQL以外の問題。</font><font style="vertical-align: inherit;">他の人の経験に基づいたストーリーですが、データエグレットが自分で見つけた問題のみです。</font></font><br>
<a name="habracut"></a><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">講演者について：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アレクセイレソフスキー（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レソフスキー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）システム管理者（Linuxシステム管理者）として始まり、Web開発（PostgreSQLデータベース管理者）で働いていました。</font><font style="vertical-align: inherit;">2014年からData Egretで働いています。</font><font style="vertical-align: inherit;">Data EgretはPostgreSQLの分野でコンサルティングを行っており、多くの企業がPostgreSQLを正しく使用できるよう支援しており、もちろん、データベースの操作に関する広範な経験を積んでいます。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事のベースとなっているレポートは、「パトロニの障害事例またはPostgreSQLクラスターをクラッシュさせる方法」と呼ばれています</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレゼンテーションへのリンクは次のとおり</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">始める前に</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パトロニとは何か、それが何を意図し、何ができるかを思い出させてください。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patroniは、そのままでHAを構築するためのテンプレートです。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">だからそれはドキュメントに書かれていて、私の観点から-これは非常に正しい説明です。つまり、パトロニは彼が設定した特効薬ではなく、すべての問題を解決します。それが働き始め、利益をもたらすように努力する必要があります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patroni-エージェントサービス。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはデータベースを備えた各サーバーにインストールされ、PostgreSQLの一種の初期化システムです。クラスターの起動と停止、再起動、構成とトポロジーの変更を行います。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PatroniはDCSに「クラスター状態」を保存します。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスターの状態（現在のビュー）を保存するには、ストレージが必要です。</font><font style="vertical-align: inherit;">Patroniは状態を外部システム（分散構成リポジトリ）に保存します。</font><font style="vertical-align: inherit;">これは、Etcd、Consul、ZooKeeper、またはEtcd Kubernetesのいずれかのオプションです。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patroni AutoFileはデフォルトで有効になっています。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patroniをインストールするとすぐに、オートファイラーをすぐに利用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、構成のサービス、新しいレプリカの作成、バックアップなど、他にも多くのものがあります。</font><font style="vertical-align: inherit;">しかし、今回はレポートの範囲外のままです。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patroniの主な目的は、信頼できるオートファイラーを提供することです。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patroniは、機器を監視したり、通知を送信したり、潜在的な事故防止について複雑なことをしたりする必要はありません。</font><font style="vertical-align: inherit;">クラスタートポロジーの変更に関係なく、クラスターが稼働し続け、アプリケーションがデータベースとの連携を継続できることが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、PostgreSQLでPatroniを使い始めると、システムは少し複雑になります。</font><font style="vertical-align: inherit;">現在、データベース自体に加えて、マスターまたはレプリカに障害が発生すると、Patroni自体、クラスター状態の分散ストレージ、またはネットワークが壊れる可能性があります。</font><font style="vertical-align: inherit;">それらの原因を理解するのがどれほど難しいかという点で、より複雑になるので、すべてのオプションを検討してください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題1.同じクラスター上のDBMSとDCS</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も単純なケースを考えてみましょう。データベースクラスターを取り、DCSを同じクラスターに展開しました。</font><font style="vertical-align: inherit;">この一般的なエラーは、PostgreSQLとPatroniのデプロイメントエラーだけに関連しているわけではありません。</font><font style="vertical-align: inherit;">これは、アーキテクチャの一般的な構築における誤りです。1つの場所に多くの異なるコンポーネントを組み合わせます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、フェイルオーバーが発生しました。</font><font style="vertical-align: inherit;">私たちは何が起こったのか理解し始めます。</font><font style="vertical-align: inherit;">ここで、feyloverがいつ発生したか、つまり</font><strong><font style="vertical-align: inherit;">、クラスターの状態が変化し</font></strong><font style="vertical-align: inherit;">た</font><strong><font style="vertical-align: inherit;">時点に</font></strong><font style="vertical-align: inherit;">注目し</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></strong><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フェイルオーバーはいつ発生しましたか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
fayloverは常に即座に発生するわけではなく、時間がかかる場合があります。</font><font style="vertical-align: inherit;">したがって、開始時刻と終了時刻があります。</font><font style="vertical-align: inherit;">すべてのイベントはfeyloverの「前」、「中」、「後」に分けられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず第一に、feyloverが起こったとき、私たちは理由を探しています。</font></font><br>
<br>
<pre><code class="xml hljs">pgdb-2 patroni: INFO: promoted self to leader by acquiring session lock<font></font>
pgdb-2 patroni: WARNING: Loop time exceeded, rescheduling immediately.<font></font>
pgdb-2 patroni: INFO: Lock owner: pgdb-2; I am pgdb-2<font></font>
pgdb-2 patroni: INFO: updated leader lock during promote<font></font>
pgdb-2 patroni: server promoting<font></font>
pgdb-2 patroni: INFO: cleared rewind state after becoming the leader<font></font>
pgdb-2 patroni: INFO: Lock owner: pgdb-2; I am pgdb-2</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記は標準のPatroniログで、サーバーの役割が変更され、ウィザードの役割が別のノードからこのノードに移動したことが報告されています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フェイルオーバーが発生したのはなぜですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、マスターの役割をあるノードから別のノードに移したイベント、古いマスターで何が起こったのかを理解する必要があります。</font></font><br>
<br>
<pre><code class="xml hljs">pgdb-2 patroni: patroni.utils.RetryFailedError: 'Exceeded retry deadline'<font></font>
pgdb-2 patroni: ERROR: Error communicating with DCS<font></font>
pgdb-2 patroni: INFO: demoted self because DCS is not accessible and i was a leader<font></font>
pgdb-2 patroni: WARNING: Loop time exceeded, rescheduling immediately.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、すべてが簡単です。- </font></font><code>Error communicating with DCS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成ストレージシステムとの対話エラー。</font><font style="vertical-align: inherit;">船長は、DCSを使用できないことを認識し、もはや船長にはなれないため辞任したと述べた。</font></font><code>demoted self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これについて話します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">feyloverに先行したものは何ですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
feyloverの前のイベントを見ると、ウィザードが続行するために問題となったまさにその理由がわかります。</font></font><br>
<br>
<pre><code class="xml hljs">pgdb-2 patroni: ERROR: touch_member<font></font>
                ... python trace <font></font>
pgdb-2 patroni: socket.timeout: timed out <font></font>
pgdb-2 patroni: During handling of the above exception, another exception occurred:<font></font>
                ... python trace <font></font>
pgdb-2 patroni:   raise ReadTimeoutError(self, url, "Read timed out. (read timeout=%s)" % timeout_value) <font></font>
pgdb-2 patroni: urllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='127.0.0.1', port=8500): Read timed out. (read timeout=3.3333333333333335) <font></font>
pgdb-2 patroni: During handling of the above exception, another exception occurred:<font></font>
                ... python trace <font></font>
pgdb-2 patroni:     raise MaxRetryError(_pool, url, error or ResponseError(cause)) <font></font>
pgdb-2 patroni: urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=8500): Max retries exceeded with url: /v1/kv/service/pgdb/members/pgdb-2?acquire=19598b72-c0d5-f066-5d24-09c1a9ad61ee&amp;dc=maindb (Caused by ReadTimeoutError("HTTPConnectionPool(host='127.0.0.1', port=8500): Read timed out. (read timeout=3.3333333333333335)",)) <font></font>
pgdb-2 patroni: INFO: no action.  i am the leader with the lock <font></font>
pgdb-2 patroni: WARNING: Loop time exceeded, rescheduling immediately.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Patroniログには、さまざまなタイムアウトエラーが多数表示されます。</font><font style="vertical-align: inherit;">Patroni AgentはDCSを処理できませんでした（この場合はConsul、ポート= 8500）。</font><font style="vertical-align: inherit;">Patroniとデータベースは同じホスト上で実行され、Consulサーバーは同じホスト上で実行されていました。</font><font style="vertical-align: inherit;">サーバーに負荷をかけると、Consulサーバーにも問題が発生しました。そのため、サーバーは正常に通信できませんでした。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてが元通りに戻った</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しばらくして、負荷が落ち着くと、Patroniはエージェントと再び通信できるようになり、すべてが再開されました。</font></font><br>
<br>
<pre><code class="xml hljs">pgdb-2 patroni: INFO: promoted self to leader by acquiring session lock<font></font>
pgdb-2 patroni: WARNING: Loop time exceeded, rescheduling immediately.<font></font>
pgdb-2 patroni: INFO: Lock owner: pgdb-2; I am pgdb-2<font></font>
pgdb-2 patroni: INFO: updated leader lock during promote<font></font>
pgdb-2 patroni: server promoting<font></font>
pgdb-2 patroni: INFO: cleared rewind state after becoming the leader<font></font>
pgdb-2 patroni: INFO: Lock owner: pgdb-2; I am pgdb-2</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じpgdb-2サーバーが再びマスターになりました。</font><font style="vertical-align: inherit;">小さな「裏返し」がありました-比較的短い時間で彼はマスターとして彼自身を辞任し、それから彼らを再び彼自身に引き継ぎました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、誤検知、またはPatroniがすべてを正しく実行したという事実のいずれかと見なすことができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題はConsulサーバーがデータベースと同じハードウェア上にあることだと私たちは自分たちで決めました。</font><font style="vertical-align: inherit;">したがって、CPUとディスクへの負荷（重いIO要求、一時ファイル、自動バキューム、移行、バックアップなど）も、Consulクラスターとの相互作用に影響します。</font><font style="vertical-align: inherit;">これをデータベースと同じ機器にインストールしないことを決定し、Consulに別のクラスターを割り当てました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、あなたはパラメータを回転させることができ</font></font><code>ttl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>loop_wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>retry_timeout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、短期的なピーク負荷を生き残るために彼らの増加によるものしてみてください。</font><font style="vertical-align: inherit;">ただし、負荷が長い場合は、これらのパラメーターを超えてしまうため、メソッドは機能しません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題2.停止</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の問題は、DCSシステムとのやり取りに問題があるという点で、最初の問題と似ています。</font></font><br>
<br>
<pre><code class="xml hljs">maindb-1 patroni: ERROR: get_cluster <font></font>
maindb-1 patroni: Traceback (most recent call last):<font></font>
                ... python trace <font></font>
maindb-1 patroni: RetryFailedError: 'Exceeded retry deadline' <font></font>
maindb-1 patroni: ERROR: Error communicating with DCS <font></font>
maindb-1 patroni: INFO: closed patroni connection to the postgresql cluster <font></font>
maindb-1 patroni: INFO: postmaster pid=214121 <font></font>
... <font></font>
... <font></font>
maindb-1 patroni: INFO: demoted self because DCS is not accessible and i was a leader <font></font>
maindb-1 patroni: WARNING: Loop time exceeded, rescheduling immediately.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Patroniは、DCSと対話できないため、現在のマスターはマスターでなくなり、レプリカモードに入りますと再度言います。</font><font style="vertical-align: inherit;">古いマスターがレプリカになります。</font></font><br>
<br>
<pre><code class="xml hljs">maindb-1 patroni: INFO: Lock owner: maindb-2; I am maindb-1 <font></font>
maindb-1 patroni: INFO: does not have lock <font></font>
maindb-1 patroni: INFO: running pg_rewind from maindb-2 <font></font>
maindb-1 patroni: INFO: running pg_rewind from user=postgres host=192.168.11.18 port=5432 ... <font></font>
maindb-1 patroni: servers diverged at WAL location 1FA/A38FF4F8 on timeline 6 <font></font>
maindb-1 patroni: rewinding from last common checkpoint at 1FA/A38FF450 on timeline 6 <font></font>
maindb-1 patroni: INFO: Lock owner: maindb-2; I am maindb-1 <font></font>
maindb-1 patroni: INFO: running pg_rewind from maindb-2 in progress <font></font>
maindb-1 patroni: Done!</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、Patroniは必要に応じて機能し</font></font><code>pg_rewind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">起動</font><font style="vertical-align: inherit;">してトランザクションログを巻き戻し、新しいマスターに接続して、新しいマスターに追いつきます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">feyloverに先行したものは何ですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
feyloverの前にある最初のこと、それを引き起こしたエラーを見つけましょう。</font><font style="vertical-align: inherit;">Patroniログはこの点で便利です。一定の間隔で同じメッセージを書き込みます。</font><font style="vertical-align: inherit;">それらをすばやくスクロールして、ログがいつ変更されたかを確認できます。</font><font style="vertical-align: inherit;">この時点で、いくつかの問題が始まりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常の状況では、Patroniログは次のようになります。</font></font><br>
<br>
<pre><code class="xml hljs">maindb-1 patroni: INFO: Lock owner: maindb-1; I am maindb-1<font></font>
maindb-1 patroni: INFO: no action. i am the leader with the lock<font></font>
maindb-1 patroni: INFO: Lock owner: maindb-1; I am maindb-1<font></font>
maindb-1 patroni: INFO: no action. i am the leader with the lock</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロックの所有者がチェックされ、変更されると、Patroniが応答する必要のあるイベントが発生する可能性があります。この場合、すべてが順調です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラーが表示され始めた場所までスクロールすると、オートファイラーが発生したことがわかります。エラーはDCSとの相互作用に関連していたため、Consulログも確認しました-ここで何が起こったか。 fayloverの時間とConsulログの時間をおおよそ比較すると、Consulクラスタ内の隣人が他の参加者の存在を疑い始めたことがわかります。</font></font><br>
<br>
<pre><code class="xml hljs">maindb-2 consul[11581]: serf: EventMemberFailed: maindb-1 192.168.11.19<font></font>
maindb-2 consul[11581]: [INFO] serf: EventMemberFailed: maindb-1 192.168.11.19<font></font>
maindb-2 consul[11581]: memberlist: Suspect maindb-1 has failed, no acks received<font></font>
maindb-2 consul[11581]: [INFO] memberlist: Suspect maindb-1 has failed, no acks received</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のConsulエージェントのログを見ると、ネットワークが崩壊していることもわかります。Consulクラスターのすべてのメンバーが相互に疑っています。</font><font style="vertical-align: inherit;">これはfeyloverの推進力でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前のエントリを見ると、PostgreSQLエージェントのConsulシステムで通信の問題が発生していることがわかります（</font></font><code>deadline reached</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>RPC failed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><br>
<br>
<pre><code class="xml hljs">maindb-1 consul: memberlist: Suspect lbs-4 has failed, no acks received<font></font>
maindb-1 consul: [ERR] yamux: keepalive failed: i/o deadline reached<font></font>
maindb-1 consul: yamux: keepalive failed: i/o deadline reached<font></font>
maindb-1 consul: [ERR] consul: "KVS.List" RPC failed to server 192.168.11.115:8300: rpc error making call: EOF<font></font>
maindb-1 consul: [ERR] http: Request GET /v1/kv/service/sam_prod/?recurse=1, error: rpc error making call: EOF from=192.168.11.19<font></font>
maindb-1 consul: [ERR] consul: "KVS.List" RPC failed to server 192.168.11.115:8300: rpc error making call: EOF<font></font>
maindb-1 consul: [ERR] agent: Coordinate update error: rpc error making call: EOF<font></font>
maindb-1 consul: [ERR] http: Request GET /v1/kv/service/sam_prod/?recurse=1, error: rpc error making call: EOF from=192.168.11.19</code></pre><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も簡単な答えは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ネットワーク</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><strong><font style="vertical-align: inherit;">修復することです</font></strong><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">助言するのは簡単ですが、状況は異なる場合があり、これが常に可能であるとは限りません。</font><font style="vertical-align: inherit;">システムは、データセンターに設置することができ、設備に影響を与えることはできません。</font><font style="vertical-align: inherit;">他のオプションが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークを使用せずにソリューションオプションがあります。</font></font><br>
<br>
<ul>
<li><strong> Consul-</strong> — <code>checks: []</code>.<br>
   ,     .    ,    Consul-    .           .</li>
<li><strong></strong> <code>raft_multiplier</code>.<br>
   Consul-,     5 (      staging-).         Consul-.  -   .</li>
<li><strong></strong> <code>renice -n -10 consul</code>.<br>
        .  renice   .          Consul-,             .</li>
<li><strong>   consul?</strong><br>
Consul-         . Patroni   Consul-    ,     :    - ,  Patroni      .   etcd,     ,    etcd   . Patroni      etcd-.    -  ,     ,   ,     Consul.</li>
<li><strong>  </strong> <code>ttl, loop_wait, retry_timeout</code>.<br>
     ,         .     Patroni       .</li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題3.ノードの損失</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Patroniを使用している場合は、クラスターの現在の状態を表示するpatronictl listコマンドに精通しています。</font></font><br>
<br>
<pre><code class="xml hljs">$ patronictl list<font></font>
<font></font>
+-----------------+-------------------------+--------------+--------+---------+-----------+<font></font>
|     Cluster     |          Member         |     Host     |  Role  |  State  | Lag in MB |<font></font>
+-----------------+-------------------------+--------------+--------+---------+-----------+<font></font>
| patroni_cluster | pg01.dev.zirconus.local | 10.202.1.101 |        | running |    0.0    |<font></font>
| patroni_cluster | pg03.dev.zirconus.local | 10.202.1.103 | Leader | running |    0.0    |<font></font>
+-----------------+-------------------------+--------------+--------+---------+-----------+<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見すると、このような結論は正常に思えるかもしれません-マスター、レプリカはありますが、レプリケーションラグはありません。</font><font style="vertical-align: inherit;">しかし、このクラスターには2つではなく3つのノードが存在することがわかるまで、この図は正常です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フェイルオーバーが発生したのはなぜですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動ファイラーが発生し、その後1つのレプリカが消えたことがわかります。</font><font style="vertical-align: inherit;">私たちは彼女がなぜ姿を消したのかを調べ、彼女を連れ戻す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ログを再度調べて、オートファイラーが発生した理由を理解します。</font></font><br>
<br>
<pre><code class="xml hljs">pg02 patroni[1425]: ERROR: failed to update leader lock<font></font>
pg02 patroni[1425]: INFO: demoted self because failed to update leader lock in DCS<font></font>
pg02 patroni[1425]: WARNING: Loop time exceeded, rescheduling immediately.<font></font>
pg02 patroni[1425]: INFO: Lock owner: None; I am pg02.dev.zirconus.local<font></font>
pg02 patroni[1425]: INFO: not healthy enough for leader race<font></font>
pg02 patroni[1425]: INFO: starting after demotion in progress</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マスターpg02はマスターキーを更新できませんでした</font></font><code>ERROR: failed to update leader lock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、db03の2番目のレプリカがマスターになり、すべてがここで正常に機能します。</font></font><br>
<br>
<pre><code class="xml hljs">pg03 patroni[9648]: INFO: promoted self to leader by acquiring session lock<font></font>
pg03 patroni[9648]: server promoting<font></font>
pg03 patroni[9648]: INFO: cleared rewind state after becoming the leader</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古いマスターはどうですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レプリカになることを決定するpg02は、トランザクションログを巻き戻すことから始めました。</font><font style="vertical-align: inherit;">ここでは、クラスターにないレプリカログを確認する必要があります。</font><font style="vertical-align: inherit;">Patroniログを開き、クラスターへの接続プロセス中に、ステージで問題が発生したことを確認します</font></font><code>pg_rewind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="xml hljs">pg02 patroni[1425]: INFO: running pg_rewind from pg03<font></font>
pg02 patroni[1425]: INFO: running pg_rewind from user=postgres host=10.202.1.103 port=5432 ...<font></font>
pg02 patroni[1425]: servers diverged at WAL location 33F/68E6AD10 on timeline 28<font></font>
pg02 patroni[1425]: could not open file "/data/pgdb/11/pg_wal/0000001C0000033F00000059": No such file or directory<font></font>
pg02 patroni[1425]: could not find previous WAL record at 33F/59FFE368 pg02 patroni[1425]: Failure, exiting<font></font>
pg02 patroni[1425]: ERROR: Failed to rewind from healty master: pg03<font></font>
pg02 patroni[1425]: WARNING: Postgresql is not running.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスタに接続するには、ノードはウィザードにトランザクションログを要求し、そこからウィザードをキャッチする必要があります。</font><font style="vertical-align: inherit;">この場合、トランザクションログ（</font></font><code>No such file or directory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">はなく</font><font style="vertical-align: inherit;">、レプリカは起動できません。</font><font style="vertical-align: inherit;">したがって、PostgreSQLはエラーで停止します。</font><font style="vertical-align: inherit;">トランザクションログがなかった理由を理解する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいマスターがWALに何を持っているか見てみましょう：</font></font><br>
<br>
<pre><code class="xml hljs">LOG: checkpoint complete:<font></font>
wrote 62928 buffers (16.0%); 0 WAL file(s) added, 0 removed, 23 recycled;<font></font>
write=12.872 s, sync=0.020 s, total=13.001 s;<font></font>
sync files=16, longest=0.009 s, average=0.001 s;<font></font>
distance=520220 kB, estimate=520220 kB</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行</font></font><code>pg_rewind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中にチェックポイントが発生し、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古いトランザクションログの一部の名前が変更され</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たこと</font><strong><font style="vertical-align: inherit;">がわかりました</font></strong><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">古いマスターが新しいマスターに接続してこれらのログを要求しようとしたとき、それらはすでに名前が変更されていて、単に存在していませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイムスタンプによれば、これらのイベント間の時間は文字通り150ミリ秒です。</font></font><br>
<br>
<pre><code class="xml hljs">2019-08-26 00:06:11,369 LOG: checkpoint complete<font></font>
2019-08-26 00:06:11,517 INFO: running pg_rewind</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これはレプリカを接続して稼ぐのに十分でした。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初はレプリケーションスロットを使用していました。運用の最初の段階でスロットをオフにしましたが、このソリューションは私たちにとっては良さそうでした。スロットが多くのウォルセグメントを蓄積する場合、マスターは落下する可能性があると考えました。スロットなしでしばらく苦しんでいたので、私たちはそれらが必要であることに気づき、返却しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、ウィザードがレプリカ状態になると、ウィザードがスロットとウォールセグメントを削除することです。この問題を平準化するために、パラメーターを増やしました</font></font><code>wal_keep_segments</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。デフォルトでは8セグメントに相当し、</font><strong><font style="vertical-align: inherit;">1000</font></strong><font style="vertical-align: inherit;">に</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイズ</font></font><code>wal_keep_segments</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しました</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。に16 GBを割り当てました</font></font><code>wal_keep_segments</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、現在は切り替え時に、すべてのノードに常に16 GBのトランザクションログがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、長期的なメンテナンスタスクにも当てはまります。</font><font style="vertical-align: inherit;">レプリカの1つ（ソフトウェア、OS、その他）を更新する必要があり、それをオフにしたいとします。</font><font style="vertical-align: inherit;">レプリカをオフにすると、そのスロットも削除されます。</font><font style="vertical-align: inherit;">小さなパラメーター値を使用する</font></font><code>wal_keep_segments</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、レプリカが長期間存在しない場合、ウィザードに表示されない可能性があるトランザクションログが要求され、レプリカは接続できなくなります。</font><font style="vertical-align: inherit;">そのため、私たちは大量の雑誌を保管しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題4.データの損失</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本番ベースでフェイルオーバーが発生しました。</font><font style="vertical-align: inherit;">クラスターを確認しました。すべてが正常で、すべてのレプリカが配置されており、レプリケーションラグがなく、ログにもエラーがありません。</font><font style="vertical-align: inherit;">しかし、製品チーム</font><font style="vertical-align: inherit;">は、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースに十分なデータがないと</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">報告</font><font style="vertical-align: inherit;">してい</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;"> -それらは1つのソースにありますが、データベースにはありません。</font><font style="vertical-align: inherit;">彼らに何が起こったかを理解する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはこれが</font></font><code>pg_rewind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼らのジャム</font><font style="vertical-align: inherit;">だとすぐに気づきましたが</font><font style="vertical-align: inherit;">、その理由を知る必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フェイルオーバーはいつ発生しましたか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ログから、いつでもマスターになったfeyloverがいつマスターになったのか、そして彼がレプリカになりたいのがいつなのかがわかります。</font></font><br>
<br>
<pre><code class="xml hljs">pgdb-1 patroni[17836]: INFO: promoted self to leader by acquiring session lock<font></font>
pgdb-1 patroni[17836]: server promoting<font></font>
pgdb-1 patroni[17836]: INFO: cleared rewind state after becoming the leader<font></font>
pgdb-1 patroni[17836]: INFO: Lock owner: pgdb-1; I am pgdb-1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ログから、失われたトランザクションログの量を特定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはこのようなものでした：古いウィザードが再起動し、autorunによって再起動された後、Patroniが起動され、その後PostgreSQLが起動されました。</font><font style="vertical-align: inherit;">PostgreSQLはPatroniクラスターのメンバーになることを決定し</font></font><code>pg_rewind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、トランザクションログの一部を消去</font><font style="vertical-align: inherit;">するプロセス</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">開始し、</font><font style="vertical-align: inherit;">新しいログをダウンロードして接続しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Patroniは意図したとおりに機能しました。</font><font style="vertical-align: inherit;">クラスターは回復しました：feyloverの3つのノードの後に​​3つのノードがあり、残りました。</font><font style="vertical-align: inherit;">ただし、データの一部が失われるため、データの一部を理解する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それが起こった瞬間に古いマスターのログで見つけてください</font></font><code>pg_rewind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="xml hljs">pgdb-2 patroni[4149]: INFO: running pg_rewind from pgdb-1<font></font>
pgdb-2 patroni[4149]: Lock owner: pgdb-1; I am pgdb-2<font></font>
pgdb-2 patroni[4149]: Deregister service pgdb/pgdb-2<font></font>
pgdb-2 patroni[4149]: running pg_rewind from pgdb-1 in progress<font></font>
pgdb-2 patroni[4149]: running pg_rewind from user=replica host=10.10.1.31 port=5432 ...<font></font>
pgdb-2 patroni[4149]: servers diverged at WAL location 0/5AD1BFD8 on timeline 66<font></font>
pgdb-2 patroni[4149]: rewinding from last common checkpoint at 0/59DD1070 on timeline 66<font></font>
pgdb-2 patroni[4149]: Done!</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古いマスターを停止したトランザクションログ内の位置を見つける必要があります。</font></font><br>
<br>
<pre><code class="xml hljs">pgdb-2 patroni[4149]: INFO: Local timeline=66 lsn=0/5BDA8EB8<font></font>
pgdb-2 patroni[4149]: INFO: master_timeline=67<font></font>
...<font></font>
pgdb-2 patroni[4149]: servers diverged at WAL location 0/5AD1BFD8 on timeline 66<font></font>
postgres=# select pg_wal_lsn_diff('0/5BDA8EB8','0/5AD1BFD8');<font></font>
pg_wal_lsn_diff<font></font>
----------------<font></font>
17354464</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合は0 / 5BDA8EB8のマークです。</font><font style="vertical-align: inherit;">2番目のマーク-0 / 5AD1BFD8-は、古いマスターが新しいマスターと異なる距離を見つけるために必要です。</font><font style="vertical-align: inherit;">関数を使用して、</font></font><code>pg_wal_lsn_diff </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これら2つのマークを比較し、17 MBを取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
17 MBのデータの大きな損失があるかどうか、誰もが自分で決める。</font><font style="vertical-align: inherit;">一部の人にとって、これは取るに足らないことですが、誰かにとってそれは多くの場合受け入れられません。</font><font style="vertical-align: inherit;">ビジネスのニーズに応じて、それぞれが個別に決定します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、システムを再起動した後、Patroniの自動起動が常に必要かどうか</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を決定する必要があり</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。ほとんどの場合、古いマスターに移動して、現在の状態との違いを確認し、おそらくトランザクションログのセグメントを調べます。このデータが失われる可能性があるかどうか、または古いウィザードをスタンドアロンモードで実行してデータをプルする必要があるかどうかを理解する必要があります。その後、データの処理方法を決定し、このノードをレプリカとしてクラスターに接続します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、パラメータがあります</font></font><code>maximum_lag_on_failover</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、デフォルトではその値は1 Mbです。これは次のように機能します。レプリカがレプリケーションラグより1 MB遅れている場合、このレプリカは選択に参加しません。突然フェイルオーバーが発生した場合、Patroniはどのレプリカが遅れているかを調べます。多数のトランザクションログに遅れているレプリカはマスターになれません。これは、大量のデータが失われるのを防ぐ優れたセキュリティ機能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、問題があります。レプリケーションラグは一定の間隔で更新され、</font></font><code>ttl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルト</font><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">は30秒です。 DCSのレプリカのレプリケーションラグの値が1である可能性は十分にありますが、実際には完全に異なるか、まったくラグがありません。これはリアルタイムの値ではなく、常に実際の状況を反映しているわけではなく、複雑なロジックを結びつける価値はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「損失」のリスクは常に残ります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最悪の場合：</font></font><code>maximum_lag_on_failover + ttl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平均的なケースで：</font></font><code>maximum_lag_on_failover + (loop_wait / 2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Patroniの実装を計画し、失う可能性のあるデータの量を評価する場合は、これらの式を考慮して、起こり得る損失をおおよそ表します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
良いニュースは、「損失」のバックグラウンドプロセスからのWALがある可能性があることです。</font><font style="vertical-align: inherit;">このデータは簡単に無視して失われる可能性があるため、問題はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ログが設定され</font></font><code>maximum_lag_on_failover</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、feyloverが発生し、新しいウィザードを選択する必要がある</font><font style="vertical-align: inherit;">場合、ログは次のように</font><font style="vertical-align: inherit;">なります。</font></font><br>
<br>
<pre><code class="xml hljs">pgdb-1 patroni[6202]: INFO: Lock owner: None; I am pgdb-1<font></font>
pgdb-1 patroni[6202]: INFO: not healthy enough for leader race<font></font>
pgdb-1 patroni[6202]: INFO: changing primary_conninfo and restarting in progress<font></font>
...<font></font>
pgdb-1 patroni[6202]: INFO: following a different leader because i am not the healthiest node<font></font>
pgdb-1 patroni[6202]: INFO: following a different leader because i am not the healthiest node</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レプリカは、彼女</font></font><code>not healthy enough for leader race</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">自分で</font><font style="vertical-align: inherit;">あると</font><font style="vertical-align: inherit;">見ているだけ</font><font style="vertical-align: inherit;">で、リーダーシップレースへの参加を拒否します。</font><font style="vertical-align: inherit;">したがって、接続する新しいウィザードが選択されるのを待つだけです。</font><font style="vertical-align: inherit;">これは、データ損失に対する追加の対策です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題5.ドライブ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
製品チームは、アプリケーションにPostgreSQLでの作業に問題があると書いています。</font><font style="vertical-align: inherit;">同時に、SSH経由で利用できないためマスターに入ることができませんが、オートファイラーも発生しません。</font><font style="vertical-align: inherit;">次に、ホストが強制的に再起動され、オートファイラーが起動されました。</font><font style="vertical-align: inherit;">マニュアルのfeyloverを作ることは可能でしたが。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再起動後、マスターに何が起こったかを確認します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_1/2u/rj/_12urj0aobgqg0pp2gkkuolhjog.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスクの問題については事前に知っていましたが、監視することで、どこを掘ればよいかがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLのログには、次のように表示されます。</font></font><br>
<br>
<pre><code class="xml hljs">[COMMIT] LOG: duration: 1138.868 ms statement: COMMIT<font></font>
...<font></font>
[] WARNING: autovacuum worker started without a worker entry<font></font>
...<font></font>
[SELECT] LOG: temporary file: path "base/pgsql_tmp/pgsql_tmp11247.983", size 532996096<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見すると、ディスクの問題のすべてのインジケーターです。コミットが1秒間続くと、autovacuumは非常に長く不思議な、ディスク上の一時ファイルで実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムdmesg-カーネルメッセージログを調べ、ディスクの1つに問題があることを確認しました。</font></font><br>
<br>
<pre><code class="xml hljs">md/raid10:md2: sde3: rescheduling sector 351273392<font></font>
blk_update_request: I/O error, dev sde, sector 64404728<font></font>
md/raid10:md2: sde3: rescheduling sector 63161592<font></font>
blk_update_request: I/O error, dev sde, sector 64404760<font></font>
...<font></font>
md2 : active raid10 sda3[0] sdc3[2] sdd3[3] sdb3[1] sdh3[7] sdf3[5] sdg3[6]<font></font>
      15623340032 blocks super 1.2 512K chunks 2 near-copies [8/7] [UUUUUUU_]<font></font>
      bitmap: 58/59 pages [232KB], 131072KB chunk</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーのディスクサブシステムは8つのディスクのソフトウェアRAIDでしたが、1つが欠落していました。</font><font style="vertical-align: inherit;">行</font></font><code>sda3[0] sdc3[2] sdd3[3] sdb3[1] sdh3[7] sdf3[5] sdg3[6]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がありません</font></font><code>sde[4]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">比較的言えば、1つのディスクが故障し、これがディスクの問題を引き起こし、アプリケーションはPostgreSQLクラスターでの作業に問題がありました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、Patroniはサーバーとディスクのステータスを監視するタスクがないため、Patroniは支援できません。</font><font style="vertical-align: inherit;">問題が発生している間、PatroniはDCSクラスターとの相互作用を続け、問題は発生しませんでした。</font><font style="vertical-align: inherit;">このような状況では、外部監視が必要です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題6.クラスターシミュレーター</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは最も奇妙な問題の1つです。</font><font style="vertical-align: inherit;">私はそれを非常に長い間研究し、多くのログを再度読み、それを「クラスターシミュレーター」と呼びました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、古いマスターが通常の手がかりになれないことでした。</font><font style="vertical-align: inherit;">パトロニはそれを実行し、このノードがレプリカとして存在することを示しましたが、同時にそれは通常のレプリカではありませんでした。その理由がわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前のケースと同様に、すべてディスクの問題で始まりました。</font></font><br>
<br>
<pre><code class="xml hljs">14:48:55.601 [COMMIT] LOG: duration: 1478.118 ms statement: COMMIT<font></font>
14:48:56.287 [COMMIT] LOG: duration: 1290.203 ms statement: COMMIT<font></font>
14:48:56.287 [COMMIT] LOG: duration: 1778.465 ms statement: COMMIT<font></font>
14:48:56.287 [COMMIT] LOG: duration: 1778.449 ms statement: COMMIT</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
壊れた接続がありました：</font></font><br>
<br>
<pre><code class="xml hljs">14:48:58.078 [idle in transaction] LOG: could not send data to client: Broken pipe<font></font>
14:48:58.078 [idle] LOG: could not send data to client: Broken pipe<font></font>
14:48:58.078 [idle] FATAL: connection to client lost<font></font>
14:48:58.107 [idle in transaction] FATAL: connection to client lost</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまな重大度の応答とブロックに対する長い期待がありました。</font></font><br>
<br>
<pre><code class="xml hljs">14:49:26.929 [UPDATE waiting] LOG: process 4298 acquired ExclusiveLock on tuple (2,10) of relation 52082 of database 50587 after 52487.463 ms<font></font>
14:49:26.929 [UPDATE waiting] STATEMENT: UPDATE sessions SET lastaccess='1565005714' WHERE sessionid=...<font></font>
14:49:27.929 [UPDATE waiting] LOG: process 4298 still waiting for ShareLock on transaction 364118337 after 1000.088 ms<font></font>
14:49:27.929 [UPDATE waiting] DETAIL: Process holding the lock: 4294. Wait queue: 4298.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、一時ファイルを再び含むディスクには明らかな問題があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私にとって最も神秘的です-それは飛んだ</font></font><code>immediate shutdown request</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="xml hljs">14:49:34.102 MSK 5335 @ from [] LOG: received immediate shutdown request<font></font>
14:49:34.689 [authentication] WARNING: terminating connection because of crash of another server process<font></font>
14:49:34.689 [authentication] DETAIL: The postmaster has commanded this server process to roll back the current transaction and exit, because another server process exited abnormally and possibly corrupted shared memory</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLには3つのシャットダウンモードがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのクライアントが自分で切断するのを待つときの優雅さ。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シャットダウンするため、お客様に切断するように指示すると、高速です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">即時。切断する必要があることをクライアントに通知せず、オフにしてすべてのクライアントにRSTメッセージを送信します（接続が中断されたことを示すTCP信号）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLバックグラウンドプロセスは、相互に即時のシャットダウン要求信号を送信せず、それらにのみ応答します。</font><font style="vertical-align: inherit;">これは緊急時の再起動であり、誰が送信したかは不明です。</font><font style="vertical-align: inherit;">だった場合</font></font><code>kill -9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ログに表示されますが、そこにはありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに理解すると、Patroniがかなり長い間ログに書き込みを行わなかったことがわかりました。54秒間メッセージがなかっただけです。</font><font style="vertical-align: inherit;">この間、レプリカの1つが「昇格」し、オートファイラーが発生しました。</font></font><br>
<br>
<pre><code class="xml hljs">pgsql03 patroni: 14:48:25,000 INFO: Lock owner: pgsql03; I am pgsql03 <font></font>
pgsql03 patroni: 14:48:25,013 INFO: no action.  i am the leader with the lock <font></font>
pgsql03 patroni: 14:48:37,159 INFO: Lock owner: pgsql03; I am pgsql03 <font></font>
pgsql03 patroni: 14:49:31,155 WARNING: Exception hened during processing of request from 10.1.0.12 <font></font>
pgsql03 patroni: 14:49:31,297 WARNING: Exception hened during processing of request from 10.1.0.11 <font></font>
pgsql03 patroni: 14:49:31,298 WARNING: Exception hened during processing of request from 10.1.0.11</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パトロニはここで再び完璧に働き、古いマスターは利用できなかったので、新しいマスターの選出が始まりました。</font></font><br>
<br>
<pre><code class="xml hljs">pgsql01 patroni: 14:48:57,136 INFO: promoted self to leader by acquiring session lock<font></font>
pgsql01 patroni: server promoting<font></font>
pgsql01 patroni: 14:48:57,214 INFO: cleared rewind state after becoming the leader<font></font>
pgsql01 patroni: 14:49:05,013 INFO: Lock owner: pgsql01; I am pgsql01<font></font>
pgsql01 patroni: 14:49:05,023 INFO: updated leader lock during promote</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pgsql01が新しいリーダーになり、2番目のレプリカに問題が発生しました。</font><font style="vertical-align: inherit;">彼女は正直に再構成を試みました：</font></font><br>
<br>
<pre><code class="xml hljs">pgsql02 patroni: 14:48:57,124 INFO: Could not take out TTL lock <font></font>
pgsql02 patroni: 14:48:57,137 INFO: following new leader after trying and failing to obtain lock <font></font>
pgsql02 patroni: 14:49:05,014 INFO: Lock owner: pgsql01; I am pgsql02 <font></font>
pgsql02 patroni: 14:49:05,025 INFO: changing primary_conninfo and restarting in progress <font></font>
pgsql02 patroni: 14:49:15,011 INFO: Lock owner: pgsql01; I am pgsql02<font></font>
pgsql02 patroni: 14:49:15,014 INFO: changing primary_conninfo and restarting in progress <font></font>
pgsql02 patroni: 14:49:25,011 INFO: Lock owner: pgsql01; I am pgsql02 <font></font>
pgsql02 patroni: 14:49:25,014 INFO: changing primary_conninfo and restarting in progress <font></font>
pgsql02 patroni: 14:49:35,011 INFO: Lock owner: pgsql01; I am pgsql02 <font></font>
pgsql02 patroni: 14:49:35,014 INFO: changing primary_conninfo and restarting in progress</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼女は、recovery.confの変更、PostgreSQLの再起動、新しいウィザードへの接続を試みました。</font><font style="vertical-align: inherit;">10秒ごとに、彼女が試みているメッセージはありますが、できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その間、同じ即時シャットダウン信号が古いマスターに流れ込みました。</font><font style="vertical-align: inherit;">ウィザードは緊急リブートを開始しました。リカバリーも停止します。</font><font style="vertical-align: inherit;">レプリカはシャットダウンモードであるため、マスターに接続できません。</font></font><br>
<br>
<pre><code class="xml hljs">14:49:34.293 [idle] LOG:  received replication command: IDENTIFY_SYSTEM <font></font>
WARNING:  terminating connection because of crash of another server process <font></font>
DETAIL:  The postmaster has commanded this server process to roll back the current transaction and exit, because another server process exited abnormally and possibly corrupted shared memory. <font></font>
14:49:35.232 FATAL:  could not receive data from WAL stream: server closed the connection unexpectedly             <font></font>
        This probably means the server terminated abnormally <font></font>
        before or while processing the request. <font></font>
14:49:35.232 LOG:  record with incorrect prev-link 142D46/315602C at 14CF/CF38C160 <font></font>
14:49:35.305 FATAL: could not connect to the primary server: FATAL: the database system is shutting down <font></font>
14:49:40.241 FATAL: could not connect to the primary server: FATAL: the database system is shutting down</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ある時点で、レプリカは機能しましたが、レプリケーションは開始されませんでした。</font></font><br>
<br>
<pre><code class="xml hljs">14:50:14.024 [] LOG:  record with incorrect prev-link 142D46/315602C at 14CF/CF38C160 <font></font>
14:50:14.028 [] LOG:  fetching timeline history file for timeline 72 from primary server <font></font>
14:50:14.104 [] FATAL:  could not start WAL streaming: ERROR:  requested starting point 14CF/CF000000 on timeline 71 is not in this server's history        <font></font>
DETAIL:  This server's history forked from timeline 71 at 14CF/CEC32E40. <font></font>
14:50:14.104 [] LOG:  new timeline 72 forked off current database system timeline 71 before current recovery point 14CF/CF38C160</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は単一の仮説を持っています：recovery.confには古いマスターのアドレスがありました。</font><font style="vertical-align: inherit;">新しいマスターがすでに表示されている場合、2番目のレプリカは古いマスターに接続しようとしました。</font><font style="vertical-align: inherit;">2番目のレプリカでPatroniが起動すると、ノードは起動しましたが、レプリケーションを介して接続できませんでした。</font><font style="vertical-align: inherit;">次のようなレプリケーションラグが形成されました。</font></font><br>
<br>
<pre><code class="xml hljs">+-----------------+----------+--------------+--------+---------+-----------+<font></font>
|     Cluster     |  Member  |     Host     |  Role  |  State  | Lag in MB |<font></font>
+-----------------+----------+--------------+--------+---------+-----------+<font></font>
| patroni_cluster |  pgsql01 | 10.2.200.151 | Leader | running |       0.0 |<font></font>
| patroni_cluster |  pgsql02 | 10.2.200.152 |        | running |    9153.0 |<font></font>
| patroni_cluster |  pgsql03 | 10.2.200.153 |        | running |       0.0 |<font></font>
+-----------------+----------+--------------+--------+---------+-----------+</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、3つのノードはすべて配置されていましたが、2番目のノードは遅れていました。</font><font style="vertical-align: inherit;">トランザクションログが異なるため、レプリケーションを開始できませんでした。</font><font style="vertical-align: inherit;">ウィザードがrecovery.confで提案したトランザクションログは、単に現在のノードに適合しませんでした。</font><font style="vertical-align: inherit;">PostgreSQLは5秒ごとにエラーを報告しました</font></font><br>
<br>
<pre><code class="xml hljs">14:50:44.143 FATAL:  could not start WAL streaming: ERROR:  requested starting point 14CF/CF000000 on timeline 71 is not in this server's history        <font></font>
         DETAIL:  This server's history forked from timeline 71 at 14CF/CEC32E40. <font></font>
14:50:44.143 LOG:  new timeline 72 forked off current database system timeline 71 before current recovery point 14CF/ CF38C160</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで私は間違いを犯し、間違ったマスターに接続しているという私の仮説を検証しませんでした。</font><font style="vertical-align: inherit;">レプリカでPatroniを再起動しました。</font><font style="vertical-align: inherit;">正直なところ、私はすでにそれに終止符を打ったので、やり直す必要があると考えましたが、それでも再起動を試みることにしました。</font></font><br>
<br>
<pre><code class="xml hljs">15:14:13.511 LOG: consistent recovery state reached at 14CF/A3F657B0<font></font>
15:14:13.511 LOG: database system is ready to accept read only connections</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リカバリが開始され、データベースが開いていても、接続を受け入れる準備ができており、レプリケーションが開始されました。</font></font><br>
<br>
<pre><code class="xml hljs">15:14:17.072 LOG: record with incorrect prev-link 142D46/315602C at 14CF/CF38C160<font></font>
15:14:17.077 LOG: started streaming WAL from primary at 14CF/CF000000 on timeline 72<font></font>
15:14:17.536 LOG: invalid record length at 14CF/CF38C160: wanted 24, got 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、1分後、彼女はエラーで脱落し</font></font><code>terminating walreceiver process due to administrator command</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました。レプリカは、トランザクションログは彼女には適していないと述べました。</font></font><br>
<br>
<pre><code class="xml hljs">15:15:27.823 FATAL: terminating walreceiver process due to administrator command<font></font>
15:15:27.895 LOG: invalid record length at 14CF/CF38C160: wanted 24, got 1<font></font>
15:15:27.895 LOG: invalid record length at 14CF/CF38C160: wanted 24, got 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、PostgreSQLを再起動しませんでしたが、データベースを魔法のように起動することを期待して再起動したのはPatroniでした。</font><font style="vertical-align: inherit;">レプリケーションが再開されましたが、データベースは同じ場所で開かれました：</font></font><br>
<br>
<pre><code class="xml hljs">15:17:33.553 LOG: consistent recovery state reached at 14CF/A3F657B0<font></font>
15:17:33.554 LOG: database system is ready to accept read only connections</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トランザクションログ内のマークは異なり、前回の起動時のマークとは異なりました。トランザクションログの位置は以前のものでした。</font></font><br>
<br>
<pre><code class="xml hljs">15:17:37.299 LOG: invalid contrecord length 5913 at 14CF/CEFFF7B0<font></font>
15:17:37.304 LOG: started streaming WAL from primary at 14CF/CE000000 on timeline 72</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レプリケーションは再び停止し、エラーメッセージは異なり、またあまり有益ではありませんでした。</font></font><br>
<br>
<pre><code class="xml hljs">15:18:12.208 FATAL: terminating walreceiver process due to administrator command<font></font>
15:18:12.240 LOG: record with incorrect prev-link 60995000/589DF000 at 14CF/CEFFF7B0<font></font>
15:18:12.240 LOG: record with incorrect prev-link 60995000/589DF000 at 14CF/CEFFF7B0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実験のために、再び再開し、ベースが同じ場所で開いた：</font></font><br>
<br>
<pre><code class="xml hljs">15:21:25.135 LOG: consistent recovery state reached at 14CF/A3F657B0<font></font>
15:21:25.135 LOG: database system is ready to accept read only connections</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それからアイデアが浮かびました：PostgreSQLを再起動すると、現時点で現在のウィザードでチェックポイントを実行してトランザクションログのポイントを少し先に移動し、別の瞬間からリカバリを開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Patroniを起動し、マスターでいくつかのチェックポイントを作成し、レプリカが開いたときにレプリカでいくつかの再起動ポイントを作成しました。</font></font><br>
<br>
<pre><code class="xml hljs">15:22:43.727 LOG: invalid record length at 14D1/BCF3610: wanted 24, got 0<font></font>
15:22:43.731 LOG: started streaming WAL from primary at 14D1/B000000 on timeline 72</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはうまくいきました-複製は別の場所から始まり、もう壊れませんでした。</font><font style="vertical-align: inherit;">しかし、私にとってこれは私がまだ頭を悩ませている最も不思議な問題の1つです。</font><font style="vertical-align: inherit;">特に、奇妙な即時シャットダウン要求。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これから、結論を出すことができます。Patroniは、計画どおり、エラーなしで問題なく動作しますが、これはすべてが実際に正常であるという絶対的な保証ではありません。</font><font style="vertical-align: inherit;">fayloverの後は、クラスターがすべて正常であることを常にダブルチェックする必要があります。適切な数のレプリカで、レプリケーションラグはありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらと他の多くの同様の問題に基づいて、私はPatroniを操作するときに留意するようにアドバイスする一般的な推奨事項を作成しました。</font></font><br>
<br>
<blockquote><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patroniを使用する場合は、監視が必要です。</font><font style="vertical-align: inherit;">自動ファイルがいつ発生したかを常に知る必要があります。自動ファイルがあることを知らなければ、クラスターを制御できないためです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;各feyloverの後は常にクラスターをチェックします。</font><font style="vertical-align: inherit;">次のことを確認する必要があります。レプリカは常に現在の数です。</font><font style="vertical-align: inherit;">複製の遅れはありません。</font><font style="vertical-align: inherit;">DCSシステムでは、Patroniを使用したスト​​リーミングレプリケーションに関連するログにエラーはありません。</font></font></li>
</ul></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Patroniは非常に優れたツールですが、どんな方法でそれが特効薬ではないとしてもです。</font><font style="vertical-align: inherit;">自動化は正常に機能しますが、同時に、自動化オブジェクトはハーフワーキング状態になる可能性があります。</font><font style="vertical-align: inherit;">とにかく、PostgreSQLとレプリケーションがどのように機能するか、PatroniがPostgreSQLをどのように管理するか、およびノー​​ド間の相互作用がどのように保証されるかについてのアイデアが必要です。</font><font style="vertical-align: inherit;">これは、手で発生する問題を修復できるようにするために必要です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">診断手順</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たまたま私たちはさまざまなクライアントで作業しましたが、ほとんどの場合、それらにはELKスタックがなく、2つのタブと6つのコンソールを開いてログを整理する必要があります。</font><font style="vertical-align: inherit;">これらすべての診断は困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は次のアプローチを開発しました。</font><font style="vertical-align: inherit;">フェイルオーバーが発生したときは常に監視しています。</font><font style="vertical-align: inherit;">私にとってそれは一種の流域です。</font><font style="vertical-align: inherit;">私はfeyloverの前、中、後に何が起こったかを見ます。</font><font style="vertical-align: inherit;">フェイルオーバーには、開始と終了の2つのタイムスタンプがあります。</font><font style="vertical-align: inherit;">ログで、feyloverの前にあるもの、つまり理由を探しています。</font><font style="vertical-align: inherit;">これにより、何が起こったのか、将来何ができるのかを把握でき、同じ状況でフェイロバーが発生しないようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これについては、私は見て：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まず、Patroniがログを記録します。</font></font></li>
<li>  PostgreSQL   DCS    ,     Patroni.</li>
<li>  —     ,    .</li>
</ul><br>
<h3></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オートファイラーには他にも多くの製品があります：stolon、repmgr、pg_auto_failover、PAF。私は4つのツールをすべて試しましたが、私の意見では、Patroniは今日の市場で最高のものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Patroniをお勧めしますか？確かに、はい、私はパトロニが好きなので、私はそれを調理する方法を学んだと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事で説明されている問題以外に、Patroniで発生している他の問題を確認したい場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https：//github.com/zalando/patroni/issues</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のページにいつでもアクセスでき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。多くの異なる物語があります。それらの半分は単純な検索で気にせずに愚かな質問をする文盲のユーザーからのものであるという事実にもかかわらず、興味深い問題もそこで議論され、議論の結果として、バグを修正するためのタスクが必要に応じて開かれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロジェクトを開発してくれたZalandoと、この製品の開発を始めた2人の人々、Alexander KukushkinとAlexey Klyukinに感謝します。すべてのPatroniの貢献者に感謝します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このレポートの後に、アレックスが彼のレポートを1つの評議会に収めようとする短いインタビューを記録し、会議に参加して講演する理由を話しました。腕を取って、Saint HighLoad ++のアプローチをチェックしてください。</font></font></i><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/lnw02pCpgRw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<blockquote> HighLoad++   6-7 .      ,    .          ,        ( ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>).      -  <strong></strong>     ,  ,     ,     .<br>
<br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Saint HighLoad++</a>!    ,  ,      PostgreSQL:   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>,     PostgreSQL    JSON    ;   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>   PostgreSQL 13,  ;   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>     .</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja489194/index.html">OpenShiftがIT組織の組織構造をどのように変えるか。PaaSへの移行時の組織モデルの進化</a></li>
<li><a href="../ja489196/index.html">Magic Smoke：マイクロコントローラーとリニアレギュレータ</a></li>
<li><a href="../ja489198/index.html">Liquibaseを使って足を撃たない方法</a></li>
<li><a href="../ja489200/index.html">2020年にY Combinatorを探しているスタートアップ</a></li>
<li><a href="../ja489204/index.html">Facebookサービスの信頼性の内部</a></li>
<li><a href="../ja489208/index.html">オンライン取引のための仮想サーバー</a></li>
<li><a href="../ja489210/index.html">Linuxコードのパフォーマンステストと例</a></li>
<li><a href="../ja489212/index.html">1C-Bitrixは、個人データの送信を要求することにより、ニュースレターの配信停止を防ぎます</a></li>
<li><a href="../ja489214/index.html">iOSでローカリゼーションをテストするための最新のアプローチ</a></li>
<li><a href="../ja489218/index.html">初心者です。スーパー：シンプルなゲームのコードとアーキテクチャ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>