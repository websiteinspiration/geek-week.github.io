<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤜🏼 🤦🏽 🤜🏼 .NET: Tratamento de Dependências 🆖 🏂🏻 ⛹🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quem não encontrou problemas devido ao redirecionamento de montagem? Provavelmente, todos que desenvolveram um aplicativo relativamente grande enfrent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>.NET: Tratamento de Dependências</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/499838/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quem não encontrou problemas devido ao redirecionamento de montagem? </font><font style="vertical-align: inherit;">Provavelmente, todos que desenvolveram um aplicativo relativamente grande enfrentarão mais cedo ou mais tarde esse problema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, trabalho no JetBrains, no projeto JetBrains Rider, e estou envolvido na tarefa de migrar o Rider para o .NET Core. </font><font style="vertical-align: inherit;">Anteriormente envolvido em infraestrutura compartilhada no Circuit, uma plataforma de hospedagem de aplicativos baseada em nuvem. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/je/f5/e-/jef5e-nc0okqm_ssla0qhniugio.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sob a cena, está a transcrição do meu relatório da conferência DotNext 2019 em Moscou, onde falei sobre as dificuldades ao trabalhar com assemblies no .NET e mostrei com exemplos práticos o que acontece e como lidar com isso.</font></font><a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/fMlTLw1agE0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em todos os projetos em que trabalhei como desenvolvedor .NET, tive que lidar com vários problemas ao conectar dependências e carregar assemblies. </font><font style="vertical-align: inherit;">Nós vamos falar sobre isso.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrutura do cargo:</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problemas de dependência</font></font></b></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carga rigorosa da plataforma</font></font></b></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redirecionamentos de ligação</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nomeação forte</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core</font></font></a></b> <br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estruturas compartilhadas, .runtimeconfig.json</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manifesto de dependência (.deps.json)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacks para executar o JetBrains Rider no Core</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depurar downloads de assembly</font></font></a> </b><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logs de fusão</font></font></a> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eventos de tempo de execução</font></font></a></li>
</ul><br>
</li>
</ol><br>
<a name="problems"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quais são alguns problemas de dependência?</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando eles começaram a desenvolver o .NET Framework no início dos anos 2000, o problema do inferno da Dependência já era conhecido quando os desenvolvedores de todas as bibliotecas permitiam quebrar alterações, e essas bibliotecas se tornaram incompatíveis para uso com o código já compilado. </font><font style="vertical-align: inherit;">Como resolver esse problema? </font><font style="vertical-align: inherit;">A primeira solução é óbvia. </font><font style="vertical-align: inherit;">Sempre mantenha compatibilidade com versões anteriores. </font><font style="vertical-align: inherit;">Obviamente, isso não é muito realista, porque quebrar as mudanças é muito fácil de inserir no código. </font><font style="vertical-align: inherit;">Por exemplo: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/un/gj/tv/ungjtvaiofi7qkm6a4if5cpgh10.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quebrando Alterações e Bibliotecas .NET</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este é um exemplo específico para o .NET. Temos um método e decidimos adicionar um parâmetro com um valor padrão. O código continuará a ser compilado se o montarmos novamente, mas binários serão dois métodos completamente diferentes: um método tem zero argumentos, o segundo método tem um argumento. Se o desenvolvedor dentro da dependência quebrou a compatibilidade com versões anteriores dessa maneira, não poderemos usar o código que foi compilado com essa dependência na versão anterior.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A segunda solução para problemas de dependência é adicionar controle de versão de bibliotecas, assemblies - qualquer coisa. Pode haver regras de versão diferentes, o ponto é que, de alguma forma, podemos distinguir versões diferentes da mesma biblioteca uma da outra, e você pode entender se a atualização será interrompida ou não. Infelizmente, assim que apresentamos as versões, um tipo diferente de problema aparece. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/xc/wu/vgxcwufmesq4jly-ecfrh5p-ko8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versão infernal é a incapacidade de usar uma dependência que é compatível com binários, mas ao mesmo tempo possui uma versão que não se encaixava no tempo de execução ou outro componente que verifica essas versões. No .NET, uma manifestação típica da versão infernal é FileLoadException, embora o arquivo esteja no disco, mas, por algum motivo, não é carregado com o tempo de execução.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qy/wg/5m/qywg5mjhpkuogm6yez7uhnxitji.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No .NET, os assemblies têm muitas versões diferentes - eles tentaram corrigir os infernos da versão de várias maneiras e ver o que aconteceu. Nós temos um pacote </font></font><code>System.Collections.Immutable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Muitas pessoas o conhecem. Ele tem a versão mais recente do pacote NuGet 1.6.0. Ele contém uma biblioteca, um assembly com a versão 1.2.4.0. Você recebeu que você não possui uma versão 1.2.4.0 da biblioteca de compilação. Como entender que ele se encontra no pacote 1.6.0 NuGet? Não vai ser fácil. Além da versão do assembly, esta biblioteca possui várias outras versões. Por exemplo, Versão do arquivo de montagem, Versão de informações da montagem. Na verdade, este pacote NuGet contém três assemblies diferentes com as mesmas versões (para versões diferentes do .NET Standard). </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentação do .NET </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opbuild padrão</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muita documentação foi escrita sobre como trabalhar com assemblies no .NET. </font><font style="vertical-align: inherit;">Existe um Guia .NET para o desenvolvimento de aplicativos modernos para o .NET, levando em consideração o .NET Framework, .NET Standard, .NET Core, código aberto e tudo o que pode ser. </font><font style="vertical-align: inherit;">Cerca de 30% de todo o documento é dedicado ao carregamento de montagens. </font><font style="vertical-align: inherit;">Analisaremos problemas e exemplos específicos que possam surgir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que tudo isso é necessário? </font><font style="vertical-align: inherit;">Em primeiro lugar, para evitar pisar em um ancinho. </font><font style="vertical-align: inherit;">Em segundo lugar, você pode facilitar a vida dos usuários de suas bibliotecas, pois com a biblioteca eles não terão os problemas de dependência aos quais estão acostumados. </font><font style="vertical-align: inherit;">Também ajudará você a lidar com a migração de aplicativos complexos para o .NET Core. </font><font style="vertical-align: inherit;">E ainda por cima, você pode se tornar um SRE, este é um engenheiro de redirecionamento sênior (obrigatório), para o qual todos da equipe vêm e perguntam como escrever outro redirecionamento.</font></font><a name="assembly"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Montagem rigorosa</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O carregamento estrito do assembly é o principal problema que os desenvolvedores do .NET Framework estão enfrentando. </font><font style="vertical-align: inherit;">É expresso em </font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Antes de passar para o carregamento restrito da montagem, deixe-me lembrá-lo de algumas coisas básicas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao criar um aplicativo .NET, você acaba com algum artefato, geralmente localizado na Lixeira / Depuração ou na Lixeira / Liberação, e contém um determinado conjunto de assemblies de montagem e arquivos de configuração. </font><font style="vertical-align: inherit;">Assemblies se referem um ao outro por nome, nome do assembly. </font><font style="vertical-align: inherit;">É importante entender que os links de montagem estão localizados diretamente na montagem que faz referência a essa montagem; não há arquivos de configuração mágica nos quais as referências de montagem são gravadas. </font><font style="vertical-align: inherit;">Embora possa parecer que esses arquivos existem. </font><font style="vertical-align: inherit;">As referências estão nas próprias assembléias na forma binária.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No .NET, existe um processo de resolução de montagem - é quando a definição de montagem já é convertida em uma montagem real, que está em disco ou carregada em algum lugar da memória. A resolução de montagem é realizada duas vezes: no estágio de construção, quando você tem referências em * .csproj, e em tempo de execução, quando você tem referências dentro dos assemblies, e por algumas regras eles se transformam em assemblies que podem ser baixados. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Nome simples </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MyAssembly, Versão = 6.0.0.0, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cultura = neutra, PublicKeyToken = null </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Nome forte </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Newtonsoft.Json, Versão = 6.0.0.0, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cultura = neutra, PublicKeyToken = 30ad4fe6b2a6aeed // PublicKey</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos para o problema. Nome da montagem, existem dois tipos principais. O primeiro tipo de nome de montagem é Nome simples. Eles são fáceis de identificar pelo fato de terem PublicKeyToken = null. Há um nome Forte, é fácil identificá-los pelo fato de que o PublicKeyToken não é nulo, mas sim algum valor. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/40/0v/uf/400vuf0e3w-ykw2fkdx2-ufdutq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos dar um exemplo. Temos um programa que depende da biblioteca com os utilitários do MyUtils, e a versão do MyUtils é 9.0.0.0. O mesmo programa possui um link para outra biblioteca. Essa biblioteca também deseja usar o MyUtils, mas a versão 6.0.0.0. MyUtils versão 9.0.0.0 e versão 6.0.0.0 têm PublicKeyToken = null, ou seja, eles têm um nome simples. Qual versão cairá no artefato binário, 6.0.0.0 ou 9.0.0.0? 9ª versão. O MyLibrary pode usar o MyUtils versão 9.0.0.0, que entrou no artefato binário?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/js/fs/2x/jsfs2xd1erckl8dkphbrhojfhxk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, pode, porque MyUtils tem um nome Simples e, portanto, o carregamento de montagem Rigoroso não existe para ele. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kz/tn/a6/kztna61effl0kkiuwnkvi1gpad8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro exemplo. </font><font style="vertical-align: inherit;">Em vez de MyUtils, temos uma biblioteca completa do NuGet, que tem um nome Forte. </font><font style="vertical-align: inherit;">A maioria das bibliotecas do NuGet tem um nome Forte.</font></font><br>
<br>
<a name="redirects"></a><img src="https://habrastorage.org/webt/rr/xp/qi/rrxpqilvehdbvemijol2iuutbie.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No estágio de compilação, a versão 9.0.0.0 é copiada para o BIN, mas em tempo de execução obtemos o famoso </font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para que MyLibrary, que deseja a versão 6.0.0.0 </font></font><code>Newtonsoft.Json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, possa usar a versão 9.0.0.0, você deve escrever o redirecionamento Binding </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redirecionamentos de ligação</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/lw/d_/yq/lwd_yq2otb7kqsbpkpglszjlr-y.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redirecionando versões de assembly</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Declara que um assembly com esse nome e publicKeyToken deve ser redirecionado de um intervalo de versões para um intervalo de versões. </font><font style="vertical-align: inherit;">Parece ser um registro muito simples, mas, no entanto, está localizado aqui </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas pode estar em outros arquivos. </font><font style="vertical-align: inherit;">Há um arquivo </font></font><code>machine.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro do .NET Framework, dentro do tempo de execução, no qual é definido um conjunto padrão de redirecionamentos, que podem diferir de versão para versão do .NET Framework. </font><font style="vertical-align: inherit;">Pode acontecer que no 4.7.1 nada funcione para você, mas no 4.7.2 ele já funciona, ou vice-versa. </font><font style="vertical-align: inherit;">Você precisa ter em mente que os redirecionamentos podem vir não apenas do seu </font></font><code>.App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e isso deve ser levado em consideração durante a depuração.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplificamos a escrita de redirecionamentos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ninguém quer escrever redirecionamentos de encadernação com as mãos. Vamos dar esta tarefa ao MSBuild! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pg/qk/ct/pgqkctk1hwcp0lewpamhi5wn35o.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como habilitar e desabilitar o redirecionamento automático de ligação</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Algumas dicas sobre como simplificar o trabalho com o redirecionamento de ligação. Dica um: Habilite a geração automática de redirecionamento de ligação no MSBuild. Ativado por propriedade em </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ao criar um projeto, ele cairá em um artefato binário </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que indica redirecionamentos para versões de bibliotecas que estão no mesmo artefato. Isso funciona apenas para aplicativos em execução, aplicativo de console, WinExe. Para bibliotecas, isso não funciona, porque para bibliotecas</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na maioria das vezes, simplesmente não é relevante, porque é relevante para um aplicativo que inicia e carrega os próprios conjuntos. Se você fez uma configuração para a biblioteca, no aplicativo algumas dependências também podem diferir daquelas que estavam ao criar a biblioteca, e acontece que a configuração da biblioteca não faz muito sentido. No entanto, às vezes para configurações de bibliotecas ainda fazem sentido. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ik/g6/6n/ikg66nyqel3ejmqbln9xb1magyq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A situação quando escrevemos testes. Os testes geralmente são encontrados na ClassLibrary e também precisam de redirecionamentos. As estruturas de teste são capazes de reconhecer que a biblioteca com testes possui uma configuração de dll e trocar os redirecionamentos neles pelo código dos testes. Você pode gerar esses redirecionamentos automaticamente. Se tivermos um formato antigo</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, não no estilo SDK, você pode seguir o caminho simples, alterar o OutputType para Exe e adicionar um ponto de entrada vazio, isso forçará o MSBuild a gerar redirecionamentos. Você pode ir para o outro lado e usar o hack. Você pode adicionar outra propriedade a </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o que faz o MSBuild considerar que, para esse OutputType, você ainda precisa gerar redirecionamentos de ligação. Esse método, embora pareça um hack, permitirá gerar redirecionamentos para bibliotecas que não podem ser refeitas no Exe e para outros tipos de projetos (exceto testes). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para o novo formato, os </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">próprios redirecionamentos serão gerados se você usar o Microsoft.NET.Test.Sdk moderno.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terceira dica: não use a geração de redirecionamento Binding com o NuGet. O NuGet tem a capacidade de gerar redirecionamento de ligação para bibliotecas que passam de pacotes para as versões mais recentes, mas essa não é a melhor opção. Todos esses redirecionamentos precisarão ser adicionados </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e confirmados e, se você gerar redirecionamentos usando o MSBuild, os redirecionamentos serão gerados durante a compilação. Se você os confirmar, pode haver conflitos de mesclagem. Você mesmo pode simplesmente esquecer de atualizar o redirecionamento de Ligação no arquivo e, se eles forem gerados durante a compilação, você não esquecerá. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yi/fr/zq/yifrzq4fnvwitenrhkteup1cjfq.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resolver referência de montagem </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gerar redirecionamentos de encadernação</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lição de casa para quem quer entender melhor como a geração de redirecionamentos Binding funciona: descubra como funciona, veja isso no código. Vá para o diretório .NET, esbarre em qualquer lugar com a propriedade name, que é usada para habilitar a geração. Geralmente, essa é uma abordagem comum; se houver alguma propriedade estranha para o MSBuild, você poderá aproveitar o uso. Felizmente, a propriedade geralmente é usada nas configurações XML, e você pode facilmente encontrar seu uso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você examinar o que há nesses destinos XML, verá que essa propriedade dispara duas tarefas do MSBuild. A primeira tarefa é chamada </font></font><code>ResolveAssemblyReferences</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e gera um conjunto de redirecionamentos que são gravados nos arquivos. A segunda tarefa </font></font><code>GenerateBindingRedirects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grava os resultados da primeira tarefa em</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Existe uma lógica XML que corrige levemente a operação da primeira tarefa e remove alguns redirecionamentos desnecessários ou adiciona novos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternativa às configurações XML</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nem sempre é conveniente manter os redirecionamentos na configuração XML. </font><font style="vertical-align: inherit;">Podemos ter uma situação em que o aplicativo baixa o plug-in, e esse plug-in usa outras bibliotecas que exigem redirecionamentos. </font><font style="vertical-align: inherit;">Nesse caso, podemos não estar cientes do conjunto de redirecionamentos de que precisamos ou talvez não desejemos gerar XML. </font><font style="vertical-align: inherit;">Em tal situação, podemos criar um AppDomain e, quando ele é criado, ainda transferir para onde o XML com os redirecionamentos necessários está localizado. </font><font style="vertical-align: inherit;">Também podemos lidar com erros de carregamento de montagem diretamente no tempo de execução. </font><font style="vertical-align: inherit;">O Rantime .NET oferece essa oportunidade.</font></font><br>
<br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (sender, eventArgs) =&gt; <font></font>
{ <font></font>
   <span class="hljs-keyword">var</span> name = eventArgs.Name; 
   <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
   <font></font>
   <span class="hljs-keyword">return</span> Assembly.LoadFrom(...); <span class="hljs-comment">// PublicKeyToken should be equal</span><font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tem um evento, é chamado </font></font><code>CurrentDomain.AssemblyResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ao assinar este evento, receberemos erros sobre todos os downloads de montagem com falha. Obtemos o nome da montagem que não foi carregada e obtemos a montagem que solicitou o carregamento da primeira montagem. Aqui, podemos carregar manualmente o assembly do lugar certo, por exemplo, descartando a versão, apenas retirando-a do arquivo e retornando esse evento do manipulador. Ou retorne null se não tivermos o que retornar, se não pudermos carregar a montagem. PublicKeyToken deve ser o mesmo; assemblies com diferentes PublicKeyToken não são de forma alguma amigos um do outro.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8q/m7/ge/8qm7ge64h4pbldvju9ya91uz8zm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este evento se aplica a apenas um domínio de aplicativo. </font><font style="vertical-align: inherit;">Se nosso plugin criar um AppDomain dentro de si, esse redirecionamento no tempo de execução não funcionará neles. </font><font style="vertical-align: inherit;">De alguma forma, você precisa se inscrever neste evento em todo o AppDomain que o plug-in criou. </font><font style="vertical-align: inherit;">Podemos fazer isso usando o AppDomainManager. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AppDomainManager é um assembly separado que contém uma classe que implementa uma interface específica e um dos métodos dessa interface permitirá que você inicialize qualquer novo AppDomain criado no aplicativo. </font><font style="vertical-align: inherit;">Depois que o AppDomain é criado, esse método será chamado. </font><font style="vertical-align: inherit;">Nele você pode se inscrever neste evento.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carregamento rigoroso de montagem e .NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No .NET Core, não há problema chamado "Carregamento estrito de assembly", devido ao fato de os assemblies assinados exigirem exatamente a versão solicitada. Há outro requisito. Para todos os assemblies, independentemente de serem ou não assinados pelo nome Strong, é verificado se a versão que foi carregada em tempo de execução é maior ou igual à anterior. Se estivermos na situação de um aplicativo com plug-ins, é possível que o plug-in tenha sido criado, por exemplo, a partir de uma nova versão do SDK, e o aplicativo para o qual ele é baixado use a versão antiga do SDK até o momento e, em vez de desmoronar, também podemos assinar este evento, mas já no .NET Core, e também carregar o assembly que temos. Podemos escrever este código:</font></font><br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (s, eventArgs) =&gt; <font></font>
{ <font></font>
     CheckForRecursion(); <font></font>
     <span class="hljs-keyword">var</span> name = eventArgs.Name;
     <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
    <font></font>
     name.Version = <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <font></font>
     <font></font>
     <span class="hljs-keyword">return</span> Assembly.Load(name); <font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Temos o nome do assembly que não inicializou, anulamos a versão e a chamamos </font></font><code>Assembly.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">da mesma versão. Não haverá recursão aqui, porque eu já verifiquei a recursão. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mt/cs/kr/mtcskrokxuvcn8i4gueywowb3_m.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Foi necessário fazer o download do MyUtils versão 0.0.2.0. No BIN, temos o MyUtils versão 0.0.1.0. Fizemos um redirecionamento da versão 0.0.2.0 para a versão 0.0. A versão 0.0.1.0 não será carregada conosco. Será emitida uma saída para nós, que não foi possível carregar o conjunto com a versão 0.0.2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16–1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16-1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) == <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>) <font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Version</span> { 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Build; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Revision; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Major; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Minor; <font></font>
} <font></font>
(<span class="hljs-keyword">ushort</span>) <span class="hljs-number">-1</span> == <span class="hljs-number">65535</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na classe Versão, nem todos os componentes são obrigatórios e, em vez dos componentes opcionais –1, são armazenados, mas em algum lugar interno ocorre um estouro e os 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16–1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> são obtidos </font><font style="vertical-align: inherit;">. Se estiver interessado, você pode tentar encontrar exatamente onde ocorre o estouro. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m5/bl/vl/m5blvl8u1xrfdigr0ay45_ps3q8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você trabalha com montagens de reflexão e deseja obter todos os tipos, pode ser que nem todos os tipos possam obter o seu método GetTypes. Um assembly tem uma classe que herda de outra classe que está em um assembly que não está carregado.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> IEnumerable <span class="hljs-title">GetTypesSafe</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Assembly assembly</span>)</span> <font></font>
{ <font></font>
    <span class="hljs-keyword">try</span> <font></font>
    { <font></font>
        <span class="hljs-keyword">return</span> assembly.GetTypes(); <font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span> (ReflectionTypeLoadException e) <font></font>
   { <font></font>
        <span class="hljs-keyword">return</span> e.Types.Where(x =&gt; x != <span class="hljs-literal">null</span>); <font></font>
    } <font></font>
}<font></font>
<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, o problema será que um ReflectionTypeLoadException será lançado. </font><font style="vertical-align: inherit;">Dentro, </font></font><code>ReflectionTypeLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">há uma propriedade na qual existem esses tipos que ainda conseguiram ser carregados. </font><font style="vertical-align: inherit;">Nem todas as bibliotecas populares levam isso em consideração. </font><font style="vertical-align: inherit;">O AutoMapper, pelo menos uma de suas versões, se confrontado com ReflectionTypeLoadException, caiu, em vez de ir e escolher os tipos por dentro da exceção.</font></font><a name="name"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nomeação forte</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Montagens com nome forte</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Vamos falar sobre o que causa o carregamento restrito de montagem, este é o nome Forte. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nome forte é a assinatura do assembly por alguma chave privada usando criptografia assimétrica. PublicKeyToken é o hash da chave pública deste assembly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A nomeação forte permite distinguir entre diferentes montagens que têm o mesmo nome. Por exemplo, MyUtils não é um nome exclusivo, pode haver vários assemblies com o mesmo nome, mas se você assinar Nome forte, eles terão PublicKeyToken diferente e podemos distingui-los dessa maneira. O nome forte é necessário para alguns cenários de carregamento de montagem.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, para instalar um assembly no Global Assembly Cache ou fazer o download de várias versões lado a lado de uma só vez. </font><font style="vertical-align: inherit;">Mais importante, assemblies nomeados fortes só podem fazer referência a outros assemblies nomeados fortes. </font><font style="vertical-align: inherit;">Como alguns usuários desejam assinar suas construções com o nome Strong, os desenvolvedores da biblioteca também assinam suas bibliotecas, para facilitar a instalação dos usuários, para que os usuários não precisem assinar novamente essas bibliotecas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nome forte: Legado?</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nomeação forte e bibliotecas .NET A</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Microsoft diz explicitamente no MSDN que você não deve usar o nome Forte para fins de segurança, pois eles fornecem apenas para distinguir diferentes assemblies com o mesmo nome. A chave de montagem não pode ser alterada de forma alguma; se você a alterou, quebrará os redirecionamentos para todos os seus usuários. Se houver uma parte privada da chave do nome Forte vazada para acesso público, não será possível retirar esta assinatura de nenhuma maneira. O formato de arquivo SNK no qual o nome Strong está localizado não oferece essa oportunidade e outros formatos para armazenar chaves contêm pelo menos um link para a Lista de revogação de certificados CRL, pelo qual é possível entender que esse certificado não é mais válido. Não há nada parecido no SNK.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O guia de código aberto tem as seguintes recomendações. Em primeiro lugar, adicionalmente, para fins de segurança, use outras tecnologias. Em segundo lugar, se você tem uma biblioteca de código aberto, geralmente é sugerido que você comprometa a parte privada da chave no repositório, para que seja mais fácil para as pessoas bifurcarem sua biblioteca, reconstruí-la e colocá-la em um aplicativo pronto. Em terceiro lugar, nunca mude o nome Forte. Muito destrutivo. Apesar de ser muito destrutivo e estar escrito sobre isso no guia de código-fonte aberto, a Microsoft às vezes tem problemas com suas próprias bibliotecas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ue/kg/l3/uekgl3iwrexq7ejjbabccq4y4p4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há uma biblioteca chamada System.Reactive. </font><font style="vertical-align: inherit;">Anteriormente, esses eram vários pacotes NuGet, um deles é o Rx-Linq. </font><font style="vertical-align: inherit;">Este é apenas um exemplo, o mesmo para o restante dos pacotes. </font><font style="vertical-align: inherit;">Na segunda versão, foi assinado com uma chave da Microsoft. </font><font style="vertical-align: inherit;">Na terceira versão, ele foi para o repositório no projeto </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/dotnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e começou a ter uma assinatura do .NET Foundation. </font><font style="vertical-align: inherit;">A biblioteca, de fato, mudou o nome Strong. </font><font style="vertical-align: inherit;">O pacote NuGet foi renomeado, mas o assembly é chamado dentro da mesma exatamente como antes. </font><font style="vertical-align: inherit;">Como redirecionar da segunda versão para a terceira? </font><font style="vertical-align: inherit;">Este redirecionamento não pode ser feito.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Validação de nome forte</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como desativar o recurso de desvio de nome forte</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro argumento de que o nome Strong já é algo do passado e permanece puramente formal é que eles não são validados. Temos um assembly assinado e queremos corrigir algum tipo de bug, mas não temos acesso às fontes. Podemos usar o dnSpy - este é um utilitário que permite descompilar e consertar os assemblies já compilados. Tudo vai funcionar para nós. Como, por padrão, o desvio de validação de nome forte está ativado, ou seja, ele apenas verifica se o PublicKeyToken é igual e se a integridade da assinatura em si não é verificada. Pode haver estudos ambientais nos quais a assinatura ainda é verificada, e aqui um exemplo vívido é o IIS. A integridade da assinatura é verificada no IIS (o desvio de validação de nome forte está desativado por padrão) e tudo será interrompido se editarmos o assembly assinado. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adição:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você pode desativar a verificação de assinatura para a montagem usando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sinal público.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Com ele, apenas a chave pública é usada para assinatura, o que garante a segurança do nome do assembly. As chaves públicas usadas pela Microsoft estão publicadas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No Rider, o sinal público pode ser ativado nas propriedades do projeto. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vl/_j/ct/vl_jctjjgui-mbcgo5uyzd26lrc.png"><br>
<br>
<img src="https://habrastorage.org/webt/ni/if/hp/niifhpriuvymkfhz78sdeaigs54.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando alterar as versões do conjunto de arquivos</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O guia de código-fonte aberto também oferece algumas políticas de controle de versão, cujo objetivo é reduzir o número de redirecionamentos de ligação necessários e as alterações para os usuários no NET Framework. Esta política de controle de versão é que não devemos alterar a versão do assembly constantemente. Obviamente, isso pode levar a problemas com a instalação no GAC, para que a imagem nativa instalada não corresponda ao assembly e você precise executar a compilação JIT novamente, mas, na minha opinião, isso é menos grave que os problemas com o controle de versão. No caso do CrossGen, os assemblies nativos não são instalados globalmente - não haverá problemas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, o pacote NuGet Newtonsoft.Json, possui várias versões: 12.0.1, 12.0.2 e assim por diante - todos esses pacotes têm um assembly com a versão 12.0.0.0. </font><font style="vertical-align: inherit;">A recomendação é que a versão do assembly seja atualizada quando uma versão principal do pacote NuGet for alterada.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">achados</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Siga as dicas para o .NET Framework: gere redirecionamentos manualmente e tente usar a mesma versão das dependências em todos os projetos em sua solução. </font><font style="vertical-align: inherit;">Isso deve minimizar significativamente o número de redirecionamentos. </font><font style="vertical-align: inherit;">Você precisará de nomes fortes apenas se tiver um cenário específico de carregamento de construção, onde for necessário, ou estiver desenvolvendo uma biblioteca e desejar simplificar a vida dos usuários que realmente precisam de nomes fortes. </font><font style="vertical-align: inherit;">Não mude Nome forte.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Standard</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passamos para o .NET Standard. Está bastante relacionado à versão infernal no .NET Framework. O .NET Standard é uma ferramenta para escrever bibliotecas compatíveis com várias implementações da plataforma .NET. As implementações referem-se ao .NET Framework, .NET Core, Mono, Unity e Xamarin. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hk/-a/-u/hk-a-u16d-oitjurhvta7lhafdi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Link para documentação</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta é a tabela de suporte do .NET Standard para várias versões de diferentes versões dos tempos de execução. E aqui podemos ver que o .NET Framework não oferece suporte à .NET Standard versão 2.1. O lançamento do .NET Framework, que dará suporte ao .NET Standard 2.1 e posterior, ainda não está planejado. Se você estiver desenvolvendo uma biblioteca e desejar que ela funcione para usuários no .NET Framework, será necessário ter um destino para o .NET Standard 2.0. Além do fato de o .NET Framework não suportar a versão mais recente do .NET Standard, vamos prestar atenção ao asterisco. O .NET Framework 4.6.1 oferece suporte ao .NET Standard 2.0, mas com um asterisco. Existe uma nota de rodapé diretamente na documentação, onde eu consegui essa tabela.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ay/mq/yu/aymqyunvnqjivv13dpqkrzvac6i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere um projeto de exemplo. Um aplicativo no .NET Framework que possui uma dependência direcionada ao .NET Standard. Algo assim: ConsoleApp e ClassLibrary. Biblioteca de destino .NET Standard. Quando montarmos esse projeto, será assim em nosso BIN. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/62/og/fh62og_vou9gzibnv5gdd2mp_uk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teremos uma centena de DLLs, das quais apenas uma relacionada ao aplicativo, tudo o mais veio para dar suporte ao .NET Standard. O fato é que o .NET Standard 2.0 apareceu mais tarde que o .NET Framework 4.6.1, mas ao mesmo tempo se mostrou compatível com a API, e os desenvolvedores decidiram adicionar o suporte ao Standard 2.0 ao .NET 4.6.1. Fizemos isso não de forma nativa (por inclusão </font></font><code>netstandard.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no próprio tempo de execução), mas de maneira que o .NET Standard * .dll e todas as outras fachadas de montagem sejam colocadas diretamente no BIN.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/af/15/am/af15amgkrw698xqylhfwemd67uy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se observarmos as dependências da versão do .NET Framework que visamos e o número de bibliotecas que caíram no BIN, veremos que não há muitas delas na 4.7.1 e, desde a 4.7.2, não há bibliotecas adicionais, e .NET O padrão é suportado lá nativamente. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rf/wu/va/rfwuvalfp3bi6zijyw5kjz-wjva.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este é um tweet de um dos desenvolvedores do .NET, que descreve esse problema e recomenda o uso do .NET Framework versão 4.7.2 se tivermos bibliotecas do .NET Standard. </font><font style="vertical-align: inherit;">Nem mesmo com a versão 2.0 aqui, mas com a versão 1.5.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">achados</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se possível, aumente o Target Framework em seu projeto para pelo menos 4.7.1, preferencialmente 4.7.2. </font><font style="vertical-align: inherit;">Se você estiver desenvolvendo uma biblioteca para facilitar a vida dos usuários da biblioteca, faça um Destino separado para o .NET Framework, evitará um grande número de dlls que podem entrar em conflito com alguma coisa.</font></font><a name="dotnet"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos começar com uma teoria geral. </font><font style="vertical-align: inherit;">Discutiremos como lançamos o JetBrains Rider no .NET Core e por que deveríamos falar sobre isso. </font><font style="vertical-align: inherit;">O Rider é um projeto muito grande, possui uma enorme solução corporativa com um grande número de projetos diferentes, um sistema complexo de dependências, você não pode simplesmente pegá-lo e migrar para outro tempo de execução ao mesmo tempo. </font><font style="vertical-align: inherit;">Para fazer isso, temos que usar alguns hacks, que também serão analisados.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplicativo .NET Core</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como é um aplicativo típico do .NET Core? Depende de como exatamente é implantado, para o que está indo. Nós podemos ter vários cenários. A primeira é uma implantação dependente da estrutura. É o mesmo que no .NET Framework quando o aplicativo usa o tempo de execução pré-instalado no computador. Pode ser uma implantação autônoma, é quando o aplicativo carrega um tempo de execução. E pode haver uma implantação de arquivo único, é quando obtemos um arquivo exe, mas no caso do .NET Core dentro desse arquivo exe, há um artefato do aplicativo Autônomo, esse é um arquivo de extração automática. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/yi/3c/hxyi3c3yxhavujn9ljcmtxkuvj0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consideraremos apenas a implantação dependente da estrutura. Temos uma DLL com o aplicativo, existem dois arquivos de configuração, o primeiro dos quais é necessário, este </font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font><code>deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A partir do .NET Core 3.0, é gerado um arquivo exe, necessário para tornar o aplicativo mais conveniente para a execução, para que você não precise digitar o comando .NET se estiver no Windows. </font><font style="vertical-align: inherit;">As dependências se enquadram nesse artefato, começando no .NET Core 3.0, no .NET Core 2.1 em que você precisa publicar ou usar outra propriedade </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><a name="config"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estruturas compartilhadas, </font></font><code>.runtimeconfig.json</code></h3><br>
<br>
<img src="https://habrastorage.org/webt/cc/a5/ab/cca5ab5zhb3v6b1itc9jjbsiwje.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contém as configurações de tempo de execução necessárias para executá-lo. Indica em qual estrutura compartilhada o aplicativo será iniciado e se parece com isso. Indicamos que o aplicativo será executado sob "Microsoft.NETCore.App" versão 3.0.0; pode haver outra Estrutura Compartilhada. Outras configurações também podem estar aqui. Por exemplo, você pode ativar o coletor de lixo do servidor. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c5/un/ic/c5unicttj2dp5ol0jiewknhb48i.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gerado durante a montagem do projeto. E se queremos incluir o GC do servidor, precisamos modificar esse arquivo com antecedência, mesmo antes de montar o projeto ou adicioná-lo manualmente. Você pode adicionar suas configurações aqui assim. Podemos incluir propriedade em </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se essa propriedade for fornecida por desenvolvedores .NET, ou se a propriedade não for fornecida, podemos criar um arquivo chamado</font></font><code>runtimeconfig.template.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e escreva as configurações necessárias aqui. Durante a montagem, outras configurações necessárias serão adicionadas a este modelo, por exemplo, a mesma Estrutura Compartilhada. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/bu/e9/rlbue9y7cikkyzwenefcu2rdxy8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A Estrutura Compartilhada é um conjunto de tempo de execução e bibliotecas. De fato, o mesmo que o tempo de execução do .NET Framework, que costumava ser instalado apenas uma vez na máquina e para todos era uma versão. O Shared Framework e, diferentemente de um único tempo de execução do .NET Framework, podem ser versionados, aplicativos diferentes podem usar versões diferentes dos tempos de execução instalados. Também o Shared Framework pode ser herdado. A própria estrutura compartilhada pode ser visualizada nos locais do disco geralmente instalados no sistema.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nc/df/7i/ncdf7ioj8afrolkvnlouh77jiaq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem várias estruturas compartilhadas padrão, por exemplo, Microsoft.NETCore.App, que executa aplicativos de console convencionais, AspNetCore.App, para aplicativos Web, e WindowsDesktop.App, a nova estrutura compartilhada no .NET Core 3, que executa aplicativos de área de trabalho. no Windows Forms e WPF. Os dois últimos Shared Framework complementam essencialmente o primeiro necessário para aplicativos de console, ou seja, eles não carregam um tempo de execução totalmente novo, mas simplesmente complementam o existente com as bibliotecas necessárias. Parece que essa herança também existe nos diretórios do Framework compartilhado </font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nos quais o Framework compartilhado base é especificado.</font></font><a name="man"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manifesto de dependência ( </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/sc/qv/qbscqv1sh6jb_r19ps_qrusogfi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teste padrão - .NET Core O</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
segundo arquivo de configuração é este </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este arquivo contém uma descrição de todas as dependências do aplicativo ou da Estrutura Compartilhada, ou da biblioteca, as bibliotecas </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">também o possuem. Ele contém todas as dependências, incluindo transitivas. E o comportamento do tempo de execução do .NET Core difere dependendo se </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o aplicativo o possui ou não. Caso </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contrário, o aplicativo poderá carregar todos os assemblies que estão em sua Estrutura Compartilhada ou em seu diretório BIN. Se houver </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a validação será ativada. Se um dos assemblies listados </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não estiver, o aplicativo simplesmente não será iniciado. Você verá o erro apresentado acima. Se o aplicativo tentar carregar algum assembly em tempo de execução, o que</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se, por exemplo, usando métodos de carregamento de montagem ou durante o processo de resolução de montagens, você verá um erro muito semelhante ao carregamento restrito de montagem.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetbrains rider</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rider é um IDE .NET. Nem todo mundo sabe que o Rider é um IDE que consiste em um front-end baseado no IntelliJ IDEA e escrito em Java e Kotlin, e um back-end. O back-end é essencialmente R #, que pode se comunicar com o IntelliJ IDEA. Esse back-end é um aplicativo .NET multiplataforma agora. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para onde ele funciona? O Windows usa o .NET Framework, que está instalado no computador do usuário. Em outros sistemas de informação, no Linux e Mac, o Mono é usado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa não é uma solução ideal quando há tempos de execução diferentes em todos os lugares, e eu quero ir para o próximo estado para que o Rider seja executado no .NET Core. Para melhorar o desempenho, porque no .NET Core todos os recursos mais recentes estão associados a isso. Para reduzir o consumo de memória. Agora, há um problema com o modo como o Mono trabalha com memória.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A mudança para o .NET Core permitirá que você abandone as tecnologias herdadas e não suportadas e corrija algumas correções para os problemas encontrados no tempo de execução. </font><font style="vertical-align: inherit;">A mudança para o .NET Core permitirá que você controle a versão do tempo de execução, ou seja, o Rider não será mais executado no .NET Framework instalado no computador do usuário, mas em uma versão específica do .NET Core, que pode ser banida, na forma de uma implantação autônoma. </font><font style="vertical-align: inherit;">A transição para o .NET Core eventualmente permitirá o uso de novas APIs importadas especificamente no Core. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, o objetivo é lançar um protótipo, iniciá-lo, apenas para verificar como ele funcionará, quais são os possíveis pontos de falha, quais componentes terão que ser reescritos novamente, o que exigirá processamento global.</font></font><br>
<br>
<a name="rider"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recursos que dificultam a tradução do Rider para o .NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Visual Studio, mesmo que o R # não esteja instalado, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trava de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> falta </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">de memória em soluções grandes, nas quais existem projetos com * .csproj no estilo SDK</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">O estilo SDK * .csproj é uma das principais condições para uma realocação completa do .NET Core. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é um problema porque o Rider é baseado em R #, eles vivem no mesmo repositório, os desenvolvedores de R # desejam usar o Visual Studio para desenvolver seu próprio produto em seu produto, a fim de torná-lo um alimento. </font><font style="vertical-align: inherit;">No R #, existem links para bibliotecas específicas para a estrutura com a qual você precisa fazer algo. </font><font style="vertical-align: inherit;">No Windows, podemos usar o Framework para aplicativos de desktop e, no Linux e Mac, o Mock já é usado para bibliotecas do Windows com funcionalidade mínima.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decisão</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Decidimos permanecer nos antigos por enquanto </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, montando sob o Framework completo, mas como os assemblies do Framework e Core são compatíveis com binários, execute-os no Core. </font><font style="vertical-align: inherit;">Não usamos recursos incompatíveis, adicionamos todos os arquivos de configuração necessários manualmente e baixamos versões especiais de dependências para o .NET Core, se houver.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para quais hacks você teve que ir?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um truque: queremos chamar um método que esteja disponível apenas no Framework, por exemplo, esse método é necessário em R #, mas não no Core. </font><font style="vertical-align: inherit;">O problema é que, se não houver método, o método que o chama durante a compilação JIT cairá mais cedo </font></font><code>MissingMethodException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ou seja, um método que não existe estragou o método que o chama.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>(<span class="hljs-params"></span>)</span> { 
  <span class="hljs-keyword">if</span> (NetFramework) <font></font>
     CallNETFrameworkOnlyMethod();<font></font>
<font></font>
  ... <font></font>
} <font></font>
[<span class="hljs-meta">MethodImpl(MethodImplOptions.NoInlining)</span>] 
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallNETFrameworkOnlyMethod</span>(<span class="hljs-params"></span>)</span> { <font></font>
  NETFrameworkOnlyMethod(); <font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A solução está aqui: fazemos chamadas para métodos incompatíveis em métodos separados. Há mais um problema: esse método pode ficar embutido, portanto, marcamos com um atributo </font></font><code>NoInlining</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hack número dois: precisamos ser capazes de carregar assemblies em caminhos relativos. Temos um assembly para o Framework, existe uma versão especial para o .NET Core. Como fazemos o download da versão do .NET Core para o .NET Core? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qm/zm/w7/qmzmw79gtllee8uyswgrn0oqnum.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eles vão nos ajudar </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Vamos dar uma olhada na </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biblioteca System.Diagnostics.PerformanceCounter. Tal biblioteca é notável em termos de</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Possui uma seção de tempo de execução, na qual é indicada uma versão da biblioteca com seu caminho relativo. Nesta biblioteca, o assembly será carregado em todos os tempos de execução e apenas lança as execuções. Se, por exemplo, ele for carregado no Linux, o PerformanceCounter não funcionará no design do Linux e uma PlatformNotSupportedException voará de lá. Há também </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma seção runtimeTargets e aqui já está indicada a versão deste assembly especificamente para Windows, onde o PerformanceCounter deve funcionar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se pegarmos a seção de tempo de execução e escrevermos nela o caminho relativo para a biblioteca que queremos carregar, isso não nos ajudará. A seção de tempo de execução realmente define o caminho relativo dentro do pacote NuGet, e não em relação ao BIN. Se procurarmos por esse assembly no BIN, somente o nome do arquivo será usado a partir daí. A seção runtimeTargets já contém um caminho relativo honesto, um caminho honesto em relação ao BIN. Vamos prescrever um caminho relativo para nossos assemblies na seção runtimeTargets. Em vez do identificador de tempo de execução, que é "win" aqui, podemos usar outro que gostamos. Por exemplo, escreveremos o identificador de tempo de execução “any” e esse assembly será carregado geralmente em todas as plataformas. Ou então, escreveremos “unix”, e ele inicializará no Linux e no Mac, e assim por diante.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Próximo corte: queremos fazer o download no Linux e no Mac Mock para criar o WindowsBase. O problema é que o assembly chamado WindowsBase já está presente na Estrutura Compartilhada </font></font><code>Microsoft.NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mesmo que não estejamos no Windows. No Windows Shared Framework, o </font></font><code>Microsoft.WindowsDesktop.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowsBase redefine a versão em que está </font></font><code>NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Vamos dar uma olhada </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nesses Framework, mais precisamente nas seções que descrevem o WindowsBase. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gc/ox/f3/gcoxf3q7mbfm_a9hzmcujfin5zc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está a diferença: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5q/pz/wq/5qpzwq-n21m38b_0xedi9txpwoc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
se alguma biblioteca entra em conflito e está presente em várias </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o máximo delas é selecionado para o par que consiste em </font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O guia .NET diz que </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é necessário apenas mostrá-lo no Windows Explorer, mas não é, ele se encaixa</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este é o único caso que eu conheço quando a versão prescrita em </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, é realmente usada. Em todos os outros casos, vi um comportamento em que, independentemente das versões </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escritas, o assembly continuava carregando de qualquer maneira. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/re/j8/bwrej8fa8_gyuyvcjnt3ixvljce.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quarto hack. Tarefa: temos um arquivo .deps.json para os dois hacks anteriores e precisamos dele apenas para dependências específicas. Como eles são </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gerados no modo semi-manual, temos um script que, de acordo com alguma descrição do que deve chegar lá, o gera durante a compilação, queremos manter isso o </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mínimo possível para que possamos entender o que está nele. Queremos desativar a validação e permitir o download de montagens que estão no BIN, mas que não estão descritas em </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solução: ative a configuração personalizada em runtimeconfig. </font><font style="vertical-align: inherit;">Essa configuração é realmente necessária para compatibilidade com versões anteriores do .NET Core 1.0.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">achados</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então, </font></font><code>.runtime.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no .NET Core - esses são tipos de análogos </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permitem fazer o mesmo, por exemplo, carregar montagens de maneiras relativas. </font><font style="vertical-align: inherit;">Usando </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, reescrevendo-o manualmente, você pode personalizar o carregamento de assemblies no .NET Core, se você tiver um cenário muito complexo.</font></font><a name="load"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depurar downloads de assembly</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu falei sobre alguns tipos de problemas, então você precisa ser capaz de depurar problemas ao carregar assemblies. </font><font style="vertical-align: inherit;">O que pode ajudar nisso? </font><font style="vertical-align: inherit;">Primeiro, os tempos de execução escrevem logs sobre como eles carregam assemblies. </font><font style="vertical-align: inherit;">Em segundo lugar, você pode olhar mais de perto as execuções que voam para você. </font><font style="vertical-align: inherit;">Você também pode se concentrar em eventos de tempo de execução.</font></font><a name="fusion"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logs de fusão</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/jl/4v/be/jl4vbeqsyjzmab2rx0xvdg-lpi4.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De volta ao básico: Usando o Fusion Log Viewer para depurar erros obscuros </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusion</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
O mecanismo para carregar assemblies no .NET Framework é chamado Fusion e ele sabe como registrar o que fez no disco. Para habilitar o log, você precisa adicionar configurações especiais ao registro. Isso não é muito conveniente, por isso faz sentido usar utilitários, como o Fusion Log Viewer e o Fusion ++. O Fusion Log Viewer é um utilitário padrão que acompanha o Visual Studio e pode ser iniciado na linha de comando do Visual Studio, Prompt de Comando do Visual Studio Developer. O Fusion ++ é um análogo de código aberto desta ferramenta com uma interface melhor.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ou/9h/bt/ou9hbtdgx1yjp6rjjdm3q61efpu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Fusion Log Viewer fica assim. Isso é pior que o WinDbg porque essa janela nem se estende. No entanto, você pode perfurar as marcas de verificação aqui, embora nem sempre seja óbvio qual conjunto de marcas de verificação está correto. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gu/h2/by/guh2byfmgazm8yvbxfa_jhf25wo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Fusion ++ possui um botão "Iniciar registro" e, em seguida, o botão "Interromper registro" é exibido. Nele, você pode ver todos os registros sobre o carregamento de montagens, ler os logs sobre o que exatamente estava acontecendo. Esses logs são parecidos com isso de maneira concisa.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zf/ep/5m/zfep5myuovdov4t7mmtw4czhwqc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta é uma isenção do carregamento rigoroso da montagem. </font><font style="vertical-align: inherit;">Se olharmos para os logs do Fusion, veremos que precisávamos baixar a versão 9.0.0.0 depois de processarmos todas as configurações. </font><font style="vertical-align: inherit;">Encontramos um arquivo no qual suspeita-se que temos a montagem de que precisamos. </font><font style="vertical-align: inherit;">Vimos que a versão 6.0.0.0 está neste arquivo. </font><font style="vertical-align: inherit;">Temos um aviso de que comparamos os nomes completos das assembléias e elas diferem na versão principal. </font><font style="vertical-align: inherit;">E, em seguida, ocorreu um erro - incompatibilidade de versão.</font></font><a name="events"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eventos de tempo de execução</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/pu/np/bn/punpbnrdvfv_mm5bpweej75ofq8.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registrando eventos de tempo de execução</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
No Mono, você pode ativar o registro usando variáveis ​​de ambiente, e os registros serão gravados em </font></font><code>stdout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Não é tão conveniente, mas a solução está funcionando. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rj/vv/g9/rjvvg9dfv0ji5sbxm_crgu3ok0a.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Análise padrão - </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentação do </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">.NET Core </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">/ documentos de design / rastreamento de host.O</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
.NET Core também possui uma variável de ambiente especial </font></font><code>COREHOST_TRACE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que inclui o logon </font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Com o .NET Core 3.0, você pode gravar logs em um arquivo, especificando o caminho para ele em uma variável </font></font><code>COREHOST_TRACEFILE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<img src="https://habrastorage.org/webt/eo/b5/yf/eob5yf90z7cgilees68uxtrhw0w.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há um evento que é acionado quando os conjuntos falham ao carregar. Este é um evento </font></font><code>AssembleResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Há um segundo evento útil, esse </font></font><code>FirstChanceException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Você pode se inscrever e obter um erro sobre o carregamento de assemblies, mesmo que alguém tenha escrito try..catch e tenha perdido todas as execuções no local em que</font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ocorreu. </font><font style="vertical-align: inherit;">Se o aplicativo já tiver sido compilado, você poderá iniciá-lo </font></font><code>perfview</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e monitorar as execuções do .NET, e poderá encontrar as relacionadas ao download de arquivos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">achados</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transfira o trabalho para ferramentas, ferramentas de desenvolvimento, para um IDE, para MSBuild, o que permite gerar redirecionamentos. </font><font style="vertical-align: inherit;">Você pode mudar para o .NET Core, depois esquecerá o que é o Strict Assembly Loading, e poderá usar a nova API exatamente como queremos alcançar no Rider. </font><font style="vertical-align: inherit;">Se você conectar a biblioteca .NET Standard, aumente a versão de destino do .NET Framework para pelo menos 4.7.1. </font><font style="vertical-align: inherit;">Se você parece estar em uma situação sem esperança, procure por hacks, use-os ou crie seus próprios hacks para situações sem esperança. </font><font style="vertical-align: inherit;">E arme-se com ferramentas de depuração. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu recomendo fortemente que você leia os seguintes links:</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">.NET Guide</a>;</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     .NET Core</a>.</li>
</ul><br>
<br>
<blockquote>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DotNext 2020 Piter</a> .       ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> 8   JUG Ru Group</a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt499824/index.html">Resumo dos eventos para recrutadores de RH e TI em maio de 2020</a></li>
<li><a href="../pt499826/index.html">Pressão arterial distribuída</a></li>
<li><a href="../pt499832/index.html">Como organizar com rapidez e segurança o trabalho remoto dos funcionários? Falamos sobre diferentes abordagens: com VDI e não apenas</a></li>
<li><a href="../pt499834/index.html">Conheça o aritmômetro Felix</a></li>
<li><a href="../pt499836/index.html">Udalenka vs. escritório para a equipe de desenvolvimento</a></li>
<li><a href="../pt499842/index.html">Por que as pessoas reaprendem</a></li>
<li><a href="../pt499846/index.html">Quando a coleta de lixo separada começará a funcionar e por que é necessário o monitoramento em vídeo de sites para contêineres de lixo</a></li>
<li><a href="../pt499850/index.html">Como analisar os concorrentes e estabelecer uma estratégia digital em 40 minutos</a></li>
<li><a href="../pt499852/index.html">Documentação em inglês para Angular</a></li>
<li><a href="../pt499854/index.html">Apache Bigtop e a escolha da distribuição do Hadoop hoje</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>