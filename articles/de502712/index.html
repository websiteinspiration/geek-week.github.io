<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💒 🍔 👴🏼 Wie funktioniert ein Adress-LED-Streifen? 🙋🏻 🤞🏿 〽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wahrscheinlich erscheint diese Frage "Wie funktioniert es?" Vielen albern. Die Antwort liegt auf der Hand: Ein adressierbarer LED-Streifen besteht aus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wie funktioniert ein Adress-LED-Streifen?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502712/"><img src="https://habrastorage.org/webt/vo/6r/d2/vo6rd2jupdaxgzun1zl3_iyp-k4.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wahrscheinlich erscheint diese Frage "Wie funktioniert es?" Vielen albern. Die Antwort liegt auf der Hand: Ein adressierbarer LED-Streifen besteht aus mehreren in Reihe geschalteten „Smart LEDs“. Dies kann einfach durch Betrachten des Bandgeräts gesehen werden. Sie können einzelne Mikroschaltungen sehen, die an ein flexibles Kabel gelötet sind, Sie können die Verbindungen sehen: Mikroschaltungen sind mit nur drei Drähten in Reihe geschaltet, und zwei davon sind Strom und Masse. Nur ein Draht überträgt Pixelfarbdaten. Wie ist das? Was ist eine intelligente LED? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes werde ich über das Datenübertragungsprotokoll sprechen, das in dem auf WS2812B basierenden LED-Streifen verwendet wird, und außerdem werde ich fast meinen eigenen „LED-Streifen-Chip“ im FPGA-Chip erstellen.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Band verwendet also eine serielle Übertragung über ein einzelnes Datensignal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bit Null wird als kurzer positiver Impuls und als Pause übertragen, die ungefähr zweimal breiter als der Impuls ist. Die Biteinheit wird als breiter positiver Impuls und kurze Pause übertragen: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6n/e9/d-/6ne9d-mfj_ah8zurj1i6fnrevgy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn keine Übertragung von mehr als 50 Mikrosekunden erfolgt, kehrt das Band in seinen ursprünglichen Zustand zurück und ist bereit, Pixel ab dem ersten zu akzeptieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle 24 Bits in einer Sequenz sind 3 Bytes für drei RGB-Farben. Und tatsächlich wird die Sequenz GRB sein. Das hohe Bit von G7 steht an erster Stelle.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Sequenz der ersten 24 Bits ist ein Pixel, das die allererste LED im Band empfängt. Bis die erste LED gesättigt ist, werden keine Daten weiter zur nächsten LED übertragen. Nachdem die erste LED ihren Teil von 24x RGB-Bits empfangen hat, öffnet sie die Übertragung zur nächsten. Primitiv kann man sich eine Folge von LEDs als eine Kaskade von Krügen vorstellen, die nacheinander mit Wasser gefüllt werden: Die </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pv/8d/rz/pv8drz6goxvaujnutaw38e0tvbi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
erste, dann die zweite, dann die dritte und so weiter füllen sich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher glaube ich, dass das Übertragungsprotokoll aussortiert wurde.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ist es möglich, eine solche „intelligente LED“ selbst zu entwerfen? Das macht natürlich wenig Sinn, aber für die Selbstbildung und die Erweiterung des eigenen Horizonts ist dies eine interessante Aufgabe. Versuchen wir, die Logik des Chips in der Programmiersprache Verilog HDL zu beschreiben. Natürlich wird dies kein echtes Chip-Design sein, es wird Einschränkungen geben. Eine der wichtigsten Einschränkungen - Ich benötige eine externe Uhr für meine Mikroschaltung. In einer echten intelligenten LED existiert ein solcher Generator ebenfalls, der jedoch bereits in den Chip integriert ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Starten wir das Verilog-Modul folgendermaßen:</font></font><br>
<br>
<pre><code class="vhdl hljs">module WS2812B(<font></font>
	input wire clk,<font></font>
	input wire <span class="hljs-keyword">in</span>,<font></font>
	output wire <span class="hljs-keyword">out</span>,<font></font>
	output reg r,<font></font>
	output reg g,<font></font>
	output reg b<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke, hier ist alles klar: die Taktfrequenz von clk, die Eingangs- und Ausgangssignale der „Smart LED“ ein und aus und natürlich die Ausgangssignale r, g, b, über die ich die realen externen LEDs in rot, grün und blau steuern werde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde das Eingangssignal in einem Zwei-Bit-Schieberegister erfassen und aus dem aktuellen Zustand in diesen erfassten Bits kann ich den Beginn einer positiven Flanke des Signals bestimmen in:</font></font><br>
<br>
<pre><code class="vhdl hljs">reg [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]r_in = <span class="hljs-number">0</span>;<font></font>
always @( posedge clk )<font></font>
	r_in &lt;= { r_in[<span class="hljs-number">0</span>],<span class="hljs-keyword">in</span> };<font></font>
<font></font>
wire in_pos_edge; assign in_pos_edge = (r_in==<span class="hljs-number">2</span><span class="hljs-symbol">'b01</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus ist es wichtig, den Status des Bandresets zu ermitteln, wenn der Steuercontroller vor dem Starten einer neuen Übertragung angehalten wird:</font></font><br>
<br>
<pre><code class="vhdl hljs">localparam reset_level = <span class="hljs-number">3000</span>;<font></font>
reg [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]reset_counter = <span class="hljs-number">0</span>;<font></font>
always @( posedge clk )<font></font>
	<span class="hljs-keyword">if</span>( r_in[<span class="hljs-number">0</span>] )<font></font>
		reset_counter &lt;= <span class="hljs-number">0</span>;
	<span class="hljs-keyword">else</span>
	<span class="hljs-keyword">if</span>( reset_counter&lt;reset_level )<font></font>
		reset_counter &lt;= reset_counter+<span class="hljs-number">1</span>;<font></font>
<font></font>
wire reset; assign reset = (reset_counter==reset_level);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ab einer positiven Flanke in_pos_edge ist es außerdem erforderlich, eine Pause zu überstehen, um den Moment des Fixierens eines neuen Bits zu erhalten:</font></font><br>
<br>
<pre><code class="vhdl hljs">localparam fix_level   = <span class="hljs-number">50</span>;<font></font>
reg [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]bit_length_cnt;<font></font>
always @( posedge clk )<font></font>
	<span class="hljs-keyword">if</span>( in_pos_edge )<font></font>
		bit_length_cnt &lt;= <span class="hljs-number">0</span>;
	<span class="hljs-keyword">else</span>
	<span class="hljs-keyword">if</span>( bit_length_cnt&lt;(fix_level+<span class="hljs-number">1</span>) &amp;&amp; !pass )<font></font>
		bit_length_cnt &lt;= bit_length_cnt + <span class="hljs-number">1</span>;<font></font>
<font></font>
wire bit_fix; assign bit_fix = (bit_length_cnt==fix_level);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anzahl der bereits empfangenen Bits im Chip wird wie folgt betrachtet:</font></font><br>
<br>
<pre><code class="vhdl hljs">reg pass = <span class="hljs-number">0</span>;<font></font>
reg [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>]bits_captured = <span class="hljs-number">0</span>;<font></font>
<font></font>
always @( posedge clk )<font></font>
	<span class="hljs-keyword">if</span>( reset )<font></font>
		bits_captured &lt;= <span class="hljs-number">1</span><span class="hljs-symbol">'b0</span>;
	<span class="hljs-keyword">else</span>
	<span class="hljs-keyword">if</span>( ~pass &amp;&amp; bit_fix )<font></font>
		bits_captured &lt;= bits_captured+<span class="hljs-number">1</span><span class="hljs-symbol">'b1</span>;</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier wird ein wichtiges Durchgangssignal eingeführt, das lediglich die Umleitung des Eingangsstroms zum Ausgang bestimmt. </font><font style="vertical-align: inherit;">Nach dem Akzeptieren des 24x-Pixelbits wird das Durchlasssignal auf eins gesetzt:</font></font><br>
<br>
<pre><code class="vhdl hljs">always @( posedge clk )
	<span class="hljs-keyword">if</span>( reset )<font></font>
		pass &lt;= <span class="hljs-number">1</span><span class="hljs-symbol">'b0</span>;
	<span class="hljs-keyword">else</span>
	<span class="hljs-keyword">if</span>( bits_captured==<span class="hljs-number">23</span> &amp;&amp; bit_fix )<font></font>
		pass &lt;= <span class="hljs-number">1</span><span class="hljs-symbol">'b1</span>;<font></font>
		<font></font>
reg pass_final;<font></font>
always @( posedge clk )<font></font>
	<span class="hljs-keyword">if</span>( reset )<font></font>
		pass_final &lt;= <span class="hljs-number">1</span><span class="hljs-symbol">'b0</span>;
	<span class="hljs-keyword">else</span>
	<span class="hljs-keyword">if</span>( r_in!=<span class="hljs-number">2</span><span class="hljs-symbol">'b11</span> )<font></font>
		pass_final &lt;= pass;<font></font>
		<font></font>
assign <span class="hljs-keyword">out</span> = pass_final ? <span class="hljs-keyword">in</span> : <span class="hljs-number">1</span><span class="hljs-symbol">'b0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Eingangsausgang wird mit dem Ausgangsausgang gemultiplext, wenn das Signal pass_final eins ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, natürlich brauchen wir ein Schieberegister, in dem die empfangenen 24 Bits des Pixels akkumuliert werden:</font></font><br>
<br>
<pre><code class="vhdl hljs">reg [<span class="hljs-number">23</span>:<span class="hljs-number">0</span>]shift_rgb;<font></font>
always @( posedge clk )<font></font>
	<span class="hljs-keyword">if</span>( bit_fix )<font></font>
		shift_rgb &lt;= { <span class="hljs-keyword">in</span>, shift_rgb[<span class="hljs-number">23</span>:<span class="hljs-number">1</span>] };<font></font>
<font></font>
reg [<span class="hljs-number">23</span>:<span class="hljs-number">0</span>]fix_rgb;<font></font>
always @( posedge clk )<font></font>
	<span class="hljs-keyword">if</span>( bits_captured==<span class="hljs-number">23</span> &amp;&amp; bit_fix )<font></font>
		fix_rgb &lt;= { <span class="hljs-keyword">in</span>, shift_rgb[<span class="hljs-number">23</span>:<span class="hljs-number">1</span>] };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Empfang aller 24 Bits werden diese ebenfalls in das endgültige 24-Bit-Register kopiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt bleibt die Sache klein. </font><font style="vertical-align: inherit;">Es ist erforderlich, ein PWM-Signal (Latitudinal Pulse Modulation) zu implementieren, um die Helligkeit gemäß den empfangenen RGB-Bytes an echte externe LEDs zu übertragen:</font></font><br>
<br>
<pre><code class="vhdl hljs">wire [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]wgreen; assign wgreen = { fix_rgb[<span class="hljs-number">0</span> ], fix_rgb[<span class="hljs-number">1</span> ], fix_rgb[<span class="hljs-number">2</span> ], fix_rgb[<span class="hljs-number">3</span> ], fix_rgb[<span class="hljs-number">4</span> ], fix_rgb[<span class="hljs-number">5</span> ], fix_rgb[<span class="hljs-number">6</span> ], fix_rgb[<span class="hljs-number">7</span> ] };<font></font>
wire [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]wred;   assign wred   = { fix_rgb[<span class="hljs-number">8</span> ], fix_rgb[<span class="hljs-number">9</span> ], fix_rgb[<span class="hljs-number">10</span>], fix_rgb[<span class="hljs-number">11</span>], fix_rgb[<span class="hljs-number">12</span>], fix_rgb[<span class="hljs-number">13</span>], fix_rgb[<span class="hljs-number">14</span>], fix_rgb[<span class="hljs-number">15</span>] };<font></font>
wire [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]wblue;  assign wblue  = { fix_rgb[<span class="hljs-number">16</span>], fix_rgb[<span class="hljs-number">17</span>], fix_rgb[<span class="hljs-number">18</span>], fix_rgb[<span class="hljs-number">19</span>], fix_rgb[<span class="hljs-number">20</span>], fix_rgb[<span class="hljs-number">21</span>], fix_rgb[<span class="hljs-number">22</span>], fix_rgb[<span class="hljs-number">23</span>] };<font></font>
<font></font>
reg [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]pwm_cnt;<font></font>
<font></font>
always @( posedge clk )<font></font>
<span class="hljs-keyword">begin</span>
	pwm_cnt &lt;= pwm_cnt+<span class="hljs-number">1</span>;<font></font>
	r &lt;= pwm_cnt&lt;wred;<font></font>
	g &lt;= pwm_cnt&lt;wgreen;<font></font>
	b &lt;= pwm_cnt&lt;wblue;<font></font>
<span class="hljs-keyword">end</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das scheint alles zu sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein kleines Detail bleibt - wie kann man das alles erleben? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe ein paar einfache Motherboards mit dem FPGA MAX II (dies sind die Karten der Mars Rover-Serie) genommen und sie alle mit einem Projekt mit diesem Verilog-Code aktualisiert. Es gab bereits 8 LEDs auf den Platinen, aber sie waren alle gelb. Auf jeder der Karten habe ich 3 LEDs durch R, G, B ersetzt. Ich habe die Karten in Reihe geschaltet und sie außerdem mit einem echten LED-Streifen verbunden. So habe ich das echte Band mit meinen selbstgemachten LEDs verlängert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Verbindung stellte sich folgendermaßen heraus: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-u/5k/sh/-u5kshz_kj4zwuj1uewj7wstrdk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Wirklichkeit sieht es so aus: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v1/rm/qt/v1rmqtb1_pbswak3fy8ewtl0-k0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ich nun ein bestimmtes Bild auf das Band anwende, sehe ich, dass sich meine „intelligenten LEDs“ genauso verhalten wie die echten vom Band:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/s7GkTgyDVCc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich heraus, dass die Logik, die ich im FPGA implementiert habe, voll funktionsfähig ist! </font><font style="vertical-align: inherit;">In erster Näherung konnte ich etwas Ähnliches wie einen echten intelligenten LED-Chip tun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eigentlich mag ich LED-Streifen. </font><font style="vertical-align: inherit;">Jeder kann auf seiner Basis etwas Eigenes erfinden: intelligente Beleuchtung, Bildschirme, Ambilight-Effekte. </font><font style="vertical-align: inherit;">Einmal habe ich sogar Farbmusik auf einem LED-Band mit FPGA implementiert. </font><font style="vertical-align: inherit;">Aber das ist eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andere Geschichte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de502696/index.html">Wie Internetdienstanbieter einen globalen Stromausfall bei Ausbrüchen vermeiden</a></li>
<li><a href="../de502700/index.html">Stack Overflow Creator: „Entwickler sind diejenigen, die das Skript für die Zukunft schreiben.“</a></li>
<li><a href="../de502702/index.html">Informationen zum Speichern von JWT-Token in Browsern</a></li>
<li><a href="../de502704/index.html">Wie wir die Unterstützung umgeschult haben, um menschlich zu sprechen, und was passiert ist</a></li>
<li><a href="../de502706/index.html">Der Zustand der Soft Skills</a></li>
<li><a href="../de502714/index.html">Exportieren Sie OpenStreetMap-Daten mit dem visuellen Editor auf rete.js.</a></li>
<li><a href="../de502716/index.html">Sie können Ihren Heimcomputer nicht freigeben? Machen Sie eins aus zwei</a></li>
<li><a href="../de502718/index.html">Das Talking Head-Projekt oder die Geschichte der Entwicklung von Software für einen Telepräsenzroboter</a></li>
<li><a href="../de502720/index.html">Testen von Trends für 2020</a></li>
<li><a href="../de502722/index.html">Silicon Valley auf Russisch. Wie # ITX5 in Innopolis funktioniert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>