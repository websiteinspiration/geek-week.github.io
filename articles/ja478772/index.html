<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚲 🍘 🌱 畳み込みテクスチャ 🍕 🧑🏿‍🤝‍🧑🏽 🦀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="自己更新テクスチャ
 シミュレーションまたはレンダリングタスクを並列化できる場合は、通常、それらをGPUで実行するのが最善です。この記事では、この事実を利用して、パフォーマンスのオーバーヘッドが少ない印象的なビジュアルトリックを作成する手法について説明します。私がデモンストレーションするすべてのエフ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>畳み込みテクスチャ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478772/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自己更新テクスチャ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シミュレーションまたはレンダリングタスクを並列化できる場合は、通常、それらをGPUで実行するのが最善です。この記事では、この事実を利用して、パフォーマンスのオーバーヘッドが少ない印象的なビジュアルトリックを作成する手法について説明します。私がデモンストレーションするすべてのエフェクトは、テクスチャを使用して実装されます。テクスチャは、更新されると「</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリング</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」されます。新しいフレームがレンダリングされるとテクスチャが更新され、次のテクスチャの状態は前の状態に完全に依存します。これらのテクスチャでは、描画して特定の変更を引き起こし、テクスチャ自体を直接または間接的に使用して、興味深いアニメーションをレンダリングできます。私はそれらを</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">畳み込みテクスチャ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼び</font><em><font style="vertical-align: inherit;">ます</font></em><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/756/a1a/005/756a1a0051471cbe895a8883d89efadd.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図1：畳み込みテクスチャのダブルバッファリング先に進む</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
前に、1つの問題を解決する必要があります。テクスチャを同時に読み書きできないため、OpenGLやDirectXなどのグラフィックAPIではこれが許可されていません。テクスチャの次の状態は前の状態に依存するため、この制限をどうにかして回避する必要があります。書いているのではなく、別のテクスチャから読み取る必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決策は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダブルバッファリング</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。図1はそれがどのように機能するかを示しています。実際には、1つのテクスチャの代わりに2つありますが、1つは書き込み、もう1つは他から読み取られます。書き込まれるテクスチャは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックバッファ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">、レンダリングテクスチャは</font><em><font style="vertical-align: inherit;">フロントバッファ</font></em><font style="vertical-align: inherit;">と呼ばれます</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（一次バッファー）。</font><font style="vertical-align: inherit;">たたみ込みテストは「それ自体に書き込まれる」ため、各フレームのセカンダリバッファーがプライマリバッファーに書き込み、プライマリがレンダリングされるか、レンダリングに使用されます。</font><font style="vertical-align: inherit;">次のフレームでは、役割が変更され、前のプライマリバッファが次のプライマリバッファのソースとして使用されます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フラグメントシェーダー（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment Aシェーダー</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）（または</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピクセルシェーダー</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を使用して以前の状態を新しい畳み込みテクスチャにレンダリングするため、</font><font style="vertical-align: inherit;">興味深い効果とアニメーションが提供されます。</font><font style="vertical-align: inherit;">シェーダーは、状態がどのように変化するかを決定します。</font><font style="vertical-align: inherit;">記事のすべての例（およびその他）のソースコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">リポジトリにあります</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単な応用例</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この手法を示すために、更新時に状態が以前の状態に完全に依存する、よく知られたシミュレーションを選択しました。それは、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンウェイゲームの「ライフ」</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">このシミュレーションは、各セルが生きているか死んでいる正方形のグリッドで実行されます。</font><font style="vertical-align: inherit;">次のセル状態のルールは簡単です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生きている細胞の隣接細胞が2つより少ないが、死んでしまった場合。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生きている細胞に2つまたは3つの生きている隣人がいる場合、生きたままです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生きている細胞に生きている隣人が4人以上いる場合、死んでしまいます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">死んだ細胞に3つの生きている隣人がいる場合、それは生きています</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このゲームを畳み込みテクスチャとして実装するために、テクスチャをゲームのグリッドとして解釈し、シェーダーは上記のルールに基づいてレンダリングします。透明なピクセルは死んだ細胞であり、白い不透明なピクセルは生きている細胞です。インタラクティブな実装を以下に示します。 GPUにアクセスするに</font><font style="vertical-align: inherit;">は、</font><em><font style="vertical-align: inherit;">WebGL 2</font></em><font style="vertical-align: inherit;">を必要</font><font style="vertical-align: inherit;">とする</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">myr.js</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用します</font><font style="vertical-align: inherit;">。最近のほとんどのブラウザー（たとえば、ChromeやFirefox）はこれで動作しますが、デモが機能しない場合は、ブラウザーがサポートしていない可能性があります。マウス（またはタッチスクリーン）[元の記事]を使用して、テクスチャ上に生細胞を描きます。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/SQ3EKUPm8FY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フラグメントシェーダーコード（GLSLでは、レンダリングにWebGLを使用しているため）を以下に示します。</font><font style="vertical-align: inherit;">まず、</font></font><code>get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電流からの特定のオフセットからピクセルを読み取ることができる</font><font style="vertical-align: inherit;">関数を実装します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">変数</font></font><code>pixelSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、各ピクセルのUVオフセットを含む事前に作成された2Dベクトルであり、関数</font></font><code>get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はそれを使用して隣接セルを読み取ります。</font><font style="vertical-align: inherit;">次に、関数</font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は現在の状態（</font></font><code>live</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）と生存している隣接</font><font style="vertical-align: inherit;">セルの数に基づいて、セルの新しい色を決定し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs">uniform sampler2D source;<font></font>
uniform lowp vec2 pixelSize;<font></font>
<font></font>
in mediump vec2 uv;<font></font>
<font></font>
layout (location = <span class="hljs-number">0</span>) out lowp vec4 color;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dx, <span class="hljs-keyword">int</span> dy)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">int</span>(texture(source, uv + pixelSize * vec2(dx, dy)).r);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> live = get(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">int</span> neighbors =<font></font>
        get(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>) +<font></font>
        get(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>) +<font></font>
        get(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>) +<font></font>
        get(<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>) +<font></font>
        get(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) +<font></font>
        get(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>) +<font></font>
        get(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) +<font></font>
        get(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (live == <span class="hljs-number">1</span> &amp;&amp; neighbors &lt; <span class="hljs-number">2</span>)<font></font>
        color = vec4(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (live == <span class="hljs-number">1</span> &amp;&amp; (neighbors == <span class="hljs-number">2</span> || neighbors == <span class="hljs-number">3</span>))<font></font>
        color = vec4(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (live == <span class="hljs-number">1</span> &amp;&amp; neighbors == <span class="hljs-number">3</span>)<font></font>
        color = vec4(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (live == <span class="hljs-number">0</span> &amp;&amp; neighbors == <span class="hljs-number">3</span>)<font></font>
        color = vec4(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">else</span>
        color = vec4(<span class="hljs-number">0</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの単純な畳み込みテクスチャは、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">落下砂を使用</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font><em><font style="vertical-align: inherit;">ゲーム</font></em><font style="vertical-align: inherit;">です。この</font><em><font style="vertical-align: inherit;">ゲームで</font></em><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">、ユーザーはカラフルな砂をシーンに投げることができ、落下して山を形成します。</font><font style="vertical-align: inherit;">その実装はもう少し複雑ですが、ルールはより単純です：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">砂粒の下に砂がない場合は、1ピクセル下に落ちます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">砂粒の下に砂があるが、45度左または右にスライドできる場合は、スライドします。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例のコントロールは、ゲーム「ライフ」と同じです。</font><font style="vertical-align: inherit;">このような規則の下では、プロセスをわずかに高速化するために、砂はフレームあたり1ピクセルの速度でのみ落下する可能性があるため、フレームあたりのテクスチャは3回更新されます。</font><font style="vertical-align: inherit;">アプリケーションのソースコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/MV10ScILiAY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一歩前進</font></font></h2><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チャネル</font></font></b></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">応用</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">赤</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">波の高さ</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">緑</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">波速</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">青い</font></font></td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用されていない</font></font></i></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルファ</font></font></td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用されていない</font></font></i></td>
</tr>
</tbody></table></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2：ピクセル波。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
上記の例では、畳み込みテクスチャを直接使用しています。その内容はそのまま画面に表示されます。画像をピクセルとしてのみ解釈する場合、この手法の使用の制限は非常に制限されますが、最新の機器のおかげで拡張できます。ピクセルを色としてカウントするのではなく、少し異なる方法で解釈します。これを使用して、さらに別のテクスチャまたは3Dモデルのアニメーションを作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、畳み込みテクスチャを高さマップとして解釈します。テクスチャは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">波</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><em><font style="vertical-align: inherit;">振動</font></em><font style="vertical-align: inherit;">をシミュレートし</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水平面上で、結果を使用して反射とシェーディングされた波をレンダリングします。テクスチャを画像として読み取る必要がなくなったため、そのピクセルを使用して情報を格納できます。ウォーターシェーダーの場合、図2に示すように、波の高さを赤のチャネルに保存し、波のパルスを緑のチャネルに保存します。青とアルファのチャネルはまだ使用されていません。波は、畳み込みテクスチャに赤いスポットを描くことによって作成されます。</font><font style="vertical-align: inherit;">インターネットから姿を消したと思われる</font><em><font style="vertical-align: inherit;">Hugo Elias</font></em></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
のウェブサイトから借りた高さマップの更新方法は考慮しません</font><font style="vertical-align: inherit;">。彼はまた、未知の作成者からこのアルゴリズムについて学び、CPUで実行するためにCに実装しました。以下のアプリケーションのソースコードは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">こちら</font></a><font style="vertical-align: inherit;">です。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/h8GjEGMV8AE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、テクスチャをオフセットしてシェーディングを追加するためだけに高さマップを使用しましたが、3番目の次元では、さらに興味深いアプリケーションを実装できます。畳み込みテクスチャが頂点シェーダーによって解釈されると、平らな細分割平面が変形して3次元の波が作成される可能性があります。結果のシェイプに通常のシェーディングとライティングを適用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例の畳み込みテクスチャのピクセルには、丸め誤差のために消えてはならない非常に小さな値が格納される場合があることに注意してください。</font><font style="vertical-align: inherit;">したがって、このテクスチャのカラーチャネルは、標準の8ビットではなく、より高い解像度を持つ必要があります。</font><font style="vertical-align: inherit;">この例では、各カラーチャネルのサイズを16ビットに増やしました。これにより、かなり正確な結果が得られました。</font><font style="vertical-align: inherit;">ピクセルを保存しない場合は、テクスチャの精度を上げる必要があることがよくあります。</font><font style="vertical-align: inherit;">さいわい、最新のグラフィックAPIはこの機能をサポートしています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのチャネルを使用します</font></font></h2><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チャネル</font></font></b></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">応用</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">赤</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xオフセット</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">緑</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yオフセット</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">青い</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X速度</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルファ</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yオフセット</font></font></td>
</tr>
</tbody></table></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3：ピクセルグラス。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
水の例では赤と緑のチャネルのみが使用されていますが、次の例では4つすべてを適用します。草（または木）のあるフィールドがシミュレートされ、カーソルを使用して移動できます。図3は、ピクセルに格納されているデータを示しています。オフセットは赤と緑のチャネルに保存され、速度は青とアルファのチャネルに保存されます。この速度は、波の動きが徐々にフェージングしながら静止位置にシフトするように更新されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
水を使用した例では、波の作成は非常に簡単です。テクスチャにスポットを描画でき、アルファブレンディングで滑らかな形状を実現できます。複数の重複するスポットを簡単に作成できます。この例では、アルファチャネルが既に使用されているため、すべてがトリッキーです。アルファが中央に1、端から0のスポットを描くことはできません。これは、グラスに不要なインパルスを与えるためです（垂直インパルスはアルファチャネルに格納されるため）。この場合、畳み込みテクスチャへの効果を描画するために、別のシェーダーが作成されました。このシェーダーは、アルファブレンディングで予期しない効果が発生しないようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションのソースコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/oBqQL7HViLE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラスは2Dで作成されますが、効果は3D環境で機能します。</font><font style="vertical-align: inherit;">ピクセル変位の代わりに、頂点がシフトされます。これも高速です。</font><font style="vertical-align: inherit;">また、ピークの助けを借りて、別の効果を実現できます：枝の強度が異なる-草はわずかな風で簡単に曲がり、強い木は嵐の間だけ振動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
風の影響と植生の変位を作成するアルゴリズムとシェーダーはたくさんありますが、このアプローチには重大な利点があります。</font><font style="vertical-align: inherit;">効果がゲームに適用される場合、植生の動きは何百もの異なる影響によって決定されます。</font><font style="vertical-align: inherit;">メインキャラクターだけでなく、すべてのオブジェクト、動物、動きがわずかなコストを犠牲にして世界に影響を与える可能性があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その他の使用例と欠陥</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、他にも多くのテクノロジーアプリケーションを考え出すことができます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">畳み込みテクスチャを使用して、風速をシミュレートできます。</font><font style="vertical-align: inherit;">テクスチャ上に、空気を周りに移動させる障害物を描くことができます。</font><font style="vertical-align: inherit;">パーティクル（雨、雪、葉）は、このテクスチャを使用して障害物を飛び回ることができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">煙や火の広がりをシミュレートできます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクスチャは、雪や砂の層の厚さをエンコードできます。</font><font style="vertical-align: inherit;">トレースやその他のレイヤーとの相互作用により、レイヤーにへこみや印刷が生じる可能性があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法を使用する場合、困難と制限があります。</font></font><br>
<br>
<ul>
<li>      . ,           —    .          ,  ,     ;      ,    .</li>
<li>   GPU —    ,       .  ,       ;    GPU,  GPU         .               (,      ),        .     GPU —   ,       .        :          ,         .   ,      .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事のデモはさらに最適化できます。</font><font style="vertical-align: inherit;">草の例では、目立った欠陥のない、はるかに低い解像度のテクスチャを使用できます。</font><font style="vertical-align: inherit;">これは大きなシーンで非常に役立ちます。</font><font style="vertical-align: inherit;">別の最適化：たとえば、4番目ごとのフレーム、またはフレームあたり4分の1で低いリフレッシュレートを使用できます（この手法はセグメント化された更新で問題を引き起こさないため）。</font><font style="vertical-align: inherit;">スムーズなフレームレートを維持するために、畳み込みテクスチャの以前の状態と現在の状態を補間できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
畳み込みテクスチャは内部のダブルバッファリングを使用するため、両方のテクスチャを同時にレンダリングに使用できます。</font><font style="vertical-align: inherit;">1次バッファーは現在の状態であり、2次バッファーは前の状態です。</font><font style="vertical-align: inherit;">これは、時間をかけてテクスチャを補間したり、テクスチャ値の導関数を計算したりするのに役立ちます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPUは、特に2Dプログラムでは、アイドル状態になることがよくあります。</font><font style="vertical-align: inherit;">複雑な3Dシーンのレンダリングにしか使用できないようですが、この記事で説明する手法は、GPUのパワーを使用する他の方法を少なくとも1つ示しています。</font><font style="vertical-align: inherit;">GPUが開発された機能を使用して、通常はCPUにコストがかかりすぎる興味深いエフェクトやアニメーションを実装できます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja478752/index.html">バージョン管理システムの歴史</a></li>
<li><a href="../ja478758/index.html">優れたUTMタグガイド：ユーザーがどこから来たのかを知る方法</a></li>
<li><a href="../ja478760/index.html">「ゼロ」地獄とそれから抜け出す方法</a></li>
<li><a href="../ja478764/index.html">JavaScriptエラー：修正、処理、修復</a></li>
<li><a href="../ja478766/index.html">Spring MVCコントローラーのマッピングをカスタマイズする</a></li>
<li><a href="../ja478774/index.html">Arduinoとスティックからの新年の気分</a></li>
<li><a href="../ja478778/index.html">ハブラ探偵とお祭り気分</a></li>
<li><a href="../ja478782/index.html">ロシア連邦でドローン（BVS、UAV）の飛行許可を取得</a></li>
<li><a href="../ja478788/index.html">ある王国では、「勢いのある」状態ではありません。Yandexレポート</a></li>
<li><a href="../ja478790/index.html">ジュリアと分布の意味</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>