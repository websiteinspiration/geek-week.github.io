<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📚 🤹🏻 🤙🏼 Visualización de cobertura de prueba automática 🕒 ⁉️ 👴🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los informes de cobertura modernos en algunos casos son bastante inútiles, y los métodos para medirlos son principalmente adecuados solo para desarrol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Visualización de cobertura de prueba automática</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/491844/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los informes de cobertura modernos en algunos casos son bastante inútiles, y los métodos para medirlos son principalmente adecuados solo para desarrolladores. </font><font style="vertical-align: inherit;">Siempre puede averiguar el porcentaje de cobertura o ver el código que no se utilizó durante las pruebas, pero ¿qué sucede si desea visibilidad, simplicidad y automatización? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_r/ms/rr/_rmsrr9pfqqgiu7vvskxe93g2po.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bajo el corte - video y transcripción de un informe de Artem Eroshenko de Qameta Software de la conferencia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heisenbug</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Introdujo varias soluciones simples y elegantes desarrolladas que ayudan al equipo de Yandex.Verticals a evaluar la cobertura de las pruebas escritas por ingenieros de automatización de pruebas. </font><font style="vertical-align: inherit;">Artem le dirá cómo descubrir rápidamente qué está cubierto, qué cubierto, qué pruebas han pasado y ver instantáneamente informes visuales.</font></font><br>
<br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/N2k4LKPWuSw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mi nombre es artyom eroshenko </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eroshenkoam</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, He estado haciendo pruebas de automatización por más de 10 años. </font><font style="vertical-align: inherit;">Fui gerente de automatización de pruebas, gerente de equipo de desarrollo de herramientas, desarrollador de herramientas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Actualmente soy consultor en el campo de la automatización de pruebas, trabajo con varias empresas con las que desarrollamos procesos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También soy el desarrollador y administrador secreto de Allure Report. </font><font style="vertical-align: inherit;">Recientemente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arreglamos algo genial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : ahora en JUnit 5 hay accesorios.</font></font><br>
<br>
<h2><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Marco Atlas</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mi desarrollo es el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atlas Framework</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si alguien comenzó a automatizar en 2012, cuando los controladores web de Java apenas comenzaban a funcionar, en ese momento hice una biblioteca de código abierto llamada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTML Elements</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Html Elements tiene su continuación y replanteamiento en la biblioteca Atlas, que se basa en interfaces: no hay clases como tales, no hay campos, una biblioteca muy conveniente, ligera y fácilmente extensible. Si desea comprenderlo, puede leer el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artículo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o ver el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">informe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mi informe está dedicado al problema de la automatización de pruebas y principalmente a los recubrimientos. Como antecedentes, me gustaría referirme a cómo se organizan los procesos de prueba en Yandex.Verticals.</font></font><br>
<br>
<h2><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cómo funciona la automatización en verticales?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solo hay cuatro personas en el equipo de automatización de pruebas de Yandex.Verticals que automatizan cuatro servicios: Yandex.Avto, Work, Real Estate y Parts. </font><font style="vertical-align: inherit;">Es decir, este es un pequeño equipo de automatizadores que hacen mucho. </font><font style="vertical-align: inherit;">Automatizamos la API, la interfaz web, las aplicaciones móviles, etc. </font><font style="vertical-align: inherit;">En total, tenemos alrededor de 15.5 mil pruebas que se realizan en diferentes niveles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La estabilidad de las pruebas en el equipo es de aproximadamente el 97%, aunque algunos de mis colegas dicen que aproximadamente el 99%. Tal alta estabilidad se logra precisamente gracias a pruebas cortas en tecnologías muy nativas. Como regla general, nuestras pruebas toman aproximadamente 15 minutos, lo cual es muy amplio, y las ejecutamos en aproximadamente 800 hilos. Es decir, tenemos 800 navegadores que comienzan al mismo tiempo, una prueba de estrés de nuestras pruebas. Como hierro usamos Selenoid (Aerokube). Puede obtener más información sobre la automatización de pruebas en Yandex.Verticals al ver mi informe de 2017, que sigue siendo relevante.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/gwXpYB6ZayE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra característica de nuestro equipo es que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">automatizamos todo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , incluidos los probadores manuales, que hacen una gran contribución al desarrollo de la automatización de pruebas. Para ellos, organizamos escuelas, les enseñamos exámenes, enseñamos cómo escribir exámenes para la API, la interfaz web y, a menudo, ayudan a acompañar los exámenes. Por lo tanto, los chicos responsables de la liberación pueden corregir inmediatamente la prueba, si es necesario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Verticals, los desarrolladores de pruebas escriben pruebas, y están tan interesados ​​en el desarrollo de pruebas que compiten con nosotros. Puede obtener más información sobre este proceso en el informe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"El ciclo completo de prueba de las aplicaciones React"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, donde Alexei Androsov y Natalya Stus hablan sobre cómo escriben las pruebas de Unidad en Puppeteer en paralelo con nuestras pruebas de extremo a extremo de Java. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los ingenieros de automatización de pruebas también escriben pruebas en nuestro equipo. </font><font style="vertical-align: inherit;">Pero a menudo estamos desarrollando algunos enfoques nuevos para optimizarlos. </font><font style="vertical-align: inherit;">Por ejemplo, implementamos pruebas de captura de pantalla, pruebas a través de moki, reducción de pruebas. </font><font style="vertical-align: inherit;">En general, nuestra área es principalmente desarrolladora de software en prueba (SDET), somos más sobre cómo escribir pruebas, y la base de prueba está parcialmente llena por nosotros y es respaldada por probadores manuales.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los desarrolladores también nos ayudan, y eso es genial.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema que surge dentro de estos procesos es que no siempre entendemos lo que ya está cubierto y lo que no. </font><font style="vertical-align: inherit;">Mirando a través de 15 mil pruebas, no siempre está claro qué es exactamente lo que verificamos. </font><font style="vertical-align: inherit;">Esto es especialmente cierto en el contexto de la comunicación con los gerentes, quienes, por supuesto, no evalúan, sino que monitorean y hacen preguntas. </font><font style="vertical-align: inherit;">En particular, si surge la pregunta de si un botón en particular se ha probado en la interfaz o en el flujo, entonces es difícil de responder, porque debe ir al código de prueba y ver esta información.</font></font><br>
<br>
<h2><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué se prueba y qué no?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si tiene muchas pruebas en diferentes idiomas y está escrito por personas con diferentes grados de capacitación, tarde o temprano surge la pregunta: ¿estas pruebas no se cruzan en absoluto? </font><font style="vertical-align: inherit;">En el contexto de este problema, el tema de la cobertura se está volviendo particularmente relevante. </font><font style="vertical-align: inherit;">Voy a describir tres temas clave:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formas de medir efectivamente la cobertura.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cobertura para pruebas API.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cobertura para pruebas web.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, determinemos que hay dos formas de cubrir: cubrir los requisitos y cubrir el código del producto.</font></font><br>
<br>
<h4><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cómo se mide la cobertura de requisitos</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere la cobertura de requisitos utilizando auto.ru como ejemplo. En lugar del probador auto.ru, haría lo siguiente. En primer lugar, buscaría en Google e inmediatamente encontraría una tabla de requisitos especiales. Esta es la base de la cobertura de requisitos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nf/v6/fh/nfv6fhqm8ukolt_4bv6bxyycohm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esta tabla, los nombres de los requisitos están escritos a la izquierda. En este caso: cuenta, anuncios, verificación y pago, es decir, verificación del anuncio. En general, esta es la cobertura. El detalle de la parte izquierda depende del nivel del probador. Por ejemplo, los ingenieros de Google tienen 49 tipos de recubrimientos que se prueban en diferentes niveles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El lado derecho de la tabla son los atributos de requisitos. Podemos usar cualquier cosa en forma de atributos, por ejemplo: prioridad, cobertura y estado. Esta puede ser la fecha del último lanzamiento.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ox/3a/kj/ox3akjf5fcmwxlmt_utf3uhnsas.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, algunos datos aparecen en la tabla. Puede usar herramientas profesionales para mantener una tabla de requisitos, por ejemplo, TestRail. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay información sobre el árbol a la derecha: las carpetas indican qué requisitos tenemos, cómo se pueden cubrir. Hay casos de prueba, etc. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wh/he/aj/whheajlxedwdqlmspx_iofg4wai.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En las Verticales, este proceso se ve así: un probador manual describe los requisitos y los casos de prueba, luego los pasa a la automatización de la prueba, y la herramienta automatizada escribe el código para estas pruebas. Además, anteriormente se nos dieron casos de prueba detallados en los que el probador manual describía la estructura completa. Entonces alguien se comprometió con el github, y la prueba comenzó a ser beneficiosa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cuáles son los pros y los contras de este enfoque? La ventaja es que este enfoque responde nuestras preguntas. Si el gerente pregunta qué hemos cubierto, abriré la tableta y mostraré qué funciones están cubiertas. Por otro lado, estos requisitos siempre deben mantenerse actualizados y se vuelven obsoletos muy rápidamente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando tienes 15 mil pruebas, mirar TestRail es como mirar una estrella en el espacio: explotó durante mucho tiempo y la luz te ha llegado justo ahora. Miras el caso de prueba actual, y ya está desactualizado hace mucho tiempo e irrevocablemente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este problema es difícil de resolver. </font><font style="vertical-align: inherit;">Para nosotros, estos son generalmente dos mundos diferentes: hay un mundo de automatización que gira de acuerdo con sus propias leyes, donde cada prueba que falla se repara de inmediato, y hay un mundo de pruebas manuales y tarjetas de requisitos. </font><font style="vertical-align: inherit;">El muro entre ellos es impenetrable, a menos que use Allure Server. </font><font style="vertical-align: inherit;">Ahora solo resolvemos este problema para ellos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tercer punto de los "pros y contras" es la necesidad de trabajo manual. </font><font style="vertical-align: inherit;">En un nuevo proyecto, debe volver a crear un mapa de requisitos, escribir todos los casos de prueba, etc. </font><font style="vertical-align: inherit;">Siempre requiere trabajo manual, y en realidad es muy triste.</font></font><br>
<br>
<h4><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cómo se mide la cobertura del código</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una alternativa a este enfoque es la cobertura del código. </font><font style="vertical-align: inherit;">Esta parece ser la solución a nuestro problema. </font><font style="vertical-align: inherit;">Así es como se ve la cobertura del código del producto: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5o/-c/oe/5o-coev_livsv-tudln9ztpau_e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
refleja la cobertura del paquete, o más bien, una pequeña parte de lo que generalmente está en el producto. </font><font style="vertical-align: inherit;">El paquete está escrito a la izquierda, ya que las características se escribieron antes. </font><font style="vertical-align: inherit;">Es decir, nuestro recubrimiento finalmente se une a algunas cosas tangibles, en este caso: Paquete. </font><font style="vertical-align: inherit;">Los atributos están escritos a la derecha: cobertura por clase, cobertura por métodos, cobertura por bloques de código y cobertura por líneas de código. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El proceso de recopilación de cobertura consiste en comprender qué línea de código pasó la prueba y cuál no. </font><font style="vertical-align: inherit;">Esta es una tarea bastante simple, pero recientemente muy relevante.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La primera mención de la cobertura del código fue en 1963, pero el progreso serio en esta dirección aparece solo ahora.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, tenemos una prueba que interactúa con el sistema. No importa cómo interactúa con ella: a través del front-end, API o directamente se arrastra hacia el back-end, simplemente asumiremos que lo tenemos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces se debe hacer la instrumentación. Este es un proceso que le permite comprender qué líneas de código se verificaron y cuáles no. No necesita estudiarlo en detalle, solo necesita buscar el nombre de su marco, en el que escribe, digamos, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , luego </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instrumentación</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cobertura</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; con estas tres palabras comprenderá cómo se hace esto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando sus pruebas verifican qué línea de código alcanzó la prueba y cuál no, guardan archivos con información sobre qué líneas están cubiertas. Según esta información, tiene datos.</font></font><br>
<br>
<h4><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cuáles son los pros y los contras de la cobertura del código?</font></font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cobertura de código llamaría inmediatamente un menos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">No acudirá al gerente, no mostrará esta placa y no dirá que todos se han automatizado, ya que estos datos no se pueden leer, él le pedirá que devuelva datos claros que pueda ver rápidamente y comprender todo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Informe de cobertura de código más cercano al desarrollo. </font><font style="vertical-align: inherit;">No se puede utilizar como un enfoque normal para proporcionar todos los datos a un equipo si queremos que todo el equipo pueda ver. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jm/kr/bw/jmkrbwezcyzyx90-qxgm4jrrlbm.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La ventaja de este enfoque es que siempre proporciona datos relevantes. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No tiene que hacer mucho trabajo, todo está automatizado para usted. </font><font style="vertical-align: inherit;">Simplemente conecte la biblioteca, sus portadas comienzan a despegar, y es realmente genial.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra ventaja de este enfoque es que solo requiere personalización. No hay nada especial que hacer allí: solo venga con una instrucción específica, ajuste la cobertura y funcionará automáticamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La cobertura de los requisitos le permite identificar los requisitos no cumplidos, pero no permite evaluar la integridad en relación con el código. Por ejemplo, comenzó a escribir una nueva función de "autorización", simplemente ingrese la "función de autorización", comience a lanzar casos de prueba. No puede ver de inmediato esta cobertura en el código, incluso si escribe alguna clase nueva, todavía no habrá información, hay una brecha. Por otro lado, este es un requisito de autorización, incluso cuando ya esté implementado, cuando cuente la cobertura, esta parte no puede ser relevante, debe mantenerse actualizada manualmente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, tuvimos una idea: ¿qué pasa si tomamos lo mejor de todos? </font><font style="vertical-align: inherit;">Para que la cobertura respondiera a nuestras preguntas, siempre era relevante y solo requería personalización. </font><font style="vertical-align: inherit;">Solo tenemos que mirar el recubrimiento desde un ángulo diferente, es decir, tomar otro sistema como base del recubrimiento. </font><font style="vertical-align: inherit;">Al mismo tiempo, asegúrese de que se recopile de forma completamente automática y que traiga muchos beneficios. </font><font style="vertical-align: inherit;">Y para esto entraremos en cobertura para las pruebas de API.</font></font><br>
<br>
<h2><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API de cobertura de prueba</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cuál es la base de la cobertura? </font><font style="vertical-align: inherit;">Para hacer esto, usamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swagger</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : esta es la API de documentación. </font><font style="vertical-align: inherit;">Ahora no puedo imaginar mi trabajo sin Swagger, es una herramienta que uso constantemente para las pruebas. </font><font style="vertical-align: inherit;">Si no usa Swagger, le recomiendo que visite el sitio y se familiarice. </font><font style="vertical-align: inherit;">Allí verá de inmediato un ejemplo de uso muy intuitivo y comprensible. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, Swagger es la documentación que genera su servicio. </font><font style="vertical-align: inherit;">Contiene:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista de solicitudes.</font></font><br>
 <img src="https://habrastorage.org/webt/in/nc/pe/inncpekmy4a699gk-eh0o4be_jy.png"></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parámetros de solicitud: no es necesario extraer el desarrollador y preguntar qué parámetros son.</font></font><br>
<img src="https://habrastorage.org/webt/yz/48/yg/yz48yg1kw8nnqdb3wn7fdcq0g1o.png"></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Códigos de respuesta</font></font><br>
<img src="https://habrastorage.org/webt/zz/y2/ku/zzy2kucjpovwr2xxue4zvct543o.png"><br>
</li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El principio de funcionamiento de Swagger es la generación. No importa qué marco utilices. Digamos Spring o Go Server, usted usa el componente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swagger </font></font></a><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codegen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y genera </font><i><font style="vertical-align: inherit;">swagger.json</font></i><font style="vertical-align: inherit;"> . Esta es una especificación, sobre la base de la cual se dibuja una hermosa interfaz de usuario. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es importante para nosotros que se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use swagger.json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : su soporte está disponible para todos los idiomas ampliamente utilizados. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos la especificación Open API </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swagger.json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se ve así: las </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jn/hl/km/jnhlkmmo1pd-7vxllopdvjhbdr0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
solicitudes se ven más o menos así: resumen, descripción, códigos de respuesta y un "identificador" (ruta: / usuarios). También hay información sobre el parámetro de consulta: todo está estructurado, hay un parámetro de ID de usuario, está en la ruta donde se requiere, tal descripción y tipo - entero.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3a/bs/7h/3abs7hrvpakohvaejel8utqdtc4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay códigos de respuesta, también están documentados: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/so/3s/yq/so3syqf7mawlmlqomizvoqdj1-u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y se nos ocurrió la idea: tenemos un servicio que genera Swagger, y queríamos mantener el mismo Swagger en las pruebas, para poder compararlos más tarde. </font><font style="vertical-align: inherit;">En otras palabras, cuando se ejecutan las pruebas, generan exactamente el mismo Swagger, lo arrojamos al Swagger Diff, entendemos qué parámetros, identificadores, códigos de estado que hemos verificado, etc. </font><font style="vertical-align: inherit;">Esta es la misma instrumentación, la misma cobertura, solo finalmente en los requisitos que entendemos.</font></font><br>
<br>
<h2><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero, ¿y si construyes un diff?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos dirigimos a la biblioteca de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diferencias Swagger</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que es lo que necesitamos para esto. Su principio de funcionamiento es algo como esto: tiene la versión 1.0, con la versión 1.1 de la API, ambos generan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swagger.json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , luego los arroja a Swagger diff y ve el resultado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado se ve más o menos así: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qk/qn/ls/qkqnlsxnssknuv8p8t9cg5ckryu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tiene información de que hay, por ejemplo, una nueva pluma. También tiene información sobre lo que se elimina. Esto significa que es hora de eliminar las pruebas, ya no son relevantes. Con la aparición de información sobre los cambios, los parámetros también cambian, por lo que es obvio que sus pruebas caerán en ese momento.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos gustó esta idea y comenzamos a implementarla. Como decidimos hacer: tenemos un Swagger de "referencia" que se genera a partir del código del desarrollador, también tenemos pruebas de API que generarán nuestro Swagger, y diferiremos entre ellos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, ejecutamos pruebas para el servicio: tenemos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rest Assured</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que a su vez accede a los servicios en la API. Y lo instrumentamos. Hay un enfoque: puede hacer filtros, la solicitud va a él y guarda la información sobre la solicitud en forma de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swagger.json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> directamente para sí mismo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí está todo el código que necesitábamos para escribir, había 69-70 líneas, este es un código muy simple.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6_/m6/ck/6_m6cka7jfewruree9d9561tayo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo curioso es que utilizamos el cliente nativo para Swagger, escribió allí mismo. </font><font style="vertical-align: inherit;">Ni siquiera necesitábamos crear nuestros binarios, solo completamos la especificación Swagger. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lr/rl/fw/lrrlfwuiqrgykrprpjnxr1fcfmq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obtuvimos muchos archivos .json con los que tuvimos que hacer algo: escribieron un agregador Swagger. </font><font style="vertical-align: inherit;">Este es un programa muy simple que funciona de acuerdo con el siguiente principio:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ella cumple con una nueva solicitud, si no está en nuestra base de datos, agrega.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ella cumple con la solicitud, él tiene un nuevo parámetro: agrega.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo mismo con los códigos de estado.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, obtenemos información sobre todos los bolígrafos, parámetros y códigos de estado que utilizamos. </font><font style="vertical-align: inherit;">Además, aquí puede recopilar datos con los que se realizaron estas solicitudes: nombre de usuario, inicios de sesión, etc. </font><font style="vertical-align: inherit;">Todavía no hemos descubierto cómo usar esta información, porque todo se genera con nosotros, pero puede entender con qué parámetros se llamaron ciertas solicitudes.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, estábamos a un tiro de piedra de la victoria, pero como resultado rechazamos Swagger Diff, porque funciona en un concepto ligeramente diferente, en el concepto de diferencial.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Swagger Diff dice qué ha cambiado, no qué está cubierto, pero queríamos mostrar el resultado de la cobertura. </font><font style="vertical-align: inherit;">Hay muchos datos adicionales, almacena información sobre la descripción, resumen y otra metainformación, pero no tenemos esta información. </font><font style="vertical-align: inherit;">Y cuando hacemos Diff, nos escriben que "este bolígrafo no tiene una descripción", pero no existía.</font></font><br>
<br>
<h2><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propio informe</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hicimos nuestra implementación y funciona de la siguiente manera: tenemos muchos archivos que provienen de las pruebas automáticas, tenemos la API del servicio Swagger y generamos un informe basado en ella. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un informe simple se ve así: arriba puede ver información sobre cuántos bolígrafos (349) en total, información sobre qué están completamente cubiertos (cada parámetro, código de estado, etc.). Puede elegir sus propios criterios, por ejemplo, cubrir varios parámetros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También hay información aquí de que el 40% está parcialmente cubierto, esto significa que ya tenemos pruebas para estos bolígrafos, pero algunas cosas aún no están cubiertas, y debe buscar cuidadosamente allí. La cobertura vacía también se refleja. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pc/og/p5/pcogp5jnc8m88l8fylt2p2uc0eq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos las pestañas. Esta es una </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cobertura completa</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vemos todos los parámetros que tenemos, que están cubiertos, códigos de estado, etc.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9o/gl/2q/9ogl2q9tf_xb1xw9dl9j8sxsku0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces tenemos una </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cobertura parcial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vemos que en el inicio de sesión social se cubre un parámetro, y dos no. </font><font style="vertical-align: inherit;">Y podemos expandirlo y ver qué parámetros específicos y códigos de estado están cubiertos. </font><font style="vertical-align: inherit;">Y en este momento se vuelve muy conveniente para el desarrollador: las versiones de la aplicación se ejecutan muy rápidamente, y a menudo podemos olvidar algunos parámetros. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fo/pf/sc/fopfscyojnuzokszhkw8ntgrqio.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta herramienta le permite estar siempre en buena forma y comprender lo que hemos cubierto parcialmente, qué parámetro se olvida, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por último - Gloria de la vergüenza, todavía tenemos que hacerlo. </font><font style="vertical-align: inherit;">Cuando miras esta página y ves Vacío allí: 172 - tus manos caen, y luego comienzas a enseñar a los evaluadores de mano cómo escribir autotests, ese es el punto.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/p8/2k/o5/p82ko5nzine_u6odc8dtl9bho5s.png"><br>
<br>
<h4><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué beneficio obtuvimos cuando lanzamos nuestra solución?</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, comenzamos a escribir pruebas de manera más significativa. </font><font style="vertical-align: inherit;">Entendemos que estamos probando, y al mismo tiempo tenemos dos estrategias. </font><font style="vertical-align: inherit;">Primero, automatizamos algo que no existe cuando vienen los probadores manuales y decimos que para un servicio en particular es fundamental que una solicitud se ejecute al menos una vez, y abrimos Empty. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La segunda opción: no nos olvidamos de las colas. </font><font style="vertical-align: inherit;">Como dije, las API se lanzarán muy rápidamente, puede haber algunas versiones dos o tres veces al día. </font><font style="vertical-align: inherit;">Allí se agregan constantemente algunos parámetros: en cinco mil pruebas es imposible comprender qué se verifica y qué no. </font><font style="vertical-align: inherit;">Por lo tanto, esta es la única forma de elegir conscientemente una estrategia de prueba y al menos hacer algo.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tercer beneficio es un proceso totalmente automático. </font><font style="vertical-align: inherit;">Hemos tomado prestado el enfoque y la automatización funciona: no necesitamos hacer nada, todo se recopila automáticamente.</font></font><br>
<br>
<h4><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ideas de desarrollo</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, realmente no quiero mantener el segundo informe, pero quiero integrarlo en la interfaz de usuario de Swagger. </font><font style="vertical-align: inherit;">Este es mi "informe de Photoshop Edition" favorito: un chip que he estado desarrollando últimamente. </font><font style="vertical-align: inherit;">Aquí de inmediato hay información sobre los parámetros que hemos probado y que no. </font><font style="vertical-align: inherit;">Y sería genial dar esta información de inmediato con Swagger. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v6/ll/n8/v6lln82kyue5errknkoxj9mkq-k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, el front-end puede ver por sí mismo qué parámetros no se han probado, priorizar y decidir que si bien no es necesario llevarlos al desarrollo, no se sabe qué tan bien funcionan. </font><font style="vertical-align: inherit;">O el backend escribe un nuevo bolígrafo, ve rojo y patea probadores para que todo sea verde. </font><font style="vertical-align: inherit;">Esto es bastante fácil de hacer, vamos en esta dirección.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La segunda idea es apoyar otras herramientas. </font><font style="vertical-align: inherit;">De hecho, no quiero escribir filtros para implementaciones específicas: para Java, Python, etc. </font><font style="vertical-align: inherit;">Existe la idea de hacer un tipo de proxy que pase todas las solicitudes a través de sí mismo y guarde la información de Swagger para sí mismo. </font><font style="vertical-align: inherit;">Por lo tanto, tendremos una biblioteca universal que puede usarse sin importar el idioma que tenga. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tercera idea de desarrollo es la integración con Allure Report. </font><font style="vertical-align: inherit;">Lo veo así: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ym/b3/ad/ymb3adazpdly9uhljv8jjqpyg04.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
como regla, cuando el parámetro se "prueba", esto no siempre nos dice cómo se prueba. </font><font style="vertical-align: inherit;">Y quiero señalar este parámetro y ver los pasos específicos de la prueba.</font></font><br>
<br>
<h4><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cobertura de pruebas web</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente punto del que quiero hablar es la cobertura de las pruebas web. La cobertura se basa en el sitio que está probando, escribiendo pruebas en el sitio. Pero puede convertirlo en una interfaz web para su cobertura. Por ejemplo, se verá así: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vq/1k/tg/vq1ktgatdwq9v-v-fpzz1444hf0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
si observa su sitio, este es un conjunto de elementos y formas de interactuar con ellos. Esta es una descripción completa: "un elemento es una forma de interactuar con él". Puede hacer clic en el enlace, puede copiar el texto, puede introducir algo en la entrada. El sitio en su conjunto consta de elementos y formas de interacción: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/f3/07/z-/f307z-lt44swcsgdas_vsspvyrk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cómo se ejecutan las pruebas: comienzan desde algún punto, luego, por ejemplo, llenan un formulario, por ejemplo, un formulario de autorización, luego se dispersan a otras páginas, luego otro a otro y finalizan .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si el gerente pregunta si se está probando un botón en particular, pero esta pregunta es difícil de responder: debe abrir el código o ir a TestRail, entonces quiero ver esta solución al problema: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hh/7q/mv/hh7qmvkk8gefu94bigbkofhdgak.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
quiero señalar este elemento y ver todas las pruebas que tenemos en este artículo Si hubiera tal instrumento, sería feliz. Cuando comenzamos a pensar en esta idea, primero miramos a Yandex.Metrica. En realidad, tienen aproximadamente la misma funcionalidad que un mapa de enlaces. Una buena idea.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La conclusión es que están resaltados exactamente como si ya dieran la información que necesitamos. Dicen: "Aquí hemos pasado este enlace 14 veces", lo que en traducción al lenguaje de prueba significa: "14 pruebas fueron probadas en este enlace" y de alguna manera pasaron por él. Pero este enlace rojo tomó hasta 120 pruebas, ¡qué pruebas interesantes! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede dibujar todo tipo de tendencias, agregar metainformación, pero ¿qué sucede si lo tomamos todo y dibujamos desde el punto de vista de las pruebas? Entonces, tenemos una tarea: señalar algún elemento y obtener una nota con una lista de pruebas. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xa/hr/dj/xahrdjma8punc8jmujxg_vwtlvs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para implementar esto, debe hacer clic en el icono, luego escribir una nota, y esta es nuestra prueba completa. Usamos Atlas en nuestro lugar, y la integración hasta ahora es solo con él. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atlas se parece a esto:</font></font><br>
<br>
<pre><code class="java hljs">SearchPage.open ();<font></font>
SearchPage.offersList().should(hasSizeGreaterThan(<span class="hljs-number">0</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Queremos que se muestre al menos un resultado, de lo contrario no lo probaremos. </font><font style="vertical-align: inherit;">Luego movemos el cursor al elemento, luego hacemos clic en él.</font></font><br>
<br>
<pre><code class="java hljs">searchPage.offer(FIRST).moveCursor();<font></font>
searchPage.offer(FIRST).actionBar().note().click();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego guardamos en la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entrada User_Text</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y lo </font><i><font style="vertical-align: inherit;">enviamos</font></i><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="java hljs">searchPage.offer(FIRST).addNoteInput().sendKeys(USER_TEXT);<font></font>
searchPage.offer(FIRST).saveNote().click();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de eso, verificamos que el texto es exactamente el que debería haber sido.</font></font><br>
<br>
<pre><code class="java hljs"> searchPage.offer(FIRST).addNoteInput().should(hasValue(USER_TEXT));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las pruebas se ejecutan en un navegador, Atlas es un proxy de esta prueba, aplicamos el mismo enfoque aquí que todos usan cuando recopilan cobertura: crearemos un localizador con .json. Guardaremos la información sobre todas las aperturas de página, todas las iteraciones con elementos, quién envió, quién envió la clave, quién hizo clic, qué ID, etc., mantendremos un registro completo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego adjuntamos este registro a Allure en la forma de cada prueba, y cuando tenemos muchos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">locators.json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , generamos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meta.json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El esquema es el mismo para todos los elementos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos un complemento para Google Chrome. Queríamos tomar una decisión en forma de complemento. Hice una captura de pantalla de curva especialmente para que un detalle importante fuera visible en la diapositiva: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ruta a locators.json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rx/kg/nz/rxkgnzghdmiw9syocwbkaqx27yy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si generó un informe ahora, entonces hay un mapa de cobertura para hoy. Si toma el informe de las dos semanas anteriores y lo pega aquí, aparecerá un mapa de cobertura del período hace dos semanas. ¡Tienes una máquina del tiempo! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, cuando conecta este complemento, dibuja una interfaz no tan amigable. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mx/q4/vx/mxq4vxhpjqlrewxte3xn_o75upm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada elemento tiene una serie de pruebas que lo atraviesan: está claro que 40 pruebas pasan por "comprar un apartamento", el encabezado se prueba una prueba a la vez, es genial, y también se muestra la opción "apartamento". Obtiene un mapa de cobertura completo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si pasa el mouse sobre algún elemento, tomará los datos e imprimirá sus pruebas reales desde su tms, Allure Board, etc. El resultado es información completa sobre lo que se está probando y cómo.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que en cada prueba puede fallar directamente en el informe de Allure. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/he/nw/iy/henwiyzy6if8o1ak2ky1i9v2s-e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando abre cualquier cosa, carga nuevos selectores: si tiene alguna prueba que pasa por estos selectores e hizo algo con el sitio, procesará y mostrará la imagen completa.</font></font><br>
<br>
<h2><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cuál es el beneficio?</font></font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tan pronto como implementamos este enfoque simple, principalmente, comenzamos a comprender lo que probamos en las pruebas.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora cualquiera puede entrar y encontrar cualquier "hilo" que conduzca al guión. Por ejemplo, asume que necesita probar el pago. El pago, obviamente, se lleva a través del botón de pago: haga clic: aparecen todas las pruebas que pasan por el botón de pago. ¡Esto es bueno! Entras en cualquiera de ellos y ves el guión. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, entiendes lo que se ha probado antes. Generamos un archivo estático, puede especificar la ruta e indicar qué pruebas fueron hace dos semanas. Si el gerente dice que hay un error en la producción y pregunta si probamos esta o aquella funcionalidad hace un par de semanas, usted toma el informe de Allure, por ejemplo, dice que no lo probó.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro beneficio es la revisión después de probar la automatización. Antes de eso, teníamos una revisión antes de probar la automatización, ahora puede hacer sus pruebas exactamente como las ve. Si quería hacer una prueba, listo, tomó una rama, lanzó Allure, soltó el enlace del complemento a un probador manual y solicitó ver las pruebas. Este es exactamente el proceso que le permitirá fortalecer la estrategia Agile: el líder del equipo realiza la revisión del código y los probadores manuales hacen sus pruebas (scripts). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra ventaja de este enfoque son los elementos de uso frecuente. Si anulamos este bloque, en el que hay 87 pruebas, todas caerán. Empiezas a entender cuán frágiles son tus exámenes.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/x3/jh/ye/x3jhyewo2z60_6-xi5iz6q-2rzs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y si se anula el "precio desde" del bloque, entonces está bien, una prueba caerá, una persona lo corregirá. </font><font style="vertical-align: inherit;">Si cambia el bloque con 87 pruebas, la cobertura se reducirá considerablemente, porque 87 pruebas no pasarán y no comprobarán ningún resultado. </font><font style="vertical-align: inherit;">Este bloque necesita mayor atención. </font><font style="vertical-align: inherit;">Luego debe decirle al desarrollador que este bloque debe estar con una ID, porque si se va, todo se vendrá abajo.</font></font><br>
<br>
<h2><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cómo puedes desarrollar más?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, puede seguir el camino del desarrollo de soporte para otras herramientas, por ejemplo, para Selenide. Incluso me gustaría admitir no un Selenide específico, sino una implementación de controlador que le permita recopilar localizadores, independientemente de la herramienta que utilice. Este proxy volcará la información y luego la mostrará. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra idea es mostrar el resultado de la prueba actual. Por ejemplo, es conveniente arrojar de inmediato una imagen de este tipo a un probador manual: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/e4/w-/q8/e4w-q8xjavk2dfern8u_fncyfu4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
no tiene que pensar qué pruebas se rompieron, porque puede ir al sitio, hacer clic en la prueba y pasarla sin verificar otras pruebas. Esto es fácil, puede recoger esta información de Allure y dibujarla aquí mismo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También puede agregar la puntuación total, porque a todos les encantan los gráficos, porque quiero lidiar con pruebas duplicadas que son muy similares entre sí, cuya parte central es la misma, y ​​el comienzo y la cola han cambiado un poco. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/op/lw/xq/oplwxqvq08hv-uaqs3c97owcuxy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También me gustaría ver de inmediato la cantidad de selectores duplicados. Si es alto, entonces en esta página debe refactorizar y ejecutar pruebas, de lo contrario, se agruparán demasiado. Lo mismo ocurre con la cantidad de elementos con los que interactuamos. Este es un síntoma común. Sin embargo, tan pronto como interactúe con la página, la cifra se saltará debido a los nuevos elementos y al número total de casos de prueba, por lo que debe agregar algún tipo de análisis, no será superfluo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También puede agregar la distribución de pruebas por capas, porque desea ver no solo que tenemos estas pruebas, sino todos los tipos de pruebas que se encuentran en esta página, posiblemente incluso pruebas manuales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, si hay pruebas de Java y pruebas en Puppeteer que otro equipo escribe, podemos mirar una página específica e inmediatamente decir dónde se cruzan nuestras pruebas. Es decir, hablaremos el mismo idioma con ellos y no necesitaremos recopilar esta información poco a poco. Si tenemos una herramienta que muestra todo en la interfaz web, la tarea de comparar pruebas en Java y Puppeteer ya no parece irresoluble.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, hablemos de la estrategia general. </font><font style="vertical-align: inherit;">Ya hemos hablado sobre qué tipos de cobertura son, nombrados dos, se nos ocurrió un tercer tipo de recubrimiento, que usamos como resultado. </font><font style="vertical-align: inherit;">Entonces tomamos y miramos este problema desde un ángulo diferente.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por un lado, hay una cobertura que se inició desde 1963, por otro lado, hay probadores manuales que están acostumbrados a vivir en un mundo más real que el código. </font><font style="vertical-align: inherit;">Solo queda combinar estos dos enfoques.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los interesados ​​siempre pueden unirse a nuestra comunidad. </font><font style="vertical-align: inherit;">Aquí hay dos repositorios de nuestros muchachos que se ocupan del problema de cobertura:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cobertura de arrogancia</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">locators-hotspots-chrome-plugin</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es491826/index.html">Bitrix Auditoría de bricolaje</a></li>
<li><a href="../es491828/index.html">DataMatrix o cómo etiquetar los zapatos correctamente</a></li>
<li><a href="../es491832/index.html">8 ventajas de Flutter en comparación con React Native</a></li>
<li><a href="../es491838/index.html">MIPT lanza un curso abierto en línea sobre programación deportiva</a></li>
<li><a href="../es491840/index.html">Visualización del trabajo de los trabajadores del servicio.</a></li>
<li><a href="../es491846/index.html">Verificación del isomorfismo de dos gráficos y búsqueda de subgráficos isomórficos: un enfoque basado en el análisis de rutas NB</a></li>
<li><a href="../es491848/index.html">Redux Toolkit ya no es necesario?</a></li>
<li><a href="../es491852/index.html">Flask-DJ: estructura Django (mvc) para un proyecto en matraz</a></li>
<li><a href="../es491854/index.html">Teléfonos corporativos para cada uno de los 31 mil empleados.</a></li>
<li><a href="../es491856/index.html">LinkedIn para estudiantes y graduados: primeros pasos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>