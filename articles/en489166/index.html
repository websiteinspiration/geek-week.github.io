<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöë üôéüèæ ‚ö´Ô∏è About the operation of a PC using the example of Windows 10 and the keyboard of Part 2 üçö üöô üë¶üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this part, we will consider which way the information about the pressed key from the keyboard to the CPU goes, there will be a lot of pictures and ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>About the operation of a PC using the example of Windows 10 and the keyboard of Part 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489166/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this part, we will consider which way the information about the pressed key from the keyboard to the CPU goes, there will be a lot of pictures and this is not the last part. I will talk about this from the point of view of a programmer who writes in user mode - user programs, web, mobile applications - therefore, there may be inaccuracies. People involved in electronics are unlikely to find anything useful for themselves. The first part is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/wl/me/mo/wlmemoyr_plutwlcq7nhezslr78.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The problem of higher programmer education is that students study in detail individual aspects taken out of context without understanding how this all fits together. Several semesters of higher mathematics to understand physics, to understand electrical engineering, electrical appliances, assembler, OS, algorithms, system programming and a bunch of other subjects tamped into a standard five-year program. The abundance of details and no one explains how this fits into the big picture, it is assumed that after 5 years the student will bind it in his head, and then he will go to work with .Net and will never touch the electronics and kernel mode. I believe that it is not necessary to know in such detail about the operation of a computer, it is enough to have a general understanding of what is happening down the technological stack. If the people making up the training programs for universities opened driving schools,you would learn Russian, calligraphy and hydrodynamics, because you need to communicate with inspectors, change fluids and write explanatory notes. There will be some inaccuracies in the article, so it will not be suitable for passing the exam in specialized subjects, but after it it will be easier to understand the PC device.</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Under cat traffic.</font></font></i><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A keyboard key is a button that closes the contacts and an electric current passes through them. </font><font style="vertical-align: inherit;">The mechanism of closing / opening is made in such a way that the button does not have to be pressed in completely, because otherwise the fingers will quickly become tired and the keyboard will be non-ergonomic. </font><font style="vertical-align: inherit;">In section, the key looks like this. </font><font style="vertical-align: inherit;">On the right side is the contact to which voltage is applied.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/g5/c1/ay/g5c1aykcd7h6pbxwih_ci_dcsk0.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The ‚Äúbrains‚Äù of the keyboard that can determine the keystroke is a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">microcontroller</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is essentially a mini-computer with a program that checks each key by applying voltage to it and if it passes then the key is pressed. The legs of the microcontroller have their own names and can be accessed in code, they are used to communicate with the outside world. The legs can control the operation of the microcontroller, report the status of the chip or serve for reading / transmitting data.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><img src="https://habrastorage.org/webt/ek/uq/om/ekuqom94exvedvmbel6ky6botvm.png"></td>
<td><img src="https://habrastorage.org/webt/mb/wm/14/mbwm14xm-h71gr7plnv5oglrhak.png"></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The program ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">firmware</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) can be written in C or assembler, it is uploaded to the microcontroller through the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programmer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It is a device with a connector for installing a microcontroller and can be connected to a computer via USB, on which special software is running. Here's what the programmer looks like in real life:</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><img src="https://habrastorage.org/webt/4q/qz/ut/4qqzutlhi4hlltp4ubcclyv2rtu.png"></td>
<td><img src="https://habrastorage.org/webt/hy/ex/xj/hyexxj5ezr-gkg4jva6rerfkbnw.png"></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Through the program, each leg can be set or measured voltage. </font><font style="vertical-align: inherit;">The algorithm for finding the pressed key is to apply voltage to one leg and measure it on the other, and if the key was pressed, then the second leg will have about the same volt as the input. </font><font style="vertical-align: inherit;">So in an infinite loop all keys are checked. </font><font style="vertical-align: inherit;">As a rule, the keyboard has 80-110 buttons, and the contact controller (pins) is much smaller. </font><font style="vertical-align: inherit;">Therefore, they use such an approach as the ‚Äúkeyboard matrix‚Äù - all the keys are distributed in columns and rows, and the algorithm is reduced to finding a column that intersects the row to which the program applied voltage. </font><font style="vertical-align: inherit;">Column / row correspondence to contacts is highlighted here.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/dm/3w/yn/dm3wynvz4faugjchr5h94ywdwgq.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In reality, the matrix may look like this. </font><font style="vertical-align: inherit;">On the left is industrial and on the right is homemade.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/-y/3o/ik/-y3oikaoyykmeihyhgskuihxgoo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the pseudo-code, part of the firmware program that determines the keys pressed can look like this.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; COLSC; i++) {<font></font>
 	SetPower(columns[i], <span class="hljs-number">3.0</span> f);
  	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; ROWSC; j++) {
    		<span class="hljs-keyword">float</span> power = GetPower(rows[j]);
    		<span class="hljs-keyword">if</span> (power &gt;= <span class="hljs-number">3.0f</span> - THRESHOLD) {<font></font>
      			BYTE key = keys[i, j];<font></font>
      			SendKey(key);<font></font>
    		}<font></font>
  	}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each key corresponds to a scan code, it is standardized and is an 8-bit number, i.e. one byte. Therefore, when the Y key is pressed, the keyboard controller will have to send the number 21 (0x15), and when released - 149 (0x95). How is the shipment done? Surely you worked with JSON, web services or sent data between processes and you know that to send data you need to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serialize</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , i.e. turn into an array of bytes or formatted text that the recipient can </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deserialize</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , i.e. recreate an object in its address space. And what can serialize data at such a low level? We need to transfer only 1 byte (8 bits). Looking ahead, I‚Äôll say that we will transmit data bit by bit.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In mathematics, there is a formula that can convert any decimal number that is familiar to us into a sequence of zeros and ones and vice versa. This formula has found application in computer technology. In the first part, I casually mentioned that analog technology exploits the laws of physics, while digital works at the level of zeros and ones. This means that an analog telephone encodes the entire spectrum of the human voice into a sequence of electromagnetic waves, and a digital telephone uses a chip that converts the human voice into digital data, for example, in WAV files, and then transmits them in a sequence of zeros and ones in the form of electromagnetic waves. Only in this case, instead of the entire spectrum of the voice, only two values ‚Äã‚Äãmust be represented - 0 and 1. They can be represented by waves of different lengths, different voltages,light pulses through the optical fiber, black and white stripes on paper, holes on the punch card.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The scan code of the pressed Y key in binary looks like 0001 0101. We will transmit them along the microcontroller leg which is responsible for the data ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DATA</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logical unit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is 3.3V or higher, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">logical zero</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- voltage is about 0V. Here's the catch - how do I pass three zeros in a row? To do this, we need a second leg which we will call CLOCK, when on it one means that the transmission session of one bit has begun, and zero has ended. Such a change in the values ‚Äã‚Äã(voltages) will occur with a certain time interval, say 50 nanoseconds, because at the other end there is a second microcontroller that works at its own speed and listens to the legs to which CLOCK and DATA are connected in an endless loop. In this example, I will assume that the keyboard is connected via the PS2 connector, which is shown below. Through the USB port, the transfer algorithm will be different. As you can see, the PS2 port has pins called Data, Clock.In addition to them, there is also a contact through which the PS2 port controller distributes the 5V voltage necessary for operation to the keyboard and a ground contact, which is simply displayed on the keyboard body. Other contacts are not used.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><img src="https://habrastorage.org/webt/8g/ug/g7/8gugg7htfuyfrzclfypvowdzkhq.png"></td>
<td><img src="https://habrastorage.org/webt/dy/zf/_w/dyzf_w-iqlutb2xiju_om0e4abq.png"></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The PS / 2 </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">port</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is called </font><i><font style="vertical-align: inherit;">a serial bus</font></i><font style="vertical-align: inherit;"> , because it transmits bits one by one (a sequence of bits). </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The parallel port</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> transfers data through several contacts at once and can transfer for example one byte (8 bits) at once for one data transfer session. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is the difference between a port, a bus, and a protocol? A bus, like a port, is a set of contacts (wiring) and an agreement on how to use them, only the port has a connection for connecting external devices, and the bus is used to communicate components on the motherboard. A port is essentially a bus with a connector in the middle. A protocol is an interaction through contacts. In the example with PS / 2, this was the order of data transfer through the Clock and Data contacts.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Previously, the Intel 8042 microcontroller was very common and was used both in the keyboard and as a PS2 port controller, i.e. two identical chips exchanged data. The PS2 port driver in Windows is called 8042prt.sys.</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In fact, we transmit not 8 bits, but 11, because the data is transmitted as a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data packet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">message</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . An additional 3 bits indicate the beginning and end of the data - one zero at the beginning and 0 1 at the end, such a protocol for transferring data from the device to the host in PS2. This may look like the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SendKey</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">in pseudo-code, if you prefer to understand the code. It sends data about the pressed key via the PS2 bus.</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SendBit</span><span class="hljs-params">(BYTE bit)</span> </span>{
	<span class="hljs-keyword">float</span> power = (bit != <span class="hljs-number">0</span>) ? <span class="hljs-number">3.3f</span> : <span class="hljs-number">0.0f</span>;<font></font>
	SetPower(DATA, power);<font></font>
	SetPower(CLOCK, <span class="hljs-number">3.3f</span>);<font></font>
	Sleep(<span class="hljs-number">50</span>);<font></font>
	SetPower(CLOCK, <span class="hljs-number">0.0f</span>);<font></font>
	Sleep(<span class="hljs-number">50</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SendData</span><span class="hljs-params">(BYTE data)</span> </span>{<font></font>
	SendBit(<span class="hljs-number">0</span>);<font></font>
	<font></font>
	<span class="hljs-keyword">for</span> (BYTE i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(BYTE); i++) {<font></font>
		BYTE bit = (data &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<font></font>
		SendBit(bit);<font></font>
	}<font></font>
<font></font>
	SendBit(<span class="hljs-number">0</span>);<font></font>
	SendBit(<span class="hljs-number">1</span>);<font></font>
}<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is not always necessary to manually set the voltage on each leg individually for data transfer. </font><font style="vertical-align: inherit;">In some cases, the value stored in the register is automatically displayed on the contacts. </font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the graph, such a data transfer will be visualized as follows. </font><font style="vertical-align: inherit;">Time is along the X axis, and voltage is along the Y axis.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zs/cy/p8/zscyp8ur1i1t0lmau3n50evbuke.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In analogue technology, the signal may be distorted, i.e. </font><font style="vertical-align: inherit;">the wire is not connected to anything, but the voltmeter shows 0.5V on it due to the fact that there is an electromagnetic field nearby. </font><font style="vertical-align: inherit;">Therefore, the concept of threshold voltage is used. </font><font style="vertical-align: inherit;">If the voltage is less than the threshold, then we assume that we got a logical zero, otherwise unity. </font><font style="vertical-align: inherit;">Taking into account possible distortions, the scan code of the pressed Y key can come like this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/u4/3k/slu43kce6evjxlk3qgrzzwpfhmg.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before we take a closer look at how data from the keyboard gets to the CPU, let's talk about </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">microchips</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buses,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">motherboards</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microcontrollers and microcircuits</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The microcontroller can execute a program sewn into it, has a certain amount of RAM memory and a place to store data and program code. In the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chip, the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> program can be set at the design stage. Manually creating an electrical circuit implementing an algorithm is very time-consuming and therefore, a special programming language called </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VHDL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Hardware Description Language) </font><font style="vertical-align: inherit;">can be used to design microcircuits </font><font style="vertical-align: inherit;">. This is a high-level programming language that is translated into a circuit plan, it is run through a program that finds the optimal location of the radio elements on the board and is ultimately made in physical form. Images are for illustrative purposes only.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/6c/rt/vp/6crtvpo861utguxs56v37-7syx4.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/r8/q7/gkr8q7m78x8ldyxvdxu7tp9pxhc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How are the data and commands represented in microchips and microcontrollers? </font><font style="vertical-align: inherit;">The basis of computer technology is a transistor, which mankind has learned to make in microscopic dimensions. </font><font style="vertical-align: inherit;">A transistor is such a radio element that has three legs: an input, an output, and between them a control that opens or closes a current between two legs. </font><font style="vertical-align: inherit;">The figure below illustrates the operation of the transistor, water illustrates the current.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/1g/kj/bw/1gkjbwtax3xmpshjmbllzgpvkoo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voltage is applied to the input leg, if the control has voltage, then the current passes to the output, otherwise there will be 0V. </font><font style="vertical-align: inherit;">Having 8 transistors, each of which has an LED connected to the output leg that either lights up or not, we can imagine 256 unique combinations (2 to the power of 8). </font><font style="vertical-align: inherit;">Lapochki are interpreted from right to left, as well as decimal numbers. </font><font style="vertical-align: inherit;">The lower digits are on the right.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><img src="https://habrastorage.org/webt/bt/gb/9l/btgb9ln9dejdgz-v-e7l_6mjx9u.png"></td>
<td><img src="https://habrastorage.org/webt/vb/js/yg/vbjsygneuovkp0ocaml6yfvoigy.png"></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Those. </font><font style="vertical-align: inherit;">one bulb represents one bit of information (0 or 1), and eight such bulbs correspond to one byte. </font><font style="vertical-align: inherit;">It is possible to build logical operators AND, OR, NOT, XOR on transistors.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/wu/rw/gz/wurwgzgga7mny0qhn3daju6hdic.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, in the AND operator circuit (on the left in the picture above), the output will only have voltage if both input voltages are non-zero. </font><font style="vertical-align: inherit;">Someone already has invented algorithms for addition, multiplication, division, and subtraction based on bitwise logical operations and bit shifts. </font><font style="vertical-align: inherit;">Chip manufacturers just need to implement them. </font><font style="vertical-align: inherit;">The operation of the bitwise addition algorithm is illustrated below; we will not analyze it:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/9k/t3/m5/9kt3m5uiw9wp1xk7ferifgngpzi.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The nanotransistors are microscopic and can be placed on the board in the millions. </font><font style="vertical-align: inherit;">The Intel processor is shown below and how approximately one of its cores might look like. </font><font style="vertical-align: inherit;">The picture is illustrative.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hy/77/gt/hy77gt038gktsayjog-kg9rh65u.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microcircuits may contain a microcontroller on the same board and in the same case.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tires</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typically, in textbooks, tires are shown as bold arrows, as in the picture below. </font><font style="vertical-align: inherit;">This is done so as not to draw all the connections of the contacts, which can be many. </font><font style="vertical-align: inherit;">The operation of the PS2 bus is very simple, all you need is three pins. </font><font style="vertical-align: inherit;">But there are buses which, for example, have 124 contacts for data transfer.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zu/-a/vd/zu-avduvaicswxtkaeihnnwureu.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are the following types of tires:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data - bits on these contacts are interpreted as data: number, symbol, part of a picture or other binary data. </font><font style="vertical-align: inherit;">Bus width affects throughput, number of bits transmitted per second</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addresses - bits on these pins are interpreted as a physical address in memory. </font><font style="vertical-align: inherit;">The width of this bus determines the maximum supported RAM capacity.</font></font></li>
<li> ‚Äî          . CPU         RAM   I/O.</li>
<li>.         ,      .    ATX 24 Pin 12V PSU Connector,       .<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/am/cb/mq/amcbmq-jxkqdth45s_79xrg6uwa.png"></div></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A tire may consist of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">substrates</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , i.e. </font><font style="vertical-align: inherit;">some contacts are used for data, others for addresses, others for control and contacts to which power is transmitted. </font><font style="vertical-align: inherit;">The approach when the same contacts are used alternately to transmit both data and addresses is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">multiplexing</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">For example, the Intel 8086 processor has a data and address bus of 20 bits, on the pin diagram its contacts are indicated by </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AD0-AD19</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (legs 16-2 and 39-35).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jp/wy/tx/jpwytxl5cbiuv_hky79ledmfzjk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In a more complex case, we may have several microcircuits connected to the same contacts. </font><font style="vertical-align: inherit;">For normal communication, they need an additional chip that will determine who at what point in time can use them, it is called a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bus controller</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In the figure below, a spherical bus in a vacuum: four identical microcontrollers transmit data to the consumer microcontroller via the bus controller. The red wire is the voltage that the bus controller distributes to all the chips connected to it. Data is transmitted through the green wires and ‚Äúnegotiating‚Äù with the bus controller is performed, and the blue wire is Clock, through which the bus controller synchronizes the communication of the controllers, because they can operate at different speeds. If the logical unit is on the blue wire, then the chip entitled to use the bus can perform one act of interaction with the outside world - read a bit, for example.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/3a/tc/pq/3atcpqqtqdpmnbvrjho1h1y-bww.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The bus controller can be considered as an integral component, because communication with the outside world will go through it and how many chips or real external devices are really on the bus is not important. </font><font style="vertical-align: inherit;">For data transfer, the motherboard has an extensive bus network. </font><font style="vertical-align: inherit;">Despite the fact that there are a great many chip sets, for the most part they follow a typical layout, because all devices connected to the motherboard are divided into:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slow - keyboard, hard drive, network card, audio, etc. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast - CPU, RAM, GPU. </font></font></li>
</ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Based on this division, the motherboard has two main chips - the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">South Bridge</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which coordinates the work of all slow devices, and the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">North Bridge,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for coordination of fast devices. In modern computers, the Northbridge is located in the CPU itself, and the Southbridge may be called the Platform Controller Hub, but this does not change the essence. Both of these bridges are interconnected by a bus through which they inform each other about significant events. Of particular interest is the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clock generator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> by which the processor, RAM and graphics card synchronize their work, the same blue wire. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Overclocking</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this is essentially changing the BIOS settings so that synchronization occurs more often, while the hardware, primarily the CPU, will heat up harder, consume more power and more quickly develop its resource. The opposite is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">underclocking</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , when the speed decreases to save battery power or reduce noise. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A chipset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a set of chips that were all designed to work with each other. They provide communication between components on the motherboard and provide functionality such as timers. The chip set works with only one processor brand, AMD cannot be inserted into the motherboard with the Intel chipset, they even have different contacts. The motherboard diagram is presented below:</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><img src="https://habrastorage.org/webt/hd/zk/ld/hdzkldbz0h6vjddegg2iqwir-f0.png"></td>
<td><img src="https://habrastorage.org/webt/2h/sl/-f/2hsl-f2t77a-x4xy0dn5xqo2ua0.png"></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Want an example of hardware encapsulation? </font><font style="vertical-align: inherit;">Intel chipsets have a chip called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Super IO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , it is shown in the picture below and is connected to the South Bridge via the LPC bus. </font><font style="vertical-align: inherit;">LPC is the smart name for wiring CLOCK, DATA, VCC (POWER). </font><font style="vertical-align: inherit;">This chip contains the emulation of all the old chips that have ever been used for peripherals, including the 8042 chip that was used for the PS2 port. </font><font style="vertical-align: inherit;">There is also a port controller emulator for Floppy and other relics that interfere with progress. </font><font style="vertical-align: inherit;">In the general diagram of the motherboard, both Super IO and the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LPC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bus are indicated above </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/bf/wx/sm/bfwxsm3i9gekd4yjd0uizbusb3u.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The modern PS2 port connects directly to the Super I / O chip. </font><font style="vertical-align: inherit;">Green is the keyboard, purple is the mouse. </font><font style="vertical-align: inherit;">Previously, it connected to the Intel 8042 microcontroller.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ae/za/tj/aezatje8p9gbwod0uap92v7sv-e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The motherboard is made of dielectric, i.e. </font><font style="vertical-align: inherit;">material that does not conduct current. </font><font style="vertical-align: inherit;">The current can pass only about the lines printed on the board. </font><font style="vertical-align: inherit;">The motherboard has many layers, each of which has its own contacts printed and therefore if you drill the motherboard where the lines are not visible, you can spoil it by damaging the invisible contacts inside the board. </font><font style="vertical-align: inherit;">Now you can take a closer look at the process of distributing data from the PS2 to the CPU.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The road from the PS2 to the processor</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typically, computer architecture is considered on the 8086 processor. On the one hand, this is correct, because it is quite simple compared to modern CPUs, and on the other hand, it is wrong, because it is old and does not reflect the architecture of a modern machine. Intel 8086 did not need any bridges, because it was so slow that it could work with peripherals on one bus, i.e. at one frequency. I don‚Äôt know the modern CPU and chip sets, so I will explain it on fictitious ones that resemble real ones. In my example, there will be a fictional CPU very similar to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intel 8086</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The Super IO chip has more than one hundred contacts and there is documentation on the Internet, but I don‚Äôt see the point of sorting out which pins the keyboard and LPC bus actually use to communicate with South Bridge. The main thing is the principle, which can be implemented in different ways. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's take a quick look at the picture to remember that we have already passed. The green arrows indicate the path we will take.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/82/ic/2e/82ic2e8smxmv-z0epnfxzk1f6n8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, the data from the keyboard has already come to the PS2 port controller, which was once an Intel 8042 chip, and is now emulated by a Super IO chip. And now let's analyze the further course of actions on my fictional motherboard with a fictional CPU. The PS2 controller received a scan code of the pressed Y key and now supplies voltage to the contact signal (purple line, see the picture below) on which the programmable interrupt controller should notify about data from the keyboard. This signal is transmitted from one chip to another until the North Bridge passes it to the interrupt manager.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zh/jb/jb/zhjbjbwyj8dgyhydsaeryyfyfrm.jpeg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmable Interrupt Controller</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is an </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intel 8259</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chip </font><font style="vertical-align: inherit;">in which 8 legs (their names IRQ0-IRQ7) are reserved for receiving notifications from certain ports ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nterrupt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uest). A keyboard is tied to IRQ1 pin, IRQ7 to a printer, Floppy disk to some pin, sound card, parallel ports and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">others</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Of course, there can be much more than eight devices, so a technique such as cascading was used when another similar PIC was connected to a leg with the name IRQ2, at which the count did not start from 0, but 7. The mouse is tied to IRQ12, i.e. foot IRQ5 on the second PIC. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The interrupt controller should now notify the CPU of the event on the keyboard. This happens as follows:</font></font><br>
<ol>
<li>      INT (Interrupt) ,     INTR (<i>Interrupt Request</i>) . CPU            ,        , ..       .     ,       .        exception  .</li>
<li>               INTR,        .</li>
<li>       ( D0-D7)  ,    .      PIC          (   IRQ).<br>
<br>
<i> ,   ?     .               .   ‚Äî      (x, y, z, w).        .</i></li>
<li>CPU     AD0-AD7  ,  .      IDT (<i>Interrupt Descriptior Table</i>)    ,     ,         .   CPU   .<br>
<br>
<i>             .       .    ,   IDT        C# .</i><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IDT_entry</span>{</span>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> offset_lowerbits;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> selector;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> zero;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> type_attr;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> offset_higherbits;<font></font>
};<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IDT_entry</span> <span class="hljs-title">IDT</span>[256];</span>
</code></pre></li>
<li>        ,          INTA (<b>Int</b>errupt <b>A</b>cknowledged).<br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The keyboard interrupt handler in the simplest code will look like this. It calls a command that signals the completion of interrupt processing, i.e. sends a signal to the INTA foot.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">irq1_handler</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{<font></font>
	  outb(<span class="hljs-number">0x20</span>, <span class="hljs-number">0x20</span>); <span class="hljs-comment">//EOI</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can learn more about how the interrupt vector table is configured on </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">osdev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we know how the interrupt happened, but we don‚Äôt know how the interrupt handler reads information about the pressed key. From a software point of view, the PS2 port is two registers, only they are not accessed by names or addresses in memory </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by the I / O port number</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . These two single-byte registers are assigned to ports 0x60 and 0x64, the first (0x60) will contain the scan code of the key. The second port is used to transfer status and commands to the PS2 port (not the keyboard!). The x86 architecture instruction set has the command </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN </font></font></a><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">storeTo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fromPortNum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which reads the value from the specified I / O port into the specified register. </font><font style="vertical-align: inherit;">For example IN AL, 0x60 will save the data from the keyboard to the AL register. </font><font style="vertical-align: inherit;">It might work something like this:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the processor that we are considering there are legs AD0-AD20, they can be used to indicate the address and data. </font><font style="vertical-align: inherit;">This is both a data bus and an address bus. </font><font style="vertical-align: inherit;">In addition to them, there are a number of control legs, for example, pin No. 28 (S2), the value of which will indicate to the north bridge where the reading will take place - from memory or an input / output device. </font><font style="vertical-align: inherit;">The IN command sets the value here talking about the I / O device.</font></font></li>
<li>   CPU (-   AD0-AD20)   0110 0000,    0x60.      CPU    ,     .        , -   , - .       0x60        SuperIO ,    -    .</li>
<li>    Super IO            .   0x60        PS2,         . </li>
<li>    .   Intel 8042,     SuperIO,   LPC       ,       . ..        ,    .</li>
<li>     CPU              (- 8   AD0-AD20). </li>
<li> CPU                   AL.         .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This whole algorithm works on a nanosecond scale and therefore runs almost instantly, even though the processor spent some time waiting for the I / O operation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you now understand reading from external devices, even such as RAM memory with so on. CPU is rather slow. This slowness can be noticed by writing a program that prints 10,000 lines in a file line by line, instead of copying them to the buffer and saving immediately. The hard drive is connected to the South Bridge and inside it there is also a controller that controls the direct placement of data.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAM is connected to the CPU via the bus and reading from it takes some time. To speed up the CPU, it has a cache, i.e. The area in which transistors are located representing data that will soon be needed or often used, their reading is much faster than from the RAM board, which communicates with the CPU through the North Bridge. RAM is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamic Random Access Memory</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , because capacitors are used to represent data in it. A capacitor is a radio element that, like a battery, holds a charge for a while until it is completely discharged. Only here discharge occurs very quickly. Therefore, the capacitors must be recharged, this happens instantly, it is enough to apply voltage. Charged capacitor - logical 1, otherwise 0. For cache memory is used</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Static RAM</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> i.e. </font><font style="vertical-align: inherit;">it does not need to be recharged and therefore it works faster, but costs more. </font><font style="vertical-align: inherit;">The cache is divided into 3 levels, which are sequentially checked during the search for the requested data before the processor accesses the RAM. </font><font style="vertical-align: inherit;">On older processors, the first level cache (L1) was part of the CPU and worked with it at the same frequency, when both L2 and L3 caches were external chips. </font><font style="vertical-align: inherit;">Now they are all on the same chip with the processor. </font><font style="vertical-align: inherit;">L1 cache is the fastest and smallest in memory size, L2 has more memory but slower. </font><font style="vertical-align: inherit;">L3 is the largest cache and the slowest, often called the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shared cache</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , because it stores data for all CPU cores, while L1 and L2 are created for each individual core. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the next part, we will talk about how Windows receives and processes the received data.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en489156/index.html">Who is smarter than IDEA?</a></li>
<li><a href="../en489158/index.html">Sber.DS - a platform that allows you to create and implement models even without code</a></li>
<li><a href="../en489160/index.html">Results of a study on job postings for a digital product designer. Part One - Results and Statistics</a></li>
<li><a href="../en489162/index.html">Manager will hand over</a></li>
<li><a href="../en489164/index.html">Kubernetes cluster upgrade without downtime</a></li>
<li><a href="../en489172/index.html">We fasten ActiveDirectory authorization to Kubernetes with Keycloak</a></li>
<li><a href="../en489174/index.html">Single Responsibility Principle (SRP) with Laravel</a></li>
<li><a href="../en489178/index.html">GSMout - receive SMS and calls ‚Äúat home‚Äù</a></li>
<li><a href="../en489182/index.html">varchar (max) -varchar (max) and in production</a></li>
<li><a href="../en489188/index.html">Logging in a microservice .Net environment in practice</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>