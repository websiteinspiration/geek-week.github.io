<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏🏻 🐲 🌠 Yandex.Cloudのモノのインターネット：Yandex IoT CoreとYandex Cloud Functionsサービスの配置方法 🥊 👩🏻‍🎤 🛣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="昨年10月、初のYandex Yandex Scaleクラウドカンファレンスが開催されました。数百万のIoTデバイスとデータを交換できるYandex IoT Coreを含む多くの新しいサービスの開始を発表しました。
 
 この記事では、Yandex IoT Coreが必要な理由とその仕組み、および他...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Yandex.Cloudのモノのインターネット：Yandex IoT CoreとYandex Cloud Functionsサービスの配置方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/491740/"><img src="https://habrastorage.org/webt/wf/_u/zo/wf_uzobkj9vxp2ddkzxzux7lhbo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
昨年10月、初のYandex Yandex Scaleクラウドカンファレンスが開催されました。数百万のIoTデバイスとデータを交換できるYandex IoT Coreを含む多くの新しいサービスの開始を発表しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、Yandex IoT Coreが必要な理由とその仕組み、および他のYandex.Cloudサービスとどのように相互作用するかについて説明します。アーキテクチャ、コンポーネントの相互作用の複雑さ、および機能の実装の機能について学びます-これらはすべて、これらのサービスの使用を最適化するのに役立ちます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、パブリッククラウドとPaaSの主な利点を思い出してみましょう-開発時間とコスト、およびIoTプロジェクトにも関連するサポートとインフラストラクチャのコストを削減します。しかし、クラウドで利用できる、それほど明確ではない便利な機能がいくつかあります。この効果的なスケーリングとフォールトトレランスは、特に重要な情報インフラストラクチャのプロジェクトでデバイスを操作する場合の重要な側面です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
効果的なスケーリングとは、技術的な問題を経験したり、変更後にシステムのコストの予測可能な変化を確認したりせずに、デバイスの数を自由に増減できる機能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォールトトレランスとは、一部のリソースに障害が発生した場合でも、可能な限り最高のパフォーマンスを保証するような方法でサービスが設計および展開されているという確信です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、詳細に入りましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IoTスクリプトアーキテクチャ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、IoTスクリプトの全体的なアーキテクチャがどのように見えるかを見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z_/po/yk/z_poykwjdwprirjgwkxmkvjnq0o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの大きな部分で区別できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つ目は、ストレージへのデータの配信とデバイスへのコマンドの配信です。</font><font style="vertical-align: inherit;">IoTシステムを構築するときは、どのプロジェクトを実行する場合でも、このタスクを解決する必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つ目は、受信したデータを処理することです。</font><font style="vertical-align: inherit;">すべては、データセットの分析と視覚化に基づく他のプロジェクトと同様です。</font><font style="vertical-align: inherit;">あなたはあなたの仕事を実現することを可能にするであろう情報の初期配列を持つリポジトリを持っています。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の部分はすべてのIoTシステムでほぼ同じです。一般的な原則に基づいて構築されており、ほとんどのIoTシステムに適した一般的なシナリオに適合します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の部分は、標準コンポーネントに基づいて構築されていますが、実行される機能の点でほとんど常に一意です。同時に、ハードウェアとの相互作用の高品質でフォールトトレラントでスケーラブルなシステムがなければ、単に分析するものがないため、アーキテクチャの分析部分の有効性はほぼゼロに低下します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、Yandex.Cloudチームはまず、デバイスからストレージにデータをすばやく、効率的かつ確実に配信し、デバイスにコマンドを送信する便利なサービスエコシステムの構築に集中することを決定しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tq/k8/ug/tqk8ugcmjnp3-s3cscc4ldhmuou.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの問題を解決するために、Yandex IoT Core、Yandex関数、およびクラウド内のデータストレージサービスの機能と統合に取り組んでいます。 </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex IoT Coreサービスは、マルチテナントのフェイルセーフでスケーラブルなMQTTブローカーであり、一連の追加の便利な機能を備えています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex Cloud Functionsサービスは有望なサーバーレスの方向性の代表であり、仮想マシンを作成して維持しなくても、安全でフォールトトレラントで自動的にスケーラブルな環境で関数としてコードを実行できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex Object Storageは、大規模なデータ配列の効果的なストレージであり、「履歴」アーカイブレコードに非常に適しています。</font></font></li>
<li>          ,    ,      Yandex Managed Service for ClickHouse,     «»  .       «»      ,       ,     ,             .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データストレージおよび分析サービスが、すでに多くのことについて記述されている「汎用」サービスである場合、Yandex IoT CoreとYandex Cloud Functionsとの相互作用は、特に物事のインターネットとクラウドテクノロジーを理解し始めたばかりの人々にとって、通常、多くの疑問を引き起こします。</font><font style="vertical-align: inherit;">また、これらのサービスはフォールトトレランスとデバイスでの作業のスケーリングを提供するため、最初にそれらが内部に何があるかを確認します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex IoT Coreの仕組み</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex IoT Coreは、MQTTプロトコルを実行するクラウドとデバイス間の双方向データ交換のための専用プラットフォームサービスです。実際、このプロトコルはデータをIoTに転送するための標準となっています。名前付きキュー（トピック）の概念を使用して、一方ではデータを書き込み、他方ではこのキューのイベントにサブスクライブすることで非同期にそれらを受信できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex IoT Coreサービスはマルチテナントです。つまり、すべてのユーザーがアクセスできる単一のエンティティです。つまり、すべてのデバイスとすべてのユーザーが同じサービスインスタンスと対話します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、一方で、すべてのユーザーの作業の均一性を確保し、他方で、無制限の数のデバイスとの接続を維持し、ボリュームと速度の両方で無制限の量のデータを処理するために、効果的なスケーリングとフォールトトレランスを確保できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このことから、負荷の変化に対応するために、サービスには冗長メカニズムと使用されるリソースを柔軟に管理する機能の両方が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、マルチテナンシーには、MQTTトピックへのアクセス権を共有する特別なロジックが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがどのように実装されているか見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の多くのYandex.Cloudサービスと同様に、Yandex IoT Coreは論理的に2つの部分、コントロールプレーンとデータプレーンに分かれています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8a/u0/f3/8au0f3pzmwa1v-hhsxikvo_l_0m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データプレーンはMQTTプロトコルでの操作のロジックを担当し、コントロールプレーンは特定のトピックへのアクセス権を区切る責任を負い、レジストリとデバイスの論理エンティティを使用します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/eu/b1/1n/eub11nm0nlmhprrhfqzohfwcyow.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各Yandex.Cloudユーザーは複数のレジストリを持つことができ、それぞれに独自のデバイスのサブセットを含めることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トピックへのアクセスは次のように提供されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/df/wc/hd/dfwchdy-bdwxs56mkgykrcs0ia4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デバイスは、イベントトピックとレジストリイベントトピックにのみデータを送信できます。</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/events</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コマンドのトピックとレジストリコマンドのトピックからのメッセージのみをサブスクライブします。</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/commands</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レジストリは、デバイスコマンドのすべてのトピックとレジストリコマンドのトピックにデータを送信できます。</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device2</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/commands</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デバイスイベントのすべてのトピックとレジストリイベントのトピックからのメッセージをサブスクライブします。</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device2</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/events</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のすべてのエンティティを操作するために、データプレーンにはgRPCプロトコルとRESTプロトコルがあり、それに基づいて、Yandex.CloudのGUIコンソールとCLIコマンドラインインターフェイスを介してアクセスが実装されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データプレーンに関しては、MQTTプロトコルバージョン3.1.1をサポートしています。</font><font style="vertical-align: inherit;">ただし、いくつかの機能があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接続するときは、必ずTLSを使用してください。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP接続のみがサポートされています。</font><font style="vertical-align: inherit;">WebSocketはまだ使用できません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">承認は、ログインとパスワード（ログインはデバイスまたはレジストリIDであり、パスワードはユーザーが設定する）と証明書の両方の両方で使用できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MQTTブローカーがフラグでマークされたメッセージを保存し、次回トピックにサブスクライブしたときに送信するときに、保持フラグはサポートされていません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MQTTブローカーが再接続を容易にするためにクライアント（デバイスまたはレジストリ）に関する情報を格納する永続セッションはサポートされていません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブスクライブおよびパブリッシュでは、最初の2つのサービスレベルのみがサポートされます。</font></font><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoS0-最大で1回。</font><font style="vertical-align: inherit;">配信の保証はありませんが、同じメッセージの再配信はありません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoS1-少なくとも1回。</font><font style="vertical-align: inherit;">配信は保証されますが、同じメッセージを再受信する可能性があります。</font></font></li>
</ol></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex IoT Coreへの接続を簡略化するために、GitHubのリポジトリにさまざまなプラットフォームと言語の新しい例を定期的に追加し、ドキュメントでスクリプトについても説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サービスアーキテクチャは次のよう</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6g/ig/4o/6gig4ofj7dksmbn18wvq5swkpuo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
になります。サービス</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">ビジネスロジックには4つの部分があります。</font></font><br>
<br>
<ol>
<li> Device management —     .   Control Plane.</li>
<li> MQTT Broker —  MQTT-.  Data Plane.</li>
<li> Triggers —     Yandex Cloud Functions.  Data Plane.</li>
<li> Shards —      MQTT-    .  Data Plane.</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「外の世界」とのすべての対話は、ロードバランサーを経由します。さらに、dogfoodの哲学に従って、すべてのYandex.Cloudユーザーが利用できるYandex Load Balancerが使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビジネスロジックの各部分は、各アベイラビリティーゾーン（スキームA、B、C）に1つずつ、3つの仮想マシンのいくつかのセットで構成されます。仮想マシンは、すべてのYandex.Cloudユーザーとまったく同じです。負荷が増加すると、セット全体を使用してスケーリングが発生します。ビジネスロジックの一部のフレームワーク内に3台のマシンが一度に追加されます。つまり、3つのMQTTブローカーマシンの1つのセットが負荷を処理できない場合、ビジネスロジックの他の部分の構成は同じままで、3つのMQTTブローカーマシンの別のセットが追加されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、Logbrokerのみが公開されていません。データストリームによる効率的なフェイルセーフ操作のためのサービスです。これはApache Kafkaに基づいていますが、他にも多くの便利な機能があります。災害復旧プロセス（重複のないメッセージ配信保証がある場合は1回限りのセマンティクスを含む）およびサービスプロセス（クロスセンターレプリケーション、データ配布など）を実装します。計算のクラスター）、およびフローサブスクライバー間でのデータの重複しない均一な分散のためのメカニズム（一種のロードバランサー）もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コントロールプレーンのデバイス管理機能については、上記で説明しています。しかし、データプレーンでは、すべてがはるかに興味深いものになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MQTTブローカーの各インスタンスは独立して動作し、他のインスタンスについては何も知りません。受信したすべてのデータ（顧客から公開）は、ブローカーによってLogbrokerに送信され、そこからシャードとトリガーによって取得されます。また、ブローカーのインスタンス間で同期が発生するのはシャードです。シャードは、すべてのMQTTクライアントと、MQTTブローカーのインスタンス間でのサブスクリプション（サブスクライブ）の分散について知っており、受信したデータの送信先を決定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、MQTTクライアントAはブローカーAからのトピックにサブスクライブし、MQTTクライアントBはブローカーBからの同じトピックにサブスクライブします。MQTTクライアントCが同じトピックにパブリッシュするがブローカーCに送信する場合、シャードはからデータを転送します。ブローカーCからブローカーAおよびBへ。その結果、データはMQTTクライアントAとMQTTクライアントBの両方で受信されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ia/dv/dz/iadvdzgd2cs6o1r3stjkqfhsq6y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビジネスロジックの最後の部分であるトリガーも、MQTTクライアントから受信したすべてのデータを受信し、これがユーザーによって構成されている場合は、それらをYandex Cloud Functionsサービスのトリガーに渡します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、Yandex IoT Coreのアーキテクチャと作業ロジックはかなり複雑で、ローカルインストールで繰り返すのは困難です。</font><font style="vertical-align: inherit;">これにより、3つのアベイラビリティーゾーンのうちの2つでも失われることに耐え、無制限の数の接続と無制限のデータボリュームを解決することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、このロジックはすべて「内部」でユーザーから隠されていますが、外部から見るとすべてが非常にシンプルに見えます。まるで、単一のMQTTブローカーで作業しているかのようです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トリガーとYandex Cloud Functions</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex Cloud Functionsは、Yandex.Cloudのいわゆる「サーバーレス」（サーバーレス）サービスの代表です。このようなサービスの主な本質は、ユーザーがコードを実行するための環境の設定、デプロイ、スケーリングに時間を費やすのではなく、必要なタスクを実行するコード自体を記述することだけです。関数の場合、これは、何らかのイベントによってトリガーされる、いわゆるアトミックステートレスコードです。 「アトミック」および「ステートレス」は、このコードは比較的小さいが不可欠なタスクを実行する必要があることを意味しますが、コードは、呼び出し間の値を格納するために変数を使用しないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数を呼び出す方法はいくつかあります：直接HTTP呼び出し、タイマー呼び出し（cron）、またはイベントサブスクリプション。後者として、サービスはすでにメッセージキュー（Yandexメッセージキュー）へのサブスクライブ、Object Storage Serviceによって生成されたイベント、および（IoTシナリオで最も価値のある）Yandex IoT Coreでのメッセージへのサブスクライブをサポートしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MQTT互換のクライアントを使用してYandex IoT Coreを操作できるという事実にもかかわらず、Yandex Cloud Functionsは、データを受信して​​処理するための最も最適で便利な方法の1つです。この理由は非常に簡単です。関数は任意のデバイスからのすべての着信メッセージで呼び出すことができ、関数は互いに並行して実行され（アトミック性およびステートレスアプローチにより）、デバイスからの着信メッセージの数が変化すると、呼び出しの数も自然に変化します。したがって、ユーザーはインフラストラクチャのセットアップの問題を完全に無視できます。さらに、同じ仮想マシンとは異なり、支払いは実際に実行された作業に対してのみ発生します。これにより、低負荷で大幅に節約でき、成長に伴って明確で予測可能なコストを獲得できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントで関数を呼び出す（イベントをサブスクライブする）メカニズムは、トリガー（トリガー）と呼ばれます。その本質を図に示し</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5u/yv/bn/5uyvbnyviueygxt4ykzdh9n2nug.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。関数を呼び出すためのイベントを生成</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">サービスは、それらをLogbrokerのキューに入れます。 Yandex IoT Coreの場合、データプレーンからのトリガーがこれを行います。さらに、これらのイベントはプリプロセッサによって取得されます。プリプロセッサは、呼び出される関数を示すこのイベントのデータベース内のレコードを探します。そのようなエントリが見つかると、プリプロセッサは関数呼び出しに関する情報（関数IDと呼び出しパラメータ）をYandexメッセージキューサービスのキューに入れ、そこからコールハンドラがピックアップします。次に、ハンドラーはYandex Cloud Functionsサービスに関数を呼び出すHTTPリクエストを送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、ドッグフーディングの哲学に従って、すべてのユーザーがアクセスできるYandex Message Queueサービスが使用され、他のユーザーが自分の関数を呼び出すのとまったく同じ方法で関数が呼び出されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex Message Queueについて少し説明しましょう。これは、Logbrokerと同様にキューサービスであるという事実にもかかわらず、それらの間には1つの大きな違いがあります。キューからのメッセージを処理するとき、ハンドラーはキューに完了したことを通知し、メッセージを削除できるようにします。これは、このようなサービスにおける重要な信頼性メカニズムですが、メッセージを処理するロジックが複雑になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex Message Queueを使用すると、キュー内の各メッセージの処理を「並列化」できます。つまり、現在処理中のキューからのメッセージは、別の「スレッド」が処理のためにキューから次のイベントを取得する可能性を妨げません。これはメッセージレベルの同時実行と呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、LogBrokerはメッセージグループを操作し、グループ全体が処理されるまで、次のグループを処理のためにピックアップすることはできません。このアプローチは、パーティションレベルでの同時実行と呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、まさにYandex Message Queueを使用することで、特定のサービスからのイベントで関数を呼び出すための多数のリクエストを迅速かつ効率的に並行して処理できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トリガーは独立した独立したユニットであるという事実にもかかわらず、トリガーはYandex Cloud Functionsサービスの一部です。関数がどのように呼び出されるかを正確に把握する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fb/ew/ke/fbewkedbrp6eyri7zkubwiu6dzu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数（外部および内部の両方）を呼び出すすべてのリクエストは、ロードバランサーに分類されます。ロードバランサーは、リクエストを異なるアクセスゾーン（AZ）のルーターに分散し、各ゾーンにいくつかのピースがデプロイされます。リクエストを受信すると、ルーターはまずIdentity and Access Manager（IAM）サービスにアクセスして、リクエストソースにこの関数を呼び出す権限があることを確認します。次に、スケジューラーに切り替えて、関数を実行するワーカーを尋ねます。ワーカーは、分離された機能のランタイムがカスタマイズされた仮想マシンです。さらに、機能を実行するワーカーのアドレスをスケジューラーから受け取ったルーターは、このワーカーにコマンドを送信して、特定のパラメーターで機能を開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
労働者はどこから来たのですか？これは、すべてのサーバーレスマジックが発生する場所です。スケジューラーは、負荷（機能の数と期間）を分析し、特定のランタイムで仮想マシンを管理（開始および停止）します。 NodeJSとPythonがサポートされるようになりました。そして、ここで1つのパラメーターが非常に重要です-関数を起動する速度。サービス開発チームは素晴らしい仕事をしてきました。現在、仮想マシンは最大250ミリ秒で起動し、機能を互いに分離するための最も安全な環境であるQEMU仮想化を使用しています。これは、すべてのYandex。Cloudを実行します。同時に、受信リクエストに対応するワーカーがすでに存在する場合、関数はほぼ瞬時に開始されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、同じドッグフーディングアプローチに従って、ロードバランサーはすべてのユーザーがアクセスできるパブリックサービスを使用し、ワーカー、スケジューラー、ルーターはすべてのユーザーと同じ通常の仮想マシンです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、サービスのフォールトトレランスは、ロードバランサーと主要なシステムコンポーネント（ルーターとスケジューラー）の冗長性のレベルで実装され、スケーリングはワーカーの展開または数の削減により発生します。</font><font style="vertical-align: inherit;">さらに、各アクセシビリティゾーンは独立して機能するため、3つのゾーンのうち2つでも失われても存続できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">役立つリンク</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論として、サービスをより詳細に研究できるリンクをいくつか示したいと思います。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex IoT Core：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloud.yandex.ru/services/iot-core</font></font></a> </li>
<li> Yandex Cloud Functions: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">cloud.yandex.ru/services/functions</a> </li>
<li> Yandex Message Queue: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">cloud.yandex.ru/services/message-queue</a> </li>
<li> Yandex Managed Service for ClickHouse: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">cloud.yandex.ru/services/managed-clickhouse</a> </li>
<li> Yandex Load Balancer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">cloud.yandex.ru/services/load-balancer</a> </li>
<li> Yandex Object Storage: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">cloud.yandex.ru/services/storage</a> </li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja491726/index.html">ネストされた列を展開する-R言語を使用したリスト（tidirパッケージとunnestファミリ関数）</a></li>
<li><a href="../ja491728/index.html">LaravelによるDRY原理</a></li>
<li><a href="../ja491732/index.html">スクラッチ後の人生はありますか、または子供をPythonに紹介する方法</a></li>
<li><a href="../ja491736/index.html">TMS1000：最初に市販されたマイクロコントローラー</a></li>
<li><a href="../ja491738/index.html">Centrifugo-非リアルタイムニュース</a></li>
<li><a href="../ja491742/index.html">シャーベット：人間工学に基づいたゲーミングキーボード</a></li>
<li><a href="../ja491744/index.html">イランのハッカーがVPNの脆弱性を悪用</a></li>
<li><a href="../ja491746/index.html">音声合成の歴史：電気的ソリューションの時代</a></li>
<li><a href="../ja491748/index.html">視覚障害者が英語を学ぶのを助ける技術</a></li>
<li><a href="../ja491750/index.html">教科書よりも部分文字列検索を書く</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>