<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👧🏾 🐇 🈴 Lorsque le filtre bloom ne rentre pas 👅 ◽️ 🧛🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je connaissais de l'université le filtre Bloom , une structure de données probabiliste nommée d'après Burton Bloom. Mais je n'ai pas eu l'occasion de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Lorsque le filtre bloom ne rentre pas</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491132/"><img src="https://habrastorage.org/webt/7x/rh/8w/7xrh8wafuzqnbs-o1jpgzjxtruw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je connaissais de l'université </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le filtre Bloom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , une structure de données probabiliste nommée d'après Burton Bloom. Mais je n'ai pas eu l'occasion de l'utiliser. Le mois dernier, une telle opportunité est apparue - et cette structure m'a littéralement fasciné. Cependant, j'ai vite trouvé des défauts en elle. Cet article est une histoire de ma brève histoire d'amour avec le filtre Bloom.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le processus de recherche de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'usurpation d'adresse IP,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> il a été nécessaire de vérifier les adresses IP dans les paquets entrants, en les comparant avec l'emplacement géographique de nos centres de données. Par exemple, les packages en provenance d'Italie ne doivent pas être envoyés au centre de données brésilien. Ce problème peut sembler simple, mais dans le paysage en constante évolution d'Internet, il est loin d'être simple. Qu'il suffise de dire qu'à la fin j'ai accumulé beaucoup de gros fichiers texte avec approximativement le contenu suivant: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7cf/4b4/f67/7cf4b4f67fdf8b4d8a88c2685051c15f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela signifie qu'une demande de l'adresse IP résolue 192.0.2.1 a été enregistrée dans le centre de données Cloudflare numéro 107. Ces données provenaient de nombreuses sources, y compris nos échantillons actifs et passifs, les journaux de certains domaines que nous possédons (par exemple,</font></font><code>cloudflare.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), les sources ouvertes (par exemple, les tables BGP), etc. La même ligne est généralement répétée dans plusieurs fichiers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je me suis retrouvé avec un gigantesque jeu de données de ce genre. </font><font style="vertical-align: inherit;">À un moment donné, dans toutes les sources collectées, j'ai compté 1 milliard de lignes. </font><font style="vertical-align: inherit;">Habituellement, j'écris des scripts bash pour prétraiter les données d'entrée, mais à cette échelle, cette approche n'a pas fonctionné. </font><font style="vertical-align: inherit;">Par exemple, la </font><font style="vertical-align: inherit;">suppression des </font><font style="vertical-align: inherit;">doublons de ce petit fichier de 600 lignes MiB et 40 millions prend ... l' </font><font style="vertical-align: inherit;">éternité: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfa/dc1/9c0/bfadc19c083b6a31bc34b568cdc81d74.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
il suffit de dire que les </font><font style="vertical-align: inherit;">lignes de </font><font style="vertical-align: inherit;">déduplication avec des </font><font style="vertical-align: inherit;">commandes ordinaires du type </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans diverses configurations (voir </font></font><code>--parallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>--buffer-size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>--unique</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) n'a pas été le meilleur pour un grand ensemble de données.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filtres Bloom</font></font></h1><br>
<img src="https://habrastorage.org/getpro/habr/post_images/3a6/110/0e6/3a61100e64277b6a515666b8bf0293f9.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Illustration de </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">David Epstein</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans le domaine public</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Alors ça m'est venu à l'esprit: ne triez pas les lignes! Vous devez supprimer les doublons, de sorte qu'une sorte de structure de données «définie» fonctionnera beaucoup plus rapidement. De plus, je connais à peu près la taille du fichier d'entrée (le nombre de lignes uniques), et la perte de certaines données n'est pas critique, c'est-à-dire que la structure de données probabiliste est tout à fait appropriée.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est parfait pour les filtres Bloom!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendant que vous lisez</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipédia sur les filtres Bloom, voici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comment je regarde cette structure de données.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment mettriez-vous en œuvre</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la pluralité</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Étant donné une fonction de hachage idéale et une mémoire infinie, nous pouvons simplement créer une image bitmap infinie et définir un nombre de bits pour chaque élément</font></font><code>hash(item)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cela fournit la structure de données idéale pour la «multitude». </font><font style="vertical-align: inherit;">Droite? </font><font style="vertical-align: inherit;">Trivialement. </font><font style="vertical-align: inherit;">Malheureusement, les fonctions de hachage entrent en collision, et la mémoire infinie n'existe pas, donc dans notre réalité, nous devons faire des compromis. </font><font style="vertical-align: inherit;">Mais nous pouvons calculer la probabilité de collisions et gérer cette valeur. </font><font style="vertical-align: inherit;">Par exemple, nous avons une bonne fonction de hachage et 128 Go de mémoire. </font><font style="vertical-align: inherit;">Nous pouvons calculer que la probabilité de collision pour chaque nouvel élément est comprise entre 1 et 1099511627776. Lorsque vous ajoutez d'autres éléments, la probabilité augmente à mesure que le bitmap est rempli. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, nous pouvons appliquer plusieurs fonctions de hachage et obtenir une image bitmap plus dense. </font><font style="vertical-align: inherit;">C'est là que le filtre Bloom fonctionne bien, qui est un ensemble de données mathématiques avec quatre variables:</font></font><br>
<br>
<ul>
<li><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - nombre d'éléments insérés (nombre cardinal)</font></font><br>
</li>
<li><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - mémoire utilisée par le bitmap</font></font><br>
</li>
<li><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - le nombre de fonctions de hachage calculées pour chaque entrée</font></font><br>
</li>
<li><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - probabilité de faux coïncidence positive</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compte tenu du nombre cardinal </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et de la probabilité souhaitée de faux positifs </font></font><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le filtre Bloom renvoie la mémoire requise </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et le nombre requis de fonctions de hachage </font></font><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Découvrez cette </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excellente visualisation de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thomas Hurst </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">sur la</font></a><font style="vertical-align: inherit;"> façon dont les paramètres s'influencent mutuellement.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-bloom</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Guidé par l'intuition, j'ai ajouté l'outil probabiliste mmuniq-bloom à mon arsenal, qui prend l'entrée STDIN et ne renvoie que des lignes uniques dans STDOUT. </font><font style="vertical-align: inherit;">Cela devrait être beaucoup plus rapide qu'une combinaison de </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font><code>uniq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le voilà:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-bloom.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour plus de simplicité et de rapidité, j'ai initialement défini quelques paramètres. Premièrement, sauf indication contraire, mmuniq-bloom utilise huit fonctions de hachage k = 8. Cela semble être proche du nombre optimal pour notre taille de données, et la fonction de hachage peut rapidement produire huit hachages décents. Ensuite, nous alignons la mémoire </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le bitmap à la puissance de deux pour éviter une opération coûteuse </font></font><code>%modulo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui en assembleur se résume à ralentir </font></font><code>div</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si le tableau est égal à la puissance de deux, nous pouvons simplement utiliser ET au niveau du bit (pour le plaisir, lisez </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comment les compilateurs optimisent certaines opérations de division en multipliant par une constante magique</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous pouvons l'exécuter sur le même fichier de données que nous avons utilisé auparavant:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3fa/019/d05/3fa019d05b8d6a72ad1ea3bde9c15a19.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh, c'est beaucoup mieux! 12 secondes au lieu de deux minutes. Le programme utilise une structure de données optimisée, une quantité de mémoire relativement limitée, une analyse de ligne optimisée et un bon tampon de sortie ... et avec tout cela, 12 secondes semblent être une éternité par rapport à l'outil </font></font><code>wc -l</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/953/ede/adb/953edeadb5701d03f92c7717f159f20d.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
que se passe-t-il? Je comprends qu'il est </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plus facile de </font><font style="vertical-align: inherit;">compter des chaînes </font><font style="vertical-align: inherit;">que de calculer des chaînes uniques, mais la différence de 26 fois est-elle vraiment justifiée? Que prend le CPU </font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Doit être pour le calcul des hachages. L'utilitaire </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne dépense pas le processeur, faisant tout ce calcul étrange pour chacune des 40 millions de lignes. J'utilise une fonction de hachage plutôt banale </font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, c'est sûr qu'elle brûle le processeur, non? Vérifions en exécutant uniquement la fonction de hachage, mais </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'effectuant aucune opération avec le filtre Bloom: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f5e/7a0/e0f/f5e7a0e0f26a3136ca3d0a9b362e0fe3.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
c'est étrange. </font><font style="vertical-align: inherit;">Le calcul de la fonction de hachage ne prend que deux secondes environ, bien que l'ensemble du programme de l'exécution précédente ait été exécuté pendant 12 secondes. </font><font style="vertical-align: inherit;">Un filtre Bloom fonctionne-t-il pendant 10 secondes? </font><font style="vertical-align: inherit;">Comment est-ce possible? </font><font style="vertical-align: inherit;">C'est une structure de données tellement simple ...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arme secrète - Profiler</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est temps d'appliquer le bon outil pour cette tâche - exécutons le profileur et voyons sur quoi le processeur travaille. Tout d'abord, exécutons </font></font><code>strace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour vérifier qu'il n'y a pas d'appels système inattendus: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7bc/29b/87c/7bc29b87cdeadac9a11ce78aa61129f6.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tout semble bien. Dix appels à </font></font><code>mmap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 ms chacun (3971 μs) sont intrigants, mais ça va. Nous pré-remplissons la mémoire </font></font><code>MAP_POPULATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour éviter plus tard les erreurs dues au manque de page. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelle est la prochaine étape? Bien sûr que ça l'est </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/1da/aa8/acc/1daaa8acc9e3a84d1f591ad94cd84387.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons ensuite le résultat: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/637/38f/3e2/63738f3e2a4bb1207927ecbc45b0cf3b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, nous brûlons vraiment 87,2% des cycles dans le code principal. Voyons où exactement. L'équipe </font></font><code>perf annotate process_line --source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">montre immédiatement quelque chose d'inattendu. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/17f/f6f/cc8/17ff6fcc833def72269a07f7fd54d9f0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On voit que 26,90% du processeur a grillé</font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Mais ce n'est pas tout! Le compilateur insère correctement la fonction et développe la boucle. Il s'avère que la plupart des cycles vont à ceci </font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou à la ligne </font></font><code>uint64_t v = *p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5c0/a3e/59c/5c0a3e59c8f954146bed3b2f1478e0ba.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De toute évidence, la perf est erronée, comment une chaîne aussi simple peut-elle occuper autant de ressources? Mais répéter le test avec n'importe quel autre profileur montre le même problème. Par exemple, j'aime utiliser google-perftools avec kcachegrind à cause des diagrammes colorés: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8af/fbd/e9e/8affbde9e2b92d4da89d445314ec4654.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le résultat de la visualisation est le suivant: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/130/ea3/9f9/130ea39f9a8c6a22c252381c3af88045.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Permettez-moi de résumer ce que nous avons découvert jusqu'à présent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'utilitaire standard </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traite un fichier de 600 Mio pour un temps processeur de 0,45 s. Notre outil optimisé </font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dure 12 secondes. Le processeur est gravé sur une seule instruction </font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, déréférençant la mémoire ...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6aa/3dd/e6a/6aa3dde6a6562dad5d0b3b2fa94c4565.jpg"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image de </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jose Nicdao</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , CC BY / 2.0</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Oh! Comment pourrai-je oublier. L'accès aléatoire à la mémoire est</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vraiment</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lent! Très, très, très lentement!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selon les</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chiffres que chaque programmeur devrait connaître</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, un seul accès à la RAM prend environ 100 ns. Comptons: 40 millions de lignes, 8 hachages chacune. Puisque notre filtre Bloom a une taille de 128 Mio, sur</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">notre ancien matériel,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il ne rentre pas dans le cache L3! Les hachages sont répartis uniformément sur une large gamme de mémoire - chacun d'eux génère un cache manquant. Mettez tout cela ensemble, et il s'avère que ...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b54/7e8/2e6/b547e82e6368f26843834121b1765103.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'avère que 32 secondes ne s'éteignent que sur les accès mémoire. Le vrai programme tient en seulement 12 secondes, car le filtre Bloom bénéficie toujours de la mise en cache. C'est facile à voir avec </font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2b8/199/785/2b8199785c666437f37b9d96c209670f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, nous aurions dû avoir un minimum de 320 millions de ratés de cache (LLC-load-misses), mais seulement 280 millions se sont produits: cela n'explique toujours pas pourquoi le programme a fonctionné en seulement 12 secondes. Mais ça ne fait rien. Il est important que le nombre d'échecs de cache soit un vrai problème, et nous ne pouvons le résoudre qu'en réduisant le nombre d'accès à la mémoire. Essayons de configurer le filtre Bloom pour utiliser une seule fonction de hachage: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/052/bec/d4f/052becd4ffe91553d1d3b01bfa53755b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ay! Ça fait vraiment mal! Pour obtenir une probabilité de collision de 1 pour 10 000 lignes, le filtre Bloom nécessitait 64 gigaoctets de mémoire. C'est horrible!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, il ne semble pas que la vitesse ait considérablement augmenté. </font><font style="vertical-align: inherit;">Il nous a fallu 22 secondes au système d'exploitation pour préparer la mémoire, mais nous avons quand même passé 11 secondes dans l'espace utilisateur. </font><font style="vertical-align: inherit;">Je crois que maintenant tous les avantages d'un accès plus rare à la mémoire sont compensés par une probabilité plus faible d'entrer dans le cache en raison de la taille de la mémoire fortement augmentée. </font><font style="vertical-align: inherit;">Auparavant, 128 Mio suffisaient pour le filtre Bloom!</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refuser les filtres Bloom</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout simplement ridicule. </font><font style="vertical-align: inherit;">Pour réduire la probabilité de faux positifs, vous devez soit utiliser beaucoup de hachages dans le filtre Bloom (par exemple, huit) avec beaucoup d'accès à la mémoire, soit laisser une fonction de hachage, mais utiliser d'énormes quantités de mémoire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, nous n'avons pas de limite de mémoire, nous voulons minimiser le nombre d'appels. </font><font style="vertical-align: inherit;">Nous avons besoin d'une structure de données qui coûte au maximum un cache manquant par élément et utilise moins de 64 gigaoctets de RAM ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr, vous pouvez implémenter des structures de données complexes, comme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un filtre à coucou</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais il existe certainement une option plus simple. </font><font style="vertical-align: inherit;">Qu'en est-il de la bonne vieille table de hachage de sondage linéaire? </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c29/a0d/136/c29a0d136e80e5fc0a6f90f1cab1378e.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Illustration de </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vadims Podans</font></font></a></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rencontrez mmuniq-hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici la nouvelle version de mmuniq-bloom utilisant une table de hachage:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-hash.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lieu des bits pour le filtre Bloom, nous stockons maintenant les hachages 64 bits de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la fonction 'siphash24'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cela offre une bien meilleure protection contre les collisions par hachage: bien meilleure qu'une par 10 000 lignes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comptons. </font><font style="vertical-align: inherit;">L'ajout d'un nouvel élément à une table de hachage, disons avec 40 millions d'entrées, donne la possibilité de collisions de hachage </font></font><code>40 000 000/2^64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">C'est environ 1 sur 461 milliards - une probabilité assez faible. </font><font style="vertical-align: inherit;">Mais nous n'ajoutons pas un élément à l'ensemble pré-rempli! </font><font style="vertical-align: inherit;">Au lieu de cela, nous ajoutons 40 millions de lignes à l'ensemble initialement vide. </font><font style="vertical-align: inherit;">Selon </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le paradoxe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">l'anniversaire</font></a><font style="vertical-align: inherit;"> , cela augmente considérablement la probabilité de collisions. </font><font style="vertical-align: inherit;">Une approximation raisonnable serait une estimation </font></font><code>'~n^2/2m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dans notre cas, il est</font></font><code>~(40M^2)/(2*(2^64))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il en résulte une chance sur 23 000. En d'autres termes, avec une bonne fonction de hachage, nous nous attendons à une collision dans l'un des 23 000 ensembles aléatoires de 40 millions d'éléments. Il s'agit d'une probabilité non nulle, mais toujours meilleure que dans le filtre Bloom, et elle est complètement tolérable pour notre cas d'utilisation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code avec une table de hachage fonctionne plus rapidement, il a de meilleurs modèles d'accès à la mémoire et une probabilité de faux positifs plus faible que dans le filtre Bloom.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/0ea/5c5/817/0ea5c5817289f136355f452748da0f86.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ne vous inquiétez pas de la ligne «conflits de hachage», elle montre simplement à quel point la table de hachage est pleine. </font><font style="vertical-align: inherit;">Nous utilisons la détection linéaire, donc lorsque nous entrons dans l'ensemble complet, nous prenons simplement le prochain vide. </font><font style="vertical-align: inherit;">Dans notre cas, nous devons sauter une moyenne de 0,7 séries pour trouver une place vide dans le tableau. </font><font style="vertical-align: inherit;">C'est normal. </font><font style="vertical-align: inherit;">Puisque nous parcourons les ensembles dans un ordre linéaire, la mémoire doit être qualitativement pleine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De l'exemple précédent, nous savons que notre fonction de hachage prend environ deux secondes. </font><font style="vertical-align: inherit;">Nous concluons que 40 millions d'accès à la mémoire prennent environ quatre secondes.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leçons apprises</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les processeurs modernes sont vraiment bons pour l'accès séquentiel à la mémoire lorsqu'il est possible de prédire les modèles d'échantillonnage (voir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la prélecture du cache</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). L'accès aléatoire à la mémoire, en revanche, coûte très cher. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les structures de données avancées sont très intéressantes, mais faites attention. Les ordinateurs modernes nécessitent l'utilisation d'algorithmes optimisés pour le cache. Lorsque vous travaillez avec des ensembles de données volumineux qui ne tiennent pas dans L3, l'optimisation sur le nombre de hits est préférable à l'optimisation sur la quantité de mémoire utilisée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est juste de dire que les filtres Bloom fonctionnent très bien lorsqu'ils sont placés dans le cache L3. Mais sinon, ils sont terribles. Ce n'est pas une nouveauté: les filtres Bloom sont optimisés pour la quantité de mémoire et non pour le nombre d'appels. Par exemple, voir</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article scientifique sur les filtres à coucou</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre chose est les discussions sans fin sur les fonctions de hachage. Honnêtement, dans la plupart des cas, cela n'a pas d'importance. Le coût du comptage même des fonctions de hachage complexes semble </font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faible par rapport au coût de l'accès aléatoire à la mémoire. Dans notre cas, la simplification de la fonction de hachage n'apportera qu'un petit avantage. Le temps CPU est simplement perdu ailleurs - en attente de mémoire! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un collègue dit souvent: «On peut supposer que les processeurs modernes sont infiniment rapides. Ils travaillent à une vitesse infinie, jusqu'à ce qu'ils </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reposent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contre le </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">mur de la mémoire</font></a><font style="vertical-align: inherit;"> . " </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, ne répétez pas mon erreur. Vous devez toujours effectuer le profilage avec</font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et regardez le compteur IPC (instructions par cycle). </font><font style="vertical-align: inherit;">S'il est inférieur à un, cela signifie généralement que le programme est bloqué en attente de mémoire. </font><font style="vertical-align: inherit;">Les valeurs optimales sont supérieures à deux. </font><font style="vertical-align: inherit;">Cela signifie que la charge de travail est principalement sur le CPU. </font><font style="vertical-align: inherit;">Malheureusement, dans mes tâches, l'IPC est encore faible ...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mmuniq supérieur</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec l'aide de collègues, j'ai écrit une version améliorée de l'outil mmuniq basée sur une table de hachage. </font><font style="vertical-align: inherit;">Voici le code:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il peut changer dynamiquement la taille de la table de hachage, prend en charge l'entrée avec un nombre cardinal arbitraire. </font><font style="vertical-align: inherit;">Ensuite, il traite les données en paquets, en utilisant efficacement l'indice </font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le processeur, ce qui accélère le programme de 35 à 40%. </font><font style="vertical-align: inherit;">Soyez prudent, une utilisation abondante </font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le code donne rarement effet. </font><font style="vertical-align: inherit;">Pour utiliser cette fonction, j'ai spécialement réorganisé les algorithmes. </font><font style="vertical-align: inherit;">Avec toutes les améliorations, le temps d'exécution a été réduit à 2,1 secondes:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e40/4df/9c4/e404df9c42a97be2f1051a69f98116e6.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la fin</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La création d'un outil de base qui tente de surpasser la combinaison «tri / uniq» a révélé certaines caractéristiques cachées de l'informatique moderne. </font><font style="vertical-align: inherit;">Après avoir un peu transpiré, nous avons accéléré le programme de plus de deux minutes à deux secondes. </font><font style="vertical-align: inherit;">Au cours du développement, nous avons découvert le retard de l'accès aléatoire à la mémoire, ainsi que la puissance des structures de données compatibles avec le cache. </font><font style="vertical-align: inherit;">Des structures de données bizarres attirent l'attention, mais dans la pratique, il est souvent plus efficace de réduire le nombre d'accès aléatoires à la mémoire.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr491116/index.html">Normes d'identification modernes: OAuth 2.0, OpenID Connect, WebAuthn</a></li>
<li><a href="../fr491118/index.html">Développeur Heart: Devkits de la 5ème génération de consoles (Partie 1)</a></li>
<li><a href="../fr491120/index.html">$ mol: 4 ans plus tard</a></li>
<li><a href="../fr491122/index.html">Analyse judiciaire des sauvegardes HiSuite</a></li>
<li><a href="../fr491130/index.html">Caractéristiques à retenir</a></li>
<li><a href="../fr491134/index.html">5 étapes d'inévitabilité de l'adoption de la certification ISO / IEC 27001. Négation</a></li>
<li><a href="../fr491136/index.html">Projection de contenu dans une documentation angulaire ou à contenu ng perdu</a></li>
<li><a href="../fr491138/index.html">Intégration satellite et tour Ansible</a></li>
<li><a href="../fr491146/index.html">UML pour les développeurs</a></li>
<li><a href="../fr491150/index.html">Comment j'ai piraté les escrocs, ou tout simplement l'intérieur des panneaux de phishing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>