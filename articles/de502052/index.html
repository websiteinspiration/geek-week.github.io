<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♻️ 🔄 🧗 Best Practices von Kubernetes. Erstellen Sie kleine Container 🧦 👩🏻‍🔧 🗣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der erste Schritt bei der Bereitstellung auf Kubernetes besteht darin, Ihre Anwendung in einem Container zu platzieren. In dieser Serie sehen wir uns ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Best Practices von Kubernetes. Erstellen Sie kleine Container</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/502052/"><img src="https://habrastorage.org/webt/bc/pv/j4/bcpvj4erzyasxzahyvqqlrc7y04.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste Schritt bei der Bereitstellung auf Kubernetes besteht darin, Ihre Anwendung in einem Container zu platzieren. In dieser Serie sehen wir uns an, wie Sie ein Bild eines kleinen und sicheren Containers erstellen können. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dank Docker war das Erstellen von Containerbildern noch nie so einfach. Geben Sie das Basis-Image an, fügen Sie Ihre Änderungen hinzu und erstellen Sie einen Container. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/i5/qe/jn/i5qejnsvy7prgkddy7b9cdfgeoo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl diese Technik für den Einstieg hervorragend geeignet ist, kann die Verwendung von Standardbildern standardmäßig zu unsicherer Arbeit mit großen Bildern führen, die voller Schwachstellen sind.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus verwenden die meisten Bilder in Docker Debian oder Ubuntu als Basis-Image. Obwohl dies eine hervorragende Kompatibilität und einfache Anpassung bietet (die Docker-Datei benötigt nur zwei Codezeilen), können Basis-Images Ihrem Container Hunderte von Megabyte zusätzliche Last hinzufügen. Eine einfache node.js-Datei der Go hello-world-Anwendung benötigt beispielsweise etwa 700 Megabyte, während die Größe Ihrer Anwendung selbst nur wenige Megabyte beträgt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ca/r-/eo/car-eo6tz-ovcb-nb3tfh8rifoa.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All diese zusätzliche Belastung ist somit eine Verschwendung von digitalem Speicherplatz und ein hervorragender Cache für Schwachstellen und Fehler im Sicherheitssystem. Schauen wir uns also zwei Möglichkeiten an, um die Größe eines Containerbilds zu verringern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste ist die Verwendung von Grundbildern kleiner Größe, das zweite ist die Verwendung des Entwurfsmuster-Builder-Musters. Die Verwendung kleinerer Basisbilder ist wahrscheinlich der einfachste Weg, um die Größe Ihres Containers zu verringern. Höchstwahrscheinlich liefert Ihre Sprache oder der Stapel, den Sie verwenden, ein ursprüngliches Anwendungsabbild, das viel kleiner als das Standardabbild ist. Werfen wir einen Blick auf unseren Container node.js.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wn/cl/xf/wnclxfmemicysaxmkdka2iecjiq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Standardmäßig beträgt die Größe des Basisknotens: 8-Images in Docker 670 MB und die Größe des Knotens: 8-alpine nur 65 MB, dh 10-mal kleiner. Durch die Verwendung des kleineren alpinen Basisbilds wird die Größe Ihres Containers erheblich reduziert. Alpine ist eine kleine und leichte Linux-Distribution, die bei Docker-Benutzern sehr beliebt ist, da sie mit vielen Anwendungen kompatibel ist und gleichzeitig die geringe Größe der Container beibehält. Im Gegensatz zum Standard-Docker-Image "node" entfernt "node: alpine" viele Dienstprogrammdateien und -programme, sodass nur diejenigen übrig bleiben, die für die Ausführung Ihrer Anwendung ausreichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu einem kleineren Basis-Image zu wechseln, aktualisieren Sie einfach die Docker-Datei, um mit dem neuen Basis-Image zu arbeiten:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vn/om/20/vnom20vd5gb1c1wmwpgnwslrxf8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Gegensatz zum alten Onbuild-Image müssen Sie jetzt Ihren Code in den Container kopieren und alle Abhängigkeiten installieren. In der neuen Docker-Datei beginnt der Container mit dem Bild node: alpine, erstellt dann ein Verzeichnis für den Code, installiert Abhängigkeiten mithilfe des NPM-Paketmanagers und startet schließlich server.js. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/x7/i3/_1/x7i3_14bs8tjo5kp-fsqh1kb5aw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit diesem Update ist ein Container zehnmal kleiner. Wenn Ihre Programmiersprache oder Ihr Stack das Basis-Image nicht reduzieren kann, verwenden Sie Alpine Linux. Es bietet auch die Möglichkeit, den Inhalt des Containers vollständig zu verwalten. Die Verwendung einfacher kleiner Bilder ist eine großartige Möglichkeit, schnell kleine Container zu erstellen. Mit dem Builder-Muster können Sie jedoch eine noch größere Reduzierung erzielen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uu/ad/ej/uuadejqnhgqhmg3-bsrcz5zvo5u.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In interpretierten Sprachen wird der Quellcode zuerst an den Interpreter übergeben und dann direkt ausgeführt. In kompilierten Sprachen wird der Quellcode zuerst in kompilierten Code konvertiert. Bei der Kompilierung werden jedoch häufig Tools verwendet, die zum Ausführen des Codes nicht wirklich benötigt werden. Dies bedeutet, dass Sie diese Werkzeuge vollständig aus dem endgültigen Container entfernen können. Sie können hierfür das Builder-Muster verwenden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5f/oj/nz/5fojnzzsh5ji6mumtiwgj1fquvm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code wird im ersten Container erstellt und kompiliert. Anschließend wird der kompilierte Code ohne die zum Kompilieren dieses Codes erforderlichen Compiler und Tools in den endgültigen Container gepackt. Lassen Sie uns die Go-App durch diesen Prozess überspringen. Zuerst werden wir vom Onbuild-Image zu Alpine Linux wechseln.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ls/ws/of/lswsofx6rz8wd9wo3pp7ptamwie.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der neuen Docker-Datei beginnt der Container mit dem Bild golang: alpine. Anschließend erstellt er ein Verzeichnis für den Code, kopiert es in den Quellcode, erstellt diesen Quellcode und startet die Anwendung. Dieser Container ist viel kleiner als der Onbuild-Container, enthält jedoch weiterhin den Compiler und andere Go-Tools, die wir nicht wirklich benötigen. Extrahieren wir also einfach das kompilierte Programm und legen es in unseren eigenen Container.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/xf/wy/sdxfwyghqamrsm-wuhaaxef4r4g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Möglicherweise bemerken Sie in dieser Docker-Datei etwas Seltsames: Sie enthält zwei FROM-Zeilen. Der erste Abschnitt mit 4 Zeilen sieht genauso aus wie die vorherige Docker-Datei, verwendet jedoch das Schlüsselwort AS, um diesen Schritt zu benennen. Im nächsten Abschnitt gibt es eine neue FROM-Zeile, mit der Sie ein neues Bild starten können. Anstelle des Golang: Alpine-Bildes wird Raw Alpine als Basisbild verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Raw Alpine Linux sind keine SSL-Zertifikate installiert, was dazu führt, dass die meisten HTTPS-API-Aufrufe fehlschlagen. Installieren Sie daher einige CA-Stammzertifikate.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt das Interessanteste: Um den kompilierten Code vom ersten Container in den zweiten zu kopieren, können Sie einfach den Befehl COPY in der 5. Zeile des zweiten Abschnitts verwenden. Es wird nur eine Anwendungsdatei kopiert und die Go-Dienstprogramme werden nicht beeinflusst. Die neue mehrstufige Docker-Datei enthält ein Container-Image mit einer Größe von nur 12 Megabyte, während das ursprüngliche Container-Image 700 Megabyte groß war. Dies ist ein großer Unterschied! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Verwendung kleiner Basisbilder und Builder-Muster ist daher eine großartige Möglichkeit, viel kleinere Container ohne viel Arbeit zu erstellen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist möglich, dass es je nach Anwendungsstapel zusätzliche Möglichkeiten gibt, die Größe des Bildes und des Containers zu reduzieren. Haben kleine Container jedoch wirklich einen messbaren Vorteil? Schauen wir uns zwei Aspekte an, bei denen kleine Container äußerst effektiv sind - Leistung und Sicherheit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berücksichtigen Sie zur Bewertung der Leistungssteigerung die Dauer des Erstellungsprozesses eines Containers, dessen Einfügung in die Registrierung (Push) und anschließendes Abrufen von dort (Pull). Sie sehen, dass ein kleinerer Container einen unbestreitbaren Vorteil gegenüber einem größeren Container hat.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vk/0b/d0/vk0bd0bv3wcsxd-mv5xhmfntypk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Docker speichert die Ebenen im Cache, sodass nachfolgende Builds sehr schnell sind. In vielen CI-Systemen, die zum Erstellen und Testen von Containern verwendet werden, werden Ebenen jedoch nicht zwischengespeichert, sodass erhebliche Zeiteinsparungen erzielt werden. Wie Sie sehen können, beträgt die Zeit zum Erstellen eines großen Containers je nach Leistung Ihrer Maschine 34 bis 54 Sekunden und bei Verwendung eines mit dem Builder-Muster reduzierten Containers 23 bis 28 Sekunden. Für Operationen dieser Art beträgt der Produktivitätsgewinn 40-50%. Überlegen Sie sich also, wie oft Sie Ihren Code erstellen und testen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem der Container erstellt wurde, müssen Sie sein Image (Push-Container-Image) in die Container-Registrierung einfügen, um Kubernetes in Ihrem Cluster verwenden zu können. Ich empfehle die Verwendung der Google-Containerregistrierung.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8j/x2/nc/8jx2ncmiv6r6op7ii8yn7di00ru.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Verwendung der Google Container Registry (GCR) zahlen Sie nur für den Rohspeicher und das Netzwerk, und es fällt keine zusätzliche Gebühr für die Containerverwaltung an. Es ist vertraulich, sicher und sehr schnell. GCR verwendet viele Tricks, um den Pull-Vorgang zu beschleunigen. Wie Sie sehen können, dauert das Einfügen eines Docker Container Image-Container-Images mit go: onbuild je nach Computerleistung 15 bis 48 Sekunden, und der gleiche Vorgang mit einem kleineren Container dauert 14 bis 16 Sekunden. Bei weniger effizienten Maschinen erhöht sich der Vorteil der Betriebsgeschwindigkeit um dreimal. Bei großen Computern ist die Zeit ungefähr gleich, da GCR den globalen Cache für eine gemeinsame Datenbank mit Bildern verwendet, dh Sie müssen sie überhaupt nicht herunterladen. In einem Computer mit geringem Stromverbrauch ist die CPU ein Engpass.Daher ist der Vorteil der Verwendung kleiner Behälter hier viel greifbarer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie GCR verwenden, empfehle ich dringend, Google Container Builder (GCB) als Teil Ihres Build-Systems zu verwenden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/td/fp/b8/tdfpb8jpar4jfjk0ifhsd1ja8sa.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen, können Sie mit dieser Funktion die Dauer des Build + Push-Vorgangs viel besser reduzieren als auf einer produktiven Maschine. In diesem Fall ist das Erstellen und Senden von Containern an den Host fast doppelt so schnell. Darüber hinaus erhalten Sie jeden Tag 120 Minuten kostenlose Montage, was in den meisten Fällen den Anforderungen für die Erstellung von Containern entspricht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes folgt die wichtigste Leistungsmetrik - die Geschwindigkeit des Extrahierens oder Herunterladens von Pull-Containern. Und wenn Sie sich nicht wirklich für die Zeit interessieren, die für den Push-Vorgang aufgewendet wird, wirkt sich die Dauer des Pull-Vorgangs ernsthaft auf die Gesamtleistung des Systems aus. Angenommen, Sie haben einen Cluster aus drei Knoten, von denen einer abstürzt. Wenn Sie ein Verwaltungssystem wie Google Kubernetes Engine verwenden, wird der inaktive Knoten automatisch durch einen neuen ersetzt. Dieser neue Knoten ist jedoch vollständig leer, und Sie müssen alle Container in ihn ziehen, damit er funktioniert. Wenn der Pull-Vorgang lang genug ist, arbeitet Ihr Cluster die ganze Zeit mit geringerer Leistung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt viele Fälle, in denen dies passieren kann: Hinzufügen eines neuen Knotens zu einem Cluster, Aktualisieren von Knoten oder sogar Wechseln zu einem neuen Container zur Bereitstellung. Somit wird die Minimierung der Pull-Extraktionszeit zu einem Schlüsselfaktor. Es ist unbestreitbar, dass ein kleiner Container viel schneller heruntergeladen wird als ein großer. Wenn Sie mehrere Container in einem Kubernetes-Cluster verwenden, kann die Zeitersparnis erheblich sein. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9n/lv/1d/9nlv1dlgiem9o83xxuwyqu-kqje.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich den Vergleich an: Der Pull-Vorgang beim Arbeiten mit kleinen Containern dauert je nach Leistung der Maschine 4-9 mal kürzer als der gleiche Vorgang mit go: onbuild. Die Verwendung gängiger Basisimages von kleinen Containercontainern beschleunigt die Zeit und Geschwindigkeit, mit der neue Kubernetes-Knoten bereitgestellt und online geschaltet werden können, erheblich.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns das Thema Sicherheit an. Kleinere Container gelten als viel sicherer als große Container, da sie eine kleinere Angriffsfläche haben. Ist das wirklich? Eine der nützlichsten Funktionen der Google Container Registry ist die Möglichkeit, Ihre Container automatisch auf Schwachstellen zu scannen. Vor einigen Monaten habe ich sowohl Onbuild- als auch mehrstufige Container erstellt. Lassen Sie uns also sehen, ob dort Schwachstellen vorhanden sind.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/b-/hy/n3/b-hyn3ocsdqhydufmjpfef5rgv0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis ist erstaunlich: In einem kleinen Container wurden nur 3 mittlere Sicherheitslücken gefunden, in einem großen 16 kritische und 376 andere Sicherheitslücken. </font><font style="vertical-align: inherit;">Wenn Sie sich den Inhalt eines großen Containers ansehen, sehen Sie, dass die meisten Sicherheitsprobleme nichts mit unserer Anwendung zu tun haben, sondern sich auf Programme beziehen, die wir nicht einmal verwenden. </font><font style="vertical-align: inherit;">Wenn Leute über eine große Fläche für Angriffe sprechen, meinen sie genau das. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xw/tw/ba/xwtwbakf57ubzw_ivsbycxzpzk4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Schlussfolgerung liegt auf der Hand: Erstellen Sie kleine Container, da diese echte Vorteile für die Leistung und Sicherheit Ihres Systems bieten. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Best Practices von Kubernetes. </font><font style="vertical-align: inherit;">Kubernetes Organisation mit Namespace</font></font></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/wGz_cbtCiEA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein bisschen Werbung :)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielen Dank für Ihren Aufenthalt bei uns. Gefällt dir unser Artikel? Möchten Sie weitere interessante Materialien sehen? Unterstützen Sie uns, indem Sie eine Bestellung </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">aufgeben</font></a><font style="vertical-align: inherit;"> oder Ihren Freunden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud-basiertes VPS für Entwickler ab 4,99 US-Dollar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> empfehlen </font><font style="vertical-align: inherit;">, ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einzigartiges Analogon von Einstiegsservern, das von uns für Sie erfunden wurde: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die ganze Wahrheit über VPS (KVM) E5-2697 v3 (6 Kerne) 10 GB DDR4 480 GB SSD 1 Gbit / s ab 19 $ oder wie teilt man den Server?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verfügbar). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2-mal günstiger im Equinix Tier IV-Rechenzentrum in Amsterdam?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nur wir haben </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2,6 GHz 14C 64 GB DDR4 4 x 960 GB SSD 1 Gbit / s 100 TV von 199 US-Dollar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in den Niederlanden!</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R420 - 2x E5-2430 2,2 GHz 6C 128 GB DDR3 2x960 GB SSD 1 Gbit / s 100 TB - ab 99 US-Dollar! </font></font></b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wie Sie eine Infrastruktur aufbauen </font><font style="vertical-align: inherit;">Klasse C mit Dell R730xd E5-2650 v4-Servern für 9.000 Euro für einen Cent?</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de502038/index.html">Ein Atom anheben, Ansatz 2.0.1</a></li>
<li><a href="../de502040/index.html">Über Phrasal Verbs-5 (hoch / runter)</a></li>
<li><a href="../de502046/index.html">Fünf Jahre Rost</a></li>
<li><a href="../de502048/index.html">Komplexes Verhalten ohne neuronale Netze und Training. Die philosophische Basis</a></li>
<li><a href="../de502050/index.html">Ein paar Anmerkungen zur Kultur</a></li>
<li><a href="../de502054/index.html">Faltungsneurales Netzwerk und seine Integration in iOS (Teil 2)</a></li>
<li><a href="../de502068/index.html">110 Volt an Ihrem Computer</a></li>
<li><a href="../de502070/index.html">Die Geschichte von Pentax (Artikel plus Video)</a></li>
<li><a href="../de502072/index.html">Andocken der ISS mit JavaScript und Kompass</a></li>
<li><a href="../de502076/index.html">Trolley Robot 2.0. Teil 1. Autonome Navigation eines Heimroboters basierend auf ROS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>