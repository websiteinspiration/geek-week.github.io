<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí≤ üôåüèø üóëÔ∏è How 3D game rendering works: lighting and shadows üçî üòß üà¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The implementation of the vast majority of visual effects in modern games depends on the judicious use of lighting and shadows. Without them, games wo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>How 3D game rendering works: lighting and shadows</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501438/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The implementation of the vast majority of visual effects in modern games depends on the judicious use of lighting and shadows. </font><font style="vertical-align: inherit;">Without them, games would be boring and lifeless. </font><font style="vertical-align: inherit;">In the fourth part of the analysis of the rendering of 3D games, we will focus on what is happening in the 3D world along with vertex processing and texture mapping. </font><font style="vertical-align: inherit;">We will again need a lot of mathematics, as well as a solid understanding of the basics of optics. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 1: vertex processing </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 2: rasterization and ray tracing </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 3: texturing and filtering textures</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recall the past</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Earlier, we examined the key aspects of moving and processing objects in scenes, their conversion from three-dimensional space to a flat grid of pixels, as well as ways to apply textures to these objects. For many years, such operations have been an essential part of the rendering process, and we can see this by returning in 1993 and launching id Software's Doom.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fe/056/d0c/2fe056d0c0f37ac3a2970bdc485b79a5.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By modern standards, the use of light and shadow in this game was very primitive: the light sources were not taken into account, each surface based on its vertices was given a general color value or the value of the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ambient light</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . All the signs of shadows were created thanks to the cunning use of textures and the choice of the color of the environment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There were no shadows, because they were not the task of programmers: the PC of that time was a 66 MHz processor (that is, 0.066 GHz!), A 40 MB hard drive and a 512-kilobyte graphics card with minimal 3D capabilities. Fast forward 23: in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">famous reboot of the series,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we see a completely different story.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b5/3ca/da0/3b53cada0530afabe788b4a70a0b7319.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lot of technologies were</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> used to render this frame </font><font style="vertical-align: inherit;">, it boasts such stages as screen space ambient occlusion, pre-pass depth mapping, bokeh blur filters, tone correction operators, and so on. </font><font style="vertical-align: inherit;">The calculation of lighting and shading of each surface is performed dynamically: they are constantly changing depending on the environmental conditions and the player‚Äôs actions.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since any 3D rendering operation requires mathematics (a whole bunch of calculations!), We better start with what happens behind the scenes of any modern game.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Math lighting</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To implement everything correctly, we need to accurately simulate the behavior of light when interacting with various surfaces. It is curious that for the first time this problem began to be solved in the 18th century by a man named Johann Heinrich Lambert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In 1760, a Swiss scientist released a book called </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Photometria</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In it, he outlined the fundamental rules of the behavior of light; the most remarkable of them was the following - the surface emits light (by reflection or as a light source) in such a way that the brightness of the emitted light varies depending on the cosine of the angle between the normal surface and the observer.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/6a2/f0c/2626a2f0c2f80f30bf5208decab2493c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This simple rule laid the foundation for so-called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diffuse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lighting. </font><font style="vertical-align: inherit;">This is a mathematical model used to calculate the color of a surface depending on its physical properties (for example, its color and degree of light reflection) and the location of the light source. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In 3D rendering, this requires a lot of information, which is easiest to imagine in the form of such a scheme:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/918/d57/386/918d573864315b11e91405d8e692c59f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We see a lot of arrows in the image, these </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are vectors</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and the following vectors are required to calculate color:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 vectors for vertex position, light source and camera looking at the scene</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 vectors for the directions of the light source and the camera from the point of view of the vertex</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 normal vector</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 half-vector (it is always in the middle between the direction vectors of the lighting and the camera)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
They are calculated at the stage of processing the vertices of the rendering process, and the equation uniting them all (called the Lambert model) has the form:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/267/ba6/279/267ba627905209780406c2148469a7ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, the color of the vertex under diffuse lighting is calculated by multiplying the color of the surface, the color of the light source and the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scalar product</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of the normal vectors of the vertex and the direction of light with the attenuation and projection lighting coefficients. </font><font style="vertical-align: inherit;">This operation is performed for each light source in the scene, hence the sum symbol at the beginning of the equation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The vectors in this equation (and everything that we see below) are </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normalized</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (as shown by the icons above each vector). </font><font style="vertical-align: inherit;">The normalized vector retains its original direction, and its length decreases to a unit value (i.e., equal to 1 unit of measurement).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The color values ‚Äã‚Äãof the surface and light source are standard RGBA numbers (red, green, blue, and alpha transparency). They can be integer (for example, INT8 for each color channel), but almost always are floating point numbers (for example, FP32). The attenuation coefficient determines how the level of illumination decreases when moving away from the source, and is calculated by another equation:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ac/17e/a22/6ac17ea2263bf82f6a2e2571bd88e0b0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The terms A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are different coefficients (constant, linear, quadratic) that describe how the distance affects the lighting level. All of them are set by programmers when creating a rendering engine. In each graphical API, this is implemented in its own way, but coefficients are introduced when encoding the type of light source. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before we consider the last coefficient (floodlight), it is worth noting that in 3D rendering there are essentially three types of light sources: spot, directional and flood.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/2be/9ce/3492be9ce1ccf5526a05bb0702f84c35.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Point sources evenly emit light in all directions, and directional sources emit light in only one direction (from the point of view of mathematics, this is just a point source, remote at an infinite distance). Spotlights are complex directional sources as they emit light in the shape of a cone. The way light varies in the body of the cone determines the size of the inner and outer parts of the cone. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And yes, for the searchlight coefficient, there is another equation:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/06a/b47/d9c/06ab47d9c2a0f7d85519d5de77cb299b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The value of the projector coefficient is either 1 (i.e., the source is </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not a</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> projector), or 0 (if the vertex is outside the cone direction), or some calculated value between the two. The angles </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">œÜ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (phi) and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Œ∏</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (theta) specify the dimensions of the inner / outer part of the cone of the spotlight. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Two vectors: L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dcs</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dir</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (inverse to camera direction and spotlight direction) are used to determine if the cone of the vertex is touching. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we should remember that all this is necessary to calculate the value of the diffuse lighting, and all these operations must be performed for </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">each</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the lighting source in the scene, or at least for each source that the programmer wanted to consider. Many of these equations are executed by graphical APIs, but they can also be done manually if encoders need more control over the image. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, in the real world, in fact, there are an </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">infinite</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> number of light sources: each surface reflects the lighting, so they all affect the overall lighting of the scene. Even at night there is background lighting, whether it is stars and planets or light scattered in the atmosphere. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To simulate this, another lighting value is calculated: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ambient</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lighting.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/73b/e8e/94473be8edd6d85ce822d059f021d9a7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This equation is simpler than for diffuse lighting because directions are not required. </font><font style="vertical-align: inherit;">Here, a simple multiplication of various coefficients is performed:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - surface illumination color</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GA</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - highlight color of the global 3D scene</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LA</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - color of illumination of all light sources in the scene</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is worth noting that the attenuation and projector coefficients are again used, as well as the summation of all light sources. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we have background lighting and we took into account the diffuse lighting of light sources from various surfaces of the 3D world. But the Lambert model works only for materials that reflect lighting from its surface in all directions; objects made of glass or metal create another type of reflection called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">specular</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; Naturally, there is an equation for him too!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6b/a60/a49/d6ba60a49dae7eb88da90c7ef26936bf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The individual parts of this formula should already be familiar to you: we have two values ‚Äã‚Äãof the mirror color (one for the surface - C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the other for light - C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LS</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), as well as the usual attenuation and flood factors. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the specular reflection is very focused and directed, two vectors are used to determine the brightness of the specular illumination: the vertex normal and the semi-vector. The coefficient </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is called the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">power of specular reflection</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , this is a number that determines the brightness of reflection depending on the properties of the surface material. As p increases, the mirror effect becomes brighter, but more focused and smaller.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The last element to be considered is the simplest because it is just a number. </font><font style="vertical-align: inherit;">It is called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emissive</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lighting, and is applied to objects that are a direct source of lighting, that is, to a flame, a flashlight, or the Sun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This means that now we have one number and three sets of equations for calculating the color of the vertex of the surface, taking into account the background lighting (environment), as well as the interaction between different light sources and the properties of the surface material (diffuse and specular). </font><font style="vertical-align: inherit;">Programmers can choose only one or combine all four by simply folding them.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/679/5d4/fc3/6795d4fc38199eed97d7e1fb875556d5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visually, the combination looks like this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/158/be2/f53/158be2f5318b5cbb2a142e166d1299ad.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The equations considered by us are applied by graphic APIs (for example, Direct3D and OpenGL) using their standard functions, but for each type of lighting there are alternative algorithms. </font><font style="vertical-align: inherit;">For example, diffuse lighting can be implemented using </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Oren-Nayyar model</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is better suited for very rough surfaces than the Lambert model. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The mirror reflection equation can be replaced by models that take into account the fact that very smooth surfaces like glass or metal are still rough, but at a microscopic level. </font><font style="vertical-align: inherit;">Such models, called </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">micro facet algorithms</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , at the cost of mathematical complexity, provide more realistic images.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Whatever model is used, they are all greatly improved by increasing the frequency of their application to the 3D scene.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertex or pixel-by-pixel calculations</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When we examined </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vertex processing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rasterization</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we saw that the results of all the tricky lighting calculations performed for each vertex should be interpolated over the surface between the vertices. </font><font style="vertical-align: inherit;">This is because the properties associated with the surface material are stored inside the vertices; </font><font style="vertical-align: inherit;">when the 3D world is compressed into a 2D pixel grid, the pixels remain only where the vertex was.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/129/bc3/e90/129bc3e90652de62263813f5274dea2c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The rest of the pixels need to transmit information about the color of the vertices so that the colors mix correctly on the surface. In 1971, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Henri Gouraud</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then a graduate student at the University of Utah, proposed a method now called </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gouraud Shading</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
His method was computationally fast and for many years became the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de facto</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> standard, but he also had problems. He could not correctly interpolate the mirror lighting, and if the object was composed of a small number of primitives, then mixing between the primitives seemed erroneous.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A solution to this problem was proposed in 1973 by Bui Tyong Fong, who also worked at the University of Utah. In his research article, Fong demonstrated a technique for interpolating the normals of vertices on rasterized surfaces. This meant that the scattered and specular reflection models would work correctly for each pixel, and we can clearly see this in </font><font style="vertical-align: inherit;">David Eck's </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">online</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> computer graphics and WebGL </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">tutorial</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The carbon spheres shown below are colored with the same lighting model, but for left-handed calculations are performed vertically, followed by Gouraud shading to interpolate them over the entire surface. For the sphere on the right, the calculations are done pixel by pixel, and the difference is obvious.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10a/5b1/329/10a5b13292d99d5250cfbfba7c737a6a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Still images do not convey all the improvements that were brought by </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shading over Phong</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but you can independently run the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">online demo of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ek and watch the animation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, Fong did not stop there, and a couple of years later he published another research article in which he showed how separate calculations for ambient, diffuse, and specular reflection can be performed with one simple equation:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c0/cf9/613/0c0cf9613d8d536c4cdb16750bbca092.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we have to seriously understand! The values ‚Äã‚Äãindicated by the letter </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are the reflection constants for the ambient, diffuse, and specular reflections. Each of them is a fraction of the corresponding type of reflected light from the magnitude of the incident light; </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> values </font><font style="vertical-align: inherit;">we saw in the equations above (color values ‚Äã‚Äãof the surface material for each type of lighting). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The vector </font></font><strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the ‚Äúperfect reflection‚Äù vector ‚Äî the direction in which the reflected light would move if the surface were perfectly smooth; it is calculated using the surface normal and the incident light vector. Vector </font></font><strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the camera direction vector; and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C are</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> normalized.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, there is the last constant in the equation: the value of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Œ±</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> determines the degree of surface gloss. The smoother the material (i.e. the more it resembles glass or metal), the higher the number. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This equation is usually called </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Phong reflection model</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . At the time of his research, such a proposal was radical, because it required serious computing resources. A simplified version of the model was created by </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jim Blinn</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , replacing the part of the formula from </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (half-distance vector and surface normal). The value of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> must be calculated for each light source and for each pixel in the frame, and</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H is</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enough to calculate once for each source and for the whole scene. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Blinn-Fong reflection model</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is today the standard lighting system and is used by default in Direct3D, OpenGL, Vulkan, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are many other mathematical models, especially now that GPUs can process pixels in long and complex shaders; together, such formulas are called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bidirectional reflectance / transmission distribution functions</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (BRDF / BTFD); they are the foundation for coloring every pixel on the monitor when we play modern 3D games. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, so far we have considered only surfaces </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reflecting</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> light: translucent materials transmit light, while the rays of light are </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">refracted</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And some surfaces. </font><font style="vertical-align: inherit;">for example, water reflect and transmit light to varying degrees.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We take lighting to a new level</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's take a look at the 2018 </font><font style="vertical-align: inherit;">Ubisoft </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assassin's Creed: Odyssey</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> game, in which the player often goes sailing on water, both in shallow rivers and in the deep sea.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/032/29d/358/03229d3582d6b574b0089a5480cfc08b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Painted wood, metal, ropes, fabric and water - all this reflects and refracts light using a bunch of calculations.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
For the most realistic rendering of water while maintaining a sufficient speed of the game, Ubisoft programmers used a whole set of tricks. The surface of the water is illuminated by the familiar trio of ambient, diffused, and specular light, but they are complemented by interesting features. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first of these is often used to generate the reflective properties of water - these are </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">screen space reflections</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (SSR). This technique renders the scene, but the colors of the pixels depend on the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depth of</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> each pixel, i.e. from his distance to the camera. Depth is stored in the so-called </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depth buffer</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Then the frame is rendered again with all the usual lighting and texturing, but the scene is saved as </font></font><em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">render texture</font></font></a></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and not as a ready buffer that is transmitted to the monitor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After that, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ray marching</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is performed </font><font style="vertical-align: inherit;">. To do this, rays are emitted from the camera and distances are set along the course of the beam. The code checks the depth of the beam relative to the pixels in the depth buffer. If they have the same value, the code checks the normal pixel to see if it is directed to the camera, and if so, the engine looks for the corresponding pixel from the render texture. Then a further set of instructions inverts the position of the pixel so that it is correctly reflected in the scene.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/645/58b/1d1/64558b1d13b6bc349bd728278ec9686a.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The SSR order used in EA's Frostbite engine.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In addition, light is scattered during movement within materials, and for materials like water or leather, another trick called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sub-surface scattering</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (SSS) is used. We will not explain it in detail, but you can read how it is used to create such amazing results in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the 2014 Nvidia presentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23c/0e1/598/23c0e15983c2cfe6b17ba3d0aab97dc5.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nvidia's 2013 FaceWorks demo ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Let's </font><i><font style="vertical-align: inherit;">get</font></i><font style="vertical-align: inherit;"> back to Assassin's Creed water: the SSS implementation is hardly noticeable here, and due to speed considerations, it is not used as much. In previous games of the AC series, Ubisoft </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used fake SSS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but in the last game its use is more complicated, but still not as large as we saw in the Nvidia demo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To change the lighting values ‚Äã‚Äãon the water surface, additional procedures are performed that correctly simulate the effects of depth due to a change in transparency depending on the distance to the coast. And when the camera looks at the water near the coast, even more algorithms are used to take into account caustics and refraction. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The results are impressive:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb2/486/f56/cb2486f5697db7c578797127371af936.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assassin's Creed: Odyssey - rendering water in all its glory.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
We looked at water, but what about the movement of light in the air? Dust particles, moisture and other elements also lead to light scattering. As a result, the rays of light receive </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">volume</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and do not remain just a set of direct rays. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The topic of volumetric lighting can be extended to a dozen articles, so we will talk about how the game </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rise of the Tomb Raider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deals with it </font><font style="vertical-align: inherit;">. In the video below, there is only one main source of lighting - the sun shining through the opening in the building.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/3w9rHXIYjI4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To create a volume of light, the game engine takes the camera visibility pyramid (see below) and exponentially breaks it in depth into 64 parts. Then, each slice is rasterized into grids with a size of 160 x 94 elements, and all this data is saved in three-dimensional render texture of the FP32 format. Since textures are usually two-dimensional, the ‚Äúpixels‚Äù of the pyramid‚Äôs volume are called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voxels</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b1/857/5cf/3b18575cfb0114e1b8ba8c152c4c4bd1.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a 4 x 4 x 4 voxel block, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">computational shaders</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> determine which active light sources affect this volume, and then write this information to another three-dimensional render texture. Then, to estimate the total ‚Äúdensity‚Äù of light inside the voxel block, a complex formula called the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://web.archive.org/web/20141102063940/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hengy-Greenstein scattering function is used</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then the engine performs several more shaders to refine the data, after which ray marching is performed along the slices of the pyramid with the accumulation of light density values. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eidos-Montr√©al claims</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that on Xbox One all of these operations take approximately 0.8 milliseconds!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although this technique is not used in all games, players expect to see volumetric coverage in almost all popular 3D games released today, especially in first-person shooters and action-adventure games.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/e06/b34/064e06b347c8e5cafe892fbdde2d14de.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The volumetric lighting used in the Rise of the Tomb Raider sequel of 2018.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Initially, this lighting technique was called "divine rays", or, as they are called in scientific terms, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"twilight rays</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><em><font style="vertical-align: inherit;">"</font></em><font style="vertical-align: inherit;"> One of the first games in which it was used was </font><font style="vertical-align: inherit;">Crytek's </font><font style="vertical-align: inherit;">first </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crysis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , released in 2007. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, this was not true volumetric lighting - the process included the initial rendering of the scene in the form of a depth buffer, which was used as a mask - another buffer in which the pixel colors became darker the closer they were to the camera. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This mask buffer was sampled several times, and the shader took samples and mixed them by blurring together. The result of this operation was mixed with the finished scene:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d9/f9b/891/5d9f9b891a670f005d77704953040215.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The progress of graphics cards over the past 12 years has been tremendous. </font><font style="vertical-align: inherit;">The most powerful GPUs at the time of the release of Crysis were the Nvidia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeForce 8800 Ultra</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The fastest modern GPU - the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeForce RTX 2080 Ti</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has more than 30 times more computing power, 14 times more memory and 6 times more bandwidth. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With all this computing power, modern games can provide much greater graphic accuracy and overall speed, despite the increased complexity of rendering.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d73/9bf/541/d739bf54169f0900929280cee0d4553b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúDivine Rays‚Äù in Ubisoft's The Division 2</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
But in fact, this effect demonstrates that despite the importance of correct lighting for the visual accuracy, the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">absence of</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> light </font><font style="vertical-align: inherit;">is actually even more important </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essence of the shadow</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start a new section of the article with the game </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shadow of the Tomb Raider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In the image below, all graphics options related to shadows are disabled; </font><font style="vertical-align: inherit;">on the right they are included. </font><font style="vertical-align: inherit;">The difference is huge, right?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/399/6db/855/3996db855ea5a727cc8b8c8e565227d8.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since shadows form naturally in the real world, games in which they are implemented incorrectly will never look right. </font><font style="vertical-align: inherit;">Our brains are used to using shadows as a visual support to create a feeling of relative depth, location and movement. </font><font style="vertical-align: inherit;">But doing it in a 3D game is surprisingly difficult, or at least difficult to do it right. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start with the duck. </font><font style="vertical-align: inherit;">Here she is moving around the field, and the rays of the sun reach her and are correctly blocked.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3f/2ad/1d8/f3f2ad1d84f865217d5e28cfaab98604.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the first ways to implement the shadow in the scene was to add a ‚Äúspot‚Äù of shadow under the model. This is completely unrealistic, because the shape of the shadow does not match the shape of the object casting the shadow; however, this approach is quick and easy to create. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first 3D games, for example, the first </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tomb Raider of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1996, used this method because the hardware of that time, for example, Sega Saturn and Sony PlayStation, could not provide anything better. This method painted a simple set of primitives just above the surface on which the model moves, and then shaded them; drawing at the bottom of a simple texture was also used.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ad/1b8/735/3ad1b8735674a430a18559fc87a28baa.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another of the first methods was </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projecting shadows</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In this case, the primitive emitting a shadow was projected onto a plane containing the floor. </font><font style="vertical-align: inherit;">Part of the necessary mathematical calculations for this was created by Jim Blinn in the late 80s. </font><font style="vertical-align: inherit;">By modern standards, this is a simple process, and it works best for simple static objects.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/130/ced/f47/130cedf47748e034cd6c87d98da9e487.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But thanks to optimization, shadow projection provided the creation of the first worthy examples of dynamic shadows, for example, in the 1999 game </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kingpin: Life of Crime</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> by Interplay. </font><font style="vertical-align: inherit;">As we see in the image below, only animated characters (even rats!) Have shadows, but this is better than simple spots.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ea/dc7/5a1/2eadc75a107ec0eec8a3c0bc37497b64.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The most serious problems with this approach are: (a) the perfect opacity of the shadow, and (b) the projection method emits the shadow on one flat surface (for example, on the ground). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These problems can be solved by applying a share of transparency when coloring the projected primitive and performing several projections for each character, but the PC hardware capabilities of the late 90s could not cope with the additional rendering.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modern technology for creating shadows</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A more accurate way to implement shadows was proposed much earlier, already in 1977. While working at the University of Austin (Texas), Franklin Crowe wrote a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">research article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in which he proposed several techniques using </font><font style="vertical-align: inherit;">shadow </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">volumes</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general terms, they can be described as follows: the process determines which primitives are directed towards the light source; their ribs are stretched to a plane. While this is very similar to projecting shadows, the important difference is that the created volume of shadows is then used to check whether the pixel is inside / outside the volume. Thanks to this information, shadows can be emitted on all surfaces, not just the ground. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This technique was improved in 1991 by Tim Heidmann, who worked on</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Silicon Graphics</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mark Kilgard</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was engaged in its further development in 1999 </font><font style="vertical-align: inherit;">, and the method that we will consider was created in 2000 by </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">John Carmack</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of id Software (although Carmack's method was independently opened two years earlier by Bilodo and Songa from Creative Labs; this led to that </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carmack was forced to change his code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to avoid legal problems). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This approach requires multiple frame rendering (called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">multipass</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rendering - a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">very</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> expensive process in the early 90s that is used everywhere today) and a concept called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stencil buffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unlike frame buffers and depths, it is not created by the 3D scene itself - this buffer is an array of values ‚Äã‚Äãequal in all dimensions (i.e. resolution in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) in the form of a raster. </font><font style="vertical-align: inherit;">The values ‚Äã‚Äãstored in it are used to tell the rendering engine what to do with each pixel in the frame buffer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The simplest example of using this buffer is to use as a mask:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b99/dfa/f1c/b99dfaf1c876fb4ed736c5947460efbd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The method with the volume of shadows is performed approximately like this:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We render the scene to the frame buffer, but use only the ambient lighting (we also include all the emission values ‚Äã‚Äãin it if the pixel contains a light source)</font></font></li>
<li>  ,    ,    (  <em>   (back-face culling)</em>).        (,  )         .   <em></em>   (..     ¬´¬ª)    -     .</li>
<li>  ,       (front-face culling)    -,     .</li>
<li>   ,        ,       -.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These stencil buffers and shadow volumes (commonly called stencil shadows) were used in the 2004 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> id Software game </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/015/720/5010157201afaff6066d609748a40eae.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notice that the surface the character is walking on is still visible through the shadow? This is the first advantage over shadow projection. In addition, this approach allows you to take into account the distance from the light source (as a result, weaker shadows are obtained) and cast shadows on any surface (including the character itself). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But this technique has serious drawbacks, the most noticeable of which is that the edges of the shadow are completely dependent on the number of primitives used to create the object casting the shadow. In addition, multipassing is associated with many read / write operations to local memory, which is why the use of stencil shadows is quite costly in terms of performance.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, there is a limit on the number of shadow volumes, which can be checked using the stencil buffer, because all graphic APIs allocate a fairly small number of bits on it (usually only 8). However, due to the computational cost of stencil shadows, this problem usually does not arise. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is another problem - the shadows themselves are far from realistic. Why? Because all light sources - lamps, open flames, lanterns and the Sun - are not single points in space, i.e. they emit light of some area. Even in the simplest case shown below, real shadows rarely have sharply defined edges.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/6b4/52b/b7c6b452bacb558d508a751c5bdebdb1.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The darkest region of shadows is called the full shadow (umbra); </font><font style="vertical-align: inherit;">penumbra is always a lighter shadow, and the border between the two is often blurred (because there are usually many light sources). </font><font style="vertical-align: inherit;">It is difficult to model this with stencil buffers and volumes, since the created shadows are stored in a wrong form so that they can be processed. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shadow mapping</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comes to the rescue </font><font style="vertical-align: inherit;">! </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The basic procedure</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was developed in 1978 by </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lance Williams</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It is pretty simple:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each light source, we render the scene from the point of view of this source, creating a special texture of the depths (that is, without color, lighting, texturing, etc.). </font><font style="vertical-align: inherit;">The resolution of this buffer does not have to be equal to the size of the finished frame, but the higher the better.</font></font></li>
<li>      ,        (  x,y  z) ,        .</li>
<li>          :   ,           .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviously, this is another multi-pass procedure, but the last step can be performed using pixel shaders so that the depth check and subsequent lighting calculations are combined in one pass. And since the whole process of creating shadows does not depend on the number of primitives used, it is much faster than using the stencil buffer and the volume of shadows. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unfortunately, the basic technique described above generates all kinds of visual artifacts (for example, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perspective aliasing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúshadow acne‚Äù</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ‚Äúpeter panning‚Äù), most of which are related to the resolution and bit size of the depth texture. All GPUs and graphics APIs have limitations similar to textures, so a whole set of additional techniques has been created to solve these problems.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the benefits of using textures for depth information is that GPUs can sample and filter them very quickly and in many different ways. In 2005, Nvidia demonstrated a texture sampling method that could solve some of the visual problems caused by standard shadowing. In addition, he provided a certain degree of smoothness of the edges of the shadows; this technique is called </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">percentage closer filtering</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c0/5bf/c31/4c05bfc31232887519a64eb7995e7d7d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Around the same time, Futuremark demonstrated the use of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cascaded shadow maps</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (CSM) in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3DMark06</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This is a technique in which for each light source several depth textures are created with different resolutions. High-resolution textures are used near the source, and lower - at a distance from the source. The result is smoother shadow transitions in the scene without distortion. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This technique was improved by Donnelly and Loritzen in 2006 in their </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variance shadow mapping</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (VSM) </font><font style="vertical-align: inherit;">procedure </font><font style="vertical-align: inherit;">, as well as Intel in 2010 in its </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sample distribution algorithm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (SDSM).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2f/91a/0d8/a2f91a0d8f6c22ba64ab03aeccf50b00.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using SDSM in Shadow of the Tomb Raider</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
To improve the picture, game developers often use a whole arsenal of shading techniques, but the main one remains shadow mapping. However, it can be applied only to a small number of active light sources, because if you try to model it for each surface reflecting or emitting light, the frame rate will catastrophically drop. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortunately, there is a convenient technique that works with any object. It gives the impression of a decrease in the brightness of the illumination reaching the object (due to the fact that he or other objects block the light a little). This feature is called </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ambient occlusion.</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and she has many versions. Some of them are specially designed by hardware manufacturers, for example, AMD created HDAO ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">high definition ambient occlusion</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), and Nvidia has </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HBAO +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horizon based ambient occlusion</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Whatever version is used, it is applied after the scene is fully rendered, therefore it is classified as a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">post-processing</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> effect </font><font style="vertical-align: inherit;">. In fact, for each pixel it is calculated how much we see it in the scene (more about this </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) by comparing the value of the pixel depth with the pixels surrounding it at the corresponding point in the depth buffer (which, again, is stored as a texture).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sampling the depth buffer and then calculating the final pixel color plays an important role in ensuring the quality of ambient occlusion; </font><font style="vertical-align: inherit;">as in the case of shadowing, all versions of ambient occlusion for their proper operation require the programmer to carefully configure and adjust the code depending on the situation.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4e/865/e15/f4e865e159dfa5e83286e1245a5b46f9.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shadow of the Tomb Raider without AO (left) and with HBAO + (right)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
However, when properly implemented, this visual effect leaves a deep impression. </font><font style="vertical-align: inherit;">In the image above, pay attention to the person‚Äôs hands, pineapples and bananas, as well as the surrounding grass and vegetation. </font><font style="vertical-align: inherit;">The HBAO + pixel color changes are pretty minor, but all objects now look better built into the environment (on the left it seems that a person is hanging above the ground).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you select any of the last games discussed in this article, then the list of rendering techniques used in them when processing lighting and shadows will be the length of the article itself. And although not every new 3D game boasts all of these technologies, universal game engines like Unreal allow you to optionally enable them, and toolkits (for example, Nvidia companies) provide a code ready to be inserted into the game. This proves that they are not highly specialized ultramodern methods - which were once the property of the best programmers, now they are available to anyone. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We cannot complete this article on lighting and shadows without mentioning ray tracing. We </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">have already talked</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about this process </font><font style="vertical-align: inherit;">in this series of articles, but the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">current level of technology development</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requires putting up with a low frame rate and serious cash outlay. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, the technology is supported by next-generation consoles Microsoft and Sony, which means that over the next few years, its use will become another standard tool for developers around the world seeking to improve the visual quality of games. </font><font style="vertical-align: inherit;">Just take a look at what Remedy managed to achieve in her latest </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> game </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/gJ7gdBGXODI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have come a long way from fake shadows in textures and simple ambient lighting!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's not all</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the article, we tried to talk about the fundamental mathematical calculations and techniques used in 3D games, which make them as realistic as possible. </font><font style="vertical-align: inherit;">We also examined the technologies underlying the modeling of the interaction of light with objects and materials. </font><font style="vertical-align: inherit;">But all this was just the tip of the iceberg. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, we skipped topics such as energy-saving lighting, lens flare, bloom, highly dynamic rendering, radiance transfer, tone correction, fog, chromatic aberration, photon mapping, caustics, radiosity - this list goes on. </font><font style="vertical-align: inherit;">A brief study would require 3-4 more articles.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en501426/index.html">Unison: setting up and automating two-way synchronization of directories on two servers</a></li>
<li><a href="../en501430/index.html">Great Guide to Website Content Design and Planning</a></li>
<li><a href="../en501432/index.html">Two alternatives to JDBC</a></li>
<li><a href="../en501434/index.html">Security Week 20: hacking a computer through Thunderbolt</a></li>
<li><a href="../en501436/index.html">Number recognition algorithm on the image with a low probability of the second kind of error</a></li>
<li><a href="../en501440/index.html">Zabbix 5.0 released</a></li>
<li><a href="../en501448/index.html">How we profiled a unique Agile course</a></li>
<li><a href="../en501450/index.html">14 things an iOS developer must know</a></li>
<li><a href="../en501454/index.html">Six Tips for Using PostgreSQL in Functional Tests</a></li>
<li><a href="../en501456/index.html">Qt on Android: how we gave a second life to an author meditation application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>