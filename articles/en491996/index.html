<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë®‚Äçüë¶ üëéüèæ ‚ù§Ô∏è More about Coroutines in C ++ üî≥ üñïüèΩ üë©‚Äçüë©‚Äçüë¶‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello colleagues. 
 
 As part of the development of the C ++ 20 theme, we at one time came across a rather old (September 2018) article from the Yande...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>More about Coroutines in C ++</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/491996/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello colleagues. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As part of the development of the C ++ 20 theme, we at one time came across a rather old (September 2018) article from the Yandex‚Äôs hublog, which is called ‚Äú </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getting Ready for C ++ 20. Coroutines TS with a Real Example</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù. It ends with the following very expressive vote: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/a-/m4/xn/a-m4xn5j3yjfy-yl2et7aeek7sc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚ÄúWhy not,‚Äù we decided and translated an article by David Pilarski under the title ‚ÄúCoroutines introduction‚Äù. The article was published a little over a year ago, but hopefully you will find it very interesting anyway.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So it happened. After much doubt, controversy, and preparation of this feature, WG21 came to a common opinion about what coroutines should look like in C ++ - and it is very likely that they will be included in C ++ 20. Since this is a major feature, I think it's time to prepare and study it already now (as you remember, there are still more modules, concepts, ranges to learn ...) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Many still oppose coroutine. Often they complain about the complexity of their development, a lot of points of customization and, possibly, suboptimal performance due to, possibly, under-optimized allocation of dynamic memory (maybe;)).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In parallel with the development of approved (officially published) technical specifications (TS), even attempts have been made to parallel development of another mechanism of corutin. </font><font style="vertical-align: inherit;">Here we will talk about those coroutines that are described in TS ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">technical specification</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">An alternative approach, in turn, belongs to Google. </font><font style="vertical-align: inherit;">As a result, it turned out that the Google approach suffers from numerous problems, the solution of which often requires strange additional features of C ++. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the end, it was decided to adopt a version of Corutin developed by Microsoft (sponsored by TS). </font><font style="vertical-align: inherit;">It is about such coroutines that will be discussed in this article. </font><font style="vertical-align: inherit;">So, let's start with the question of ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What are coroutines?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Coroutines already exist in many programming languages, for example, in Python or C #. </font><font style="vertical-align: inherit;">Coroutines are another way to create asynchronous code. </font><font style="vertical-align: inherit;">How they differ from flows, why coroutines should be implemented as a dedicated language feature and, finally, what is their use will be explained in this section. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is a serious misunderstanding regarding what coroutines are. </font><font style="vertical-align: inherit;">Depending on the environment in which they are used, they may be called:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stackless Coroutines</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stack coroutines</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Green streams</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fibers</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gorutins</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The good news: stack corutins, green streams, fibers and gorutins are one and the same thing (but they are sometimes used in different ways). We will talk about them later in this article and we will call them fibers or stack coroutines. But the stackless coroutine has some features that need to be discussed separately. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To understand coroutines, including on an intuitive level, let's briefly get to know the functions and (let us put it this way) ‚Äútheir API‚Äù. The standard way to work with them is to call and wait until it finishes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>{
     <span class="hljs-keyword">return</span>; <span class="hljs-comment">//     </span><font></font>
}	<font></font>
foo(); <span class="hljs-comment">//   / </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After calling the function, it is already impossible to pause, or resume its work. You can perform only two operations on functions: </font></font><code>start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. When the function is launched, you must wait until it is completed. If the function is called again, its execution will go from the very beginning. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With coroutines, the situation is different. You can not only start and stop them, but also pause and resume them. They are still different from core flows, because the coroutines themselves are not crowding out (on the other hand, coroutines are usually flowing, and the flow is crowding out). To understand this, consider a generator defined in Python. Let such a thing be called a generator in Python, in C ++ it would be called coroutine. An example is taken from this </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_nums</span>():</span>
     num = <span class="hljs-number">0</span>
     <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
          <span class="hljs-keyword">yield</span> num<font></font>
          num = num + <span class="hljs-number">1</span>	<font></font>
<font></font>
nums = generate_nums()<font></font>
	<font></font>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<font></font>
     print(x)<font></font>
	<font></font>
     <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">9</span>:
          <span class="hljs-keyword">break</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here's how this code works: a function call </font></font><code>generate_nums</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leads to the creation of a coroutine object. </font><font style="vertical-align: inherit;">At each step of enumerating a coroutine object, coroutine itself resumes work and pauses it only after a keyword </font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the code; </font><font style="vertical-align: inherit;">then the next integer from the sequence is returned (the for loop is syntactic sugar for calling a function </font></font><code>next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that resumes coroutine). </font><font style="vertical-align: inherit;">The code ends the loop by encountering a break statement. </font><font style="vertical-align: inherit;">In this case, corutin never ends, but it is easy to imagine a situation in which corutin reaches the end and ends. </font><font style="vertical-align: inherit;">As we can see, to a korutine applicable operations </font></font><code>start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>suspend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>resume</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and finally,</font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">[Note: C ++ also provides creation and destruction operations, but they are not important in the context of an intuitive understanding of coroutine].</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutines as a library</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, now it‚Äôs approximately clear what coroutines are. </font><font style="vertical-align: inherit;">You may know that there are libraries for creating fiber objects. </font><font style="vertical-align: inherit;">The question is, why do we need coroutines in the form of a dedicated language feature, and not just a library that would work with coroutines. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we are trying to answer this question and demonstrate the difference between stacked and stackless coroutines. </font><font style="vertical-align: inherit;">This difference is key to understanding corutin as part of the language.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stack coroutines</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, let's first discuss what stack coroutines are, how they work, and why they can be implemented as a library. </font><font style="vertical-align: inherit;">Explaining them is relatively simple, because they resemble streams in terms of design. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fiber or stack corutin has a separate stack that can be used to handle function calls. </font><font style="vertical-align: inherit;">To understand exactly how coroutines of this kind work, we briefly look at function frames and function calls from a low-level point of view. </font><font style="vertical-align: inherit;">But first, let's talk about the properties of fibers.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">They have their own stack,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The lifetime of the fibers does not depend on the code that calls them (usually they have a user-defined scheduler),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fibers can be detached from one thread and attached to another,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cooperative planning (the fiber must decide to switch to another fiber / scheduler),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cannot work simultaneously in the same thread.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following effects result from the above properties:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">switching the context of the fibers should be carried out by the user of the fibers, and not the OS (in addition, the OS can release the fiber, releasing the thread in which it works),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no real data race between the two fibers, since at any given time only one of them can be active,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fiber designer must be able to choose the right place and time, where and when it is appropriate to return computing power to a possible scheduler or caller.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The input / output operations in the fiber must be asynchronous, so that other fibers can perform their tasks without blocking each other.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's take a closer look at the operation of the fibers and first explain how the stack participates in function calls. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, the stack is a continuous block of memory needed to store local variables and function arguments. But, more importantly, after each function call (with a few exceptions), additional information is pushed onto the stack that tells the called function how to return to the caller and restore processor registers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Some of these registers have special assignments, and when calling functions, they are stored on the stack. These are the registers (in the case of the ARM architecture): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SP - stack pointer </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LR - communication register </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PC - program counter </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stack pointer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(SP) is a register that contains the address of the beginning of the stack related to the current function call. Thanks to the existing value, you can easily refer to arguments and local variables stored on the stack. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The communication register</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (LR) is very important when calling functions. It stores the return address (the address of the calling party), where the code will be executed after the execution of the current function is completed. When the function is called, the PC is saved in LR. When the function returns, the PC is restored using LR. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Program Counter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (PC) is the address of the currently executing instruction. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Whenever a function is called, the list of links is saved, so that the function knows where the program should return after it finishes.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/r2/yk/njr2ykw0o6hrsww5-uq3ybjjddg.png"><br>
 <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The behavior of the PC and LR registers when calling and returning a function</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
When executing a stack coroutine, the called functions use the previously allocated stack to store its arguments and local variables. </font><font style="vertical-align: inherit;">Since all information on each function called on the stack corutin is stored on the stack, the fiber can suspend any function within that corutin. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/r2/yk/njr2ykw0o6hrsww5-uq3ybjjddg.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's see what happens in this picture. </font><font style="vertical-align: inherit;">Firstly, each fiber and thread has its own separate stack. </font><font style="vertical-align: inherit;">Green color indicates serial numbers indicating the sequence of actions.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A regular function call inside a thread. </font><font style="vertical-align: inherit;">Memory is allocated on the stack.</font></font></li>
<li><b>   </b>.      .     ,      .    .       ,              . </li>
<li>  .</li>
<li><b> </b>.       .</li>
<li>    .</li>
<li>    .</li>
<li><b> </b>.    ,    , ,      .</li>
<li>    .</li>
<li>    .</li>
<li><b> </b> ‚Äì     ,     . </li>
<li>        ,      .</li>
<li>    .      . </li>
<li>       .    :   ,    . ,          (  ) .</li>
<li>  ,   .</li>
<li>  .</li>
<li><b> </b>.   .     .    ,      .</li>
<li>     .</li>
<li>      , ,     .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When working with stack coroutines, there is no need for a dedicated language feature that would ensure their use. </font><font style="vertical-align: inherit;">Entire stack korutiny well be implemented using libraries, and libraries already exist that are designed specifically for this purpose: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swtch.com/libtask </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code.google.com/archive/p/libconcurrency </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.boost.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boost.Fiber </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.boost.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the Boost .Coroutine </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of all these libraries, only Boost is C ++, and all the rest are C. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a detailed description of how these libraries work, </font><font style="vertical-align: inherit;">see the </font><font style="vertical-align: inherit;">documentation. </font><font style="vertical-align: inherit;">But, in general, all these libraries allow you to create a separate stack for fiber and provide the opportunity to resume coroutine (at the initiative of the caller) and pause it (from the inside).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider an example </font></font><code>Boost.Fiber</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><font></font>
	<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/intrusive_ptr.hpp&gt;</span></span><font></font>
	<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/fiber/all.hpp&gt;</span></span><font></font>
	<font></font>
<span class="hljs-function"><span class="hljs-keyword">inline</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">fn</span><span class="hljs-params">( <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-keyword">const</span>&amp; str, <span class="hljs-keyword">int</span> n)</span> </span>{
     <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; str &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
               boost::this_fiber::yield();<font></font>
     }<font></font>
}<font></font>
	<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
     <span class="hljs-keyword">try</span> {<font></font>
          boost::<span class="hljs-function">fibers::fiber <span class="hljs-title">f1</span><span class="hljs-params">( fn, <span class="hljs-string">"abc"</span>, <span class="hljs-number">5</span>)</span></span>;
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"f1 : "</span> &lt;&lt; f1.get_id() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
          f1.join();<font></font>
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"done."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
	<font></font>
          <span class="hljs-keyword">return</span> EXIT_SUCCESS;<font></font>
     } <span class="hljs-keyword">catch</span> ( <span class="hljs-built_in">std</span>::exception <span class="hljs-keyword">const</span>&amp; e) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"exception: "</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
     } <span class="hljs-keyword">catch</span> (...) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"unhandled exception"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
     }<font></font>
     <span class="hljs-keyword">return</span> EXIT_FAILURE;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the case of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boost.Fiber</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the library has a built-in scheduler for coroutine. </font><font style="vertical-align: inherit;">All fibers run in the same thread. </font><font style="vertical-align: inherit;">Since corutin planning is cooperative, the fiber must first decide when to return control to the scheduler. </font><font style="vertical-align: inherit;">In this example, this happens when the yield function is called, which pauses the coroutine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since there is no other fiber, the fiber planner always decides to resume coroutine.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stackless Coroutines</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stackless coroutines differ slightly in properties from stack ones. </font><font style="vertical-align: inherit;">However, they have the same basic characteristics, since the non-stacked coroutines can also be started, and after their suspension can be resumed. </font><font style="vertical-align: inherit;">Coroutines of this type we are likely to find in C ++ 20. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we talk about the similar properties of corutin - coroutines can:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corutin is closely connected with her caller: when a coroutine is called, execution is transferred to her, and the result of the coroutine is transferred back to the caller.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The life span of a stack corutin is equal to the life of its stack. </font><font style="vertical-align: inherit;">The lifespan of a stackless coroutine is equal to the life of its object.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, in the case of stackless coroutines, there is no need to allocate a whole stack. They consume much less memory than stack ones, but this is precisely due to some of their limitations. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To begin with, if they do not allocate memory for the stack, then how do they work? Where in their case all the data goes that should be stored on the stack when working with stack coroutines. Answer: on the stack of the caller.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The secret to stackless coroutines is that they can only suspend themselves from the topmost function. For all other functions, their data is located on the stack of the called side, so all functions called from corutin must be completed before the corutin's work is suspended. All data needed by coroutine to maintain its state is dynamically allocated on the heap. This usually requires a couple of local variables and arguments, which are much more compact than a whole stack that would have to be allocated in advance. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Take a look at how stackless corutins work: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ow/vc/nw/owvcnwldgczpxdmjorsjlrh3yvm.png"><br>
 <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Challenging a stackless corutin</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, now there is only one stack - this is the main stack of the thread. </font><font style="vertical-align: inherit;">Let's take a step-by-step look at what is shown in this picture (the coroutine activation frame here is two-color - black shows what is stored on the stack, and blue - what is stored on the heap).</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A regular function call whose frame is stored on the stack</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function creates a coroutine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">That is, it allocates an activation frame for it somewhere on the heap.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal function call.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Call Corutin</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Corutin's body stands out in a regular stack. </font><font style="vertical-align: inherit;">The program is executed in the same way as in the case of a regular function.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A regular function call from coroutine. </font><font style="vertical-align: inherit;">Again, everything still happens on the stack [Note: you cannot pause the coroutine from this point, since this is not the topmost function in the coroutine]</font></font></li>
<li>       [:     .]</li>
<li>  ‚Äì  ,        ,     .</li>
<li>  </li>
<li><b>  </b> ‚Äì      ,        +     .</li>
<li>     5.</li>
<li>     6.</li>
<li><b> </b>.        .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, it is obvious that in the second case it is necessary to remember much less data for all operations of suspending and resuming the work of coroutine, however, coroutine can resume and suspend only itself, and only from the topmost function. All function calls and coroutine occur the same way, however, between calls it is required to save some additional data, and the function must be able to jump to the suspension point and restore the state of local variables. There are no other differences between the coroutine frame and the function frame.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Corutin can also cause other coroutines (not shown in this example). </font><font style="vertical-align: inherit;">In the case of stackless coroutines, each call results in the allocation of a new space for new coroutine data (with a repeated call of coroutine, dynamic memory can also be allocated several times). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The reason why coroutines need to provide a dedicated language feature is because the compiler needs to decide which variables describe the state of coroutine and create stereotyped code to jump to the suspension points.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Practical use of corutin</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Coroutines in C ++ can be used in the same ways as in other languages. </font><font style="vertical-align: inherit;">Coroutines will simplify the spelling:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generators</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asynchronous input / output code </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lazy computing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">event driven applications</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summary</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I hope that by reading this article you will find out:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">why in C ++ you need to implement coroutines as a dedicated language feature</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is the difference between stacked and stackless coroutines?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">why coroutines are needed</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en491986/index.html">RemoteLoRa - More Than ON / OFF</a></li>
<li><a href="../en491988/index.html">What's New in Red Hat OpenShift 4.2 and 4.3?</a></li>
<li><a href="../en491990/index.html">Work with the Chinese chip ADC Hx711 (conclusion)</a></li>
<li><a href="../en491992/index.html">Analyst Development</a></li>
<li><a href="../en491994/index.html">Migrating from Cocoapods to Swift Package Manager</a></li>
<li><a href="../en492000/index.html">Product very first. Burnout</a></li>
<li><a href="../en492002/index.html">Light-Absorbing Wings: The Secret to Super Black Butterflies</a></li>
<li><a href="../en492004/index.html">How to grow from a programmer to a manager (‚ÄúI want to be the mistress of the sea‚Äù)</a></li>
<li><a href="../en492006/index.html">The power of PWA: A video surveillance system with a 300-line neural network JS code</a></li>
<li><a href="../en492008/index.html">Results of IT motivation research: are developers happy with their work?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>