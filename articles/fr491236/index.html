<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚋 🦁 😫 Programmation asynchrone dans .NET: meilleures pratiques 🤟🏽 ⛹🏼 🅰️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'avènement de async / wait en C # a conduit à une redéfinition de la façon d'écrire du code parallèle simple et correct. Souvent, en utilisant la pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programmation asynchrone dans .NET: meilleures pratiques</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/491236/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'avènement de async / wait en C # a conduit à une redéfinition de la façon d'écrire du code parallèle simple et correct. Souvent, en utilisant la programmation asynchrone, les programmeurs non seulement ne résolvent pas les problèmes liés aux threads, mais en introduisent également de nouveaux. Les impasses et les vols ne vont nulle part - ils deviennent simplement plus difficiles à diagnostiquer. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/uz/8g/buuz8gok2hqubwnj1773hwimncq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dmitry Ivanov - Software Analysis TeamLead chez Huawei, un ancien développeur technologique JetBrains Rider et développeur du noyau ReSharper: structures de données, caches, multithreading, et un conférencier régulier à la conférence </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sous la cinématique - enregistrement vidéo et transcription textuelle du rapport de Dmitry de la conférence DotNext 2019 Piter.</font></font><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/wM-h6P1BJRk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nouvelle narration au nom de l'orateur.</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dans le code multithread ou asynchrone, quelque chose se casse souvent. La raison pourrait être à la fois une impasse et une race. En règle générale, une course se bloque une fois sur mille, souvent pas localement, mais uniquement sur un serveur de build, et il faut plusieurs jours pour l'attraper. Je suis sûr que pour beaucoup, c'est une situation familière. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, en regardant du code asynchrone même par des développeurs expérimentés, je me surprends à penser que certaines choses peuvent être écrites trois fois plus rapidement et plus correctement.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela suggère que le problème ne vient pas des personnes, mais de l'instrument. </font><font style="vertical-align: inherit;">Les gens utilisent simplement l'outil et veulent qu'il résout leur problème. </font><font style="vertical-align: inherit;">L'outil lui-même dispose d'un très grand nombre de capacités (parfois même superflues), de paramètres, d'un contexte implicite, ce qui conduit au fait qu'il est très facile à utiliser incorrectement. </font><font style="vertical-align: inherit;">Essayons de comprendre comment utiliser async / wait et travailler avec une classe </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans .NET.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plan</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problèmes avec les approches résolues avec async / wait.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemples de conception controversée.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une tâche de la vie réelle que nous allons résoudre de manière asynchrone.</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async / attente et problèmes à résoudre</font></font></h2><br>
<img src="https://habrastorage.org/webt/v1/ym/30/v1ym304jgxmwh_4kymlyqr4wddi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi avons-nous besoin d'async / wait? Disons que nous avons du code qui fonctionne avec la mémoire partagée partagée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au début du travail, nous lisons la demande, dans ce cas, le fichier de la file d'attente de blocage (par exemple, d'Internet ou du disque), en utilisant la demande de blocage </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dequeue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (les demandes de blocage seront marquées en rouge dans les images avec des exemples). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette approche nécessite beaucoup de threads, et chaque thread nécessite des ressources, crée une charge sur le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planificateur</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mais ce n'est pas le problème principal. Supposons que les utilisateurs puissent réécrire les systèmes d'exploitation afin que ces systèmes prennent en charge à la fois cent mille et un million de threads. Mais le principal problème est que certains threads ne peuvent tout simplement pas être pris. Par exemple, vous disposez d'un thread d'interface utilisateur. Il n'y a pas de cadres d'interface utilisateur adéquats normaux où l'accès aux données ne serait pas seulement à partir d'un seul thread, pour l'instant. Le thread d'interface utilisateur ne peut pas être bloqué. Et pour ne pas le bloquer, nous avons besoin d'un code asynchrone. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parlons maintenant de la deuxième tâche. Après avoir lu le fichier, il doit être traité d'une manière ou d'une autre. Nous le ferons en parallèle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beaucoup d'entre vous ont entendu dire que le parallélisme n'est pas la même chose que l'asynchronie. Dans ce cas, la question se pose: l'asynchronie peut-elle aider à écrire du code parallèle plus compact, beau et plus rapide?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La dernière tâche consiste à travailler avec la mémoire partagée. </font><font style="vertical-align: inherit;">Avons-nous besoin de faire glisser ce mécanisme avec des verrous, la synchronisation vers du code asynchrone, ou cela peut-il être évité d'une manière ou d'une autre? </font><font style="vertical-align: inherit;">Peut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asynchroniser / attendre de l'</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aide à ce sujet?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chemin vers async / attente</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons l'évolution de la programmation asynchrone en général dans le monde et en .NET.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rappeler</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Void <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {…}<font></font>
 <font></font>
<font></font>
<span class="hljs-function">Void <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    …<span class="hljs-comment">//synchronous code</span><font></font>
 <font></font>
    Foo(<span class="hljs-keyword">params</span>,() =&gt;{<font></font>
       …<span class="hljs-comment">//asynchronous code;continuation</span><font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La programmation asynchrone a commencé par des rappels. </font><font style="vertical-align: inherit;">Autrement dit, vous devez d'abord appeler une partie du code de manière synchrone et la seconde partie - de manière asynchrone. </font><font style="vertical-align: inherit;">Par exemple, vous lisez un fichier et lorsque les données sont prêtes, elles vous seront livrées d'une manière ou d'une autre. </font><font style="vertical-align: inherit;">Cette partie asynchrone est passée en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rappel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus de rappels</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {...} 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">Action callback</span>)</span> {...}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Baz</span>(<span class="hljs-params">Action callback</span>)</span> {...}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
    <font></font>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; { <font></font>
      ... <span class="hljs-comment">//continuation 1 </span><font></font>
      Bar(() =&gt; {<font></font>
        <span class="hljs-comment">//continuation 2</span><font></font>
        Baz(() =&gt; {<font></font>
          <span class="hljs-comment">//continuation 3</span><font></font>
        }); <font></font>
      });<font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, à partir d'un rappel, vous pouvez enregistrer un autre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rappel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , à partir duquel vous pouvez enregistrer un troisième rappel, et à la fin, tout se transforme en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enfer de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rappel </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/vq/8g/bfvq8gknishmtrdwaiixz6mzuvs.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rappel: exceptions</font></font></h3><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action onSuccess, Action onFailure</span>)</span> {...}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code </span>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; {<font></font>
      ... <span class="hljs-comment">//asynchronous code on success </span><font></font>
    },<font></font>
    () =&gt; {<font></font>
        ... <span class="hljs-comment">//asynchronous code on failure</span><font></font>
    }); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment travailler avec des exceptions? Par exemple, ReSharper, lorsqu'il répond séparément aux exceptions et à une bonne exécution, ne présente pas les plus beaux morceaux de code - il existe des rappels distincts pour une situation exceptionnelle et pour une continuation réussie. Le résultat est un tel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enfer de rappel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais pas linéaire, mais semblable à un arbre, ce qui peut être complètement déroutant. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/hs/y3/lghsy31j9pke1do-8rpmcyuovfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans .NET, la première approche de rappel est appelée le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modèle de programmation asynchrone</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (APM). La méthode sera appelée </font></font><code>AsyncCallback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui est essentiellement la même que </font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais l'approche a certaines caractéristiques. Tout d'abord, les méthodes doivent commencer par le mot «Begin» (la lecture d'un fichier est BeginRead), qui en renvoie </font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lui-même</font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Il s'agit d'un gestionnaire qui sait que l'opération est terminée et qui dispose d'un mécanisme </font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Vous </font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pouvez attendre, en attendant que l'opération se termine de manière asynchrone. D'un autre côté, vous pouvez appeler </font></font><code>EndOperation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, c'est-à-dire créer </font></font><code>EndRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et bloquer de manière synchrone (ce qui est très similaire à une propriété </font></font><code>Task.Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette approche pose un certain nombre de problèmes. Premièrement, cela ne nous protège pas de l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enfer des rappels</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Deuxièmement, on ne sait pas trop quoi faire des exceptions. Troisièmement, il n'est pas clair sur quel thread ce rappel sera appelé - nous n'avons aucun contrôle sur l'appel. Quatrièmement, la question se pose, comment combiner des morceaux de code avec des rappels? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mr/5z/xr/mr5zxr01ztmadod_fuetd3loqew.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxième modèle est appelé </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modèle asynchrone basé sur les événements</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il s'agit d'une approche de rappel réactif. L'idée de la méthode est que nous passons à la méthode </font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un objet qui a l'événement Completed et </font><font style="vertical-align: inherit;">que nous nous </font><font style="vertical-align: inherit;">abonnions à cet événement. Comme vous l'avez remarqué, les </font></font><code>BeginOperationName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modifications sont apportées à </font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Une confusion peut se produire lorsque vous entrez dans la classe Socket, où deux modèles sont mélangés: </font></font><code>ConnectAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>BeginConnect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez noter que vous devez appeler pour annuler </font></font><code>OperationNameAsyncCancel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Comme dans .NET, cela ne se trouve nulle part ailleurs, généralement tout le monde envoie des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellationToken s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ainsi, si vous rencontrez accidentellement une méthode dans la bibliothèque qui se termine par </font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous devez comprendre qu'elle ne retourne pas nécessairement </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais peut renvoyer une construction similaire. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/w4/4u/6sw44uh3ljw5kwdkowtxylfz5xc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérez un modèle connu sous Java comme</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Futures</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en JavaScript, en tant que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">promesses</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et en .NET, en tant que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modèles asynchrones de tâches</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en d'autres termes, «tâches». Cette méthode suppose que vous disposez d'un objet de calcul et que vous pouvez voir l'état de cet objet (en cours d'exécution ou terminé). Dans .NET, il existe une soi-disant </font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">séparation pratique de deux états: le début de la tâche et l'achèvement de la tâche. Une erreur courante se produit lorsqu'une méthode est appelée sur une tâche </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui renvoie une continuation non réussie, mais </font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Faulted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ainsi, le résultat du clic sur «Annuler» dans l'application d'interface utilisateur devrait différer du retour d'exceptions (exécutions). Dans .NET, une distinction a été faite: si l'exécution est votre erreur que vous souhaitez sécuriser, alors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annuler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- opération forcée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans .NET, un concept a également été introduit </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- c'est une sorte d'abstraction au-dessus des threads qui indique où exécuter la tâche. Dans ce cas, le support d'annulation a été conçu au niveau de la conception. Presque toutes les opérations de la bibliothèque en .NET </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peuvent être passées. Cela ne fonctionne pas pour toutes les langues: par exemple, dans Kotlin, vous pouvez annuler la tâche, mais pas dans .NET. La solution peut être la répartition des responsabilités entre ceux qui annulent la tâche et la tâche elle-même. Lorsque vous recevez une tâche, vous ne pouvez pas l'annuler autrement qu'explicitement - vous devez la transmettre </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un objet spécial </font></font><code>TaskCompletionSoure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous permet d'adapter facilement les anciennes API associées au </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modèle asynchrone basé</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur les </font><i><font style="vertical-align: inherit;">événements</font></i><font style="vertical-align: inherit;"> ou au </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modèle de programmation asynchrone</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il y a un document que vous devez lire si vous programmez des tâches. </font><font style="vertical-align: inherit;">Il décrit tous les accords concernant les tasas. </font><font style="vertical-align: inherit;">Par exemple, toute méthode renvoyant la tâche doit la retourner dans un état en cours d'exécution, ce qui signifie qu'elle ne peut pas l'être </font></font><code>Created</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, alors que toutes ces opérations doivent se terminer </font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combiner les suites</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Task <span class="hljs-title">ourMethod</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">return</span> Task.RunSynchronously(() =&gt;{<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Foo(); <span class="hljs-comment">//continuation 1</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Bar(); <span class="hljs-comment">//continuation 2</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Baz(); <span class="hljs-comment">//continuation 3</span><font></font>
  })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quant à la combinaison, compte tenu de l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enfer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> du </font><i><font style="vertical-align: inherit;">rappel</font></i><font style="vertical-align: inherit;"> , elle peut apparaître sous une forme plus linéaire, malgré la présence de morceaux de code répétitif avec des changements minimes. </font><font style="vertical-align: inherit;">Il semble que le code s'améliore de cette façon, mais il y a aussi des pièges ici.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Démarrer et continuer les tâches</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
  TaskCreationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)<font></font>
Task.ContinueWith(Action&lt;Task&gt;, <font></font>
  TaskContinuationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons à trois paramètres lors du lancement de la tâche standard: les premiers sont les options de démarrage de la tâche, le second est </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">celui sur lequel la tâche est lancée, et le troisième - </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/w_/a4/fw/w_a4fwuiwflisfw-ifxqwtgnpxu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TaskScheduler indique où commence la tâche et est un objet que vous pouvez remplacer indépendamment. Par exemple, vous pouvez remplacer une méthode </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si vous le faites </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la méthode </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend un thread </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et y envoie votre tâche. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous reprenez </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le thread principal, il place tout dans une file d'attente et les tâches sont exécutées séquentiellement sur le thread principal. Cependant, le problème est que dans .NET, vous pouvez exécuter une tâche sans passer </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La question se pose: comment alors .NET calcule-t-il la tâche qui lui a été transmise? Quand la tâche commence à l' </font></font><code>StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">intérieur</font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exposé dans celui </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que nous lui avons donné. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette conception semble plutôt controversée en raison du contexte implicite. Il y avait des cas où il </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contenait du code asynchrone qui héritait quelque part très profondément </font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et se chevauchait avec un autre ordonnanceur, ce qui entraînait des blocages. Dans ce cas, vous pouvez utiliser l'option </font></font><code>TaskCreationOption.HideScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il s'agit d'une sonnette d'alarme qui indique que nous avons une option qui remplace le </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paramètre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout est pareil avec les suites. La question se pose: d'où vient-elle </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour les suites? Tout d'abord, il est pris dans la méthode dans laquelle vous avez commencé </font></font><code>Continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il est également </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extrait de ThreadStatic. Il est important que pour </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / wait, les</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> suites fonctionnent très différemment.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bt/-f/ne/bt-fnekfbdnfmn4n-u3zrvp7bdc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous passons aux paramètres </font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>TaskContinuationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Leur principal problème est qu'il y en a beaucoup. Certains de ces paramètres s'annulent, certains s'excluent mutuellement. Tous ces paramètres peuvent être utilisés dans toutes les combinaisons possibles, il est donc difficile de garder à l'esprit tout ce qui peut arriver avec le désir. Certaines de ces options fonctionnent de manière totalement incompréhensible. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/us/wh/aguswhpfaos0qjqvfopo_rr8aeo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, les paramètres </font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">représentent deux options d'application possibles, mais le fait que la poursuite soit lancée de manière synchrone ou asynchrone dépend de tant de choses que vous ignorez. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jm/-c/zv/jm-czv9x4lhhmibfgxqxwjcvxqe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre exemple: nous avons lancé la tâche, lancé la continuation et donné simultanément deux paramètres</font></font><code>TaskContinuations.ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, après quoi ils ont commencé la suite de manière asynchrone. </font><font style="vertical-align: inherit;">Sera-t-il exécuté dans la même pile où la tâche précédente se termine, ou sera-t-il transféré </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Dans ce cas, il y aura une troisième option: cela dépend.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/j6/8z/vvj68zu1keb_n50viyk4iqbydae.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCompletionSource</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérez </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lorsque vous créez une tâche, vous définissez son résultat </font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour adapter les modèles asynchrones précédents au monde de la tâche. Vous </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pouvez demander </font></font><code>tcs.Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et cette tâche entrera dans un état </font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque vous appelez </font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cependant, si vous exécutez cela sur le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pool de threads</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vous obtiendrez un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blocage</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La question est, pourquoi si nous n’écrivions rien, même de manière synchrone? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v5/g1/2b/v5g12bn0tycbshdrascqvi-hkug.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous créons </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, commençons une nouvelle tâche et nous avons un deuxième thread qui démarre quelque chose dans cette tâche. Il va plus loin et tombe dans l'attente pour une centaine de millisecondes. Ensuite, notre fil principal - vert - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attend</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et c'est tout. Il libère la pile, la pile se bloque, attendant d'être appelée dans une suite sur</font></font><code>task.Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsqu'il est </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exposé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le fil bleu, nous arrivons à </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis le plus intéressant. </font><font style="vertical-align: inherit;">Sur la base de considérations internes à .NET, il </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pense que la poursuite de cela </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut être effectuée de manière synchrone, c'est-à-dire directement sur la même pile, puis cela </font></font><code>task.Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est effectué de manière synchrone sur la même pile. </font><font style="vertical-align: inherit;">C'est très étrange, malgré le fait que nous n'avons même écrit nulle part </font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">C'est probablement le problème avec le mélange de code synchrone et asynchrone. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uv/7z/go/uv7zgosoif24okbeyq7fffwdz8o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre problème avec cela </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est que lorsque nous appelons </font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sous le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verrou</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vous ne pouvez pas appeler de code arbitraire, car sous le verrou, vous ne pouvez faire qu'une petite activité granulaire. </font><font style="vertical-align: inherit;">Courez sous certaines </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actions</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il est impossible de venir d'où ils viennent. </font><font style="vertical-align: inherit;">Comment résoudre ce problème?</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span>  tcs  =  <span class="hljs-keyword">new</span>   TaskCompletionSource&lt;<span class="hljs-keyword">int</span>&gt;(<font></font>
       TaskContinuationsOptions.RunContinuationsAsynchronously  <font></font>
) ;<font></font>
<span class="hljs-keyword">lock</span>(mylock)<font></font>
{  <font></font>
    tcs.SetResult(O); <font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vaut la peine d'être </font><font style="vertical-align: inherit;">utilisé </font><font style="vertical-align: inherit;">uniquement pour l'adaptation du </font><font style="vertical-align: inherit;">code </font><font style="vertical-align: inherit;">non </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans les bibliothèques. </font><font style="vertical-align: inherit;">Presque tout le reste peut être résolu en attendant. </font><font style="vertical-align: inherit;">Dans ce cas, il est toujours fortement recommandé de prescrire le paramètre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"TaskCompletionSource.RunContinuationsAsynchronously"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vous devez presque toujours exécuter une continuation de manière asynchrone. </font><font style="vertical-align: inherit;">Dans ce cas, vous </font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avez quelque chose sous lequel rien ne sera lancé. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ap/_-/ab/ap_-abu8wjhwxr0edsvayrcc-6w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi la poursuite doit-elle être effectuée de manière synchrone? </font><font style="vertical-align: inherit;">Parce qu'il </font></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fait référence aux éléments suivants </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et non aux nôtres. </font><font style="vertical-align: inherit;">Pour établir un lien avec le nôtre, vous devez écrire ce qui suit: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/zj/6q/qbzj6q1fjhhqozii8yec5ok3pcy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet exemple montre comment les paramètres ne sont pas intuitifs, comment ils se croisent les uns avec les autres, comment ils introduisent une complexité cognitive - c'est si difficile à écrire.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hiérarchie parent-enfant</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   })<font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// don’t wait for child</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe d'autres options d'utilisation des paramètres. Par exemple, une </font><font style="vertical-align: inherit;">hiérarchie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parent-enfant</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> apparaît </font><font style="vertical-align: inherit;">lorsque vous lancez une tâche et en exécutez une autre sous celle-ci. Dans ce cas, si vous écrivez </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'attendrez pas la tâche lancée à l'intérieur. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gw/se/28/gwse28nxykd4vfwt_chfw0qjt_w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous écrivez </font></font><code>TaskCreationOptions.AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cela </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attendra. Vous pouvez utiliser cette propriété dans vos produits. Je pense que tout le monde peut trouver un exemple dans lequel il y a une hiérarchie de tâches, la tâche attendant la sous-tâche et la sous-tâche pour ses sous-tâches. Pas besoin d'écrire n'importe où </font></font><code>WaitForChildren</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cette attente se produit de manière asynchrone. En d'autres termes, le corps de la tâche parent se termine et, après cela, la tâche parent n'est pas considérée comme terminée, ne démarre pas ses continuations tant que les tâches enfants ne fonctionnent pas.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// still wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... parent task to attach is in ThreadStatic</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il peut y avoir un problème dans lequel la tâche est transférée quelque part </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis tout ce que vous avez commencé </font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sera ajouté à cette tâche parent, qui est une alarme.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo();<font></font>
}, TaskCreationOptions.DenyChildAttach)<font></font>
.ContinueWith(...) <span class="hljs-comment">// don’t wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'un autre côté, il existe une option qui annule l'option précédente </font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Une telle application se produit assez souvent.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Run(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">//don’t wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
    }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient de rappeler que </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c'est la façon standard de démarrer, ce qui implique par défaut </font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le contexte implicite que vous mettez vous </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajoute de la complexité. Vous ne comprenez pas comment fonctionne la tâche, car vous devez connaître le contexte. Un autre problème qui peut survenir est lié à l'état inactif de async / wait. C'est parce que dans </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / attendent,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous n'avez pas de tâches, mais des actions. La poursuite n'est pas une tâche honnête, mais une action. Lorsque vous écrivez du code asynchrone / attendent, vous n'avez pas besoin de l'utiliser </font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car vous liez explicitement les tâches à attendre, et c'est la bonne approche. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/k7/q5/vg/k7q5vgi8h9qwvvo3akgzow8vu_q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous avez six options pour démarrer une continuation. Vous avez lancé la tâche, lancé</font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Question: Quel statut aura cette continuation? </font><font style="vertical-align: inherit;">Il y a cinq réponses possibles:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la poursuite générale se terminera avec succès; RunToCompletion se produira;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la tâche sera erronée;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'annulation aura lieu;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la tâche n'atteindra pas son terme du tout, elle sera dans une sorte de vide;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">option - "dépend".</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/5u/x5/1k/5ux51kwpr4aixg_2io3xroerxam.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, la tâche sera dans l'état «annulé», bien que nulle part le mot «annulé» ne soit mentionné. </font><font style="vertical-align: inherit;">Ici, nous jetons la réception et ne faisons rien. </font><font style="vertical-align: inherit;">Le problème est que lorsque vous lisez le code de quelqu'un d'autre avec beaucoup d'options - même si vous connaissiez ces options il y a 10 minutes - vous oubliez toujours ce qui se passe ici. </font><font style="vertical-align: inherit;">Alors n'écrivez pas.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annulation</font></font></h3><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(); <font></font>
});<font></font>
<font></font>
                                                      Failed</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le troisième paramètre au début de la tâche est la kancellation. </font><font style="vertical-align: inherit;">Vous écrivez </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, c'est-à-dire une action spéciale qui met la tâche à l'état «Annulé». </font><font style="vertical-align: inherit;">Dans ce cas, la tâche sera dans l'état "Échec", car tous ne </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont pas égaux.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(cancellationToken); <font></font>
}, cancellationToken);<font></font>
<font></font>
                                                      Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour que la tâche soit en mesure de le faire </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous devez la jeter </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec son CancellationToken. </font><font style="vertical-align: inherit;">En réalité, vous ne faites jamais explicitement cela, mais faites-le de cette façon:</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    cancellationToken.ThrowIfCancellationRequested(); <font></font>
}, cancellationToken);<font></font>
                                                       Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Est-il nécessaire de distinguer CancellationToken? </font><font style="vertical-align: inherit;">Quelque part à l'intérieur de la tâche, vous vérifiez que quelqu'un vous a supprimé: annulation du lancer, puis la tâche passe à l'état </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ou quelqu'un a cliqué sur «Annuler» au moment de l'exécution et a annulé la tâche. </font><font style="vertical-align: inherit;">Notre pratique chez JetBrains suggère que vous n'avez pas besoin de faire la distinction entre ces jetons. </font><font style="vertical-align: inherit;">Si vous obtenez une </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OperationCanceledException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - un type spécial qui se produit lorsqu'une annulation s'est produite, vous pouvez la distinguer. </font><font style="vertical-align: inherit;">Dans ce cas, il vous suffit de terminer la tâche normalement, de ne pas vous connecter et lorsque vous recevez l'exécution - connectez-vous.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pile profonde</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    Foo();<font></font>
}, cancellationToken);<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
     Bar() {<font></font>
       ...<font></font>
          Baz() {<font></font>
             <span class="hljs-comment">//how to get cancellation token?</span><font></font>
          } <font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Disons que vous avez une pile profonde. C'est </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le seul paramètre explicite dont nous avons discuté. Elle doit être transmise partout dans absolument toutes les hiérarchies. Que dois-je faire si, en présence d'une hiérarchie profonde, vous devez annuler votre tâche quelque part, au niveau le plus bas, pour rejeter la réception? Il y a une astuce si spéciale que nous utilisons. Il est appelé </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">static</span> AsyncLocal&lt;Cancelation&gt; asyncLocalCancellation;<font></font>
<font></font>
Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
     asyncLocalCancellation.Set(cancellationToken) <font></font>
    Foo();<font></font>
}, cancellationToken); <span class="hljs-comment">// use AsyncLocal to put cancellation int</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { 
     <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span> {<font></font>
      ...<font></font>
         Baz() {<font></font>
             asyncLocalCancellation.Value.CheckForInterrupt(); <font></font>
         }<font></font>
   } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est la même chose que, </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seul celui spécial </font></font><code>ThreadLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui survit aux trajets de code asynchrone / attente. </font><font style="vertical-align: inherit;">Étant donné que votre code est asynchrone et que vous avez cette annulation, vous l'avez insérée </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et quelque part à un niveau profond, vous pouvez dire " </font></font><code>CheckForInterrupt Throw If Cancellation Requested</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". </font><font style="vertical-align: inherit;">Encore une fois, c'est le seul paramètre </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui doit complètement enduire le code entier, mais, à mon avis, pour la plupart des tâches, vous avez juste besoin de savoir ce qui s'est passé </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et de cela en tirer une conclusion qui indique: Annulé ou Échoué.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complexité cognitive</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
    TaskCreationOptions, <font></font>
    TaskScheduler, <font></font>
    CancellationToken<font></font>
)<font></font>
                                                   JetBrains.Lifetimes<font></font>
<font></font>
lifetime.Start(TaskScheduler, Action) <span class="hljs-comment">//puts lifetime in AsyncLocal</span><font></font>
<font></font>
lifetime.StartMainRead(Action) <font></font>
lifetime.StartMainWrite(TaskScheduler, Action) <font></font>
lifetime.StartBackgroundRead(TaskScheduler, Action)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus le code est difficile à lire lors du démarrage de la tâche, plus le risque d'erreur est élevé. En regardant le code après un an, vous oublierez ce qu'il fait, car il y a un grand nombre de paramètres. Mais nous avons la bibliothèque </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JetBrains.Lifetimes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui offre des durées de vie modernes, un CancellationToken bien optimisé, avec lequel la méthode Start a été réécrite et le problème avec la répétition de morceaux de code a été résolu, comme avec </font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe un petit nombre de planificateurs qui vous permettent de planifier une tâche sur le thread principal avec un verrou en lecture. Autrement dit, le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verrou de lecture</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n'est pas quelque chose que vous choisissez explicitement, c'est un planificateur spécial qui planifie votre code sur le thread principal avec un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verrou de lecture</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ainsi que le thread principal avec verrouillage en écriture, le thread d'arrière-plan - et maintenant les méthodes deviennent très simples pour démarrer la lecture aléatoire. Dans le même temps, les durées de vie s'annulent automatiquement </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui simplifie considérablement le code. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_h/1n/gu/_h1ngucdl-vvbpyyalkk_gwvapu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / wait</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> résout ces problèmes et quels problèmes ils introduisent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet exemple, une partie du code est exécutée de manière synchrone, puis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attend</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et code asynchrone. Premièrement, il est bon qu’il y ait beaucoup moins de morceaux de code répétitifs ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plaque de chaudière</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Deuxièmement, il est bon que le code asynchrone soit très similaire au code synchrone, c'est exactement à cela que sert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / attente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Vous pouvez écrire de manière asynchrone de la même manière que vous avez écrit de manière synchrone, sans prendre de threads.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, que déploiera le compilateur? Le code synchrone s'exécutera de manière synchrone, après quoi la tâche s'exécutera de manière synchrone </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, d'où vient l'objet GetAwaiter spécial. Dans ce cas, nous sommes intéressés </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Vous pouvez écrire votre serveur pour absolument n'importe quel objet. Par conséquent, nous attendons que la tâche soit terminée </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font><font style="vertical-align: inherit;">exécutée de manière </font><font style="vertical-align: inherit;">synchrone </font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si la tâche ne s'est pas terminée, alors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuationCode</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est planifié sur le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planificateur de contexte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il se peut que, même si vous avez écrit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attendre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , absolument tout sera appelé de manière synchrone.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
   <span class="hljs-keyword">await</span> InnerAsync();
   <span class="hljs-keyword">await</span> Task.Yield(); <span class="hljs-comment">//guaranteed !IsCompleted </span><font></font>
   continuationCode();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a une astuce </font></font><code>Task.Yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- c'est une tâche spéciale qui garantit que son serveur ne vous reviendra pas toujours </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Par conséquent, </font></font><code>continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il ne sera pas appelé de manière synchrone à cet endroit. Pour un thread d'interface utilisateur, cela peut être important car vous ne prenez pas ce thread pendant une longue période. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jg/jy/7d/jgjy7dh0cnbslfcyk4jpyapc9du.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment choisir un fil pour la suite? La philosophie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asynchrone / attendre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est la </font><font style="vertical-align: inherit;">suivante: vous écrivez du code asynchrone de la même manière que synchrone. Si vous avez un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pool de threads</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">cela </font><font style="vertical-align: inherit;">ne </font><font style="vertical-align: inherit;">fait </font><font style="vertical-align: inherit;">aucune différence pour vous - continuationCode sera exécuté sur un autre thread. Indépendamment du fait qu'elle ait été </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terminée lorsque vous avez dit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attendre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou non, vous avez besoin de tout pour exécuter sur le thread d'interface utilisateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le mécanisme de tâche en attente est le suivant: il est pris </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il est appelé</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et à partir de là est créé </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SynchronizationContext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une chose avec la méthode Post, qui est très similaire à la méthode </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En fait </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui était plus tôt, il prend simplement </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et à travers Post effectue sa tâche.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
    continuationCode(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe un moyen de modifier ce comportement à l'aide d'un paramètre </font></font><code>ContinueOnCapturedContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">L'API la plus dégoûtante de .NET est appelée </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans ce cas, l'API crée un serveur d'attente spécial, différent de </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">celui qui décale la suite, il s'exécute sur le même thread, dans le même contexte dans lequel la méthode s'est terminée </font></font><code>InnerAsync </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et où la tâche s'est terminée.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//code must be absolutely context-agnostic</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a une quantité insensée de conseils sur Internet: si vous avez un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blocage</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , veuillez salir tout votre code ConfigureAwait et tout ira bien. </font><font style="vertical-align: inherit;">C'est la mauvaise façon. </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut être utilisé dans les cas où vous souhaitez améliorer légèrement les performances, ou à la fin de la méthode, dans certaines méthodes de bibliothèque.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deadlocks</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode();<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit d'une </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impasse</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> classique </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sur le thread d'interface utilisateur, ils ont attendu dix secondes et l'ont fait </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En raison de ce que vous avez fait </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il </font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne sera jamais lancé, il </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne reviendra donc jamais. </font><font style="vertical-align: inherit;">Tout cela a lieu au tout début.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">OnBluttionClick</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span>
  <span class="hljs-keyword">int</span> v = Button.Text.ParseInt();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
  Button.Text.Set((v+<span class="hljs-number">1</span>).ToString());<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imaginez qu'il s'agit d'une véritable activité. Nous avons cliqué sur le bouton, l'avons pris </font></font><code>Button.ParseInt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, fait </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attendre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , écrit </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons dit: "Veuillez ne pas fermer notre flux d'interface utilisateur, effectuez la suite." Le problème est que nous voulons que la deuxième partie après soit </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">également exécutée sur le thread d'interface utilisateur, car c'est la philosophie de l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Autrement dit, votre code asynchrone ressemble au code synchrone et s'exécute dans le même contexte. Dans ce cas, bien sûr, il y aura une erreur. De plus, </font></font><code>Button.Text.Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il peut y avoir un certain nombre d'appels de méthode qui prennent également en compte leur contexte. que-faire dans cette situation? Tu peux le faire:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//The same UI context</span><font></font>
}<font></font>
PumpUntil(() =&gt; task.IsCompleted);<font></font>
<span class="hljs-comment">//VS synchronization contexts always pump on any Wait</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec un thread d'interface utilisateur, vous devez interdire de le faire </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur les threads qui ont une file d'attente de messages commune. Au lieu de faire </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou d'écrire </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous pouvez pomper cette file d'attente de messages, et en même temps, le continuum sera également pompé. Si vous ne pouvez pas mélanger du code synchrone et asynchrone, vous ne devez pas les mélanger. Mais parfois, cela ne peut être évité. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, vous avez un ancien code, et vous devez les mélanger, puis vous pompez le flux d'interface utilisateur. Visual Studio pompe le fil de l'interface utilisateur sur les attentes, il a même </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un peu changé. Si vous accédez à WaitHandle sur l'un d'eux </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lorsque vous raccrochez, votre flux d'interface utilisateur est pompé. Ainsi, ils choisissent entre les </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blocages</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et les races en faveur de la race s. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pumpuntil</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Il s'agit d'une API non idéale, c'est-à-dire que lorsque vous effectuez une continuité aléatoire dans un endroit arbitraire, il peut y avoir des nuances. </font><font style="vertical-align: inherit;">Il n'y a malheureusement pas d'autre moyen. </font><font style="vertical-align: inherit;">Mélangez les codes synchrones et asynchrones. </font><font style="vertical-align: inherit;">Si quoi que ce soit, l'ensemble du Rider est ainsi arrangé dans les anciens endroits, donc parfois il y a aussi des nuances.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changer le contexte</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> myTaskScheduler;<font></font>
    continuationCode(); <span class="hljs-comment">//on scheduler context </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe une autre façon intéressante d'utiliser </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / wait</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vous pouvez écrire </font></font><code>Awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et sauter sur les </font><font style="vertical-align: inherit;">filets. </font><font style="vertical-align: inherit;">J'ai lu des articles dans Visual Studio, ils ont écrit pendant très longtemps qu'il n'était pas bon de faire des allers-retours au milieu de la méthode, mais maintenant ils le font eux-mêmes. </font><font style="vertical-align: inherit;">Visual Studio possède une API qui saute sur les threads via les planificateurs. </font><font style="vertical-align: inherit;">Pour une utilisation normale, ce n'est pas bon.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concurrence structurée</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Factory.StartNew(() =&gt; {...}, myTaskScheduler);<font></font>
    continuationCode(); <span class="hljs-comment">//on initial context </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour une immersion pratique dans le nouveau contexte et un retour à l'ancien, une certaine concurrence structurelle, ou parallélisme structurel, devrait être établie. </font><font style="vertical-align: inherit;">Par exemple, dans les années 60, l'opérateur GoTo était considéré comme nuisible car il violait la structure. </font><font style="vertical-align: inherit;">C'est donc ici. </font><font style="vertical-align: inherit;">Sauter sur les fils viole la structure. </font><font style="vertical-align: inherit;">Étonnamment, l'utilisation d'une machine d'état asynchrone semble être une bonne solution. </font><font style="vertical-align: inherit;">Autrement dit, lorsque votre structure habituelle est violée, vous sautez sur GoTo, vous pouvez violer la structure des threads: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attendez</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">mélangez </font><font style="vertical-align: inherit;">-la avec des balises. </font><font style="vertical-align: inherit;">Il s'agit d'une situation extrêmement étrange et rare lorsque vous devez le faire. </font><font style="vertical-align: inherit;">Pourtant, c'est mieux quand </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attendre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> revient dans le même contexte. </font><font style="vertical-align: inherit;">Ainsi, le pool de threads n'aura pas le même thread, mais le même contexte qu'il était à l'origine.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comportement séquentiel</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attendre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n'est-il pas la même chose que l'exécution parallèle? </font><font style="vertical-align: inherit;">Attendre l'exécution est une exécution séquentielle. </font><font style="vertical-align: inherit;">Dans ce cas, nous commençons la première tâche, l'attendons, démarrons la deuxième tâche - nous attendons. </font><font style="vertical-align: inherit;">Nous n'avons aucun parallélisme. </font><font style="vertical-align: inherit;">Pour la plupart des utilisations, le parallélisme n'est pas nécessaire. </font><font style="vertical-align: inherit;">Le parallélisme lui-même est plus complexe que la séquence. </font><font style="vertical-align: inherit;">Le code série est plus simple que parallèle, c'est un axiome. </font><font style="vertical-align: inherit;">Mais parfois, vous devez exécuter quelque chose en code parallèle, et vous le faites comme ceci:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">await</span> task1;<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comportement simultané</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();<font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, les tâches commencent en parallèle. </font><font style="vertical-align: inherit;">Il est clair que les méthodes peuvent renvoyer la tâche immédiatement dans un état en cours d'exécution, il n'y aura donc pas de parallélisme. </font><font style="vertical-align: inherit;">Disons que les deux lancent une exécution. </font><font style="vertical-align: inherit;">Et vous avez attendu la première tâche, puis la première attente a décollé. </font><font style="vertical-align: inherit;">Autrement dit, dès que vous avez écrit </font></font><code>await task1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous avez décollé et n'avez pas traité </font></font><code>exception task2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fait intéressant, il s'agit d'un code absolument valide. </font><font style="vertical-align: inherit;">Et c'est ce code qui a conduit .NET au fait que dans la version 4.5, le comportement de travail avec les exécutions a changé.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gestion des exceptions</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async(); <font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2;<font></font>
<font></font>
  <span class="hljs-comment">// if task1 throws exception and task2 throws exception we only throw and</span>
  <span class="hljs-comment">// handle task1’s exception</span><font></font>
<font></font>
  <span class="hljs-comment">//4.0 -&gt; 4.5 framework: unhandled exceptions now don’t crush process</span>
  <span class="hljs-comment">//still visible in UnobservedExceptionHandler</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auparavant, les exécutions non gérées jetaient simplement le processus, et si vous n’avez pas détecté d’exécution </font></font><code>UnobservedExceptionHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous pouvez également en attacher </font><font style="vertical-align: inherit;">certaines </font><font style="vertical-align: inherit;">à des planificateurs), ce processus n’a pas été exécuté. Maintenant, c'est un code absolument valide. Bien que .NET ait modifié son comportement, il a conservé le paramètre pour renvoyer le comportement dans la direction opposée.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span>  Task  <span class="hljs-title">MyAsync</span>(<span class="hljs-params">CancellationToken cancellationToken</span>)</span>  {  <font></font>
<font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">SomeTask1  <span class="hljs-title">Async</span>(<span class="hljs-params">cancellationToken</span>)</span>; <font></font>
 <font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">Some <span class="hljs-title">Task2Async</span>(<span class="hljs-params"> cancellation  Token</span>)</span>; 
  <span class="hljs-comment">//you should always pass use async API with cancelationToken  if possible </span><font></font>
} <font></font>
  <font></font>
<span class="hljs-keyword">try</span> { 
    <span class="hljs-keyword">await</span>  MyAsync( cancellation  Token); <font></font>
} <span class="hljs-keyword">catch</span> (OperationException e) { <span class="hljs-comment">// do nothing: OCE happened</span>
} <span class="hljs-keyword">catch</span> (Exception e) { <font></font>
    log.Error(e);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyez comment se déroule le traitement de l'exécution. </font><font style="vertical-align: inherit;">Les CancellationToken-s doivent être transmis, il faut "enduire" CancellationToken-s de tout le code. </font><font style="vertical-align: inherit;">Le comportement normal d'Async est que vous ne vérifiez nulle part </font></font><code>Task.Status ancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous travaillez avec du code asynchrone de la même manière qu'avec Synchrone. </font><font style="vertical-align: inherit;">Autrement dit, dans le cas d'une annulation, vous obtenez une exécution, et dans ce cas, vous ne faites rien lorsque vous la recevez </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La différence entre le statut Annulé et En panne est que vous n'avez pas reçu </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais l'exécution habituelle. </font><font style="vertical-align: inherit;">Et dans ce cas, nous pouvons le promettre, il vous suffit d'obtenir une exécution et de tirer des conclusions sur cette base. </font><font style="vertical-align: inherit;">Si vous aviez démarré la tâche explicitement, via Task, vous auriez volé </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Et en async, dans le cas où ils </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lancent toujours la toute première exécution qui s'y trouvait (dans ce cas - </font></font><code>OperationCanceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En pratique</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Méthode synchrone</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SynchronousWorker</span>(<span class="hljs-params">...</span>)</span> {<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, un démon fonctionne dans ReSharper - un éditeur qui teinte le fichier pour vous. </font><font style="vertical-align: inherit;">Si le fichier est ouvert dans l'éditeur, une activité le place dans une file d'attente de blocage. </font><font style="vertical-align: inherit;">Notre processus </font></font><code>worker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lit à partir de là, après quoi il effectue un tas de tâches différentes avec ce fichier, le teint, analyse, construit, après quoi ces fichiers sont ajoutés </font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Avec un </font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verrou, d'autres mécanismes fonctionnent déjà avec lui.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Méthode asynchrone</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la réécriture du code en asynchrone, nous le remplacerons tout d'abord </font></font><code>void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par </font></font><code>async Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Assurez-vous d'écrire le mot «Async» à la fin. </font><font style="vertical-align: inherit;">Toutes les méthodes asynchrones doivent se terminer par Async - c'est une convention.</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
<font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après cela, vous devez faire quelque chose avec le nôtre </font></font><code>blockingQueue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. De toute évidence, s'il existe une primitive synchrone, il doit y avoir une primitive asynchrone. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-6/zk/8i/-6zk8ilnmdsonzd6zkafkcloqyi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette primitive est appelée canal: les canaux qui vivent dans le package </font></font><code>System.Threading.Channels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Vous pouvez créer des canaux et des files d'attente, limités et illimités, que vous pouvez attendre de manière asynchrone. De plus, vous pouvez créer un canal avec une valeur "zéro", c'est-à-dire qu'il n'aura pas du tout de tampon. Ces canaux sont appelés canaux de rendez-vous et sont activement promus à Go et Kotlin. Et en principe, s'il est possible d'utiliser des canaux en code asynchrone, c'est un très bon schéma. Autrement dit, nous changeons la file d'attente pour le canal où il existe des méthodes </font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>WriteAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessInParallel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un tas de code parallèle qui fait le traitement d'un fichier et le transforme en</font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">L'async peut-il nous aider à écrire un code non asynchrone, mais parallèle plus compact?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplifiez le code parallèle</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code peut être réécrit de cette façon:</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e0/zt/8u/e0zt8ud_8b4_wsiqsrd9_baalwy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À quoi ressemblent-ils </font></font><code>ProcessInParallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Par exemple, nous avons un fichier. Tout d'abord, nous le décomposons en lexèmes, et nous pouvons avoir deux tâches en parallèle: construire des caches de recherche et construire un arbre de syntaxe. Après cela vient la tâche de «rechercher les erreurs sémantiques». Il est important ici que toutes ces tâches forment un graphe acyclique dirigé. Autrement dit, vous pouvez exécuter certaines parties dans des threads parallèles, d'autres non, et il existe évidemment des dépendances qui doivent attendre d'autres tâches. Vous obtenez un graphique de ces tâches, vous voulez en quelque sorte les disperser le long des fils. Est-il possible de l'écrire magnifiquement, sans erreurs? Dans notre code, ce problème a été résolu plusieurs fois, à chaque fois d'une manière différente. Cela se produit rarement lorsque ce code est écrit sans erreur.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xh/-h/3j/xh-h3jav69twzsqei3rrjbe2ymy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous définissons ce graphique de tâches comme suit: disons que chaque tâche a d'autres tâches dont elle dépend, puis en utilisant le dictionnaire ExecuteBefore nous écrivons le squelette de notre méthode.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solutions squelettes</font></font></h3> <br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore; <span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();<font></font>
<font></font>
<font></font>
  <span class="hljs-comment">// lots of work with toposort, locks, etc.</span><font></font>
<font></font>
  <span class="hljs-keyword">return</span> res; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous résolvez ce problème de front, vous devez effectuer un tri topologique de ce graphique. </font><font style="vertical-align: inherit;">Prenez ensuite une tâche qui n'a pas de tâches dépendantes, exécutez-la, analysez la structure sous un verrou, voyez quelles tâches n'en ont pas. </font><font style="vertical-align: inherit;">Courez, dispersez-les d'une manière ou d'une autre </font></font><code>Task Runner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous l'écrivons un peu plus compact: tri topologique du graphe + exécution de telles tâches sur différents threads.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async paresseux</font></font></h3><br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore;
<span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();
  <span class="hljs-keyword">var</span> lazy = <span class="hljs-keyword">new</span> Dictionary&lt;Action&lt;ProcessedFile&gt;, Lazy&lt;Task&gt;&gt;(); 
  <span class="hljs-keyword">foreach</span> ((action, beforeList) <span class="hljs-keyword">in</span> ExecuteBefore)<font></font>
    lazy[action] = <span class="hljs-keyword">new</span> Lazy&lt;Task&gt;(<span class="hljs-keyword">async</span> () =&gt; <font></font>
    {<font></font>
      <span class="hljs-keyword">await</span> Task.WhenAll(beforeList.Select(b =&gt; lazy[b].Value)) 
      <span class="hljs-keyword">await</span> Task.Yield();<font></font>
      action(res);<font></font>
}<font></font>
  <span class="hljs-keyword">await</span> Task.WhenAll(lazy.Values.Select(l =&gt; l.Value)) 
  <span class="hljs-keyword">return</span> res;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un modèle appelé </font></font><code>Async Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nous créons les nôtres </font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur lesquelles différentes actions doivent être exécutées. Créons un dictionnaire: nous allons formater chacune de nos étapes (Action ProcessedFile) dans une tâche, ou plutôt dans Lazy from Task et parcourir le graphique d'origine. La variable </font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aura l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">action</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elle </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">même </font><font style="vertical-align: inherit;">, et dans beforeList - les actions qui doivent être effectuées avant la nôtre. Créez ensuite à </font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partir de </font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nous écrivons dans Task </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ainsi, nous attendons toutes les tâches qui doivent être accomplies avant lui. Dans beforeList, sélectionnez celui </font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui se trouve dans ce dictionnaire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez noter qu'ici, rien ne sera exécuté de manière synchrone, donc ce code ne tombera pas </font></font><code>ItemNotFoundException in Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nous réalisons toutes les tâches qui étaient avant les nôtres, effectuant une recherche par action</font></font><code>Lazy Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ensuite, nous exécutons notre action. </font><font style="vertical-align: inherit;">En fin de compte, il vous suffit de demander à chaque tâche de démarrer, sinon vous ne savez jamais si quelque chose n'a pas commencé. </font><font style="vertical-align: inherit;">Dans ce cas, rien n'a commencé. </font><font style="vertical-align: inherit;">Voilà la solution. </font><font style="vertical-align: inherit;">Cette méthode est écrite en 10 minutes, c'est absolument évident. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, le code asynchrone a pris notre décision, il occupait initialement quelques écrans avec un code concurrentiel complexe. </font><font style="vertical-align: inherit;">Ici, il est absolument cohérent. </font><font style="vertical-align: inherit;">Je ne l'utilise même pas </font></font><code>ConcurrentDictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, j'utilise l'habituel </font></font><code>Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car nous n'y écrivons rien de manière compétitive. </font><font style="vertical-align: inherit;">Il existe un code cohérent et cohérent. </font><font style="vertical-align: inherit;">Nous résolvons </font><font style="vertical-align: inherit;">magnifiquement </font><font style="vertical-align: inherit;">le problème de l'écriture de code parallèle en utilisant </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async-s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui signifie - sans bugs.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Débarrassez-vous des verrous</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
    <span class="hljs-keyword">lock</span> (_lock) {<font></font>
      sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
   }<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vaut-il la peine de retirer async et ces verrous? Il existe maintenant toutes sortes de verrous asynchrones, des sémaphores asynchrones, c'est-à-dire une tentative d'utilisation des primitives qui sont en code synchrone et asynchrone. Ce concept semble être faux, car avec le verrou, vous protégez quelque chose contre l'exécution parallèle. Notre tâche est de traduire l'exécution parallèle en séquentielle, car c'est plus facile. Et si c'est plus facile, il y a moins d'erreurs.</font></font><br>
<br>
<pre><code class="cs hljs">Channel&lt;Pair&lt;File, ProcessedFile&gt;&gt; output;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
  <font></font>
  <span class="hljs-keyword">await</span> output.WriteAsync(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons créer un canal et y mettre quelques fichiers et fichiers traités, et </font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une autre procédure </font><font style="vertical-align: inherit;">traitera ce canal </font><font style="vertical-align: inherit;">et le fera séquentiellement. Le verrou lui-même, en plus de protéger la structure, linéarise essentiellement l'accès, un endroit où tous les fils de fils consécutifs deviennent parallèles. Et nous remplaçons cela explicitement par le canal. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q_/qe/mf/q_qemfc4mssz9shitqlekzee6nc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'architecture est la suivante: les travailleurs reçoivent des fichiers </font></font><code>input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et les envoient quelque part au processeur, qui traite également tout séquentiellement, il n'y a pas de parallélisme. Le code semble beaucoup plus simple. Je comprends que tout ne peut pas être fait de cette façon. Une telle architecture, lorsque vous pouvez créer des canaux de données, ne fonctionne pas toujours.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7k/9j/sv/7k9jsvdwqbqrzgbejoozsk5lj_s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il se peut que vous ayez un deuxième canal qui entre dans votre processeur et qu'un graphique dirigé acyclique ne soit pas formé à partir des canaux, mais un graphique avec des cycles. </font><font style="vertical-align: inherit;">C'est un exemple que Roman Elizarov a déclaré à KotlinConf en 2018. </font><font style="vertical-align: inherit;">Il a écrit un exemple sur Kotlin avec ces canaux, et il y avait des cycles là-bas, et cet exemple a été arrêté. </font><font style="vertical-align: inherit;">Le problème était que si vous avez de tels cycles dans un graphique, alors tout devient plus compliqué dans le monde asynchrone. </font><font style="vertical-align: inherit;">Les interblocages asynchrones sont mauvais en ce sens qu'ils sont beaucoup plus difficiles à résoudre que les synchrones lorsque vous avez une pile de threads, et il est clair de quoi il s'agit. </font><font style="vertical-align: inherit;">C'est donc un outil qui doit être utilisé correctement.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sommaire</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Évitez la synchronisation en code asynchrone.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code série est plus simple que parallèle.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code asynchrone peut être simple et utiliser un minimum de paramètres et un contexte implicite qui modifient son comportement.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous avez développé l'habitude d'écrire du code synchrone, et même si le code asynchrone est très similaire au code synchrone, n'y faites pas glisser de primitives, ce à quoi vous êtes habitué en code synchrone </font></font><code>async mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Utilisez des flux, si possible, et d'autres primitives de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passage de message</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code série est plus simple que parallèle. Si vous pouvez écrire votre architecture de façon à ce qu'elle apparaisse séquentiellement, sans exécuter de code parallèle ni verrouiller, alors écrivez l'architecture séquentiellement.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et la dernière chose que nous avons vue à partir d'un grand nombre d'exemples de tâches. </font><font style="vertical-align: inherit;">Lorsque vous concevez votre système, essayez de vous fier moins au contexte implicite. </font><font style="vertical-align: inherit;">Le contexte implicite conduit à une mauvaise compréhension de ce qui se passe dans le code, et vous pouvez oublier les problèmes implicites dans un an. </font><font style="vertical-align: inherit;">Et si une autre personne travaille sur ce code et y refait quelque chose, cela peut entraîner des difficultés que vous connaissiez autrefois, et le nouveau programmeur ne le sait pas à cause du contexte implicite. </font><font style="vertical-align: inherit;">En conséquence, une mauvaise conception est caractérisée par un grand nombre de paramètres, leur combinaison et leur contexte implicite.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que lire</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Document TAP</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guidage asynchrone</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durée de vie</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">medium.com/@elizarov/deadlocks-in-non-hierarchical-csp-e5910d137cc</font></font></a></li>
</ul><br>
<blockquote>     -10     .     DotNext   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr491218/index.html">Intégration de PVS-Studio dans PlatformIO</a></li>
<li><a href="../fr491224/index.html">Automatisation d'un service de répartition, ou comment une entreprise de services peut réduire les coûts de transport de 30%</a></li>
<li><a href="../fr491230/index.html">Comment je suis allé à l'école 21 et la divulgation de secrets</a></li>
<li><a href="../fr491232/index.html">RPA + Machine Learning = automatisation intelligente</a></li>
<li><a href="../fr491234/index.html">Trois astuces pour travailler avec SOLIDWORKS pour la modélisation de pièces pour l'impression 3D</a></li>
<li><a href="../fr491238/index.html">Analyse du code génétique II</a></li>
<li><a href="../fr491240/index.html">La route vers les nuages: hier et aujourd'hui Adobe</a></li>
<li><a href="../fr491244/index.html">Ableton n'est pas nécessaire: connectez Ableton Push 2 au rack VCV</a></li>
<li><a href="../fr491246/index.html">Conférence DEFCON 27. Votre voiture est ma voiture. Partie 2</a></li>
<li><a href="../fr491250/index.html">Lampes à LED Gauss Basic</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>