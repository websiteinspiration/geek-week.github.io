<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöã ü¶Å üò´ Programmation asynchrone dans .NET: meilleures pratiques ü§üüèΩ ‚õπüèº üÖ∞Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'av√®nement de async / wait en C # a conduit √† une red√©finition de la fa√ßon d'√©crire du code parall√®le simple et correct. Souvent, en utilisant la pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programmation asynchrone dans .NET: meilleures pratiques</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/491236/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'av√®nement de async / wait en C # a conduit √† une red√©finition de la fa√ßon d'√©crire du code parall√®le simple et correct. Souvent, en utilisant la programmation asynchrone, les programmeurs non seulement ne r√©solvent pas les probl√®mes li√©s aux threads, mais en introduisent √©galement de nouveaux. Les impasses et les vols ne vont nulle part - ils deviennent simplement plus difficiles √† diagnostiquer. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/uz/8g/buuz8gok2hqubwnj1773hwimncq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dmitry Ivanov - Software Analysis TeamLead chez Huawei, un ancien d√©veloppeur technologique JetBrains Rider et d√©veloppeur du noyau ReSharper: structures de donn√©es, caches, multithreading, et un conf√©rencier r√©gulier √† la conf√©rence </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sous la cin√©matique - enregistrement vid√©o et transcription textuelle du rapport de Dmitry de la conf√©rence DotNext 2019 Piter.</font></font><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/wM-h6P1BJRk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nouvelle narration au nom de l'orateur.</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dans le code multithread ou asynchrone, quelque chose se casse souvent. La raison pourrait √™tre √† la fois une impasse et une race. En r√®gle g√©n√©rale, une course se bloque une fois sur mille, souvent pas localement, mais uniquement sur un serveur de build, et il faut plusieurs jours pour l'attraper. Je suis s√ªr que pour beaucoup, c'est une situation famili√®re. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, en regardant du code asynchrone m√™me par des d√©veloppeurs exp√©riment√©s, je me surprends √† penser que certaines choses peuvent √™tre √©crites trois fois plus rapidement et plus correctement.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela sugg√®re que le probl√®me ne vient pas des personnes, mais de l'instrument. </font><font style="vertical-align: inherit;">Les gens utilisent simplement l'outil et veulent qu'il r√©sout leur probl√®me. </font><font style="vertical-align: inherit;">L'outil lui-m√™me dispose d'un tr√®s grand nombre de capacit√©s (parfois m√™me superflues), de param√®tres, d'un contexte implicite, ce qui conduit au fait qu'il est tr√®s facile √† utiliser incorrectement. </font><font style="vertical-align: inherit;">Essayons de comprendre comment utiliser async / wait et travailler avec une classe </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans .NET.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plan</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probl√®mes avec les approches r√©solues avec async / wait.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemples de conception controvers√©e.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une t√¢che de la vie r√©elle que nous allons r√©soudre de mani√®re asynchrone.</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async / attente et probl√®mes √† r√©soudre</font></font></h2><br>
<img src="https://habrastorage.org/webt/v1/ym/30/v1ym304jgxmwh_4kymlyqr4wddi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi avons-nous besoin d'async / wait? Disons que nous avons du code qui fonctionne avec la m√©moire partag√©e partag√©e. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au d√©but du travail, nous lisons la demande, dans ce cas, le fichier de la file d'attente de blocage (par exemple, d'Internet ou du disque), en utilisant la demande de blocage </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dequeue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (les demandes de blocage seront marqu√©es en rouge dans les images avec des exemples). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette approche n√©cessite beaucoup de threads, et chaque thread n√©cessite des ressources, cr√©e une charge sur le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planificateur</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mais ce n'est pas le probl√®me principal. Supposons que les utilisateurs puissent r√©√©crire les syst√®mes d'exploitation afin que ces syst√®mes prennent en charge √† la fois cent mille et un million de threads. Mais le principal probl√®me est que certains threads ne peuvent tout simplement pas √™tre pris. Par exemple, vous disposez d'un thread d'interface utilisateur. Il n'y a pas de cadres d'interface utilisateur ad√©quats normaux o√π l'acc√®s aux donn√©es ne serait pas seulement √† partir d'un seul thread, pour l'instant. Le thread d'interface utilisateur ne peut pas √™tre bloqu√©. Et pour ne pas le bloquer, nous avons besoin d'un code asynchrone. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parlons maintenant de la deuxi√®me t√¢che. Apr√®s avoir lu le fichier, il doit √™tre trait√© d'une mani√®re ou d'une autre. Nous le ferons en parall√®le. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beaucoup d'entre vous ont entendu dire que le parall√©lisme n'est pas la m√™me chose que l'asynchronie. Dans ce cas, la question se pose: l'asynchronie peut-elle aider √† √©crire du code parall√®le plus compact, beau et plus rapide?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La derni√®re t√¢che consiste √† travailler avec la m√©moire partag√©e. </font><font style="vertical-align: inherit;">Avons-nous besoin de faire glisser ce m√©canisme avec des verrous, la synchronisation vers du code asynchrone, ou cela peut-il √™tre √©vit√© d'une mani√®re ou d'une autre? </font><font style="vertical-align: inherit;">Peut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asynchroniser / attendre de l'</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aide √† ce sujet?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chemin vers async / attente</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons l'√©volution de la programmation asynchrone en g√©n√©ral dans le monde et en .NET.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rappeler</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Void <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {‚Ä¶}<font></font>
 <font></font>
<font></font>
<span class="hljs-function">Void <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ‚Ä¶<span class="hljs-comment">//synchronous code</span><font></font>
 <font></font>
    Foo(<span class="hljs-keyword">params</span>,() =&gt;{<font></font>
       ‚Ä¶<span class="hljs-comment">//asynchronous code;continuation</span><font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La programmation asynchrone a commenc√© par des rappels. </font><font style="vertical-align: inherit;">Autrement dit, vous devez d'abord appeler une partie du code de mani√®re synchrone et la seconde partie - de mani√®re asynchrone. </font><font style="vertical-align: inherit;">Par exemple, vous lisez un fichier et lorsque les donn√©es sont pr√™tes, elles vous seront livr√©es d'une mani√®re ou d'une autre. </font><font style="vertical-align: inherit;">Cette partie asynchrone est pass√©e en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rappel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus de rappels</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {...} 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">Action callback</span>)</span> {...}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Baz</span>(<span class="hljs-params">Action callback</span>)</span> {...}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
    <font></font>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; { <font></font>
      ... <span class="hljs-comment">//continuation 1 </span><font></font>
      Bar(() =&gt; {<font></font>
        <span class="hljs-comment">//continuation 2</span><font></font>
        Baz(() =&gt; {<font></font>
          <span class="hljs-comment">//continuation 3</span><font></font>
        }); <font></font>
      });<font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, √† partir d'un rappel, vous pouvez enregistrer un autre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rappel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , √† partir duquel vous pouvez enregistrer un troisi√®me rappel, et √† la fin, tout se transforme en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enfer de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rappel </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/vq/8g/bfvq8gknishmtrdwaiixz6mzuvs.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rappel: exceptions</font></font></h3><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action onSuccess, Action onFailure</span>)</span> {...}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code </span>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; {<font></font>
      ... <span class="hljs-comment">//asynchronous code on success </span><font></font>
    },<font></font>
    () =&gt; {<font></font>
        ... <span class="hljs-comment">//asynchronous code on failure</span><font></font>
    }); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment travailler avec des exceptions? Par exemple, ReSharper, lorsqu'il r√©pond s√©par√©ment aux exceptions et √† une bonne ex√©cution, ne pr√©sente pas les plus beaux morceaux de code - il existe des rappels distincts pour une situation exceptionnelle et pour une continuation r√©ussie. Le r√©sultat est un tel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enfer de rappel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais pas lin√©aire, mais semblable √† un arbre, ce qui peut √™tre compl√®tement d√©routant. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/hs/y3/lghsy31j9pke1do-8rpmcyuovfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans .NET, la premi√®re approche de rappel est appel√©e le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mod√®le de programmation asynchrone</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (APM). La m√©thode sera appel√©e </font></font><code>AsyncCallback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui est essentiellement la m√™me que </font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais l'approche a certaines caract√©ristiques. Tout d'abord, les m√©thodes doivent commencer par le mot ¬´Begin¬ª (la lecture d'un fichier est BeginRead), qui en renvoie </font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lui-m√™me</font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Il s'agit d'un gestionnaire qui sait que l'op√©ration est termin√©e et qui dispose d'un m√©canisme </font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Vous </font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pouvez attendre, en attendant que l'op√©ration se termine de mani√®re asynchrone. D'un autre c√¥t√©, vous pouvez appeler </font></font><code>EndOperation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, c'est-√†-dire cr√©er </font></font><code>EndRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et bloquer de mani√®re synchrone (ce qui est tr√®s similaire √† une propri√©t√© </font></font><code>Task.Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette approche pose un certain nombre de probl√®mes. Premi√®rement, cela ne nous prot√®ge pas de l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enfer des rappels</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Deuxi√®mement, on ne sait pas trop quoi faire des exceptions. Troisi√®mement, il n'est pas clair sur quel thread ce rappel sera appel√© - nous n'avons aucun contr√¥le sur l'appel. Quatri√®mement, la question se pose, comment combiner des morceaux de code avec des rappels? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mr/5z/xr/mr5zxr01ztmadod_fuetd3loqew.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxi√®me mod√®le est appel√© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mod√®le asynchrone bas√© sur les √©v√©nements</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il s'agit d'une approche de rappel r√©actif. L'id√©e de la m√©thode est que nous passons √† la m√©thode </font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un objet qui a l'√©v√©nement Completed et </font><font style="vertical-align: inherit;">que nous nous </font><font style="vertical-align: inherit;">abonnions √† cet √©v√©nement. Comme vous l'avez remarqu√©, les </font></font><code>BeginOperationName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modifications sont apport√©es √† </font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Une confusion peut se produire lorsque vous entrez dans la classe Socket, o√π deux mod√®les sont m√©lang√©s: </font></font><code>ConnectAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>BeginConnect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez noter que vous devez appeler pour annuler </font></font><code>OperationNameAsyncCancel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Comme dans .NET, cela ne se trouve nulle part ailleurs, g√©n√©ralement tout le monde envoie des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellationToken s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ainsi, si vous rencontrez accidentellement une m√©thode dans la biblioth√®que qui se termine par </font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous devez comprendre qu'elle ne retourne pas n√©cessairement </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais peut renvoyer une construction similaire. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/w4/4u/6sw44uh3ljw5kwdkowtxylfz5xc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consid√©rez un mod√®le connu sous Java comme</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Futures</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en JavaScript, en tant que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">promesses</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et en .NET, en tant que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mod√®les asynchrones de t√¢ches</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en d'autres termes, ¬´t√¢ches¬ª. Cette m√©thode suppose que vous disposez d'un objet de calcul et que vous pouvez voir l'√©tat de cet objet (en cours d'ex√©cution ou termin√©). Dans .NET, il existe une soi-disant </font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√©paration pratique de deux √©tats: le d√©but de la t√¢che et l'ach√®vement de la t√¢che. Une erreur courante se produit lorsqu'une m√©thode est appel√©e sur une t√¢che </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui renvoie une continuation non r√©ussie, mais </font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Faulted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ainsi, le r√©sultat du clic sur ¬´Annuler¬ª dans l'application d'interface utilisateur devrait diff√©rer du retour d'exceptions (ex√©cutions). Dans .NET, une distinction a √©t√© faite: si l'ex√©cution est votre erreur que vous souhaitez s√©curiser, alors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annuler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- op√©ration forc√©e. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans .NET, un concept a √©galement √©t√© introduit </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- c'est une sorte d'abstraction au-dessus des threads qui indique o√π ex√©cuter la t√¢che. Dans ce cas, le support d'annulation a √©t√© con√ßu au niveau de la conception. Presque toutes les op√©rations de la biblioth√®que en .NET </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peuvent √™tre pass√©es. Cela ne fonctionne pas pour toutes les langues: par exemple, dans Kotlin, vous pouvez annuler la t√¢che, mais pas dans .NET. La solution peut √™tre la r√©partition des responsabilit√©s entre ceux qui annulent la t√¢che et la t√¢che elle-m√™me. Lorsque vous recevez une t√¢che, vous ne pouvez pas l'annuler autrement qu'explicitement - vous devez la transmettre </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un objet sp√©cial </font></font><code>TaskCompletionSoure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous permet d'adapter facilement les anciennes API associ√©es au </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mod√®le asynchrone bas√©</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur les </font><i><font style="vertical-align: inherit;">√©v√©nements</font></i><font style="vertical-align: inherit;"> ou au </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mod√®le de programmation asynchrone</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il y a un document que vous devez lire si vous programmez des t√¢ches. </font><font style="vertical-align: inherit;">Il d√©crit tous les accords concernant les tasas. </font><font style="vertical-align: inherit;">Par exemple, toute m√©thode renvoyant la t√¢che doit la retourner dans un √©tat en cours d'ex√©cution, ce qui signifie qu'elle ne peut pas l'√™tre </font></font><code>Created</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, alors que toutes ces op√©rations doivent se terminer </font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combiner les suites</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Task <span class="hljs-title">ourMethod</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">return</span> Task.RunSynchronously(() =&gt;{<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Foo(); <span class="hljs-comment">//continuation 1</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Bar(); <span class="hljs-comment">//continuation 2</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Baz(); <span class="hljs-comment">//continuation 3</span><font></font>
  })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quant √† la combinaison, compte tenu de l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enfer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> du </font><i><font style="vertical-align: inherit;">rappel</font></i><font style="vertical-align: inherit;"> , elle peut appara√Ætre sous une forme plus lin√©aire, malgr√© la pr√©sence de morceaux de code r√©p√©titif avec des changements minimes. </font><font style="vertical-align: inherit;">Il semble que le code s'am√©liore de cette fa√ßon, mais il y a aussi des pi√®ges ici.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©marrer et continuer les t√¢ches</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
  TaskCreationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)<font></font>
Task.ContinueWith(Action&lt;Task&gt;, <font></font>
  TaskContinuationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons √† trois param√®tres lors du lancement de la t√¢che standard: les premiers sont les options de d√©marrage de la t√¢che, le second est </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">celui sur lequel la t√¢che est lanc√©e, et le troisi√®me - </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/w_/a4/fw/w_a4fwuiwflisfw-ifxqwtgnpxu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TaskScheduler indique o√π commence la t√¢che et est un objet que vous pouvez remplacer ind√©pendamment. Par exemple, vous pouvez remplacer une m√©thode </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si vous le faites </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la m√©thode </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend un thread </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et y envoie votre t√¢che. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous reprenez </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le thread principal, il place tout dans une file d'attente et les t√¢ches sont ex√©cut√©es s√©quentiellement sur le thread principal. Cependant, le probl√®me est que dans .NET, vous pouvez ex√©cuter une t√¢che sans passer </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La question se pose: comment alors .NET calcule-t-il la t√¢che qui lui a √©t√© transmise? Quand la t√¢che commence √† l' </font></font><code>StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int√©rieur</font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expos√© dans celui </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que nous lui avons donn√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette conception semble plut√¥t controvers√©e en raison du contexte implicite. Il y avait des cas o√π il </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contenait du code asynchrone qui h√©ritait quelque part tr√®s profond√©ment </font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et se chevauchait avec un autre ordonnanceur, ce qui entra√Ænait des blocages. Dans ce cas, vous pouvez utiliser l'option </font></font><code>TaskCreationOption.HideScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il s'agit d'une sonnette d'alarme qui indique que nous avons une option qui remplace le </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param√®tre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout est pareil avec les suites. La question se pose: d'o√π vient-elle </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour les suites? Tout d'abord, il est pris dans la m√©thode dans laquelle vous avez commenc√© </font></font><code>Continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il est √©galement </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extrait de ThreadStatic. Il est important que pour </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / wait, les</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> suites fonctionnent tr√®s diff√©remment.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bt/-f/ne/bt-fnekfbdnfmn4n-u3zrvp7bdc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous passons aux param√®tres </font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>TaskContinuationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Leur principal probl√®me est qu'il y en a beaucoup. Certains de ces param√®tres s'annulent, certains s'excluent mutuellement. Tous ces param√®tres peuvent √™tre utilis√©s dans toutes les combinaisons possibles, il est donc difficile de garder √† l'esprit tout ce qui peut arriver avec le d√©sir. Certaines de ces options fonctionnent de mani√®re totalement incompr√©hensible. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/us/wh/aguswhpfaos0qjqvfopo_rr8aeo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, les param√®tres </font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repr√©sentent deux options d'application possibles, mais le fait que la poursuite soit lanc√©e de mani√®re synchrone ou asynchrone d√©pend de tant de choses que vous ignorez. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jm/-c/zv/jm-czv9x4lhhmibfgxqxwjcvxqe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre exemple: nous avons lanc√© la t√¢che, lanc√© la continuation et donn√© simultan√©ment deux param√®tres</font></font><code>TaskContinuations.ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, apr√®s quoi ils ont commenc√© la suite de mani√®re asynchrone. </font><font style="vertical-align: inherit;">Sera-t-il ex√©cut√© dans la m√™me pile o√π la t√¢che pr√©c√©dente se termine, ou sera-t-il transf√©r√© </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Dans ce cas, il y aura une troisi√®me option: cela d√©pend.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/j6/8z/vvj68zu1keb_n50viyk4iqbydae.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCompletionSource</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consid√©rez </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lorsque vous cr√©ez une t√¢che, vous d√©finissez son r√©sultat </font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour adapter les mod√®les asynchrones pr√©c√©dents au monde de la t√¢che. Vous </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pouvez demander </font></font><code>tcs.Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et cette t√¢che entrera dans un √©tat </font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque vous appelez </font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cependant, si vous ex√©cutez cela sur le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pool de threads</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vous obtiendrez un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blocage</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La question est, pourquoi si nous n‚Äô√©crivions rien, m√™me de mani√®re synchrone? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v5/g1/2b/v5g12bn0tycbshdrascqvi-hkug.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous cr√©ons </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, commen√ßons une nouvelle t√¢che et nous avons un deuxi√®me thread qui d√©marre quelque chose dans cette t√¢che. Il va plus loin et tombe dans l'attente pour une centaine de millisecondes. Ensuite, notre fil principal - vert - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attend</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et c'est tout. Il lib√®re la pile, la pile se bloque, attendant d'√™tre appel√©e dans une suite sur</font></font><code>task.Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsqu'il est </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expos√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le fil bleu, nous arrivons √† </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis le plus int√©ressant. </font><font style="vertical-align: inherit;">Sur la base de consid√©rations internes √† .NET, il </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pense que la poursuite de cela </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut √™tre effectu√©e de mani√®re synchrone, c'est-√†-dire directement sur la m√™me pile, puis cela </font></font><code>task.Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est effectu√© de mani√®re synchrone sur la m√™me pile. </font><font style="vertical-align: inherit;">C'est tr√®s √©trange, malgr√© le fait que nous n'avons m√™me √©crit nulle part </font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">C'est probablement le probl√®me avec le m√©lange de code synchrone et asynchrone. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uv/7z/go/uv7zgosoif24okbeyq7fffwdz8o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre probl√®me avec cela </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est que lorsque nous appelons </font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sous le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verrou</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vous ne pouvez pas appeler de code arbitraire, car sous le verrou, vous ne pouvez faire qu'une petite activit√© granulaire. </font><font style="vertical-align: inherit;">Courez sous certaines </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actions</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il est impossible de venir d'o√π ils viennent. </font><font style="vertical-align: inherit;">Comment r√©soudre ce probl√®me?</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span>  tcs  =  <span class="hljs-keyword">new</span>   TaskCompletionSource&lt;<span class="hljs-keyword">int</span>&gt;(<font></font>
       TaskContinuationsOptions.RunContinuationsAsynchronously  <font></font>
) ;<font></font>
<span class="hljs-keyword">lock</span>(mylock)<font></font>
{  <font></font>
    tcs.SetResult(O); <font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vaut la peine d'√™tre </font><font style="vertical-align: inherit;">utilis√© </font><font style="vertical-align: inherit;">uniquement pour l'adaptation du </font><font style="vertical-align: inherit;">code </font><font style="vertical-align: inherit;">non </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans les biblioth√®ques. </font><font style="vertical-align: inherit;">Presque tout le reste peut √™tre r√©solu en attendant. </font><font style="vertical-align: inherit;">Dans ce cas, il est toujours fortement recommand√© de prescrire le param√®tre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"TaskCompletionSource.RunContinuationsAsynchronously"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vous devez presque toujours ex√©cuter une continuation de mani√®re asynchrone. </font><font style="vertical-align: inherit;">Dans ce cas, vous </font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avez quelque chose sous lequel rien ne sera lanc√©. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ap/_-/ab/ap_-abu8wjhwxr0edsvayrcc-6w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi la poursuite doit-elle √™tre effectu√©e de mani√®re synchrone? </font><font style="vertical-align: inherit;">Parce qu'il </font></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fait r√©f√©rence aux √©l√©ments suivants </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et non aux n√¥tres. </font><font style="vertical-align: inherit;">Pour √©tablir un lien avec le n√¥tre, vous devez √©crire ce qui suit: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/zj/6q/qbzj6q1fjhhqozii8yec5ok3pcy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet exemple montre comment les param√®tres ne sont pas intuitifs, comment ils se croisent les uns avec les autres, comment ils introduisent une complexit√© cognitive - c'est si difficile √† √©crire.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hi√©rarchie parent-enfant</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   })<font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// don‚Äôt wait for child</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe d'autres options d'utilisation des param√®tres. Par exemple, une </font><font style="vertical-align: inherit;">hi√©rarchie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parent-enfant</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> appara√Æt </font><font style="vertical-align: inherit;">lorsque vous lancez une t√¢che et en ex√©cutez une autre sous celle-ci. Dans ce cas, si vous √©crivez </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'attendrez pas la t√¢che lanc√©e √† l'int√©rieur. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gw/se/28/gwse28nxykd4vfwt_chfw0qjt_w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous √©crivez </font></font><code>TaskCreationOptions.AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cela </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attendra. Vous pouvez utiliser cette propri√©t√© dans vos produits. Je pense que tout le monde peut trouver un exemple dans lequel il y a une hi√©rarchie de t√¢ches, la t√¢che attendant la sous-t√¢che et la sous-t√¢che pour ses sous-t√¢ches. Pas besoin d'√©crire n'importe o√π </font></font><code>WaitForChildren</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cette attente se produit de mani√®re asynchrone. En d'autres termes, le corps de la t√¢che parent se termine et, apr√®s cela, la t√¢che parent n'est pas consid√©r√©e comme termin√©e, ne d√©marre pas ses continuations tant que les t√¢ches enfants ne fonctionnent pas.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// still wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... parent task to attach is in ThreadStatic</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il peut y avoir un probl√®me dans lequel la t√¢che est transf√©r√©e quelque part </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis tout ce que vous avez commenc√© </font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sera ajout√© √† cette t√¢che parent, qui est une alarme.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo();<font></font>
}, TaskCreationOptions.DenyChildAttach)<font></font>
.ContinueWith(...) <span class="hljs-comment">// don‚Äôt wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'un autre c√¥t√©, il existe une option qui annule l'option pr√©c√©dente </font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Une telle application se produit assez souvent.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Run(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">//don‚Äôt wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
    }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient de rappeler que </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c'est la fa√ßon standard de d√©marrer, ce qui implique par d√©faut </font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le contexte implicite que vous mettez vous </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajoute de la complexit√©. Vous ne comprenez pas comment fonctionne la t√¢che, car vous devez conna√Ætre le contexte. Un autre probl√®me qui peut survenir est li√© √† l'√©tat inactif de async / wait. C'est parce que dans </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / attendent,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous n'avez pas de t√¢ches, mais des actions. La poursuite n'est pas une t√¢che honn√™te, mais une action. Lorsque vous √©crivez du code asynchrone / attendent, vous n'avez pas besoin de l'utiliser </font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car vous liez explicitement les t√¢ches √† attendre, et c'est la bonne approche. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/k7/q5/vg/k7q5vgi8h9qwvvo3akgzow8vu_q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous avez six options pour d√©marrer une continuation. Vous avez lanc√© la t√¢che, lanc√©</font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Question: Quel statut aura cette continuation? </font><font style="vertical-align: inherit;">Il y a cinq r√©ponses possibles:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la poursuite g√©n√©rale se terminera avec succ√®s; RunToCompletion se produira;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la t√¢che sera erron√©e;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'annulation aura lieu;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la t√¢che n'atteindra pas son terme du tout, elle sera dans une sorte de vide;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">option - "d√©pend".</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/5u/x5/1k/5ux51kwpr4aixg_2io3xroerxam.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, la t√¢che sera dans l'√©tat ¬´annul√©¬ª, bien que nulle part le mot ¬´annul√©¬ª ne soit mentionn√©. </font><font style="vertical-align: inherit;">Ici, nous jetons la r√©ception et ne faisons rien. </font><font style="vertical-align: inherit;">Le probl√®me est que lorsque vous lisez le code de quelqu'un d'autre avec beaucoup d'options - m√™me si vous connaissiez ces options il y a 10 minutes - vous oubliez toujours ce qui se passe ici. </font><font style="vertical-align: inherit;">Alors n'√©crivez pas.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annulation</font></font></h3><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(); <font></font>
});<font></font>
<font></font>
                                                      Failed</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le troisi√®me param√®tre au d√©but de la t√¢che est la kancellation. </font><font style="vertical-align: inherit;">Vous √©crivez </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, c'est-√†-dire une action sp√©ciale qui met la t√¢che √† l'√©tat ¬´Annul√©¬ª. </font><font style="vertical-align: inherit;">Dans ce cas, la t√¢che sera dans l'√©tat "√âchec", car tous ne </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont pas √©gaux.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(cancellationToken); <font></font>
}, cancellationToken);<font></font>
<font></font>
                                                      Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour que la t√¢che soit en mesure de le faire </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous devez la jeter </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec son CancellationToken. </font><font style="vertical-align: inherit;">En r√©alit√©, vous ne faites jamais explicitement cela, mais faites-le de cette fa√ßon:</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    cancellationToken.ThrowIfCancellationRequested(); <font></font>
}, cancellationToken);<font></font>
                                                       Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Est-il n√©cessaire de distinguer CancellationToken? </font><font style="vertical-align: inherit;">Quelque part √† l'int√©rieur de la t√¢che, vous v√©rifiez que quelqu'un vous a supprim√©: annulation du lancer, puis la t√¢che passe √† l'√©tat </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ou quelqu'un a cliqu√© sur ¬´Annuler¬ª au moment de l'ex√©cution et a annul√© la t√¢che. </font><font style="vertical-align: inherit;">Notre pratique chez JetBrains sugg√®re que vous n'avez pas besoin de faire la distinction entre ces jetons. </font><font style="vertical-align: inherit;">Si vous obtenez une </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OperationCanceledException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - un type sp√©cial qui se produit lorsqu'une annulation s'est produite, vous pouvez la distinguer. </font><font style="vertical-align: inherit;">Dans ce cas, il vous suffit de terminer la t√¢che normalement, de ne pas vous connecter et lorsque vous recevez l'ex√©cution - connectez-vous.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pile profonde</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    Foo();<font></font>
}, cancellationToken);<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
     Bar() {<font></font>
       ...<font></font>
          Baz() {<font></font>
             <span class="hljs-comment">//how to get cancellation token?</span><font></font>
          } <font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Disons que vous avez une pile profonde. C'est </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le seul param√®tre explicite dont nous avons discut√©. Elle doit √™tre transmise partout dans absolument toutes les hi√©rarchies. Que dois-je faire si, en pr√©sence d'une hi√©rarchie profonde, vous devez annuler votre t√¢che quelque part, au niveau le plus bas, pour rejeter la r√©ception? Il y a une astuce si sp√©ciale que nous utilisons. Il est appel√© </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">static</span> AsyncLocal&lt;Cancelation&gt; asyncLocalCancellation;<font></font>
<font></font>
Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
     asyncLocalCancellation.Set(cancellationToken) <font></font>
    Foo();<font></font>
}, cancellationToken); <span class="hljs-comment">// use AsyncLocal to put cancellation int</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { 
     <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span> {<font></font>
      ...<font></font>
         Baz() {<font></font>
             asyncLocalCancellation.Value.CheckForInterrupt(); <font></font>
         }<font></font>
   } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est la m√™me chose que, </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seul celui sp√©cial </font></font><code>ThreadLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui survit aux trajets de code asynchrone / attente. </font><font style="vertical-align: inherit;">√âtant donn√© que votre code est asynchrone et que vous avez cette annulation, vous l'avez ins√©r√©e </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et quelque part √† un niveau profond, vous pouvez dire " </font></font><code>CheckForInterrupt Throw If Cancellation Requested</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". </font><font style="vertical-align: inherit;">Encore une fois, c'est le seul param√®tre </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui doit compl√®tement enduire le code entier, mais, √† mon avis, pour la plupart des t√¢ches, vous avez juste besoin de savoir ce qui s'est pass√© </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et de cela en tirer une conclusion qui indique: Annul√© ou √âchou√©.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complexit√© cognitive</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
    TaskCreationOptions, <font></font>
    TaskScheduler, <font></font>
    CancellationToken<font></font>
)<font></font>
                                                   JetBrains.Lifetimes<font></font>
<font></font>
lifetime.Start(TaskScheduler, Action) <span class="hljs-comment">//puts lifetime in AsyncLocal</span><font></font>
<font></font>
lifetime.StartMainRead(Action) <font></font>
lifetime.StartMainWrite(TaskScheduler, Action) <font></font>
lifetime.StartBackgroundRead(TaskScheduler, Action)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus le code est difficile √† lire lors du d√©marrage de la t√¢che, plus le risque d'erreur est √©lev√©. En regardant le code apr√®s un an, vous oublierez ce qu'il fait, car il y a un grand nombre de param√®tres. Mais nous avons la biblioth√®que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JetBrains.Lifetimes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui offre des dur√©es de vie modernes, un CancellationToken bien optimis√©, avec lequel la m√©thode Start a √©t√© r√©√©crite et le probl√®me avec la r√©p√©tition de morceaux de code a √©t√© r√©solu, comme avec </font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe un petit nombre de planificateurs qui vous permettent de planifier une t√¢che sur le thread principal avec un verrou en lecture. Autrement dit, le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verrou de lecture</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n'est pas quelque chose que vous choisissez explicitement, c'est un planificateur sp√©cial qui planifie votre code sur le thread principal avec un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verrou de lecture</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ainsi que le thread principal avec verrouillage en √©criture, le thread d'arri√®re-plan - et maintenant les m√©thodes deviennent tr√®s simples pour d√©marrer la lecture al√©atoire. Dans le m√™me temps, les dur√©es de vie s'annulent automatiquement </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui simplifie consid√©rablement le code. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_h/1n/gu/_h1ngucdl-vvbpyyalkk_gwvapu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / wait</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> r√©sout ces probl√®mes et quels probl√®mes ils introduisent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet exemple, une partie du code est ex√©cut√©e de mani√®re synchrone, puis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attend</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et code asynchrone. Premi√®rement, il est bon qu‚Äôil y ait beaucoup moins de morceaux de code r√©p√©titifs ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plaque de chaudi√®re</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Deuxi√®mement, il est bon que le code asynchrone soit tr√®s similaire au code synchrone, c'est exactement √† cela que sert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / attente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Vous pouvez √©crire de mani√®re asynchrone de la m√™me mani√®re que vous avez √©crit de mani√®re synchrone, sans prendre de threads.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, que d√©ploiera le compilateur? Le code synchrone s'ex√©cutera de mani√®re synchrone, apr√®s quoi la t√¢che s'ex√©cutera de mani√®re synchrone </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, d'o√π vient l'objet GetAwaiter sp√©cial. Dans ce cas, nous sommes int√©ress√©s </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Vous pouvez √©crire votre serveur pour absolument n'importe quel objet. Par cons√©quent, nous attendons que la t√¢che soit termin√©e </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font><font style="vertical-align: inherit;">ex√©cut√©e de mani√®re </font><font style="vertical-align: inherit;">synchrone </font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si la t√¢che ne s'est pas termin√©e, alors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuationCode</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est planifi√© sur le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planificateur de contexte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il se peut que, m√™me si vous avez √©crit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attendre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , absolument tout sera appel√© de mani√®re synchrone.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
   <span class="hljs-keyword">await</span> InnerAsync();
   <span class="hljs-keyword">await</span> Task.Yield(); <span class="hljs-comment">//guaranteed !IsCompleted </span><font></font>
   continuationCode();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a une astuce </font></font><code>Task.Yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- c'est une t√¢che sp√©ciale qui garantit que son serveur ne vous reviendra pas toujours </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Par cons√©quent, </font></font><code>continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il ne sera pas appel√© de mani√®re synchrone √† cet endroit. Pour un thread d'interface utilisateur, cela peut √™tre important car vous ne prenez pas ce thread pendant une longue p√©riode. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jg/jy/7d/jgjy7dh0cnbslfcyk4jpyapc9du.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment choisir un fil pour la suite? La philosophie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asynchrone / attendre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est la </font><font style="vertical-align: inherit;">suivante: vous √©crivez du code asynchrone de la m√™me mani√®re que synchrone. Si vous avez un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pool de threads</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">cela </font><font style="vertical-align: inherit;">ne </font><font style="vertical-align: inherit;">fait </font><font style="vertical-align: inherit;">aucune diff√©rence pour vous - continuationCode sera ex√©cut√© sur un autre thread. Ind√©pendamment du fait qu'elle ait √©t√© </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">termin√©e lorsque vous avez dit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attendre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou non, vous avez besoin de tout pour ex√©cuter sur le thread d'interface utilisateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le m√©canisme de t√¢che en attente est le suivant: il est pris </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il est appel√©</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et √† partir de l√† est cr√©√© </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SynchronizationContext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une chose avec la m√©thode Post, qui est tr√®s similaire √† la m√©thode </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En fait </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui √©tait plus t√¥t, il prend simplement </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et √† travers Post effectue sa t√¢che.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
    continuationCode(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe un moyen de modifier ce comportement √† l'aide d'un param√®tre </font></font><code>ContinueOnCapturedContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">L'API la plus d√©go√ªtante de .NET est appel√©e </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans ce cas, l'API cr√©e un serveur d'attente sp√©cial, diff√©rent de </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">celui qui d√©cale la suite, il s'ex√©cute sur le m√™me thread, dans le m√™me contexte dans lequel la m√©thode s'est termin√©e </font></font><code>InnerAsync </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et o√π la t√¢che s'est termin√©e.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//code must be absolutely context-agnostic</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a une quantit√© insens√©e de conseils sur Internet: si vous avez un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blocage</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , veuillez salir tout votre code ConfigureAwait et tout ira bien. </font><font style="vertical-align: inherit;">C'est la mauvaise fa√ßon. </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut √™tre utilis√© dans les cas o√π vous souhaitez am√©liorer l√©g√®rement les performances, ou √† la fin de la m√©thode, dans certaines m√©thodes de biblioth√®que.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deadlocks</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode();<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit d'une </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impasse</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> classique </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sur le thread d'interface utilisateur, ils ont attendu dix secondes et l'ont fait </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En raison de ce que vous avez fait </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il </font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne sera jamais lanc√©, il </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne reviendra donc jamais. </font><font style="vertical-align: inherit;">Tout cela a lieu au tout d√©but.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">OnBluttionClick</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span>
  <span class="hljs-keyword">int</span> v = Button.Text.ParseInt();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
  Button.Text.Set((v+<span class="hljs-number">1</span>).ToString());<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imaginez qu'il s'agit d'une v√©ritable activit√©. Nous avons cliqu√© sur le bouton, l'avons pris </font></font><code>Button.ParseInt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, fait </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attendre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , √©crit </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons dit: "Veuillez ne pas fermer notre flux d'interface utilisateur, effectuez la suite." Le probl√®me est que nous voulons que la deuxi√®me partie apr√®s soit </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©galement ex√©cut√©e sur le thread d'interface utilisateur, car c'est la philosophie de l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Autrement dit, votre code asynchrone ressemble au code synchrone et s'ex√©cute dans le m√™me contexte. Dans ce cas, bien s√ªr, il y aura une erreur. De plus, </font></font><code>Button.Text.Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il peut y avoir un certain nombre d'appels de m√©thode qui prennent √©galement en compte leur contexte. que-faire dans cette situation? Tu peux le faire:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//The same UI context</span><font></font>
}<font></font>
PumpUntil(() =&gt; task.IsCompleted);<font></font>
<span class="hljs-comment">//VS synchronization contexts always pump on any Wait</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec un thread d'interface utilisateur, vous devez interdire de le faire </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur les threads qui ont une file d'attente de messages commune. Au lieu de faire </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou d'√©crire </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous pouvez pomper cette file d'attente de messages, et en m√™me temps, le continuum sera √©galement pomp√©. Si vous ne pouvez pas m√©langer du code synchrone et asynchrone, vous ne devez pas les m√©langer. Mais parfois, cela ne peut √™tre √©vit√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, vous avez un ancien code, et vous devez les m√©langer, puis vous pompez le flux d'interface utilisateur. Visual Studio pompe le fil de l'interface utilisateur sur les attentes, il a m√™me </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un peu chang√©. Si vous acc√©dez √† WaitHandle sur l'un d'eux </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lorsque vous raccrochez, votre flux d'interface utilisateur est pomp√©. Ainsi, ils choisissent entre les </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blocages</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et les races en faveur de la race s. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pumpuntil</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Il s'agit d'une API non id√©ale, c'est-√†-dire que lorsque vous effectuez une continuit√© al√©atoire dans un endroit arbitraire, il peut y avoir des nuances. </font><font style="vertical-align: inherit;">Il n'y a malheureusement pas d'autre moyen. </font><font style="vertical-align: inherit;">M√©langez les codes synchrones et asynchrones. </font><font style="vertical-align: inherit;">Si quoi que ce soit, l'ensemble du Rider est ainsi arrang√© dans les anciens endroits, donc parfois il y a aussi des nuances.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changer le contexte</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> myTaskScheduler;<font></font>
    continuationCode(); <span class="hljs-comment">//on scheduler context </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe une autre fa√ßon int√©ressante d'utiliser </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / wait</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vous pouvez √©crire </font></font><code>Awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et sauter sur les </font><font style="vertical-align: inherit;">filets. </font><font style="vertical-align: inherit;">J'ai lu des articles dans Visual Studio, ils ont √©crit pendant tr√®s longtemps qu'il n'√©tait pas bon de faire des allers-retours au milieu de la m√©thode, mais maintenant ils le font eux-m√™mes. </font><font style="vertical-align: inherit;">Visual Studio poss√®de une API qui saute sur les threads via les planificateurs. </font><font style="vertical-align: inherit;">Pour une utilisation normale, ce n'est pas bon.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concurrence structur√©e</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Factory.StartNew(() =&gt; {...}, myTaskScheduler);<font></font>
    continuationCode(); <span class="hljs-comment">//on initial context </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour une immersion pratique dans le nouveau contexte et un retour √† l'ancien, une certaine concurrence structurelle, ou parall√©lisme structurel, devrait √™tre √©tablie. </font><font style="vertical-align: inherit;">Par exemple, dans les ann√©es 60, l'op√©rateur GoTo √©tait consid√©r√© comme nuisible car il violait la structure. </font><font style="vertical-align: inherit;">C'est donc ici. </font><font style="vertical-align: inherit;">Sauter sur les fils viole la structure. </font><font style="vertical-align: inherit;">√âtonnamment, l'utilisation d'une machine d'√©tat asynchrone semble √™tre une bonne solution. </font><font style="vertical-align: inherit;">Autrement dit, lorsque votre structure habituelle est viol√©e, vous sautez sur GoTo, vous pouvez violer la structure des threads: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attendez</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">m√©langez </font><font style="vertical-align: inherit;">-la avec des balises. </font><font style="vertical-align: inherit;">Il s'agit d'une situation extr√™mement √©trange et rare lorsque vous devez le faire. </font><font style="vertical-align: inherit;">Pourtant, c'est mieux quand </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attendre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> revient dans le m√™me contexte. </font><font style="vertical-align: inherit;">Ainsi, le pool de threads n'aura pas le m√™me thread, mais le m√™me contexte qu'il √©tait √† l'origine.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comportement s√©quentiel</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attendre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n'est-il pas la m√™me chose que l'ex√©cution parall√®le? </font><font style="vertical-align: inherit;">Attendre l'ex√©cution est une ex√©cution s√©quentielle. </font><font style="vertical-align: inherit;">Dans ce cas, nous commen√ßons la premi√®re t√¢che, l'attendons, d√©marrons la deuxi√®me t√¢che - nous attendons. </font><font style="vertical-align: inherit;">Nous n'avons aucun parall√©lisme. </font><font style="vertical-align: inherit;">Pour la plupart des utilisations, le parall√©lisme n'est pas n√©cessaire. </font><font style="vertical-align: inherit;">Le parall√©lisme lui-m√™me est plus complexe que la s√©quence. </font><font style="vertical-align: inherit;">Le code s√©rie est plus simple que parall√®le, c'est un axiome. </font><font style="vertical-align: inherit;">Mais parfois, vous devez ex√©cuter quelque chose en code parall√®le, et vous le faites comme ceci:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">await</span> task1;<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comportement simultan√©</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();<font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, les t√¢ches commencent en parall√®le. </font><font style="vertical-align: inherit;">Il est clair que les m√©thodes peuvent renvoyer la t√¢che imm√©diatement dans un √©tat en cours d'ex√©cution, il n'y aura donc pas de parall√©lisme. </font><font style="vertical-align: inherit;">Disons que les deux lancent une ex√©cution. </font><font style="vertical-align: inherit;">Et vous avez attendu la premi√®re t√¢che, puis la premi√®re attente a d√©coll√©. </font><font style="vertical-align: inherit;">Autrement dit, d√®s que vous avez √©crit </font></font><code>await task1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous avez d√©coll√© et n'avez pas trait√© </font></font><code>exception task2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fait int√©ressant, il s'agit d'un code absolument valide. </font><font style="vertical-align: inherit;">Et c'est ce code qui a conduit .NET au fait que dans la version 4.5, le comportement de travail avec les ex√©cutions a chang√©.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gestion des exceptions</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async(); <font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2;<font></font>
<font></font>
  <span class="hljs-comment">// if task1 throws exception and task2 throws exception we only throw and</span>
  <span class="hljs-comment">// handle task1‚Äôs exception</span><font></font>
<font></font>
  <span class="hljs-comment">//4.0 -&gt; 4.5 framework: unhandled exceptions now don‚Äôt crush process</span>
  <span class="hljs-comment">//still visible in UnobservedExceptionHandler</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auparavant, les ex√©cutions non g√©r√©es jetaient simplement le processus, et si vous n‚Äôavez pas d√©tect√© d‚Äôex√©cution </font></font><code>UnobservedExceptionHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous pouvez √©galement en attacher </font><font style="vertical-align: inherit;">certaines </font><font style="vertical-align: inherit;">√† des planificateurs), ce processus n‚Äôa pas √©t√© ex√©cut√©. Maintenant, c'est un code absolument valide. Bien que .NET ait modifi√© son comportement, il a conserv√© le param√®tre pour renvoyer le comportement dans la direction oppos√©e.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span>  Task  <span class="hljs-title">MyAsync</span>(<span class="hljs-params">CancellationToken cancellationToken</span>)</span>  {  <font></font>
<font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">SomeTask1  <span class="hljs-title">Async</span>(<span class="hljs-params">cancellationToken</span>)</span>; <font></font>
 <font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">Some <span class="hljs-title">Task2Async</span>(<span class="hljs-params"> cancellation  Token</span>)</span>; 
  <span class="hljs-comment">//you should always pass use async API with cancelationToken  if possible </span><font></font>
} <font></font>
  <font></font>
<span class="hljs-keyword">try</span> { 
    <span class="hljs-keyword">await</span>  MyAsync( cancellation  Token); <font></font>
} <span class="hljs-keyword">catch</span> (OperationException e) { <span class="hljs-comment">// do nothing: OCE happened</span>
} <span class="hljs-keyword">catch</span> (Exception e) { <font></font>
    log.Error(e);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyez comment se d√©roule le traitement de l'ex√©cution. </font><font style="vertical-align: inherit;">Les CancellationToken-s doivent √™tre transmis, il faut "enduire" CancellationToken-s de tout le code. </font><font style="vertical-align: inherit;">Le comportement normal d'Async est que vous ne v√©rifiez nulle part </font></font><code>Task.Status ancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous travaillez avec du code asynchrone de la m√™me mani√®re qu'avec Synchrone. </font><font style="vertical-align: inherit;">Autrement dit, dans le cas d'une annulation, vous obtenez une ex√©cution, et dans ce cas, vous ne faites rien lorsque vous la recevez </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diff√©rence entre le statut Annul√© et En panne est que vous n'avez pas re√ßu </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais l'ex√©cution habituelle. </font><font style="vertical-align: inherit;">Et dans ce cas, nous pouvons le promettre, il vous suffit d'obtenir une ex√©cution et de tirer des conclusions sur cette base. </font><font style="vertical-align: inherit;">Si vous aviez d√©marr√© la t√¢che explicitement, via Task, vous auriez vol√© </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Et en async, dans le cas o√π ils </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lancent toujours la toute premi√®re ex√©cution qui s'y trouvait (dans ce cas - </font></font><code>OperationCanceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En pratique</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©thode synchrone</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SynchronousWorker</span>(<span class="hljs-params">...</span>)</span> {<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, un d√©mon fonctionne dans ReSharper - un √©diteur qui teinte le fichier pour vous. </font><font style="vertical-align: inherit;">Si le fichier est ouvert dans l'√©diteur, une activit√© le place dans une file d'attente de blocage. </font><font style="vertical-align: inherit;">Notre processus </font></font><code>worker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lit √† partir de l√†, apr√®s quoi il effectue un tas de t√¢ches diff√©rentes avec ce fichier, le teint, analyse, construit, apr√®s quoi ces fichiers sont ajout√©s </font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Avec un </font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verrou, d'autres m√©canismes fonctionnent d√©j√† avec lui.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©thode asynchrone</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la r√©√©criture du code en asynchrone, nous le remplacerons tout d'abord </font></font><code>void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par </font></font><code>async Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Assurez-vous d'√©crire le mot ¬´Async¬ª √† la fin. </font><font style="vertical-align: inherit;">Toutes les m√©thodes asynchrones doivent se terminer par Async - c'est une convention.</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
<font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s cela, vous devez faire quelque chose avec le n√¥tre </font></font><code>blockingQueue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. De toute √©vidence, s'il existe une primitive synchrone, il doit y avoir une primitive asynchrone. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-6/zk/8i/-6zk8ilnmdsonzd6zkafkcloqyi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette primitive est appel√©e canal: les canaux qui vivent dans le package </font></font><code>System.Threading.Channels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Vous pouvez cr√©er des canaux et des files d'attente, limit√©s et illimit√©s, que vous pouvez attendre de mani√®re asynchrone. De plus, vous pouvez cr√©er un canal avec une valeur "z√©ro", c'est-√†-dire qu'il n'aura pas du tout de tampon. Ces canaux sont appel√©s canaux de rendez-vous et sont activement promus √† Go et Kotlin. Et en principe, s'il est possible d'utiliser des canaux en code asynchrone, c'est un tr√®s bon sch√©ma. Autrement dit, nous changeons la file d'attente pour le canal o√π il existe des m√©thodes </font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>WriteAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessInParallel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un tas de code parall√®le qui fait le traitement d'un fichier et le transforme en</font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">L'async peut-il nous aider √† √©crire un code non asynchrone, mais parall√®le plus compact?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplifiez le code parall√®le</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code peut √™tre r√©√©crit de cette fa√ßon:</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e0/zt/8u/e0zt8ud_8b4_wsiqsrd9_baalwy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä quoi ressemblent-ils </font></font><code>ProcessInParallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Par exemple, nous avons un fichier. Tout d'abord, nous le d√©composons en lex√®mes, et nous pouvons avoir deux t√¢ches en parall√®le: construire des caches de recherche et construire un arbre de syntaxe. Apr√®s cela vient la t√¢che de ¬´rechercher les erreurs s√©mantiques¬ª. Il est important ici que toutes ces t√¢ches forment un graphe acyclique dirig√©. Autrement dit, vous pouvez ex√©cuter certaines parties dans des threads parall√®les, d'autres non, et il existe √©videmment des d√©pendances qui doivent attendre d'autres t√¢ches. Vous obtenez un graphique de ces t√¢ches, vous voulez en quelque sorte les disperser le long des fils. Est-il possible de l'√©crire magnifiquement, sans erreurs? Dans notre code, ce probl√®me a √©t√© r√©solu plusieurs fois, √† chaque fois d'une mani√®re diff√©rente. Cela se produit rarement lorsque ce code est √©crit sans erreur.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xh/-h/3j/xh-h3jav69twzsqei3rrjbe2ymy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous d√©finissons ce graphique de t√¢ches comme suit: disons que chaque t√¢che a d'autres t√¢ches dont elle d√©pend, puis en utilisant le dictionnaire ExecuteBefore nous √©crivons le squelette de notre m√©thode.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solutions squelettes</font></font></h3> <br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore; <span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();<font></font>
<font></font>
<font></font>
  <span class="hljs-comment">// lots of work with toposort, locks, etc.</span><font></font>
<font></font>
  <span class="hljs-keyword">return</span> res; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous r√©solvez ce probl√®me de front, vous devez effectuer un tri topologique de ce graphique. </font><font style="vertical-align: inherit;">Prenez ensuite une t√¢che qui n'a pas de t√¢ches d√©pendantes, ex√©cutez-la, analysez la structure sous un verrou, voyez quelles t√¢ches n'en ont pas. </font><font style="vertical-align: inherit;">Courez, dispersez-les d'une mani√®re ou d'une autre </font></font><code>Task Runner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous l'√©crivons un peu plus compact: tri topologique du graphe + ex√©cution de telles t√¢ches sur diff√©rents threads.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async paresseux</font></font></h3><br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore;
<span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();
  <span class="hljs-keyword">var</span> lazy = <span class="hljs-keyword">new</span> Dictionary&lt;Action&lt;ProcessedFile&gt;, Lazy&lt;Task&gt;&gt;(); 
  <span class="hljs-keyword">foreach</span> ((action, beforeList) <span class="hljs-keyword">in</span> ExecuteBefore)<font></font>
    lazy[action] = <span class="hljs-keyword">new</span> Lazy&lt;Task&gt;(<span class="hljs-keyword">async</span> () =&gt; <font></font>
    {<font></font>
      <span class="hljs-keyword">await</span> Task.WhenAll(beforeList.Select(b =&gt; lazy[b].Value)) 
      <span class="hljs-keyword">await</span> Task.Yield();<font></font>
      action(res);<font></font>
}<font></font>
  <span class="hljs-keyword">await</span> Task.WhenAll(lazy.Values.Select(l =&gt; l.Value)) 
  <span class="hljs-keyword">return</span> res;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un mod√®le appel√© </font></font><code>Async Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nous cr√©ons les n√¥tres </font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur lesquelles diff√©rentes actions doivent √™tre ex√©cut√©es. Cr√©ons un dictionnaire: nous allons formater chacune de nos √©tapes (Action ProcessedFile) dans une t√¢che, ou plut√¥t dans Lazy from Task et parcourir le graphique d'origine. La variable </font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aura l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">action</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elle </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">m√™me </font><font style="vertical-align: inherit;">, et dans beforeList - les actions qui doivent √™tre effectu√©es avant la n√¥tre. Cr√©ez ensuite √† </font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partir de </font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nous √©crivons dans Task </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ainsi, nous attendons toutes les t√¢ches qui doivent √™tre accomplies avant lui. Dans beforeList, s√©lectionnez celui </font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui se trouve dans ce dictionnaire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez noter qu'ici, rien ne sera ex√©cut√© de mani√®re synchrone, donc ce code ne tombera pas </font></font><code>ItemNotFoundException in Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nous r√©alisons toutes les t√¢ches qui √©taient avant les n√¥tres, effectuant une recherche par action</font></font><code>Lazy Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ensuite, nous ex√©cutons notre action. </font><font style="vertical-align: inherit;">En fin de compte, il vous suffit de demander √† chaque t√¢che de d√©marrer, sinon vous ne savez jamais si quelque chose n'a pas commenc√©. </font><font style="vertical-align: inherit;">Dans ce cas, rien n'a commenc√©. </font><font style="vertical-align: inherit;">Voil√† la solution. </font><font style="vertical-align: inherit;">Cette m√©thode est √©crite en 10 minutes, c'est absolument √©vident. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, le code asynchrone a pris notre d√©cision, il occupait initialement quelques √©crans avec un code concurrentiel complexe. </font><font style="vertical-align: inherit;">Ici, il est absolument coh√©rent. </font><font style="vertical-align: inherit;">Je ne l'utilise m√™me pas </font></font><code>ConcurrentDictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, j'utilise l'habituel </font></font><code>Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car nous n'y √©crivons rien de mani√®re comp√©titive. </font><font style="vertical-align: inherit;">Il existe un code coh√©rent et coh√©rent. </font><font style="vertical-align: inherit;">Nous r√©solvons </font><font style="vertical-align: inherit;">magnifiquement </font><font style="vertical-align: inherit;">le probl√®me de l'√©criture de code parall√®le en utilisant </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async-s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui signifie - sans bugs.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©barrassez-vous des verrous</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
    <span class="hljs-keyword">lock</span> (_lock) {<font></font>
      sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
   }<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vaut-il la peine de retirer async et ces verrous? Il existe maintenant toutes sortes de verrous asynchrones, des s√©maphores asynchrones, c'est-√†-dire une tentative d'utilisation des primitives qui sont en code synchrone et asynchrone. Ce concept semble √™tre faux, car avec le verrou, vous prot√©gez quelque chose contre l'ex√©cution parall√®le. Notre t√¢che est de traduire l'ex√©cution parall√®le en s√©quentielle, car c'est plus facile. Et si c'est plus facile, il y a moins d'erreurs.</font></font><br>
<br>
<pre><code class="cs hljs">Channel&lt;Pair&lt;File, ProcessedFile&gt;&gt; output;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
  <font></font>
  <span class="hljs-keyword">await</span> output.WriteAsync(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons cr√©er un canal et y mettre quelques fichiers et fichiers trait√©s, et </font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une autre proc√©dure </font><font style="vertical-align: inherit;">traitera ce canal </font><font style="vertical-align: inherit;">et le fera s√©quentiellement. Le verrou lui-m√™me, en plus de prot√©ger la structure, lin√©arise essentiellement l'acc√®s, un endroit o√π tous les fils de fils cons√©cutifs deviennent parall√®les. Et nous rempla√ßons cela explicitement par le canal. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q_/qe/mf/q_qemfc4mssz9shitqlekzee6nc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'architecture est la suivante: les travailleurs re√ßoivent des fichiers </font></font><code>input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et les envoient quelque part au processeur, qui traite √©galement tout s√©quentiellement, il n'y a pas de parall√©lisme. Le code semble beaucoup plus simple. Je comprends que tout ne peut pas √™tre fait de cette fa√ßon. Une telle architecture, lorsque vous pouvez cr√©er des canaux de donn√©es, ne fonctionne pas toujours.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7k/9j/sv/7k9jsvdwqbqrzgbejoozsk5lj_s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il se peut que vous ayez un deuxi√®me canal qui entre dans votre processeur et qu'un graphique dirig√© acyclique ne soit pas form√© √† partir des canaux, mais un graphique avec des cycles. </font><font style="vertical-align: inherit;">C'est un exemple que Roman Elizarov a d√©clar√© √† KotlinConf en 2018. </font><font style="vertical-align: inherit;">Il a √©crit un exemple sur Kotlin avec ces canaux, et il y avait des cycles l√†-bas, et cet exemple a √©t√© arr√™t√©. </font><font style="vertical-align: inherit;">Le probl√®me √©tait que si vous avez de tels cycles dans un graphique, alors tout devient plus compliqu√© dans le monde asynchrone. </font><font style="vertical-align: inherit;">Les interblocages asynchrones sont mauvais en ce sens qu'ils sont beaucoup plus difficiles √† r√©soudre que les synchrones lorsque vous avez une pile de threads, et il est clair de quoi il s'agit. </font><font style="vertical-align: inherit;">C'est donc un outil qui doit √™tre utilis√© correctement.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sommaire</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âvitez la synchronisation en code asynchrone.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code s√©rie est plus simple que parall√®le.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code asynchrone peut √™tre simple et utiliser un minimum de param√®tres et un contexte implicite qui modifient son comportement.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous avez d√©velopp√© l'habitude d'√©crire du code synchrone, et m√™me si le code asynchrone est tr√®s similaire au code synchrone, n'y faites pas glisser de primitives, ce √† quoi vous √™tes habitu√© en code synchrone </font></font><code>async mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Utilisez des flux, si possible, et d'autres primitives de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passage de message</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code s√©rie est plus simple que parall√®le. Si vous pouvez √©crire votre architecture de fa√ßon √† ce qu'elle apparaisse s√©quentiellement, sans ex√©cuter de code parall√®le ni verrouiller, alors √©crivez l'architecture s√©quentiellement.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et la derni√®re chose que nous avons vue √† partir d'un grand nombre d'exemples de t√¢ches. </font><font style="vertical-align: inherit;">Lorsque vous concevez votre syst√®me, essayez de vous fier moins au contexte implicite. </font><font style="vertical-align: inherit;">Le contexte implicite conduit √† une mauvaise compr√©hension de ce qui se passe dans le code, et vous pouvez oublier les probl√®mes implicites dans un an. </font><font style="vertical-align: inherit;">Et si une autre personne travaille sur ce code et y refait quelque chose, cela peut entra√Æner des difficult√©s que vous connaissiez autrefois, et le nouveau programmeur ne le sait pas √† cause du contexte implicite. </font><font style="vertical-align: inherit;">En cons√©quence, une mauvaise conception est caract√©ris√©e par un grand nombre de param√®tres, leur combinaison et leur contexte implicite.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que lire</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Document TAP</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guidage asynchrone</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dur√©e de vie</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">medium.com/@elizarov/deadlocks-in-non-hierarchical-csp-e5910d137cc</font></font></a></li>
</ul><br>
<blockquote>     -10     .     DotNext   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr491218/index.html">Int√©gration de PVS-Studio dans PlatformIO</a></li>
<li><a href="../fr491224/index.html">Automatisation d'un service de r√©partition, ou comment une entreprise de services peut r√©duire les co√ªts de transport de 30%</a></li>
<li><a href="../fr491230/index.html">Comment je suis all√© √† l'√©cole 21 et la divulgation de secrets</a></li>
<li><a href="../fr491232/index.html">RPA + Machine Learning = automatisation intelligente</a></li>
<li><a href="../fr491234/index.html">Trois astuces pour travailler avec SOLIDWORKS pour la mod√©lisation de pi√®ces pour l'impression 3D</a></li>
<li><a href="../fr491238/index.html">Analyse du code g√©n√©tique II</a></li>
<li><a href="../fr491240/index.html">La route vers les nuages: hier et aujourd'hui Adobe</a></li>
<li><a href="../fr491244/index.html">Ableton n'est pas n√©cessaire: connectez Ableton Push 2 au rack VCV</a></li>
<li><a href="../fr491246/index.html">Conf√©rence DEFCON 27. Votre voiture est ma voiture. Partie 2</a></li>
<li><a href="../fr491250/index.html">Lampes √† LED Gauss Basic</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>