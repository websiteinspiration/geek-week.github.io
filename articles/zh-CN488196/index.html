<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❔ 🎅 💉 Android插图：处理恐惧并为Android Q做准备 👩‍❤️‍👩 🥒 🍙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Android Q是具有API级别29的Android的第十版。新版本的主要思想之一是边缘到边缘的概念，当应用程序从底部到顶部占据整个屏幕时。这意味着状态栏和导航栏必须是透明的。但是，如果它们是透明的，则没有系统UI-它与应用程序的交互式组件重叠。这个问题可以用插图解决。
 
 移动开发人员避免插入...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Android插图：处理恐惧并为Android Q做准备</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/488196/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android Q是具有API级别29的Android的第十版。</font><font style="vertical-align: inherit;">新版本的主要思想之一是边缘到边缘的概念，当应用程序从底部到顶部占据整个屏幕时。</font><font style="vertical-align: inherit;">这意味着状态栏和导航栏必须是透明的。</font><font style="vertical-align: inherit;">但是，如果它们是透明的，则没有系统UI-它与应用程序的交互式组件重叠。</font><font style="vertical-align: inherit;">这个问题可以用插图解决。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
移动开发人员避免插入，会引起恐惧。</font><font style="vertical-align: inherit;">但是在Android Q中，无法避免插入-您必须研究并应用它们。</font><font style="vertical-align: inherit;">实际上，插图没有什么复杂的：它们显示哪些屏幕元素与系统界面相交，并建议如何移动该元素，以免与系统UI冲突。</font><strong><font style="vertical-align: inherit;">康斯坦丁（Konstantin Tskhovrebov）</font></strong><font style="vertical-align: inherit;">将讲解插图如何工作以及如何使用</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/6Djql74drwk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">康斯坦丁</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><strong><font style="vertical-align: inherit;">Konstantin Tskhovrebov）</font></strong><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特拉科克</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redmadrobot中工作</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">从事Android已有10年了，并且在各种项目中积累了很多经验，在这些项目中没有插件，他们总是设法以某种方式解决问题。</font><font style="vertical-align: inherit;">康斯坦丁（Konstantin）将讲述避免插页问题的悠久历史，以及研究和对抗Android。</font><font style="vertical-align: inherit;">他将从他的经验中考虑可以应用插图的典型任务，并展示如何避免害怕键盘，识别键盘的大小并响应外观。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意。</font><font style="vertical-align: inherit;">该文章基于Konstantin在</font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saint AppsConf 2019</font></font></em></a><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">上的一份报告撰写</font></em></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该报告使用了有关插图的几篇文章的材料。</font><font style="vertical-align: inherit;">最后链接到这些材料。</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">典型任务</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">颜色状态栏。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在许多项目中，设计人员绘制一个颜色状态栏。</font><font style="vertical-align: inherit;">当Android 5与新的Material Design一同出现时，它变得时尚起来。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9l/ii/76/9lii76jdfrbb5i0vq8-ecv2ikby.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如何绘制状态栏？</font><font style="vertical-align: inherit;">基本-添加</font></font><code>colorPrimaryDark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并替换颜色。</font></font><br>
<br>
<pre><code class="kotlin hljs"> &lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;<font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"colorPrimaryDark"</span>&gt;<span class="hljs-meta">@color</span>/colorAccent&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于高于第五版本的Android（21及更高版本的API），您可以在主题中设置特殊参数：</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;<font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"android:statusBarColor"</span>&gt;<span class="hljs-meta">@color</span>/colorAccent&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彩色状态栏</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">有时，设计师在不同的屏幕上以不同的颜色绘制状态栏。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uo/ev/nl/uoevnldknz2rtfq5lcqpn1mpj4g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没关系，最简单的方法是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在不同的活动中</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font><strong><font style="vertical-align: inherit;">不同的主题</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更有趣的方法是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接在运行时</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改颜色</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(...)</span></span>: View {<font></font>
    requireActivity().window.statusBarColor = requireContext().getColor(R.color.colorPrimary)<font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该参数通过特殊标志更改。</font><font style="vertical-align: inherit;">但是最主要的是不要忘记在用户退出屏幕时将颜色改回原来的颜色。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">透明状态栏。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这比较难。</font><font style="vertical-align: inherit;">透明度通常与地图相关联，因为在地图上可以最清楚地看到透明度。</font><font style="vertical-align: inherit;">在这种情况下，像以前一样，我们设置一个特殊参数：</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;    <font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentStatus"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，这里有一个众所周知的技巧-缩进更高，否则状态栏将叠加在图标上，并且很难看。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/49/8f/c8/498fc8wuip6i-o4eutfnviumuio.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是在其他屏幕上，一切都中断了。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/if/-0/0q/if-00qq6b7zidoz-_nfyehlev7s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如何解决问题？我想到的第一种方法是不同的活动：我们有不同的主题，不同的参数，它们的工作方式也不同。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用键盘。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不仅避免在状态栏上插入，而且在使用键盘时也避免插入。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s-/jk/mz/s-jkmzxzi-5xqr1ei0ku6pfubpy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没有人喜欢左侧的选项，但要将其变成右侧的选项，有一个简单的解决方案。</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;activity<font></font>
    ...<font></font>
    android:windowSoftInputMode=<span class="hljs-string">"adjustResize"</span>&gt;<font></font>
    ...<font></font>
&lt;/activity&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，可以在出现键盘时调整活动的大小。它的工作原理简单而严格。但是不要忘记另一个窍门-把一切都包装进去</font></font><code>ScrollView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。突然，键盘将占据整个屏幕，并且顶部会出现一个小条？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我们想在键盘出现时更改布局时，有时会更加困难。例如，否则安排按钮或隐藏徽标。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/q3/ia/zl/q3iazltlnajt-cpvdzc0u2i8zcs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们使用键盘和透明的状态栏训练了许多拐杖，现在很难阻止我们。转到StackOverflow并复制漂亮的代码。</font></font><br>
<br>
<pre><code class="kotlin hljs">boolean isOpened = <span class="hljs-literal">false</span>;<font></font>
<font></font>
<span class="hljs-keyword">public</span> void setListenerToRootView() {
    <span class="hljs-keyword">final</span> View activityRootView = getWindow().getDecorView().findViewById(android.R.id.content);<font></font>
    activityRootView.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {<font></font>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> void onGlobalLayout() {<font></font>
    <font></font>
            int heightDiff = activityRootView.getRootView().getHeight() - activityRootView.getHeight();      <font></font>
            <span class="hljs-keyword">if</span> (heightDiff &gt; <span class="hljs-number">100</span>) { <span class="hljs-comment">// 99% of the time the height diff will be due to a keyboard.       </span>
                Toast.makeText(getApplicationContext(), <span class="hljs-string">"Gotcha!!! softKeyboardup"</span>, <span class="hljs-number">0</span>).show();<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (isOpened == <span class="hljs-literal">false</span>) {
                   <span class="hljs-comment">//Do two things, make the view top visible and the editText smaller</span><font></font>
                }<font></font>
                isOpened = <span class="hljs-literal">true</span>;<font></font>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isOpened == <span class="hljs-literal">true</span>) {<font></font>
                Toast.makeText(getApplicationContext(), <span class="hljs-string">"softkeyborad Down!!!"</span>, <span class="hljs-number">0</span>).show();<font></font>
                isOpened = <span class="hljs-literal">false</span>;<font></font>
            }    <font></font>
        }<font></font>
    });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它甚至计算出键盘出现的可能性。</font><font style="vertical-align: inherit;">该代码在我们甚至使用过的其中一个项目中起作用，但是时间很长。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
示例中的许多拐杖与使用不同的活动有关。</font><font style="vertical-align: inherit;">但是，它们的坏处不仅是拐杖，还有其他原因：“冷启动”，异步问题。</font><font style="vertical-align: inherit;">我在“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">驾驶执照或为什么应用程序应该是单项活动</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">一</font></a><font style="vertical-align: inherit;">文中更详细地描述了这些问题</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">另外，Google的文档表明，推荐的方法是“单一活动”应用程序。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android 10之前我们做了什么</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们（在Redmadrobot处）正在开发相当高质量的应用程序，但长期以来避免了插入。我们如何在没有大拐杖的情况下一次活动来避免它们？</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意。屏幕截图和代码取自我的宠物项目</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitFox</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
想象一下应用程序屏幕。在开发应用程序时，我们从未想到下面会出现一个透明的导航栏。下面是否有黑条？那么，用户已经习惯了。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ce/ab/6v/ceab6v6m5dqnbl9zpotdi1vqmre.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在顶部，我们最初将状态栏设置为黑色且透明的参数。它在布局和代码方面如何看待？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0g/tu/of/0gtuoffisoeudtgxlnmqd-jicnk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
图中的抽象：红色块是应用程序的活动，蓝色是带有导航bot（带有Tabs）的片段，在其中有内容的绿色片段被切换了。可以看到工具栏不在状态栏下方。我们是如何实现的？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android有一个棘手的标志</font></font><code>fitSystemWindow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果将其设置为true，则容器将为其自身添加填充，以使其中的任何内容都不会落在状态栏下。我相信这个标志是Google对那些担心插曲的人的官方拐杖。使用所有内容都将相对良好地工作，而不会产生插图。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该标志</font></font><code>FitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将填充添加到您指定的容器。但是层次结构很重要：如果父项之一将此标志设置为“ true”，则将不考虑其分布，因为容器已经应用了缩进。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该标志有效，但是出现另一个问题。</font><font style="vertical-align: inherit;">想象一个带有两个标签的屏幕。</font><font style="vertical-align: inherit;">切换时，将启动一个事务，这会导致一个</font></font><code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片段彼此残缺，并且一切都会中断。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/02/_u/lv02_ui9sepxlvi7djz_xpem2sy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个片段也设置了一个标志</font></font><code>FitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这不会发生。</font><font style="vertical-align: inherit;">但是发生了什么，为什么呢？</font><font style="vertical-align: inherit;">答案是，这是拐杖，有时不起作用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是我们找到了一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆栈溢出</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的解决方案</font><font style="vertical-align: inherit;">：使用root而不是片段</font></font><code>FrameLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而是</font></font><code>CoordinatorLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它是为其他目的而创建的，但是可以在这里使用。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么行得通？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从源代码中了解发生了什么</font></font><code>CoordinatorLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> void onAttachedToWindow() {   
    <span class="hljs-keyword">super</span>.onAttachedToWindow();<font></font>
    ...    <font></font>
    <span class="hljs-keyword">if</span> (mLastInsets == <span class="hljs-literal">null</span> &amp;&amp; ViewCompat.getFitsSystemWindows(<span class="hljs-keyword">this</span>)) {         
        <span class="hljs-comment">// We're set to fitSystemWindows but we haven't had any insets yet...</span>
        <span class="hljs-comment">// We should request a new dispatch of window insets</span>
        ViewCompat.requestApplyInsets(<span class="hljs-keyword">this</span>);<font></font>
    }     <font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们看到一个美丽的注释，这里需要插入，但不是必需的。</font><font style="vertical-align: inherit;">当我们请求窗口时，我们需要重新询问它们。</font><font style="vertical-align: inherit;">我们发现插图可以在内部工作，但我们不想与它们一起工作并离开</font></font><code>Coordinator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在2019年春季，我们开发了该应用程序，当时Google I / O刚刚通过。</font><font style="vertical-align: inherit;">我们还没有弄清一切，因此我们继续坚持偏见。</font><font style="vertical-align: inherit;">但是我们注意到切换底部的Tabs有点慢，因为我们有一个复杂的布局，加载了UI。</font><font style="vertical-align: inherit;">我们找到一种解决此问题的简单方法-更改</font></font><code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为，</font></font><code>show/hide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样您就不必每次都重新创建布局。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/7l/vz/hx7lvzsl8-kfv3qqac2pbvllt8q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们改变了，再次没有任何作用-一切都坏了！</font><font style="vertical-align: inherit;">显然不可能分散拐杖，您需要了解拐杖的工作原理。</font><font style="vertical-align: inherit;">我们研究了代码，结果发现任何ViewGroup都可以使用inset。</font></font><br>
<br>
<pre><code class="kotlin hljs">
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> WindowInsets dispatchApplyWindowInsets(WindowInsets insets) {    <font></font>
    insets = <span class="hljs-keyword">super</span>.dispatchApplyWindowInsets(insets);     
    <span class="hljs-keyword">if</span> (!insets.isConsumed()) {         
        <span class="hljs-keyword">final</span> int count = getChildCount();        
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; count; i++) {<font></font>
            insets = getChildAt(i).dispatchApplyWindowInsets(insets);             <font></font>
            <span class="hljs-keyword">if</span> (insets.isConsumed()) {          
                <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> insets;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部有这样一种逻辑：如果至少有人已经处理过插图，则ViewGroup中的所有后续View将不会收到它们。</font><font style="vertical-align: inherit;">这对我们意味着什么？</font><font style="vertical-align: inherit;">让我向您展示一个用于切换Tabs的FrameLayout的示例。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h1/fo/nn/h1fonnc4qrqpmj_x-fc8m47ptci.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
里面有第一个设置了标志的片段</font></font><code>fitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这意味着第一个片段处理插图。</font><font style="vertical-align: inherit;">之后，我们将</font></font><code>HIDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个片段称为</font></font><code>SHOW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二个</font><font style="vertical-align: inherit;">片段</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是第一个仍然保留在布局中-他的“视图”保留了下来，只是隐藏了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
容器通过其视图：获取第一个片段，为其提供插图，然后从中获取</font></font><code>fitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-对其进行处理。</font><font style="vertical-align: inherit;">完美的是，FrameLayout看起来已经处理了插图，并且没有将其分配给第二个片段。</font><font style="vertical-align: inherit;">一切正常。</font><font style="vertical-align: inherit;">但这不适合我们，我们该怎么办？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们编写自己的ViewGroup</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们来自Java，而OOP具有所有荣耀，因此我们决定继承。</font><font style="vertical-align: inherit;">我们编写了自己的ViewGroup，从中我们重新定义了方法</font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它按照我们需要的方式工作：它总是将子集返回给孩子，而不管我们是否对其进行处理。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowInsetFrameLayout</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
    context: Context,      <font></font>
    attrs: AttributeSet? = <span class="hljs-literal">null</span>,     <font></font>
    defStyleRes: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><font></font>
) : FrameLayout(context, attrs, defStyleRes) {<font></font>
<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchApplyWindowInsets</span><span class="hljs-params">(insets: <span class="hljs-type">WindowInsets</span>)</span></span>: WindowInsets { 
        <span class="hljs-keyword">for</span> (child <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span> until childCount)) {<font></font>
            getChildAt(child).dispatchApplyWindowInsets(insets)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> insets.consumeSystemWindowInsets()<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自定义ViewGroup可以工作，项目也是我们需要的一切。</font><font style="vertical-align: inherit;">但是他仍然没有达成一个普遍的解决方案。</font><font style="vertical-align: inherit;">当我们弄清楚他们在Google IO上告诉我们的内容时，我们意识到我们将不再能够那样做。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android 10</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android 10向我们展示了两个严格建议遵循的重要UI概念：边缘到边缘和手势导航。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">边缘到边缘。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概念</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表明应用程序的内容应占据</font><font style="vertical-align: inherit;">屏幕上</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有可能的空间</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。对于我们（作为开发人员）来说，这意味着应将应用程序放置</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在状态栏和导航栏系统面板下。</font></font></strong><br>
<br>
<img src="https://habrastorage.org/webt/cr/gl/nh/crglnh9iw__fu4lct0gavaibqey.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
以前，我们可以以某种方式忽略它，或者仅将其置于状态栏下方。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
至于列表，它们不仅应滚动到最后一个元素，而且还应滚动到其他位置，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以免保留在导航栏下方。</font></font></strong><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tl/pl/it/tlplit1o65rn55edkixuuojxtha.png" width="350"></div><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手势导航。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二个重要概念是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手势导航</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它使您可以从屏幕边缘用手指控制应用程序。</font><font style="vertical-align: inherit;">手势模式是非标准的，一切看起来都不同，但是现在您无法在两个不同的导航栏之间切换。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此刻，我们意识到一切都不是那么简单。</font><font style="vertical-align: inherit;">如果我们要开发高质量的应用程序，将不可能进一步避免插入。</font><font style="vertical-align: inherit;">是时候研究文档并了解插图了。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插图 </font><font style="vertical-align: inherit;">您需要了解什么？</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建插图是为了吓developers开发人员。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自从它出现在Android 5中以来，他们就一直在完美地完成此工作</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。当然，一切还不是那么可怕。插入的概念很简单- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它们在应用程序屏幕上报告系统UI覆盖。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它可以是导航栏，状态栏或键盘。键盘也是常规系统UI，它叠加在应用程序的顶部。不必尝试只用插图的拐杖进行处理。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插图的目的是解决冲突</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。例如，如果按钮上方还有另一个元素，我们可以移动按钮，以便用户可以继续使用该应用程序。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了处理插图，</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><code>Windowlnsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android的10和</font></font><code>WindowInsetsCompat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他版本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android 10中有</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5种不同类型的插图</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个“红利”，不是内插图，否则称为。</font><font style="vertical-align: inherit;">我们将处理所有类型，因为大多数人只知道一件事-系统窗口插入。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统窗口插图</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Android 5.0（API 21）中引入。</font><font style="vertical-align: inherit;">通过方法获得</font></font><code>getSystemWindowInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是插图的主要类型，您需要学习如何使用它们，因为其余部分的工作方式相同。</font><font style="vertical-align: inherit;">首先需要它们来处理状态栏，然后是导航栏和键盘。</font><font style="vertical-align: inherit;">例如，当导航栏位于应用程序上方时，它们可以解决问题。</font><font style="vertical-align: inherit;">如图所示：该按钮保留在导航栏下方，用户无法单击它，并且非常不满意。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nx/yj/tt/nxyjttdppbkrnrnqkspovzp4hko.png" width="350"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可贴图元素插图</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仅出现在Android 10中</font></font><code>getTappableElementInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些插图</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅对处理各种导航栏模式</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有用</font><font style="vertical-align: inherit;">。就像</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">克里斯·贝恩</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><strong><font style="vertical-align: inherit;">Chris Bane）</font></strong><font style="vertical-align: inherit;">自己说的那样</font><font style="vertical-align: inherit;">，您可以忘记这种类型的插入，而只绕开系统窗口插入。但是，如果您希望应用程序是100％凉爽的，而不是99.9％凉爽的，则应该使用它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看图片。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/yd/fk/rlydfkwy39pfrc7jfhizhqdkg0q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顶部的深红色表示系统窗口插入，将以导航栏的不同模式显示。可以看出，它们在右侧和左侧等于导航栏。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回想一下手势导航的工作原理：在正确的模式下，我们从不单击新面板，而总是将手指从下往上拖动。</font><font style="vertical-align: inherit;">这意味着无法删除按钮。</font><font style="vertical-align: inherit;">我们可以继续按下FAB（浮动操作按钮）按钮，没有人会干涉。</font><font style="vertical-align: inherit;">因此，</font></font><code>TappableElementInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于不需要移动FAB </font><font style="vertical-align: inherit;">，它将变</font><font style="vertical-align: inherit;">空。</font><font style="vertical-align: inherit;">但是，如果我们再高一点，那没关系。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">区别仅在手势导航和透明导航栏</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（颜色自适应）中出现。</font><font style="vertical-align: inherit;">这不是一个非常令人愉快的情况。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zv/ei/qz/zveiqz33n9dc290ib9yhrrjl09u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一切正常，但看起来不愉快。</font><font style="vertical-align: inherit;">元素的接近可能会使用户感到困惑。</font><font style="vertical-align: inherit;">可以解释的是，一个用于手势，另一个用于按压，但仍然不美观。</font><font style="vertical-align: inherit;">因此，可以将FAB调高些或将其放在右边。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统手势插入</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仅出现在Android 10中</font></font><code>getSystemGestureInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些插图与手势导航有关。最初，假定系统UI是在应用程序的顶部绘制的，但是系统手势插图表示不是绘制UI，而是由系统本身来处理手势。它们描述了系统默认情况下将在哪里处理手势。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些插图的区域大约是图中黄色标记的区域。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/8d/jl/vv8djlgxe4cnjchozbllrysagd0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是我要警告您-他们不会一直这样。我们永远不会知道三星和其他制造商会推出什么样的新屏幕。已经有屏幕四面八方的设备。也许插图根本不会是我们期望的。因此，您需要像使用某些抽象一样使用它们：系统手势插入中有这样的插入，系统本身在其中处理手势。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些插图可以被覆盖。</font><font style="vertical-align: inherit;">例如，您正在开发照片编辑器。</font><font style="vertical-align: inherit;">在某些地方，即使手势在屏幕边缘附近，您自己也要处理手势。</font><font style="vertical-align: inherit;">指示系统您将自己处理照片一角在屏幕上的点。</font><font style="vertical-align: inherit;">可以通过告诉系统重新定义它：“我将始终自己处理该点周围的正方形。”</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">强制系统手势插入</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仅在Android 10中出现。这是系统手势插入的子类型，但不能被应用程序覆盖。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们使用该方法</font></font><code>getMandatorySystemGestureInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来确定它们将无法工作的区域。</font><font style="vertical-align: inherit;">这样做是有意进行的，因此不可能开发“无希望”应用程序：从下至上重新定义导航手势，这使您可以将应用程序退出到主屏幕。</font><font style="vertical-align: inherit;">在这里，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统始终处理手势本身</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/89/gl/df/89gldfknoq8z9dje_naytwp0pti.png" width="450"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不一定会在设备底部，也不一定要在此尺寸下。</font><font style="vertical-align: inherit;">作为抽象使用它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些是相对较新的插图。</font><font style="vertical-align: inherit;">但是有些甚至在Android 5之前就出现了，它们的名称有所不同。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">稳定的插图</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与Android 5.0（API 21）一起引入。通过方法获得</font></font><code>getStableInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
即使是经验丰富的开发人员也不能总是说出为什么需要它们。我将告诉您一个秘密：这些插图仅对全屏应用程序有用：视频播放器，游戏。例如，在播放模式下，任何系统UI都被隐藏，包括状态栏，该状态栏移到屏幕边缘之外。但是值得触摸屏幕，因为状态栏将显示在顶部。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您在屏幕顶部放置了任何“返回”按钮，而它正确处理了系统窗口插入，则对于每个选项卡，一个UI都将出现在屏幕顶部，并且该按钮会向下跳。如果您有一阵子不触摸屏幕，状态栏将消失，该按钮将弹起，因为“系统窗口插入”已消失。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于这种情况，稳定的插入是正确的。</font><font style="vertical-align: inherit;">他们说，现在您的应用程序上没有绘制任何元素，但是可以做到。</font><font style="vertical-align: inherit;">通过这些插图，您可以预先知道例如在此模式下状态栏的值，并将按钮放置在所需的位置。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意。</font><font style="vertical-align: inherit;">该方法</font></font></em><code><em>getStableInsets()</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅在API 21中出现。以前，屏幕的每一侧都有几种方法。&nbsp;</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们检查了5种插图，但还有另外一种不适用于直接插图。</font><font style="vertical-align: inherit;">它有助于应对刘海和缺口。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">刘海和领口</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
屏幕不再是正方形的。</font><font style="vertical-align: inherit;">它们是长方形的，在相机上有一个或多个切口，在各个侧面都有刘海。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ls/kv/sc/lskvscp_j-hy2gesyynicb346cq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们最多无法处理28个API。</font><font style="vertical-align: inherit;">我不得不通过插图来猜测那里发生了什么。</font><font style="vertical-align: inherit;">但是，随着28 API及更高版本（来自先前的Android），该类正式出现</font></font><code>DisplayCutout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它具有相同的插图，您可以从中获得所有其他类型。</font><font style="vertical-align: inherit;">该类使您可以找到工件的位置和大小。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了位置信息之外，还为开发人员提供了一组y标志</font></font><code>WindowManager.LayoutParams</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它们使您可以在切口周围包含不同的行为。</font><font style="vertical-align: inherit;">您的内容可能会显示在它们周围，或者可能不会显示：以横向和纵向模式以不同的方式显示。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
标志</font></font><code>window.attributes.layoutInDisplayCutoutMode =</code><br>
<br>
<ul>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">默认情况下，在肖像中-有风景；在风景中-有黑条。</font></font></li>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">完全没有-黑色条纹。</font></font></li>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -永远是。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以控制显示，但是我们使用它们的方式与处理其他插图相同。</font></font><br>
<br>
<pre><code class="kotlin hljs">insets.displayCutout<font></font>
    .boundingRects<font></font>
    .forEach { rect -&gt; ... }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
带有数组插入的回调来了</font></font><code>displayCutout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后，我们可以运行它，处理应用程序中的所有切口和爆炸。</font><font style="vertical-align: inherit;">您可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本文中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解有关如何使用它们的更多信息</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
了解了6种插图。</font><font style="vertical-align: inherit;">现在让我们谈谈它是如何工作的。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">怎么运行的</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，当在应用程序顶部绘制某些内容时，例如导航栏，需要插入。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ft/ct/_w/ftct_wh_dc64t9rw6ir_7zpqg8m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没有插图，应用程序将没有透明的导航栏和状态栏。</font><font style="vertical-align: inherit;">别为您不来而感到惊讶</font></font><code>SystemWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这会发生。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">价差</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
整个UI层次结构看起来像一棵树，树的末端是View。</font><font style="vertical-align: inherit;">节点通常是一个ViewGroup。</font><font style="vertical-align: inherit;">它们也从View继承，因此插图以特殊的方式出现在它们身上</font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">从根视图开始，系统会在整个树中发送插图。</font><font style="vertical-align: inherit;">让我们看看在这种情况下View是如何工作的。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jy/rw/hk/jyrwhkavrimytpqs4je0ltfn7-w.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
系统在其上调用</font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插入</font><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">返回此视图应返回某些内容。</font><font style="vertical-align: inherit;">如何处理此行为？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了简单起见，我们仅考虑WindowInsets。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理插图</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，</font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在其自己的逻辑内部</font><font style="vertical-align: inherit;">重新定义方法</font><font style="vertical-align: inherit;">和实现</font><font style="vertical-align: inherit;">似乎是合乎逻辑的</font><font style="vertical-align: inherit;">：插入后，我们在内部实现了所有内容。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果打开View类并查看在此方法顶部编写的Javadoc，您将看到：“请勿覆盖此方法！”</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们通过委派或继承处理Inset。</font></font></blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用委托</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Google提供了暴露自己的代表的机会，该代表负责处理插图。</font><font style="vertical-align: inherit;">您可以通过方法安装它</font></font><code>setOnApplyWindowInsetsListener(listener)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们设置了一个处理这些插图的回调。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果由于某种原因这不适合我们，则可以</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从View继承并重写另一个方法</font></font></strong> <code>onApplyWindowInsets(WindowInsets insets)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们用自己的插图代替它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google不在委托和继承之间进行选择，而是允许一起做所有事情。</font><font style="vertical-align: inherit;">这很棒，因为我们不必重新定义所有工具栏或ListView即可处理插图。</font><font style="vertical-align: inherit;">我们可以使用任何现成的View，甚至可以是库View，然后在其中设置委托，该委托将处理inset而无需重新定义。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将返回什么？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么要退货？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，您需要了解插图的分布方式，即ViewGroup。</font><font style="vertical-align: inherit;">她在自己里面做什么。</font><font style="vertical-align: inherit;">让我们使用前面显示的示例仔细研究默认行为。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
系统插图位于顶部和底部，例如每个100像素。</font><font style="vertical-align: inherit;">ViewGroup将它们发送到它拥有的第一个View。</font><font style="vertical-align: inherit;">此视图以某种方式处理了它们并返回insets：在顶部，它减少到0，但在底部，它离开。</font><font style="vertical-align: inherit;">在顶部，她添加了填充或边距，但在底部，她没有触摸并报告了此情况。</font><font style="vertical-align: inherit;">接下来，ViewGroup将插图传递给第二个View。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tj/-a/rw/tj-arwxjkus-n6xnvl099lqbqqg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下一个View处理并渲染插图。</font><font style="vertical-align: inherit;">现在，ViewGroup可以看到在上方和下方都处理了插入物-剩下的都没有，所有参数均为零。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三个视图甚至都不知道有一些插图并且正在发生某些事情</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ViewGroup会将插图返回给暴露它们的那个。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我们开始处理该主题时，我们为自己写下了这个想法-总是返回相同的插图。</font><font style="vertical-align: inherit;">我们希望避免某些View甚至不知道有插图的情况。</font><font style="vertical-align: inherit;">这个想法看起来合乎逻辑。</font><font style="vertical-align: inherit;">但是事实证明没有。</font><font style="vertical-align: inherit;">Google并没有像在示例中那样为插图添加行为。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是必需的，以便插图始终可以到达视图的整个层次结构，并且您可以始终使用它们。</font><font style="vertical-align: inherit;">在这种情况下，当我们切换两个片段，一个已经处理，第二个还没有收到时，将不会出现任何情况。</font><font style="vertical-align: inherit;">在练习部分，我们将回到这一点。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实践</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理论完成了。</font><font style="vertical-align: inherit;">让我们看看它在代码中的外观，因为从理论上讲，一切总是很顺利的。</font><font style="vertical-align: inherit;">我们将使用AndroidX。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意。</font><font style="vertical-align: inherit;">在</font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitFox中，</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码中已经实现了所有功能，完全支持新Android的所有功能。</font><font style="vertical-align: inherit;">为了不检查Android版本并且不搜索所需的Insets类型，请始终使用</font></font></em><code><em>view.setOnApplyWindowInsetsListener { v, insets -&gt; ... }</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AndroidX中</font></font></em><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">的</font></em><em><font style="vertical-align: inherit;">版本- </font></em><em><font style="vertical-align: inherit;">代替</font></em></font><code><em>ViewCompat.setOnApplyWindowInsetsListener(view) { v, insets -&gt; ... }</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
屏幕上有一个深色的导航栏。</font><font style="vertical-align: inherit;">它不与任何元素重叠。</font><font style="vertical-align: inherit;">一切都是我们习惯的方式。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/3r/wq/sp/3rwqspgcdlgie2m00lmedkwzgi8.png" width="350"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是事实证明，现在我们需要使其透明。</font><font style="vertical-align: inherit;">怎么样？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开启透明度</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最简单的事情是在主题中指示状态栏和导航栏是透明的。</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.MaterialComponents.Light"</span>&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentStatus"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentNavigation"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此时，一切都从上方和下方开始相互重叠。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有趣的是，有两个标志，并且总是有三个选项：如果您为导航栏指定透明性，则状态栏本身将变为透明-这样的限制。</font><font style="vertical-align: inherit;">您不能写第一行，但我始终喜欢清晰，因此我写了两行，以便追随者可以了解正在发生的事情，而无需深入了解。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果选择此方法，则导航栏和状态栏将变为透明的黑色。</font><font style="vertical-align: inherit;">如果应用程序是白色的，则只能从代码中添加颜色。</font><font style="vertical-align: inherit;">怎么做？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用颜色打开透明度</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最好有一个“单一活动”应用程序，所以我们在一个活动中放置两个标志。</font></font><br>
<br>
<pre><code class="kotlin hljs">rootView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE or  <font></font>
    View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION<font></font>
<font></font>
&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.MaterialComponents.Light"</span>&gt;<font></font>
    &lt;!-- Set the navigation bar to <span class="hljs-number">50</span>% translucent white --&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:navigationBarColor"</span>&gt;#<span class="hljs-number">80F</span>FFFFF&lt;/item&gt; <font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那里有很多标志，但正是这两个标志有助于在导航栏和状态栏中保持透明。</font><font style="vertical-align: inherit;">可以通过主题指定颜色。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是Android的奇怪行为：通过主题进行操作，通过标志进行操作。</font><font style="vertical-align: inherit;">但是我们可以在代码和主题中指定参数。</font><font style="vertical-align: inherit;">这在Android上还不错，只是在较旧版本的Android上，该主题中指定的标志将被忽略。</font></font><code>navigationBarColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它会突出显示在Android 5上不是这样，但是所有内容都会融合在一起。</font><font style="vertical-align: inherit;">在GitFox中，正是我从代码中设置了导航栏的颜色。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们进行了欺诈-表示导航栏为白色且透明。</font><font style="vertical-align: inherit;">现在应用程序看起来像这样。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/eo/vs/mz/eovsmz1tczlc9vl_kg2yihxs0u0.png" width="350"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有什么比处理插图更容易的呢？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
的确是初级。</font></font><br>
<br>
<pre><code class="kotlin hljs">ViewCompat<font></font>
    .setOnApplyWindowInsetsListener(bottomNav) { view, insets -&gt;  <font></font>
        view.updatePadding(bottom = insets.systemWindowInsetBottom) <font></font>
        insets<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们采用该方法</font></font><code>setOnApplyWindowInsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将其传递给它</font></font><code>bottomNav</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们说当插图出现时，请安装进来的底部衬垫</font></font><code>systemWindowInsetBottom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们希望它在下面，但是所有可点击的元素都在最上面。</font><font style="vertical-align: inherit;">我们返回完整的插图，以便层次结构中的所有其他View也可以接收它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一切看起来都很棒。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zl/8e/ku/zl8ekuc_pvpc2wrmeop-khxmomg.png" width="350"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是有一个问题！</font><font style="vertical-align: inherit;">如果在布局中我们在下面的导航栏上指示了某种填充，则此处</font></font><code>updatePadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已将</font><font style="vertical-align: inherit;">其删除-将</font><font style="vertical-align: inherit;">插图</font><font style="vertical-align: inherit;">设置为</font><font style="vertical-align: inherit;">相等。</font><font style="vertical-align: inherit;">我们的布局看起来并不理想。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要从布局保存值，必须首先保存下部填充中的内容。</font><font style="vertical-align: inherit;">稍后，当插图到达时，添加并设置结果值。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> bottomNavBottomPadding = bottomNav.paddingBottom<font></font>
ViewCompat<font></font>
    .setOnApplyWindowInsetsListener(bottomNav) { view, insets -&gt;                 <font></font>
        view.updatePadding(<font></font>
        bottom = bottomNavBottomPadding + insets.systemWindowInsetBottom<font></font>
    )<font></font>
    Insets<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样写起来很不方便：在代码中所有使用inset的地方，都需要保存布局中的值，然后将其添加到UI中。</font><font style="vertical-align: inherit;">但是这里有Kotlin，这很棒-您可以编写自己的扩展程序，它将为我们完成所有这些工作。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加科特林！</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们会记住，</font></font><code>initialPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并在出现新的插图时（连同它们一起）将其交给处理程序。</font><font style="vertical-align: inherit;">这将帮助他们以某种方式加在一起或从上面构建某种逻辑。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">doOnApplyWindowInsets</span><span class="hljs-params">(block: (<span class="hljs-type">View</span>, <span class="hljs-type">WindowInsetsCompat</span>, <span class="hljs-type">Rect</span>) -&gt; <span class="hljs-type">WindowInsetsCompat</span>)</span></span> {    <font></font>
<font></font>
    <span class="hljs-keyword">val</span> initialPadding = recordInitialPaddingForView(<span class="hljs-keyword">this</span>)<font></font>
<font></font>
    ViewCompat.setOnApplyWindowInsetsListener(<span class="hljs-keyword">this</span>) { v, insets -&gt;        <font></font>
        block(v, insets, initialPadding)<font></font>
    }<font></font>
    <font></font>
    requestApplyInsetsWhenAttached()<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">recordInitialPaddingForView</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> =<font></font>
   Rect(view.paddingLeft, view.paddingTop, view.paddingRight, view.paddingBottom)<font></font>
<font></font>
  .<font></font>
<font></font>
bottomNav.doOnApplyWindowInsets { view, insets, padding -&gt;   <font></font>
    view.updatePadding(<font></font>
        bottom = padding.bottom + insets.systemWindowInsetBottom<font></font>
    ) <font></font>
    insets<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们必须重新定义lambda。</font><font style="vertical-align: inherit;">它不仅有插图，而且还有填充物。</font><font style="vertical-align: inherit;">如果它是处理状态栏的工具栏，我们不仅可以从下方添加它们，还可以从上方添加它们。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遗忘的东西！</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
调用了一个无法理解的方法。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">doOnApplyWindowInsets</span><span class="hljs-params">(block: (<span class="hljs-type">View</span>, <span class="hljs-type">WindowInsetsCompat</span>, <span class="hljs-type">Rect</span>) -&gt; <span class="hljs-type">WindowInsetsCompat</span>)</span></span> {<font></font>
<font></font>
    <span class="hljs-keyword">val</span> initialPadding = recordInitialPaddingForView(<span class="hljs-keyword">this</span>)<font></font>
     <font></font>
    ViewCompat.setOnApplyWindowInsetsListener(<span class="hljs-keyword">this</span>) { v, insets -&gt;        <font></font>
        block(v, insets, initialPadding)<font></font>
    }<font></font>
      <font></font>
    requestApplyInsetsWhenAttached() <font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">recordInitialPaddingForView</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> =<font></font>
      Rect(view.paddingLeft, view.paddingTop, view.paddingRight, view.paddingBottom)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是由于您不能仅仅希望系统会向您发送插图。</font><font style="vertical-align: inherit;">如果我们通过代码创建一个View或</font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">稍后</font><font style="vertical-align: inherit;">安装</font><font style="vertical-align: inherit;">，则系统本身可能不会传递最后一个值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们必须检查屏幕上是否显示了“视图”，然后告诉系统：“插图已到达，我们要对其进行处理。” </font><font style="vertical-align: inherit;">我们设置了监听器并且必须发出请求</font></font><code>requestsApplyInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。“</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">requestApplyInsetsWhenAttached</span><span class="hljs-params">()</span></span> {    
    <span class="hljs-keyword">if</span> (isAttachedToWindow) {        <font></font>
        requestApplyInsets()<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        addOnAttachStateChangeListener(<span class="hljs-keyword">object</span> : View.OnAttachStateChangeListener {            
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewAttachedToWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> {<font></font>
                v.removeOnAttachStateChangeListener(<span class="hljs-keyword">this</span>)<font></font>
                v.requestApplyInsets()           <font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewDetachedFromWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> = <span class="hljs-built_in">Unit</span><font></font>
        })<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们创建了View代码，但尚未将其附加到布局中，那么我们必须订阅执行该代码的时间。</font><font style="vertical-align: inherit;">只有这样，我们才能请求插图。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是话又说回来，这里有Kotlin：他们写了一个简单的扩展名，我们不必再考虑了。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完善RecyclerView</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在让我们谈谈完成RecyclerView的过程。最后一个元素位于导航栏下方，而在下方-丑陋。单击它也很不方便。如果这不是一个新面板，而是一个旧面板，一个大面板，则通常整个元素可能会在其下方消失。该怎么办？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jc/qa/f7/jcqaf7okahkrhrrnols54exqhdu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一个想法是在下面添加一个元素，并设置高度以适合插图。但是，如果我们有一个包含数百个列表的应用程序，那么我们将不得不以某种方式将每个列表预订为inset，在其中添加新元素并设置高度。此外，RecyclerView是异步的，尚不清楚何时可以使用。有很多问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，还有另一种官方破解方法。令人惊讶的是，它有效地工作。</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;androidx.recyclerview.widget.RecyclerView <font></font>
        android:id=<span class="hljs-string">"@+id/recyclerView"</span>        
    android:layout_width=<span class="hljs-string">"match_parent"</span>    
    android:layout_height=<span class="hljs-string">"match_parent"</span>             
    android:clipToPadding=<span class="hljs-string">"false"</span> /&gt;<font></font>
<font></font>
recyclerView.doOnApplyWindowInsets { view, insets, padding -&gt;    <font></font>
    view.updatePadding(<font></font>
        bottom = padding.bottom + insets.systemWindowInsetBottom<font></font>
    )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
布局中有这样的标记</font></font><code>clipToPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。默认情况下，它始终为true。这表明您不需要绘制出现填充的地方出现的元素。但是，如果设置了</font></font><code>clipToPadding="false"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则可以绘制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，如果您在底部设置了填充，则在RecyclerView中它将像这样工作：在底部，设置了填充，并在其顶部绘制了元素，直到我们滚动。一旦到达末尾，RecyclerView会将元素滚动到我们需要的位置。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过设置一个这样的标志，我们可以像普通View一样使用RecyclerView。不要以为有元素可以滚动-只需在下面设置填充，例如在底部导航栏中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们总是返回插入项，就好像未处理它们一样。</font><font style="vertical-align: inherit;">整个插图都来到了我们，我们对它们做了一些事情，设置了填充物，然后再次将所有的整个插图都退了回来。</font><font style="vertical-align: inherit;">这是必需的，以便任何ViewGroup始终将这些插图传递给所有View。</font><font style="vertical-align: inherit;">有用。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用程序错误</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Google Play上的许多已经处理了插图的应用程序中，我注意到了一个小错误。现在，我将介绍他。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
地下室有一个带有导航的屏幕。右侧是显示层次结构的同一屏幕。绿色片段在屏幕上显示内容，其中有一个RecyclerView。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hl/e6/jo/hle6jod0ws19fydq734lqnuaixu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
谁处理了这里的插图？工具栏：他在顶部应用了填充，以便其内容在状态栏下移动。因此，底部导航栏从导航栏下方应用插图，并在导航栏上方应用插图。但是RecyclerView不会以任何方式处理插图，它不会落在它们之下，也不需要处理插图-一切都正确完成。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/r3/xc/qi/r3xcqipovgqu-zbbxruxsy-wqvk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是事实证明，我们想在底部导航栏不再存在的另一个地方使用绿色的RecyclerView片段。此时，RecyclerView已经开始从下面处理插图。我们需要对其应用填充以从导航栏下方正确滚动。因此，在RecyclerView中，我们还添加了insets处理。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ve/ws/m-/vewsm-_o80cw7mbn9tyk0bu_mfs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们返回到屏幕，每个人都处理插图。还记得没有人报告他已经处理过这些吗？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/um/vd/x8/umvdx8faxxk48r-inx-cxhkjqdm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们看到了这种情况：RecyclerView从下面处理了插图，尽管它没有到达导航栏-底部出现了一个空格。我在应用程序中注意到了这一点，并且非常流行。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/i9/3_/ar/i93_arxauyvbitayfpyonkxnudy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果是这种情况，请记住我们将所有插图返回给处理。因此（事实证明！）有必要报告插图已处理：导航栏应报告插图已处理。他们不应该进入RecyclerView。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jf/r2/vi/jfr2vi8jpsas_ptxjjqh_qhg1vk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，请安装底部导航栏</font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。减去</font></font><code>bottom + insets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未处理的内容，返回0。</font></font><br>
<br>
<pre><code class="kotlin hljs">doOnApplyWindowInsets { view, insets, initialPadding -&gt;    <font></font>
    view.updatePadding(<font></font>
        bottom = initialPadding.bottom + insets.systemWindowInsetBottom<font></font>
    )<font></font>
    insets.replaceSystemWindowInsets(<font></font>
        Rect(<font></font>
            insets.systemWindowInsetLeft,            <font></font>
            insets.systemWindowInsetTop,            <font></font>
            insets.systemWindowInsetRight,<font></font>
            <span class="hljs-number">0</span><font></font>
        )<font></font>
    )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们返回新的inset，其中所有旧参数均相等，但</font></font><code>bottom + insets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等于0。似乎一切都很好。</font><font style="vertical-align: inherit;">我们开始胡说八道-由于某些原因，RecyclerView仍然处理inset。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lp/yw/ut/lpywut3fvlk5w-nwbd3-wnrceaw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我没有立即理解问题是这三个视图的容器是LinearLayout。</font><font style="vertical-align: inherit;">它们内部是一个工具栏，一个带有RecyclerView的代码段，位于底部导航栏的底部。</font><font style="vertical-align: inherit;">LinearLayout按顺序排列其子项，并将其套用到它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事实证明，底部导航栏将是最后一个。</font><font style="vertical-align: inherit;">他告诉某人他已经处理了所有插图，但为时已晚。</font><font style="vertical-align: inherit;">所有插图均已从上到下进行处理，RecyclerView已收到它们，但这并不能挽救我们。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uj/mm/jd/ujmmjdgumv0bl6e0ewydx7ueq5g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该怎么办？</font><font style="vertical-align: inherit;">LinearLayout不能按照我想要的方式工作，而是将它们从上到下传输，我需要先获取下一个。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重新定义全部</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java开发人员扮演了我的角色- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一切都</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要</font><strong><font style="vertical-align: inherit;">重新定义</font></strong><font style="vertical-align: inherit;">！</font><font style="vertical-align: inherit;">好了，现在</font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重新定义set </font></font><code>yLinearLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它将始终从下到上。</font><font style="vertical-align: inherit;">他将首先将插图底部导航栏发送给其他人。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> WindowInsets dispatchApplyWindowInsets(WindowInsets insets) {     <font></font>
    insets = <span class="hljs-keyword">super</span>.dispatchApplyWindowInsets(insets);     
    <span class="hljs-keyword">if</span> (!insets.isConsumed()) {        
        <span class="hljs-keyword">final</span> int count = getChildCount();
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; count; i++) {<font></font>
            insets = getChildAt(i).dispatchApplyWindowInsets(insets);<font></font>
            <span class="hljs-keyword">if</span> (insets.isConsumed()) {
                <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> insets;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是我及时停下来，回想起没有必要重新定义此方法的评论。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，救赎要高一些：ViewGroup检查是否有处理插入的委托，然后在View上调用super方法并启用其自己的处理。</font><font style="vertical-align: inherit;">在此代码中，我们获得了插入物，如果尚未处理它们，我们将为子级开始标准逻辑。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我写了一个简单的扩展。</font><font style="vertical-align: inherit;">应用于</font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个视图，</font><font style="vertical-align: inherit;">它允许</font><font style="vertical-align: inherit;">说出这些插图传递给谁。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">addSystemBottomPadding</span><span class="hljs-params">(    
    targetView: <span class="hljs-type">View</span> = this
)</span></span> {<font></font>
    doOnApplyWindowInsets { _, insets, initialPadding -&gt;           <font></font>
        targetView.updatePadding(<font></font>
            bottom = initialPadding.bottom + insets.systemWindowInsetBottom<font></font>
        )<font></font>
        insets.replaceSystemWindowInsets(<font></font>
            Rect(<font></font>
                insets.systemWindowInsetLeft,<font></font>
                insets.systemWindowInsetTop,     <font></font>
                insets.systemWindowInsetRight,<font></font>
                <span class="hljs-number">0</span><font></font>
            )<font></font>
        )<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><code>targetView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下，</font><font style="vertical-align: inherit;">它</font><font style="vertical-align: inherit;">等于我们要应用的同一视图</font></font><code>addSystemBottomPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们可以重新定义它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我的LinearLayout上，我悬挂了这样的处理程序，传递为</font></font><code>targetView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是我的底部导航栏。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，他将提供插图底部导航栏。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那将处理插图，将返回零底。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，默认情况下，它们将自上而下：工具栏，带有RecyclerView的片段。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，也许他会再次发送插图底部导航栏。</font><font style="vertical-align: inherit;">但这不再重要，一切都会很好。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我完全实现了我想要的：所有插图均按需要的顺序进行处理。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s3/b0/nc/s3b0nc07bayude3nvrvevkxnwyc.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
需要牢记的一些重要事项。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">键盘是应用程序顶部的系统UI。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无需特殊对待她。如果您查看的是Google键盘，则不仅是带有可单击按钮的布局。该键盘有数百种模式：搜索gif和memes，语音输入，从10像素的高度调整到屏幕大小。不要考虑键盘，而是订阅插图。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">导航抽屉仍不支持手势导航</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他们承诺在Google IO上开箱即用。</font><font style="vertical-align: inherit;">但是在Android 10中，导航抽屉仍不支持此功能。</font><font style="vertical-align: inherit;">如果您升级到Android 10并启用手势导航，导航抽屉将掉线。</font><font style="vertical-align: inherit;">现在，您需要单击汉堡菜单以使其显示，或者随机情况的组合允许您拉伸它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Android的预发布版本中，导航抽屉有效，但我不敢更新-这是预发布版本。</font><font style="vertical-align: inherit;">因此，即使您从存储库中安装了最新版本的GitFox，那里也有一个导航抽屉，但是无法将其拉出。</font><font style="vertical-align: inherit;">官方支持一经发布，我就会更新，一切都会正常进行。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android 10准备清单</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从项目开始设置导航栏和状态栏的透明度</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Google强烈建议您维护透明的导航栏。对我们来说，这是重要的实践部分。如果该项目可行，但您没有打开它，请选择支持Android 10的时间。首先在主题中打开它们（例如半透明），然后更正其中断的布局。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将扩展程序添加到Kotlin-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用它们更容易。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将所有工具栏添加到填充顶部。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工具栏始终位于顶部，这就是您需要做的。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于所有RecyclerViews，从底部添加填充</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和滚动浏览的功能</font></font><code>clipToPadding="false"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑一下屏幕</font></font></strong><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（FAB）</font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">边缘上的所有按钮</font></strong><font style="vertical-align: inherit;">。 FAB很可能不在您期望的位置。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于所有LinearLayout</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和其他类似情况，</font><strong><font style="vertical-align: inherit;">请不要覆盖或自行实现</font></strong><font style="vertical-align: inherit;">。像在GitFox中一样，完成技巧，或者使用我现成的扩展程序来提供帮助。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查屏幕边缘的手势以获取自定义View</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。导航抽屉不支持此功能。但是，用手支撑它并不是很困难，可以使用导航抽屉在屏幕上重新定义手势的插入。也许您有图片编辑器，手势在其中起作用。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在ViewPager中滚动无法从边缘开始，而只能从中心向右和向左滚动</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Google说这很正常。如果从边缘拖动ViewPager，则将其视为按下“返回”按钮。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在一个新项目中，立即包括所有透明度</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您可以告诉设计者您没有导航栏和状态栏。</font><font style="vertical-align: inherit;">整个方框就是您的应用程序内容。</font><font style="vertical-align: inherit;">开发人员将已经弄清楚了在哪里筹集什么。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有用的链接：</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电报中的@rmr_spb-Redmadrobot SPb的内部mitap记录。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本文中的所有源代码，以及</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitFox中的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更多源代码</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">有一个单独的Android 10分支，在这里您可以通过commit看到我如何完成所有这些工作以及我如何支持新的Android。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">克里斯·贝恩（Chris Bane）的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Insetter图书馆</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它包含了我展示的5-6个扩展名。</font><font style="vertical-align: inherit;">要在您的项目中使用，请与该库联系，最有可能它将移至Android Jetpack。</font><font style="vertical-align: inherit;">我在项目中开发了它们，在我看来，它们变得更好。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">克里斯·贝恩（Chris Bane）的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">文章</font></a><font style="vertical-align: inherit;">。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>   FunCorn,    ,      .</li>
<li> «<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Why would I want to fitsSystemWindows?</a>»  .</li>
</ul><br>
<blockquote>    AppConf,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">youtube-</a>      .            ,     - .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AppsConf</a>     ,            .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>, stay tuned!</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN488164/index.html">SEC与电报之战</a></li>
<li><a href="../zh-CN488184/index.html">由ZeroTier提供支持。构建虚拟网络的实用指南。第2部分</a></li>
<li><a href="../zh-CN488186/index.html">我的质量检查工程师之路：从倦怠到高考</a></li>
<li><a href="../zh-CN488190/index.html">再一次关于情绪倦怠</a></li>
<li><a href="../zh-CN488194/index.html">我们为什么要编写质量这么差的程序？</a></li>
<li><a href="../zh-CN488198/index.html">Timlids害怕什么，为什么他们应该停止这样做</a></li>
<li><a href="../zh-CN488202/index.html">PVS-Studio现在位于Chocolatey中：从Azure DevOps检查Chocolatey</a></li>
<li><a href="../zh-CN488208/index.html">周年纪念DUMP2020-4天你不会忘记</a></li>
<li><a href="../zh-CN488210/index.html">使用TensorFlow在android上识别对象：从数据准备到在设备上启动</a></li>
<li><a href="../zh-CN488212/index.html">DORA 2019年DevOps状况报告，现在也以俄语显示</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>