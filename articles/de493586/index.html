<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂 🚡 🥃 JIT-Compiler-Optimierungen für .NET 5 ☝🏿 😳 👏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einiger Zeit habe ich eine erstaunliche Reise in die Welt des JIT-Compilers begonnen, um Orte zu finden, an denen Sie Ihre Hände hineinstecken und...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>JIT-Compiler-Optimierungen für .NET 5</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/493586/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor einiger Zeit habe ich eine erstaunliche Reise in die Welt des JIT-Compilers begonnen, um Orte zu finden, an denen Sie Ihre Hände hineinstecken und etwas beschleunigen können Im Laufe der Hauptarbeit hat sich ein wenig Wissen über LLVM und seine Optimierungen angesammelt. In diesem Artikel möchte ich eine Liste meiner Verbesserungen in JIT (in .NET heißt es RyuJIT zu Ehren eines Drachen oder Anime - ich habe es nicht herausgefunden) teilen, von denen die meisten bereits den Master erreicht haben und in .NET (Core) 5 verfügbar sein werden Meine Optimierungen wirken sich auf verschiedene Phasen der JIT aus, die sehr schematisch wie folgt dargestellt werden können: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/di/ao/qk/diaoqktgwhzremeu8qd8inutrak.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie aus dem Diagramm ersichtlich, ist die JIT ein separates Modul in Bezug auf die enge </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jit-Schnittstelle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , über die die JIT beispielsweise einige Dinge berät, ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dies möglich</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wirf eine Klasse in eine andere. </font><font style="vertical-align: inherit;">Je später die JIT die Methode in Tier1 kompiliert, desto mehr Informationen kann die Laufzeit beispielsweise liefern, dass die </font></font><code>static readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Felder durch eine Konstante ersetzt werden können, weil </font><font style="vertical-align: inherit;">Die Klasse ist bereits statisch initialisiert.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir also mit der Liste.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PR </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># 1817</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Boxing / Unboxing-Optimierungen beim Pattern Matching</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phase:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Importer </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele der neuen C # -Funktionen werden häufig durch Einfügen von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Box / Unbox-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CIL-Opcodes verursacht </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist eine sehr teure Operation, bei der es sich im Wesentlichen um die Zuweisung eines neuen Objekts auf dem Heap handelt, bei der der Wert vom Stapel in den Heap kopiert wird und am Ende auch der GC geladen wird. </font><font style="vertical-align: inherit;">Es gibt bereits eine Reihe von Optimierungen in JIT für diesen Fall, aber ich habe in C # 8 einen fehlenden Mustervergleich gefunden, zum Beispiel:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> Case1&lt;T&gt;(T o)<font></font>
{<font></font>
    <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">is</span> <span class="hljs-keyword">int</span> x)
        <span class="hljs-keyword">return</span> x;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> Case2&lt;T&gt;(T o) =&gt; o <span class="hljs-keyword">is</span> <span class="hljs-keyword">int</span> n ? n : <span class="hljs-number">42</span>;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> Case3&lt;T&gt;(T o)<font></font>
{<font></font>
    <span class="hljs-keyword">return</span> o <span class="hljs-keyword">switch</span><font></font>
    {<font></font>
        <span class="hljs-keyword">int</span> n =&gt; n,
        <span class="hljs-keyword">string</span> str =&gt; str.Length,<font></font>
        _ =&gt; <span class="hljs-number">0</span><font></font>
    };<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und lassen Sie uns den asm-Codegen vor meiner Optimierung (zum Beispiel für die Int-Spezialisierung) für alle drei Methoden sehen: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/iv/5m/8h/iv5m8hqdrwqazfpztoh_n0o0lho.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt nach meiner Verbesserung: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-t/f7/bx/-tf7bxj9jip9xzpa9nr3ccelv9w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsache ist, dass die Optimierung Muster von IL-Code gefunden hat</font></font><br>
<br>
<pre><code class="plaintext hljs">box !!T<font></font>
isinst Type1<font></font>
unbox.any Type2</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Importieren und Informationen über Typen konnte ich diese Opcodes einfach ignorieren und kein Boxing-Anboxing einfügen. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gleiche Optimierung habe ich übrigens auch </font><font style="vertical-align: inherit;">in Mono </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">implementiert</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Im Folgenden ist im Header der Optimierungsbeschreibung ein Link zu Pull-Request enthalten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PR </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># 1157</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> typeof (T) .IsValueType ⇨ wahr / falsch</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phase:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Importer </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier habe ich JIT geschult, um </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Type.IsValueType</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nach Möglichkeit </font><font style="vertical-align: inherit;">sofort durch </font><font style="vertical-align: inherit;">eine Konstante </font><font style="vertical-align: inherit;">zu ersetzen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ein Minuspunkt der Herausforderung und der Fähigkeit, in Zukunft ganze Bedingungen und Zweige auszuschneiden. Ein Beispiel:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">void</span> Foo&lt;T&gt;()<font></font>
{<font></font>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">typeof</span>(T).IsValueType)<font></font>
        Console.WriteLine(<span class="hljs-string">"not a valuetype"</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sehen wir uns den Codegen für die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foo &lt;int&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Spezialisierung vor der Verbesserung an: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/oa/28/lc/oa28lcmskvzitsjlpqr5dlh8uv4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und nach der Verbesserung: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zw/db/n_/zwdbn_ukemjzxf9qbkato_ptblm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dasselbe kann bei Bedarf mit anderen Type-Eigenschaften durchgeführt werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PR </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># 1157</font></font></a> <code>typeof(T1).IsAssignableFrom(typeof(T2)) ⇨ true/false</code></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phase:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Importer </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fast das Gleiche - jetzt können Sie in generischen Methoden nach Hierarchien suchen, ohne befürchten zu müssen, dass dies nicht optimiert ist, zum Beispiel:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">void</span> Foo&lt;T1, T2&gt;()<font></font>
{<font></font>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">typeof</span>(T1).IsAssignableFrom(<span class="hljs-keyword">typeof</span>(T2)))<font></font>
        Console.WriteLine(<span class="hljs-string">"T1 is not assignable from T2"</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf die gleiche Weise wird es durch eine Konstante ersetzt </font></font><code>true/false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die Bedingung kann vollständig gelöscht werden. </font><font style="vertical-align: inherit;">Bei solchen Optimierungen gibt es natürlich einige Eckfälle, die Sie immer berücksichtigen sollten: System .__ Freigegebene Generika, Arrays, Co (ntr) -Variabilität, Nullables, COM-Objekte usw. von Canon.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PR </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># 1378</font></font></a> <code>"Hello".Length ⇨ 5</code></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phase:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Importer </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass die Optimierung so offensichtlich und einfach wie möglich ist, musste ich viel schwitzen, um sie in JIT-e zu implementieren. Die Sache ist, dass JIT nichts über den Inhalt des Strings wusste, er sah String-Literale ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GT_CNS_STR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), wusste aber nichts über den spezifischen Inhalt des Strings. Ich musste ihm helfen, indem ich mich an VM wandte (um das oben erwähnte JIT-Interface zu erweitern), und die Optimierung selbst besteht im Wesentlichen aus ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paar Codezeilen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Abgesehen von den offensichtlichen Fällen gibt es eine ganze Reihe von Benutzerfällen, wie zum Beispiel: </font></font><b><code>str.IndexOf("foo") + "foo".Length</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu den nicht offensichtlichen, an denen Inlining beteiligt ist (ich erinnere Sie daran: Roslyn befasst sich nicht mit Inlining, daher wäre diese Optimierung darin wie alles andere unwirksam), ein Beispiel:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Validate</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> str</span>)</span> =&gt; str.Length &gt; <span class="hljs-number">0</span> &amp;&amp; str.Length &lt;= <span class="hljs-number">100</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Test</span>(<span class="hljs-params"></span>)</span> =&gt; Validate(<span class="hljs-string">"Hello"</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns den Codegen für </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test an</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Validieren ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inline): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sl/kl/dz/slkldz4tb8stxhrq_bhz7cmqkdm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und jetzt den Codegen nach dem Hinzufügen der Optimierung: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/4p/ao/f5/4paof5hshv_gsogtwqsocahc6vu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
d.h. </font><font style="vertical-align: inherit;">Inline die Methode, ersetzen Sie die Variablen durch String-Literale, ersetzen Sie .Length von Literalen durch echte String-Längen, falten Sie die Konstanten, löschen Sie den toten Code. </font><font style="vertical-align: inherit;">Übrigens, da JIT jetzt den Inhalt einer Zeichenfolge überprüfen kann, haben sich Türen für andere Optimierungen in Bezug auf Zeichenfolgenliterale geöffnet. </font><font style="vertical-align: inherit;">Die Optimierung selbst wurde in der Ankündigung der ersten Vorschau von .NET 5.0 erwähnt: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Abschnitt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbesserungen der Codequalität in RyuJIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PR </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># 1644:</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimierung gebundener Prüfungen.</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phase:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eliminierung von Grenzprüfungen </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für viele ist es kein Geheimnis, dass jedes Mal, wenn Sie über einen Index auf ein Array zugreifen, die JIT eine Überprüfung für Sie einfügt, dass das Array nicht darüber hinausgeht, und in diesem Fall eine Ausnahme auslöst - im Fall einer fehlerhaften Logik konnten Sie dies nicht Um einen zufälligen Speicher zu lesen, erhalten Sie einen Wert und fahren Sie fort.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> index</span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">// if ((uint) array.Length &lt;= (uint) index)</span>
    <span class="hljs-comment">//     throw new IndexOutOfRangeException();</span>
    <span class="hljs-keyword">return</span> array[index];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine solche Überprüfung ist nützlich, kann jedoch die Leistung erheblich beeinträchtigen: Erstens wird eine Vergleichsoperation hinzugefügt und Ihr Code wird unverzweigt, und zweitens wird Ihrer Methode ein Ausnahmeaufrufcode mit allen Konsequenzen hinzugefügt. In vielen Fällen kann die JIT diese Überprüfungen jedoch entfernen, wenn sie sich selbst beweisen kann, dass der Index niemals darüber hinausgeht oder dass es bereits eine andere Überprüfung gibt und Sie keine weitere hinzufügen müssen - Eliminierung von Bounds (Range) Checks. Ich habe mehrere Fälle gefunden, in denen er sie nicht bewältigen und korrigieren konnte (und in Zukunft plane ich weitere Verbesserungen dieser Phase).</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> item = array[index &amp; mask];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier in diesem Code sage ich JIT, dass </font></font><code>&amp; mask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Index von oben im Wesentlichen auf einen Wert begrenzt ist </font></font><code>mask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, d. H. </font><font style="vertical-align: inherit;">Wenn der Wert </font></font><code>mask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die Länge des Arrays </font><font style="vertical-align: inherit;">JIT bekannt sind </font><font style="vertical-align: inherit;">, können Sie keine gebundene Prüfung einfügen. </font><font style="vertical-align: inherit;">Gleiches gilt für%, (&amp; x &gt;&gt; y) Operationen. </font><font style="vertical-align: inherit;">Ein Beispiel für die Verwendung dieser Optimierung in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aspnetcore</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir wissen, dass unser Array beispielsweise 256 oder mehr Elemente enthält, kann unser unbekannter Indexer vom Bytetyp, egal wie sehr er es versucht, niemals außerhalb der Grenzen austreten. </font><font style="vertical-align: inherit;">PR: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/dotnet/coreclr/pull/25912</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PR </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># 24584:</font></font></a> <code>x / 2 ⇨ x * 0.5</code></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phase:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Morph </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C dieser PR und begann meinen erstaunlichen Sprung in die Welt der JIT-Optimierungen. </font><font style="vertical-align: inherit;">Die Operation "Division" ist langsamer als die Operation "Multiplikation" (und wenn für ganze Zahlen und allgemein - eine Größenordnung). </font><font style="vertical-align: inherit;">Funktioniert für Konstanten, die nur der Zweierpotenz entsprechen, Beispiel:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> <span class="hljs-title">DivideBy2</span>(<span class="hljs-params"><span class="hljs-keyword">float</span> x</span>)</span> =&gt; x / <span class="hljs-number">2</span>; <span class="hljs-comment">// = x * 0.5; </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Codegen vor der Optimierung: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/df/vo/mf/dfvomfc6foisqpk9uvq8nfihfzy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und danach: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ij/xk/u5/ijxku5zq0hhxmltazwxgfq1tvss.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir diese beiden Anweisungen für Haswell vergleichen, wird alles klar:</font></font><br>
<br>
<pre><code class="plaintext hljs">vdivss (Latency: 10-20,  R.Throughput: 7-14)<font></font>
vmulss (Latency:     5,  R.Throughput:  0.5)<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Darauf folgen Optimierungen, die sich noch in der Codeüberprüfungsphase befinden, und nicht die Tatsache, dass sie akzeptiert werden.</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PR </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># 31978:</font></font></a> <code>Math.Pow(x, 2) ⇨ x * x</code></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phase:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Importer Hier ist </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
alles einfach: Anstatt pow (f) für einen recht beliebten Fall aufzurufen, können Sie ihn bei konstantem Grad 2 (also auch für 1, -1, 0 kostenlos) zu einem einfachen x * x erweitern. </font><font style="vertical-align: inherit;">Sie können alle anderen Grade erweitern, müssen jedoch auf die Implementierung des "Fast Math" -Modus in .NET warten, in dem die IEEE-754-Spezifikation aus Gründen der Leistung vernachlässigt werden kann. </font><font style="vertical-align: inherit;">Beispiel:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> <span class="hljs-title">Pow2</span>(<span class="hljs-params"><span class="hljs-keyword">float</span> x</span>)</span> =&gt; MathF.Pow(x, <span class="hljs-number">2</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Codegen vor der Optimierung: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1o/7m/zw/1o7mzwatkp3kritfyahj_zjhija.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und danach:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/el/9g/19/el9g19y1rul_r4sej7fx7sixiso.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PR </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># 33024:</font></font></a> <code>x * 2 ⇨ x + x</code></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phase:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Absenken </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auch eine recht einfache Mikro- (Nano-) Piphol-Optimierung ermöglicht es Ihnen, mit 2 zu multiplizieren, ohne die Konstante in das Register zu laden.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> <span class="hljs-title">MultiplyBy2</span>(<span class="hljs-params"><span class="hljs-keyword">float</span> x</span>)</span> =&gt; x * <span class="hljs-number">2</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Codegen vor der Optimierung: Nachher </font></font><br>
<br>
<img src="https://habrastorage.org/webt/e7/4s/-r/e74s-rigvhc6eh14gl7ygnbeqva.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d5/wg/ru/d5wgrutrxfvbsccck-hhjdvw37w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen ist der Befehl in </font><font style="vertical-align: inherit;">Bezug </font></font><code>mul(ss/sd/ps/pd)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf Latenz und Durchsatz dieselbe wie </font></font><code>add(ss/sd/ps/pd)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber die Notwendigkeit, die Konstante „2“ zu laden, kann die Arbeit etwas verlangsamen. </font><font style="vertical-align: inherit;">Hier, im obigen Beispiel des Codegens, habe ich </font></font><code>vaddss</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alles im Rahmen eines Registers gemacht.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PR </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># 32368:</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimierung von Array.Length / c (oder% s)</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phase:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Morph </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist einfach so passiert, dass das Längenfeld von Array ein vorzeichenbehafteter Typ ist und das Teilen und der Rest durch eine Konstante von einem vorzeichenlosen Typ (und nicht nur einer Zweierpotenz) viel effizienter ist. Vergleichen Sie einfach diesen Codegen: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7u/cf/0a/7ucf0a2z26ew1ndszgycipb4dxw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meine PR erinnert JIT nur daran </font></font><code>Array.Length</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl signifikant, kann die Länge des Arrays NIEMALS (es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sei denn, Sie sind Anarchist</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) kleiner als Null sein. Dies bedeutet, dass Sie es als vorzeichenlose Zahl betrachten und einige Optimierungen wie für uint anwenden können.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PR </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># 32716:</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimierung einfacher Vergleiche in verzweigungslosem Code</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phase:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussanalyse </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist eine weitere Klasse von Optimierungen, die mit Basisblöcken anstelle von Ausdrücken innerhalb eines Blocks arbeitet. </font><font style="vertical-align: inherit;">Hier ist JIT etwas konservativ und bietet Raum für Verbesserungen, zum Beispiel cmove-Einsätze, wo dies möglich ist. </font><font style="vertical-align: inherit;">Ich habe mit einer einfachen Optimierung für diesen Fall begonnen:</font></font><br>
<br>
<pre><code class="cs hljs">x = condition ? A : B;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn A und B Konstanten sind und der Unterschied zwischen ihnen beispielsweise Eins ist, können </font></font><code>condition ? 1 : 2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir, da wir wissen, dass die Vergleichsoperation an sich 0 oder 1 zurückgibt, den Sprung durch add ersetzen. </font><font style="vertical-align: inherit;">In Bezug auf RyuJIT sieht es ungefähr so ​​aus: Ich </font></font><br>
<br>
<img src="https://habrastorage.org/webt/am/y8/rv/amy8rv0tjz3vxzelpbz1lhgqr6a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
empfehle, die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschreibung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der PR selbst zu sehen, ich hoffe, dass dort alles klar beschrieben ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht alle Optimierungen sind gleichermaßen nützlich.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Optimierungen erfordern eine ziemlich hohe Gebühr: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
* Erhöhen = Komplexität des vorhandenen Codes für Support und Lesen </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
* Mögliche Fehler: Das Testen von Compiler-Optimierungen ist wahnsinnig schwierig und leicht, etwas zu übersehen und eine Art Segfault von Benutzern zu erhalten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
* Langsame Kompilierung </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
* Vergrößerung des JIT-Binars </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie bereits verstanden haben, werden nicht alle Ideen und Prototypen von Optimierungen akzeptiert, und es muss nachgewiesen werden, dass sie das Recht auf Leben haben. Eine der akzeptierten Möglichkeiten, dies in .NET zu beweisen, besteht darin, das Dienstprogramm jit-utils auszuführen, mit dem AOT eine Reihe von Bibliotheken (alle BCL und Corelib) kompiliert und den Assembler-Code für alle Methoden vor und nach Optimierungen vergleicht. So </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sieht dieser Bericht</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nach Optimierung aus</font></font><code>"str".Length</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Neben dem Bericht gibt es auch einen bestimmten Personenkreis (z. B. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jkotas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), der auf einen Blick die Nützlichkeit bewerten und alles aus der Höhe ihrer Erfahrung und ihres Verständnisses heraus hacken kann, welche Stellen in .NET ein Engpass sein können und welche nicht. </font><font style="vertical-align: inherit;">Und noch etwas: Beurteilen Sie die Optimierung nicht anhand des Arguments „Niemand schreibt“, „es wäre besser, nur in Roslyn eine Warnung anzuzeigen“ - Sie wissen nie, wie Ihr Code aussehen wird, wenn JIT alles Mögliche einfügt und Konstanten ausfüllt.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de493574/index.html">Lokaler Proxy zum Filtern des Browserverkehrs</a></li>
<li><a href="../de493578/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 407 (16. - 22. März 2020)</a></li>
<li><a href="../de493580/index.html">Lernen, Microservices bereitzustellen. Teil 4. Jenkins</a></li>
<li><a href="../de493582/index.html">Künstlicher Sommer: weit ultraviolett gegen Coronavirus</a></li>
<li><a href="../de493584/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 503 (03.03.2020-09.03.2020)</a></li>
<li><a href="../de493590/index.html">Warum Cisco AnyConnect nicht nur ein VPN-Client ist</a></li>
<li><a href="../de493594/index.html">PHP Digest Nr. 176 (11. - 23. März 2020)</a></li>
<li><a href="../de493596/index.html">Der Mann, der es nicht eilig hatte</a></li>
<li><a href="../de493598/index.html">Verstecke einen Teil der Telefonnummer</a></li>
<li><a href="../de493604/index.html">Digitale Veranstaltungen in Moskau vom 23. bis 29. März</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>