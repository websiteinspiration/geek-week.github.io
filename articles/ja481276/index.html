<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎢 👨🏾‍🍳 🔜 12年間のYPとコンパイラーの作成方法 ✒️ 🥦 🎰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="物語の出来事は時系列で伝えられます。何かの出来事が無関係であると思われる場合は、おそらくそうではありません。私がこの出来事が後で言及する理由が明らかになる瞬間だけです。私が作成する言語は時間の経過とともに変化しました。その言語をよく読んで理解できず、さらに読むことができない場合は、最後まで読むことを...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>12年間のYPとコンパイラーの作成方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481276/"><img src="https://habrastorage.org/webt/4f/vm/nz/4fvmnzs3xgp7ey8bqljrz13xl1k.jpeg"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物語の出来事は時系列で伝えられます。何かの出来事が無関係であると思われる場合は、おそらくそうではありません。私がこの出来事が後で言及する理由が明らかになる瞬間だけです。</font><font style="vertical-align: inherit;">私が作成する言語は時間の経過とともに変化しました。その言語をよく読んで理解できず、さらに読むことができない場合は、最後まで読むことをお勧めします。おそらくあなたの意見が変わるでしょう。</font><font style="vertical-align: inherit;">記事の画像は言語の主な特徴を反映していませんが、実際には言語にリンクはありません。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読者こんにちは！私の名前はアレクサンダーです。私はベラルーシの小さな町（1万人未満）で生まれました。私の家族は貧乏で、おもちゃはほとんどなく、コンピューターやコンソールについては、どもることはできません。家族が貧しかったという事実にもかかわらず、母親には貧しい親戚がいませんでした。そして、ある日（2001年のどこかで）、これらの同じ親族はバイトコンピュータ（ZX Spectrum 48kのソビエトアナログ）を私たちに与えます。私の喜びは限界がありませんでした！すぐにゲームを始めました。このコンピューター上のゲームは、通常のテープカセットからダウンロードされました。 1つのゲームのダウンロードは約5分続きましたが、信号の質が悪いために、確率は決して低くありませんでした。ダウンロードが成功する可能性を高めるには、アルコールで拭いてテープレコーダーの読み取りヘッドの位置を調整しました。ロード中のこのすべてのシャーマニズム、ロードの持続時間、およびゲームで持続できないことは、徐々にゲームへの興味を失い始めたという事実につながりました。しかし、Byteとともに、このコンピュータの操作に関する本も提示されました。 「バイト」の特徴をもっと知るためにこの本を読むことにしました。この本は、Byteに組み込まれたBASICプログラミング言語の教科書であることがわかりました。この本は、Byteに組み込まれたBASICプログラミング言語の教科書であることがわかりました。この本は、Byteに組み込まれたBASICプログラミング言語の教科書であることがわかりました。</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本から手に入れた最初のプログラムを取り、それをコンピューターにコピーして、それを開始しました。画面に丸が見えたとき、私はただ驚いてしまいました。それは何とも言えない感じでした。やってきて、プログラムの中で色々な数字を変え始めて、形を変えてから形を変えて、何度も何度もプログラムを始めると、まるで別の宇宙にいるかのように感じて勉強を始めました。この本の基礎をすべて読んだ後、私は自分のプログラムを作成し始めました。最初に私はそれらを紙に書いて、それらを編集して頭の中で実行し、それをコンピューターに転送して何が起こるかを調べました。私がテキストなしで最初のプログラムを書いた後、私は気づきました-これは私のものです。一日中、紙にさまざまなプログラム（ゲームを含む）を書き始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
約1年後、上記のイベントの後、コンピューターサイエンスが私の学校に現れます。時間の経過とともに、レッスンではIntAlプログラムでプログラミングを学び始めます。レッスンでは、プログラミングに関係のない他の多くの教材があったので、少しプログラミングしました。また、順番にコンピューターで作業しました（学生よりコンピューターの数が少なかった）。しかし、私たちの学校にはコンピュータサイエンスの選択科目があり、私はそこに登録することを決めました。学部では、ターボパスカルの勉強を始めました。最初から、私は本当に言語が好きでした。レコード（これらは構造体）、ユニット（これらもモジュールとライブラリーです）、手順、関数がありました。それは、私が以前に知っていたすべてのものよりも美しい、ある種の新しい美しい世界でした。パスカルの勉強を始めて、ようやくプログラマーになりたいと思いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中学2年生を卒業した後、大学に行くか10年生にするかを決めました。私は物理学、数学、天文学、コンピューターサイエンスの詳細な研究を行っているコンピューターオペレーターを専門とする大学に行くことにしました。私はこの専門を卒業すれば、プログラマーとして大学に入学するのが簡単になると多くの人が言っています。入学試験を解くのに3時間かかりましたが、30分しか使用しませんでした。そのうちの10時間で、すべてが正しいかどうかを確認しました。入りました！ Lyceumでは、Pascalの研究を続けましたが、Photoshop、Corel Draw、Excel、Windowsコマンドライン、.batファイルの研究も始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が何をしたかを学ぶと、「バイト」をくれた同じ親戚から、シングルコアインテルCeleron 800 Mhz、64 Mb RAM、14 Gbハードドライブ、解像度640 x 480の統合ビデオ、および16色。両親は離陸し、64 MbのRAMとMatrox Milenium g400 16 Mbビデオカードを購入してアップグレードしました。1600万色をサポートし、解像度は800 x 600（モニターの制限）でした。当時、ほとんど誰もインターネットにアクセスできず、すべての情報は主に店頭で販売されていたディスクから取得されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の友人の1人がいくつかのDelphiプログラミングCDを購入しました。CDには、Borland Delphi 7、一連のチュートリアル、一連のコンポーネント、およびDelphiに関する多くの質問とこれらの質問に対する回答（少なくともオフラインのStackOverflowの一種）が含まれたプログラムが含まれていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてがとてもシンプルで便利だったので、プログラムは次々と書かれました。また、Lyceumライブラリには、Cでのプログラミングに関する教科書がありました。それを読んだ後、Cがまったく好きではないことに気付きました。Pascal、特にDelphiが何倍も好きでした。 Cはより複雑で便利ではありませんが、Cが好きなのは、開始と終了の代わりに中括弧が使用されていることだけです。しかし、パスカルが私にとって理想的な言語であったと考える必要はありません。時間が経つにつれて、その言語の多くのことが私に（始まりの終わりに加えて）迷惑をかけ始めました。たとえば、文字列と配列を次のフィールドを持つ構造にする必要があります。データのあるメモリ領域へのポインタ、要素の数、ポインタが指すメモリ領域を保持できる要素の最大数、これにより、複数の配列または文字列が同じメモリ領域を指すことができ、要素をコピーせずに別の配列の一部から配列を作成できます。後で判明したように、私が望んだような配列はスライスと呼ばれます。それから私はそのような修正されたパスカルから通常に翻訳する翻訳者を書きたかったのですが、私はこの考えを放棄しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Delphiを紹介してくれた同じ友人は、ある会社が無料のディスクをUbuntuとKubuntuとともに無料で送っていると言っていました。それが何なのかさえ知りませんでしたが、彼は私に2枚のディスクを無料でくれました。 Ubuntuは私から始まったわけではありませんでしたが、Kubuntuは起動して非常にうまくいきました。私は驚いた-Windowsとdos以外に何か他にあることが判明した。私は本当にコンピュータにKubuntuを置いて研究したかったのですが、14 Gbドライブは断固としてそれに反対でした。さらに、この時点ですでにインターネットアクセス（5 Kb /秒）があり、Kubuntuのモデムは機能していませんでした。そのため、Kubuntuの入ったディスクを棚に投げました。突然、同じ友人がある種のアセンブラーで激怒し始め、すべてが何らかの種類のプログラムを見せてくれましたが、50行のアセンブラーがDelphiの1行に置き換えられたので、彼らは私を笑わせるだけでした。とはいえ、友人が私に説得してFASMとアセンブリブックの入ったディスクを渡してくれた。私はアセンブラが好きではありませんでしたが、FASMのマクロはクールです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高校を卒業したので、今度は大学に行きます。けれども、Lyceumが終わる直前に、私はインターネットでお金を稼ぎ始めました。成功した起業家のふりをして、無警戒なユーザーに次の取引を提供するインターネット上の詐欺師がたくさんいます-「私たちに少なくとも1ドルを与え、2週間後に私たちは2ドルを払い戻します」。奇妙なことに、これらの詐欺師に1ドルを与えると、2週間後に実際に2ドルを返しますが、10を与えると、2週間後に、アカウントに20ドルあることが示されますが、引き出すことはできません。たくさんのメールボックスを作成し、さまざまなメールボックスを使用してIPアドレスを変更しました（動的IPがありました）、詐欺サイトに多数のアカウントを登録し、毎回1ドルを追加しました。この方法ですでに少し稼いでいるとすれば、「大学に行ってはいけないのでは？大学がなくても好きなようにプログラミングできます。」私はまた、インターネットでプログラマーが塔を必要としないと彼らがしばしば書いているという事実によって、この考えに傾倒しました。 「行動するべきか行動しないべきか？」と考えていたとき、人生そのものが私のために決めました。父は出会い系サイトに登録し、自分への新たな愛を見つけ、母親と一緒に私を投げました。勉強している間、母だけではサポートできないことに気づき、大学に入学しませんでした。体育館の後、私はある企業で一年働かなければなりませんでした。私は食料品店で仕事を得て、TTNを抽出し、その店に来た商品をコンピューターに入力することに従事していました。店で少し働いた後、店の製品のデータベースを分析して潜在的な問題を探すプログラムを書きました。その後会社では、店を所有し、プログラマーとして彼らに転勤することを申し出たが、私が高等教育を受けていないことを知ったとき、彼らは考えを変えた。そして、私は店で働き続けました。私の給料は悪くなかったが、詐欺師からの収入は非常に控えめだった。アカウントの登録に時間がかかるため、収入は低く、ベラルーシではインターネットお金を扱うのは非常に困難でした。 Liberty Reserve-インターネットマネー。コスタリカの銀行から提供されたインターネットマネーで、顧客に関する情報を政府に提供しなかったため、ほとんどの詐欺師がLiberty Reserveを使用しました。アカウントの登録に時間がかかるため、収入は低く、ベラルーシではインターネットお金を扱うのは非常に困難でした。 Liberty Reserve-インターネットマネー。コスタリカの銀行から提供されたインターネットマネーで、顧客に関する情報を政府に提供しなかったため、ほとんどの詐欺師がLiberty Reserveを使用しました。アカウントの登録に時間がかかるため、収入は低く、ベラルーシではインターネットお金を扱うのは非常に困難でした。 Liberty Reserve-インターネットマネー。コスタリカの銀行から提供されたインターネットマネーで、顧客に関する情報を政府に提供しなかったため、ほとんどの詐欺師がLiberty Reserveを使用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ベラルーシでこのお金を購入するのは特に困難でした。自動交換機では7倍の金額を支払う必要があり（記憶が機能する場合）、人々からの購入は危険なビジネスだったからです。私は詐欺師のごまかしをやめて、仕事だけから収入を得ました。一年働いた後、もっと良いものを探すことにしました。手元に十分な金額があり、コンピューターをアップグレードすることにしました。新しいPCの特性：AMD Athlon 64 x2 2600（以前のプロセッサにはなかったSSE2命令をサポート。これは重要です）、1 GbのRAM、80 Gbのハードドライブ。私はKubuntuを学びたかったが、ハードドライブが小さすぎたので、ドライブに問題がなかったので、LinuxとWindowsを同時にインストールすることにしました。コンピューターのドライブストアに行ったとき、openSUSE 10.2ドライブを購入しました。私の新しい仕事は、私の市の会社の1つでコンピューターを修理することで、試用期間は1か月でした。この会社の社長と彼の妻は、ある種の会計ソフトウェアを開発していて、私がプログラミングが好きだということを知り、将来の売り上げの一部に参加することを申し出ましたが、Visual FoxProとSQLで開発していたため、これらの言語を学ぶ必要がありました。私は同意しました。 1か月後、彼らは私を雇うつもりはないことが判明しましたが、休暇中に戻ってきた従業員を彼が戻ったときに取り替える必要があり、彼らはもう私を必要としないが、それでも助けてほしいと言った開発に伴い、もちろん私は拒否し、新しい仕事を探し始めました。数か月の調査に失敗して、私は補助作業員として建設現場に行ったという事実につながりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
店員さんの給料は店内のコンピューターオペレーターより3.5倍低かったのですが、仕事はずっと楽だと言わざるを得ません（私は強者でした）。週末に、私はFASMを使用して、これらの新しいSSE2命令を学び始めました。実験して、いくつかのタスクでは、これらの指示は生産性を大幅に向上させることができることに気付きました。ソフトウェア開発者がSSE2命令をアプリケーションに埋め込む方法に興味を持ちました。SSE2を使用することが理にかなっているすべてのタスクがそれらを使用して解決されると、プログラムはSSE2サポートのないコンピューターでは実行できませんが、それらを使用しないと、プログラムが実行されます。遅くなります。もちろん、プロセッサがSSE2をサポートしているかどうかをプログラムの最初で確認し、結果に応じてさまざまなコードを実行することができます。ただし、この場合、開発とテストの複雑さが増し、RAMとプロセッサキャッシュの消費が増加します。複数のプログラムを分析した後、ほとんどのプログラムがSSE2を使用していないことがわかりました。そして、私は自分に尋ねました。「なぜコンパイラーはマクロを使用してアセンブラーにコンパイルしないのですか。エンドユーザーのコンピューターでは、一部のユーティリティがマクロに必要な定数を入力せず、その後バイナリが作成されます。」そして私は、Lyceumで発明した修正版のpascalを思い出して、そのようなコンパイラーを作成することにしました。私はまた、ジェネリックを言語に追加することを決定し、言語は次のようになり始めました。そして、私は自分に尋ねました。「なぜコンパイラーはマクロを使用してアセンブラーにコンパイルしないのですか。エンドユーザーのコンピューターでは、一部のユーティリティがマクロに必要な定数を入力せず、その後バイナリが作成されます。」そして、私は、Lyceumで発明した修正版のパスカルを思い出して、そのようなコンパイラーを作成することにしました。私はまた、ジェネリックを言語に追加することを決定し、言語は次のようになり始めました。そして、私は自分自身に尋ねました。「なぜコンパイラーはマクロを使用してアセンブラーにコンパイルしないのですか。エンドユーザーのコンピューターでは、一部のユーティリティがマクロに必要な定数を入力せず、その後、バイナリーが作成されます。」そして、私は、Lyceumで発明した修正版のパスカルを思い出して、そのようなコンパイラーを作成することにしました。私はまた、ジェネリックを言語に追加することを決定し、言語は次のようになり始めました。</font></font><br>
<br>
<pre><code class="delphi">type Point(a){<font></font>
    x, y: a;<font></font>
}<font></font>
<font></font>
type Line(a){<font></font>
    a, b: Point(a);<font></font>
}<font></font>
<font></font>
function createLine(a, b: Point(a)) Line(a){<font></font>
    result.a = a;<font></font>
    result.b = b;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間が経つにつれ、インターネットは通常の速度で動作し、Windowsを完全に放棄してLinuxを採用しました（Windows用のプログラムを搭載したディスクが多数あり、低速のインターネットを使用するLinux用のディスクをダウンロードするのは問題がありました）。当時、私はUbuntu 8.10ディストリビューションを持っていましたが、他のディストリビューションに積極的に興味を持っていました。ある時点で、Gentooというディストリビューションを試すことにしました。 Gentooのインストール方法を理解して、私は使用フラグについて学び、それらのサポートを私の言語に追加する必要があることにすぐに気付きました。つまり、私の言語で書かれたプログラムをインストールするときに、アセンブラコードに定数を追加するユーティリティは、開発者が開発中に決定した定数の意味も尋ね、これらの定数に応じて、マクロは異なるコードを挿入します。ほぼ完成したコンパイラ開発、私はフォーラムからいくつかのLLVMについて学びます。そこには特定のアセンブラーのような言語のLLVM IRがあります。それが何で、何が食べられるかを少し調べた後、私はFASMではなくLLVM IRでコンパイルすることにしました。コードを最適化する方法を知っていて、コンパイラーは実際には何も最適化しなかったため、LLVM開発者がおそらく追加することは言うまでもありません。新しい最適化。つまり、これを行う必要がなく、他の問題に集中できます。そして、コンパイラを書き直し始めました。 LLVM IRでは、指示に加えて、関数パラメーターと関数引数パラメーターもありました。たとえば、リンクである関数引数をコピーしないように指定できます。そして、私はそのようなパラメーターを追加することにしました、それらは関数を宣言するときではなく、呼び出すときに指定する必要があり、LLVM IRとは異なり、これらのパラメータは、最適化のために本質的に有益ではありませんでしたが、動作の要件でした。例：</font></font><br>
<br>
<pre><code class="delphi">function inc(a: ^Integer) Integer{<font></font>
    result = a^ + 1;<font></font>
}<font></font>
<font></font>
procedure foo(){<font></font>
    var<font></font>
        a: ^Integer;<font></font>
        b: Integer;<font></font>
    ...<font></font>
    // <font></font>
    ...<font></font>
    b = inc(ro nocp a) //   inc       ,     <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間が経つにつれ、ミンスクに向けて出発し、ローダーを手に入れました。給与は非常に高かった（月額800ドル）が、開発期間は短縮されました。フォーラムを読んでいると、Haskell言語への参照に出くわすことがよくありました。参照には通常、「脳が爆発する」、「非常に珍しい」などのフレーズが付随し、理解しにくいモナドがいくつかあることも言及されていました。私はそれに耐えられず、この言語を学ぶことにしました。たくさんのHaskellチュートリアルをダウンロードした後、私は学び始めました。私は最初の教科書を取りました、それは非常に濁った書かれています-削除され、2番目を取り、すべてのページがシャッフルされるように読んで感じます-削除されました、私は3番目を取り、本はインテリジェントに書かれていますが、例を通して研究されるように設計されているようです（そして私は理論を研究したい練習でそれを補強する）-削除され、それは4番目になります、それはインテリジェントに書かれています、それは理論を通して研究されます-それは必要であるようですこの本のタイトルは「Haskell for Goodを探検する」です。読んでいる間、私は一つの質問もしなかったし、モナドについても何の問題もなかった。私はその本がとても好きだったので、紙のコピーを買いに行きました。本を最後まで読んだ後、それまでに見たすべての言語がHaskellの背景から消えていくことに気づきました。それは、他の言語レベルでは達成できない、新しいもののようなものです。私はHaskellをより深く研究することに決め、Haskellでコースを受講し（同時に統計の基礎とPython言語について）、関数型プログラミングと教会ラムダ計算に関する講義を見始めました。私が以前見たすべての言語は、Haskellの背景から消えていくだけです。それは、他の言語では達成できない、ある種の新しいレベルです。私はHaskellをより深く学ぶことに決め、Haskellでコースを受講し（同時に統計の基礎とPython言語について）、関数型プログラミングと教会ラムダ計算に関する講義を見始めました。私が以前見たすべての言語は、Haskellの背景から消えていくだけで、他の言語では達成できない、ある種の新しいレベルです。私はHaskellをより深く研究することに決め、Haskellでコースを受講し（同時に統計の基礎とPython言語について）、関数型プログラミングと教会ラムダ計算に関する講義を見始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は本当にカテゴリーの理論を勉強したかったのですが、この理論をシンプルで理解できる言語で説明する資料は見つかりませんでした。 Haskellであらゆる種類の小さなユーティリティを書いた。ある時点で、私はジュニアHaskell開発者の欠員に偶然出会いました。要件を読んだ後、私はすべての要件に適合していることに気付き、それを試してみることにしました。履歴書を書いて応募しました。彼らが私のスキルをテストするためのテストタスクを送ってくれると思って、IDEとfirefox + googleを開いて回答を待ったところ、丁寧に送られた約1時間半後に回答が返ってきました。この空席はさらに1年間サイトに留まりました。 Haskellが私の主な言語になり、すべてを書き始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
やがて、宣言型プログラミングを使用する場合にのみHaskellが非常に優れていることに気付きましたが、このシナリオでは、プログラムが遅くなり、過剰な量のメモリを消費することが判明したため、効率的にHaskellを記述できますが、この場合、命令型アプローチを使用する必要があり、Haskellでの記述は必須です-怪しい喜び！私はHaskellを放棄してコンパイラの開発を続けましたが、高次関数を言語に追加して中かっこを削除し、インデントを使用してコードを構造化しました（Haskellの場合と同様）。言語は次のようになりました：</font></font><br>
<br>
<pre><code class="delphi">function lineLength(line: Line) Real<font></font>
    result = sqrt(sqr(line.a.x - line.b.x) + sqr(line.a.y - line.b.y))<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ある時点で危機が発生し、私の800ドルが400ドルになり、120ドル+仕事への道を借り、仕事+共同給与から約250ドルが残っています。通常のアパートに住み、自分の街で同じくらいのお金を稼ぐことができるのに、なぜ私は賃貸部屋に住んで250ドルを手に入れなければならないのですか？私はやめることにしました。解任後、私は一定の金額を残しました。それを考えた後、私は決定しました。私はベラルーシのどの地域でも家を借り、どこでも仕事をせず、何にも邪魔されずに、コンパイラーを追加します。私は1つの町で1か月あたり35ドルで家全体を見つけました。家は大きくなく、古く、トイレは外にあり、シャワーとバスルームはありません。しかし、値札はとても魅力的でした、そして、ホステスが言った、私は庭にあるすべてのものを外に食べることができ、そして野菜と果物がたくさんあったので、私は食べ物をたくさん節約することができました。私は同意し、2か月分の家賃を支払いました。すべてのものを運ぶのに一日中かかりました、そして私は夜だけで解決しました、それで私が家に帰ったとき私はすぐにベッドに横になって眠りました理由です。目が覚めたとき、テーブルの袋に残していたパンがねずみに食べられているのを見ました。食べ物を金属製の冷蔵庫に隠します」-その瞬間を考えて外に出ました。外に出ると、足にニブル、耳が転がるのを感じ、ノミの束（14ピース）を見ました。アパートを調べたところ、私が寝ている部屋から離れた家のある場所に住んでいることがわかりましたが、外に出るためには、彼らの隠れ家を渡らなければなりません。一般的に、ほとんどの場合私は安全な部屋にいました（そしてそのときノミは実際には現れませんでした）、そして私が外に出る必要があったとき、私はすぐにノミの部屋を走り回り、ノミを1匹も拾わずに出かけることもありましたが、ほとんどの場合1〜2匹はまだしがみついています。定期的に母に電話をかけ、会話の中でノミについて話しました。話し合った後、母は私が家に帰ることに同意しましたが、3か月は仕事を探していませんでしたが、コンパイラーを書いていたので、彼女は私を困らせませんでした。帰国後、3か月足らずでコンパイラを完成させました。先に進む前に、私が開発で使用するアプローチについてお話ししたいと思います。時間の経過とともに、私は自分でアプローチを開発し、常にそれを順守しようとしました（たまにそれが私を駆り立てて、私がそれを使用するのを忘れてしまう場合があります）。話し合った後、母は私が家に帰ることに同意しましたが、3か月は仕事を探していませんでしたが、コンパイラーを書いていたので、彼女は私を困らせませんでした。帰国後、3か月足らずでコンパイラを完成させました。先に進む前に、私が開発で使用するアプローチについてお話ししたいと思います。時間の経過とともに、私は自分でアプローチを開発し、常にそれを遵守しようとしました（ただし、それがときどき私を動かし、使用するのを忘れてしまいます）。話し合った後、母は私が帰国することに同意しましたが、3か月間仕事を探していなかったので、コンパイラーを作成しましたが、そのとき彼女は私に迷惑をかけませんでした。帰国後、3か月足らずでコンパイラを完成させました。先に進む前に、私が開発で使用するアプローチについてお話ししたいと思います。時間の経過とともに、私は自分でアプローチを開発し、常にそれを遵守しようとしました（ただし、それがときどき私を動かし、使用するのを忘れてしまいます）。時間の経過とともに、私は自分でアプローチを開発し、常にそれを遵守しようとしました（ただし、それがときどき私を動かし、使用するのを忘れてしまいます）。時間の経過とともに、私は自分でアプローチを開発し、常にそれを遵守しようとしました（ただし、それがときどき私を動かし、使用するのを忘れてしまいます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプローチは次のとおりです。1つを除いて、可能なすべての型と関数を含むライブラリがあると想像します。この不足している関数を（架空のライブラリーの関数と型のすべての機能を使用して）作成し、コンパイラーを起動します。型が十分でない場合は作成し、関数が十分でない場合は、この関数を作成する必要があります。今私は自分のアプローチを変更したことを言わなければなりません、そしてライブラリが関数と型を持っていると想像する代わりに、クラスとメソッドがあると想像します（言語がオブジェクト指向ではない場合でも）。コンパイラーを完成させたとき、もちろんたくさんのエラーがありました。私はバグの検索と修正を始めましたが、可能性（ジェネリック、関数引数のパラメーター、型クラス、高次関数）が多数あるため、多くのエラーがあり、私が開発中に使用したアプローチのために、1つの関数を変更すると、多数の関数グループが変更される可能性があります。長い間エラーを修正していました（ちなみに、エラーを探すだけでなく、ユニットテストのみを書くのは嫌いです）。コードを60％書き換える必要のあるエラーを見つけました。私は絶望に陥り、自分の言語をシンプルにする方法を考えましたが、必要なものはすべてサポートしています。私はOOPをベースにして、言語を単純にするために、次のルールを守ることを試みることにしました。コードの60％を書き換える必要のあるエラーを修正しました。私は絶望に陥り、自分の言語をシンプルにする方法を考えましたが、必要なものはすべてサポートしています。私はOOPをベースにして、言語を単純にするために、次のルールを守ることを試みることにしました。コードの60％を書き換える必要のあるエラーを修正しました。私は絶望に陥り、自分の言語をシンプルにする方法を考えましたが、必要なものはすべてサポートしています。私はOOPをベースにして、言語を単純にするために、次のルールを守ることを試みることにしました。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス、プロパティ、およびメソッドのみが言語に含まれている必要があります（他にはありません）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のクラスの各メソッドは、1つのLLVM IR関数にコンパイルする必要があります。</font><font style="vertical-align: inherit;">つまり、クラスAにはメソッドmがあり、それに渡される引数に関係なく、常に単一のLLVM IR関数にコンパイルされますが、BがAを継承する場合、メソッドmはすでに別のLLVM IR関数にコンパイルされています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ管理は自動化する必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">言語にリンクがあってはなりません。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルールを破らずに必要な言語機能を作る方法を考え始めました。</font><font style="vertical-align: inherit;">そしてこれが私が思いついたものです：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haskellから型クラスの類似体を作る方法は？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非抽象クラスに継承するときに上書きする必要があるメソッドを持つ可能性がある抽象クラスを作成します。</font><font style="vertical-align: inherit;">例：</font></font><br>
<br>
<pre><code class="delphi">abstract class Printable<font></font>
<font></font>
require method (Printable) print()<font></font>
method (Printable) printLn()<font></font>
    this.print()<font></font>
    String.eol().print()<font></font>
</code></pre><br>
</li>
<li>        ?<br>
<br>
   ,  ,     ,   . :<br>
<br>
<pre><code class="delphi">class Some(SomeParent)<font></font>
    a, b String<font></font>
<font></font>
class Some(Some, Printable)<font></font>
<font></font>
override method (Some) print()<font></font>
    this.a.print()<font></font>
    this.b.print()<font></font>
</code></pre><br>
</li>
<li>   ?<br>
<br>
      ( 2        ,      —    ).</li>
<li>       ,     ?<br>
<br>
    ,   .            . :<br>
<br>
<pre><code class="delphi">method (Some) foo(a :String, b String) // a -  , b - <font></font>
    c := 10 // c  <font></font>
    d .= 12 // d  <font></font>
    :someMethod() //   someMethod, c    <font></font>
    c.someMethod() //   someMethod, c    <font></font>
    //2  ,     ,    ,     <font></font>
</code></pre><br>
</li>
<li>  ?<br>
<br>
     ,    . :<br>
<br>
<pre><code class="delphi">class Point<font></font>
    x,y Number<font></font>
<font></font>
method (Some) foo(a Point&lt;x UInt64, y UInt64&gt;) // a   ,     Point,      x  y.    ,     .<font></font>
</code></pre></li>
<li>,    Point  x  y    .<br>
<br>
<pre><code class="delphi">class Point<font></font>
    x, y !Number //   x  ,  y   x<font></font>
</code></pre><br>
</li>
<li>   ?<br>
<br>
   ,         ,      . :<br>
<br>
<pre><code class="delphi">class Point<font></font>
    numberClass #Number<font></font>
    private x, y .numberClass<font></font>
<font></font>
method (Point) createPoint(x, y .numberClass) This //This -           <font></font>
    result:x = x<font></font>
    result:y = y<font></font>
</code></pre><br>
</li>
<li>  ,          LLVM IR ?<br>
<br>
         ( )    ,     . :<br>
<br>
<pre><code class="delphi">method (Some) foo(a .z, b Point&lt;numberClass .f&gt;, c UInt64)<font></font>
//a      z     <font></font>
//b       Point      numberClass,           f     <font></font>
//c    UInt64,     <font></font>
</code></pre><br>
</li>
<li>    ?<br>
<br>
    ,     ,  ,  -      ,    ,    .    0 —  .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンセプトは良さそうで、ゼロから開発を始めました。私の3か月が経過し、仕事を探す時が来ました。困難な時期であり、どこにも仕事がなく、人事部門の従業員でさえ、すべてがそれほど悪くない外観を作成するために偽のジョブを印刷せざるを得ないという噂があります。そして、私はこれらの噂を信じています、あなたはしばしば広告を呼びます、そして彼らは空席が定期的に更新されて長い間ハングアップしているにもかかわらず空席は関係がないとすぐに私に言うので。少なくともいくつかの仕事の検索には5か月かかりました。結核病院にある物に検問所の検査官の立場で治安部に就職しました。私の責任には、患者と訪問者のスクリーニングが含まれます。給与-$ 170 /月。以前よりも作業時間が多かったにもかかわらず、シフト作業だったため、開発期間も長くなりました。そして、すべてのコードを追加し、標準ライブラリを作成し、ライブラリのテストを作成しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストを実行したところ、エラーを修正する過程で多くのエラーが発生しました。それらのほとんどは未定義の動作に関連しており、それらを排除することは非常に難しいことに気付きました。たとえば、一部のエラーは1回だけ表示され、一部はO0およびO2の最適化レベルで表示されましたが、O1およびO3では表示されませんでした。エラーの終わりと終わりはわかりませんでしたが、LLVM IRでエラーを見つけるための適切なツールは見つかりませんでした。 LLVM IRの調査中に、Cからclangを生成するものを観察しました。ある時点で、CからLLVM IRへの変換にはほとんど時間がかからず、主な部分はLLVM IRの最適化であることに気付きました。では、なぜLLVM IRを使用するのですか？結局のところ、その最適化は依然としてエンドユーザーのコンピューターで行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、なぜLLVM IRの代わりにCを使用しないのですか？ LLVM IRをCに置き換える際の利点は、通常のマクロ、簡素化されたコードの記述、一連のツール、必要に応じてサードパーティのCライブラリを使用する可能性だけです。そして、LLVM IRをCに置き換えるコンパイラーの書き直しを開始しました。置き換えが完了すると、テストで見つかったすべてのエラーをすばやく見つけて修正しました。コンパイラーを書いている時点で、私が犯した最も一般的な間違いは、それを一意であると考えてポインターによって値を変更することでしたが、実際にはいくつかのリンクがポインターによってオブジェクトを指しています。変数の可変性レベルの数、このオブジェクト、およびメソッド引数を2（可変および不変）から4に変更することにしました。この記事では、言語作成のすべての段階におけるすべてのニュアンスと微妙さの説明として、多くの詳細を省略しました。そのような記事は20〜40本必要です（これはすでに巨大です）。しかし、新しいレベルを理解するためには、いくつかの詳細を明らかにする必要があります。 2つの変数が同じデータを含み、1つの変数を変更できると書いたとき、2番目の変数に影響を与えることができます。変数を作成すると、オブジェクトがヒープ上に作成され、変数がこのオブジェクトへのポインターを格納すると思いましたが、本当じゃない。私は自分の言語のプログラムを生産的にしたかったので、各変数にメモリを割り当てることは生産的ではありませんでした。したがって、変数を作成すると、値は変数に格納されますが、値にはポインターが含まれる場合があります。変数をオブジェクトに割り当てると、オブジェクトの値が変数にコピーされ、すべてのポインターが同じメモリ領域を指します。新しいレベルを理解するためには、それでもいくつかの詳細を明確にする必要があります。 2つの変数が同じデータを含み、1つの変数を変更できると書いたとき、2番目の変数に影響を与えることができます。変数を作成すると、オブジェクトがヒープ上に作成され、変数がこのオブジェクトへのポインターを格納すると思いましたが、本当じゃない。私は自分の言語のプログラムを生産的にしたかったので、各変数にメモリを割り当てることは生産的ではありませんでした。したがって、変数を作成すると、値は変数に格納されますが、値にはポインターが含まれる場合があります。変数をオブジェクトに割り当てると、オブジェクトの値が変数にコピーされ、すべてのポインターが同じメモリ領域を指します。新しいレベルを理解するためには、それでもいくつかの詳細を明確にする必要があります。 2つの変数が同じデータを含み、1つの変数を変更できると書いたとき、2番目の変数に影響を与えることができます。おそらく変数を作成すると、オブジェクトがヒープ上に作成され、変数はこのオブジェクトへのポインターを格納すると思いましたが、本当じゃない。私は自分の言語のプログラムを生産的にしたかったので、各変数にメモリを割り当てることは生産的ではありませんでした。したがって、変数を作成すると、値は変数に格納されますが、値にはポインターが含まれる場合があります。変数をオブジェクトに割り当てると、オブジェクトの値が変数にコピーされ、すべてのポインターが同じメモリ領域を指します。2つの変数が同じデータを含み、1つの変数を変更する場合、2番目の変数に影響を与える可能性があります。変数を作成すると、オブジェクトがヒープ上に作成され、変数がこのオブジェクトへのポインターを格納すると考えたかもしれませんが、そうではありません。私は自分の言語のプログラムを生産的にしたかったので、各変数にメモリを割り当てることは生産的ではありませんでした。したがって、変数を作成すると、値は変数に格納されますが、値にはポインターが含まれる場合があります。変数をオブジェクトに割り当てると、オブジェクトの値が変数にコピーされ、すべてのポインターが同じメモリ領域を指します。2つの変数が同じデータを含み、1つの変数を変更すると、2番目の変数に影響を与える可能性があります。変数を作成すると、オブジェクトがヒープ上に作成され、変数がこのオブジェクトへのポインターを格納すると思いましたが、そうではありません。私は自分の言語のプログラムを生産的にしたかったので、各変数にメモリを割り当てることは生産的ではありませんでした。したがって、変数を作成すると、値は変数に格納されますが、値にはポインターが含まれる場合があります。変数をオブジェクトに割り当てると、オブジェクトの値が変数にコピーされ、すべてのポインターが同じメモリ領域を指します。私の言語のプログラムは生産的であり、各変数にメモリを割り当てることは生産的ではありません。したがって、変数を作成すると、値は変数に格納されますが、値にはポインターが含まれる場合があります。変数をオブジェクトに割り当てると、オブジェクトの値が変数にコピーされ、すべてのポインターが同じメモリ領域を指します。私の言語のプログラムは生産的であり、各変数にメモリを割り当てることは生産的ではありません。したがって、変数を作成すると、値は変数に格納されますが、値にはポインターが含まれる場合があります。変数をオブジェクトに割り当てると、オブジェクトの値が変数にコピーされ、すべてのポインターが同じメモリ領域を指します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可変性のレベルに戻りますが、ここに2つの新しいレベルがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数の値は変更できますが、参照によって値を変更することはできません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数の値は変更できませんが、参照により値を変更できます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらくあなたは「言語がリンクをサポートしていないのに、なぜリンクを検討するのか」という疑問を抱くかもしれません。</font><font style="vertical-align: inherit;">私はそれらを考慮に入れる必要はなく、いくつかのルールを守らなければならず、ほとんどの場合、コンパイルエラーが発生することに違反していると私は答えます。</font><font style="vertical-align: inherit;">また、メソッド内のこのオブジェクトが（プロパティと同様に）読み取れないことを示すこともできました。</font><font style="vertical-align: inherit;">言語は次のようになりました：</font></font><br>
<br>
<pre><code class="delphi">method (#Some) foo(a String, b `String, c ~String, d :String)<font></font>
//this  <font></font>
//a   <font></font>
// b    ,         <font></font>
//c        ,        <font></font>
//d  ,  <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラを書き直して、標準ライブラリの書き直しを始めました。国勢調査の間に深刻な問題を発見しました。実際には、（シグネチャによる）引数が部分的または完全に不変でなければならないメソッドを呼び出すときに、より可変的な引数が渡されると、呼び出しの可変性のレベルが低下します（これは論理的です）。これが問題です：完全に変更可能な変数があり、変更可能な値を持つ変数にのみ適用されるメソッドにそれを適用するとしますが、参照によって不変の値を持つ場合、このメソッドでは、完全に不変のオブジェクトをこれに割り当てることが合法です（値がどのようにコピーされ、リンクが不変である）が、メソッドの最後に、不変値へのリンクがあり、これがすべてを完全に破壊する完全に可変な変数を取得します。説明は非常にわかりにくいことがわかりましたので、ここに例を示します：</font></font><br>
<br>
<pre><code class="delphi">method (~Some) veryBadMethod(value This)<font></font>
 this = value<font></font>
<font></font>
method (#Some) foo()<font></font>
    a := Some<font></font>
    b .= Some#randomValue() //,    b    <font></font>
    a~veryBadMethod(b)<font></font>
    a:someMethod() //  ,   <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題に気付いた瞬間、私は激怒しました。私は正直に言って、生産的プログラムを作成するための安全でシンプルで強制的な言語を作成しようとしましたが、すべて無駄でした。すべて疲れて、生産性を気にしませんが、ルビーは何とか生き残ります。私は決定しました-初めのように2レベルの可変性しかありません、そしてオブジェクトを割り当てるとき、その値は完全にコピーされます、この場合、あなたはまだメモリ管理について入浴する必要はありません、オブジェクトは必要ありません-それは完全にそれを解放することを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラの次の国勢調査の間に、私は非常に激しく咳を始めました、これはすべて高熱を伴っていました。咳はとても強いので、「それだけです！よくやった！彼は結核病院で働いていた。」私はクリニックに行き、そこで彼らは私の肺の写真を撮り、私を病院に入れました。それは急性気管支炎であることが判明しました。入院中、私は常に圧力を監視されていました。その上限は、しばしば150〜180の範囲でした。圧迫用および気管支炎用の錠剤の合計数は1日あたり11個でした。退院後、特に記憶に関して、認知能力に問題が出てきました。何かを考えていて、その過程で何かを忘れて、長い間思い出せない状況になりました。私はこれについて病院に行きませんでした（なぜですか？簡単に言えば、私にはわかりません。記事全体を書くことができます）。時間の経過とともに、私の能力は回復し始めましたが、まだ完全には回復していません。病院から戻って、考えが悪く、母親と一緒に住んでいる30歳近くの男が、世界の郊外で月200ドル（彼の給与はわずかに増加しました）で、彼の青春を彼ができないことに費やしていたので、私は非常に落ち込みました状態。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主にコンピューターゲームをプレイして、先延ばしにし始めました。ゲームの1つ（弟子3）には、そのようなユニットがありました。彼がひどく負傷しているとき、彼は非常に強くなり、「私は戦いで死んでしまいます！」というフレーズを言います。このフレーズは私にインスピレーションを与えました。なぜなら、自分が始めたものを終えなかった場合、私の人生の何がポイントでしたかどんなに費用がかかっても、コンパイラを完成させます！私は発展を続け、以前は週末にだけ書いたとしたら、今は仕事の後に書き始めることがよくあります。開発を始めて間もなく、「なぜオブジェクトを完全にコピーするのか？結局のところ、Haskellのようにそれを行うことができます。」 Haskellが10個の数値を追加することを許可されている場合、彼はそれらを追加しません。追加する必要があることに気づくだけですが、計算の結果が必要になるとすぐに追加が行われ、そのようなイベントは発生しません。オブジェクトをコピーするのではなく、同じことを実行できますが、メモリ領域を所有しているオブジェクトの数（特に、自動メモリ管理を提供するカウンターがあるため）をマークし、複数のオブジェクトがメモリを所有していて、このメモリの値を変更する必要がある場合、それだけがコピーされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、自分の言語で生産的なプログラムを作成できることを理解しています。そして、私が終わった瞬間が来ましたが、私自身の言語を使用してコンパイラを書き直すことが私にとって根本的に重要でした。コンパイラの書き直し中に、言語が非常に不便であることにすぐに気づきました。特に私を悩ませたプロパティへのリンクは、言語の便利な機能と考えられていましたが、実際には、それらが最大の欠点であることが判明し、正しい心の誰もそのような言語を使用することはありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語に可変性のための多くのオプションがあったその瞬間、私は言語の別の設計について考えていましたが、可変性のための非常に多くのオプションがあるとそれは非常に不便であり、変数を相互接続できるという事実は言語を危険にするので、それを実装しませんでした。</font><font style="vertical-align: inherit;">しかし、今はそのような問題はありません。</font><font style="vertical-align: inherit;">そして、私は最初からやり直しました。</font><font style="vertical-align: inherit;">新しい言語はクラスではなくオブジェクト指向ではなくなり、ジェネリックを作成する機能を備えた型が利用できるようになりました。</font><font style="vertical-align: inherit;">例：</font></font><br>
<br>
<pre><code class="go">type Point(a)<font></font>
    x,y a<font></font>
<font></font>
type SimplePoint<font></font>
    x,y Double<font></font>
<font></font>
//-  <font></font>
a := Point(UInt64)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haskellの型クラスに類似したものがありますが、私の言語ではグループと呼ばれますが、型クラスとは異なり、グループはグループのメンバーがどの型になることができるかについて制限を設けることはできません。</font><font style="vertical-align: inherit;">論理的には存在しますが、言語の特殊性のため、実装できません。</font><font style="vertical-align: inherit;">したがって、グループを作成するときにコメントでグループの要件を記述します。</font><font style="vertical-align: inherit;">例：</font></font><br>
<br>
<pre><code class="cs">group Equal<font></font>
//equal(a, a) -&gt; Bool<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、型がEqualグループのメンバーである場合、equalという関数が必要です。この関数は、この型の引数を2つ取り、Bool型を返す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルールは言語に現れました-これはそのようなミニプログラミング言語であり、そのコードはコンパイル時に実行されます。このコードでは、グループにタイプを追加できます。例：</font></font><br>
<br>
<pre><code class="cs">rules<font></font>
    1 = type == [_] //    <font></font>
    2 = type[0] &gt; Equal //      Equal<font></font>
    3 = 1 &amp; 2<font></font>
    join 3 Equal //      Equal<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、同じ名前の関数とプロシージャが無数に存在する可能性があります。呼び出し可能なセットからどの関数を呼び出すかを決定するために、関数には、渡された引数のタイプを使用して、関数がこれらの引数に適しているかどうかを決定できるルールがあります。関数には1から9（デフォルトは5）までの優先度があります。関数を呼び出すときに、同じ優先度の適切なオプションがいくつかあり、優先度の高い適切なオプションがない場合、これはコンパイルエラーです。関数の例：</font></font><br>
<br>
<pre><code class="cs">func notEqual(a, b)<font></font>
    rules<font></font>
        final = a &gt; Equal &amp; a == b<font></font>
        result = Bool<font></font>
    result = !(a == b) //!  ==  ,    result = (neg(equal(a, b))  a.equal(b).neg()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいコンパイラーの開発を終え、標準ライブラリーを書き直してテストした後、私は以前書いたように、自分の言語でコンパイラーを書き直し始めました。これは私にとって重要です。事前に予測できなかった言語で再び問題を見つけるのではないかと非常に恐れていましたが、すべてが順調に進んでおり、そのような言語で書くことは喜びでした。プログラムを作成するために、私は自己作成のbashスクリプトを使用しましたが、もちろんこれはオプションではありません。したがって、私は（もちろん自分の言語で）パッケージビルダーとインストーラーを作成しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、シネプログラミング言語、同名のコンパイラ、feiプロジェクトビルダーおよびインストーラーを紹介します。 githubへのリンクは次のとおりです</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。cineおよびfeiインストーラー。</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラソース</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インストーラーとパッケージコレクターのソース。</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準ライブラリのソース（私はnameモジュールを使用しています）。</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kateテキストエディタで構文の強調表示を作成するためのXMLファイル。</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インストールと操作には、Linux x86_64（残念ながら、これまでのところのみ）とインストールされたclangが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語の教科書はまだないので、</font><font style="vertical-align: inherit;">シネプログラミングのチュートリアルを書く</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブログ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を開きました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味深い事実：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前cineおよびfeiは、n-kineおよびenfeiのランダムな名前ジェネレーターに由来します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シネコードでは、Cで記述されたコードを使用できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シネコンパイラーは、型メンバーを自動的に整列（最大から最小へ）でソートします。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もともとは4ernikaと呼ばれていました。作成することを決めたときにブルーベリーを食べたからです。</font></font></li>
<li>    ,        ,   .  size  count    ,       size  count,        .     ,         ,   ,       .</li>
<li>     ,       (     ).</li>
<li>      ,            ,     (        ,          ).            ,       ,    .        .</li>
<li>  cine     ,   cine —     UInt8,       ,   .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM IRの使用からCに切り替えたとき、clangまたはGCCの使用を選択できました。</font><font style="vertical-align: inherit;">2つのコンパイラーでアセンブラー・コードにコンパイルしたいくつかの例を書いて、両方のファイルを調べた後、clangに落ち着きました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">言語はもともとコードにSIMD命令を含めることを可能にするために考案されましたが、バージョン0.1ではSIMDの明示的な使用はありません（確かに表示されます）が、言語のパススルーバリアントの1つでは、それに耐えられず、SIMD命令を使用してスライス要素の検索を実装できませんでした。</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja481258/index.html">登録とSMSなしでスクーナーのフレームを接着します</a></li>
<li><a href="../ja481260/index.html">例として.classファイルのバイトコードを使用してバイナリ形式を探索します。</a></li>
<li><a href="../ja481262/index.html">ICD F41.2で12年間。私たちを殺さないものは私たちをより強くします...そしてより良い</a></li>
<li><a href="../ja481264/index.html">アプリ「今日のアプリ」の期間中、App Storeであなたのアイコンを見る人の数</a></li>
<li><a href="../ja481272/index.html">凍結または近代化-休暇中に何をしますか？</a></li>
<li><a href="../ja481280/index.html">CTFZone-2020の認定段階の準備方法</a></li>
<li><a href="../ja481282/index.html">アイデアの価値とそれをコンセプトに変える方法：ゲームデザイナーツール</a></li>
<li><a href="../ja481286/index.html">テーブルに着きなさい！ささいなことのないオフィス雑学</a></li>
<li><a href="../ja481288/index.html">効果的なRedux開発ツールとしてのRedux Toolkit</a></li>
<li><a href="../ja481290/index.html">HOW-to /専用のHetznerおよびMikrotikサーバーでのネットワークとVLANの設定</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>