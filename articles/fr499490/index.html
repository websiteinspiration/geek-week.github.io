<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏽 🚾 🗻 Algorithmes aléatoires 🙌🏾 👩‍👦‍👦 ‼️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, vous verrez les algorithmes de vélo les plus divers pour générer des nombres aléatoires.
 
 À propos de quel article
 A propos des a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Algorithmes aléatoires</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499490/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cet article, vous verrez les </font><font style="vertical-align: inherit;">algorithmes de </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vélo</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> les plus divers </font><font style="vertical-align: inherit;">pour générer des nombres aléatoires.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À propos de quel article</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A propos des algorithmes générant des nombres pseudo-aléatoires qui diffèrent par la qualité du résultat et la vitesse d'exécution. </font><font style="vertical-align: inherit;">L'article sera utile à ceux qui souhaitent obtenir une génération de nombres haute performance dans leurs programmes ou aux développeurs de logiciels pour microcontrôleurs et anciennes plates-formes comme ZX Spectrum ou MSX.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rand C ++</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première chose qu'un programmeur C ++ novice apprend à obtenir une maison aléatoire est la fonction rand, qui génère un nombre aléatoire entre 0 et RAND_MAX. </font><font style="vertical-align: inherit;">La constante RAND_MAX est décrite dans le fichier stdlib.h et vaut 32'767, mais cela peut ne pas être le cas, par exemple, sous Linux ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voir commentaire</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Si rand () dans votre compilateur génère des nombres dans 32'767 (0x7FFF) et que vous souhaitez obtenir un nombre aléatoire de grande taille, le code ci-dessous peut être considéré comme une solution à ce problème:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int64_t</span> A = rand();<font></font>
A &lt;&lt;= <span class="hljs-number">15</span>; <span class="hljs-comment">//   15,   7FFF  15 </span><font></font>
A |= rand();<font></font>
A &lt;&lt;= <span class="hljs-number">15</span>;<font></font>
A |= rand();<font></font>
A &lt;&lt;= <span class="hljs-number">15</span>;<font></font>
A |= rand();<font></font>
A &lt;&lt;= <span class="hljs-number">3</span>;<font></font>
A |= rand() &amp; <span class="hljs-number">0b111</span>; <span class="hljs-comment">//  3  </span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'implémentation de la fonction rand dans l'ancien C était simple et ressemblait à ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> next = <span class="hljs-number">1</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rand</span><span class="hljs-params">()</span>
</span>{<font></font>
  next = next * <span class="hljs-number">1103515245</span> + <span class="hljs-number">12345</span>;
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(next / <span class="hljs-number">65536</span>) % <span class="hljs-number">32768</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette implémentation n'avait pas une très bonne distribution des nombres et est maintenant améliorée en C ++. </font><font style="vertical-align: inherit;">De plus, la bibliothèque C ++ standard offre des moyens supplémentaires d'obtenir un nombre aléatoire, qui sont abordés ci-dessous.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11 STL aléatoire</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette variété d'aléatoire est apparue en C ++ 11 et se compose de l'ensemble de classes suivant: minstd_rand, mt19937, ranlux, knuth_b et leurs diverses variations. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour éviter que la séquence de nombres aléatoires ne se répète à chaque démarrage du programme, le «grain» du générateur pseudo-aléatoire est défini sous la forme de l'heure actuelle ou, dans le cas de certains jeux rétro (et pas seulement), les intervalles entre les frappes du clavier / joystick. </font><font style="vertical-align: inherit;">La bibliothèque aléatoire suggère d'utiliser std :: random_device pour obtenir un grain meilleur que le temps (NULL), cependant, dans le cas du compilateur MinGW sous Windows, la fonction ne fonctionne pratiquement pas comme elle le devrait. </font><font style="vertical-align: inherit;">Encore…</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ,   :</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;random&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><font></font>
<font></font>
<span class="hljs-built_in">std</span>::mt19937 engine; <span class="hljs-comment">// mt19937    </span>
engine.seed(<span class="hljs-built_in">std</span>::time(<span class="hljs-literal">nullptr</span>));
<span class="hljs-comment">/*
 ,    UNIX--    MinGW
std::random_device device;
engine.seed(device());
*/</span>
<span class="hljs-keyword">int</span> val = engine(); <span class="hljs-comment">//   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certains des algorithmes de STL random peuvent fonctionner plus rapidement que rand (), mais donnent une séquence de nombres aléatoires de qualité inférieure.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PRNG - Générateur de nombres pseudo-aléatoires</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez considérer ce nom comme synonyme de la méthode congruente linéaire. </font><font style="vertical-align: inherit;">Les algorithmes PRNG sont similaires à l'implémentation rand en C et ne diffèrent que par les constantes.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">PRNG</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> seed = <span class="hljs-number">1</span>; <span class="hljs-comment">//     0</span>
  seed = (seed * <span class="hljs-number">73129</span> + <span class="hljs-number">95121</span>) % <span class="hljs-number">100000</span>;
  <span class="hljs-keyword">return</span> seed;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les algorithmes PRNG sont rapides et faciles à implémenter dans de nombreux langages, mais n'ont pas une longue période.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xorshift</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'algorithme présente de nombreuses variantes, différentes les unes des autres par la période et les registres utilisés. </font><font style="vertical-align: inherit;">Les détails et les variétés de XorShift peuvent être consultés sur Wikipedia ou Habré. </font><font style="vertical-align: inherit;">Je donnerai l'une des options avec une séquence de 2 au 128e degré.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seed_t</span>
{</span>
  <span class="hljs-keyword">unsigned</span> x = <span class="hljs-number">1</span>; <span class="hljs-comment">//     </span>
  <span class="hljs-keyword">unsigned</span> y = <span class="hljs-number">123</span>;
  <span class="hljs-keyword">unsigned</span> z = <span class="hljs-number">456</span>;
  <span class="hljs-keyword">unsigned</span> w = <span class="hljs-number">768</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">XorShift128</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">seed_t</span> s;
  <span class="hljs-keyword">unsigned</span> t = s.x^(s.x&lt;&lt;<span class="hljs-number">11</span>);<font></font>
  s.x = s.y;<font></font>
  s.y = s.z;<font></font>
  s.z = s.w;<font></font>
  s.w = (s.w^(s.w&gt;&gt;<span class="hljs-number">19</span>)) ^ (t^(t&gt;&gt;<span class="hljs-number">8</span>));
  <span class="hljs-keyword">return</span> s.w;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce générateur est très bon car il n'y a aucune opération de division et de multiplication - cela peut être utile sur les processeurs et les microcontrôleurs dans lesquels il n'y a pas d'instructions de division / multiplication d'assembleur (PIC16, Z80, 6502).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Émulateur aléatoire 8 bits dans z26</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Z26 est un émulateur d'un ancien préfixe Atari2600, dans le code duquel vous pouvez trouver un aléatoire orienté pour fonctionner avec des registres à 1 octet.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// P2_sreg - static uint8_t</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">P2_Read_Random</span><span class="hljs-params">()</span>
</span>{<font></font>
  P2_sreg =<font></font>
    (((((P2_sreg &amp; <span class="hljs-number">0x80</span>) &gt;&gt; <span class="hljs-number">7</span>) ^<font></font>
       ((P2_sreg &amp; <span class="hljs-number">0x20</span>) &gt;&gt; <span class="hljs-number">5</span>)) ^<font></font>
      (((P2_sreg &amp; <span class="hljs-number">0x10</span>) &gt;&gt; <span class="hljs-number">4</span>) ^<font></font>
       ((P2_sreg &amp; <span class="hljs-number">0x08</span>) &gt;&gt; <span class="hljs-number">3</span>))) ^ <span class="hljs-number">1</span>) |<font></font>
        (P2_sreg &lt;&lt; <span class="hljs-number">1</span>);<font></font>
  DataBus = P2_sreg;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois, j'ai dû faire une implémentation de cet algorithme pour z80:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code d'assemblage</font></font></b>
                        <div class="spoiler_text"><pre><code class="plaintext hljs">;    z26<font></font>
; a - output<font></font>
; rdseed - 1  <font></font>
randz26:<font></font>
    exx<font></font>
<font></font>
    ld a,(rdseed)<font></font>
    and 20h<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    ld h, a<font></font>
<font></font>
    ld a,(rdseed)<font></font>
    and 80h<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    xor h<font></font>
    ld l, h<font></font>
    <font></font>
    ld a,(rdseed)<font></font>
    and 08h<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    ld h, a<font></font>
<font></font>
    ld a,(rdseed)<font></font>
    and 10h<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    sra a<font></font>
    xor h<font></font>
    ld h, a<font></font>
    ld a, l<font></font>
    xor h<font></font>
    xor 1<font></font>
<font></font>
    ld h, a<font></font>
    ld a,(rdseed)<font></font>
    sla a<font></font>
    or h<font></font>
    ld (rdseed),a<font></font>
<font></font>
    exx<font></font>
    ret<font></font>
</code></pre><br>
</div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compact random pour Z80 de Joe Wingbermuehle</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous êtes intéressé à écrire des programmes pour les voitures avec zilog, je présente à votre attention un algorithme de Joe Wingbermuehle (ne fonctionne que sur zilog):</font></font><br>
<br>
<pre><code class="plaintext hljs">; By Joe Wingbermuehle<font></font>
; a res 1 byte - out val<font></font>
; rdseed res 1 byte - need for rand. != 0<font></font>
rand8:<font></font>
        exx<font></font>
        ld      hl,(rdseed)<font></font>
        ld      a,r<font></font>
        ld      d,a<font></font>
        ld      e,(hl)<font></font>
        add     hl,de<font></font>
        add     a,l<font></font>
        xor     h<font></font>
        ld      (rdseed),hl<font></font>
        exx<font></font>
        ret<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Générateur de maison aléatoire dans DOOM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le code source du jeu Doom, il existe un fichier intéressant appelé m_random.c </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(voir le code)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui décrit la fonction du caractère aléatoire de la "table", c'est-à-dire qu'il n'y a pas de formules et de magie avec des décalages de bits. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vais donner un code plus compact qui montre clairement le fonctionnement de cette fonction.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> random_map[] =<font></font>
{<font></font>
  <span class="hljs-number">4</span>,  <span class="hljs-number">1</span>,   <span class="hljs-number">63</span>, <span class="hljs-number">3</span>,
  <span class="hljs-number">64</span>, <span class="hljs-number">22</span>,  <span class="hljs-number">54</span>, <span class="hljs-number">2</span>,
  <span class="hljs-number">0</span>,  <span class="hljs-number">52</span>,  <span class="hljs-number">75</span>, <span class="hljs-number">34</span>,
  <span class="hljs-number">89</span>, <span class="hljs-number">100</span>, <span class="hljs-number">23</span>, <span class="hljs-number">84</span><font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">uint8_t</span> <span class="hljs-title">get_random</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> index = <span class="hljs-number">0</span>;<font></font>
  index = (index + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xF</span>; <span class="hljs-comment">// 0xF,      random_map</span>
  <span class="hljs-keyword">return</span> random_map[index];<font></font>
}<font></font>
</code></pre><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Varik pour z80</font></font></b>
                        <div class="spoiler_text"><pre><code class="plaintext hljs">;   (  DOOM)<font></font>
; rand_table -    .  <font></font>
;                        256    .<font></font>
; a - output num<font></font>
randtab:<font></font>
    exx<font></font>
    ; index<font></font>
    ld a, (rdseed)<font></font>
    inc a<font></font>
    ;and filter ; for crop array index<font></font>
    ld (rdseed), a<font></font>
    ; calc array address<font></font>
    ld hl, rand_table<font></font>
    ld d, 0<font></font>
    ld e, a<font></font>
    add hl, de<font></font>
    ld a, (hl) ; get num from arr<font></font>
    exx<font></font>
    ret<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr, ce n'est pas aléatoire et la séquence de nombres aléatoires est facile à prévoir même au niveau de l'intuition pendant le jeu, mais tout fonctionne extrêmement rapidement. </font><font style="vertical-align: inherit;">Si la force cryptographique n'est pas particulièrement importante pour vous et que vous voulez quelque chose qui génère rapidement un "type aléatoire", alors cette fonction est pour vous. </font><font style="vertical-align: inherit;">Par ailleurs, dans Quake3, aléatoire semble simple - rand () &amp; 0x7FFF.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RDRAND</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certains processeurs modernes sont capables de générer des nombres aléatoires avec une seule instruction d'assembleur - RDRAND. </font><font style="vertical-align: inherit;">Pour utiliser cette fonction en C ++, vous pouvez écrire manuellement les instructions nécessaires avec des insertions d'assembleur, ou connecter le fichier immintrin.h dans GCC et sélectionner l'une des variantes de la fonction _rdrandXX_step, où XX signifie le nombre de bits dans le registre et peut être 16, 32 ou 64.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-keyword">unsigned</span> val;<font></font>
_rdrand32_step(&amp;val);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous voyez une erreur de compilation, cela signifie que vous n'avez pas activé l'indicateur -mrdrnd ou que votre compilateur / processeur ne prend pas en charge cet outil. </font><font style="vertical-align: inherit;">C'est peut-être le générateur de nombres aléatoires le plus rapide, mais il y a des questions sur sa force cryptographique, alors pensez-y.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fin</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe std :: minstd_rand de la bibliothèque aléatoire STL est plus rapide que rand () ordinaire et peut devenir un remplacement alternatif si vous n'êtes pas particulièrement préoccupé par la longueur de la période dans minstd. </font><font style="vertical-align: inherit;">Il peut y avoir des différences dans le fonctionnement de ces fonctions sous Windows et Unix.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INFA sur le sujet</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un article sur C ++ 11 random et quelques fonctionnalités de son utilisation: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Génération de nombres aléatoires en C ++ moderne</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quels sont les générateurs en STL aléatoires? </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exilé</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Article wiki sur XorShift avec différentes implémentations: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tyk</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Émulateur Git z26. </font><font style="vertical-align: inherit;">Code aléatoire dans le fichier c_pitfall2.c: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">git</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Générateur aléatoire Dumchik: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">git</font></font></a></li>
</ul><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Mon premier article. </font><font style="vertical-align: inherit;">Écrivez ce qui est superflu, quoi ajouter / réduire</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr499472/index.html">Comment le coronavirus accélérera la quatrième révolution industrielle</a></li>
<li><a href="../fr499474/index.html">Comment mettre en œuvre Atlassian Jira + Confluence dans une entreprise. Problèmes techniques</a></li>
<li><a href="../fr499476/index.html">Test d'automatisation d'applications web clé en main, sans inscription et SMS</a></li>
<li><a href="../fr499482/index.html">Comment les investisseurs économisent leurs finances en cas de crise: approches de diversification, sélection d'actifs à faible risque et optimisation des coûts</a></li>
<li><a href="../fr499486/index.html">La rhétorique comme outil de sécurité</a></li>
<li><a href="../fr499492/index.html">Est-il possible pour un développeur de la Silicon Valley de devenir millionnaire? Ingénieur d'état-major analysant à Lyft</a></li>
<li><a href="../fr499502/index.html">Pourquoi OceanStor Dorado V6 est le stockage le plus rapide et le plus fiable</a></li>
<li><a href="../fr499504/index.html">Protocole de suivi des contacts Bluetooth Apple et Google</a></li>
<li><a href="../fr499506/index.html">Paiement horaire, pour le résultat ou le salaire?</a></li>
<li><a href="../fr499508/index.html">Préparer notre produit à évoluer avec les files d'attente Laravel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>