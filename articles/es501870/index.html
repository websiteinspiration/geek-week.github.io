<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☢️ 🅱️ 👩🏽‍🌾 Número máximo de valores en enum Parte II 📽️ 🚶🏻 👴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Primera parte, teórica  | Segunda parte, práctica
 
 
 Continuamos buscando el número máximo posible de valores en la enumeración. 
 Esta vez nos cent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Número máximo de valores en enum Parte II</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501870/"><nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primera parte, teórica</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;|&nbsp;</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segunda parte, práctica</font></font></b></nobr><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Continuamos buscando el número máximo posible de valores en la enumeración. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta vez nos centraremos en el lado práctico del problema y veremos cómo el IDE, el compilador y la JVM responderán a nuestros logros.</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenido</font></font></h1><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Herramientas de </font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac </font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Método de extracción </font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constantes dinámicas de archivos de clase </font></font></a><br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dificultades repentinas </font></font></a><br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Futuro brillante </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Prueba </font></a></font><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">insegura </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Javac y </font></a></font><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rendimiento del </font></font></a><br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conmutador </font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusión </font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recursos adicionales</font></font></a><br>
<br>
<a name="Tools"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Herramientas</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javac nos cuida: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elimina los caracteres que no le gustan de los identificadores</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y prohíbe heredar de ellos </font></font><code>java.lang.Enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo que para los experimentos necesitamos otras herramientas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pondremos a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prueba</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hipótesis utilizando </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">asmtools</font></a><font style="vertical-align: inherit;"> (ensamblador y desensamblador para JVM) y generaremos archivos de clase a escala industrial, utilizando la biblioteca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para simplificar la comprensión, la esencia de lo que está sucediendo se duplicará en un pseudocódigo similar a Java.</font></font><br>
<br>
<a name="Javac"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como punto de partida, es lógico obtener el mejor resultado, alcanzable sin trucos, con la ayuda de uno solo </font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Todo es simple aquí - creamos el archivo fuente con la enumeración y añadir elementos a ella hasta javac para compilar niega </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la maldición “código demasiado grande”. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mucho tiempo, desde Java 1.7, este número se ha mantenido en el nivel de 2_746 elementos. </font><font style="vertical-align: inherit;">Pero en algún lugar después de Java 11, hubo cambios en el algoritmo para almacenar valores en el grupo constante y el número máximo disminuyó a 2_743. </font><font style="vertical-align: inherit;">¡Sí, sí, solo por cambiar el orden de los elementos en el grupo de constantes! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos centraremos en el mejor de los valores.</font></font><br>
<br>
<a name="ExtractMethod"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Método de extracción</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que uno de los factores limitantes está relacionado con el tamaño del código de bytes en el bloque de inicialización estática, intentaremos hacer que este último sea lo más fácil posible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recordemos cómo se ve en el ejemplo de la enumeración </font></font><code>FizzBuzz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de la primera parte. </font><font style="vertical-align: inherit;">Los comentarios proporcionan instrucciones de montaje apropiadas.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estática {}</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Fizz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>);
    <span class="hljs-comment">//  0: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">//  3: dup</span>
    <span class="hljs-comment">//  4: ldc           #22                 // String Fizz</span>
    <span class="hljs-comment">//  6: iconst_0</span>
    <span class="hljs-comment">//  7: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 10: putstatic     #25                 // Field Fizz:LFizzBuzz;</span>
    Buzz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>);
    <span class="hljs-comment">// 13: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">// 16: dup</span>
    <span class="hljs-comment">// 17: ldc           #28                 // String Buzz</span>
    <span class="hljs-comment">// 19: iconst_1</span>
    <span class="hljs-comment">// 20: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 23: putstatic     #30                 // Field Buzz:LFizzBuzz;</span>
    FizzBuzz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>);
    <span class="hljs-comment">// 26: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">// 29: dup</span>
    <span class="hljs-comment">// 30: ldc           #32                 // String FizzBuzz</span>
    <span class="hljs-comment">// 32: iconst_2</span>
    <span class="hljs-comment">// 33: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 36: putstatic     #33                 // Field FizzBuzz:LFizzBuzz;</span><font></font>
<font></font>
    $VALUES = <span class="hljs-keyword">new</span> FizzBuzz[] {
    <span class="hljs-comment">// 39: iconst_3</span>
    <span class="hljs-comment">// 40: anewarray     #2                  // class FizzBuzz</span><font></font>
        Fizz, <font></font>
    <span class="hljs-comment">// 43: dup</span>
    <span class="hljs-comment">// 44: iconst_0</span>
    <span class="hljs-comment">// 45: getstatic     #25                 // Field Fizz:LFizzBuzz;</span>
    <span class="hljs-comment">// 48: aastore</span><font></font>
        Buzz, <font></font>
    <span class="hljs-comment">// 49: dup</span>
    <span class="hljs-comment">// 50: iconst_1</span>
    <span class="hljs-comment">// 51: getstatic     #30                 // Field Buzz:LFizzBuzz;</span>
    <span class="hljs-comment">// 54: aastore</span><font></font>
        FizzBuzz<font></font>
    <span class="hljs-comment">// 55: dup</span>
    <span class="hljs-comment">// 56: iconst_2</span>
    <span class="hljs-comment">// 57: getstatic     #33                 // Field FizzBuzz:LFizzBuzz;</span>
    <span class="hljs-comment">// 60: aastore</span><font></font>
    };<font></font>
    <span class="hljs-comment">// 61: putstatic     #1                  // Field $VALUES:[LFizzBuzz;</span>
    <span class="hljs-comment">// 64: return</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo primero que viene a la mente es poner la creación y el llenado de la matriz </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en un método separado.</font></font><br>
<br>
<pre><code class="java hljs">$VALUES = createValues();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al desarrollar esta idea, la creación de instancias de elementos de enumeración se puede transferir al mismo método:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    FizzBuzz[] localValues = createValues();<font></font>
<font></font>
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<font></font>
    Fizz = localValues[index++];<font></font>
    Buzz = localValues[index++];<font></font>
    FizzBuzz = localValues[index++];<font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FizzBuzz[] {
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>), 
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>), 
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>)<font></font>
    };<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya es mejor, pero cada captura de un elemento de matriz y el incremento del índice posterior cuestan 6 bytes, lo cual es demasiado costoso para nosotros. </font><font style="vertical-align: inherit;">Ponlos en un método separado.</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> valueIndex;<font></font>
<font></font>
<span class="hljs-keyword">static</span>  {<font></font>
    $VALUES = createValues();<font></font>
<font></font>
    valueIndex = <span class="hljs-number">0</span>;<font></font>
    Fizz = nextValue();<font></font>
    Buzz = nextValue();<font></font>
    FizzBuzz = nextValue();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz <span class="hljs-title">nextValue</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> $VALUES[valueIndex++];<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se </font><font style="vertical-align: inherit;">requieren 11 bytes para </font><font style="vertical-align: inherit;">inicializar </font><font style="vertical-align: inherit;">y regresar del bloque de inicialización estático </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>valueIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y quedan 65_524 bytes más para inicializar los campos. </font><font style="vertical-align: inherit;">La inicialización de cada campo requiere 6 bytes, lo que nos permite crear una enumeración de 10_920 elementos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Casi cuatro veces el crecimiento en comparación con javac definitivamente debe celebrarse mediante la generación de código! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Código fuente del generador: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExtractMethodHugeEnumGenerator.java</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ejemplo de clase </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">generada</font></a><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExtractMethodHugeEnum.class</font></font></a><br>
<a name="ConDy"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constantes dinámicas de archivo de clase</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es hora de recordar sobre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 309</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y sus misteriosas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constantes dinámicas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La esencia de la innovación en pocas palabras: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
a los tipos ya existentes respaldados por un grupo de constantes se agregó otro </font></font><code>CONSTANT_Dynamic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Al cargar una clase, se conoce el tipo de tal constante, pero se desconoce su valor. La primera carga de una constante conduce a una llamada al método bootstrap especificado en su declaración. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado de este método se convierte en un valor constante. No hay formas de cambiar el valor asociado con una constante ya inicializada. Lo cual es bastante lógico para una constante.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si también pensaste en Singleton, olvídalo de inmediato. </font><font style="vertical-align: inherit;">La especificación enfatiza por separado que no hay garantías de seguridad de subprocesos en este caso y que el método de inicialización en código multiproceso puede llamarse más de una vez. </font><font style="vertical-align: inherit;">Solo se garantiza que en el caso de varias llamadas al método bootstrap para la misma constante, la JVM arrojará una moneda y seleccionará uno de los valores calculados para el papel del valor constante, y los otros serán sacrificados al recolector de basura.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comportalmente, una constante CONSTANT_Dynamics se resuelve ejecutando su método bootstrap en los siguientes parámetros: </font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un objeto de búsqueda local,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la cadena que representa el componente de nombre de la constante,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la clase que representa el tipo constante esperado, y</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cualquier argumento de arranque restante.</font></font></li>
</ol><br>
As with invokedynamic, multiple threads can race to resolve, but a unique winner will be chosen and any other contending answers discarded.<br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para cargar los valores de la piscina de constantes en el código de bytes, se proporcionan comandos </font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ldc_w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>ldc2_w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. De interés para nosotros es el primero de ellos </font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A diferencia de los demás, solo puede cargar valores de los primeros 255 espacios del grupo constante, pero se necesita 1 byte menos en bytecode. Todo esto nos da ahorros de hasta 255 bytes y un </font></font><code>255 + ((65_524 - (255 * 5)) / 6) = 10_963</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemento en la enumeración. Esta vez el crecimiento no es tan impresionante, pero todavía está allí. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Armado con este conocimiento, comencemos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el bloque de inicialización estática, en lugar de llamadas a métodos, </font></font><code>nextValue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ahora cargaremos el valor de la constante dinámica. El valor del </font></font><code>ordinal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">índice ordinal del elemento de enumeración se pasará explícitamente, eliminando así el campo </font></font><code>valueIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el método de fábrica</font></font><code>nextValue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y dudas sobre la seguridad del hilo de nuestra implementación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como método de arranque, utilizaremos un subtipo especial de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHandle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que imita el comportamiento de un operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en Java. </font><font style="vertical-align: inherit;">La biblioteca estándar para obtener dicho identificador de método proporciona el método </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHandles.Lookup :: findConstructor ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero en nuestro caso, la JVM se encargará de la construcción del identificador de método deseado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para usar el constructor de nuestra enumeración como método bootstrap, tendrá que modificarse ligeramente cambiando la firma. </font><font style="vertical-align: inherit;">Los parámetros necesarios para el método bootstrap se agregarán al constructor tradicional del elemento de enumeración de nombres y el número de serie:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">FizzBuzz</span><span class="hljs-params">(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; enumClass, <span class="hljs-keyword">int</span> ordinal)</span> </span>{
    <span class="hljs-keyword">super</span>(name, ordinal);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En forma de pseudocódigo, la inicialización se verá así:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Fizz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>);<font></font>
    Buzz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>);<font></font>
    FizzBuzz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>);<font></font>
<font></font>
    $VALUES = createValues();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el ejemplo anterior, las instrucciones se </font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">designan como llamadas de método </font></font><code>JVM_ldc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en el bytecode en su lugar serán las instrucciones JVM correspondientes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como ahora tenemos una constante separada para cada elemento de la enumeración, la creación y el llenado de la matriz </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">también se pueden implementar a través de una constante dinámica. </font><font style="vertical-align: inherit;">El método bootstrap es muy simple:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; clazz, FizzBuzz... elements) {
    <span class="hljs-keyword">return</span> elements;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo el truco en la lista de parámetros estáticos para esta constante dinámica, allí enumeraremos todos los elementos que queremos poner </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Métodos de arranque:</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1: # 54 REF_invokeStatic FizzBuzz.createValues: (Ljava / lang / invoke / MethodHandles $ Lookup; Ljava / lang / String; Ljava / lang / Class; [LFizzBuzz;) [LFizzBuzz;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Argumentos del método:</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      # 1 # 0: Fizz: LFizzBuzz;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      # 2 # 0: Zumbido: LFizzBuzz;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      # 3 # 0: FizzBuzz: LFizzBuzz;</font></font><font></font>
</pre><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La JVM estropea la matriz de estos parámetros estáticos y la pasa a nuestro método bootstrap como un parámetro vararg </font></font><code>elements</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El número máximo de parámetros estáticos es el tradicional 65_535, por lo que se garantiza que será suficiente para todos los elementos de la enumeración, sin importar cuántos haya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para las transferencias con una gran cantidad de elementos, este cambio reducirá el tamaño del archivo de clase resultante y, en el caso de que, debido a la gran cantidad de elementos, el método haya </font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tenido que dividirse en varias partes, también guarda ranuras en el grupo constante. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y al final, es simplemente hermoso.</font></font><br>
<br>
<a name="Surprise"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dificultades repentinas</font></font></h1><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que superamos heroicamente generando clases manualmente. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las bibliotecas de alto nivel proporcionan una interfaz conveniente a cambio de cierta restricción de la libertad de acción. </font><font style="vertical-align: inherit;">La biblioteca ASM que utilizamos para generar archivos de clase no es una excepción. </font><font style="vertical-align: inherit;">No proporciona mecanismos para controlar directamente el contenido del grupo de constantes. </font><font style="vertical-align: inherit;">Esto generalmente no es muy importante, pero no en nuestro caso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como recordará, necesitamos los primeros 255 elementos del grupo constante para guardar bytes preciosos en el bloque de inicialización estática. </font><font style="vertical-align: inherit;">Cuando se agregan constantes dinámicas de manera estándar, se ubicarán en índices aleatorios y se mezclarán con otros elementos que no son tan críticos para nosotros. </font><font style="vertical-align: inherit;">Esto nos impedirá alcanzar el máximo.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmento de un conjunto de constantes formadas de la manera tradicional.</font></font></b>
                        <div class="spoiler_text"><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Piscina constante:</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
   # 1 = Utf8 FizzBuzz</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
   # 2 = Clase # 1 // FizzBuzz</font></font><font></font>
   #3 = Utf8               java/lang/Enum<font></font>
   #4 = Class              #3             // java/lang/Enum<font></font>
   #5 = Utf8               $VALUES<font></font>
   #6 = Utf8               [LFizzBuzz;<font></font>
   #7 = Utf8               valueIndex<font></font>
   #8 = Utf8               I<font></font>
   #9 = Utf8               Fizz<font></font>
  #10 = Utf8               LFizzBuzz;<font></font>
  #11 = Utf8               Buzz<font></font>
  #12 = Utf8               FizzBuzz<font></font>
  #13 = Utf8               values<font></font>
  #14 = Utf8               ()[LFizzBuzz;<font></font>
  #15 = NameAndType        #5:#6          // $VALUES:[LFizzBuzz;<font></font>
  #16 = Fieldref           #2.#15         // FizzBuzz.$VALUES:[LFizzBuzz;<font></font>
  #17 = Class              #6             // "[LFizzBuzz;"<font></font>
  #18 = Utf8               clone<font></font>
  #19 = Utf8               ()Ljava/lang/Object;<font></font>
  #20 = NameAndType        #18:#19        // clone:()Ljava/lang/Object;<font></font>
  #21 = Methodref          #17.#20        // "[LFizzBuzz;".clone:()Ljava/lang/Object;<font></font>
  ...<font></font>
  #40 = NameAndType        #9:#10         // Fizz:LFizzBuzz;<font></font>
  #41 = Dynamic            #0:#40         // #0:Fizz:LFizzBuzz;<font></font>
  #42 = Fieldref           #2.#40         // FizzBuzz.Fizz:LFizzBuzz;<font></font>
  #43 = NameAndType        #11:#10        // Buzz:LFizzBuzz;<font></font>
  #44 = Dynamic            #0:#43         // #0:Buzz:LFizzBuzz;<font></font>
  #45 = Fieldref           #2.#43         // FizzBuzz.Buzz:LFizzBuzz;<font></font>
  #46 = NameAndType        #12:#10        // FizzBuzz:LFizzBuzz;<font></font>
  #47 = Dynamic            #0:#46         // #0:FizzBuzz:LFizzBuzz;<font></font>
  #48 = Fieldref           #2.#46         // FizzBuzz.FizzBuzz:LFizzBuzz;<font></font>
</pre><br>
</blockquote><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afortunadamente, existe una solución alternativa: al crear una clase, puede especificar una clase de muestra de la que se copiará un grupo de constantes y un atributo con una descripción de los métodos de arranque. </font><font style="vertical-align: inherit;">Solo que ahora tenemos que generarlo manualmente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, no es tan difícil como podría parecer a primera vista. </font><font style="vertical-align: inherit;">El formato del archivo de clase es bastante simple y su generación manual es un proceso algo tedioso, pero nada complicado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo más importante aquí es un plan claro. </font><font style="vertical-align: inherit;">Para enumerar a partir de los </font></font><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elementos que necesitamos:</font></font><br>
<br>
<ul>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registros de tipo </font></font><code>CONSTANT_Dynamic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: nuestras constantes dinámicas</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registros de tipo </font></font><code>CONSTANT_NameAndType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: pares de enlaces al nombre del elemento de enumeración y su tipo. </font><font style="vertical-align: inherit;">El tipo será el mismo para todos, este es el tipo de clase de nuestra enumeración.</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escribir registros </font></font><code>CONSTANT_Utf8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: directamente los nombres de los elementos de enumeración</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registros de tipo </font></font><code>CONSTANT_Integer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: números de serie de elementos de enumeración pasados ​​al constructor como un valor de parámetro</font></font><code>ordinal</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nombres de las clases actuales y básicas, atributos, firmas de métodos y otros detalles de implementación aburridos. </font><font style="vertical-align: inherit;">Los interesados ​​pueden consultar el código fuente del generador.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay muchos elementos constituyentes en el grupo de constantes que se refieren a otros elementos del grupo por índice, por lo que todos los índices que necesitamos deben calcularse por adelantado, </font></font><code>elementNames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es una lista de los nombres de los elementos de nuestra enumeración:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">int</span> elementCount = elementNames.size();<font></font>
<font></font>
<span class="hljs-keyword">int</span> baseConDy = <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> baseNameAndType = baseConDy + elementCount;
<span class="hljs-keyword">int</span> baseUtf8 = baseNameAndType + elementCount;
<span class="hljs-keyword">int</span> baseInteger = baseUtf8 + elementCount;
<span class="hljs-keyword">int</span> indexThisClass = baseInteger + elementCount;
<span class="hljs-keyword">int</span> indexThisClassUtf8 = indexThisClass + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexSuperClass = indexThisClassUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexSuperClassUtf8 = indexSuperClass + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodsUtf8 = indexSuperClassUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexConDyDescriptorUtf8 = indexBootstrapMethodsUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodHandle = indexConDyDescriptorUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodRef = indexBootstrapMethodHandle + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodNameAndType = indexBootstrapMethodRef + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodName = indexBootstrapMethodNameAndType + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodDescriptor = indexBootstrapMethodName + <span class="hljs-number">1</span>;<font></font>
<font></font>
<span class="hljs-keyword">int</span> constantPoolSize = indexBootstrapMethodDescriptor + <span class="hljs-number">1</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de eso, comenzamos a escribir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al principio: la firma del archivo de clase, los cuatro bytes conocidos por todos </font></font><nobr><code>0xCA 0xFE 0xBA 0xBE</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la versión del formato de archivo:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Class file header</span><font></font>
u4(CLASS_FILE_SIGNATURE);<font></font>
u4(version);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego, un grupo de constantes:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pool de constantes</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment">// Constant pool</span><font></font>
u2(constantPoolSize);<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Dynamic</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1u2u2(CONSTANT_Dynamic, i, baseNameAndType + i);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_NameAndType</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1u2u2(CONSTANT_NameAndType, baseUtf8 + i, indexConDyDescriptorUtf8);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Utf8</span>
<span class="hljs-comment">//noinspection ForLoopReplaceableByForEach</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1(CONSTANT_Utf8);<font></font>
    utf8(elementNames.get(i));<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Integer</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1(CONSTANT_Integer);<font></font>
    u4(i);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ThisClass</span><font></font>
u1(CONSTANT_Class);<font></font>
u2(indexThisClassUtf8);<font></font>
<font></font>
<span class="hljs-comment">// ThisClassUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(enumClassName);<font></font>
<font></font>
<span class="hljs-comment">// SuperClass</span><font></font>
u1(CONSTANT_Class);<font></font>
u2(indexSuperClassUtf8);<font></font>
<font></font>
<span class="hljs-comment">// SuperClassUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(JAVA_LANG_ENUM);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodsUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(ATTRIBUTE_NAME_BOOTSTRAP_METHODS);<font></font>
<font></font>
<span class="hljs-comment">// ConDyDescriptorUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(binaryEnumClassName);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodHandle</span><font></font>
u1(CONSTANT_MethodHandle);<font></font>
u1(REF_newInvokeSpecial);<font></font>
u2(indexBootstrapMethodRef);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodRef</span><font></font>
u1u2u2(CONSTANT_Methodref, indexThisClass, indexBootstrapMethodNameAndType);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodNameAndType</span><font></font>
u1u2u2(CONSTANT_NameAndType, indexBootstrapMethodName, indexBootstrapMethodDescriptor);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodName</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(BOOTSTRAP_METHOD_NAME);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodDescriptor</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(BOOTSTRAP_METHOD_DESCRIPTOR);<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de la constante de la piscina hablando de modificadores de acceso y banderas ( </font></font><code>public</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>enun</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, etc.), el nombre de la clase y su ancestro:</font></font><br>
<br>
<pre><code class="java hljs">u2(access);<font></font>
u2(indexThisClass);<font></font>
u2(indexSuperClass);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La clase ficticia que generamos no tendrá interfaces, ni campos, ni métodos, pero habrá un atributo con una descripción de los métodos de arranque:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Interfaces count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Fields count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Methods count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Attributes count</span>
u2(<span class="hljs-number">1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y aquí está el cuerpo del atributo mismo:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// BootstrapMethods attribute</span><font></font>
u2(indexBootstrapMethodsUtf8);<font></font>
<span class="hljs-comment">// BootstrapMethods attribute size</span>
u4(<span class="hljs-number">2</span> <span class="hljs-comment">/* num_bootstrap_methods */</span> + <span class="hljs-number">6</span> * elementCount);
<span class="hljs-comment">// Bootstrap method count</span><font></font>
u2(elementCount);<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {
    <span class="hljs-comment">// bootstrap_method_ref</span><font></font>
    u2(indexBootstrapMethodHandle);<font></font>
    <span class="hljs-comment">// num_bootstrap_arguments</span>
    u2(<span class="hljs-number">1</span>);
    <span class="hljs-comment">// bootstrap_arguments[1]</span><font></font>
    u2(baseInteger + i);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eso es todo, la clase está formada. </font><font style="vertical-align: inherit;">Tomamos estos bytes y creamos a partir de ellos </font></font><code>ClassReader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> ClassReader <span class="hljs-title">getBootstrapClassReader</span><span class="hljs-params">(<span class="hljs-keyword">int</span> version, <span class="hljs-keyword">int</span> access, String enumClassName, List&lt;String&gt; elementNames)</span> </span>{
    <span class="hljs-keyword">byte</span>[] bootstrapClassBytes = <span class="hljs-keyword">new</span> ConDyBootstrapClassGenerator(<font></font>
        version,<font></font>
        access,<font></font>
        enumClassName,<font></font>
        elementNames<font></font>
    )<font></font>
    .generate();<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (bootstrapClassBytes == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ClassReader(bootstrapClassBytes);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No fue tan difícil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Código fuente del generador: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConDyBootstrapClassGenerator.java</font></font></a><br>
<a name="Future"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Futuro brillante</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos desviamos brevemente de nuestros listados:</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscoverConstantValueAttribute</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String STRING = <span class="hljs-string">"Habrahabr, world!"</span>;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object OBJECT = <span class="hljs-keyword">new</span> Object();<font></font>
<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el bloque de inicialización estática de esta clase, de repente solo habrá una operación de escritura, en el campo </font></font><code>OBJECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">static</span> {<font></font>
    OBJECT = <span class="hljs-keyword">new</span> Object();
    <span class="hljs-comment">//  0: new           #2                  // class java/lang/Object</span>
    <span class="hljs-comment">//  3: dup</span>
    <span class="hljs-comment">//  4: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span>
    <span class="hljs-comment">//  7: putstatic     #7                  // Field OBJECT:Ljava/lang/Object;</span>
    <span class="hljs-comment">// 10: return</span><font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Pero que pasa </font></font><code>STRING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El equipo ayudará a arrojar luz sobre este acertijo </font></font><nobr><code>javap -c -s -p -v DiscoverConstantValueAttribute.class</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aquí está el fragmento que nos interesa:</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.String STRING;<font></font>
  descriptor: Ljava/lang/String;<font></font>
  flags: (<span class="hljs-number">0x0019</span>) ACC_PUBLIC, ACC_STATIC, ACC_FINAL<font></font>
  ConstantValue: String Habrahabr, world!<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El valor del campo final estático se ha movido del bloque de inicialización a un atributo separado </font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto es lo que escriben sobre este atributo en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMS11 §4.7.2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un atributo ConstantValue representa el valor de una expresión constante (JLS §15.28) y se usa de la siguiente manera:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si se establece el indicador ACC_STATIC en el elemento access_flags de la estructura field_info, al campo representado por la estructura field_info se le asigna el valor representado por su atributo ConstantValue como parte de la inicialización de la clase o interfaz que declara el campo (§5.5). </font><font style="vertical-align: inherit;">Esto ocurre antes de la invocación del método de inicialización de clase o interfaz de esa clase o interfaz (§2.9.2).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De lo contrario, la máquina virtual Java debe ignorar silenciosamente el atributo.</font></font></li>
</ul><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si tal atributo ocurre al mismo tiempo </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(aunque este último no se explica explícitamente aquí) en un campo, dicho campo se inicializa con el valor de este atributo. </font><font style="vertical-align: inherit;">Y esto sucede incluso antes de que se llame al método de inicialización estática. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sería tentador utilizar este atributo para inicializar los elementos de la enumeración, en nuestro capítulo anterior solo había constantes, aunque dinámicas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y no somos los primeros en pensar en esta dirección, hay una mención en JEP 309 </font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Desafortunadamente, esta mención se encuentra en el capítulo Trabajo futuro:</font></font><br>
<br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabajo</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
futuro Las posibles extensiones futuras incluyen: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adjuntar constantes dinámicas al atributo ConstantValue de campos estáticos</font></font></li>
</ul><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mientras tanto, solo podemos soñar con los momentos en que esta función pasará del estado "bueno" a "listo". </font><font style="vertical-align: inherit;">Luego, las restricciones sobre el tamaño del código en el bloque de inicialización perderán su influencia y el número máximo de elementos en la enumeración determinará las limitaciones del grupo constante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Según estimaciones aproximadas, en este caso podemos esperar un </font></font><code>65&nbsp;489 / 4 = 16_372</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemento. </font><font style="vertical-align: inherit;">Aquí </font></font><code>65_489</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">está el número de ranuras desocupadas del grupo constante, 46 de los 65_535 teóricamente posibles fueron a gastos generales. </font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- el número de ranuras requeridas para la declaración de un campo y la constante dinámica correspondiente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El número exacto, por supuesto, se puede encontrar solo después del lanzamiento de la versión JDK con soporte para esta función.</font></font><br>
<br>
<a name="Unsafe"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inseguro</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestro enemigo es el crecimiento lineal del bloque de inicialización con un aumento en el número de elementos de enumeración. </font><font style="vertical-align: inherit;">Si hubiéramos encontrado una manera de reducir la inicialización en un bucle, eliminando así la relación entre el número de elementos en la enumeración y el tamaño del bloque de inicialización, habríamos hecho otro gran avance. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desafortunadamente, ninguna de las API públicas estándar permite escribir en </font></font><code>static final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campos incluso dentro de un bloque de inicialización estático. </font><font style="vertical-align: inherit;">Ni Reflection ni VarHandles ayudarán aquí. </font><font style="vertical-align: inherit;">Nuestra única esperanza es grande y terrible </font></font><code>sun.misc.Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una ejecución insegura de FizzBuzz podría verse así:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FizzBuzz inseguro</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword">import</span> java.lang.reflect.Field;
<span class="hljs-keyword">import</span> sun.misc.Unsafe;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> FizzBuzz {<font></font>
<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz[] $VALUES;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz Fizz;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz Buzz;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz FizzBuzz;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FizzBuzz[] values() {
        <span class="hljs-keyword">return</span> (FizzBuzz[]) $VALUES.clone();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FizzBuzz <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">return</span> (FizzBuzz) Enum.valueOf(FizzBuzz.class, name);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">FizzBuzz</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>{
        <span class="hljs-keyword">super</span>(name, ordinal);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FizzBuzz[] {<font></font>
            Fizz,<font></font>
            Buzz,<font></font>
            FizzBuzz<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span>  {<font></font>
        Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
        unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
        String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
            String fieldName = fieldNames[i];<font></font>
            Field field = FizzBuzz.class.getDeclaredField(fieldName);<font></font>
            <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
            unsafe.putObject(FizzBuzz.class, fieldOffset, <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i));<font></font>
        }<font></font>
<font></font>
        $VALUES = createValues();<font></font>
    }<font></font>
<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este enfoque nos permite crear una enumeración con aproximadamente 21 mil elementos; para más, la capacidad del grupo de constantes no es suficiente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La documentación en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enum :: ordinal ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> requiere que su valor coincida con el número de secuencia del elemento correspondiente en la declaración de enumeración, por lo que debe almacenar explícitamente la lista de nombres de campo en el orden correcto, casi duplicando el tamaño del archivo de clase.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">public final int ordinal () </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Devuelve el ordinal de esta constante de enumeración (su posición en su declaración de enumeración, donde a la constante inicial se le asigna un ordinal de cero).</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí la API pública de los contenidos del grupo de constantes podría ayudar, ya sabemos cómo llenarla en el orden que necesitamos, pero no existe tal API y es poco probable que lo sea. El método </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class :: getConstantPool ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> disponible en OpenJDK se </font><font style="vertical-align: inherit;">declara como paquete privado y sería imprudente confiar en él en el código de usuario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El bloque de inicialización ahora es bastante compacto y casi independiente del número de elementos en la enumeración, por lo que </font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede rechazarlo incrustando su cuerpo en el bucle:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
    unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
    Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
    String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
    FizzBuzz[] localValues = <span class="hljs-keyword">new</span> FizzBuzz[fieldNames.length];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
        String fieldName = fieldNames[i];<font></font>
        Field field = FizzBuzz.class.getDeclaredField(fieldName);<font></font>
        <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
        unsafe.putObject(<font></font>
            FizzBuzz.class,<font></font>
            fieldOffset,<font></font>
            (localValues[i] = <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i))<font></font>
        );<font></font>
    }<font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí ocurre un proceso similar a una avalancha: junto con el método </font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, las instrucciones para leer los campos de elementos de enumeración desaparecen, los registros de tipo </font></font><code>Fieldref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para estos campos se </font><font style="vertical-align: inherit;">vuelven innecesarios </font><font style="vertical-align: inherit;">y, por lo tanto, los </font></font><code>NameAndType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registros de tipo para los registros de tipo </font></font><code>Fieldref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En el grupo constante, </font></font><code>2 * &lt;   &gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se </font><font style="vertical-align: inherit;">liberan </font><font style="vertical-align: inherit;">ranuras que se pueden usar para declarar elementos de enumeración adicionales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero no todo es tan optimista, las pruebas muestran una reducción significativa del rendimiento: inicializar una clase de enumeración con 65 mil elementos lleva un minuto y medio impensable. Como resultó bastante rápido, "el reflejo se ralentiza". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La implementación de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class :: getDeclaredField ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en OpenJDK tiene un comportamiento asintótico lineal del número de campos en la clase, y nuestro bloque de inicialización es cuadrático debido a esto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregar almacenamiento en caché mejora un poco la situación, aunque no la resuelve por completo:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
    unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
    Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
    String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
    Field[] fields = FizzBuzz.class.getDeclaredFields();<font></font>
    HashMap&lt;String, Field&gt; cache = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(fields.length);<font></font>
<font></font>
    <span class="hljs-keyword">for</span>(Field field : fields) {<font></font>
        cache.put(field.getName(), field);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
        String fieldName = fieldNames[i];<font></font>
        Field field = cache.get(fieldName);<font></font>
        <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
        unsafe.putObject(<font></font>
            FizzBuzz.class,<font></font>
            fieldOffset,<font></font>
            (localValues[i] = <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i))<font></font>
        );<font></font>
    }    <font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El enfoque inseguro descrito en este capítulo le permite crear transferencias con el número de elementos hasta 65_410, que es casi 24 veces más que el resultado alcanzable con javac y está bastante cerca del límite teórico de 65_505 elementos calculados por nosotros en la publicación anterior del ciclo.</font></font><br>
<br>
<a name="Testing"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verificar rendimiento</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para las pruebas, tomamos la enumeración más grande y la generamos usando el comando </font></font><nobr><code>java -jar HugeEnumGen.jar -a Unsafe UnsafeHugeEnum</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Como resultado, obtenemos un archivo de clase con un tamaño de 2 megabytes y 65_410 elementos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cree un nuevo proyecto Java en IDEA y agregue la clase generada como una biblioteca externa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Casi de inmediato, se hace evidente que IDEA no está lista para tal prueba de esfuerzo: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m4/su/-6/m4su-6bvdkkqmf3pypqrmpzntnw.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
la finalización automática de un elemento de enumeración lleva decenas de segundos tanto en el antiguo i5 móvil como en el i7 8700K más moderno. Y si intenta utilizar una solución rápida para agregar los elementos que faltan al conmutador, IDEA incluso deja de volver a dibujar las ventanas. Sospecho que temporalmente, pero no pude esperar a que se completara. La capacidad de respuesta durante la depuración también deja mucho que desear. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comencemos con una pequeña cantidad de elementos en </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFew</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>{
        <span class="hljs-keyword">for</span>(String arg : args) {<font></font>
            System.out.print(arg + <span class="hljs-string">" : "</span>);<font></font>
<font></font>
            <span class="hljs-keyword">try</span> {<font></font>
                UnsafeHugeEnum value = UnsafeHugeEnum.valueOf(arg);<font></font>
<font></font>
                doSwitch(value);<font></font>
            } <span class="hljs-keyword">catch</span>(Throwable e) {<font></font>
                e.printStackTrace(System.out);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSwitch</span><span class="hljs-params">(UnsafeHugeEnum value)</span> </span>{
        <span class="hljs-keyword">switch</span>(value) {
            <span class="hljs-keyword">case</span> VALUE_00001:<font></font>
                System.out.println(<span class="hljs-string">"First"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> VALUE_31415:<font></font>
                System.out.println(<span class="hljs-string">"(int) (10_000 * Math.PI)"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> VALUE_65410:<font></font>
                System.out.println(<span class="hljs-string">"Last"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:<font></font>
                System.out.println(<span class="hljs-string">"Unexpected value: "</span> + value);
                <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
    }<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí no hay sorpresas, la compilación y el lanzamiento son regulares:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ java TestFew VALUE_00001 VALUE_00400 VALUE_31415 VALUE_65410<font></font>
VALUE_00001 : First<font></font>
VALUE_00400 : Unexpected value: VALUE_00400<font></font>
VALUE_31415 : (int) (10_000 * Math.PI)<font></font>
VALUE_65410 : Last<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué pasa con más artículos en </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">¿Podemos, por ejemplo, procesar </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todos nuestros 65 mil elementos </font><font style="vertical-align: inherit;">en uno a la </font><font style="vertical-align: inherit;">vez?</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">switch</span>(value) {
    <span class="hljs-keyword">case</span> VALUE_00001:
    <span class="hljs-keyword">case</span> VALUE_00002:<font></font>
        ...<font></font>
    <span class="hljs-keyword">case</span> VALUE_65410:<font></font>
        System.out.println(<span class="hljs-string">"One of known values: "</span> + value);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:<font></font>
        System.out.println(<span class="hljs-string">"Unexpected value: "</span> + value);
        <span class="hljs-keyword">break</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por desgracia no. </font><font style="vertical-align: inherit;">Cuando intentamos compilar, recibimos un montón de mensajes de error:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ javac -fullversion<font></font>
javac full version "14.0.1+7"<font></font>
<font></font>
$ javac TestAll.java<font></font>
TestAll.java:18: error: code too large for try statement<font></font>
        switch(value) {<font></font>
        ^<font></font>
TestAll.java:65433: error: too many constants<font></font>
                break;<font></font>
                ^<font></font>
TestAll.java:17: error: code too large<font></font>
    private static void doSwitch(UnsafeHugeEnum value) {<font></font>
                        ^<font></font>
TestAll.java:1: error: too many constants<font></font>
public class TestAll {<font></font>
       ^<font></font>
4 errors<font></font>
</code></pre><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testfew.java</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TestAll.java</font></font></a></li>
</ul><br>
<a name="JavacSwitchTranslation"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac y switch</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comprender lo que está sucediendo, tenemos que descubrir cómo se produce la traducción </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de los elementos de la enumeración. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La especificación JVM tiene un capítulo separado en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMS11 §3.10 Compilación de conmutadores</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cuyas recomendaciones se reducen al </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uso de una de las dos instrucciones de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">código de bytes</font></a><font style="vertical-align: inherit;"> , </font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>lookupswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No encontraremos </font><font style="vertical-align: inherit;">ninguna referencia </font><font style="vertical-align: inherit;">a cadenas o elementos de enumeración en este capítulo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mejor documentación es el código, por lo que es hora de sumergirse en la fuente </font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La elección entre </font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>lookupswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ocurre en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gen :: visitSwitch ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y depende del número de opciones en </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En la mayoría de los casos, gana </font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Determine whether to issue a tableswitch or a lookupswitch</span>
<span class="hljs-comment">// instruction.</span>
<span class="hljs-keyword">long</span> table_space_cost = <span class="hljs-number">4</span> + ((<span class="hljs-keyword">long</span>) hi - lo + <span class="hljs-number">1</span>); <span class="hljs-comment">// words</span>
<span class="hljs-keyword">long</span> table_time_cost = <span class="hljs-number">3</span>; <span class="hljs-comment">// comparisons</span>
<span class="hljs-keyword">long</span> lookup_space_cost = <span class="hljs-number">3</span> + <span class="hljs-number">2</span> * (<span class="hljs-keyword">long</span>) nlabels;
<span class="hljs-keyword">long</span> lookup_time_cost = nlabels;
<span class="hljs-keyword">int</span> opcode =<font></font>
    nlabels &gt; <span class="hljs-number">0</span> &amp;&amp;<font></font>
    table_space_cost + <span class="hljs-number">3</span> * table_time_cost &lt;=<font></font>
    lookup_space_cost + <span class="hljs-number">3</span> * lookup_time_cost<font></font>
    ?<font></font>
    tableswitch : lookupswitch;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El encabezado </font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es de aproximadamente 16 bytes más 4 bytes por valor. </font><font style="vertical-align: inherit;">Por lo tanto, </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bajo ninguna circunstancia puede haber más </font></font><code>( 65_535 - 16 ) / 4 = 16_379</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elementos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, después de reducir el número de ramas </font></font><code>case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el cuerpo </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a 16 mil, solo queda un error de compilación, el más misterioso:</font></font><br>
<br>
<pre><code class="plaintext hljs">TestAll.java:18: error: code too large for try statement<font></font>
        switch(value) {<font></font>
        ^<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En busca de la fuente del error, volveremos un poco antes, a la etapa de deshacernos del azúcar sintáctico. </font><font style="vertical-align: inherit;">Los </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">métodos son responsables de la </font><font style="vertical-align: inherit;">traducción </font></font><code>visitEnumSwitch()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>mapForEnum()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la clase </font></font><code>EnumMapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lower.java</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Allí también encontramos un pequeño comentario documental:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EnumMapping JavaDoc</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment">/** This map gives a translation table to be used for enum
 *  switches.
 *
 *  &lt;p&gt;For each enum that appears as the type of a switch
 *  expression, we maintain an EnumMapping to assist in the
 *  translation, as exemplified by the following example:
 *
 *  &lt;p&gt;we translate
 *  &lt;pre&gt;
 *          switch(colorExpression) {
 *          case red: stmt1;
 *          case green: stmt2;
 *          }
 *  &lt;/pre&gt;
 *  into
 *  &lt;pre&gt;
 *          switch(Outer$0.$EnumMap$Color[colorExpression.ordinal()]) {
 *          case 1: stmt1;
 *          case 2: stmt2
 *          }
 *  &lt;/pre&gt;
 *  with the auxiliary table initialized as follows:
 *  &lt;pre&gt;
 *          class Outer$0 {
 *              synthetic final int[] $EnumMap$Color = new int[Color.values().length];
 *              static {
 *                  try { $EnumMap$Color[red.ordinal()] = 1; } catch (NoSuchFieldError ex) {}
 *                  try { $EnumMap$Color[green.ordinal()] = 2; } catch (NoSuchFieldError ex) {}
 *              }
 *          }
 *  &lt;/pre&gt;
 *  class EnumMapping provides mapping data and support methods for this translation.
 */</span>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El misterioso </font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resulta ser parte de una clase auxiliar generada automáticamente </font></font><code>TestAll$0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Inside: una declaración de una matriz estática y un código para inicializarla. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La matriz corrige la correspondencia entre los nombres de los elementos de enumeración y los </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valores numéricos </font><font style="vertical-align: inherit;">asignados a ellos durante la compilación </font><font style="vertical-align: inherit;">, protegiendo así el código compilado de los efectos nocivos de la refactorización. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al reordenar, agregar nuevos o eliminar elementos de enumeración existentes, algunos de ellos pueden cambiar el valor </font></font><code>ordinal()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y esto es de lo que protege un nivel adicional de indirección.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">try</span> {<font></font>
    $SwitchMap$UnsafeHugeEnum[UnsafeHugeEnum.VALUE_00001.ordinal()] = <span class="hljs-number">1</span>;
    <span class="hljs-comment">//  9: getstatic     #2                  // Field $SwitchMap$UnsafeHugeEnum:[I</span>
    <span class="hljs-comment">// 12: getstatic     #3                  // Field UnsafeHugeEnum.VALUE_00001:LUnsafeHugeEnum;</span>
    <span class="hljs-comment">// 15: invokevirtual #4                  // Method UnsafeHugeEnum.ordinal:()I</span>
    <span class="hljs-comment">// 18: iconst_1</span>
    <span class="hljs-comment">// 19: iastore</span><font></font>
}<font></font>
<span class="hljs-comment">// 20: goto          24</span>
<span class="hljs-keyword">catch</span>(NoSuchFieldError e) { }
<span class="hljs-comment">// 23: astore_0</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El código de inicialización es simple y consume de 15 a 17 bytes por elemento. </font><font style="vertical-align: inherit;">Como resultado, el bloque de inicialización estática acomoda la inicialización de no más de 3_862 elementos. </font><font style="vertical-align: inherit;">Este número resulta ser el número máximo de elementos de enumeración que podemos usar en uno </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con la implementación actual </font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="Conclusion"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusión</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vimos que el uso de incluso una técnica tan simple como asignar la creación de elementos de enumeración e inicializar una matriz </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en un método separado le permite aumentar el número máximo de elementos en una enumeración de 2_746 a 10_920. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los resultados dinámicos constantes en el contexto de logros anteriores no se ven muy impresionantes y le permiten obtener solo 43 elementos más, pero con este enfoque es mucho más elegante agregar nuevas propiedades a la enumeración: simplemente modifique el constructor y pase los valores necesarios a través de los parámetros estáticos de la constante dinámica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si en algún momento en el futuro </font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se enseñara el </font><font style="vertical-align: inherit;">atributo </font><font style="vertical-align: inherit;">a comprender las constantes dinámicas, este número podría aumentar de 10 mil a 16. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usar</font></font><code>sun.misc.Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le permite dar un salto gigante y aumentar el número máximo de elementos a 65_410. Pero no olvide que </font></font><code>Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta es una API patentada que puede desaparecer con el tiempo y su uso es un riesgo considerable, ya que javac advierte directamente:</font></font><br>
<br>
<pre><code class="plaintext hljs">Test.java:3: warning: Unsafe is internal proprietary API and may be removed in a future release<font></font>
import sun.misc.Unsafe;<font></font>
               ^<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero, como resultó, no es suficiente generar una enumeración gigante, también debe poder usarla. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Actualmente, existen problemas con el soporte de tales enumeraciones tanto desde el IDE como a nivel del compilador Java. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un gran número de campos en la clase puede degradar la capacidad de respuesta del IDE tanto durante la edición como durante la depuración. </font><font style="vertical-align: inherit;">A veces hasta una caída completa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las restricciones impuestas por el formato de archivo de clase y los detalles de implementación de javac hacen que sea imposible usar </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">más de 3_862 elementos </font><font style="vertical-align: inherit;">en el código </font><font style="vertical-align: inherit;">al mismo tiempo. </font><font style="vertical-align: inherit;">De los aspectos positivos, vale la pena mencionar que estos pueden ser elementos arbitrarios 3_862. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mejora adicional de los resultados solo es posible a través del refinamiento del compilador de Java, pero esta es una historia completamente diferente.</font></font><br>
<br>
<a name="Appendix"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Materiales adicionales</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Código fuente de GitHub: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/Maccimo/HugeEnumGeneratorArticle</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Archivo JAR recopilado: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/Maccimo/HugeEnumGeneratorArticle/releases/tag/v1.0</font></font></a><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ayuda de inicio compatible</font></font></b>
                        <div class="spoiler_text"><pre><font></font>
Huge enumeration generator<font></font>
<font></font>
    https://github.com/Maccimo/HugeEnumGeneratorArticle<font></font>
<font></font>
Additional information (in Russian):<font></font>
<font></font>
    https://habr.com/ru/post/483392/<font></font>
    https://habr.com/ru/post/501870/<font></font>
<font></font>
Usage:<font></font>
    java -jar HugeEnumGen.jar [ &lt;options&gt; ] &lt;enum name&gt;<font></font>
<font></font>
    &lt;enum name&gt;<font></font>
        An enumeration class name.<font></font>
        Should be a valid Java identifier. May contain package name.<font></font>
<font></font>
Options:<font></font>
<font></font>
    -d &lt;directory&gt;<font></font>
        Output directory path.<font></font>
        Current working directory by default.<font></font>
<font></font>
    -e &lt;item list file&gt;<font></font>
        Path to UTF8-encoded text file with list of enumeration item names.<font></font>
        Item names will be autogenerated if absent.<font></font>
        Mutually exclusive with the -c option.<font></font>
<font></font>
    -c &lt;count&gt;<font></font>
        Count of autogenerated enumeration item names.<font></font>
        Mutually exclusive with the -e option.<font></font>
        Default value: Algorithm-depended<font></font>
<font></font>
    -a &lt;algorithm&gt;<font></font>
        Enumeration generation algorithm.<font></font>
        Supported algorithms:<font></font>
          ConDy          - Employ Constant Dynamic (JEP 309) for enum elements initialization<font></font>
          ExtractMethod  - Extract enum elements initialization code to separate method<font></font>
          Unsafe         - Employ sun.misc.Unsafe for enum elements initialization<font></font>
<font></font>
        Default algorithm: ExtractMethod<font></font>
<font></font>
    -h / -?<font></font>
        Show this help page.<font></font>
<font></font>
Example:<font></font>
<font></font>
    java -jar HugeEnumGen.jar -d ./bin -c 2020 com.habr.maccimo.HugeEnum2020<font></font>
<font></font>
</pre><br>
</div>
                    </div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es501860/index.html">15 de mayo RU-Center puede agregarle un servicio pago sin su participación</a></li>
<li><a href="../es501862/index.html">Aleteo bajo el capó</a></li>
<li><a href="../es501864/index.html">Asistente o inspector: ¿a quién llama el robot?</a></li>
<li><a href="../es501866/index.html">¿Cuántos trabajos destruirán los robots?</a></li>
<li><a href="../es501868/index.html">Cómo no dejar que el contador se arroje o transfiramos 1C a la nube. Instrucciones paso a paso</a></li>
<li><a href="../es501872/index.html">Lugar de estudio en sistemas cibernéticos.</a></li>
<li><a href="../es501874/index.html">Arquitecturas modernas de front-end (Parte 2)</a></li>
<li><a href="../es501880/index.html">Acerca de la traducción de "comienzos" y "comienzos" sin comenzar, comenzar y primero</a></li>
<li><a href="../es501882/index.html">Cómo usamos algoritmos de visión por computadora: procesamiento de video en un navegador móvil usando OpenCV.js</a></li>
<li><a href="../es501884/index.html">Cómo los archivos electrónicos de información médica ayudarán a diagnosticar enfermedades de manera más efectiva</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>