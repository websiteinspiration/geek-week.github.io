<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏅 🥛 💆🏼 モバイルPvPシューティングゲームの物理学と、ECSとの友情 🤘🏾 🤦🏿 🧑‍🤝‍🧑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="みなさん、こんにちは！この記事では、マルチプレイヤーシューティングゲームの物理エンジンを操作する個人的な経験について説明し、主に物理学とECSの相互作用に焦点を当てます。作業中にどのような種類のレーキを取り入れたか、学んだこと、特定の解決策に着手した理由。
 
 
 
 まず、物理エンジンが必要な理...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>モバイルPvPシューティングゲームの物理学と、ECSとの友情</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/481880/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">みなさん、こんにちは！この記事では、マルチプレイヤーシューティングゲームの物理エンジンを操作する個人的な経験について説明し、主に物理学と</font></font><abbr title="ECSは、データをロジックから分離するデータ指向のアプローチです。 データは、エンティティおよびエンティティに属するコンポーネントとして表されます。 ロジックはシステムで説明されており、通常、エンティティのコンポーネントを通過して変更し、新しいコンポーネントとエンティティを作成します。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECSの</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相互作用に焦点を当てます。</font><font style="vertical-align: inherit;">作業中にどのような種類のレーキを取り入れたか、学んだこと、特定の解決策に着手した理由。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gp/b_/2-/gpb_2-4ml1nwdsb443-f2pp6zyu.png"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、物理エンジンが必要な理由を理解しましょう。普遍的な答えはありません。どのゲームでも目的を果たします。一部のゲームでは、物理エンジンを使用して、世界のオブジェクトの動作を正しくシミュレートし、プレイヤーを没入させる効果を実現しています。他のゲームでは、物理はゲームプレイの基礎です-たとえば、Angry BirdsやRed Factionなど。また、物理的な法則が通常の法則とは異なる「サンドボックス」もあり、ゲームプレイがより面白く、珍しいものになっています（Portal、A Slower Speed of Light）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラミングの観点からは、物理エンジンにより、ゲーム内のオブジェクトの動作をシミュレートするプロセスを簡略化できます。実際、これはオブジェクトの物理プロパティの記述を格納するライブラリです。物理的なエンジンが存在する場合、ゲーム世界が生きる身体と普遍的な法則との間の相互作用のシステムを開発する必要はありません。これにより、膨大な時間と開発作業を節約できます。</font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">上</font></a></i></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5ef/938/61f/5ef93861ff7c4921e44bcf14902cab51.jpg" alt="画像"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図では</font></font></a>   Player,     ,  ,       .      :      —  Transform  Movement,  MoveSystem;   -     —  Health, Damage,  DamageSystem;       (respawn) —  Transform  ,  RespawnSystem;    —  Invincible.</i><br>
<br>
<h2>        ?</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのゲームには複雑な物理的相互作用はありませんが、物理的エンジンが依然として必要となる多くのものがあります。最初は、これを使用して、所定の法則に従って世界のキャラクターを移動する予定でした。通常、これはボディに特定のインパルスまたは一定の速度を与えることによって行われます。その後、ライブラリのSimulate / Updateメソッドを使用して、そこに登録されているすべてのボディが1ステップだけシミュレートされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シューティングゲームでは、キャラクターの動きをシミュレートするだけでなく、弾丸やロケットの弾道、ジャンプ、キャラクター同士の相互作用や環境を正しく処理するために、3D物理がよく使用されます。射手が現実的であると主張し、射撃プロセスの本当の感覚を伝えようとする場合、物理的なエンジンが必要です。プレーヤーがターゲットにショットガンを撃ったとき、彼は経験と、シューティングゲームの長期的なゲームからすでに知っているものに可能な限り近い結果を得ることを期待しています-根本的に新しい何かは、おそらく彼を不愉快に驚かせます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私たちのゲームの場合、いくつかの制限があります。私たちのシューティングゲームは可動式であるため、キャラクター同士や周囲の世界との複雑な相互作用を意味するものではなく、美しい弾道、破壊性、凹凸のある表面でのジャンプを必要としません。しかし同時に、同じ理由で、非常に厳しいトラフィック要件があります。この場合、3D物理演算は冗長になります。コンピューティングリソースのごく一部しか使用せず、不要なデータを生成します。モバイルネットワークでは、UDPを介してクライアントとサーバーを常に同期すると、必要なスペースが大きくなります。私たちのネットワークモデルには、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">予測や調整</font></a><font style="vertical-align: inherit;">などのものがまだ残っていることを思い出してください。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、クライアントの和解も含みます。その結果、レンダーや他のクライアントサブシステムに干渉することなく、モバイルデバイスで正常に起動して作業するために、物理演算が可能な限り高速に動作するはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、3D物理学は私たちに適していませんでした。ただし、ここでは、ゲームが3次元のように見えても、物理が3次元であることは事実ではありません。すべてがオブジェクトの相互作用の性質を決定します。多くの場合、2D物理ではカバーできない効果はカスタマイズされます。つまり、3次元の相互作用のように見えるロジックが作成されるか、ゲームプレイに影響を与えない視覚効果に単純に置き換えられます。 Heroes of the Storm、Defense of the Ancients、League of Legendsでは、2次元の物理学により、ゲームのデザイナーやアーティストが作成した画像の品質や信頼性に影響を与えることなく、ゲームのすべてのゲームプレイ機能を提供できます。たとえば、これらのゲームではジャンプするキャラクターがいますが、ジャンプの高さに物理的な感覚はありません。したがって、それは2次元シミュレーションに帰着し、キャラクターが空中にいるときに_isInTheAir形式のフラグを設定します-ロジックを計算するときに考慮されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、2D物理演算を使用することが決定されました。ゲームはUnityで記述していますが、サーバーはUnityなしの.netを使用していますが、Unityはこれを理解していません。シミュレーションコードの大部分がクライアントとサーバーの間でぶつかるので、クロスプラットフォーム、つまりモバイルプラットフォームのクラッシュのリスクを排除するネイティブコードを使用せずに純粋なC＃で記述された物理ライブラリを探し始めました。さらに、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">射手の詳細</font></a><font style="vertical-align: inherit;">を考慮に入れる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特に、プレーヤーがどこを撃っていたかを特定するためにサーバー上で一定の巻き戻しを行うことは、ライブラリが履歴と連動できることが重要でした。つまり、Nフレーム前のボディの位置を安く確認できました。そしてもちろん、プロジェクトは放棄されるべきではありません。作者がそれをサポートし、運用中にバグが見つかった場合はすぐにバグを修正できることが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結局のところ、現時点では、要件を満たすことができるライブラリはほとんどありません。実際、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VolatilePhysicsの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1つだけが私たちに適していました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このライブラリは、UnityとUnityを使用しないソリューションの両方で機能し、オブジェクトの過去の状態にすぐに再キャストできるようにするという点で注目に値します。</font><font style="vertical-align: inherit;">シューティングロジックに適しています。</font><font style="vertical-align: inherit;">さらに、ライブラリの利便性は、シミュレーションの開始Simulate（）を制御するためのメカニズムにより、クライアントが必要なときにいつでもそれを生成できることにあります。</font><font style="vertical-align: inherit;">もう1つの機能-追加のデータを身体に書き込む機能。</font><font style="vertical-align: inherit;">これは、reykastの結果でシミュレーションからオブジェクトをアドレス指定するときに役立ちますが、パフォーマンスが大幅に低下します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかのテストを行い、クライアントとサーバーがクラッシュせずにVolatilePhysicsと適切に相互作用することを確認した後、それを選択しました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリをECSで作業する通常の方法にどのように入力したか、およびそれから何が得られたか</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VolatilePhysicsで作業するときの最初のステップは、VoltWorldの物理的な世界を作成することです。</font><font style="vertical-align: inherit;">これは、主な作業が行われるプロキシクラスです：チューニング、オブジェクトに関するデータのシミュレーション、レイクキャストなど。特別なファサードにラップして、将来、ライブラリの実装を別のものに変更できるようにしました。</font><font style="vertical-align: inherit;">ファサードコードは次のようになります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを表示</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PhysicsWorld</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> HistoryLength = <span class="hljs-number">32</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> VoltWorld _voltWorld;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Dictionary&lt;<span class="hljs-keyword">uint</span>, VoltBody&gt; _cache = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">uint</span>, VoltBody&gt;();<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PhysicsWorld</span>(<span class="hljs-params"><span class="hljs-keyword">float</span> deltaTime</span>)</span><font></font>
    {<font></font>
        _voltWorld = <span class="hljs-keyword">new</span> VoltWorld(HistoryLength) { DeltaTime = deltaTime };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">HasBody</span>(<span class="hljs-params"><span class="hljs-keyword">uint</span> tag</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> _cache.ContainsKey(tag);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> VoltBody <span class="hljs-title">GetBody</span>(<span class="hljs-params"><span class="hljs-keyword">uint</span> tag</span>)</span><font></font>
    {<font></font>
        VoltBody body;<font></font>
        _cache.TryGetValue(tag, <span class="hljs-keyword">out</span> body);
        <span class="hljs-keyword">return</span> body;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> VoltRayResult <span class="hljs-title">RayCast</span>(<span class="hljs-params">Vector2 origin, Vector2 direction, <span class="hljs-keyword">float</span> distance, VoltBodyFilter filter, <span class="hljs-keyword">int</span> ticksBehind</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> ray = <span class="hljs-keyword">new</span> VoltRayCast(origin, direction.normalized, distance);
        <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">new</span> VoltRayResult();<font></font>
<font></font>
        _voltWorld.RayCast(<span class="hljs-keyword">ref</span> ray, <span class="hljs-keyword">ref</span> result, filter, ticksBehind);
        <span class="hljs-keyword">return</span> result;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> VoltRayResult <span class="hljs-title">CircleCast</span>(<span class="hljs-params">Vector2 origin, Vector2 direction, <span class="hljs-keyword">float</span> distance, <span class="hljs-keyword">float</span> radius, VoltBodyFilter filter, <span class="hljs-keyword">int</span> ticksBehind</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> ray = <span class="hljs-keyword">new</span> VoltRayCast(origin, direction.normalized, distance);
        <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">new</span> VoltRayResult();<font></font>
<font></font>
        _voltWorld.CircleCast(<span class="hljs-keyword">ref</span> ray, radius, <span class="hljs-keyword">ref</span> result, filter, ticksBehind);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> result;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        _voltWorld.Update();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"><span class="hljs-keyword">uint</span> tag</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> body = _cache[tag];<font></font>
        _voltWorld.Update(body, <span class="hljs-literal">true</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateBody</span>(<span class="hljs-params"><span class="hljs-keyword">uint</span> tag, Vector2 position, <span class="hljs-keyword">float</span> angle</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> body = _cache[tag];<font></font>
        body.Set(position, angle);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateStaticCircle</span>(<span class="hljs-params">Vector2 origin, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">uint</span> tag</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> shape = _voltWorld.CreateCircleWorldSpace(origin, radius, <span class="hljs-number">1f</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>);
        <span class="hljs-keyword">var</span> body = _voltWorld.CreateStaticBody(origin, <span class="hljs-number">0</span>, shape);<font></font>
        body.UserData = tag;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateDynamicCircle</span>(<span class="hljs-params">Vector2 origin, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">uint</span> tag</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> shape = _voltWorld.CreateCircleWorldSpace(origin, radius, <span class="hljs-number">1f</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>);
        <span class="hljs-keyword">var</span> body = _voltWorld.CreateDynamicBody(origin, <span class="hljs-number">0</span>, shape);<font></font>
        body.UserData = tag;<font></font>
        body.CollisionFilter = StaticCollisionFilter;<font></font>
        _cache.Add(tag, body);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateStaticSquare</span>(<span class="hljs-params">Vector2 origin, <span class="hljs-keyword">float</span> rotationAngle, Vector2 extents, <span class="hljs-keyword">uint</span> tag</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> shape = _voltWorld.CreatePolygonBodySpace(extents.GetRectFromExtents(), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">var</span> body = _voltWorld.CreateStaticBody(origin, rotationAngle, shape);<font></font>
        body.UserData = tag;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateDynamicSquare</span>(<span class="hljs-params">Vector2 origin, <span class="hljs-keyword">float</span> rotationAngle, Vector2 extents, <span class="hljs-keyword">uint</span> tag</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> shape = _voltWorld.CreatePolygonBodySpace(extents.GetRectFromExtents(), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">var</span> body = _voltWorld.CreateDynamicBody(origin, rotationAngle, shape);<font></font>
        body.UserData = tag;<font></font>
        body.CollisionFilter = StaticCollisionFilter;<font></font>
        _cache.Add(tag, body);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;VoltBody&gt; <span class="hljs-title">GetBodies</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> _voltWorld.Bodies;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">StaticCollisionFilter</span>(<span class="hljs-params">VoltBody a, VoltBody b</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> b.IsStatic;<font></font>
    }<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
世界を作成するとき、歴史の大きさが示されます-ライブラリが保存する世界の状態の数。私たちの場合、それらの数は32でした：1秒あたり30フレーム。ロジックを更新する要件に基づいて必要であり、デバッグプロセスの制限を超えた場合に備えて、さらに2つ必要です。このコードでは、物理的なボディを生成する外部キャストメソッドや、さまざまな種類のレイキャストも考慮に入れています。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">以前の記事</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
から思い出すように</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ECSの世界は本質的に、すべてのシステムに対して定期的にExecuteメソッドを呼び出すことを中心に展開します。各システムの適切な場所で、ファサードへの呼び出しを使用します。最初は、物理的なエンジンに挑戦するためのバッチ処理は記述していませんでしたが、そのような考えはありました。ファサード内では、物理世界のUpdate（）の呼び出しが行われ、ライブラリは、フレームごとに発生したオブジェクトのすべての相互作用をシミュレートします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、物理演算は2つのコンポーネントに削減されます。1つのフレームでの空間内の体の均一な動きと、撮影に必要な多くのラカスト、エフェクトの適切な操作などです。レイカストは特に身体の状態の歴史に関連しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストの結果によると、ライブラリーはさまざまな速度では非常にうまく機能せず、特定の速度では体が壁を簡単に通過し始めることがすぐにわかりました。</font><font style="vertical-align: inherit;">このエンジンの問題を解決するための継続的な衝突検出に関連する設定はありませんでした。</font><font style="vertical-align: inherit;">しかし、当時の市場には私たちのソリューションに代わるものはなかったので、私は自分のバージョンのオブジェクトを世界中で動かし、物理データをECSと同期させる必要がありました。</font><font style="vertical-align: inherit;">したがって、たとえば、移動システムのコードは次のようになります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを表示</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">using</span> System;<font></font>
...<font></font>
<span class="hljs-keyword">using</span> Volatile;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MovePhysicsSystem</span> : <span class="hljs-title">ExecutableSystem</span><font></font>
{<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> PhysicsWorld _physicsWorld;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> CollisionFilter _moveFilter;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> VoltBodyFilter _collisionFilterDelegate;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MovePhysicsSystem</span>(<span class="hljs-params">PhysicsWorld physicsWorld</span>)</span><font></font>
    {<font></font>
        _physicsWorld = physicsWorld;<font></font>
        _moveFilter = <span class="hljs-keyword">new</span> CollisionFilter(<span class="hljs-literal">true</span>, CollisionLayer.ExplosiveBarrel);<font></font>
        _collisionFilterDelegate = _moveFilter.Filter;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span>(<span class="hljs-params">GameState gs</span>)</span><font></font>
    {<font></font>
        _moveFilter.State = gs;<font></font>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> pair <span class="hljs-keyword">in</span> gs.WorldState.Movement)<font></font>
        {<font></font>
            ExecuteMovement(gs, pair.Key, pair.Value);<font></font>
        }<font></font>
<font></font>
        _physicsWorld.Update();<font></font>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> pair <span class="hljs-keyword">in</span> gs.WorldState.PhysicsDynamicBody)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span>(pair.Value.IsAlive)<font></font>
            {<font></font>
                ExecutePhysicsDynamicBody(gs, pair.Key);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span>(<span class="hljs-params">GameState gs, <span class="hljs-keyword">uint</span> avatarId</span>)</span><font></font>
    {<font></font>
        _moveFilter.State = gs;<font></font>
        <span class="hljs-keyword">var</span> movement = gs.WorldState.Movement[avatarId];
        <span class="hljs-keyword">if</span> (movement != <span class="hljs-literal">null</span>)<font></font>
        {<font></font>
            ExecuteMovement(gs, avatarId, movement);<font></font>
<font></font>
            _physicsWorld.Update(avatarId);<font></font>
            <span class="hljs-keyword">var</span> physicsDynamicBody = gs.WorldState.PhysicsDynamicBody[avatarId];
            <span class="hljs-keyword">if</span> (physicsDynamicBody != <span class="hljs-literal">null</span> &amp;&amp; physicsDynamicBody.IsAlive)<font></font>
                ExecutePhysicsDynamicBody(gs, avatarId);<font></font>
        }<font></font>
<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ExecutePhysicsDynamicBody</span>(<span class="hljs-params">GameState gs, <span class="hljs-keyword">uint</span> entityId</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> body = _physicsWorld.GetBody(entityId);
        <span class="hljs-keyword">if</span> (body != <span class="hljs-literal">null</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> transform = gs.WorldState.Transform[entityId];<font></font>
            transform.Position = body.Position;<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ExecuteMovement</span>(<span class="hljs-params">GameState gs, <span class="hljs-keyword">uint</span> entityId, Movement movement</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> body = _physicsWorld.GetBody(entityId);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (body != <span class="hljs-literal">null</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">float</span> raycastRadius;
            <span class="hljs-keyword">if</span> (CalculateRadius(gs, entityId, <span class="hljs-keyword">out</span> raycastRadius))<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span>;<font></font>
            }<font></font>
<font></font>
            body.AngularVelocity = <span class="hljs-number">0</span>;<font></font>
            body.LinearVelocity = movement.Velocity;<font></font>
            <span class="hljs-keyword">var</span> movPhysicInfo = gs.WorldState.MovementPhysicInfo[entityId];
            <span class="hljs-keyword">var</span> collisionDirection = CircleRayCastSpeedCorrection(body, GameState.TickDurationSec, raycastRadius);<font></font>
            CheckMoveInWall(movement, movPhysicInfo, collisionDirection, gs.WorldState.Transform[entityId]);<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">CalculateRadius</span>(<span class="hljs-params">GameState gs, <span class="hljs-keyword">uint</span> id, <span class="hljs-keyword">out</span> <span class="hljs-keyword">float</span> raycastRadius</span>)</span><font></font>
    {<font></font>
        raycastRadius = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> circleShape = gs.WorldState.DynamicCircleCollider[id];
        <span class="hljs-keyword">if</span> (circleShape != <span class="hljs-literal">null</span>)<font></font>
        {<font></font>
            raycastRadius = circleShape.Radius;<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> boxShape = gs.WorldState.DynamicBoxCollider[id];
            <span class="hljs-keyword">if</span> (boxShape != <span class="hljs-literal">null</span>)<font></font>
            {<font></font>
                raycastRadius = boxShape.RaycastRadius;<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span><font></font>
            {<font></font>
                gs.Log.Error(<span class="hljs-keyword">string</span>.Format(<span class="hljs-string">"Physics body {0} doesn't contains shape!"</span>, id));
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CheckMoveInWall</span>(<span class="hljs-params">Movement movement, MovementPhysicInfo movPhysicInfo,
        Vector2 collisionDirection, Transform transform</span>)</span><font></font>
    {<font></font>
        <span class="hljs-comment">// 60 is the max angle when player move in wall and can shoot through the wall from weapon without target.</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxAngleToWall = <span class="hljs-number">60</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (movement.Velocity.IsEqual(Vector2.zero))<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (movPhysicInfo.LastCollisionDirection.IsEqual(Vector2.zero))<font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> angleToCollision = transform.Angle.GetDirection().CalculateAbsoluteAngleInDegrees(movPhysicInfo.LastCollisionDirection);<font></font>
                movPhysicInfo.TurnOnWall = angleToCollision &lt;= maxAngleToWall;<font></font>
            }<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        movPhysicInfo.LastCollisionDirection = collisionDirection * <span class="hljs-number">-1f</span>;
        <span class="hljs-keyword">if</span> (movPhysicInfo.LastCollisionDirection.IsEqual(Vector2.zero))<font></font>
        {<font></font>
            movPhysicInfo.TurnOnWall = <span class="hljs-literal">false</span>;<font></font>
            movPhysicInfo.LastCollisionDirection = collisionDirection;<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> angleToCollision = transform.Angle.GetDirection().CalculateAbsoluteAngleInDegrees(movPhysicInfo.LastCollisionDirection);<font></font>
            movPhysicInfo.TurnOnWall = angleToCollision &lt;= maxAngleToWall;<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// I can't believe we are using a physics engine and have to write such kludges</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> Vector2 <span class="hljs-title">CircleRayCastSpeedCorrection</span>(<span class="hljs-params">VoltBody targetBody, <span class="hljs-keyword">float</span> deltaSeconds, <span class="hljs-keyword">float</span> rayCastRadius</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (rayCastRadius &lt;= <span class="hljs-number">0</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Vector2.zero;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">var</span> speed = targetBody.LinearVelocity;
        <span class="hljs-keyword">var</span> position = targetBody.Position;<font></font>
<font></font>
        <span class="hljs-keyword">var</span> direction = speed * deltaSeconds;<font></font>
<font></font>
        <span class="hljs-keyword">var</span> rayCastResult = _physicsWorld.CircleCast(position + direction.normalized * <span class="hljs-number">0.1f</span>, direction, direction.magnitude, rayCastRadius, _collisionFilterDelegate, <span class="hljs-number">0</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (rayCastResult.Body == <span class="hljs-literal">null</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> Vector2.zero;<font></font>
        }<font></font>
<font></font>
<font></font>
        <span class="hljs-keyword">var</span> magSpeed = speed.magnitude;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (rayCastResult.Distance &gt; <span class="hljs-number">0</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> penetratingDistance = magSpeed * deltaSeconds - rayCastResult.Distance;
            <span class="hljs-keyword">var</span> sinVelocityEdge = Vector2.Dot(-speed.normalized, rayCastResult.Normal);<font></font>
<font></font>
            <span class="hljs-keyword">var</span> biasSpeed = penetratingDistance * sinVelocityEdge / deltaSeconds;
            <span class="hljs-keyword">var</span> biasVector = rayCastResult.Normal * biasSpeed * <span class="hljs-number">1.1f</span>;<font></font>
<font></font>
            <span class="hljs-keyword">var</span> resultVelocity = speed + biasVector;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (magSpeed &lt;= <span class="hljs-number">0</span>)<font></font>
            {<font></font>
                resultVelocity = Vector2.zero;<font></font>
            }<font></font>
            targetBody.LinearVelocity = resultVelocity;<font></font>
            <span class="hljs-keyword">return</span> rayCastResult.Normal;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">var</span> destination = rayCastResult.Body.Position;<font></font>
        direction = destination - position;<font></font>
<font></font>
        <span class="hljs-keyword">var</span> rayCastResultToBody =<font></font>
            _physicsWorld.RayCast(position, direction, direction.magnitude, _collisionFilterDelegate, <span class="hljs-number">0</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (rayCastResultToBody.IsValid)<font></font>
            targetBody.LinearVelocity = rayCastResultToBody.Normal * magSpeed * deltaSeconds;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> rayCastResultToBody.Normal;<font></font>
    }<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイデアは、各キャラクターが動く前に</font><font style="vertical-align: inherit;">、その動きの方向に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CircleCast</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を作成して、</font><font style="vertical-align: inherit;">その前に障害物があるかどうかを判断するというものです。ゲーム内のキャラクターの投影は円を表すため、CircleCastが必要であり、異なるジオメトリ間のコーナーに留まることは望ましくありません。次に、速度の増分を考慮し、この値を1フレームの速度として物理世界のオブジェクトに割り当てます。次のステップは、物理エンジンUpdate（）のシミュレーションメソッドを呼び出し、必要なすべてのオブジェクトを移動し、同時に古い状態を履歴に記録します。エンジン内部のシミュレーションが完了したら、このシミュレートされたデータを読み取り、それをECSの変換コンポーネントにコピーして、引き続き作業します。特に、ネットワーク経由で送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャラクターの移動速度に関する小さな制御されたデータのチャンクで物理を更新するこのアプローチは、クライアントとサーバーの物理の不一致を処理するのに非常に効果的であることがわかりました。そして、私たちの物理学は決定論的ではないため、つまり、同じ入力データではシミュレーション結果が異なる可能性があります。それを使用する価値があるかどうか、および業界の誰かが同様のことをするかどうかについて多くの議論がありました。決定論的な物理エンジンを手にしています。幸いにも、ゲーム開発者会議でNetherRealm Studiosの開発者から彼らのゲームのネットワークコンポーネントに関する優れたレポートを見つけ、そのようなアプローチが実際に行われていることに気付きました。システムを完全に組み立て、いくつかのテストで実行すると、9000ティック、つまり5分間のバトル中に約50の誤予測が発生しました。このような予測ミスは、調整メカニズムとプレーヤーの位置を視覚的に補間することで簡単に平準化できます。独自のデータを使用して物理を手動で頻繁に更新するときに発生するエラーは重要ではないため、視覚的な補間はかなり迅速に実行できます。これは、キャラクターモデルで視覚的なジャンプが発生しないようにするためにのみ必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントとサーバーの状態の一致を確認するために、次の形式の自己記述クラスを使用しました。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを表示</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">using</span> PS.Logs.Unity;<font></font>
<font></font>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Compares the same avatar in two states. Compares the values potentially</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> affected by prediction.</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameStateComparer</span> : <span class="hljs-title">IGameStateComparer</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IsSame</span>(<span class="hljs-params">GameState s1, GameState s2, <span class="hljs-keyword">uint</span> avatarId</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (s1 == <span class="hljs-literal">null</span> &amp;&amp; s2 != <span class="hljs-literal">null</span> ||<font></font>
            s1 != <span class="hljs-literal">null</span> &amp;&amp; s2 == <span class="hljs-literal">null</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (s1 == <span class="hljs-literal">null</span> &amp;&amp; s2 == <span class="hljs-literal">null</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
<font></font>
        <span class="hljs-keyword">var</span> entity1 = s1.WorldState[avatarId];
        <span class="hljs-keyword">var</span> entity2 = s2.WorldState[avatarId];<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (entity1 == <span class="hljs-literal">null</span> &amp;&amp; entity2 == <span class="hljs-literal">null</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (entity1 == <span class="hljs-literal">null</span> || entity2 == <span class="hljs-literal">null</span>)<font></font>
        {<font></font>
            LogManager.Debug(<span class="hljs-string">"entity is different"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (s1.Time != s2.Time)<font></font>
        {<font></font>
            LogManager.Warning(<span class="hljs-keyword">string</span>.Format(<span class="hljs-string">"Trying to compare states with different time! Predicted time: {0} Server time: {1}"</span>, <font></font>
                s1.Time, s2.Time));<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (s1.WorldState.Transform[avatarId] != s2.WorldState.Transform[avatarId])<font></font>
        {<font></font>
            LogManager.Debug(<span class="hljs-string">"Transform is different"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-comment">// ... some code ...</span><font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要に応じて自動化することもできますが、将来的には考えましたが、自動化はしていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変換比較コード：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを表示</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> ==(Transform a, Transform b)<font></font>
{<font></font>
    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">object</span>)a == <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">object</span>)b == <span class="hljs-literal">null</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">object</span>)a == <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">object</span>)b != <span class="hljs-literal">null</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">object</span>)a != <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">object</span>)b == <span class="hljs-literal">null</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (Math.Abs(a.Angle - b.Angle) &gt; <span class="hljs-number">0.01f</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (Math.Abs(a.Position.x - b.Position.x) &gt; <span class="hljs-number">0.01f</span> || Math.Abs(a.Position.y - b.Position.y) &gt; <span class="hljs-number">0.01f</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}</code></pre><br>
</div></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の困難</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モーションのシミュレーションには問題はありませんでしたが、2D平面に投影することができました。そのような場合の物理学は非常にうまく機能しましたが、ある時点でゲームデザイナーが来て言った：「手榴弾が欲しい！」</font><font style="vertical-align: inherit;">そして、あまり変化しないと思ったので、手元に2Dデータしかない、身体の3D飛行をシミュレートしてみませんか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、彼らはいくつかのオブジェクトの高さの概念を導入しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標高の法則が時間の経過とともに変化する様子は、放棄された身体にとってどのように見えるか、彼らは中学2年生の物理学のクラスに合格したため、弾道学の決定は取るに足らないものであることが判明しました。しかし、衝突を伴うソリューションは、それほど簡単ではありませんでした。この場合を想像してみましょう。飛行中の手榴弾は、壁に衝突するか、現在の高さと壁の高さに応じて、その上を飛行する必要があります。グレネードが円で、壁が長方形で表される2次元の世界でのみ問題を解決します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ej/yr/lk/ejyrlkwa0tu9hm-3j7nobxmazpo.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題を解決するためのオブジェクトのジオメトリのビュー。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、手榴弾の動的本体と他の静的および動的本体との相互作用を無効にしました。これは、目標に焦点を合わせるために必要です。私たちのタスクでは、手榴弾は他のオブジェクトを通過し、2次元平面への投影が互いに交差するときに壁を「飛び越える」ことができるはずです。通常の相互作用では、2つのオブジェクトが相互に通過することはできませんが、動きと高さのカスタムロジックを持つ手榴弾の場合、特定の条件下でこれを行うことができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グレネード用の別のコンポーネントGrenadeMovementを導入し、高さの概念を導入しました。</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">Component</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GrenadeMovement</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> Height;<font></font>
   [<span class="hljs-meta">DontPack</span>]
   <span class="hljs-keyword">public</span> Vector2 Velocity;<font></font>
   [<span class="hljs-meta">DontPack</span>]
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> VerticalVelocity;<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GrenadeMovement</span>(<span class="hljs-params"><span class="hljs-keyword">float</span> height, Vector2 velocity, <span class="hljs-keyword">float</span> verticalVelocity</span>)</span> { }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで手榴弾には高さ座標がありますが、この情報は他の世界には何も与えません。したがって、私たちはチートをすることを決定し、次の条件を追加しました：手榴弾は壁の上を飛ぶことができますが、一定の高さしかありませんしたがって、衝突の定義全体は、投影の衝突をチェックし、壁の高さをGrenadeMovement.Heightフィールドの値と比較することになります。手榴弾の飛行の高さが低い場合は、壁と衝突します。それ以外の場合は、2Dスペースを含め、パスに沿って静かに動き続けることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の反復では、交差点を見つけると手榴弾が落ちるだけでしたが、次に弾性衝突を追加し、3Dで得られる結果とほとんど区別がつかない動作を始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手榴弾の軌道と弾性衝突を計算するための完全なコードを以下に示します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを表示</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">using</span> System;
<span class="hljs-comment">// ... some code ...</span>
<span class="hljs-keyword">using</span> Volatile;<font></font>
<font></font>
<span class="hljs-keyword">namespace</span> <span class="hljs-title">Common.WorldState</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GrenadeMovementSystem</span> : <span class="hljs-title">ExecutableSystem</span><font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">struct</span> Projection<font></font>
        {<font></font>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> Min;
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> Max;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> _r;<font></font>
<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Vector2[] _vertices = <span class="hljs-keyword">new</span> Vector2[<span class="hljs-number">4</span>];
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Vector2[] _verticesV = <span class="hljs-keyword">new</span> Vector2[<span class="hljs-number">4</span>];
        <span class="hljs-keyword">private</span> Vector2 _Vunit;
        <span class="hljs-keyword">private</span> Vector2 _VTunit;
        <span class="hljs-keyword">private</span> Projection _wallProj1;
        <span class="hljs-keyword">private</span> Projection _wallProj2;
        <span class="hljs-keyword">private</span> Projection _wallProj1V;
        <span class="hljs-keyword">private</span> Projection _wallProj2V;<font></font>
<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> CollisionPrecision = <span class="hljs-number">1e-3</span>f;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">float</span> HalfSlope = Mathf.Cos(Mathf.PI / <span class="hljs-number">4.0f</span>);<font></font>
<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ContactPointList _contactPoints = <span class="hljs-keyword">new</span> ContactPointList(<span class="hljs-number">3</span>);<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span>(<span class="hljs-params">GameState gs</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> settings = gs.RuleBook.GrenadeConfig[<span class="hljs-number">1</span>];<font></font>
            _r = settings.R;<font></font>
<font></font>
            <span class="hljs-keyword">var</span> floorDampeningPerTick = (<span class="hljs-keyword">float</span>)Math.Pow(settings.FloorDampening, <span class="hljs-number">1.0</span> / GameState.Hz);<font></font>
<font></font>
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> grenade <span class="hljs-keyword">in</span> gs.WorldState.GrenadeMovement)<font></font>
            {<font></font>
                <span class="hljs-comment">// Gravity must take effect before collision</span>
                <span class="hljs-comment">// because contact with walls may and will adjust vertical velocity</span>
                <span class="hljs-comment">// and penetration will even move the ball up.</span><font></font>
                grenade.Value.VerticalVelocity -= settings.Gravity * GameState.TickDurationSec;<font></font>
                grenade.Value.Height += grenade.Value.VerticalVelocity * GameState.TickDurationSec;<font></font>
                <span class="hljs-comment">// prevent falling through floor</span>
                <span class="hljs-keyword">if</span> (grenade.Value.Height &lt;= _r)<font></font>
                {<font></font>
                    <span class="hljs-comment">// slow down horizontal movement by floor friction</span>
                    <span class="hljs-comment">// actually, friciton is simplified to just dampening coefficient</span>
                    <span class="hljs-keyword">var</span> spdH = grenade.Value.Velocity.sqrMagnitude;
                    <span class="hljs-keyword">var</span> spdV = grenade.Value.VerticalVelocity;
                    <span class="hljs-keyword">var</span> cos = spdH / Mathf.Sqrt(spdH * spdH + spdV * spdV);<font></font>
                    grenade.Value.Velocity *= floorDampeningPerTick * cos;<font></font>
<font></font>
                    <span class="hljs-comment">// slow down vertical movement</span><font></font>
                    grenade.Value.VerticalVelocity = settings.FloorRestitution * Math.Abs(grenade.Value.VerticalVelocity);<font></font>
<font></font>
                    <span class="hljs-comment">// move up to the floor level</span><font></font>
                    grenade.Value.Height = _r;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">// A collision will stop the ball and change its velocity.</span>
                <span class="hljs-comment">// Otherwise it will be moved by velocity</span><font></font>
                PerformCollisionAndMovement(gs, grenade.Key, grenade.Value);<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PerformCollisionAndMovement</span>(<span class="hljs-params">GameState gs, <span class="hljs-keyword">uint</span> id, GrenadeMovement grenade</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> settings = gs.RuleBook.GrenadeConfig[<span class="hljs-number">1</span>];
            <span class="hljs-keyword">var</span> velocity = grenade.Velocity * GameState.TickDurationSec;<font></font>
<font></font>
            <span class="hljs-keyword">var</span> trans = gs.WorldState.Transform[id];
            <span class="hljs-keyword">var</span> position = trans.Position;<font></font>
            _Vunit = velocity.normalized;<font></font>
            _VTunit = <span class="hljs-keyword">new</span> Vector2(-_Vunit.y, _Vunit.x);<font></font>
<font></font>
            _vertices[<span class="hljs-number">0</span>] = position + _VTunit * _r;<font></font>
            _vertices[<span class="hljs-number">1</span>] = position - _VTunit * _r;<font></font>
            _vertices[<span class="hljs-number">2</span>] = _vertices[<span class="hljs-number">1</span>] + velocity;<font></font>
            _vertices[<span class="hljs-number">3</span>] = _vertices[<span class="hljs-number">0</span>] + velocity;<font></font>
<font></font>
            _contactPoints.Reset();<font></font>
<font></font>
            <span class="hljs-keyword">int</span> collisions = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">var</span> grenProj1V = ProjectCapsule(_Vunit, _vertices, position, velocity);
            <span class="hljs-keyword">var</span> grenProj2V = ProjectCapsule(_VTunit, _vertices, position, velocity);<font></font>
            collisions += CollideWithStaticBoxes(gs, id, position, velocity, grenade, grenProj1V, grenProj2V);<font></font>
            collisions += CollideWithCircles(gs, gs.RuleBook.StaticCircleCollider, gs.RuleBook.Transform, id, position, velocity, grenade, grenProj1V, grenProj2V, (CollisionLayer)~<span class="hljs-number">0</span>);<font></font>
            collisions += CollideWithCircles(gs, gs.WorldState.DynamicCircleCollider, gs.WorldState.Transform, id, position, velocity, grenade, grenProj1V, grenProj2V, ~CollisionLayer.Character);<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (collisions == <span class="hljs-number">0</span>)<font></font>
            {<font></font>
                trans.Position += velocity;<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span><font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> contactSuperposition = CalculateContactSuperposition();<font></font>
<font></font>
                trans.Position += velocity * contactSuperposition.TravelDistance;<font></font>
<font></font>
                <span class="hljs-keyword">var</span> reflectedVelocity = grenade.Velocity - <span class="hljs-number">2.0f</span> * Vector2.Dot(grenade.Velocity, contactSuperposition.Normal) * contactSuperposition.Normal;<font></font>
                reflectedVelocity *= settings.WallRestitution;<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEBUG_GRENADES</span>
                gs.Log.Debug(<span class="hljs-string">"contact"</span>
                             + <span class="hljs-string">"\n\ttravel "</span> + contactSuperposition.TravelDistance<font></font>
                             + <span class="hljs-string">"\n\tcontactNormal "</span> + contactSuperposition.Normal.x + <span class="hljs-string">":"</span> + contactSuperposition.Normal.y<font></font>
                             + <span class="hljs-string">"\n\treflected V "</span> + reflectedVelocity.x + <span class="hljs-string">":"</span> + reflectedVelocity.y);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
                grenade.Velocity = reflectedVelocity;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">CollideWithStaticBoxes</span>(<span class="hljs-params">
            GameState gs,
            <span class="hljs-keyword">uint</span> id,
            Vector2 position,
            Vector2 velocity,
            GrenadeMovement grenade,
            Projection grenProj1V,
            Projection grenProj2V</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> settings = gs.RuleBook.GrenadeConfig[<span class="hljs-number">1</span>];
            <span class="hljs-keyword">var</span> collisions = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-comment">// TODO spatial query</span>
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> collider <span class="hljs-keyword">in</span> gs.RuleBook.StaticBoxCollider)<font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> wall = collider.Value;<font></font>
<font></font>
                <span class="hljs-keyword">var</span> transform = gs.RuleBook.Transform[collider.Key];
                <span class="hljs-keyword">var</span> colliderData = gs.RuleBook.PrecomputedColliderData[collider.Key];<font></font>
<font></font>
                <span class="hljs-comment">// test projection to V</span><font></font>
                _wallProj1V = ProjectPolygon(_Vunit, colliderData.Vertices);<font></font>
                <span class="hljs-keyword">if</span> (!Overlap(_wallProj1V, grenProj1V)) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
                <span class="hljs-comment">// test projection to VT</span><font></font>
                _wallProj2V = ProjectPolygon(_VTunit, colliderData.Vertices);<font></font>
                <span class="hljs-keyword">if</span> (!Overlap(_wallProj2V, grenProj2V)) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
                <span class="hljs-comment">// test projection to wall axis 1</span><font></font>
                _wallProj1 = ProjectPolygon(colliderData.Axis1, colliderData.Vertices);<font></font>
                <span class="hljs-keyword">var</span> grenProj1 = ProjectCapsule(colliderData.Axis1, _vertices, position, velocity);
                <span class="hljs-keyword">if</span> (!Overlap(_wallProj1, grenProj1)) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
                <span class="hljs-comment">// test projection to wall axis 2</span><font></font>
                _wallProj2 = ProjectPolygon(colliderData.Axis2, colliderData.Vertices);<font></font>
                <span class="hljs-keyword">var</span> grenProj2 = ProjectCapsule(colliderData.Axis2, _vertices, position, velocity);
                <span class="hljs-keyword">if</span> (!Overlap(_wallProj2, grenProj2)) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
                <span class="hljs-keyword">var</span> lowWall = wall.Height &lt; settings.TallWallHeight;
                <span class="hljs-keyword">if</span> (lowWall)<font></font>
                {<font></font>
                    <span class="hljs-comment">// the wall is too far below, ignore it completely</span>
                    <span class="hljs-keyword">if</span> (grenade.Height &gt; wall.Height + _r) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
                    <span class="hljs-comment">// if grenade if falling down, it can bounce off the top of the wall</span>
                    <span class="hljs-keyword">if</span> (grenade.VerticalVelocity &lt; <span class="hljs-number">0f</span>)<font></font>
                    {<font></font>
                        <span class="hljs-keyword">if</span> (grenade.Height &gt; wall.Height - _r)<font></font>
                        {<font></font>
                            <span class="hljs-keyword">var</span> localPV = WorldToBoxLocal(transform.Position, colliderData, position + velocity);<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEBUG_GRENADES</span>
                            gs.Log.Debug(<span class="hljs-string">"fall on wall"</span>
                                         + <span class="hljs-string">"\n\tP+V "</span> + (P.x + V.x) + <span class="hljs-string">":"</span> + (P.y + V.y)<font></font>
                                         + <span class="hljs-string">"\n\tlocal "</span> + localPV.x + <span class="hljs-string">":"</span> + localPV.y<font></font>
                                         + <span class="hljs-string">"\n\tH w "</span> + wall.Height + <span class="hljs-string">" g "</span> + grenade.Height<font></font>
                            );<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
                            <span class="hljs-keyword">if</span> (Math.Abs(localPV.x) &lt; wall.Size.x * <span class="hljs-number">0.5f</span> || Math.Abs(localPV.y) &lt; wall.Size.y * <span class="hljs-number">0.5f</span>)<font></font>
                            {<font></font>
                                grenade.Height = wall.Height + _r;<font></font>
                                grenade.VerticalVelocity = settings.WallRestitution * Math.Abs(grenade.VerticalVelocity);<font></font>
                                <span class="hljs-keyword">continue</span>;<font></font>
                            }<font></font>
                        }<font></font>
                    }<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">// collision detected</span><font></font>
<font></font>
                <span class="hljs-comment">// try to find minimal V before collision</span>
                <span class="hljs-keyword">var</span> scaleV = CalcTranslationScaleBeforeCollision(CheckBoxCollision, colliderData, <span class="hljs-number">0</span>, position, velocity);<font></font>
<font></font>
                <span class="hljs-keyword">var</span> contactPoint = CalcBoxContactPoint(transform.Position, wall, colliderData, position);<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEBUG_GRENADES</span>
                gs.Log.Debug(<span class="hljs-string">"collision grenade #"</span> + id + <span class="hljs-string">" with static box #"</span> + collider.Key<font></font>
                             + <span class="hljs-string">"\n\tP="</span> + P.x + <span class="hljs-string">":"</span> + P.y<font></font>
                             + <span class="hljs-string">"\n\tV="</span> + V.x + <span class="hljs-string">":"</span> + V.y + <span class="hljs-string">" scale="</span> + scaleV<font></font>
                             + <span class="hljs-string">"\n\tP+Vs="</span> + (P.x + V.x * scaleV) + <span class="hljs-string">":"</span> + (P.y + V.y * scaleV)<font></font>
                             + <span class="hljs-string">"\n\twall pos "</span> + transform.Position.x + <span class="hljs-string">":"</span> + transform.Position.y + <span class="hljs-string">" sz "</span> + wall.Size.x + <span class="hljs-string">":"</span> + wall.Size.y + <span class="hljs-string">" angle "</span> + transform.Angle<font></font>
                             + <span class="hljs-string">"\n\tproj V  w "</span> + _wallProj1V.Min + <span class="hljs-string">":"</span> + _wallProj1V.Max + <span class="hljs-string">" g "</span> + grenProj1V.Min + <span class="hljs-string">":"</span> + grenProj1V.Max + <span class="hljs-string">" overlap="</span> + Overlap(_wallProj1V, grenProj1V)<font></font>
                             + <span class="hljs-string">"\n\tproj VT w "</span> + _wallProj2V.Min + <span class="hljs-string">":"</span> + _wallProj2V.Max + <span class="hljs-string">" g "</span> + grenProj2V.Min + <span class="hljs-string">":"</span> + grenProj2V.Max + <span class="hljs-string">" overlap="</span> + Overlap(_wallProj2V, grenProj2V)<font></font>
                             + <span class="hljs-string">"\n\taxis1 "</span> + colliderData.Axis1.x + <span class="hljs-string">":"</span> + colliderData.Axis1.y<font></font>
                             + <span class="hljs-string">"\n\tproj  1 w "</span> + _wallProj1.Min + <span class="hljs-string">":"</span> + _wallProj1.Max + <span class="hljs-string">" g "</span> + grenProj1.Min + <span class="hljs-string">":"</span> + grenProj1.Max + <span class="hljs-string">" overlap="</span> + Overlap(_wallProj1, grenProj1)<font></font>
                             + <span class="hljs-string">"\n\taxis2 "</span> + colliderData.Axis2.x + <span class="hljs-string">":"</span> + colliderData.Axis2.y<font></font>
                             + <span class="hljs-string">"\n\tproj  2 w "</span> + _wallProj2.Min + <span class="hljs-string">":"</span> + _wallProj2.Max + <span class="hljs-string">" g "</span> + grenProj2.Min + <span class="hljs-string">":"</span> + grenProj2.Max + <span class="hljs-string">" overlap="</span> + Overlap(_wallProj2, grenProj2)<font></font>
                             + <span class="hljs-string">"\n\tpoint "</span> + contactPoint.Point.x + <span class="hljs-string">":"</span> + contactPoint.Point.y + <span class="hljs-string">" dotV "</span> + Vector2.Dot(P - contactPoint.Point, V)<font></font>
                );<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
                <span class="hljs-comment">// ignore colliders that are behind</span>
                <span class="hljs-keyword">if</span> (Vector2.Dot(position - contactPoint.Point, velocity) &gt;= <span class="hljs-number">0.0f</span>) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
                contactPoint.TravelDistance = velocity.magnitude * scaleV;<font></font>
                _contactPoints.Add(<span class="hljs-keyword">ref</span> contactPoint);<font></font>
<font></font>
                collisions++;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> collisions;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">CheckBoxCollision</span>(<span class="hljs-params">PrecomputedColliderData colliderData, <span class="hljs-keyword">int</span> x, Vector2 position, Vector2 velocity</span>)</span><font></font>
        {<font></font>
            _verticesV[<span class="hljs-number">0</span>] = _vertices[<span class="hljs-number">0</span>];<font></font>
            _verticesV[<span class="hljs-number">1</span>] = _vertices[<span class="hljs-number">1</span>];<font></font>
            _verticesV[<span class="hljs-number">2</span>] = _vertices[<span class="hljs-number">1</span>] + velocity;<font></font>
            _verticesV[<span class="hljs-number">3</span>] = _vertices[<span class="hljs-number">0</span>] + velocity;<font></font>
<font></font>
            <span class="hljs-comment">// test projection to V</span>
            <span class="hljs-keyword">var</span> grenProj1V = ProjectCapsule(_Vunit, _verticesV, position, velocity);
            <span class="hljs-keyword">if</span> (!Overlap(_wallProj1V, grenProj1V)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
<font></font>
            <span class="hljs-comment">// testing projection to VT would be redundant</span><font></font>
<font></font>
            <span class="hljs-comment">// test projection to wall axis 1</span>
            <span class="hljs-keyword">var</span> grenProj1 = ProjectCapsule(colliderData.Axis1, _verticesV, position, velocity);
            <span class="hljs-keyword">if</span> (!Overlap(_wallProj1, grenProj1)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
<font></font>
            <span class="hljs-comment">// test projection to wall axis 2</span>
            <span class="hljs-keyword">var</span> grenProj2 = ProjectCapsule(colliderData.Axis2, _verticesV, position, velocity);
            <span class="hljs-keyword">if</span> (!Overlap(_wallProj2, grenProj2)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">CollideWithCircles</span>(<span class="hljs-params">
            GameState gs,
            Table&lt;CircleCollider&gt; colliderTable,
            Table&lt;Transform&gt; transformTable,
            <span class="hljs-keyword">uint</span> id,
            Vector2 position,
            Vector2 velocity,
            GrenadeMovement grenade,
            Projection grenProj1V,
            Projection grenProj2V,
            CollisionLayer collisionLayers</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> settings = gs.RuleBook.GrenadeConfig[<span class="hljs-number">1</span>];
            <span class="hljs-keyword">var</span> collisions = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> collider <span class="hljs-keyword">in</span> colliderTable)<font></font>
            {<font></font>
                <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">int</span>)collisionLayers != ~<span class="hljs-number">0</span>)<font></font>
                {<font></font>
                    <span class="hljs-keyword">var</span> body = gs.WorldState.PhysicsDynamicBody[collider.Key];
                    <span class="hljs-keyword">if</span> (body != <span class="hljs-literal">null</span> &amp;&amp; (body.CollisionLayer &amp; collisionLayers) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">var</span> wall = collider.Value;
                <span class="hljs-keyword">var</span> transform = transformTable[collider.Key];<font></font>
<font></font>
                <span class="hljs-comment">// test projection to V</span><font></font>
                _wallProj1V = ProjectCircle(_Vunit, transform.Position, wall.Radius);<font></font>
                <span class="hljs-keyword">if</span> (!Overlap(_wallProj1V, grenProj1V)) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
                <span class="hljs-comment">// test projection to VT</span><font></font>
                _wallProj2V = ProjectCircle(_VTunit, transform.Position, wall.Radius);<font></font>
                <span class="hljs-keyword">if</span> (!Overlap(_wallProj2V, grenProj2V)) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
                <span class="hljs-comment">// test distance from the circle wall to semicircles on capsule ends</span>
                <span class="hljs-keyword">var</span> collisionDistance = (_r + wall.Radius) * (_r + wall.Radius);
                <span class="hljs-keyword">if</span> ((position - transform.Position).sqrMagnitude &gt; collisionDistance) <span class="hljs-keyword">continue</span>;
                <span class="hljs-keyword">var</span> distSqr = (position + velocity - transform.Position).sqrMagnitude;
                <span class="hljs-keyword">if</span> (distSqr &gt; collisionDistance) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
                <span class="hljs-keyword">var</span> lowWall = wall.Height &lt; settings.TallWallHeight;
                <span class="hljs-keyword">if</span> (lowWall)<font></font>
                {<font></font>
                    <span class="hljs-comment">// the wall is too far below, ignore it completely</span>
                    <span class="hljs-keyword">if</span> (grenade.Height &gt; wall.Height + _r) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
                    <span class="hljs-comment">// if grenade if falling down, it can bounce off the top of the wall</span>
                    <span class="hljs-keyword">if</span> (grenade.VerticalVelocity &lt; <span class="hljs-number">0f</span>)<font></font>
                    {<font></font>
                        <span class="hljs-keyword">if</span> (grenade.Height &gt; wall.Height - _r)<font></font>
                        {<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEBUG_GRENADES</span>
                            gs.Log.Debug(<span class="hljs-string">"grenade #"</span> + id + <span class="hljs-string">" falls on wall"</span>
                                         + <span class="hljs-string">"\n\tP+V "</span> + (P.x + V.x) + <span class="hljs-string">":"</span> + (P.y + V.y)<font></font>
                                         + <span class="hljs-string">"\n\tdist "</span> + Mathf.Sqrt(distSqr)<font></font>
                                         + <span class="hljs-string">"\n\tH w "</span> + wall.Height + <span class="hljs-string">" g "</span> + grenade.Height<font></font>
                            );<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
                            <span class="hljs-keyword">if</span> (distSqr &lt; wall.Radius * wall.Radius)<font></font>
                            {<font></font>
                                grenade.Height = wall.Height + _r;<font></font>
                                grenade.VerticalVelocity = settings.WallRestitution * Math.Abs(grenade.VerticalVelocity);<font></font>
                                <span class="hljs-keyword">continue</span>;<font></font>
                            }<font></font>
                        }<font></font>
                    }<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">// collision detected</span><font></font>
<font></font>
                <span class="hljs-comment">// try to find minimal V before collision</span>
                <span class="hljs-keyword">var</span> scaleV = CalcTranslationScaleBeforeCollision(CheckCircleCollision, transform.Position, wall, position, velocity);<font></font>
<font></font>
                <span class="hljs-keyword">var</span> contactPoint = CalcCircleContactPoint(transform.Position, wall, position);<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEBUG_GRENADES</span>
                gs.Log.Debug(<span class="hljs-string">"collision grenade #"</span> + id + <span class="hljs-string">" with circle #"</span> + collider.Key<font></font>
                             + <span class="hljs-string">"\n\tP="</span> + P.x + <span class="hljs-string">":"</span> + P.y<font></font>
                             + <span class="hljs-string">"\n\tV="</span> + V.x + <span class="hljs-string">":"</span> + V.y + <span class="hljs-string">" scale="</span> + scaleV<font></font>
                             + <span class="hljs-string">"\n\tP+Vs="</span> + (P.x + V.x * scaleV) + <span class="hljs-string">":"</span> + (P.y + V.y * scaleV)<font></font>
                             + <span class="hljs-string">"\n\tcircle pos "</span> + transform.Position.x + <span class="hljs-string">":"</span> + transform.Position.y + <span class="hljs-string">" r "</span> + wall.Radius<font></font>
                             + <span class="hljs-string">"\n\tdist "</span> + (transform.Position - (P + V * scaleV)).magnitude<font></font>
                             + <span class="hljs-string">"\n\tproj V  w "</span> + _wallProj1V.Min + <span class="hljs-string">":"</span> + _wallProj1V.Max + <span class="hljs-string">" g "</span> + grenProj1V.Min + <span class="hljs-string">":"</span> + grenProj1V.Max + <span class="hljs-string">" overlap="</span> + Overlap(_wallProj1V, grenProj1V)<font></font>
                             + <span class="hljs-string">"\n\tproj VT w "</span> + _wallProj2V.Min + <span class="hljs-string">":"</span> + _wallProj2V.Max + <span class="hljs-string">" g "</span> + grenProj2V.Min + <span class="hljs-string">":"</span> + grenProj2V.Max + <span class="hljs-string">" overlap="</span> + Overlap(_wallProj2V, grenProj2V)<font></font>
                             + <span class="hljs-string">"\n\tpoint "</span> + contactPoint.Point.x + <span class="hljs-string">":"</span> + contactPoint.Point.y + <span class="hljs-string">" dotV "</span> + Vector2.Dot(P - contactPoint.Point, V)<font></font>
                             );<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
                <span class="hljs-comment">// ignore colliders that are behind</span>
                <span class="hljs-keyword">if</span> (Vector2.Dot(position - contactPoint.Point, velocity) &gt;= <span class="hljs-number">0.0f</span>) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
                contactPoint.TravelDistance = velocity.magnitude * scaleV;<font></font>
                _contactPoints.Add(<span class="hljs-keyword">ref</span> contactPoint);<font></font>
<font></font>
                collisions++;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> collisions;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">CheckCircleCollision</span>(<span class="hljs-params">Vector2 wallCentre, CircleCollider wall, Vector2 position, Vector2 velocity</span>)</span><font></font>
        {<font></font>
            _verticesV[<span class="hljs-number">0</span>] = _vertices[<span class="hljs-number">0</span>];<font></font>
            _verticesV[<span class="hljs-number">1</span>] = _vertices[<span class="hljs-number">1</span>];<font></font>
            _verticesV[<span class="hljs-number">2</span>] = _vertices[<span class="hljs-number">1</span>] + velocity;<font></font>
            _verticesV[<span class="hljs-number">3</span>] = _vertices[<span class="hljs-number">0</span>] + velocity;<font></font>
<font></font>
            <span class="hljs-comment">// test projection to V</span>
            <span class="hljs-keyword">var</span> grenProj1V = ProjectCapsule(_Vunit, _verticesV, position, velocity);
            <span class="hljs-keyword">if</span> (!Overlap(_wallProj1V, grenProj1V)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
<font></font>
            <span class="hljs-comment">// testing projection to VT would be redundant</span><font></font>
<font></font>
            <span class="hljs-comment">// test distance from the circle wall to the semicircle on the second capsule end</span>
            <span class="hljs-keyword">var</span> dSqr = (_r + wall.Radius) * (_r + wall.Radius);
            <span class="hljs-keyword">return</span> (position + velocity - wallCentre).sqrMagnitude &lt; dSqr;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> CalcTranslationScaleBeforeCollision&lt;TData1, TData2&gt;(<font></font>
            Func&lt;TData1, TData2, Vector2, Vector2, <span class="hljs-keyword">bool</span>&gt; collision,<font></font>
            TData1 colliderData1,<font></font>
            TData2 colliderData2,<font></font>
            Vector2 position,<font></font>
            Vector2 vector)<font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> min = <span class="hljs-number">0.0f</span>;
            <span class="hljs-keyword">var</span> max = <span class="hljs-number">1.0f</span>;
            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> d = (max - min) * <span class="hljs-number">0.5f</span>;
                <span class="hljs-keyword">if</span> (d &lt; CollisionPrecision) <span class="hljs-keyword">break</span>;<font></font>
<font></font>
                <span class="hljs-keyword">var</span> scale = min + d;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (collision(colliderData1, colliderData2, position, vector * scale))<font></font>
                {<font></font>
                    max = scale;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span><font></font>
                {<font></font>
                    min = scale;<font></font>
                }<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> min;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> ContactPoint <span class="hljs-title">CalculateContactSuperposition</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            ContactPoint contactSuperposition;<font></font>
            _contactPoints.TryPopClosest(<span class="hljs-number">1000f</span>, <span class="hljs-keyword">out</span> contactSuperposition);<font></font>
<font></font>
            ContactPoint contact;<font></font>
            <span class="hljs-keyword">while</span> (_contactPoints.TryPopClosest(contactSuperposition.TravelDistance, <span class="hljs-keyword">out</span> contact))<font></font>
            {<font></font>
                contactSuperposition.Normal += contact.Normal;<font></font>
            }<font></font>
<font></font>
            contactSuperposition.Normal = contactSuperposition.Normal.normalized;<font></font>
<font></font>
            <span class="hljs-keyword">return</span> contactSuperposition;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Projection <span class="hljs-title">ProjectPolygon</span>(<span class="hljs-params">Vector2 axisNormalised, Vector2[] vertices</span>)</span><font></font>
        {<font></font>
            Projection proj;<font></font>
            <span class="hljs-keyword">var</span> d = Vector2.Dot(axisNormalised, vertices[<span class="hljs-number">0</span>]);<font></font>
            proj.Min = d;<font></font>
            proj.Max = d;<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; vertices.Length; i++)<font></font>
            {<font></font>
                d = Vector2.Dot(axisNormalised, vertices[i]);<font></font>
                proj.Min = Mathf.Min(proj.Min, d);<font></font>
                proj.Max = Mathf.Max(proj.Max, d);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> proj;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> Projection <span class="hljs-title">ProjectCapsule</span>(<span class="hljs-params">Vector2 axisNormalised, Vector2[] vertices, Vector2 p, Vector2 v</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> proj = ProjectPolygon(axisNormalised, vertices);<font></font>
            proj = AddCircleProjection(proj, axisNormalised, p, _r);<font></font>
            proj = AddCircleProjection(proj, axisNormalised, p + v, _r);<font></font>
            <span class="hljs-keyword">return</span> proj;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Projection <span class="hljs-title">AddCircleProjection</span>(<span class="hljs-params">Projection proj, Vector2 axisNormalised, Vector2 centre, <span class="hljs-keyword">float</span> r</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> c = Vector2.Dot(axisNormalised, centre);<font></font>
            proj.Min = Mathf.Min(proj.Min, c - r);<font></font>
            proj.Max = Mathf.Max(proj.Max, c + r);<font></font>
            <span class="hljs-keyword">return</span> proj;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Projection <span class="hljs-title">ProjectCircle</span>(<span class="hljs-params">Vector2 axisNormalised, Vector2 centre, <span class="hljs-keyword">float</span> r</span>)</span><font></font>
        {<font></font>
            Projection proj;<font></font>
            <span class="hljs-keyword">var</span> c = Vector2.Dot(axisNormalised, centre);<font></font>
            proj.Min = c - r;<font></font>
            proj.Max = c + r;<font></font>
            <span class="hljs-keyword">return</span> proj;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Overlap</span>(<span class="hljs-params">Projection p1, Projection p2</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> p1.Min &lt; p2.Min ? p1.Max &gt; p2.Min : p2.Max &gt; p1.Min;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Vector2 <span class="hljs-title">WorldToBoxLocal</span>(<span class="hljs-params">Vector2 wallCentre, PrecomputedColliderData colliderData, Vector2 position</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector2(<font></font>
                Vector2.Dot(colliderData.Axis1, position) - Vector2.Dot(colliderData.Axis1, wallCentre),<font></font>
                Vector2.Dot(colliderData.Axis2, position) - Vector2.Dot(colliderData.Axis2, wallCentre)<font></font>
            );<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ContactPoint <span class="hljs-title">CalcBoxContactPoint</span>(<span class="hljs-params">Vector2 wallCentre, BoxCollider wall, PrecomputedColliderData colliderData, Vector2 position</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> contactPoint = CaclBoxLocalContactPoint(wall.Size * <span class="hljs-number">0.5f</span>, WorldToBoxLocal(wallCentre, colliderData, position));<font></font>
<font></font>
            <span class="hljs-keyword">var</span> worldAxisX = <span class="hljs-keyword">new</span> Vector2(colliderData.Axis1.x, -colliderData.Axis1.y);
            <span class="hljs-keyword">var</span> worldAxisY = <span class="hljs-keyword">new</span> Vector2(colliderData.Axis1.y, colliderData.Axis1.x);<font></font>
            contactPoint.Point = wallCentre + <span class="hljs-keyword">new</span> Vector2(Vector2.Dot(worldAxisX, contactPoint.Point), Vector2.Dot(worldAxisY, contactPoint.Point));<font></font>
            contactPoint.Normal = <span class="hljs-keyword">new</span> Vector2(Vector2.Dot(worldAxisX, contactPoint.Normal), Vector2.Dot(worldAxisY, contactPoint.Normal));<font></font>
<font></font>
            <span class="hljs-keyword">return</span> contactPoint;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ContactPoint <span class="hljs-title">CaclBoxLocalContactPoint</span>(<span class="hljs-params">Vector2 boxHalfSize, Vector2 localPosition</span>)</span><font></font>
        {<font></font>
            ContactPoint localContactPoint = <span class="hljs-keyword">default</span>(ContactPoint);<font></font>
<font></font>
            <span class="hljs-comment">// cases are numbered like numpad keys</span><font></font>
<font></font>
            <span class="hljs-comment">// 1, 2, 3</span>
            <span class="hljs-keyword">if</span> (localPosition.y &lt; -boxHalfSize.y)<font></font>
            {<font></font>
                <span class="hljs-comment">// 1</span>
                <span class="hljs-keyword">if</span> (localPosition.x &lt; -boxHalfSize.x)<font></font>
                {<font></font>
                    localContactPoint.Point = <span class="hljs-keyword">new</span> Vector2(-boxHalfSize.x, -boxHalfSize.y);<font></font>
                    localContactPoint.Normal = <span class="hljs-keyword">new</span> Vector2(-HalfSlope, -HalfSlope);<font></font>
                }<font></font>
                <span class="hljs-comment">// 2, 3</span>
                <span class="hljs-keyword">else</span><font></font>
                {<font></font>
                    <span class="hljs-comment">// 3</span>
                    <span class="hljs-keyword">if</span> (localPosition.x &gt; boxHalfSize.x)<font></font>
                    {<font></font>
                        localContactPoint.Point = <span class="hljs-keyword">new</span> Vector2(boxHalfSize.x, -boxHalfSize.y);<font></font>
                        localContactPoint.Normal = <span class="hljs-keyword">new</span> Vector2(HalfSlope, -HalfSlope);<font></font>
                    }<font></font>
                    <span class="hljs-comment">// 2</span>
                    <span class="hljs-keyword">else</span><font></font>
                    {<font></font>
                        localContactPoint.Point = <span class="hljs-keyword">new</span> Vector2(localPosition.x, -boxHalfSize.y);<font></font>
                        localContactPoint.Normal = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">0.0f</span>, <span class="hljs-number">-1.0f</span>);<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-comment">// 4, 6, 7, 8, 9</span>
            <span class="hljs-keyword">else</span><font></font>
            {<font></font>
                <span class="hljs-comment">// 7, 8, 9</span>
                <span class="hljs-keyword">if</span> (localPosition.y &gt; boxHalfSize.y)<font></font>
                {<font></font>
                    <span class="hljs-comment">// 7</span>
                    <span class="hljs-keyword">if</span> (localPosition.x &lt; -boxHalfSize.x)<font></font>
                    {<font></font>
                        localContactPoint.Point = <span class="hljs-keyword">new</span> Vector2(-boxHalfSize.x, boxHalfSize.y);<font></font>
                        localContactPoint.Normal = <span class="hljs-keyword">new</span> Vector2(-HalfSlope, HalfSlope);<font></font>
                    }<font></font>
                    <span class="hljs-comment">// 8, 9</span>
                    <span class="hljs-keyword">else</span><font></font>
                    {<font></font>
                        <span class="hljs-comment">// 9</span>
                        <span class="hljs-keyword">if</span> (localPosition.x &gt; boxHalfSize.x)<font></font>
                        {<font></font>
                            localContactPoint.Point = <span class="hljs-keyword">new</span> Vector2(boxHalfSize.x, boxHalfSize.y);<font></font>
                            localContactPoint.Normal = <span class="hljs-keyword">new</span> Vector2(HalfSlope, HalfSlope);<font></font>
                        }<font></font>
                        <span class="hljs-comment">// 8</span>
                        <span class="hljs-keyword">else</span><font></font>
                        {<font></font>
                            localContactPoint.Point = <span class="hljs-keyword">new</span> Vector2(localPosition.x, boxHalfSize.y);<font></font>
                            localContactPoint.Normal = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<font></font>
                        }<font></font>
                    }<font></font>
                }<font></font>
                <span class="hljs-comment">// 4, 6</span>
                <span class="hljs-keyword">else</span><font></font>
                {<font></font>
                    <span class="hljs-comment">// 4</span>
                    <span class="hljs-keyword">if</span> (localPosition.x &lt; -boxHalfSize.x)<font></font>
                    {<font></font>
                        localContactPoint.Point = <span class="hljs-keyword">new</span> Vector2(-boxHalfSize.x, localPosition.y);<font></font>
                        localContactPoint.Normal = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">-1.0f</span>, <span class="hljs-number">0.0f</span>);<font></font>
                    }<font></font>
                    <span class="hljs-comment">// 6</span>
                    <span class="hljs-keyword">else</span><font></font>
                    {<font></font>
                        localContactPoint.Point = <span class="hljs-keyword">new</span> Vector2(boxHalfSize.x, localPosition.y);<font></font>
                        localContactPoint.Normal = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>);<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> localContactPoint;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ContactPoint <span class="hljs-title">CalcCircleContactPoint</span>(<span class="hljs-params">Vector2 wallCentre, CircleCollider wall, Vector2 position</span>)</span><font></font>
        {<font></font>
            ContactPoint contactPoint = <span class="hljs-keyword">default</span>(ContactPoint);<font></font>
<font></font>
            contactPoint.Normal = (position - wallCentre).normalized;<font></font>
            contactPoint.Point = wallCentre + wall.Radius * contactPoint.Normal;<font></font>
<font></font>
            <span class="hljs-keyword">return</span> contactPoint;<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼らは物理学を書いた。</font><font style="vertical-align: inherit;">次は何ですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームは生き続け、発展し、時間の経過とともに、サーバー上の物理エンジンで何が起こっているのかをデバッグすることが必要になりました。</font><font style="vertical-align: inherit;">記事の1つで</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、サーバーでのECS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">デバッグ</font></a><font style="vertical-align: inherit;">について詳しく説明し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ました</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">物理学に関しては、JSONからデータを取得する直接ビジュアルエディターがあり、その構造は残りのECSレイアウトと共に生成されます。</font><font style="vertical-align: inherit;">このエディターは次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/x6/wv/1w/x6wv1w0hkb13r4rflik9hvacnk0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には2つの「世界」があることがわかります。 1つ目はECSです。ECSでは、物理パラメータを含むゲームのオブジェクトの状態を記述します。第二の世界-物理的な世界-はライブラリによって作成され、もちろん、ECSスタイルで記述されていませんが、ECSはこれらの世界間でデータを同期するタスクを引き受けます。ライブラリがデータを管理するために使用できるAPIを提供し、読み書きできることが重要です。また、私たちにとって非常に重要な結論は、物理エンジンのすべての機能の中で、予測の失敗を防ぐという点で最も信頼できるのは、一定の速度とレーキキャストの短い量でオブジェクトの相互作用と移動のシステムを構築することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しばらくの間、私たちは2D物理学で成功を収め続けてきました。それは、私たちのタスクとゲームデザインのニーズを完全にカバーし、一般に非常に成功したソリューションでした。もちろん、マイナスもありました。私たちは常にそのパフォーマンスに満足しているわけではありませんでしたが、オープンソース市場には適切な代替手段がまだなく、私たち自身のものを書くのはエネルギー集約的でした。同じシミュレーションティックで実行される100を超えるECSシステムのプロファイリングの結果によると、物理エンジン上のシステムが最も貪欲であることが判明しました。さらに、ライブラリには、物理​​ボディのジオメトリとその対称性に基づく多くの最適化が欠けているため、非常に便利です。ライブラリコードのOOPに焦点を当て、データパケットではなく個々の本体を操作することも混乱します。これは、物理エンジンにとってはるかに最適です。そしてはい-最終的に、開発者はまだライブラリを放棄しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでもしばらくして、3D物理演算の使用を含む新しい要件がゲームのゲームデザインに現れました。そして、物理的に予防のために書かれたファサードは大きく誤解され、新しい現実に完全には適合していませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2次元の物理エンジンを3次元のエンジンに置き換える方法、理由、および理由についての質問に、今後の記事で取り上げます。</font><font style="vertical-align: inherit;">それまでの間、ご理解のほどよろしくお願いいたします。この資料の後で、ECSと外部システムとの相互作用が少し明確になったことを願っています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">役立つリンク</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前の関連記事へ：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントとサーバーの一般的なゲームロジック</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モバイルPvPシューターのネットワークコードを記述したとき：クライアントでのプレーヤーの同期</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECSを作成した方法と理由</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームサーバーのブラウザーで自己記述型ECSをデバッグする方法</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">8 Frames in 16ms: Rollback Networking in Mortal Kombat and Injustice 2</a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja481858/index.html">Googleカレンダーの誕生日と年齢</a></li>
<li><a href="../ja481860/index.html">2020年にITは何をすべきか？ </a></li>
<li><a href="../ja481862/index.html">Nvidia Jetson組み込み機械学習システム</a></li>
<li><a href="../ja481866/index.html">DBA：VACUUMがパスしたとき-テーブルを手動でクリーニングします</a></li>
<li><a href="../ja481874/index.html">指標-プロジェクトの健全性の指標</a></li>
<li><a href="../ja481882/index.html">4. Fortinet Getting Started v6.0。ファイアウォールポリシー</a></li>
<li><a href="../ja481884/index.html">シニアの岐路：次はどこへ？</a></li>
<li><a href="../ja481886/index.html">出席ジャーナルをすばやく作成する方法</a></li>
<li><a href="../ja481890/index.html">ロシアへのドイツのウラン尾鉱の輸入。パート2.エンリッチメント</a></li>
<li><a href="../ja481892/index.html">ビットの代わりに量子ビット：量子コンピュータは私たちにとってどのような未来を持っていますか？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>