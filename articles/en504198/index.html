<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòú üõÄ üïé SwiftUI on the shelves: Animation. Part 1 üòÇ üå± üö£üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently I came across a fresh article in which the guys tried to reproduce an interesting concept using SwiftUI. Here's what they did: 
 
 
 
 I stud...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SwiftUI on the shelves: Animation. Part 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504198/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recently I came across a fresh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in which the guys tried to reproduce an interesting concept using SwiftUI. Here's what they did: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I studied their code with interest, but experienced some frustration. No, not in the sense that they did something wrong, not at all. It‚Äôs just that I didn‚Äôt learn anything new from their code. Their implementation is more about Combine than about animation. And I decided to </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">build my lunopark</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to write my article on animation in SwiftUI, implementing about the same concept, but using 100% of the capabilities of the built-in animation, even if it is not very effective. To study - so to the end. To experiment - so with a twinkle :) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here's what I got:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, for a full disclosure of the topic, I had to talk in some detail about the very basics. The text turned out to be voluminous, and therefore, I broke it into two articles. Here is the first part of it - rather, a tutorial on animation in general, not directly related to rainbow animation, which I will discuss in detail in the next article. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this article, I will talk about the basics, without which you can easily get confused in more complex examples. Much of what I will talk about, in one form or another, has already been described in English-language articles such as this series ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">I, on the other hand, focused not so much on enumerating the ways of working as on describing how exactly this works. </font><font style="vertical-align: inherit;">And as always, I experimented a lot, so I hasten to share the most interesting results. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
warning: under the cat there are a lot of pictures and gif-animations.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLDR</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The project is available on </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">You can see the current result with rainbow animation in TransitionRainbowView (), but I would not rush in your place, but I waited for the next article. </font><font style="vertical-align: inherit;">In addition, when preparing it, I comb the code a bit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this article, we will discuss only the basics, and affect only the contents of the Bases folder.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introduction</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I admit, I was not going to write this article now. I had a plan according to which an article about animation was supposed to be the third or even the fourth in a row. However, I could not resist, I really wanted to provide an alternative point of view. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I want to make a reservation right away. I do not believe that any errors were made in the mentioned article, or the approach used in it is incorrect. Not at all. It builds an object model of the process (animation), which, responding to the received signal, starts to do something. However, as for me, this article most likely reveals work with the Combine framework. Yes, this framework is an important part of SwiftUI, but it's more about react-like style in general than about animation.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My option is certainly not more elegant, faster and easier to maintain. However, it reveals much better what is under the hood of SwiftUI, and indeed this was the purpose of the article - to figure it out first. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As I said in a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">previous article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by SwiftUI, I began my dive into the world of mobile development right away with SwiftUI, ignoring UIKit. This, of course, has a price, but there are advantages. I am not trying to live in a new monastery according to the old charter. Honestly, I don‚Äôt yet know any charters, so I don‚Äôt have a rejection of the new. That is why, this article, it seems to me, can be of value not only for beginners, like me, but also for those who study SwiftUI already having background in the form of development on UIKit. It seems to me that many people lack a fresh look. Do not do the same thing, trying to fit a new tool into the old drawings, but change your vision according to new possibilities.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We 1c-nicks went through this with ‚Äúcontrolled forms‚Äù. This is a kind of SwiftUI in the world of 1s, which happened more than 10 years ago. In fact, the analogy is pretty accurate, because managed forms are just a new way to draw an interface. However, he completely changed the client-server interaction of the application as a whole, and the picture of the world in the minds of developers in particular. This was not easy, I myself did not want to study it for about 5 years, because I thought that many of the opportunities that were cut off there were simply necessary for me. But, as practice has shown, coding on managed forms is not only possible, but only necessary.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, let's not talk about it anymore. </font><font style="vertical-align: inherit;">I got a detailed, independent guide that does not have any references, or other links with the mentioned article or the 1st past. </font><font style="vertical-align: inherit;">Step by step, we will dive into the details, features, principles and limitations. </font><font style="vertical-align: inherit;">Go.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animating Shape</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How animation works in general</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, the main idea of ‚Äã‚Äãanimation is the transformation of a particular, discrete change into a continuous process. For example, the radius of the circle was 100 units, became 50 units. Without animation, the change will happen instantly, with animation - smoothly. How it works? Very simple. For smooth changes, we need to interpolate several values ‚Äã‚Äãwithin the ‚ÄúIt was ... It has become‚Äù segment. In the case of the radius, we will have to draw several intermediate circles with a radius of 98 units, 95 units, 90 units ... 53 units and, finally, 50 units. SwiftUI can do this easily and naturally, just wrap the code that performs this change in withAnimation {...}. It seems magic ... Until you want to implement something a little more complicated than ‚Äúhello world‚Äù.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's move on to the examples. The simplest and most understandable object for animation is considered to be animation of forms. Shape (I will still call the structure conforming to the shape form protocol) in SwiftUI is a structure with parameters that can fit itself into these boundaries. Those. it is a structure that has the function body (in rect: CGRect) -&gt; Path. All the runtime needs to draw this form is to request its outline (the result of the function is an object of type Path, in fact, it is a Bezier curve) for the required size (specified as a function parameter, a rectangle of type CGRect).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Shape is a stored structure. By initializing it, you store in the parameters everything you need to draw its outline. The size of the selection for this form can change, then all that is needed is to get a new Path value for the new CGRect frame, and voila. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start coding already:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">Circle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.green)<font></font>
            .frame(height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habra"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.gray)<font></font>
                )<font></font>
<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)<font></font>
            .frame(width: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>, height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habr"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.green)<font></font>
                )<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleTestView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">50</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">CircleView</span>(radius: radius)<font></font>
               .frame(height: <span class="hljs-number">200</span>)
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$radius, <span class="hljs-keyword">in</span>: <span class="hljs-number">42</span>...<span class="hljs-number">100</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.radius = <span class="hljs-number">50</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set default radius"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/pf/3j/eo/pf3jeo651jcwbhazddldv-rgxhy.gif"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we have a circle (Circle ()), the radius of which we can change using the slider. This happens smoothly, as the slider gives us all the intermediate values. However, when you click the ‚Äúset default radius‚Äù button, the change also does not occur instantly, but according to the withAnimation (.linear (duration: 1)) instruction. Linearly, without acceleration, stretched for 1 second. Class! We mastered the animation! We disagree :) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But what if we want to implement our own form and animate its changes? Is it hard to do this? Let's check. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I made a copy of Circle as follows:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{
        <span class="hljs-keyword">let</span> radius = <span class="hljs-built_in">min</span>(rect.width, rect.height) / <span class="hljs-number">2</span>
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: rect.width / <span class="hljs-number">2</span>, y: rect.height / <span class="hljs-number">2</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-type">Path</span>(){path <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> rect.width &gt; rect.height{<font></font>
                path.move(to: <span class="hljs-type">CGPoint</span>(x: center.x, y: <span class="hljs-number">0</span>))
                <span class="hljs-keyword">let</span> startAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
                path.addArc(center: center, radius: radius, startAngle: startAngle, endAngle:  startAngle + <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>), clockwise: <span class="hljs-literal">false</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                path.move(to: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: center.y))
                <span class="hljs-keyword">let</span> startAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
                path.addArc(center: center, radius: radius, startAngle: startAngle, endAngle:  startAngle + <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>), clockwise: <span class="hljs-literal">false</span>)<font></font>
            }<font></font>
            path.closeSubpath()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The radius of the circle is calculated as half the smaller of the width and height of the border of the screen area allocated to us. </font><font style="vertical-align: inherit;">If the width is greater than the height, we start from the middle of the upper border (Note 1), describe the full circle in a clockwise direction (Note 2), and close our outline on this. </font><font style="vertical-align: inherit;">If the height is greater than the width, we start from the middle of the right border, we also describe the full circle clockwise and close the contour.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note 1</font></font></b>
                        <div class="spoiler_text">Apple     (  )  .  ,      (0, 0),         (x, y),  x ‚Äî  ,  y ‚Äî  . ..        y.   y ‚Äî   .  ,        .  90    , 180  ‚Äî , 270  ‚Äî .</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note 2</font></font></b>
                        <div class="spoiler_text">   1   ,   ‚Äú ‚Äù  ‚Äú ‚Äù         .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"></a>  Core Graphics (SwiftUI      ):<br>
<blockquote>In a flipped coordinate system (the default for UIView drawing methods in iOS), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.</blockquote></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's check how our new circle will respond to changes in the withAnimation block:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)<font></font>
            .frame(width: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>, height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habr"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.green)<font></font>
                )<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleTestView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">50</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
                <span class="hljs-type">HStack</span>{
                <span class="hljs-type">CircleView</span>(radius: radius)<font></font>
                    .frame(height: <span class="hljs-number">200</span>)
                <span class="hljs-type">CustomCircleView</span>(radius: radius)<font></font>
                    .frame(height: <span class="hljs-number">200</span>)<font></font>
            }<font></font>
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$radius, <span class="hljs-keyword">in</span>: <span class="hljs-number">42</span>...<span class="hljs-number">100</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.radius = <span class="hljs-number">50</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set default radius"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/ba/qp/5obaqpgty5ckwvic5uxzscqtix4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wow! </font><font style="vertical-align: inherit;">We learned how to make our own free-form pictures and animate them! </font><font style="vertical-align: inherit;">It is so? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Not really. </font><font style="vertical-align: inherit;">All the work here is done by the .frame modifier (width: self.radius * 2, height: self.radius * 2). </font><font style="vertical-align: inherit;">Inside the withAnimation block {...} we change</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">State</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a variable, it sends a signal to reinitialize CustomCircleView () with a new radius value, this new value falls into the .frame () modifier, and this modifier already can animate parameter changes. Our CustomCircle () form reacts to this with animation, because it does not depend on anything other than the size of the area selected for it. Changing the area occurs with the animation, (i.e. gradually, interpolating the intermediate values ‚Äã‚Äãbetween it was-has become), therefore our circle is drawn with the same animation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's simplify (or still complicate?) Our form a little. We will not calculate the radius based on the size of the available area, but we will transfer the radius in the finished form, i.e. make it a stored structure parameter.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{
        <span class="hljs-comment">//let radius = min(rect.width, rect.height) / 2</span><font></font>
...<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>(radius: radius)<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)
            <span class="hljs-comment">//.frame(height: self.radius * 2)</span><font></font>
...<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/g9/ju/pp/g9juppbsuti7iazguvffuy02fiu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, magic is irretrievably lost. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We excluded the frame () modifier from our CustomCircleView (), shifting the responsibility for the size of the circle to the shape itself, and the animation disappeared. </font><font style="vertical-align: inherit;">But it doesn‚Äôt matter; to teach a form to animate changes in its parameters is not too difficult. </font><font style="vertical-align: inherit;">To do this, you need to implement the requirements of the Animatable protocol:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span>, <span class="hljs-title">Animatable</span></span>{
    <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span>{
         <span class="hljs-keyword">get</span>{<font></font>
             radius<font></font>
         }<font></font>
         <span class="hljs-keyword">set</span>{
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"new radius is \(newValue)"</span>)<font></font>
            radius = newValue<font></font>
         }<font></font>
     }<font></font>
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{<font></font>
	...<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/f1/1-/xs/f11-xshpugfdigdwhnle4nupbek.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voila! </font><font style="vertical-align: inherit;">The magic is back again! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And now we can confidently say that our form is really animated - it can reflect changes in its parameters with animation. </font><font style="vertical-align: inherit;">We gave the system a window where it can cram the interpolated values ‚Äã‚Äãneeded for the animation. </font><font style="vertical-align: inherit;">If there is such a window, the changes are animated. </font><font style="vertical-align: inherit;">If it is not, the changes take place without animation, i.e. </font><font style="vertical-align: inherit;">instantly. </font><font style="vertical-align: inherit;">Nothing complicated, right?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AnimatableModifier</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to animate changes inside a View</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But let's go directly to View. </font><font style="vertical-align: inherit;">Suppose we want to animate the position of an element inside a container. </font><font style="vertical-align: inherit;">In our case, it will be a simple rectangle of green color and a width of 10 units. </font><font style="vertical-align: inherit;">We will animate its horizontal position.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SimpleView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">ZStack</span>{
                <span class="hljs-type">Rectangle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.gray)
                <span class="hljs-type">BorderView</span>(position: position)<font></font>
            }<font></font>
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$position, <span class="hljs-keyword">in</span>: <span class="hljs-number">0</span>...<span class="hljs-number">1</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.position = <span class="hljs-number">0</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set to 0"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderView</span>: <span class="hljs-title">View</span>,  <span class="hljs-title">Animatable</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Reding position: \(position)"</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.position<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.position = newValue
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"setting position: \(position)"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">let</span> borderWidth: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">init</span>(position: <span class="hljs-type">CGFloat</span>, borderWidth: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">10</span>){
        <span class="hljs-keyword">self</span>.position = position
        <span class="hljs-keyword">self</span>.borderWidth = borderWidth
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"BorderView init"</span>)<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-keyword">self</span>.borderWidth)<font></font>
                .offset(x: <span class="hljs-keyword">self</span>.getXOffset(inSize: geometry.size), y: <span class="hljs-number">0</span>)
                <span class="hljs-comment">// .borderIn(position: position)</span><font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getXOffset</span><span class="hljs-params">(inSize: CGSize)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"calculating position: \(position)"</span>)
        <span class="hljs-keyword">return</span> -inSize.width / <span class="hljs-number">2</span> + inSize.width * position<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/7l/b-/pr/7lb-pry2ta71tvntbemngt8duts.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Class! </font><font style="vertical-align: inherit;">Works! </font><font style="vertical-align: inherit;">Now we know everything about animation! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Not really. </font><font style="vertical-align: inherit;">If you look at the console, then we will see the following:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BorderView init </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
calculating position: 0.4595176577568054 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BorderView init </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
calculating position: 0.468130886554718 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BorderView init </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
calculating position: 0.0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Firstly, each change in the position value using the slider causes the BorderView to reinitialize with the new value. That is why we see a smooth movement of the green line after the slider, the slider simply very often reports a change in the variable, and it looks like an animation, but it is not. Using the slider is really convenient when you debug animation. You can use it to track some transitional states. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secondly, we see that the calculating position simply became equal to 0, and no intermediate logs, as was the case with the correct animation of the circle. Why?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The thing, as in the previous example, is in the modifier. </font><font style="vertical-align: inherit;">This time, the .offset () modifier gets the new indent value, and it animates the change itself. </font><font style="vertical-align: inherit;">Those. </font><font style="vertical-align: inherit;">in fact, it‚Äôs not the change in the position parameter that we intended to be animated, but the horizontal change of the indent in the .offset () modifier derived from it. </font><font style="vertical-align: inherit;">In this case, this is a harmless replacement, the result is the same. </font><font style="vertical-align: inherit;">But since they have come, let's dig deeper. </font><font style="vertical-align: inherit;">Let's make our own modifier, which will receive position (from 0 to 1) at the input, it will receive the size of the available area and calculate the indent.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderPosition</span>: <span class="hljs-title">ViewModifier</span></span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span><font></font>
            content<font></font>
            .offset(x: <span class="hljs-keyword">self</span>.getXOffset(inSize: geometry.size), y: <span class="hljs-number">0</span>)<font></font>
            .animation(<span class="hljs-literal">nil</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getXOffset</span><span class="hljs-params">(inSize: CGSize)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-keyword">let</span> offset = -inSize.width / <span class="hljs-number">2</span> + inSize.width * position
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"at position  \(position) offset is \(offset)"</span>)
        <span class="hljs-keyword">return</span> offset<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">borderIn</span><span class="hljs-params">(position: CGFloat)</span></span> -&gt; some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">BorderPosition</span>(position: position))<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the original BorderView, respectively, the GeometryReader is no longer needed, as well as the function for calculating the indent:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderView</span>: <span class="hljs-title">View</span>,  <span class="hljs-title">Animatable</span></span>{<font></font>
    ...<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-keyword">self</span>.borderWidth)<font></font>
                .borderIn(position: position)<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hd/3i/r0/hd3ir0e-_jji7qwiasacdwpnpx4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yes, we still use the .offset () modifier inside our modifier, but after it we added the .animation (nil) modifier, which blocks our own offset animation. </font><font style="vertical-align: inherit;">I understand that at this stage you can decide that it is enough to remove this lock, but then we will not get to the bottom of the truth. </font><font style="vertical-align: inherit;">And the truth is that our trick with animatableData for BorderView does not work. </font><font style="vertical-align: inherit;">In fact, if you look at the documentation for the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animatable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> protocol </font><font style="vertical-align: inherit;">, you will notice that the implementation of this protocol is supported only for AnimatableModifier, GeometryEffect and Shape. </font><font style="vertical-align: inherit;">View is not among them.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The right approach is to animate modifications</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The approach itself, when we ask View to animate some changes, was incorrect. </font><font style="vertical-align: inherit;">For View, you cannot use the same approach as for forms. </font><font style="vertical-align: inherit;">Instead, the animation needs to be embedded in each modifier. </font><font style="vertical-align: inherit;">Most built-in modifiers already support animation out of the box. </font><font style="vertical-align: inherit;">If you want animation for your own modifiers, you can use the AnimatableModifier protocol instead of ViewModifier. </font><font style="vertical-align: inherit;">And there you can implement the same thing as when animating shape changes, as we did above.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderPosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> startDate: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"reading position: \(position) at time \(Date().timeIntervalSince(startDate))"</span>)
            <span class="hljs-keyword">return</span> position<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {<font></font>
            position = newValue<font></font>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"setting position: \(position) at time \(Date().timeIntervalSince(startDate))"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
...<font></font>
    }<font></font>
    ...<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/p2/l3/ys/p2l3yslis_hirenud-lpkt8xaoa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now everything is right. </font><font style="vertical-align: inherit;">Messages in the console help to understand that our animation really works, and .animation (nil) inside the modifier does not interfere with it at all. </font><font style="vertical-align: inherit;">But let's still figure out exactly how it works.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, you need to understand what a modifier is.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we have a View. As I said in the previous part, this is a structure with stored parameters and assembly instructions. This instruction, by and large, does not contain a sequence of actions, which is the usual code that we write in a non-declarative style, but a simple list. It lists the other View, the modifiers applied to them, and the containers in which they are included. We are not interested in containers yet, but let's talk more about modifiers.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A modifier is again a structure with stored parameters, and View processing instructions. </font><font style="vertical-align: inherit;">This is actually the same instruction as the View - we can use other modifiers, use containers (for example, I used the GeometryReader a little higher) and even other View. </font><font style="vertical-align: inherit;">But we only have incoming content, and we need to somehow change it using this instruction. </font><font style="vertical-align: inherit;">Modifier parameters are part of the instruction. </font><font style="vertical-align: inherit;">But the most interesting is that they are stored.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In a previous article, I said that the instruction itself is not stored, that it is thrown every time after the View is updated. </font><font style="vertical-align: inherit;">Everything is so, but there is a nuance. </font><font style="vertical-align: inherit;">As a result of the work of this instruction, we get not quite a picture, as I said earlier - it was a simplification. </font><font style="vertical-align: inherit;">Modifiers do not disappear after the operation of this instruction. </font><font style="vertical-align: inherit;">They remain so while the parent View exists.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some primitive analogies</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How would we describe a table in a declarative style? </font><font style="vertical-align: inherit;">Well, we would list 4 legs and a countertop. </font><font style="vertical-align: inherit;">They would combine them into some kind of container, and with the help of some modifiers would prescribe how they are fastened to each other. </font><font style="vertical-align: inherit;">For example, each leg would indicate the orientation with respect to the countertop, and the position - which leg is pinned to which corner. </font><font style="vertical-align: inherit;">Yes, we can throw out the instructions after assembly, but the nails will remain in the table. </font><font style="vertical-align: inherit;">So are the modifiers. </font><font style="vertical-align: inherit;">At the exit from the body function, we have not quite a table. </font><font style="vertical-align: inherit;">Using body, we create table elements (view), and fasteners (modifiers), and lay it all out in drawers. </font><font style="vertical-align: inherit;">The table itself is assembled by a robot. </font><font style="vertical-align: inherit;">What fasteners you put in a box to each leg, you will get such a table.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The .modifier (BorderPosition (position: position)) function, with which we turned the BorderPosition structure into a modifier, only puts an additional screw in the drawer to the table leg. The BorderPosition structure is this screw. The render, at the time of rendering, takes this box, takes out a leg from it (Rectangle () in our case), and sequentially gets all modifiers from the list, with the values ‚Äã‚Äãstored in them. The body function of each modifier is an instruction on how to screw a leg to a tabletop with this screw, and the structure itself with stored properties, this is that screw. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why is it important to understand this in the context of animation? Because the animation allows you to change the parameters of one modifier without affecting the others, and then re-render the image. If you do the same by changing some</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameters - this will cause reinitialization of nested View, modifier structures, and so on, all along the chain. But the animation is not. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, when we change the value of position when we press a button, it changes. Right to the end. No intermediate states are stored in the variable itself, which cannot be said about the modifier. For each new frame, the values ‚Äã‚Äãof the modifier parameters change according to the progress of the current animation. If the animation lasts 1 second, then every 1/60 of a second (the iphone shows exactly that number of frames per second), the animatableData value inside the modifier will change, then it will be read by the render for rendering, after which, after another 1/60 of a second it will be changed again, and read again by the render.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typically, we first get the final state of the entire View, remember it, and only then the animation mechanism begins to palm off the interpolated position values ‚Äã‚Äãinto the modifier. The initial state is not stored anywhere. Somewhere in the bowels of SwiftUI, only the difference between the initial and final state is stored. This difference is each time multiplied by the fraction of elapsed time. This is how the interpolated value is calculated, which is subsequently substituted into animatableData. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Difference = </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Steel </font></font><br><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">- Was </font></i><i><font style="vertical-align: inherit;">Current Value = Steel - Difference * (1 - Time Elapsed) </font></i><i><font style="vertical-align: inherit;">
Time Elapsed = Time From StartAnimations / DurationAnimations The</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
current value needs to be calculated as many times as the number of frames we need to show.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why is the ‚ÄúWas‚Äù not used explicitly? The fact is that SwiftUI does not store the initial state. Only the difference is stored: so, in the event of some kind of failure, you can simply turn off the animation, and go to the current state of ‚Äúbecome‚Äù. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This approach allows you to make the animation reversible. Suppose, somewhere in the middle of one animation, the user pressed a button again, and we again changed the value of the same variable. In this case, all we need to do to beat this change beautifully is to use the ‚ÄúCurrent‚Äù value inside the animation at the time of the new change, remember the new Difference, and start a new animation based on the new ‚ÄúBecame‚Äù and the new ‚ÄúDifference‚Äù . Yes, in fact, these transitions from one animation to another may be a little more difficult to simulate inertia, but the meaning, I think, is understandable.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is interesting is that the animation each frame asks for the current value inside the modifier (using a getter). This, as you can see from the service records in the log, is responsible for the status of ‚ÄúSteel‚Äù. Then, using the setter, we set the new state that is current for this frame. After that, for the next frame, the current value from the modifier is again requested - and it again ‚ÄúHas become‚Äù, i.e. The final value to which the animation is moving. It is likely that copies of modifier structures are used for animation, and a getter of one structure (a real modifier of the actual View) is used to get the value ‚ÄúSteel‚Äù, and a setter of another (a temporary modifier used for animation) is used. I haven‚Äôt come up with a way to make sure of this, but by indirect indications everything looks just like that. Anyway,changes within the animation do not affect the stored value of the modifier structure of the current View. If you have ideas on how to find out exactly what exactly happens with the getter and setter, write about it in the comments, I will update the article.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Several parameters</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Until this moment, we had only one parameter for animation. </font><font style="vertical-align: inherit;">The question may arise, but what about if more than one parameter is passed to the modifier? </font><font style="vertical-align: inherit;">And if both of them need to be animated at the same time? </font><font style="vertical-align: inherit;">Here's how with the frame modifier (width: height :) for example. </font><font style="vertical-align: inherit;">After all, we can simultaneously change both the width and the height of this View, and we want the change to occur in one animation, how to do it? </font><font style="vertical-align: inherit;">After all, the AnimatableData parameter is one, what can I substitute into it?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you look, Apple has only one requirement for animatableData. The data type that you substitute into it must satisfy the VectorArithmetic protocol. This protocol requires the object to ensure the minimum arithmetic operations that are necessary in order to be able to form a segment of two values, and interpolate the points inside this segment. The operations necessary for this are addition, subtraction and multiplication. The difficulty is that we must perform these operations with a single object that stores several parameters. Those. we must pack the entire list of our parameters in a container that will be a vector. Apple provide such an object out of the box, and offer us to use a turnkey solution for not very difficult cases. It is called AnimatablePair.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's change the task a bit. </font><font style="vertical-align: inherit;">We need a new modifier that will not only move the green bar, but also change its height. </font><font style="vertical-align: inherit;">These will be two independent modifier parameters. </font><font style="vertical-align: inherit;">I will not give the full code of all the changes that need to be done, you can see it on the github in the SimpleBorderMove file. </font><font style="vertical-align: inherit;">I will show only the modifier itself:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TwoParameterBorder</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> startDate: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">AnimatablePair</span>&lt;<span class="hljs-type">CGFloat</span>, <span class="hljs-type">CGFloat</span>&gt; {
        <span class="hljs-keyword">get</span> {
           <span class="hljs-built_in">print</span>(<span class="hljs-string">"animation read position: \(position), height: \(height)"</span>)
           <span class="hljs-keyword">return</span> <span class="hljs-type">AnimatablePair</span>(position, height)<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.position = newValue.first
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"animating position at \(position)"</span>)
            <span class="hljs-keyword">self</span>.height = newValue.second
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"animating height at \(height)"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(position: <span class="hljs-type">CGFloat</span>, height: <span class="hljs-type">CGFloat</span>){
        <span class="hljs-keyword">self</span>.position = position
        <span class="hljs-keyword">self</span>.height = height<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span><font></font>
            content<font></font>
                .animation(<span class="hljs-literal">nil</span>)<font></font>
                .offset(x: -geometry.size.width / <span class="hljs-number">2</span> + geometry.size.width * <span class="hljs-keyword">self</span>.position, y: <span class="hljs-number">0</span>)<font></font>
                .frame(height: <span class="hljs-keyword">self</span>.height * (geometry.size.height - <span class="hljs-number">20</span>) + <span class="hljs-number">20</span>)<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vn/0q/mi/vn0qmirl31w63mzgjvijsw-f-ps.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I added another slider and a button for randomly changing both parameters at once in the parent view of SimpleView, but there‚Äôs nothing interesting, so for the full code, welcome to the github. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything works, we really get a consistent change in the pair of parameters packed in the AnimatablePair tuple. </font><font style="vertical-align: inherit;">Not bad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nothing confuses in this implementation? </font><font style="vertical-align: inherit;">Personally, I tensed up when I saw this design:</font></font><br>
<br>
<pre><code class="swift hljs">        
<span class="hljs-keyword">self</span>.position = newValue.first
<span class="hljs-keyword">self</span>.height = newValue.second
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I didn‚Äôt indicate anywhere which of these parameters should go first and which second. How does SwiftUI decide which value to put in first and which value in second? Well, doesn‚Äôt it match the names of the parameters of the function with the names of the attributes of the structure?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first idea was the order of the attributes in the parameters of the function and their types, as happens with @EnvironmentObject. There, we simply put the values ‚Äã‚Äãin the box, without assigning them any labels, and then we get them out of there, also without indicating any labels. There, type matters, and within one type, order. In what order they put in the box, in the same way and get it. I tried a different order of the arguments of the function, the order of the arguments to initialize the structure, the order of the attributes of the structure itself, generally banged my head against the wall, but could not confuse SwiftUI so that it began to animate the position with height values ‚Äã‚Äãand vice versa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then it dawned on me. I myself indicate which parameter will be the first and which second in the getter. SwiftUI does not need to know exactly how we initialize this structure. He can get the animatableData value before the change, get it after the change, calculate the difference between them, and return the same difference, scaled in proportion to the elapsed time interval, to our setter. It generally does not need to know anything about the value itself inside AnimatableData. And if you do not confuse the order of variables in two adjacent lines, then everything will be in order, no matter how complicated the structure of the rest of the code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But let's check it out. After all, we can create our own container vector (oh, I love it, create our own implementation of existing objects, you might have noticed this from a previous article).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ao/v4/an/aov4an8tjqou27syes6klcckwy0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We describe the elementary structure, declare support for the VectorArithmetic protocol, open the error about the protocol not conforming, click fix, and we get the declaration of all the required functions and calculated parameters. </font><font style="vertical-align: inherit;">It remains only to fill them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the same way, we fill our object with the required methods for the AdditiveArithmetic protocol (VectorArithmetic includes its support).</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyAnimatableVector</span>: <span class="hljs-title">VectorArithmetic</span></span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> - <span class="hljs-params">(lhs: MyAnimatableVector, rhs: MyAnimatableVector)</span></span> -&gt; <span class="hljs-type">MyAnimatableVector</span> {
        <span class="hljs-type">MyAnimatableVector</span>(position: lhs.position - rhs.position, height: lhs.height - rhs.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> + <span class="hljs-params">(lhs: MyAnimatableVector, rhs: MyAnimatableVector)</span></span> -&gt; <span class="hljs-type">MyAnimatableVector</span> {
        <span class="hljs-type">MyAnimatableVector</span>(position: lhs.position + rhs.position, height: lhs.height + rhs.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scale</span><span class="hljs-params">(by rhs: Double)</span></span> {
        <span class="hljs-keyword">self</span>.position = <span class="hljs-keyword">self</span>.position * <span class="hljs-type">CGFloat</span>(rhs)
        <span class="hljs-keyword">self</span>.height = <span class="hljs-keyword">self</span>.height * <span class="hljs-type">CGFloat</span>(rhs)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> magnitudeSquared: <span class="hljs-type">Double</span>{
         <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.position * <span class="hljs-keyword">self</span>.position) + <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.height * <span class="hljs-keyword">self</span>.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> zero: <span class="hljs-type">MyAnimatableVector</span>{
        <span class="hljs-type">MyAnimatableVector</span>(position: <span class="hljs-number">0</span>, height: <span class="hljs-number">0</span>)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">CGFloat</span>
}</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I think why we need + and - obviously. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scale is a function of scaling. </font><font style="vertical-align: inherit;">We take the difference ‚ÄúIt was - It has become‚Äù and multiply it by the current stage of the animation (from 0 to 1). </font><font style="vertical-align: inherit;">‚ÄúIt became + Difference * (1 - Stage)‚Äù and there will be a current value which we should palm off in animatableData</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zero is probably needed to initialize new objects whose values ‚Äã‚Äãwill be used for animation. </font><font style="vertical-align: inherit;">The animation uses .zero at the very beginning, but I could not figure out exactly how. </font><font style="vertical-align: inherit;">However, I do not think that this is important.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">magnitudeSquared is a scalar product of a given vector with itself. </font><font style="vertical-align: inherit;">For two-dimensional space, this means the length of the vector squared. </font><font style="vertical-align: inherit;">This is probably used to be able to compare two objects with each other, not elementwise, but as a whole. </font><font style="vertical-align: inherit;">It seems to be not used for animation purposes.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Generally speaking, the ‚Äú- =‚Äù ‚Äú+ =‚Äù functions are also included in the protocol support, but for the structure they can be generated automatically in this form</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> -= <span class="hljs-params">(lhs: <span class="hljs-keyword">inout</span> MyAnimatableVector, rhs: MyAnimatableVector)</span></span> {<font></font>
        lhs = lhs - rhs<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> += <span class="hljs-params">(lhs: <span class="hljs-keyword">inout</span> MyAnimatableVector, rhs: MyAnimatableVector)</span></span> {<font></font>
        lhs = lhs + rhs<font></font>
    }<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For clarity, I set out all this logic in the form of a diagram. </font><font style="vertical-align: inherit;">
The picture is clickable. </font><font style="vertical-align: inherit;">
What we get during the animation is highlighted in red - every next tick (1/60 second) the timer gives a new value of t, and we, in the setter of our modifier, get a new value of animatableData. </font><font style="vertical-align: inherit;">That's how animation works under the hood. </font><font style="vertical-align: inherit;">At the same time, it is important to understand that a modifier is a stored structure, and a copy of the current modifier with a new, current state is used to display the animation.</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/zl/ag/q4/zlagq42atcapum-br2sj00ikubu.png"></a><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why AnimatableData can only be a structure</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is one more point. You cannot use classes as an AnimatableData object. Formally, you can describe for a class all the necessary methods of the corresponding protocol, but this will not take off, and here's why. As you know, a class is a reference data type, and a structure is a value-based data type. When you create one variable based on another, in the case of a class, you copy a link to this object, and in the case of a structure, you create a new object based on the values ‚Äã‚Äãof the existing one. Here is a small example illustrating this difference:</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TestStruct</span></span>{
        <span class="hljs-keyword">var</span> value: <span class="hljs-type">CGFloat</span>
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scaled</span><span class="hljs-params">(by: CGFloat)</span></span>{
            <span class="hljs-keyword">self</span>.value = <span class="hljs-keyword">self</span>.value * by<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span></span>{
        <span class="hljs-keyword">var</span> value: <span class="hljs-type">CGFloat</span>
        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scaled</span><span class="hljs-params">(by: CGFloat)</span></span>{
             <span class="hljs-keyword">self</span>.value = <span class="hljs-keyword">self</span>.value * by<font></font>
        }<font></font>
        <span class="hljs-keyword">init</span>(value: <span class="hljs-type">CGFloat</span>){
            <span class="hljs-keyword">self</span>.value = value<font></font>
        }<font></font>
    }<font></font>
        <span class="hljs-keyword">var</span> stA = <span class="hljs-type">TestStruct</span>(value: <span class="hljs-number">5</span>)
        <span class="hljs-keyword">var</span> stB = stA<font></font>
        stB.scaled(by: <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"structs: a = \(stA.value), b = \(stB.value))"</span>) <span class="hljs-comment">//structs: a = 5.0, b = 10.0)</span>
        <span class="hljs-keyword">var</span> clA = <span class="hljs-type">TestClass</span>(value: <span class="hljs-number">5</span>)
        <span class="hljs-keyword">var</span> clB = clA<font></font>
        clB.scaled(by: <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"classes: a = \(clA.value), b = \(clB.value))"</span>) <span class="hljs-comment">//classes: a = 10.0, b = 10.0)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With animation exactly the same thing happens. We have an AnimatableData object representing the difference between ‚Äúwas‚Äù and ‚Äúbecame‚Äù. We need to calculate part of this difference to reflect on the screen. To do this, we must copy this difference and multiply it by a number representing the current stage of the animation. In the case of the structure, this will not affect the difference itself, but in the case of the class it will. The first frame that we draw is the ‚Äúwas‚Äù state. To do this, we need to calculate Steel + Difference * Current Stage - Difference. In the case of the class, in the first frame we multiply the difference by 0, zeroing it, and all subsequent frames are drawn so that the difference = 0. i.e. the animation seems to be drawn correctly, but in fact we see an instant transition from one state to another, as if there was no animation.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can probably write some kind of low-level code that creates new memory addresses for the multiplication result - but why? </font><font style="vertical-align: inherit;">You can just use structures - they are created for that. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For those who want to thoroughly understand exactly how SwiftUI calculates intermediate values, by what operations and at what moment, </font><font style="vertical-align: inherit;">messages are pushed into the console </font><font style="vertical-align: inherit;">in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">project</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In addition, I inserted sleep 0.1 second there to simulate resource-intensive calculations inside the animation, have fun :)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Screen animation: .transition ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Up to this point, we talked about animating a change in a value passed to a modifier or form. These are pretty powerful tools. But there is another tool that also uses animation - this is the animation of the appearance and disappearance of the View. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the last article, we talked about the fact that in the declarative style of if-else, this is not at all control over the flow of code in runtime, but rather a view of Schr√∂dinger. This is a container containing two View at the same time, which decides which one to show in accordance with a certain condition. If you miss the else block, then EmptyView is displayed instead of the second view. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Switching between the two View can also be animated. To do this, use the .transition () modifier.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TransitionView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">let</span> views: [<span class="hljs-type">AnyView</span>] = [<span class="hljs-type">AnyView</span>(<span class="hljs-type">CustomCircleTestView</span>()), <span class="hljs-type">AnyView</span>(<span class="hljs-type">SimpleBorderMove</span>())]<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> currentViewInd = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">ZStack</span>{
                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                        }<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-type">HStack</span>{
                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">10</span>)<font></font>
                        .fill(ind == <span class="hljs-keyword">self</span>.currentViewInd ? <span class="hljs-type">Color</span>.green : <span class="hljs-type">Color</span>.gray)<font></font>
                        .overlay(<font></font>
                            <span class="hljs-type">Text</span>(<span class="hljs-string">"\(ind + Int(1))"</span>))<font></font>
                        .onTapGesture{<font></font>
                            withAnimation{<font></font>
                                <span class="hljs-keyword">self</span>.currentViewInd = ind<font></font>
                            }<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
                .frame(height: <span class="hljs-number">50</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's watch how it works. First of all, in advance, even at the initialization stage of the parent view, we created and placed several Views in the array. The array is of type AnyView, because the elements of the array must have the same type, otherwise they cannot be used in ForEach. Opaque result type from the previous </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , remember? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, we prescribed enumeration of the indices of this array, and for each of them we display view by this index. We are forced to do this, and not iterate over View immediately, because to work with ForEach, we need to assign an internal identifier to each element so that SwiftUI can iterate over the contents of the collection. As an alternative, we would have to create a proxy identifier in each View, but why, if indexes can be used?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We wrap each view from the collection in a condition, and show it only if it is active. However, the if-else construct just cannot exist here, the compiler takes it for control of the flow, so we enclose all this in Group so that the compiler understands exactly what it is View, or more precisely, instructions for ViewBuilder to create an optional container ConditionalContent &lt;View1, View2&gt;. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, when changing the value of currentViewInd, SwiftUI hides the previous active view, and shows the current one. How do you like this navigation inside the application?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ua/kr/gd/uakrgd2tzwv9hik_egmn1fglsfw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All that remains to be done is to put the currentViewInd change in the withAnimation wrapper, and switching between windows will become smooth. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Add the .transition modifier, specifying .scale as the parameter. </font><font style="vertical-align: inherit;">This will make the animation of the appearance and disappearance of each of these views different - using the scaling rather than transparency used by default SwiftUI.</font></font><br>
<br>
<pre><code class="swift hljs">                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                                .transition(.scale)<font></font>
                        }<font></font>
                    }<font></font>
                }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/l5/ib/d-/l5ibd-y7m986miqinbv56qaslfc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note that the view appears and disappears with the same animation, only the disappearance scrolls in the reverse order. </font><font style="vertical-align: inherit;">In fact, we can individually assign animations for both the appearance and the disappearance of a view. </font><font style="vertical-align: inherit;">An asymmetric transition is used for this.</font></font><br>
<br>
<pre><code class="swift hljs">                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                               .transition(.asymmetric(<font></font>
                                    insertion: insertion: <span class="hljs-type">AnyTransition</span>.scale(scale: <span class="hljs-number">0.1</span>, anchor: .leading).combined(with: .opacity),<font></font>
                                    removal: .move(edge: .trailing)))<font></font>
                        }<font></font>
                    }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mq/xg/ji/mqxgji1ton95qn6ywl23xhl2mzm.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The same .scale animation is used to appear on the screen, but now we have specified the parameters for its use. It does not begin with a size zero (point), but with a size of 0.1 from the usual one. And the starting position of the small window is not in the center of the screen, but shifted to the left edge. In addition, not one transition is responsible for the appearance, but two. They can be combined with .combined (with :). In this case, we have added transparency. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The disappearance of the view is now rendered by another animation - sweeping the right edge of the screen. I made the animation a little slower so you can take a look at it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And as always, I can‚Äôt wait to write my own version of transit animation. This is even simpler than animated forms or modifiers.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpinTransitionModifier</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-keyword">let</span> angle: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> anchor: <span class="hljs-type">UnitPoint</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        content<font></font>
            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle), anchor: anchor)<font></font>
            .clipped()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">AnyTransition</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinIn</span><span class="hljs-params">(anchor: UnitPoint)</span></span> -&gt; <span class="hljs-type">AnyTransition</span> {<font></font>
        .modifier(<font></font>
            active: <span class="hljs-type">SpinTransitionModifier</span>(angle: -<span class="hljs-number">90</span>, anchor: anchor),<font></font>
            identity: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">0</span>, anchor: anchor))<font></font>
    }<font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinOut</span><span class="hljs-params">(anchor: UnitPoint)</span></span> -&gt; <span class="hljs-type">AnyTransition</span> {<font></font>
        .modifier(<font></font>
            active: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">90</span>, anchor: anchor),<font></font>
            identity: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">0</span>, anchor: anchor))<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/k-/mu/eck-muqydvucs1o59dkbnzpnw6e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To begin with, we write the usual modifier in which we transfer a certain number - the rotation angle in degrees, as well as the point relative to which this rotation occurs. Then, we extend the AnyTransition type with two functions. It could have been one, but it seemed to me more convenient. I found it easier to assign speaking names to each of them than to control degrees of rotation directly in the View itself. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AnyTransition type has a static modifier method, into which we pass two modifiers, and we get an AnyTransition object that describes a smooth transition from one state to another. identity is the normal state modifier of the animated View. Active is the state of the beginning of the animation for the appearance of the view, or the end of the animation for the disappearance, i.e. the other end of the segment, the states within which will be interpolated.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, spinIn implies that I will use it to make the view appear from outside the screen (or the space allocated for the View) by rotating clockwise around the specified point. spinOut means that the view will disappear in the same way, rotating around the same point, also clockwise. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
According to my idea, if you use the same point for the appearance and disappearance of the View, you get the effect of rotating the entire screen around this point.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All animation is based on standard modifier mechanics. If you write a fully custom modifier, you must implement the requirements of the AnimatableModifier protocol, as we did earlier with TwoParameterBorder, or use the built-in modifiers inside it that provide their own default animation. In this case, I relied on the built-in .rotationEffect () animation inside my SpinTransitionModifier modifier.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The .transition () modifier only clarifies what to consider as the start and end point of the animation. If we need to request the AnimatableData state before starting the animation to animate the usual change, then request the AnimatableData of the current state modifier, calculate the difference, and then animate the reduction of this difference from 1 to 0, then .transition () only changes the initial data. You are not attached to the state of your View; you are not based on it. You explicitly specify the initial and final state yourself, from them you get AnimatableData, calculate the difference and animate it. Then, at the end of the animation, your current View comes to the fore.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By the way, identity is a modifier that will remain applied to your View at the end of the animation. Otherwise, an error here would lead to jumps at the end of the appearance animation, and the beginning of the disappearance animation. So transition can be considered as ‚Äútwo in one‚Äù - applying a specific modifier directly to View + the ability to animate its changes when the View appears and disappears. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Honestly, this animation control mechanism seems very strong to me, and I'm a little sorry that we cannot use it for any animation. I would not refuse such for creation of endless closed animation. However, we will talk about it in the next article.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To better see how the change itself occurs, I replaced our test View with elementary squares, signed with numbers, and framed.</font></font><br>
<br>
<pre><code class="swift hljs">                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-comment">//self.views[ind]</span>
                            <span class="hljs-type">Rectangle</span>()<font></font>
                                .fill(<span class="hljs-type">Color</span>.gray)<font></font>
                                .frame(width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)<font></font>
                                .border(<span class="hljs-type">Color</span>.black, width: <span class="hljs-number">2</span>)<font></font>
                                .overlay(<span class="hljs-type">Text</span>(<span class="hljs-string">"\(ind + 1)"</span>))<font></font>
                              .transition(.asymmetric(<font></font>
                                  insertion: .spinIn(anchor: .bottomTrailing),<font></font>
                                  removal: .spinOut(anchor: .bottomTrailing)))<font></font>
                        }<font></font>
                    }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/4s/u9/vx4su9aoaqzuqzi2wq8uctpxe7c.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And to make this movement even better, I removed .clipped () from the SpinTransitionModifier modifier:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpinTransitionModifier</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-keyword">let</span> angle: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> anchor: <span class="hljs-type">UnitPoint</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        content<font></font>
            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle), anchor: anchor)
            <span class="hljs-comment">//.clipped()</span><font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/ml/0i/ihml0id6hnttwuhbjuv5s28jhaa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By the way, now we need SpinTransitionModifier in our own modifier altogether. </font><font style="vertical-align: inherit;">It was created only in order to combine the two modifiers, rotationEffect and clipped () into one, so that the rotation animation does not go beyond the scope selected for our View. </font><font style="vertical-align: inherit;">Now, we can use .rotationEffect () directly inside .modifier (), we do not need an intermediary in the form of SpinTransitionModifier.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When View Dies</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An interesting point is the View life cycle if it is placed in an if-else. </font><font style="vertical-align: inherit;">View, although initiated, and recorded as an array element, is not stored in memory. </font><font style="vertical-align: inherit;">All her</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">State</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameters are reset to default the next time they appear on the screen. This is almost the same as initialization. Despite the fact that the object-structure itself still exists, the render removed it from its field of view, for it it is not. On the one hand, this reduces memory usage. If you have a large number of complex Views in the array, the render would have to draw them all constantly, reacting to changes - this negatively affected the performance. If I am not mistaken, that was the case before the Xcode 11.3 update. Now, inactive views are unloaded from the render memory. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the other hand, we must move all important state beyond the scope of this View. For this, it is best to use @EnvironmentObject variables.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Returning to the life cycle, it should also be noted that the .onAppear {} modifier, if one is registered inside this View, works immediately after changing the condition and the appearance of the View on the screen, even before the animation starts. </font><font style="vertical-align: inherit;">Accordingly, onDisappear {} is triggered after the end of the disappearance animation. </font><font style="vertical-align: inherit;">Keep this in mind if you plan to use them with transition animation.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What's next? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Phew </font><font style="vertical-align: inherit;">It turned out quite voluminously, but in detail, and, I hope, intelligibly. </font><font style="vertical-align: inherit;">Honestly, I was hoping to talk about rainbow animation as part of one article, but I could not stop in time with the details. </font><font style="vertical-align: inherit;">So wait for the continuation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The next part expects us:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use of gradients: linear, circular and angular - everything will come in handy</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Color is not color at all: choose wisely.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">looped animation: how to start and how to stop, and how to stop immediately (without animation, changing the animation - yes, there is one too)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">current stream animation: priorities, overrides, different animation for different objects</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">details about animation timings: we will drive timings both in the tail and in the mane, right up to our own implementation of timingCurve (oh, keep me seven :))</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">how to find out the current moment of the played animation</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If SwiftUI is not enough</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will talk about all this in detail using the example of creating rainbow animation, as in the picture:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I did not go the easy way, but collected all the rakes I could reach, embodying this animation on the principles described above. </font><font style="vertical-align: inherit;">The story about this should turn out to be very informative, and rich in tricks and all kinds of hacks, about which there were few reports, and which will be useful to those who decide to become a pioneer in SwiftUI. </font><font style="vertical-align: inherit;">It will appear approximately in a week or two. </font><font style="vertical-align: inherit;">By the way, you can subscribe so as not to miss. </font><font style="vertical-align: inherit;">But this, of course, only if the material seems useful to you, and the method of presentation is approved. </font><font style="vertical-align: inherit;">Then, your subscription will help to quickly bring new articles to the top, bringing them to a wider audience early. </font><font style="vertical-align: inherit;">Otherwise, write in the comments what is wrong.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en504186/index.html">Paul Graham: How to Write Useful Texts (Full)</a></li>
<li><a href="../en504188/index.html">Quarantine, online systems and data science. Who thinks about customer retention?</a></li>
<li><a href="../en504190/index.html">MVCC as one way to ensure transaction isolation</a></li>
<li><a href="../en504194/index.html">The result of a survey of developers on Stack Overflow 2020 (+ habraopros)</a></li>
<li><a href="../en504196/index.html">NFC: Parsing Near Field Communication Technology</a></li>
<li><a href="../en504204/index.html">IBM Workshops: Quarkus (Ultrafast Java for Microservices), Jakarta EE, and OpenShift</a></li>
<li><a href="../en504208/index.html">How to Automate a Shared Service Center</a></li>
<li><a href="../en504210/index.html">What is Deno and will it replace Node.js?</a></li>
<li><a href="../en504214/index.html">The development of DATA VAULT and the transition to BUSINESS DATA VAULT</a></li>
<li><a href="../en504216/index.html">How old is this house. How I made a map of the age of houses in St. Petersburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>