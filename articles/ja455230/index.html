<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⌨️ 👲🏻 〽️ ﻿C＃8.0のnull可能な参照型と静的分析 👂🏿 👨🏿‍🚀 👨🏼‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="マイクロソフトがC＃の8番目のバージョンのリリースにかなりの期間取り組んできたことは秘密ではありません。最近のVisual Studio 2019リリースでは、言語の新しいバージョン（C＃8.0）が既に利用可能ですが、これまでのところベータリリースのみです。この新しいバージョンの計画にはいくつかの機...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>﻿C＃8.0のnull可能な参照型と静的分析</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/455230/"><p><img src="https://habrastorage.org/getpro/habr/post_images/523/17b/496/52317b4960a8b063bc7b6541e4e2666d.png" alt="写真9"></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マイクロソフトがC＃の8番目のバージョンのリリースにかなりの期間取り組んできたことは秘密ではありません。最近のVisual Studio 2019リリースでは、言語の新しいバージョン（C＃8.0）が既に利用可能ですが、これまでのところベータリリースのみです。この新しいバージョンの計画にはいくつかの機能があり、それらの実装は完全に明白ではないように見えるか、かなり期待されていない場合があります。これらの革新の1つは、Nullable Referenceタイプを使用する機能です。この革新の明記された意味は、ヌル参照例外（NRE）との戦いです。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語が開発されており、新しい機能が開発者に役立つはずです。</font><font style="vertical-align: inherit;">偶然にも、C＃用のPVS-Studioアナライザーでは、コード内でまったく同じNREを検出する機能が比較的最近拡張されました。</font><font style="vertical-align: inherit;">そして私たちは自分自身に尋ねました-静的アナライザー一般、特にPVS-Studioにとって、少なくともNullable参照を使用する新しいコードで、そのような逆参照が「不可能」になる場合に、null参照の逆参照の可能性を探すことには意味があるのでしょうか。 ？</font><font style="vertical-align: inherit;">この質問に答えてみましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イノベーションの長所と短所</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、この記事の執筆時点で入手可能なC＃8.0の最新のベータ版では、デフォルトでNullable Referenceがオフになっていることを思い出してください。参照型の動作は変更されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C＃8.0でnull可能な参照型を含めるとどうなりますか？これは同じ古き良き参照型ですが、この型の変数は '？'でマークする必要があるという違いがあります。 （例：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">string？</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nullable &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">すでに行われている方法と同様</font><i><font style="vertical-align: inherit;">です。</font></i><font style="vertical-align: inherit;"> null可能な重要な型（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int？など</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。ただし、</font><font style="vertical-align: inherit;">「？」なしの</font><font style="vertical-align: inherit;">同じ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文字列</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すでにnull可能ではない参照として解釈され始めています。これは、変数に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値を含めることができない参照型です</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Null参照例外は、特に例外をスローするメソッドの行に複数の逆参照がある場合、問題の原因についてほとんど言及しないため、最も厄介な例外の1つです。</font><font style="vertical-align: inherit;">型の参照変数に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">渡すことを禁止する機能は優れているように</font><font style="vertical-align: inherit;">見え</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、以前の</font><i><font style="vertical-align: inherit;">nullが</font></i><font style="vertical-align: inherit;"> method </font><i><font style="vertical-align: inherit;">に</font></i><font style="vertical-align: inherit;">渡され</font><font style="vertical-align: inherit;">、その後の実行のロジックがこれに関連付けられている場合、次に何をすべきですか？もちろん、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代わりに</font><font style="vertical-align: inherit;">、リテラル、定数、または単に「不可能な」値を渡す</font><font style="vertical-align: inherit;">ことができます</font><font style="vertical-align: inherit;">。これらの値は、プログラムのロジックに従って、他の場所ではこの変数に割り当てることができません。ただし、プログラム全体の低下は、さらに「サイレント」な誤った実行に置き換えることができます。エラーをすぐに確認するよりも、常に良いとは限りません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして代わりに例外を投げたら？何か問題が発生した場所での意味のある例外は</font><font style="vertical-align: inherit;">、スタックの上下に</font><font style="vertical-align: inherit;">ある</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よりも常に優れ</font><font style="vertical-align: inherit;">ています。ただし、コンシューマを修正し、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try-catchブロック</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を挿入できる独自のプロジェクトについて話しているとよいでしょ</font><i><font style="vertical-align: inherit;">う。</font></i><font style="vertical-align: inherit;">（Nullable以外の）リファレンスを使用してライブラリを開発するときは、何らかのメソッドが常に値を返すという責任を負います。また</font><font style="vertical-align: inherit;">、例外をスローする</font><font style="vertical-align: inherit;">代わりに</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">返すことを（少なくとも単純な方法で）行うのは、ネイティブコードでさえも常にではありません</font><font style="vertical-align: inherit;">（影響を受けるコードが多すぎる可能性があります）。</font><i><font style="vertical-align: inherit;">NullableContextOptions</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
プロパティ</font><font style="vertical-align: inherit;">に値</font><i><font style="vertical-align: inherit;">enable</font></i><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">追加すると、プロジェクトレベルでNullable Referenceを</font><i><font style="vertical-align: inherit;">有効にできます</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、またはファイルレベルで、プリプロセッサディレクティブを使用します。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#nullable enable </span>
<span class="hljs-built_in">string</span> cantBeNull = <span class="hljs-built_in">string</span>.Empty;
<span class="hljs-built_in">string</span>? canBeNull = null;<font></font>
cantBeNull = canBeNull!;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプはより視覚的になります。</font><font style="vertical-align: inherit;">メソッドのシグネチャによれば、それがチェックされ、その挙動を決定することが可能である</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヌル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または、それが返すことができない</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヌル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはできません。</font><font style="vertical-align: inherit;">チェックなしでnull許容の参照変数にアクセスしようとすると、コンパイラーは警告を生成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サードパーティのライブラリを使用する場合はかなり便利ですが、誤った情報が含まれる可能性があります。</font><font style="vertical-align: inherit;">実際には、</font><font style="vertical-align: inherit;">たとえば、新しいnullを許容する演算子（！）を使用して、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を渡すこと</font><font style="vertical-align: inherit;">も可能です。</font><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">ただ1つの感嘆符の助けを借りて、これらの変数を使用してインターフェースに関して行われるすべてのさらなる仮定を破ることができます。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#nullable enable </span>
<span class="hljs-function">String <span class="hljs-title">GetStr</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> _count &gt; <span class="hljs-number">0</span> ? _str : null!; }<font></font>
String str = GetStr();<font></font>
var len = str.Length;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、このように書くのは間違っていると言え、誰もそれを行うことはありませんが、この機会が残っている限り、このメソッドのインターフェイスによって課されたコントラクトのみに完全に依存することはできません（nullを返すことはできません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ところで、いくつかの演算子の助けを借りて同じことを書くことができます！、C＃は次のように書くことができる（そしてこのコードは完全にコンパイルされている）ので：</font></font><br>
<pre><code class="cpp hljs">cantBeNull = canBeNull!!!!!!!;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それら。</font><font style="vertical-align: inherit;">さらに強調したいのですが、注意してください-これは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">かもしれません</font><font style="vertical-align: inherit;">!!! </font><font style="vertical-align: inherit;">（私たちはチームでこれを「感情的な」プログラミングと呼んでいます）。</font><font style="vertical-align: inherit;">実際、（Roslynの）コンパイラは、コードの構文ツリーを構築するときに演算子を解釈します。</font><font style="vertical-align: inherit;">単純な角かっこに似ているため、角かっこの場合のように、その数は無制限です。</font><font style="vertical-align: inherit;">ただし、それらを多数記述した場合、コンパイラは「ダンプ」されます。</font><font style="vertical-align: inherit;">おそらくこれは、C＃8.0の最終バージョンで変更されるでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、null許容の参照変数にチェックを付けずにアクセスする場合は、コンパイラの警告をバイパスできます。</font></font><br>
<pre><code class="cpp hljs">canBeNull!.ToString();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より感情的に書くことができます：</font></font><br>
<pre><code class="cpp hljs">canBeNull!!!?.ToString();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この構文は実際のプロジェクトでは想像するのが難しいため</font><font style="vertical-align: inherit;">、コンパイラーに</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullを許容する</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子を指定します。ここではすべて問題なく、検証は必要ありません。エルビス演算子を追加すると、次のようになります。ただし、一般的には正常でない場合があります。確認してみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今、正当な質問が発生します-なぜ、非null可能な参照型の概念が、この型の変数が</font><i><font style="vertical-align: inherit;">nullを</font></i><font style="vertical-align: inherit;">含むことができないことを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示唆する場合</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それでも簡単に記録できますか？実際のところ、ILコードのレベルでは、「内部」では、null不可の参照型はそのままです。すべて同じ「通常の」参照型です。そして、null可能性構文全体は、実際にはコンパイラーに組み込まれた静的アナライザーの注釈にすぎません（私たちの意見では、最も便利なアナライザーではありませんが、後で詳しく説明します）。私たちの意見では、（コンパイラに組み込まれている場合でも）サードパーティツールの注釈としてのみ言語の新しい構文を含めることは、最も「美しい」ソリューションではありません。この言語を使用しているプログラマにとって、これが単なる注釈であることはまったく明らかではないかもしれません。結局のところ、null許容構造の非常によく似た構文は、まったく異なる方法で機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nullable参照型を「壊す」ことが依然としてどのように可能であるかに戻ってください。執筆時点で、ソリューションに複数のプロジェクトがある場合、1つのプロジェクトで宣言さ</font><font style="vertical-align: inherit;">れたメソッドから</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">String</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型などの参照変数を、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullableContextOptionsが</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有効になっている別のプロジェクトのメソッド</font><font style="vertical-align: inherit;">に渡す</font><i><font style="vertical-align: inherit;">と、</font></i><font style="vertical-align: inherit;">コンパイラーはこれがnullにできないStringであると判断します。警告を出しません。そして、これは</font><font style="vertical-align: inherit;">、Nullable ReferenceがオンのときにILコードの各フィールドとクラスメソッドに追加された</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Nullable（1）]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性の数が非常に多いにもかかわらず</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ちなみに、リフレクションを使用して属性のリストを操作する場合は、これらの属性を考慮に入れる必要があります。自分で追加した属性のみの存在を数えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況では、大きなコードベースをnull可能な参照に変換するときに追加の問題が発生する可能性があります。ほとんどの場合、このプロセスはプロジェクトごとに段階的に行われます。もちろん、変更するための有能なアプローチがあれば、徐々に新しい機能に切り替えることができますが、すでに作業中のドラフトがある場合、その変更は危険であり、望ましくありません（それは機能します-触れないでください！）。そのため、PVS-Studioアナライザーを使用する場合、ソースコードを編集したり、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を検出するためにソースコードをマークアップしたりする必要はありません</font><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">NullReferenceException</font></i><font style="vertical-align: inherit;">が発生する可能性のある場所を確認するには</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナライザを起動して、警告V3080を確認するだけです。</font><font style="vertical-align: inherit;">プロジェクトのプロパティやソースコードを変更する必要はありません。</font><font style="vertical-align: inherit;">ディレクティブ、属性、または演算子を追加する必要はありません。</font><font style="vertical-align: inherit;">コードを変更する必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-StudioアナライザーのNullable参照タイプのサポートにより、私たちは選択に直面しました-アナライザーはnull可能ではない参照変数を常に非ゼロ値として解釈する必要がありますか？</font><font style="vertical-align: inherit;">この保証を「破る」可能性の問題を調査した後、私たちは存在しないという結論に達しました—分析装置はそのような仮定を行うべきではありません。</font><font style="vertical-align: inherit;">実際、null可能ではない参照型がプロジェクトのあらゆる場所で使用されている場合でも、アナライザーは、そのような変数に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が存在する可能性がある状況を発見するだけで、その使用を補完できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studioがnull参照例外を探す方法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C＃アナライザーのデータフローメカニズムPVS-Studioは、分析中に変数の可能な値を監視します。特に、PVS-Studioはプロシージャ間分析も実行します。メソッドによって返される可能性のある値、およびこのメソッドで呼び出されたメソッドなどを判別しようとします。特に、アナライザーは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なる可能性のある変数を記憶してい</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。今後、アナライザーがこのような変数をチェックせずに逆参照を検出した場合、現在のコードまたはこのコードで呼び出されたメソッドの内部で、潜在的なNull参照例外に関する警告V3080が発行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、この診断の根底にある主なアイデアは、アナライザーが割り当てがどこかで</font><i><font style="vertical-align: inherit;">nullである</font></i><font style="vertical-align: inherit;">場合にのみ、アナライザーが誓うということです。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数に。これは、この診断の動作と、Nullable Reference型で機能するコンパイラに組み込まれているアナライザーの主な違いです。コンパイラーに組み込まれたアナライザーは、もちろん、このアナライザーがオペレーターによって「だまされ」ていない限り、タイプの未検証のNULL可能な参照変数の逆参照を誓います。他の方法では、特にそのような目標を自分で設定し、PVS-Studioも例外ではない場合は、絶対に任意のアナライザーを使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-Studioは、</font><i><font style="vertical-align: inherit;">nullと表示された</font></i><font style="vertical-align: inherit;">場合にのみ誓う</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ローカルコンテキスト、またはメソッドから取得）。同時に、変数がnullにできない参照変数であっても、アナライザーの動作は変更されません。nullが書き込まれたことが検出された場合でも、アナライザーはそれを誓います。このアプローチは、次の理由により、より正確です（または、少なくともアナライザーのユーザーにとっては便利です）。</font><i><font style="vertical-align: inherit;">null</font></i><font style="vertical-align: inherit;">チェックですべてのコードを「コーティング」する必要はありません</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">潜在的な逆参照を見つけるために-これは、たとえば同じコントラクトを使用して、Nullable Referenceなしで以前に実行されている可能性があります。さらに、アナライザーを使用して、ヌル化できない同じ参照変数をさらに制御できるようになりました。それらが「正直に」使用され、nullが割り当てられていない場合、アナライザは無音のままになります。 nullが割り当てられていて、変数がチェックなしで逆参照されている場合、アナライザーはメッセージV3080でこれについて警告します。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#nullable enable </span>
<span class="hljs-function">String <span class="hljs-title">GetStr</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> _count &gt; <span class="hljs-number">0</span> ? _str : null!; }<font></font>
String str = GetStr();<font></font>
var len = str.Length; &lt;== V3080: Possible null dereference. <font></font>
                                 Consider inspecting <span class="hljs-string">'str'</span></code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、Roslynのコード自体でV3080診断をトリガーするいくつかの例を検討します。私たちは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このプロジェクトを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少し前</font><font style="vertical-align: inherit;">に</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">確認しました</font></a><font style="vertical-align: inherit;">が、今回は、以前の記事にはなかった潜在的なnull参照例外トリガーのみを検討します。 PVS-Studioアナライザーがnull参照の潜在的な逆参照を見つける方法と、新しいNullable Reference構文を使用してこれらの場所を修正する方法を見てみましょう。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3080 [CWE-476]メソッド内でnull参照が発生する可能性があります。 2番目の引数chainedTupleTypeを調べることを検討してください。 Microsoft.CodeAnalysis.CSharp TupleTypeSymbol.cs 244</font></font></i><br>
<pre><code class="cpp hljs">NamedTypeSymbol chainedTupleType;
<span class="hljs-keyword">if</span> (_underlyingType.Arity &lt; TupleTypeSymbol.RestPosition)<font></font>
  { ....  chainedTupleType = null; }<font></font>
<span class="hljs-keyword">else</span> { .... }
<span class="hljs-keyword">return</span> Create(ConstructTupleUnderlyingType(firstTupleType,<font></font>
  chainedTupleType, newElementTypes), elementNames: _elementNames);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のように、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chainedTupleType</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数</font><font style="vertical-align: inherit;">は、コード実行ブランチの1つでnullになる可能性があります。次いで</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chainedTupleTypeである</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内側通過</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConstructTupleUnderlyingTypeの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><i><font style="vertical-align: inherit;">、</font></i><font style="vertical-align: inherit;">およびを通じて検証とが使用される</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug.Assertの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この状況はRoslynで非常に一般的ですが</font><font style="vertical-align: inherit;">、リリースバージョンのアセンブリでは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug.Assert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が削除され</font><font style="vertical-align: inherit;">ていることを覚えて</font><i><font style="vertical-align: inherit;">おく</font></i><font style="vertical-align: inherit;">価値があります</font><font style="vertical-align: inherit;">。したがって、アナライザーは引き続き、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConstructTupleUnderlyingType</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド内の逆参照を</font><font style="vertical-align: inherit;">危険である</font><font style="vertical-align: inherit;">と見なし</font><font style="vertical-align: inherit;">ます。次に、逆参照が発生するこのメソッドの本体を示します。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">internal <span class="hljs-keyword">static</span> NamedTypeSymbol <span class="hljs-title">ConstructTupleUnderlyingType</span><span class="hljs-params">(
  NamedTypeSymbol firstTupleType, 
  NamedTypeSymbol chainedTupleTypeOpt, 
  ImmutableArray&lt;TypeWithAnnotations&gt; elementTypes)</span>
</span>{<font></font>
  Debug.Assert<font></font>
    (chainedTupleTypeOpt is null ==<font></font>
     elementTypes.Length &lt; RestPosition);<font></font>
  ....<font></font>
  <span class="hljs-keyword">while</span> (loop &gt; <span class="hljs-number">0</span>)<font></font>
  {   <font></font>
    ....<font></font>
    currentSymbol = chainedTupleTypeOpt.Construct(chainedTypes);<font></font>
    loop--;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> currentSymbol;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、アナライザーがSystem.Diagnostics.Contractsからのコントラクトを考慮に入れるため、アナライザーがそのようなAssertを考慮に入れるかどうかは、実際には問題のあるポイントです（一部のユーザーはこれを求めています）。アナライザーで同じRoslynを実際に使用した例を少しだけお話しします。最近、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいバージョンのVisual Studioをサポートする</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と同時に、Roslynアナライザーをバージョン3に更新しました。その後、アナライザーは、それが該当しなかった特定のコードをチェックするとクラッシュし始めました。同時に、アナライザーはコード内ではなく、Roslyn自体のコード内に収まり始めました-Null参照例外が発生しました。さらにデバッグを行うと、Roslynが現在落下している場所で、正確に数行上にあることがわかりました。以下のためにそのチェックがあり</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ヌル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">までは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug.Assert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。そして、私たちが見るように、彼女は救いませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、NULL可能リファレンスに伴う問題の非常に良い例です</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラが考慮するため</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug.Assertの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意の構成で有効チェック。それはあなたが単に有効にした場合、ある</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#nullableが可能</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とアウトマーク</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chainedTupleTypeOptの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引数</font><font style="vertical-align: inherit;">NULL可能リファレンスとして</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何も存在しません</font><font style="vertical-align: inherit;">での間接参照の場所でコンパイラの警告</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConstructTupleUnderlyingTypeの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のPVS-Studioトリガーの例を考えます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3080ヌル逆参照の可能性があります。 「effectiveRuleset」の検査を検討してください。 RuleSet.cs 146</font></font></i><br>
<pre><code class="cpp hljs">var effectiveRuleset = <font></font>
  ruleSet.GetEffectiveRuleSet(includedRulesetPaths);<font></font>
effectiveRuleset = <font></font>
  effectiveRuleset.WithEffectiveAction(ruleSetInclude.Action);<font></font>
<font></font>
<span class="hljs-keyword">if</span> (IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, ....))<font></font>
   effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この警告では、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WithEffectiveAction</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドを呼び出すと</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が返さ</font><font style="vertical-align: inherit;">れる</font><font style="vertical-align: inherit;">場合があり</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">が、結果はチェックされずに使用されています（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effectiveRuleset.GeneralDiagnosticOption</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">nullを返すことができる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WithEffectiveAction</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドの本体は</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effectiveRuleset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数に書き込まれます</font><font style="vertical-align: inherit;">。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> RuleSet <span class="hljs-title">WithEffectiveAction</span><span class="hljs-params">(ReportDiagnostic action)</span>
</span>{
  <span class="hljs-keyword">if</span> (!_includes.IsEmpty)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(....);
  <span class="hljs-keyword">switch</span> (action)<font></font>
  {<font></font>
    <span class="hljs-keyword">case</span> ReportDiagnostic.Default:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">case</span> ReportDiagnostic.Suppress:
      <span class="hljs-keyword">return</span> null;<font></font>
    ....     <font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RuleSet(....);
     <span class="hljs-keyword">default</span>:
       <span class="hljs-keyword">return</span> null;<font></font>
   }<font></font>
}</code></pre><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetEffectiveRuleSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
メソッドのNullable参照モードを有効</font><font style="vertical-align: inherit;">にすると、動作を変更する必要のある場所が2つあります。上記のメソッドには例外のスローがあるため、メソッド呼び出しが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try-catchブロックに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラップされ、</font><font style="vertical-align: inherit;">nullを返す代わりに例外をスローしてメソッドを正しく書き換えると</font><font style="vertical-align: inherit;">想定するのが論理的</font><font style="vertical-align: inherit;">です。しかし、上記の課題が高まっているため、遮断が高く、その結果は非常に予測不可能である可能性があります。コンシューマー変数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effectiveRuleset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><i><font style="vertical-align: inherit;">IsStricterThan</font></i><font style="vertical-align: inherit;">メソッドを</font><font style="vertical-align: inherit;">見てみましょう</font></font><i><font style="vertical-align: inherit;"></font></i><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> 
  <span class="hljs-title">IsStricterThan</span><span class="hljs-params">(ReportDiagnostic action1, ReportDiagnostic action2)</span>
</span>{
  <span class="hljs-keyword">switch</span> (action2)<font></font>
  {<font></font>
    <span class="hljs-keyword">case</span> ReportDiagnostic.Suppress:<font></font>
      ....;<font></font>
    <span class="hljs-keyword">case</span> ReportDiagnostic.Warn:
      <span class="hljs-keyword">return</span> action1 == ReportDiagnostic.Error;
    <span class="hljs-keyword">case</span> ReportDiagnostic.Error:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、これは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReportDiagnostic.Defaultの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能な列挙値を</font><i><font style="vertical-align: inherit;">持つ</font></i><font style="vertical-align: inherit;"> 2つの列挙の単純なスイッチです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、次のように呼び出しを書き直すことが最善です</font><i><font style="vertical-align: inherit;">。WithEffectiveAction</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
シグネチャ</font><font style="vertical-align: inherit;">が変更されます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#nullable enable</span>
<span class="hljs-keyword">public</span> RuleSet? WithEffectiveAction(ReportDiagnostic action)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
呼び出しは次のようになります。</font></font><br>
<pre><code class="cpp hljs">RuleSet? effectiveRuleset = <font></font>
  ruleSet.GetEffectiveRuleSet(includedRulesetPaths);<font></font>
effectiveRuleset = <font></font>
  effectiveRuleset?.WithEffectiveAction(ruleSetInclude.Action);<font></font>
<font></font>
<span class="hljs-keyword">if</span> (IsStricterThan(effectiveRuleset?.GeneralDiagnosticOption ?? <font></font>
                     ReportDiagnostic.Default,<font></font>
                   effectiveGeneralOption))<font></font>
   effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IsStricterThan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は比較のみを実行する</font><font style="vertical-align: inherit;">
ことを知っている</font><font style="vertical-align: inherit;">-条件は、たとえば次のように書き換えることができます。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span> (effectiveRuleset == null || <font></font>
    IsStricterThan(effectiveRuleset.GeneralDiagnosticOption,<font></font>
                   effectiveGeneralOption))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アナライザーからの次のメッセージに移りましょう。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3080ヌル逆参照の可能性があります。</font><font style="vertical-align: inherit;">「propertySymbol」を調べることを検討してください。</font><font style="vertical-align: inherit;">BinderFactory.BinderFactoryVisitor.cs 372</font></font></i><br>
<pre><code class="cpp hljs">var propertySymbol = GetPropertySymbol(parent, resultBinder);<font></font>
var accessor = propertySymbol.GetMethod;<font></font>
<span class="hljs-keyword">if</span> ((object)accessor != null)<font></font>
  resultBinder = <span class="hljs-keyword">new</span> InMethodBinder(accessor, resultBinder);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナライザーの警告を修正するとき</font><font style="vertical-align: inherit;">
は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propertySymbol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数をさらに使用する</font><font style="vertical-align: inherit;">ことを考慮する必要があります。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> SourcePropertySymbol <span class="hljs-title">GetPropertySymbol</span><span class="hljs-params">(
  BasePropertyDeclarationSyntax basePropertyDeclarationSyntax,
  Binder outerBinder)</span>
</span>{<font></font>
  ....<font></font>
  NamedTypeSymbol container <font></font>
    = GetContainerType(outerBinder, basePropertyDeclarationSyntax);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> ((object)container == null)
    <span class="hljs-keyword">return</span> null;<font></font>
  ....<font></font>
  <span class="hljs-keyword">return</span> (SourcePropertySymbol)GetMemberSymbol(propertyName,<font></font>
    basePropertyDeclarationSyntax.Span, container,<font></font>
    SymbolKind.Property);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetMemberSymbol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
メソッド</font><font style="vertical-align: inherit;">も</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">返す</font><font style="vertical-align: inherit;">場合があります。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> Symbol <span class="hljs-title">GetMemberSymbol</span><span class="hljs-params">(
  <span class="hljs-built_in">string</span> memberName, 
  TextSpan memberSpan, 
  NamedTypeSymbol container, 
  SymbolKind kind)</span>
</span>{<font></font>
  foreach (Symbol sym in container.GetMembers(memberName))<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (sym.Kind != kind)
      <span class="hljs-keyword">continue</span>;
    <span class="hljs-keyword">if</span> (sym.Kind == SymbolKind.Method)<font></font>
    {<font></font>
      ....<font></font>
      var implementation =<font></font>
        ((MethodSymbol)sym).PartialImplementationPart;<font></font>
      <span class="hljs-keyword">if</span> ((object)implementation != null)
        <span class="hljs-keyword">if</span> (InSpan(implementation.Locations[<span class="hljs-number">0</span>],
            <span class="hljs-keyword">this</span>.syntaxTree, memberSpan))
          <span class="hljs-keyword">return</span> implementation;<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (InSpan(sym.Locations, <span class="hljs-keyword">this</span>.syntaxTree, memberSpan))
      <span class="hljs-keyword">return</span> sym;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> null;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
null可能な参照型を使用すると、呼び出しは次のように変更されます。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#nullable enable</span><font></font>
SourcePropertySymbol? propertySymbol <font></font>
  = GetPropertySymbol(parent, resultBinder);<font></font>
MethodSymbol? accessor = propertySymbol?.GetMethod;<font></font>
<span class="hljs-keyword">if</span> ((object)accessor != null)<font></font>
  resultBinder = <span class="hljs-keyword">new</span> InMethodBinder(accessor, resultBinder);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
修正する場所がわかっていると、とても簡単です。</font><font style="vertical-align: inherit;">静的分析は、プロシージャコールのすべてのチェーンにわたってすべての可能なフィールド値を取得することにより、この潜在的なエラーを簡単に見つけます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3080ヌル逆参照の可能性があります。</font><font style="vertical-align: inherit;">「simpleName」を調べることを検討してください。</font><font style="vertical-align: inherit;">CSharpCommandLineParser.cs 1556</font></font></i><br>
<pre><code class="cpp hljs"><span class="hljs-built_in">string</span> simpleName;<font></font>
simpleName = PathUtilities.RemoveExtension(<font></font>
  PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path));<font></font>
outputFileName = simpleName + outputKind.GetDefaultExtension();<font></font>
<span class="hljs-keyword">if</span> (simpleName.Length == <span class="hljs-number">0</span> &amp;&amp; !outputKind.IsNetModule())<font></font>
  ....</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simpleName.Lengthの</font></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェックと</font><i><font style="vertical-align: inherit;">一致しています。</font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simpleName</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は一連のメソッド全体の結果であり、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合があり</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ちなみに、好奇心のために、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RemoveExtension</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">見て、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Path.GetFileNameWithoutExtension</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">との違いを見つける</font><font style="vertical-align: inherit;">ことができます</font><i><font style="vertical-align: inherit;">。</font></i><font style="vertical-align: inherit;">ここでは</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simpleName！= Nullの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェックだけに制限でき</font><font style="vertical-align: inherit;">ますが、ゼロ以外のリンクのコンテキストでは、コードは次のようになります。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#nullable enable</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span>? RemoveExtension(<span class="hljs-built_in">string</span> path) { .... }
<span class="hljs-built_in">string</span> simpleName;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
呼び出しは次のようになります。</font></font><br>
<pre><code class="cpp hljs">simpleName = PathUtilities.RemoveExtension(<font></font>
  PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)) ?? <font></font>
  String.Empty;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
null可能な参照型は、ゼロから構築されたアーキテクチャの計画に非常に役立ちますが、既存のコードを作り直すことは、多くの微妙なエラーを引き起こす可能性があるため、多くの時間と注意を要する可能性があります。この記事では、プロジェクトでNullable Reference型を使用しないようにするつもりはありませんでした。このイノベーションは一般的に言語にとって有用であると信じていますが、それがどのように実装されたかは疑問を投げかけるかもしれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチに固有の制限を常に覚えておく必要があります。NullableReferenceモードをオンにしても、nullリンクの逆参照によるエラーは防止されず、誤って使用すると、エラーが発生する可能性もあります。 Nullable Referenceと共にnull参照の逆参照を防ぐことができる追加のツールとして、手続き間分析をサポートするPVS-Studioなどの最新の静的アナライザーの使用を検討する価値があります。これらのアプローチのそれぞれ-詳細な手続き間分析とメソッドシグネチャのアノテーション（これにより、本質的にnull可能な参照が作成されます）には、それぞれ長所と短所があります。アナライザーを使用すると、潜在的に危険な場所のリストを取得できるほか、既存のコードを変更するときに、そのような変更のすべての結果を確認できます。あなたが割り当てる場合</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、アナライザーは変数のすべてのコンシューマーをすぐに示す必要があります。逆参照する前にチェックされません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検討中のプロジェクトと自分のプロジェクトの両方で、他のエラーを個別に検索できます。</font><font style="vertical-align: inherit;">これを行うには</font><font style="vertical-align: inherit;">、PVS-Studioアナライザー</font><font style="vertical-align: inherit;">を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダウンロード</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して試す</font><font style="vertical-align: inherit;">だけです</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事を英語を話す視聴者と共有する場合は、翻訳へのリンクを使用してください：Paul Eremeev、Alexander Senichkin。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C＃8.0のnull可能な参照型と静的分析</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja455216/index.html">ドップラー速度計</a></li>
<li><a href="../ja455218/index.html">ビジネステクノロジーへの生態系アプローチ</a></li>
<li><a href="../ja455224/index.html">Finger Music：SpheroのSpecDrumsで何でもプレイ</a></li>
<li><a href="../ja455226/index.html">なぜ応用言語学者を適用するのですか？</a></li>
<li><a href="../ja455228/index.html">デュークヌケムを復活させた人：ギアボックスウィザード、ランディピッチフォードへのインタビュー</a></li>
<li><a href="../ja455236/index.html">Comodoは理由もなく証明書を取り消す</a></li>
<li><a href="../ja455240/index.html">拒否された不良率を使用してエラー報告を改善する</a></li>
<li><a href="../ja455242/index.html">マイナスの耳、またはゲームのサウンドを最初から損なわないようにする方法</a></li>
<li><a href="../ja455244/index.html">コミック「はんだ付けは簡単」更新版（2019）</a></li>
<li><a href="../ja455246/index.html">サンクトペテルブルクのカスタマーエクスペリエンスデーの登録は6月20日に始まります</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>