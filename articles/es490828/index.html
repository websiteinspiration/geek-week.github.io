<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌙 🧑🏻‍🤝‍🧑🏻 👌🏽 Creando roguelike en Unity desde cero 🔇 👩🏻‍🌾 🤦🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No hay muchos tutoriales sobre cómo crear roguelike en Unity, así que decidí escribirlo. No para alardear, sino para compartir conocimientos con aquel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Creando roguelike en Unity desde cero</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490828/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad4/093/6ab/ad40936ab0dff25fd3214571faf9aa61.png" alt="imagen"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No hay muchos tutoriales sobre cómo crear roguelike en Unity, así que decidí escribirlo. No para alardear, sino para compartir conocimientos con aquellos que están en la etapa en la que ya estaba bastante tiempo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nota: No digo que esta sea la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">única</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> forma de crear un roguelike en Unity. Él es solo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uno de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Probablemente no sea el mejor y más efectivo, aprendí a través de prueba y error. Y aprenderé algunas cosas correctamente en el proceso de creación de un tutorial. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conoce al menos los conceptos básicos de Unity</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por ejemplo, cómo crear un prefabricado o script, y similares. </font><font style="vertical-align: inherit;">No esperes que te enseñe cómo crear hojas de sprites, hay muchos tutoriales geniales sobre esto. </font><font style="vertical-align: inherit;">No me centraré en estudiar el motor, sino en cómo implementar el juego que crearemos juntos. </font><font style="vertical-align: inherit;">Si tiene dificultades, diríjase a una de las increíbles comunidades de Discord y solicite ayuda: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity Developer Community </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roguelikes</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Entonces, ¡comencemos!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 0 - planificación</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si eso es correcto. Lo primero que hay que crear es un plan. Será bueno para ti planificar el juego, y para mí, planificar el tutorial para que después de un tiempo no nos distraigamos del tema. Es fácil confundirse con las funciones del juego, al igual que en las mazmorras de roguelike. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escribiremos roguelike. Seguiremos principalmente los sabios consejos del desarrollador de Cogmind Josh Ge </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sigue el enlace, lee la publicación o mira el video, y luego regresa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cuál es el propósito de este tutorial? Obtenga un sólido roguelike básico simple, con el que luego puede experimentar. Debería tener generación de mazmorras, un jugador moviéndose en el mapa, niebla de visibilidad, enemigos y objetos. Solo lo más necesario. Entonces, el jugador debería poder bajar las escaleras varios pisos. digamos, por cinco, aumente su nivel, mejore y al final pelee con el jefe y derrótelo. O morir. Eso, de hecho, es todo.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Siguiendo los consejos de Josh Ge, construiremos las funciones del juego para que nos lleven a la meta. </font><font style="vertical-align: inherit;">Por lo tanto, obtenemos el marco roguelike, que puede ampliarse aún más, agregar sus propios chips, creando singularidad. </font><font style="vertical-align: inherit;">O arroje todo a la canasta, aproveche la experiencia adquirida y comience de cero. </font><font style="vertical-align: inherit;">Será genial de todos modos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No te daré ningún recurso gráfico. </font><font style="vertical-align: inherit;">Dibújelos usted mismo o use los mosaicos gratuitos, que se pueden descargar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o buscando en Google. </font><font style="vertical-align: inherit;">Solo no olvides mencionar a los autores de los gráficos en el juego. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora enumeremos todas las funciones que estarán en nuestro roguelike en el orden de su implementación:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generación de mapas de mazmorras</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El personaje del jugador y su movimiento.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Área de visibilidad</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enemigos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Busca un camino</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lucha, salud y muerte</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nivel de jugador arriba</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artículos (armas y pociones)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trucos de consola (para pruebas)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pisos de mazmorras</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guardar y cargar</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jefe final</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de implementar todo esto, tendremos un fuerte roguelike y aumentarás enormemente tus habilidades de desarrollo de juegos. </font><font style="vertical-align: inherit;">En realidad, era </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mi</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> forma de mejorar </font><em><font style="vertical-align: inherit;">mis</font></em><font style="vertical-align: inherit;"> habilidades: crear código e implementar funciones. </font><font style="vertical-align: inherit;">Por lo tanto, estoy seguro de que puede manejar esto también.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 1 - Clase MapManager</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es el primer script que crearemos y se convertirá en la columna vertebral de nuestro juego. </font><font style="vertical-align: inherit;">Es simple, pero contiene la mayor parte de la información importante para el juego. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, cree un script .cs llamado MapManager y ábralo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elimine ": MonoBehaviour" porque no heredará de él y no se adjuntará a ningún GameObject. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elimine las funciones Start () y Update (). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al final de la clase MapManager, cree una nueva clase pública llamada Tile.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/431/54e/4c2/43154e4c2708a580bc3838b1fbee573b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La clase Tile contendrá toda la información de un solo mosaico. </font><font style="vertical-align: inherit;">Hasta ahora, no necesitamos mucho, solo posiciones x e y, así como un objeto de juego ubicado en esta posición del mapa.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/405/21e/cd9/40521ecd9e1292e813391181e523b6dc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, tenemos información básica sobre mosaicos. </font><font style="vertical-align: inherit;">Creemos un mapa a partir de este mosaico. </font><font style="vertical-align: inherit;">Es simple, solo necesitamos una matriz bidimensional de objetos Tile. </font><font style="vertical-align: inherit;">Suena complicado, pero no tiene nada de especial. </font><font style="vertical-align: inherit;">Simplemente agregue la variable Tile [,] a la clase MapManager:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/2e8/806/f442e88061e77cbbb4c1aa904c73bdfd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voila! </font><font style="vertical-align: inherit;">Tenemos un mapa! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si, esta vacio. </font><font style="vertical-align: inherit;">Pero este es un mapa. </font><font style="vertical-align: inherit;">Cada vez que algo se mueve o cambia de estado en el mapa, la información en este mapa se actualizará. </font><font style="vertical-align: inherit;">Es decir, si, por ejemplo, un jugador intenta cambiar a una nueva casilla, la clase verificará la dirección de la casilla de destino en el mapa, la presencia del enemigo y su permeabilidad. </font><font style="vertical-align: inherit;">Gracias a esto, no tenemos que verificar miles de colisiones en cada turno, y no necesitamos colisionadores para cada objeto del juego, lo que facilitará y simplificará el trabajo con el juego. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El código resultante se ve así:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MapManager</span> <font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Tile[,] map; <span class="hljs-comment">// the 2-dimensional map with the information for all the tiles</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Tile</span> { <span class="hljs-comment">//Holds all the information for each tile on the map</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> xPosition; <span class="hljs-comment">// the position on the x axis</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> yPosition; <span class="hljs-comment">// the position on the y axis</span>
    <span class="hljs-keyword">public</span> GameObject baseObject; <span class="hljs-comment">// the map game object attached to that position: a floor, a wall, etc.</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La primera etapa se completa, pasemos a completar la tarjeta. </font><font style="vertical-align: inherit;">Ahora comenzaremos a crear un generador de mazmorras.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 2: un par de palabras sobre la estructura de datos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero antes de comenzar, permítanme compartir los consejos que han surgido gracias a los comentarios recibidos después de la publicación de la primera parte. Al crear una estructura de datos, debes pensar desde el principio cómo mantendrás el estado del juego. De lo contrario, más tarde será mucho más caótico. El usuario de Discord st33d, el desarrollador de Star Shaped Bagel (puedes jugar este juego gratis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), dijo que al principio creó el juego, pensando que no salvaría estados en absoluto. Poco a poco, el juego comenzó a hacerse más grande, y su fan le pidió apoyo para el mapa guardado. Pero debido al método elegido para crear la estructura de datos, fue muy difícil guardar los datos, por lo que no pudo hacerlo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82c/b02/858/82cb02858af686ef409ad8a6c0496135.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Realmente aprendemos de nuestros errores. A pesar de que puse la parte de guardar / cargar al final del tutorial, pienso en ellos desde el principio, y todavía no los he explicado. En esta parte hablaré un poco sobre ellos, pero para no sobrecargar a los desarrolladores inexpertos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Guardaremos cosas como una matriz de variables de la clase Tile en la que se almacena el mapa. Guardaremos todos estos datos, excepto las variables de la clase GameObject, que están dentro de la clase Tile. ¿Por qué? Solo porque GameObjects no se puede serializar con Unity a los datos almacenados.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, de hecho, no necesitamos guardar los datos almacenados dentro de GameObjects. Todos los datos se almacenarán en clases como Tile, y más tarde también Player, Enemy, etc. Luego tendremos GameObjects para simplificar el cálculo de cosas como la visibilidad y el movimiento, así como dibujar sprites en la pantalla. Por lo tanto, dentro de las clases habrá variables GameObject, pero el valor de estas variables no se guardará ni cargará. Al cargar, forzaremos a generar GameObject nuevamente a partir de los datos guardados (posición, sprite, etc.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, ¿qué necesitamos hacer ahora? Bueno, solo agregue dos líneas a la clase Tile existente y una a la parte superior del script. Primero agregamos "usando el sistema"; al título del script, y luego [Serializable] delante de toda la clase y [No serializado] justo delante de la variable GameObject. Me gusta esto:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfd/931/aa3/bfd931aa3a4a1b2b7792650cc25cba07.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2e/178/9d3/a2e1789d3663b1530d64d3d900c7f047.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Te contaré más sobre esto cuando lleguemos a la parte del tutorial sobre guardar / cargar. </font><font style="vertical-align: inherit;">Por ahora, dejemos todo y sigamos adelante.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 3: un poco más sobre la estructura de datos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obtuve otra revisión sobre la estructura de datos que quiero compartir aquí.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, hay muchas formas de implementar datos en un juego. El primero que utilizo y que se implementará en este tutorial: todos los datos del mosaico están en la clase Tile, y todos se almacenan en una matriz. Este enfoque tiene muchas ventajas: es más fácil de leer, todo lo que necesita está en un solo lugar, los datos son más fáciles de manipular y exportar a un archivo guardado. Pero desde el punto de vista de la memoria, no es tan efectivo. Tendrás que asignar mucha memoria para variables que nunca se usarán en el juego. Por ejemplo, más adelante colocaremos la variable Enemy GameObject en la clase Tile para que podamos apuntar directamente desde el mapa al GameObject del enemigo que está parado en este mosaico para simplificar todos los cálculos relacionados con la batalla. Pero esto significará que cada mosaico en el juego tendrá espacio asignado en la memoria para la variable GameObject,incluso si no hay enemigo en este azulejo. Si hay 10 enemigos en un mapa de 2500 fichas, habrá 2490 vacías, pero variables de GameObject asignadas: puede ver cuánta memoria se desperdicia.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un método alternativo sería usar estructuras para almacenar los datos básicos de los mosaicos (por ejemplo, posición y tipo), y todos los demás datos se almacenarían en hashmap-s, que se generarían solo si fuera necesario. </font><font style="vertical-align: inherit;">Esto ahorraría mucha memoria, pero la recuperación sería una implementación un poco más complicada. </font><font style="vertical-align: inherit;">En realidad, sería un poco más avanzado de lo que me gustaría en este tutorial, pero si lo desea, en el futuro puedo escribir una publicación más detallada al respecto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, si desea leer una discusión sobre este tema, puede hacerlo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en Reddit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 4 - Algoritmo de generación de mazmorras</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sí, esta es otra sección en la que hablaré y no comenzaremos a programar nada. Pero esto es importante, una planificación cuidadosa de los algoritmos nos ahorrará mucho tiempo de trabajo en el futuro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay varias formas de crear un generador de mazmorras. La que implementaremos juntos no es la mejor ni la más efectiva ... es solo una forma fácil e inicial. Es muy simple, pero los resultados serán bastante buenos. El principal problema serán muchos pasillos sin salida. Más tarde, si lo desea, puedo publicar otro tutorial sobre mejores algoritmos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, el algoritmo que utilizamos funciona de la siguiente manera: digamos que tenemos un mapa completo lleno de valores cero, un nivel que consiste en una piedra. </font><font style="vertical-align: inherit;">Al principio, cortamos una habitación en el centro. </font><font style="vertical-align: inherit;">Desde esta sala, atravesamos el corredor en una dirección, y luego agregamos otros pasillos y salas, siempre comenzando de manera aleatoria desde una sala o corredor existente, hasta que alcanzamos el número máximo de corredores / salas dados al principio. </font><font style="vertical-align: inherit;">O hasta que el algoritmo pueda encontrar un nuevo lugar para agregar una nueva habitación / corredor, lo que ocurra primero. </font><font style="vertical-align: inherit;">Y así tenemos un calabozo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, describamos esto de una manera más parecida a un algoritmo, paso a paso. </font><font style="vertical-align: inherit;">Por conveniencia, llamaré a cada detalle del mapa (corredor o habitación) un elemento para que no tenga que decir "habitación / corredor" cada vez.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cortar la habitación en el centro del mapa.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selecciona aleatoriamente uno de los muros</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atravesamos el corredor en este muro</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seleccione aleatoriamente uno de los elementos existentes.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seleccione aleatoriamente uno de los muros de este elemento.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el último elemento seleccionado es una habitación, generamos un corredor. </font><font style="vertical-align: inherit;">Si es el corredor, elija al azar si el siguiente elemento será una habitación u otro corredor</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compruebe si hay suficiente espacio en la dirección seleccionada para crear el elemento deseado.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si hay un lugar, cree un elemento, si no, regrese al paso 4</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repita desde el paso 4</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eso es todo. </font><font style="vertical-align: inherit;">Obtendremos un mapa simple de la mazmorra, en el que solo hay habitaciones y pasillos, sin puertas y elementos especiales, pero este será nuestro comienzo. </font><font style="vertical-align: inherit;">Más tarde lo llenaremos con cofres, enemigos y trampas. </font><font style="vertical-align: inherit;">E incluso puede personalizarlo: aprenderemos cómo agregar elementos interesantes que necesita.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 5 - corta la habitación</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Finalmente proceda a la codificación! </font><font style="vertical-align: inherit;">Cortemos nuestra primera habitación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, crea un nuevo script y llámalo DungeonGenerator. </font><font style="vertical-align: inherit;">Heredará de Monobehaviour, por lo que deberá adjuntarlo a GameObject más adelante. </font><font style="vertical-align: inherit;">Luego necesitaremos declarar varias variables públicas en la clase para que podamos establecer los parámetros de la mazmorra desde el inspector. </font><font style="vertical-align: inherit;">Estas variables serán el ancho y la altura del mapa, la altura mínima y máxima y el ancho de las habitaciones, la longitud máxima de los corredores y el número de elementos que deben estar en el mapa.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/120/331/04d/12033104d1f3fcf270fdc5fd64ffb6bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego necesitamos inicializar el generador de mazmorras. Hacemos esto para inicializar las variables que serán pobladas por la generación. Por ahora, esto será solo un mapa. Y, y también elimine las funciones Start () y Update () que Unity genera para el nuevo script, no las necesitaremos.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f92/a8f/e5d/f92a8fe5dc2ea241284fe95b8758c289.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad7/841/44b/ad784144b6aeea6aee3967caedaa37eb.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí inicializamos la variable de mapa de la clase MapManager (que creamos en el paso anterior), pasando el ancho y la altura del mapa, definidos por las variables anteriores como parámetros de las dos dimensiones de la matriz. Gracias a esto, tendremos un mapa de tamaño x horizontal (ancho) y tamaño y vertical (altura), y podemos acceder a cualquier celda del mapa ingresando MapManager.map [x, y]. Esto será muy útil al manipular la posición de los objetos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora crearemos una función para representar la primera sala. Lo llamaremos FirstRoom (). Hicimos InitializeDungeon () una función pública, ya que será lanzada por otro script (Game Manager, que pronto crearemos; centralizará la gestión de todo el proceso de lanzamiento del juego). No necesitamos ningún script externo para tener acceso a FirstRoom (), por lo que no lo hacemos público.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, para continuar, crearemos tres nuevas clases en el script de MapManager para que pueda crear una sala. Estas son las clases de entidad, muro y posición. La clase Posición contendrá las posiciones x e y para que podamos rastrear dónde está todo. El muro tendrá una lista de posiciones, la dirección en la que "se ve" en relación con el centro de la habitación (norte, sur, este u oeste), la longitud y la presencia de un nuevo elemento creado a partir de él. El elemento tendrá una lista de todas las posiciones que lo componen, el tipo de elemento (habitación o corredor), una matriz de variables de Muro y su ancho y alto.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b7/abe/924/3b7abe9241bb1442f3224048384263ff.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/938/8bc/8d7/9388bc8d7dd523b45013fa80d918d8a2.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora vamos a la función FirstRoom (). </font><font style="vertical-align: inherit;">Volvamos al script DungeonGenerator y creemos una función justo debajo de InitializeDungeon. </font><font style="vertical-align: inherit;">Ella no necesitará recibir ningún parámetro, por lo que lo dejaremos simple (). </font><font style="vertical-align: inherit;">A continuación, dentro de la función, primero debemos crear e inicializar la variable Room y su lista de variables de posición. </font><font style="vertical-align: inherit;">Lo hacemos así:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/164/b81/b5d/164b81b5dde06f8e996e22a75bf0b947.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora configuremos el tamaño de la habitación. </font><font style="vertical-align: inherit;">Recibirá un valor aleatorio entre la altura mínima y máxima y el ancho declarado al comienzo del script. </font><font style="vertical-align: inherit;">Mientras estén vacíos, porque no les hemos establecido un valor en el inspector, pero no se preocupe, lo haremos pronto. </font><font style="vertical-align: inherit;">Establecemos valores aleatorios como este:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d77/bbd/389/d77bbd3896dc4c60d93a9e6b1c006729.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuación, debemos declarar dónde se ubicará el punto de partida de la habitación, es decir, dónde se ubicará el punto de la habitación 0.0 en la cuadrícula del mapa. Queremos que comience en el centro del mapa (medio ancho y medio alto), pero tal vez no </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exactamente</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el centro. Puede valer la pena agregar un pequeño aleatorizador para que se mueva ligeramente hacia la izquierda y hacia abajo. Por lo tanto, establecemos xStartingPoint como la mitad del ancho del mapa, y yStartingPoint como la mitad de la altura del mapa, y luego tomamos el valor de roomWidth y roomHeight, obtenemos un valor aleatorio de 0 a este ancho / altura, y lo restamos de las x e y iniciales. Me gusta esto:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50f/3f2/f0e/50f3f2f0ecb267d5283dcd4684019708.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8eb/0e7/f2b/8eb0e7f2bff7d3d08b1b0691885e89cd.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuación, en la misma función agregaremos muros. Necesitamos inicializar la matriz de muros que se encuentran en la variable de habitación recién creada, y luego inicializar cada variable de pared dentro de esta matriz. Y luego inicialice cada lista de posiciones, establezca la longitud del muro en 0 e ingrese la dirección en la que cada muro "mirará". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de que se inicializa la matriz, recorremos cada elemento de la matriz en el bucle for (), inicializamos las variables de cada muro y luego usamos el interruptor, que nombra la dirección de cada muro. Se elige arbitrariamente, solo necesitamos recordar lo que significarán.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3a/f8f/9da/d3af8f9da1ee8f317452d52f9f905536.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora ejecutaremos dos bucles anidados para inmediatamente después de colocar las paredes. </font><font style="vertical-align: inherit;">En el bucle externo, rodeamos todos los valores de y en la sala, y en el bucle anidado, todos los valores de x. </font><font style="vertical-align: inherit;">De esta forma comprobaremos cada celda x en la fila y para que podamos implementarla.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ee/cb3/695/3eecb3695c59d199fb32064501ce1009.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, lo primero que debe hacer es encontrar el valor real de la posición de la celda en la escala del mapa desde la posición de la habitación. </font><font style="vertical-align: inherit;">Esto es bastante simple: tenemos los puntos de partida x e y. </font><font style="vertical-align: inherit;">Estarán en la posición 0,0 en la cuadrícula de la sala. </font><font style="vertical-align: inherit;">Entonces, si necesitamos obtener el valor real de x, y de cualquier x local, y, entonces sumamos el x e y local con las posiciones iniciales x e y. </font><font style="vertical-align: inherit;">Luego guardamos estos valores reales x, y en la variable Posición (de una clase creada previamente) y luego los agregamos a la Lista &lt;&gt; de las posiciones de la sala.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b2/cc4/4a0/0b2cc44a0ae9953a3d49ac0b3c01a6c9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente paso es agregar esta información al mapa. </font><font style="vertical-align: inherit;">Antes de cambiar los valores, recuerde inicializar la variable Tile.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1aa/fe5/a43/1aafe5a43a8c30f2c343472ad7f157ca.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora haremos un cambio en la clase Tile. </font><font style="vertical-align: inherit;">Vayamos al script de MapManager y agreguemos una línea a la definición de la clase Tile: "public string type;". </font><font style="vertical-align: inherit;">Esto nos permitirá agregar una clase de mosaico al declarar que el mosaico en x, y es una pared, piso u otra cosa. </font><font style="vertical-align: inherit;">Luego, volvamos al ciclo en el que hicimos el trabajo y agreguemos una gran construcción if-else, que nos permitirá no solo determinar cada muro, su longitud y todas las posiciones en este muro, sino también definir en el mapa global qué es un mosaico específico: un muro o género</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c3/276/28c/7c327628cea73dafe9319a01ac10b72b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y ya hemos hecho algo. Si la variable y (control de la variable en el bucle externo) es 0, entonces el mosaico pertenece a la fila más baja de celdas en la habitación, es decir, es la pared sur. Si x (control de la variable del bucle interno) es 0, entonces el mosaico pertenece a la columna de celdas más a la izquierda, es decir, es el muro occidental. Y si está en la línea superior, entonces pertenece al muro norte, y en el extremo derecho, el muro este. Restamos 1 de las variables roomWidth y roomHeight, porque estos valores se calcularon a partir de 1, y las variables x e y del ciclo comenzaron desde 0, por lo que esta diferencia debe tenerse en cuenta. Y todas las células que no cumplen con las condiciones no son paredes, es decir, son el piso.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/258/4a6/2c9/2584a62c91fc46205f903cb4283bd1ce.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Genial, casi hemos terminado con la primera habitación. </font><font style="vertical-align: inherit;">Está casi listo, solo necesitamos poner los últimos valores en la variable Característica que creamos. </font><font style="vertical-align: inherit;">Salimos del bucle y finalizamos la función así:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bd/aaf/a47/2bdaafa47adb2694f360eea850341920.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Multa! </font><font style="vertical-align: inherit;">Tenemos un cuarto! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero, ¿cómo entendemos que todo funciona? </font><font style="vertical-align: inherit;">Necesito probar. </font><font style="vertical-align: inherit;">¿Pero cómo hacer la prueba? </font><font style="vertical-align: inherit;">Podemos dedicar tiempo y agregar recursos para esto, pero será una pérdida de tiempo y también nos distraerá de completar el algoritmo. </font><font style="vertical-align: inherit;">Hmm, pero esto se puede hacer usando ASCII! </font><font style="vertical-align: inherit;">Si, buena idea! </font><font style="vertical-align: inherit;">ASCII es una forma simple y de bajo costo de dibujar un mapa para que pueda ser probado. </font><font style="vertical-align: inherit;">Además, si lo desea, puede omitir la parte con sprites y efectos visuales, que estudiaremos más adelante, y crear todo su juego en ASCII. </font><font style="vertical-align: inherit;">Así que veamos cómo se hace esto.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 6 - dibujando la primera habitación</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo primero que debe tener en cuenta al implementar una tarjeta ASCII es qué fuente elegir. El factor principal a considerar al elegir una fuente para ASCII es si es proporcional (ancho variable) o monoespaciado (ancho fijo). Necesitamos una fuente monoespaciada para que las tarjetas se vean según sea necesario (ver ejemplo a continuación). Por defecto, cualquier nuevo proyecto de Unity usa la fuente Arial, y no es monoespaciado, por lo que necesitamos encontrar otro. Windows 10 generalmente tiene fuentes monoespaciadas Courier New, Consolas y Lucida Console. Elija uno de estos tres o descargue cualquier otro en el lugar que necesita y colóquelo en la carpeta Fuentes dentro de la carpeta Activos del proyecto.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff4/beb/f23/ff4bebf23a4523f4dd348524ac6b0a9f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos a preparar la escena para la salida ASCII. Para empezar, haga que el color de fondo de la cámara principal de la escena sea negro. Luego agregamos el objeto Canvas a la escena y le agregamos el objeto Text. Establezca la transformación del rectángulo de texto en el centro y en la posición 0,0,0. Establezca el objeto Texto para que use la fuente que elija y el color blanco, el desbordamiento horizontal y vertical (desbordamiento horizontal / vertical), seleccione Desbordamiento y centre la alineación vertical y horizontal. Luego cambie el nombre del objeto de texto a "ASCIITest" o algo similar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora de vuelta al código. En el script DungeonGenerator, cree una nueva función llamada DrawMap. Queremos que obtenga un parámetro que indique qué tarjeta generar: ASCII o sprite, así que cree un parámetro booleano y llámelo isASCII.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/387/67a/957/38767a9575270115821d6be36ce97293.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego verificaremos si el mapa representado es ASCII. </font><font style="vertical-align: inherit;">En caso afirmativo (por ahora, consideraremos solo este caso), buscaremos un objeto de texto en la escena, le pasaremos el nombre dado como parámetro y obtendremos su componente Texto. </font><font style="vertical-align: inherit;">Pero primero, debemos decirle a Unity que queremos trabajar con la interfaz de usuario. </font><font style="vertical-align: inherit;">Agregue la línea usando UnityEngine.UI al encabezado del script:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17c/e18/c24/17ce18c24ec7c286b4390159dc98dab1.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Multa. </font><font style="vertical-align: inherit;">Ahora podemos obtener el componente de texto del objeto. </font><font style="vertical-align: inherit;">El mapa será una línea enorme, que se refleja en la pantalla como texto. </font><font style="vertical-align: inherit;">Por eso es tan fácil de configurar. </font><font style="vertical-align: inherit;">Así que creemos una cadena e inicialícela con el valor "".</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d2/7f2/92c/6d27f292c1f519a7b351d7b8d80a8f84.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Multa. Entonces, cada vez que se llama a DrawMap, necesitaremos informar si la tarjeta es un ASCII. Si esto es así (y siempre lo tendremos de esta manera, trabajaremos con otra cosa más adelante), entonces la función buscará en la jerarquía de la escena en busca de un objeto de juego llamado "ASCIITest". Si es así, recibirá su componente de Texto y lo guardará en la variable de pantalla, en la que luego podemos escribir fácilmente el mapa. Luego crea una cadena cuyo valor está inicialmente vacío. Completaremos esta línea con nuestro mapa marcado con símbolos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo general, damos la vuelta al mapa en un bucle, comenzando en 0 y llegando al final de su longitud. </font><font style="vertical-align: inherit;">Pero para llenar la línea, comenzamos con la primera línea de texto, es decir, la línea superior. </font><font style="vertical-align: inherit;">Por lo tanto, en el eje y, debemos movernos en un bucle en la dirección opuesta, yendo desde el final hasta el comienzo de la matriz. </font><font style="vertical-align: inherit;">Pero el eje x de la matriz va de izquierda a derecha, al igual que el texto, por lo que esto nos conviene.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/536/019/f47/536019f479ea1af260d551f342ed46aa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ciclo, verificamos cada celda del mapa para averiguar qué contiene. </font><font style="vertical-align: inherit;">Hasta ahora, solo hemos inicializado las celdas como un nuevo Tile (), que cortamos para la sala, por lo que todos los demás devolverán un error al intentar acceder. </font><font style="vertical-align: inherit;">Entonces, primero debemos verificar </font><font style="vertical-align: inherit;">si </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algo en esta celda, y lo hacemos al verificar que la celda sea nula. </font><font style="vertical-align: inherit;">Si no es nulo, entonces seguimos trabajando, pero si es nulo, entonces no hay nada dentro, por lo que podemos agregar espacio vacío al mapa.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f3/f56/5d9/3f3f565d9e9f7886c3baa600cd1ab99f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, para cada celda no vacía, verificamos su tipo y luego agregamos el símbolo correspondiente. </font><font style="vertical-align: inherit;">Queremos que las paredes se indiquen con el símbolo "#" y los pisos se indiquen con el ".". </font><font style="vertical-align: inherit;">Y aunque solo tenemos estos dos tipos. </font><font style="vertical-align: inherit;">Más tarde, cuando agreguemos el jugador, los monstruos y las trampas, todo será un poco más complicado.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9f/a24/ef0/f9fa24ef002860f5331479f9ac07a6e8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, debemos realizar saltos de línea al llegar al final de la fila de la matriz, de modo que las celdas con la misma posición x estén directamente una debajo de la otra. </font><font style="vertical-align: inherit;">Comprobaremos en cada iteración del ciclo si la celda es la última de la fila y luego agregaremos un salto de línea con el carácter especial "\ n".</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/7b8/1eb/c147b81eb1f4efa01bafdfa8a4aa092d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eso es todo. </font><font style="vertical-align: inherit;">Luego salimos del bucle para poder agregar esta línea después de la finalización al objeto de texto en la escena.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20f/8bb/f4d/20f8bbf4d1c8e5b59afc3163a97d57bb.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fcb/83f/a7f/fcb83fa7f923ec53e33696bb8962a1d9.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Felicidades! Ha completado la secuencia de comandos que crea la sala y la muestra en la pantalla. Ahora solo necesitamos poner estas líneas en acción. No usamos Start () en el script DungeonGenerator, porque queremos tener un script separado para controlar todo lo que se realiza al comienzo del juego, incluida la generación de mapas, pero también la configuración del jugador, los enemigos, etc. Por lo tanto, este otro script contendrá la función Start () y, si es necesario, llamará a las funciones de nuestro script. El script DungeonGenerator tiene una función Initialize, que es pública, y FirstRoom y DrawMap no son públicos. Initialize simplemente inicializa las variables para configurar el proceso de generación de mazmorras, por lo que necesitamos otra función que llame al proceso de generación, que debe ser público para que pueda llamarse desde otros scripts.Por ahora, solo llamará a la función FirstRoom (), y luego a la función DrawMap (), pasándole un valor verdadero para que dibuje un mapa ASCII. Ah, o no, es aún mejor: creemos una variable pública isASCII, que se puede incluir en el inspector, y simplemente pase esta variable como parámetro a la función. Multa.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c58/288/502/c58288502f107440def4f803d602662b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, ahora creemos un script GameManager. </font><font style="vertical-align: inherit;">Será el mismo script que controla todos los elementos de alto nivel del juego, por ejemplo, creando un mapa y el curso de los movimientos. </font><font style="vertical-align: inherit;">Eliminemos la función Update (), agreguemos una variable del tipo DungeonGenerator llamada dungeonGenerator y creemos una instancia de esta variable en la función Start ().</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5b/8da/424/e5b8da4243c91f887c08213b9ec14953.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de eso, simplemente llamamos a las funciones InitializeDungeon () y GenerateDungeon () desde dungeonGenerator, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en ese orden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esto es importante: primero debe inicializar las variables y solo después de eso comenzar a construir sobre la base de ellas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/158/7e6/781/1587e6781595d0ee6661aea7898aa6e4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esta parte con el código se completa. </font><font style="vertical-align: inherit;">Necesitamos crear un objeto de juego vacío en el panel de jerarquía, cambiarle el nombre a GameManager y adjuntarle los scripts GameManager y DungeonGenerator. </font><font style="vertical-align: inherit;">Y luego establezca los valores del generador de mazmorras en el inspector. </font><font style="vertical-align: inherit;">Puede probar diferentes esquemas para el generador, y me decidí por esto:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a11/41f/495/a1141f4953a6fdeac32cc978ac4a0b05.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Ahora solo haz clic en jugar y mira la magia! </font><font style="vertical-align: inherit;">Deberías ver algo similar en la pantalla del juego:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad4/093/6ab/ad40936ab0dff25fd3214571faf9aa61.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Felicidades, ahora tenemos una habitación! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quería que pusiéramos al personaje del jugador allí y lo hiciéramos mover, pero la publicación ya era bastante larga. </font><font style="vertical-align: inherit;">Por lo tanto, en la siguiente parte, podemos proceder directamente a la implementación del resto del algoritmo de mazmorra, o podemos colocar al jugador en él y enseñarle cómo moverse. </font><font style="vertical-align: inherit;">Vota lo que más te guste en los comentarios al artículo original. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MapManager.cs:</font></font></b><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System; <span class="hljs-comment">// So the script can use the serialization commands</span>
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MapManager</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Tile[,] map; <span class="hljs-comment">// the 2-dimensional map with the information for all the tiles</span><font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">Serializable</span>] <span class="hljs-comment">// Makes the class serializable so it can be saved out to a file</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Tile</span> { <span class="hljs-comment">// Holds all the information for each tile on the map</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> xPosition; <span class="hljs-comment">// the position on the x axis</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> yPosition; <span class="hljs-comment">// the position on the y axis</span>
    [<span class="hljs-meta">NonSerialized</span>]
    <span class="hljs-keyword">public</span> GameObject baseObject; <span class="hljs-comment">// the map game object attached to that position: a floor, a wall, etc.</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> type; <span class="hljs-comment">// The type of the tile, if it is wall, floor, etc</span><font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">Serializable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Position</span> { <span class="hljs-comment">//A class that saves the position of any cell</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> x;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> y;<font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">Serializable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Wall</span> { <span class="hljs-comment">// A class for saving the wall information, for the dungeon generation algorithm</span>
    <span class="hljs-keyword">public</span> List&lt;Position&gt; positions;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> direction;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> length;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> hasFeature = <span class="hljs-literal">false</span>;<font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">Serializable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Feature</span> { <span class="hljs-comment">// A class for saving the feature (corridor or room) information, for the dungeon generation algorithm</span>
    <span class="hljs-keyword">public</span> List&lt;Position&gt; positions;
    <span class="hljs-keyword">public</span> Wall[] walls;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> type;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> width;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DungeonGenerator.cs:</font></font></b><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.UI;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DungeonGenerator</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapWidth;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapHeight;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMaxRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMaxRoom;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxFeatures;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isASCII;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        MapManager.map = <span class="hljs-keyword">new</span> Tile[mapWidth, mapHeight];<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GenerateDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        FirstRoom();<font></font>
        DrawMap(isASCII);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FirstRoom</span>(<span class="hljs-params"></span>)</span> {<font></font>
        Feature room = <span class="hljs-keyword">new</span> Feature();<font></font>
        room.positions = <span class="hljs-keyword">new</span> List&lt;Position&gt;();<font></font>
<font></font>
        <span class="hljs-keyword">int</span> roomWidth = Random.Range(widthMinRoom, widthMaxRoom);
        <span class="hljs-keyword">int</span> roomHeight = Random.Range(heightMinRoom, heightMaxRoom);<font></font>
<font></font>
        <span class="hljs-keyword">int</span> xStartingPoint = mapWidth / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">int</span> yStartingPoint = mapHeight / <span class="hljs-number">2</span>;<font></font>
<font></font>
        xStartingPoint -= Random.Range(<span class="hljs-number">0</span>, roomWidth);<font></font>
        yStartingPoint -= Random.Range(<span class="hljs-number">0</span>, roomHeight);<font></font>
<font></font>
        room.walls = <span class="hljs-keyword">new</span> Wall[<span class="hljs-number">4</span>];<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; room.walls.Length; i++) {<font></font>
            room.walls[i] = <span class="hljs-keyword">new</span> Wall();<font></font>
            room.walls[i].positions = <span class="hljs-keyword">new</span> List&lt;Position&gt;();<font></font>
            room.walls[i].length = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">switch</span> (i) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"South"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"North"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"West"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"East"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; roomHeight; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; roomWidth; x++) {<font></font>
                Position position = <span class="hljs-keyword">new</span> Position();<font></font>
                position.x = xStartingPoint + x;<font></font>
                position.y = yStartingPoint + y;<font></font>
<font></font>
                room.positions.Add(position);<font></font>
<font></font>
                MapManager.map[position.x, position.y] = <span class="hljs-keyword">new</span> Tile();<font></font>
                MapManager.map[position.x, position.y].xPosition = position.x;<font></font>
                MapManager.map[position.x, position.y].yPosition = position.y;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">0</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">0</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y == (roomHeight - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">1</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">1</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">2</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">2</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == (roomWidth - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">3</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">3</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Floor"</span>;<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
<font></font>
        room.width = roomWidth;<font></font>
        room.height = roomHeight;<font></font>
        room.type = <span class="hljs-string">"Room"</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawMap</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> isASCII</span>)</span> {
        <span class="hljs-keyword">if</span> (isASCII) {<font></font>
            Text screen = GameObject.Find(<span class="hljs-string">"ASCIITest"</span>).GetComponent&lt;Text&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">string</span> asciiMap = <span class="hljs-string">""</span>;<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = (mapHeight - <span class="hljs-number">1</span>); y &gt;= <span class="hljs-number">0</span>; y--) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; mapWidth; x++) {
                    <span class="hljs-keyword">if</span> (MapManager.map[x,y] != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">switch</span> (MapManager.map[x, y].type) {
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Wall"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"#"</span>;
                                <span class="hljs-keyword">break</span>;
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Floor"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"."</span>;
                                <span class="hljs-keyword">break</span>;<font></font>
                        }<font></font>
                    } <span class="hljs-keyword">else</span> {<font></font>
                        asciiMap += <span class="hljs-string">" "</span>;<font></font>
                    }<font></font>
<font></font>
                    <span class="hljs-keyword">if</span> (x == (mapWidth - <span class="hljs-number">1</span>)) {<font></font>
                        asciiMap += <span class="hljs-string">"\n"</span>;<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
<font></font>
            screen.text = asciiMap;<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameManager.cs:</font></font></b><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameManager</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
    DungeonGenerator dungeonGenerator;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> {<font></font>
        dungeonGenerator = GetComponent&lt;DungeonGenerator&gt;();<font></font>
<font></font>
        dungeonGenerator.InitializeDungeon();<font></font>
        dungeonGenerator.GenerateDungeon();<font></font>
    }<font></font>
}</code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es490812/index.html">Spring Professional Certification 5 Experiencia de envío</a></li>
<li><a href="../es490816/index.html">¿Cómo resisten los sitios de comercio electrónico a las botnets AuthBots?</a></li>
<li><a href="../es490820/index.html">Todo Habr en una base</a></li>
<li><a href="../es490822/index.html">Los mejores materiales para hackear autos con DEF CON 2019-2020</a></li>
<li><a href="../es490826/index.html">La fuente de eficiencia de producción.</a></li>
<li><a href="../es490830/index.html">Gestión de contraseñas en Zimbra Collaboration Suite Edición de código abierto</a></li>
<li><a href="../es490832/index.html">Marcado de calzado: a medida que ponemos en circulación 2 millones de códigos de marcado "1C" + "Signo honesto"</a></li>
<li><a href="../es490836/index.html">Cómo abrir comentarios y no ahogarse en spam</a></li>
<li><a href="../es490838/index.html">WiFi 6 está aquí: lo que ofrece el mercado y por qué necesitamos esta tecnología</a></li>
<li><a href="../es490840/index.html">Planeación de recursos. Parte 4.1. Antes de hacer un plan de recursos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>