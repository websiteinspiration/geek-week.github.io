<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗂️ 🕵️ 🐛 三次元の世界でのモスクワのメトロの様子 👴🏿 👨🏿 👨🏾‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="UPD：コメントのリクエストで、JavaScriptにvraschabelnuyuスキームへのリンクを追加します。
 残念ながら、投稿の本文に挿入するJavaScriptコードは
 Hello！に失敗しました。最近、理想的なメトロスキームがどうあるべきかについて議論していたアーバニストのブログを読み...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>三次元の世界でのモスクワのメトロの様子</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470602/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD：コメントのリクエストで、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にvraschabelnuyuスキームへのリンクを追加します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、投稿の本文に挿入するJavaScriptコードは</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hello！に</font><font style="vertical-align: inherit;">失敗しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最近、理想的なメトロスキームがどうあるべきかについて議論していたアーバニストのブログを読みました。メトロスキームは、2つの原則に基づいて描くことができます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回路は、便利で覚えやすく、方向付けが容易でなければなりません。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スキームは都市の地理に対応する必要があります</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、これらの原則は相互に排他的であり、最初の原則は地理的現実の大幅な歪みを必要とします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モスクワの地下鉄スキームが美しいリングと直線でどのように見えるかを思い出すには十分です：</font></font><br>
<a name="habracut"></a><br>
<img src="http://news.metro.ru/19/mm20190620s.jpg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
地理的に正確な計画と比較し</font></font><br>
<br>
<img src="https://kartymetro.ru/wp-content/uploads/2018/07/karta_metro_moskvy_2020-1024x950.jpeg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この計画は、リングが完全に均一で同心円状ではなく、線がスキームよりもはるかに曲がっていること、および市内中心部の駅の密度が非常に高いため、計画を理解することがほとんど不可能であることを示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の画像は現実をより正確に反映していますが、メトロのルートを計画するために最初のスキームを使用する方が便利であることがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、次のような考えが浮かびました。「回路を構築するための基準が、ある駅から別の駅に移動するのに必要な時間である場合、メトロはどのように見えるでしょうか？」つまり、あるステーションから別のステーションにすばやく移動できる場合、空間的にはダイアグラムの近くに配置されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、2次元空間では、メトログラフのトポロジが複雑なため、2つのステーション間の距離が一方から他方への移動時間に等しくなるようなスキームを描くことは不可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、高次元の空間でスキームを構築するときに正確に可能であるという考えもあります（上限の見積もりはn-1で、nはステーションの数です）。次元の数が少ないスペースの場合、そのようなスキームはおおよそのみ構築できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
移動時間によってメトロマップを作成するタスクは、一般的な最適化タスクのように見えます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての測点の座標の初期セット（X、Y、Z）とペアワイズ時間のターゲット行列（距離）があるとします。特定の座標セットの「不正確さ」メトリックを構築し、各測点の各座標の勾配降下法によってそれを最小化することが可能です。メトリックとして、距離の標準偏差の単純な関数をとることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、残っているのは、モスクワの地下鉄の駅から他の駅までの移動に費やすべき時間に関するデータを取得することだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に考えたのは、Yandex Metro APIをチェックして、このデータをそこから取得することでした。残念ながら、APIの説明が見つかりませんでした。アプリケーションで長時間手動で時間を監視します（メトロには268の駅があり、時間行列のサイズは268 * 268 = 71824です）。そのため、Yandex Metroのソースデータを理解することにしました。サーバーへのアクセスがないため、アプリケーションを含むapkファイルがダウンロードされ、必要なデータが見つかりました。 Metroに関するすべての情報は非常に構造化されており、JSON形式でアプリケーションのassets / metrokit / apkアーカイブフォルダーに保存されています。すべてのデータは自己説明型の構造で保存されます。 Meta.jsonには、スキームがアプリケーションに存在する都市に関する情報と、これらのスキームのIDが含まれています。</font></font><br>
<br>
<pre><code class="json hljs">{
            <span class="hljs-attr">"id"</span>: <span class="hljs-string">"sc77792237"</span>, 
            <span class="hljs-attr">"name"</span>: {
                <span class="hljs-attr">"en"</span>: <span class="hljs-string">"Nizhny Novgorod"</span>, 
                <span class="hljs-attr">"ru"</span>: <span class="hljs-string">" "</span>, 
                <span class="hljs-attr">"tr"</span>: <span class="hljs-string">"Nizhny Novgorod"</span>, 
                <span class="hljs-attr">"uk"</span>: <span class="hljs-string">"і "</span><font></font>
            }, <font></font>
            <span class="hljs-attr">"size"</span>: {
                <span class="hljs-attr">"packed"</span>: <span class="hljs-number">30300</span>, 
                <span class="hljs-attr">"unpacked"</span>: <span class="hljs-number">145408</span><font></font>
            }, <font></font>
            <span class="hljs-attr">"tags"</span>: [
                <span class="hljs-string">"published"</span><font></font>
            ], <font></font>
            <span class="hljs-attr">"aliases"</span>: [
                <span class="hljs-string">"nizhny-novgorod"</span><font></font>
            ], <font></font>
            <span class="hljs-attr">"logoUrl"</span>: <span class="hljs-string">"https://avatars.mds.yandex.net/get-bunker/135516/f2f0e33d8def90c56c189cfb57a8e6403b5a441c/orig"</span>, 
            <span class="hljs-attr">"version"</span>: <span class="hljs-string">"2c27fe1"</span>, 
            <span class="hljs-attr">"geoRegion"</span>: {
                <span class="hljs-attr">"delta"</span>: {
                    <span class="hljs-attr">"lat"</span>: <span class="hljs-number">0.168291</span>, 
                    <span class="hljs-attr">"lon"</span>: <span class="hljs-number">0.219727</span><font></font>
                }, <font></font>
                <span class="hljs-attr">"center"</span>: {
                    <span class="hljs-attr">"lat"</span>: <span class="hljs-number">56.326635</span>, 
                    <span class="hljs-attr">"lon"</span>: <span class="hljs-number">43.992153</span><font></font>
                }<font></font>
            }, <font></font>
            <span class="hljs-attr">"countryCode"</span>: <span class="hljs-string">"RU"</span>, 
            <span class="hljs-attr">"defaultAlias"</span>: <span class="hljs-string">"nizhny-novgorod"</span><font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スキームのIDによって、モスクワに関連するJSONを含むフォルダーが見つかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
data.jsonファイルには、グラフのノードの名前、ノードID、ノードの地理座標、駅間の遷移に関する情報（id、遷移時間、遷移のタイプ-運転中か徒歩か、路上かどうか、時間）など、メトログラフに関する基本情報が含まれています秒）と駅の出入り口に関する多くの追加情報に関心があります。</font><font style="vertical-align: inherit;">これは理解するのに十分簡単です。</font><font style="vertical-align: inherit;">回路を構築するためのコードを書き始めましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要なライブラリをインポートします。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np 
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> codecs
<span class="hljs-keyword">import</span> networkx <span class="hljs-keyword">as</span> nx
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd 
<span class="hljs-keyword">import</span> itertools
<span class="hljs-keyword">import</span> keras
<span class="hljs-keyword">import</span> keras.backend <span class="hljs-keyword">as</span> K
<span class="hljs-keyword">from</span> mpl_toolkits.mplot3d <span class="hljs-keyword">import</span> Axes3D
<span class="hljs-keyword">from</span> mpl_toolkits.mplot3d.proj3d <span class="hljs-keyword">import</span> proj_transform
<span class="hljs-keyword">from</span> matplotlib.text <span class="hljs-keyword">import</span> Annotation
<span class="hljs-keyword">import</span> pickle
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python辞書とリストの構造は、json形式の構造と完全に一致しているため、metro情報を読み取り、jsonオブジェクトに対応するオブジェクトを作成します。</font></font><br>
<br>
<pre><code class="python hljs">names = json.loads(codecs.open( <span class="hljs-string">"l10n.json"</span>, <span class="hljs-string">"r"</span>, <span class="hljs-string">"utf_8_sig"</span> ).read() )<font></font>
graph = json.loads(codecs.open( <span class="hljs-string">"data.json"</span>, <span class="hljs-string">"r"</span>, <span class="hljs-string">"utf_8_sig"</span> ).read() )
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラフのノードとステーションに一致するディクショナリーを作成します（ステーションはグラフのノードではなく名前に割り当てられているため、これが必要です）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、念のため、地理的マップを構築する可能性のためにノードの座標を保存します（範囲0-1に正規化）</font></font><br>
<br>
<pre><code class="python hljs">nodeStdict={}
<span class="hljs-keyword">for</span> stop <span class="hljs-keyword">in</span> graph[<span class="hljs-string">'stops'</span>][<span class="hljs-string">'items'</span>]:<font></font>
    nodeStdict[stop[<span class="hljs-string">'nodeId'</span>]]=stop[<span class="hljs-string">'stationId'</span>]<font></font>
coordDict={}<font></font>
<span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph[<span class="hljs-string">'nodes'</span>][<span class="hljs-string">'items'</span>]:<font></font>
    coordDict[node[<span class="hljs-string">'id'</span>]]=(node[<span class="hljs-string">'attributes'</span>][<span class="hljs-string">'geoPoint'</span>][<span class="hljs-string">'lon'</span>],node[<span class="hljs-string">'attributes'</span>][<span class="hljs-string">'geoPoint'</span>][<span class="hljs-string">'lat'</span>])<font></font>
lats=[]<font></font>
longs=[]<font></font>
<span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> coordDict.values():<font></font>
    lats.append(value[<span class="hljs-number">1</span>])<font></font>
    longs.append(value[<span class="hljs-number">0</span>])
<span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> coordDict.items():<font></font>
    coordDict[k]=((v[<span class="hljs-number">0</span>]-np.min(longs))/(np.max(longs)-np.min(longs)),(v[<span class="hljs-number">1</span>]-np.min(lats))/(np.max(lats)-np.min(lats)))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接続を持つメトログラフを作成します。</font><font style="vertical-align: inherit;">各接続の重みを設定します。</font><font style="vertical-align: inherit;">重量は移動時間に対応します。</font><font style="vertical-align: inherit;">ステーションではないノードを削除します（私の意見では、これらはメトロからの出口であり、時間を計算するときにYandexカードにそれらへの接続が必要ですが、正確に理解していませんでした）、ノードID辞書、ロシア語での実際の名前を作成します</font></font><br>
<br>
<pre><code class="python hljs">G=nx.Graph()
<span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph[<span class="hljs-string">'nodes'</span>][<span class="hljs-string">'items'</span>]:<font></font>
    G.add_node(node[<span class="hljs-string">'id'</span>])
<span class="hljs-comment">#graph['links']</span>
<span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> graph[<span class="hljs-string">'links'</span>][<span class="hljs-string">'items'</span>]:
    <span class="hljs-comment">#G.add_edges_from([(link['fromNodeId'],link['toNodeId'])])</span>
    G.add_edge(link[<span class="hljs-string">'fromNodeId'</span>], link[<span class="hljs-string">'toNodeId'</span>], length=link[<span class="hljs-string">'attributes'</span>][<span class="hljs-string">'time'</span>])<font></font>
nodestoremove=[]<font></font>
<span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> G.nodes():
    <span class="hljs-keyword">if</span> len(G.edges(node))&lt;<span class="hljs-number">2</span>:<font></font>
        nodestoremove.append(node)<font></font>
<span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> nodestoremove:<font></font>
    G.remove_node(node)<font></font>
labels={}<font></font>
<span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> G.nodes():
    <span class="hljs-keyword">try</span>:<font></font>
        labels[node]=names[<span class="hljs-string">'keysets'</span>][<span class="hljs-string">'generated'</span>][nodeStdict[node]+<span class="hljs-string">'-name'</span>][<span class="hljs-string">'ru'</span>]
    <span class="hljs-keyword">except</span>: labels[node]=<span class="hljs-string">'error'</span>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ノードがどのブランチ（どのブランチID）に属するかを定義します（これは、図のメトロラインに色を付けるために後で必要になります）</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getlines</span>(<span class="hljs-params">graph, G</span>):</span><font></font>
    nodetoline={}<font></font>
    id_from={}<font></font>
    id_to={}<font></font>
    <span class="hljs-keyword">for</span> lk <span class="hljs-keyword">in</span> graph[<span class="hljs-string">'tracks'</span>][<span class="hljs-string">'items'</span>]:<font></font>
        id_from[lk[<span class="hljs-string">'id'</span>]]=lk[<span class="hljs-string">'fromNodeId'</span>]<font></font>
        id_to[lk[<span class="hljs-string">'id'</span>]]=lk[<span class="hljs-string">'toNodeId'</span>]
    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> graph[<span class="hljs-string">'linesToTracks'</span>][<span class="hljs-string">'items'</span>]:
        <span class="hljs-keyword">if</span> line[<span class="hljs-string">'trackId'</span>] <span class="hljs-keyword">in</span> id_from.keys():<font></font>
            nodetoline[id_from[line[<span class="hljs-string">'trackId'</span>]]]=line[<span class="hljs-string">'lineId'</span>]<font></font>
            nodetoline[id_to[line[<span class="hljs-string">'trackId'</span>]]]=line[<span class="hljs-string">'lineId'</span>]
    <span class="hljs-keyword">return</span> nodetoline<font></font>
lines=getlines(graph,G)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
networkxライブラリでは、nx.shortest_path_length（G、id1、id2、weight = 'length'）関数を使用して、あるノードから別のノードへの最短パス長を見つけることができるため、データの準備が完了したと想定できます。次に行うことは、測点の座標を最適化するモデルを準備することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うために、入力、出力に何が与えられ、測点座標行列を最適化する方法を理解します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての座標（3x268）の行列があるとします。次元268のワンホットベクトル（nの代わりに1つの単位座標を除くすべての場所にあるベクトル）にこの座標行列を乗算すると、測点nに対応する3つの座標が得られます。ワンホットベクトルのペアを取得して、必要な行列を掛けると、2つのトリプルの座標が得られます。座標のペアから、ステーション間のユークリッド距離を計算できます。したがって、モデルのアーキテクチャを決定でき</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ik/sx/aw/iksxawvycguvch8k9apg7bbm6wi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。入力にいくつかの測点を与え、出力での測点間の距離を取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルのトレーニングのデータ形式を決定したら、グラフの距離検索を使用してデータを準備します。</font></font><br>
<br>
<pre><code class="python hljs">myIDs=list(G.nodes())<font></font>
listofinputs1=[]<font></font>
listofinputs2=[]<font></font>
listofoutputs=[]<font></font>
<span class="hljs-keyword">for</span> pair <span class="hljs-keyword">in</span> itertools.product(G.nodes(), repeat=<span class="hljs-number">2</span>):<font></font>
    vec1=np.zeros((len(myIDs)))<font></font>
    vec2=np.zeros((len(myIDs)))<font></font>
    vec1[myIDs.index(pair[<span class="hljs-number">0</span>])]=<span class="hljs-number">1</span>
    vec2[myIDs.index(pair[<span class="hljs-number">1</span>])]=<span class="hljs-number">1</span><font></font>
    listofinputs1.append(vec1)<font></font>
    listofinputs2.append(vec2)<font></font>
    <span class="hljs-comment">#listofinputs.append([vec1,vec2])</span>
    listofoutputs.append(nx.shortest_path_length(G, pair[<span class="hljs-number">0</span>], pair[<span class="hljs-number">1</span>], weight=<span class="hljs-string">'length'</span>)/<span class="hljs-number">3600</span>)
    <span class="hljs-comment">#myDistMatrix[myIDs.index(pair[0]),myIDs.index(pair[1])]=nx.shortest_path_length(G, pair[0], pair[1], weight='length')</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
勾配降下法を使用して、測点座標の行列を最適化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機械学習にkerasフレームワークを使用すると、次のようになります。</font></font><br>
<br>
<pre><code class="python hljs">np.random.seed(<span class="hljs-number">0</span>)<font></font>
initweightmatrix=np.zeros((len(myIDs),<span class="hljs-number">3</span>))
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(myIDs)):<font></font>
    initweightmatrix[i,:<span class="hljs-number">2</span>]=coordDict[myIDs[i]]<font></font>
    initweightmatrix[i,<span class="hljs-number">2</span>]=np.random.randn()*<span class="hljs-number">0.001</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">euclidean_distance</span>(<span class="hljs-params">vects</span>):</span><font></font>
    x, y = vects<font></font>
    sum_square = K.sum(K.square(x - y), axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-literal">True</span>)
    <span class="hljs-keyword">return</span> K.sqrt(K.maximum(sum_square, K.epsilon()))
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eucl_dist_output_shape</span>(<span class="hljs-params">shapes</span>):</span><font></font>
    shape1, shape2 = shapes<font></font>
    <span class="hljs-keyword">return</span> (shape1[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>)<font></font>
<font></font>
inp1=keras.layers.Input((len(myIDs),))<font></font>
inp2=keras.layers.Input((len(myIDs),))<font></font>
layer1=keras.layers.Dense(<span class="hljs-number">3</span>,use_bias=<span class="hljs-literal">None</span>, activation=<span class="hljs-literal">None</span>)<font></font>
x1=layer1(inp1)<font></font>
x2=layer1(inp2)<font></font>
x=keras.layers.Lambda(euclidean_distance,<font></font>
                  output_shape=eucl_dist_output_shape)([x1, x2])<font></font>
out=keras.layers.Dense(<span class="hljs-number">1</span>,use_bias=<span class="hljs-literal">None</span>,activation=<span class="hljs-literal">None</span>)(x)<font></font>
model=keras.Model(inputs=[inp1,inp2],outputs=out)<font></font>
model.layers[<span class="hljs-number">2</span>].set_weights([initweightmatrix])<font></font>
model.layers[<span class="hljs-number">2</span>].trainable=<span class="hljs-literal">False</span>
model.compile(optimizer=keras.optimizers.Adam(lr=<span class="hljs-number">0.01</span>), loss=<span class="hljs-string">'mse'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
layer1の初期座標として実際の地理座標を使用していることに注意してください。これは、標準偏差関数の極小値に入らないようにするために必要です。</font><font style="vertical-align: inherit;">3番目の座標を非ゼロに初期化して非ゼロの勾配を取得します（最初にマップが完全に平坦である場合、測点の上下のシフトは同じになるため、勾配は0であり、zは最適化されません）。</font><font style="vertical-align: inherit;">モデルの最後の要素（密（1））は、タイムラインに合うようにスキームのスケーリングに影響します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
距離の次数は約1時間であるため、秒ではなく時間で距離を測定します。モデルをより効果的にトレーニングするには、すべての値（入力データ、重み、ターゲット）がほぼ同じ大きさであることが重要です。これらの値が1に近い場合は、最適化に標準のステップ値（0.001-0.01）を使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
行model.layers [2] .trainable = Falseはステーションの座標を固定し、最初の段階で1つのパラメーターが変化します-スケール。スキームのスケールを選択した後、座標のフリーズを解除し、すでにそれらを最適化します。</font></font><br>
<br>
<pre><code class="python hljs">hist=model.fit([listofinputs1,listofinputs2],listofoutputs,batch_size=<span class="hljs-number">71824</span>,epochs=<span class="hljs-number">200</span>)<font></font>
model.layers[<span class="hljs-number">2</span>].trainable=<span class="hljs-literal">True</span>
model.layers[<span class="hljs-number">-1</span>].trainable=<span class="hljs-literal">False</span>
model.compile(optimizer=keras.optimizers.Adam(lr=<span class="hljs-number">0.01</span>), loss=<span class="hljs-string">'mse'</span>)<font></font>
hist2=model.fit([listofinputs1,listofinputs2],listofoutputs,batch_size=<span class="hljs-number">71824</span>,epochs=<span class="hljs-number">200</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 すべての測点のペアに一度に、出口ですべての距離をフィードし、最適化は完全なバッチ勾配降下（すべてのデータで1ステップ）であることがわかります。この場合の損失関数は標準偏差であり、トレーニングの最後で0.015であったことがわかります。これは、どのステーションペアでも標準偏差が1分未満であることを意味します。つまり、結果のスキームでは、あるステーションから別のステーションへの移動に必要な距離を、ステーション間の直線距離から+ -1分の精度で正確に知ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、回路がどのように見えるか見てみましょう！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステーションの座標を取得し、ラインの色分けを行い、署名付きの3D画像を作成します（署名の美しい表示のコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここから</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取得さ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">れます</font></a><font style="vertical-align: inherit;">）：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Annotation3D</span>(<span class="hljs-params">Annotation</span>):</span>
    <span class="hljs-string">'''Annotate the point xyz with text s'''</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, s, xyz, *args, **kwargs</span>):</span>
        Annotation.__init__(self,s, xy=(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), *args, **kwargs)<font></font>
        self._verts3d = xyz        <font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw</span>(<span class="hljs-params">self, renderer</span>):</span><font></font>
        xs3d, ys3d, zs3d = self._verts3d<font></font>
        xs, ys, zs = proj_transform(xs3d, ys3d, zs3d, renderer.M)<font></font>
        self.xy=(xs,ys)<font></font>
        Annotation.draw(self, renderer)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">annotate3D</span>(<span class="hljs-params">ax, s, *args, **kwargs</span>):</span>
    <span class="hljs-string">'''add anotation text s to to Axes3d ax'''</span><font></font>
<font></font>
    tag = Annotation3D(s, *args, **kwargs)<font></font>
    ax.add_artist(tag)<font></font>
<font></font>
fincoords=model.layers[<span class="hljs-number">2</span>].get_weights()<font></font>
ccode={}<font></font>
<span class="hljs-keyword">for</span> obj <span class="hljs-keyword">in</span> graph[<span class="hljs-string">'services'</span>][<span class="hljs-string">'items'</span>]:<font></font>
    ccode[obj[<span class="hljs-string">'id'</span>]]=(<span class="hljs-string">'\#'</span>+obj[<span class="hljs-string">'attributes'</span>][<span class="hljs-string">'color'</span>])[<span class="hljs-number">1</span>:]<font></font>
<font></font>
xn = fincoords[<span class="hljs-number">0</span>][:,<span class="hljs-number">0</span>]<font></font>
yn = fincoords[<span class="hljs-number">0</span>][:,<span class="hljs-number">1</span>]<font></font>
zn = fincoords[<span class="hljs-number">0</span>][:,<span class="hljs-number">2</span>]<font></font>
l=[labels[idi] <span class="hljs-keyword">for</span> idi <span class="hljs-keyword">in</span> myIDs]<font></font>
colors=[ccode[lines[idi]] <span class="hljs-keyword">for</span> idi <span class="hljs-keyword">in</span> myIDs]<font></font>
xyzn = zip(xn, yn, zn)<font></font>
<font></font>
fig = plt.figure()<font></font>
ax = fig.gca(projection=<span class="hljs-string">'3d'</span>)<font></font>
ax.scatter(xn,yn,zn, c=colors, marker=<span class="hljs-string">'o'</span>)
<span class="hljs-keyword">for</span> j, xyz_ <span class="hljs-keyword">in</span> enumerate(xyzn): <font></font>
    annotate3D(ax, s=labels[myIDs[j]], xyz=xyz_, fontsize=<span class="hljs-number">9</span>, xytext=(<span class="hljs-number">-3</span>,<span class="hljs-number">3</span>),<font></font>
               textcoords=<span class="hljs-string">'offset points'</span>, ha=<span class="hljs-string">'right'</span>,va=<span class="hljs-string">'bottom'</span>)    <font></font>
plt.show()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブラウザーでインタラクティブな3D形式に変換するのが困難だったので、私はgifを投稿し</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ts/h8/-n/tsh8-niklcayz5gixfk5vkbrczq.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。テキストのないバージョンはより美しく、認識できるように見えます。</font></font><br>
<br>
<pre><code class="python hljs">xn = fincoords[<span class="hljs-number">0</span>][:,<span class="hljs-number">0</span>]<font></font>
yn = fincoords[<span class="hljs-number">0</span>][:,<span class="hljs-number">1</span>]<font></font>
zn = fincoords[<span class="hljs-number">0</span>][:,<span class="hljs-number">2</span>]<font></font>
l=[labels[idi] <span class="hljs-keyword">for</span> idi <span class="hljs-keyword">in</span> myIDs]<font></font>
colors=[ccode[lines[idi]] <span class="hljs-keyword">for</span> idi <span class="hljs-keyword">in</span> myIDs]<font></font>
xyzn = zip(xn, yn, zn)<font></font>
<font></font>
fig = plt.figure()<font></font>
ax = fig.gca(projection=<span class="hljs-string">'3d'</span>)<font></font>
ax.scatter(xn,yn,zn, c=colors, marker=<span class="hljs-string">'o'</span>)<font></font>
plt.show()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/webt/kk/oi/ay/kkoiaydx47oun6-enod5azcsotq.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UPD：目的の色のメトロラインを追加してgifを作成します。</font><font style="vertical-align: inherit;">黒い線-ステーション間の遷移：</font></font><br>
<br>
<pre><code class="python hljs">myedges=[(myIDs.index(edge[<span class="hljs-number">0</span>]),myIDs.index(edge[<span class="hljs-number">1</span>]))<span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> G.edges]<font></font>
xn = fincoords[<span class="hljs-number">0</span>][:,<span class="hljs-number">0</span>]<font></font>
yn = fincoords[<span class="hljs-number">0</span>][:,<span class="hljs-number">1</span>]<font></font>
zn = fincoords[<span class="hljs-number">0</span>][:,<span class="hljs-number">2</span>]<font></font>
l=[labels[idi] <span class="hljs-keyword">for</span> idi <span class="hljs-keyword">in</span> myIDs]<font></font>
c=[ccode[lines[idi]] <span class="hljs-keyword">for</span> idi <span class="hljs-keyword">in</span> myIDs]<font></font>
<font></font>
fig = plt.figure()<font></font>
ax = fig.gca(projection=<span class="hljs-string">'3d'</span>)<font></font>
ax.scatter(x,y,z, c=c, marker=<span class="hljs-string">'o'</span>,s=<span class="hljs-number">25</span>)
<span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> myedges:<font></font>
    col=<span class="hljs-string">'black'</span>
    <span class="hljs-keyword">if</span> c[edge[<span class="hljs-number">0</span>]]==c[edge[<span class="hljs-number">1</span>]]:<font></font>
        col=c[edge[<span class="hljs-number">0</span>]]<font></font>
    ax.plot3D([x[edge[<span class="hljs-number">0</span>]], x[edge[<span class="hljs-number">1</span>]]], [y[edge[<span class="hljs-number">0</span>]], y[edge[<span class="hljs-number">1</span>]]], [z[edge[<span class="hljs-number">0</span>]], z[edge[<span class="hljs-number">1</span>]]], col)<font></font>
<font></font>
ims = []<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotate</span>(<span class="hljs-params">angle</span>):</span><font></font>
    ax.view_init(azim=angle)<font></font>
<font></font>
rot_animation = animation.FuncAnimation(fig, rotate, frames=np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">362</span>, <span class="hljs-number">3</span>), interval=<span class="hljs-number">70</span>)<font></font>
rot_animation.save(<span class="hljs-string">'rotation2.gif'</span>, dpi=<span class="hljs-number">80</span>, writer=matplotlib.animation.PillowWriter(<span class="hljs-number">80</span>))
</code></pre><br>
<img src="https://habrastorage.org/webt/0w/y9/r6/0wy9r6wx7k882e530jad51o8pc0.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このスキームから、他のスキームからはそれほど明白ではないいくつかの興味深い結論を引き出すことができます。緑、青、紫などの一部の枝については、これらの枝からリングの距離で見られる不快な移植のため、MCC（ピンクのリング）は実質的に役に立たない。最長のルートは、共同アパートからスナッピングまたはPyatnitsky高速道路（赤とピンク/青の馬）までです。長いルートは、アルマアタストーリーテリングとブニンアリーネクラソフカです。計画から判断すると、モスクワの北には灰色と薄緑色の枝が部分的に重複しています-それらは図の近くにあります。新しいライン（WDC、BKL）とそれをより頻繁に使用するユーザーを確認することは興味深いでしょう。いずれにせよ、そのようなスキームが分析、インスピレーション、旅行計画のための興味深いツールになることを願っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PS 3Dは必要ありません。2Dバージョンの場合、コードをわずかに修正するだけで十分です。</font><font style="vertical-align: inherit;">しかし、2Dスキームの場合、そのような距離の正確さを達成することは不可能です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bk/bt/cp/bkbtcppvnxoxqzxtg_ijzzb0woy.png"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja470592/index.html">Pleskレビュー-ホスティングおよびサイトコントロールパネル</a></li>
<li><a href="../ja470594/index.html">モスクワでの光のショー「光のサークル」2019からのレポート</a></li>
<li><a href="../ja470596/index.html">リアルタイムサービスの例に関するQおよびKDB +の機能</a></li>
<li><a href="../ja470598/index.html">本「現代のJava。ラムダ式、ストリーム、関数型プログラミング」</a></li>
<li><a href="../ja470600/index.html">安全なnoVNCコンソール、Kubernetesでの自動スケーリング、OstrovkaでのHaproxy、およびプログラマーとの管理者の作業について</a></li>
<li><a href="../ja470604/index.html">eコマースでのサイトの読み込み速度：ロシアの上位48のオンラインストアの分析</a></li>
<li><a href="../ja470608/index.html">Unity UIの最適化</a></li>
<li><a href="../ja470610/index.html">開発者の人生のある日</a></li>
<li><a href="../ja470612/index.html">電圧計が示すもの、または数学ソケット</a></li>
<li><a href="../ja470614/index.html">NESグラフィックはどのように配置されましたか？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>