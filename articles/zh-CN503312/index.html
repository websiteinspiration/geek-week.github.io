<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🎤 🍁 ☯️ 如何在Angular应用程序中导致内存泄漏？ 👩🏿‍🔧 🛀🏻 🔇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="性能是Web应用程序成功的关键。因此，开发人员需要知道内存泄漏是如何发生的以及如何处理。
 
 当开发人员正在处理的应用程序达到一定大小时，此知识尤其重要。如果您对内存泄漏没有给予足够的关注，那么开发人员可能会进入“消除内存泄漏的团队”（我必须是这样的团队的一员）。 内存泄漏可能由于各种原因而发生。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>如何在Angular应用程序中导致内存泄漏？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/503312/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性能是Web应用程序成功的关键。因此，开发人员需要知道内存泄漏是如何发生的以及如何处理。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当开发人员正在处理的应用程序达到一定大小时，此知识尤其重要。如果您对内存泄漏没有给予足够的关注，那么开发人员可能会进入“消除内存泄漏的团队”（我必须是这样的团队的一员）。</font><font style="vertical-align: inherit;">
内存泄漏可能由于各种原因而发生。但是，我相信在使用Angular时，您可能会遇到与最常见的内存泄漏原因相匹配的模式。有一种方法可以处理此类内存泄漏。当然，最好的事情不是解决问题，而是避免问题。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/bg/op/jz/bgopjzk2msaiedpikpoa1qcv2cm.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么是内存管理？</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript使用自动内存管理系统。</font><font style="vertical-align: inherit;">内存生命周期通常包含三个步骤：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配必要的内存。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用分配的内存，执行读取和写入操作。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不再需要之后释放内存。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN上</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示自动内存管理-这是造成混乱的潜在原因。</font><font style="vertical-align: inherit;">这会给开发人员一种错误的感觉，即他们不必担心内存管理。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您根本不关心内存管理，则意味着在您的应用程序增长到一定大小后，您很可能会遇到内存泄漏。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，内存泄漏可以认为是分配给应用程序的内存，不再需要但不释放。</font><font style="vertical-align: inherit;">换句话说，这些是无法进行垃圾回收操作的对象。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">垃圾收集如何工作？</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在非常合乎逻辑的垃圾收集过程中，所有被视为“垃圾”的东西都被清除了。</font><font style="vertical-align: inherit;">垃圾收集器清理了应用程序不再需要的内存。</font><font style="vertical-align: inherit;">为了找出应用程序仍需要哪些内存区域，垃圾回收器使用“标记和清除”算法（标记算法）。</font><font style="vertical-align: inherit;">顾名思义，该算法包括两个阶段-标记阶段和扫描阶段。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍标志阶段</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对象和指向它们的链接以树的形式呈现。</font><font style="vertical-align: inherit;">在下图中，树的根是一个节点</font></font><code>root</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在JavaScript中，这是一个object </font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">每个对象都有一个特殊的标志。</font><font style="vertical-align: inherit;">让我们命名这个标志</font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在标记阶段，首先，将所有标记</font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置为value </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/433/436/b8a/433436b8a72bc7a207bd66c5b76788f5.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，将标记对象的标志设置为false，</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
然后遍历对象树。</font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从节点可到达的</font><font style="vertical-align: inherit;">所有</font><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">标记</font></font><code>root</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">均设置为</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">那些无法到达的对象的标志保留在value中</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果无法从根对象访问对象，则认为该对象不可访问。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cf/d14/a50/1cfd14a50f9be4e7aa402052982eb253.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可达对象被标记为marked = true，不可达对象被标记marked = false</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
结果，所有</font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不可达对象的</font><font style="vertical-align: inherit;">标志都</font><font style="vertical-align: inherit;">保留在value中</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">内存尚未释放，但是在完成标记阶段之后，一切准备就绪即可进行清洁阶段。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍清洁阶段</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在该算法的此阶段，将精确清除内存。此处，所有不可达的对象（其标志</font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保留在value中的</font><font style="vertical-align: inherit;">那些对象</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）都会被垃圾收集器破坏。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/75f/f16/8a075ff162428195665afe583a85151f.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">垃圾回收后的对象树。</font><font style="vertical-align: inherit;">所有标记标志设置为false的对象都会被垃圾收集器销毁，</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
垃圾收集会在JavaScript程序运行时定期执行。</font><font style="vertical-align: inherit;">在此过程中，将释放可以释放的内存。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可能在这里出现以下问题：“如果垃圾收集器删除了所有标记为不可访问的对象-如何造成内存泄漏？”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里的重点是，如果应用程序不需要该对象，则垃圾回收器将不会对其进行处理，但是您仍然可以从对象树的根节点访问该对象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该算法无法知道应用程序是否将使用它可以访问的某些内存。</font><font style="vertical-align: inherit;">只有程序员才具有这种知识。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">角度内存泄漏</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大多数情况下，当重复重新渲染组件时，随着时间的流逝会发生内存泄漏。</font><font style="vertical-align: inherit;">例如-通过路由，或使用指令的结果</font></font><code>*ngIf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">假设某些高级用户整天使用该应用程序而不更新浏览器中的应用程序页面。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了重现此场景，我们将创建两个组件的构造。</font><font style="vertical-align: inherit;">这些将是</font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">的组成部分</font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
&nbsp;&nbsp;<span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;app-sub *ngIf="hide"&gt;&lt;/app-sub&gt;`</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppComponent</span> </span>{<font></font>
&nbsp;&nbsp;hide = <span class="hljs-literal">false</span>;<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.hide = !<span class="hljs-keyword">this</span>.hide, <span class="hljs-number">50</span>);<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
组件模板</font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用component </font></font><code>app-sub</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这里最有趣的是，我们的组件使用的功能</font></font><code>setInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><code>hide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每50毫秒</font><font style="vertical-align: inherit;">切换</font><font style="vertical-align: inherit;">一次</font><font style="vertical-align: inherit;">标志</font><font style="vertical-align: inherit;">。这导致每50 ms重新渲染一个组件</font></font><code>app-sub</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。即，执行类的新实例的创建</font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。此代码模仿了整天都在使用Web应用程序而不刷新浏览器中的页面的用户的行为。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在中</font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们实现了不同的方案，在这些方案的使用中，随着时间的流逝，应用程序使用的内存量开始出现变化。注意组件</font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">始终保持不变。</font><font style="vertical-align: inherit;">在每种情况下，我们都会通过分析浏览器进程的内存消耗来找出我们正在处理的是否是内存泄漏。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果该进程的内存消耗随着时间的推移而增加，则意味着我们面临着内存泄漏。</font><font style="vertical-align: inherit;">如果一个进程或多或少地使用了一定数量的内存，则这意味着没有内存泄漏，或者该泄漏（尽管存在）没有以明显的方式表现出来。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍场景1：巨大的for循环</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的第一个场景由运行100,000次的循环表示。</font><font style="vertical-align: inherit;">在循环中，将随机值添加到数组中。</font><font style="vertical-align: inherit;">我们不要忘记该组件每50毫秒重新渲染一次。</font><font style="vertical-align: inherit;">看一下代码，然后考虑我们是否造成了内存泄漏。</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;arr = [];<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; ++i) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.arr.push(<span class="hljs-built_in">Math</span>.random());<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管此类代码不应发送到生产环境，但不会造成内存泄漏。</font><font style="vertical-align: inherit;">即，存储器消耗不超过限制为15MB的值的范围。</font><font style="vertical-align: inherit;">结果，没有内存泄漏。</font><font style="vertical-align: inherit;">下面我们将讨论为什么会这样。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍方案2：BehaviorSubject订阅</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，我们订阅</font></font><code>BehaviorSubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将一个值分配给一个常量。</font><font style="vertical-align: inherit;">此代码中是否存在内存泄漏？</font><font style="vertical-align: inherit;">和以前一样，不要忘记该组件每50毫秒渲染一次。</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;subject = <span class="hljs-keyword">new</span> BehaviorSubject(<span class="hljs-number">42</span>);<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.subject.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> foo = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与前面的示例一样，这里没有内存泄漏。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍场景3：为预订中的类字段分配值</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，几乎提供了与先前示例相同的代码。</font><font style="vertical-align: inherit;">主要区别在于，该值不是分配给常量，而是分配给类字段。</font><font style="vertical-align: inherit;">现在，您是否认为代码中存在泄漏？</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;subject = <span class="hljs-keyword">new</span> BehaviorSubject(<span class="hljs-number">42</span>);<font></font>
&nbsp;&nbsp;randomValue = <span class="hljs-number">0</span>;<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.subject.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.randomValue = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您认为这里没有泄漏-绝对正确。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在方案1中，没有订阅。</font><font style="vertical-align: inherit;">在场景2和3中，我们订阅了在组件中初始化的观察对象的流。</font><font style="vertical-align: inherit;">订阅组件流程就好像我们很安全。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如果我们在方案中增加服务呢？</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用服务的方案</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在以下情况下，我们将回顾以上示例，但是这次我们将订阅服务提供的流</font></font><code>DummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是服务代码。</font></font><br>
<br>
<pre><code class="javascript hljs">@Injectable({
&nbsp;&nbsp;<span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DummyService</span> </span>{<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;some$ = <span class="hljs-keyword">new</span> BehaviorSubject&lt;number&gt;(<span class="hljs-number">42</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们面前的是一项简单的服务。</font><font style="vertical-align: inherit;">这只是一种</font></font><code>some$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以公共类字段的形式</font><font style="vertical-align: inherit;">提供流（</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">的服务</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍场景4：订阅流并将值分配给本地常量</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们将重新创建与先前已经描述的相同的方案。</font><font style="vertical-align: inherit;">但是这一次，我们订阅流</font></font><code>some$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><code>DummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而不是组件的领域。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有内存泄漏吗？</font><font style="vertical-align: inherit;">同样，在回答此问题时，请记住该组件已在</font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">和渲染多次。</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.dummyService.some$.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> foo = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们终于造成了内存泄漏。</font><font style="vertical-align: inherit;">但这是一个小小的泄漏。</font><font style="vertical-align: inherit;">所谓“小泄漏”，是指随着时间的流逝，导致消耗的内存量缓慢增加。</font><font style="vertical-align: inherit;">这种增加几乎没有引起注意，但是对堆快照的粗略检查表明存在许多未删除的副本</font></font><code>Subscriber</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍方案5：订阅服务并为类字段分配值</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们再次订阅</font></font><code>dummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是这次我们将结果值分配给class字段，而不是局部常量。</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;randomValue = <span class="hljs-number">0</span>;<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.dummyService.some$.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.randomValue = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们终于造成了严重的内存泄漏。</font><font style="vertical-align: inherit;">一分钟内，内存消耗迅速超过1 GB。</font><font style="vertical-align: inherit;">让我们谈谈为什么会这样。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍什么时候发生内存泄漏？</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可能已经注意到，在前三种情况下，我们无法创建内存泄漏。</font><font style="vertical-align: inherit;">这三种情况有一个共同点：所有链接都位于组件本地。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我们订阅一个可观察对象时，它存储了一个订阅者列表。</font><font style="vertical-align: inherit;">我们的回调也在此列表中，该回调可以引用我们的组件。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/49f/92e/bda49f92eb184ad1eb78231a4144b71c.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无内存泄漏</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
当组件被销毁时，即当Angular不再具有链接时，这意味着无法从根节点访问该组件，也无法从根节点访问观察到的对象及其订阅者列表。结果，整个组件对象被垃圾回收。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
只要我们订阅了可观察对象（该链接仅在组件内），就不会出现问题。但是，当服务开始起作用时，情况就发生了变化。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/454/6f7/b5b/4546f7b5b2ab2d2858f550740243189e.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内存泄漏</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
一旦我们订阅了服务或另一个类提供的可观察对象，我们就创建了内存泄漏。</font><font style="vertical-align: inherit;">这是由于观察到的对象，因为有其订阅者列表。</font><font style="vertical-align: inherit;">因此，尽管Angular没有对组件的直接引用，但可以从根节点访问回调及其组件。</font><font style="vertical-align: inherit;">结果，垃圾收集器不会触摸相应的对象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我会澄清：您可以使用此类构造，但是您需要正确使用它们，而不是像我们一样。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确的订阅工作</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了避免内存泄漏，通过不再需要订阅时执行此操作来正确取消订阅是很重要的。例如，当一个组件被破坏时。有许多方法可以退订观察到的对象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
向大型公司项目所有者提供建议的经验表明，在这种情况下，最好</font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将团队创建</font><font style="vertical-align: inherit;">的实体</font></font><code>new Subject&lt;void&gt;()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与操作员结合使用</font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnDestroy</span> </span>{<font></font>
<font></font>
&nbsp;&nbsp;private destroy$: Subject&lt;<span class="hljs-keyword">void</span>&gt; = <span class="hljs-keyword">new</span> Subject&lt;<span class="hljs-keyword">void</span>&gt;();<font></font>
&nbsp;&nbsp;randomNumber = <span class="hljs-number">0</span>;<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dummyService.some$.pipe(<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;takeUntil(<span class="hljs-keyword">this</span>.destroy$)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;).subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-keyword">this</span>.randomNumber = value);<font></font>
&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;ngOnDestroy(): <span class="hljs-keyword">void</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.destroy$.next();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.destroy$.complete();<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此</font><font style="vertical-align: inherit;">，在销毁组件之后，</font><font style="vertical-align: inherit;">我们使用</font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and运算符</font><font style="vertical-align: inherit;">取消订阅</font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们在组件中实现了生命周期挂钩</font></font><code>ngOnDestroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">每次销毁组件时，我们都会调用</font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该呼叫</font></font><code>complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常重要，因为此呼叫会清除中的订阅</font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，我们使用运算符</font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将其传递给我们的流</font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这样可确保在销毁组件之后清除订阅（即，我们已取消订阅）。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何记住清除订阅？</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Hook生命周期中</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">
很容易忘记添加组件</font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而忘记调用</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">尽管事实上我是为从事项目工作的团队讲授这些的，但我经常还是自己忘记了这一点。</font><font style="vertical-align: inherit;">
幸运的是，有一个很棒的Linter规则，它是一</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">组规则的</font></a><font style="vertical-align: inherit;">一部分，该</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">规则</font></a><font style="vertical-align: inherit;">使您可以确保从订阅中正确取消订阅。</font><font style="vertical-align: inherit;">您可以设置如下规则集：</font></font><code>next</code><font style="vertical-align: inherit;"></font><code>complete</code><font style="vertical-align: inherit;"></font><code>ngOnDestroy</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="javascript hljs">npm install @angular-extensions/lint-rules --save-dev
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，它必须连接到</font></font><code>tslint.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs">{
&nbsp;&nbsp;<span class="hljs-string">"extends"</span>: [
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"tslint:recommended"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"@angular-extensions/lint-rules"</span><font></font>
&nbsp;&nbsp;]<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我强烈建议您在项目中使用这套规则。</font><font style="vertical-align: inherit;">这样可以节省大量的调试时间来查找内存泄漏的来源。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Angular中，很容易造成导致内存泄漏的情况。</font><font style="vertical-align: inherit;">显然，即使在很小的地方更改代码也不应引起内存泄漏，这可能会导致严重的不利后果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
避免内存泄漏的最佳方法是正确管理您的订阅。</font><font style="vertical-align: inherit;">不幸的是，清理订阅的操作需要开发人员的高度准确性。</font><font style="vertical-align: inherit;">这很容易忘记。</font><font style="vertical-align: inherit;">因此，建议您应用规则</font></font><code>@angular-extensions/lint-rules</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来帮助组织订阅的正确操作。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有此材料基础代码</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">的</font></a><font style="vertical-align: inherit;">存储库。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您在Angular应用程序中是否遇到内存泄漏？</font></font></b><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/a_/bs/aa/a_bsaactpbr8fltzymtkhqbw1d4.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN503288/index.html">我们如何使用机器学习搜索候选人</a></li>
<li><a href="../zh-CN503290/index.html">DJI Matrice 300 RTK工业直升机评测</a></li>
<li><a href="../zh-CN503300/index.html">《瑞克与莫蒂》一书。所有星系中最杰出的卡通指南»</a></li>
<li><a href="../zh-CN503302/index.html">加快基于CMake + GCC的项目构建：头文件的预编译</a></li>
<li><a href="../zh-CN503310/index.html">高级程序员怎么看？</a></li>
<li><a href="../zh-CN503318/index.html">职业：程序员。并非一切都清楚</a></li>
<li><a href="../zh-CN503322/index.html">固件开发：简介</a></li>
<li><a href="../zh-CN503324/index.html">Brad Stalberg和Steve Magness的“巅峰时期”：防止自燃（第一部分）</a></li>
<li><a href="../zh-CN503328/index.html">我们使用GraalVM将Spring Boot应用程序编译为本机</a></li>
<li><a href="../zh-CN503330/index.html">如何向数据科学家学习：最想要的技术技能</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>