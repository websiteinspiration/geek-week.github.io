<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüéì ü§û üà∫ Allocateurs de m√©moire üëá üë®üèø‚Äçüç≥ üë®‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! Il n'y a pas si longtemps, apr√®s une √©tude tr√®s approfondie des allocateurs et des algorithmes d'allocation de m√©moire, ainsi que dans...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Allocateurs de m√©moire</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505632/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour √† tous! </font><font style="vertical-align: inherit;">Il n'y a pas si longtemps, apr√®s une √©tude tr√®s approfondie des allocateurs et des algorithmes d'allocation de m√©moire, ainsi que dans leur application ult√©rieure dans la pratique, j'ai eu l'id√©e d'√©crire un article qui les d√©crirait le plus en d√©tail possible. </font><font style="vertical-align: inherit;">Je pense que ce sujet sera tr√®s populaire, car il existe actuellement tr√®s peu de sources sur le r√©seau, en particulier dans la partie russophone, consacr√©e √† cette question.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√©face</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour commencer, je voudrais imm√©diatement noter que si quelqu'un entend d'abord les termes "allocateur", "algorithmes d'allocation de m√©moire" et ne comprend pas pourquoi tout cela est n√©cessaire, puis avant de lire cet article, je vous recommande de vous familiariser avec </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> source . </font><font style="vertical-align: inherit;">Cet article d√©crit assez bien quels probl√®mes existent dans les allocateurs de m√©moire standard et √† quelles fins il vaut la peine d'utiliser d'autres m√©thodes d'allocation de m√©moire, en plus des m√©thodes standard. </font><font style="vertical-align: inherit;">Ici, je ne parlerai que des algorithmes de distribution eux-m√™mes, et, bien s√ªr, √† la fin, je donnerai une impl√©mentation de l'un des allocateurs, qui peut √™tre utilis√© sans probl√®me dans les conteneurs C ++ standard.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les bases</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cinq op√©rations principales pouvant √™tre effectu√©es sur un allocateur sont mises en √©vidence conceptuellement (je voudrais noter que tous les allocateurs ne peuvent pas correspondre explicitement √† cette interface):</font></font><br>
<br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">create</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - cr√©e un allocateur et lui donne une certaine quantit√© de m√©moire;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allouer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - s√©lectionne un bloc d'une certaine taille de la zone m√©moire que les commandes de l' </font><font style="vertical-align: inherit;">allocateur;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©sallouer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - lib√®re un bloc sp√©cifique;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">free</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - lib√®re tous les blocs allou√©s de la m√©moire de l'allocateur (la m√©moire allou√©e √† l'allocateur n'est pas lib√©r√©e);</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">destroy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - d√©truit l'allocateur avec la lib√©ration subs√©quente de m√©moire allou√©e √† l'allocateur.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allocateur lin√©aire</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Allocateur lin√©aire, il est √©galement ¬´lin√©aire¬ª - c'est le type d'allocateur le plus simple. L'id√©e est d'enregistrer un pointeur au d√©but du bloc de m√©moire pour l'allocateur allou√©, et √©galement d'utiliser un pointeur diff√©rent ou une repr√©sentation num√©rique, qui devra √™tre d√©plac√© chaque fois que l'allocation de l'allocateur est termin√©e. Dans cet allocateur, la fragmentation interne est minimis√©e car tous les √©l√©ments sont ins√©r√©s s√©quentiellement (localit√© spatiale), et la seule fragmentation entre eux est l'alignement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, je propose de consid√©rer plusieurs exemples dans lesquels il sera clairement montr√© en d√©tail comment fonctionne ce r√©partiteur. Prenez un bloc de m√©moire √©gal √† 14 octets et donnez-le au contr√¥le de l'allocateur. Comme le montre l'image ci-dessous, nous enregistrons un pointeur vers le d√©but de la m√©moire ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©but</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) et stockent √©galement deux pointeurs ou deux repr√©sentations num√©riques qui contiennent des informations sur les </font><font style="vertical-align: inherit;">tailles de m√©moire </font><font style="vertical-align: inherit;">totales ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et utilis√©es ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilis√©es</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/aa/wg/vgaawgiqzerseegtgqvk0qbjhus.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imaginez que l'allocateur a re√ßu une demande d'allocation de 4 octets de m√©moire. </font><font style="vertical-align: inherit;">Les actions de l'allocateur sur l'ex√©cution de cette demande seront les suivantes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v√©rifier s'il y a suffisamment de m√©moire √† allouer;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enregistrer le pointeur utilis√© actuellement, qui sera ensuite donn√© √† l'utilisateur comme pointeur vers un bloc de m√©moire allou√©e par l'allocateur;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©caler le pointeur utilis√© d'une quantit√© √©gale √† la taille du bloc de m√©moire allou√©, c'est-√†-dire </font><font style="vertical-align: inherit;">de 4 octets.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/wp/3q/_r/wp3q_r2dp-ywsaou93vzk8zhqkk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En outre, par exemple, une demande vient pour l'allocation de 8 octets et, en cons√©quence, les actions de l'allocateur seront exactement les m√™mes quelle que soit la taille du bloc de m√©moire allou√©. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/di/g4/ih/dig4ihecjl8qfasqqonhdqtt2lm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais ici, ce sera d√©j√† un peu plus int√©ressant, par exemple, si une demande vient pour allouer seulement 1 octet, et si nous ne voulons pas aligner des blocs en m√©moire (par exemple, des adresses qui sont des multiples de 2, 4, ...), alors les actions de l'allocateur resteront exactement les m√™mes.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vz/x_/cc/vzx_cc45oildurtaxdyi7n9fi7i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais, si nous devons allouer des blocs de m√©moire avec un certain alignement (par exemple, alignement d'adresses multiples de 2), alors l'action de l'allocateur change l√©g√®rement. Cela ne change pas en termes de mise en ≈ìuvre, mais en ce que, en plus des donn√©es elles-m√™mes √©gales au volume d'un octet, nous prenons √©galement un octet suppl√©mentaire de la m√©moire de l'allocateur pour l'alignement, ce qui n'a aucune signification. Il s'agit pr√©cis√©ment de la fragmentation minimale tr√®s possible de la m√©moire √† l'int√©rieur d'un allocateur lin√©aire. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jx/xg/pz/jxxgpzvrvs9nhyodrphmi1xg1sy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Super, il est maintenant temps de parler de lib√©rer de la m√©moire. Comme indiqu√© pr√©c√©demment, ce type d'allocotor ne prend pas en charge la lib√©ration s√©lective de certains blocs de m√©moire. Autrement dit, si nous tirons une analogie subtile avec </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc / free</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ayant un pointeur sur, disons, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFAA00</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous pourrions lib√©rer ce bloc de m√©moire, mais un allocateur lin√©aire ne peut pas nous permettre de le faire. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mj/es/_0/mjes_04nsdmq3bfiolwehoxwdfk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout ce que nous pouvons faire est de lib√©rer toute la m√©moire occup√©e enti√®rement √† l'int√©rieur de l'allocateur et de continuer √† travailler avec lui comme s'il √©tait compl√®tement vide.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/aa/wg/vgaawgiqzerseegtgqvk0qbjhus.png"><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allocateur de pool</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'id√©e d'un allocateur de blocs est qu'il divise un gros morceau de m√©moire en petits morceaux de la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√™me taille</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . √Ä la base, il s'agit √©galement d'un allocateur tr√®s simple, car lorsque l'allocation est demand√©e, il renvoie simplement l'un des emplacements de m√©moire libres d'une taille fixe, et lorsqu'il est demand√© d'√™tre lib√©r√©, il enregistre simplement cette zone de m√©moire pour une utilisation future. Ainsi, la distribution est tr√®s rapide et la fragmentation est encore tr√®s faible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, ainsi qu'avec un allocateur lin√©aire, je propose de tout consid√©rer avec un exemple afin de comprendre plus en d√©tail comment cela fonctionne, donc nous prenons un bloc de m√©moire √©gal √† 12 octets et le donnons au contr√¥le de l'allocateur. Comme vous pouvez le voir sur l'image ci-dessous, nous gardons le pointeur au d√©but (</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et la fin ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">end</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) de la m√©moire contr√¥l√©e par l'allocateur, ainsi qu'une liste ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freeblocks</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) des adresses des blocs libres dans l'allocateur. Pour stocker des donn√©es indiquant que le bloc est occup√© ou libre, vous pouvez utiliser de nombreux outils, par exemple un tableau de valeurs bool√©ennes, mais j'ai simplement d√©cid√© de choisir une liste simplement connect√©e, car elle caract√©rise le plus simplement et clairement ce concept (√† propos, les liens de la liste peuvent √™tre stock√©s dans des blocs de m√©moire libres, supprimant ainsi les co√ªts suppl√©mentaires de m√©moire).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/co/6s/5o/co6s5o7c7ufuvofrrb1oqwke8vy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si une demande vient d'allouer un bloc de m√©moire, alors les actions de l'allocateur sont tr√®s primitives. Tout d'abord, il v√©rifie s'il y a des liens dans la liste des blocs libres, s'ils ne sont pas l√†, alors il n'est pas difficile de deviner que la m√©moire dans l'allocateur est d√©j√† √©puis√©e. S'il y a au moins un lien, il supprime simplement le lien racine ou queue (dans cette impl√©mentation, les liens de queue sont donn√©s) de la liste et donne son adresse √† l'utilisateur. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uc/j_/44/ucj_44gjfi99_jf4whquo4sra78.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si une demande vient pour l'allocation de plusieurs blocs de m√©moire, alors l'allocateur effectue de la m√™me mani√®re les m√™mes actions successivement, d√©crites √† l'√©tape pr√©c√©dente.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ri/qc/zy/riqczyaeceqtxdshywd0py4r0nw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quant √† la lib√©ration du bloc, si une demande de lib√©ration arrive, l'allocateur ajoute simplement cette adresse √† l'une des extr√©mit√©s d'une liste simplement connect√©e. Il convient de noter un tel moment que, par exemple, une adresse qui ne correspond pas √† l'adresse m√©moire de l'allocateur, par exemple </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xEFAB12</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">peut venir comme adresse du bloc √† </font><b><font style="vertical-align: inherit;">lib√©rer</font></b><font style="vertical-align: inherit;"> , et il sera alors possible que nous donnions √† l'utilisateur un morceau de m√©moire qui ne nous appartient pas (bien s√ªr , cela conduira √† un comportement ind√©fini ou si vous √™tes tr√®s chanceux, alors simplement √† planter le programme). Pour √©viter ce probl√®me √©ventuel, il suffit de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commencer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terminer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui vous permet de v√©rifier si l'utilisateur s'est tromp√© d'adresse lors de la demande d'op√©ration de lib√©ration.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/0n/ed/gd0nedbx2nlhsrxggnymb42keey.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus d'aller au-del√† de la m√©moire que l'allocateur ne contr√¥le pas, il existe un autre probl√®me possible. </font><font style="vertical-align: inherit;">Un utilisateur peut pr√©senter une demande pour lib√©rer absolument n'importe quelle adresse situ√©e dans la zone de m√©moire de l'allocateur, mais pas √©gale √† l'adresse de d√©but de l'un des blocs, disons un bloc avec l'adresse </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFAA07</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cette op√©ration, bien s√ªr, conduira √† un comportement ind√©fini. </font><font style="vertical-align: inherit;">S'il est √©galement n√©cessaire de v√©rifier si l'utilisateur fait tout correctement, il est possible de le suivre. </font><font style="vertical-align: inherit;">Pour suivre cela, il existe de nombreuses solutions, par exemple, pour stocker √©galement les adresses et les blocs occup√©s, ou m√™me v√©rifier l'adresse pour la multiplicit√© de la taille des blocs dans l'allocateur (tout d√©pend de l'imagination et de la situation particuli√®re dans laquelle l'allocateur est utilis√©).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3u/mn/hw/3umnhwagefbl_eysi3zl6yhu9be.png"><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allocateur de pile</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, il s'agit d'une √©volution intelligente d'un allocateur lin√©aire qui vous permet de g√©rer la m√©moire comme une pile. Tout est le m√™me qu'avant, nous enregistrons le pointeur avec le bloc "en-t√™te" (ci-apr√®s sera utilis√© comme en- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t√™te</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) √† l'adresse m√©moire actuelle et le d√©pla√ßons pour chaque allocation. Contrairement √† un allocateur lin√©aire, nous pouvons √©galement le reculer, c'est-√†-dire effectuer l'op√©ration de d√©sallocation, qui n'est pas prise en charge par un allocateur lin√©aire. Comme pr√©c√©demment, le principe de la localisation spatiale est conserv√© et la fragmentation est encore minime. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je propose de consid√©rer plusieurs exemples tous avec le m√™me bloc m√©moire de 14 octets. Comme avec un allocateur lin√©aire, nous stockons √©galement des pointeurs vers le d√©but de la m√©moire ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©but</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et la fin ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), ainsi qu'un pointeur vers la fin de la m√©moire </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilis√©e</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><i><font style="vertical-align: inherit;">utilis√©e</font></i><font style="vertical-align: inherit;"> ). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ba/sb/qv/basbqv8yj_v1sijo_td54pa472k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsqu'une demande d'allocation de m√©moire arrive, en plus d'allouer une certaine quantit√© de m√©moire demand√©e par l'utilisateur, nous allouons √©galement un en-t√™te (l'utilisateur n'interagira pas avec lui de quelque mani√®re que ce soit), dans lequel nous stockons des informations sur le nombre d'octets allou√©s (dans cet exemple, la taille de l'en-t√™te est 2 octets). Par exemple, si vous avez re√ßu une demande d'allocation de 2 octets, l'√©tat de l'allocateur sera exactement le m√™me que dans la figure ci-dessous. Il est important de noter que l'utilisateur ne recevra pas un pointeur vers l'en-t√™te, mais vers le bloc suivant imm√©diatement l'en-t√™te, c'est-√†-dire, dans cet exemple, c'est le bloc avec l'adresse </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFAA02</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/qb/q2/bgqbq2fei1egpmowdnmz9vciplo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une situation similaire sera, par exemple, avec l'allocation de 6 octets.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/up/pf/x_/uppfx_dpultvroggfr2rvy7lxhc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais avec la version, tout est un peu plus int√©ressant (comme discut√© pr√©c√©demment, nous ne pouvons allouer et lib√©rer de la m√©moire qu'en utilisant l'algorithme </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LIFO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Tout d'abord, √† partir du pointeur que l'utilisateur demande √† √™tre lib√©r√©, vous devez soustraire la taille de l'en-t√™te, puis d√©r√©f√©rencer la valeur et seulement apr√®s cela, d√©placer le pointeur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilis√©</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† la taille de l'en-t√™te avec la taille du bloc obtenu √† partir de l'en-t√™te. </font><font style="vertical-align: inherit;">Ici, tout comme avec l'allocateur de blocs, une situation de lib√©ration de blocs de m√©moire ¬´al√©atoires¬ª est possible, ce qui entra√Ænera √©galement un comportement ind√©fini. </font><font style="vertical-align: inherit;">C'est √† chacun de compl√©ter ou non les allocateurs par des ch√®ques suppl√©mentaires. </font><font style="vertical-align: inherit;">Le plus important est de ne pas oublier ce moment. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/as/fh/s4/asfhs4qflx43fwr9jizq-zmsatq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, apr√®s avoir compris les bases, il est temps d'apprendre quelque chose de plus s√©rieux.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Allocateur standard primitif"</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, une impl√©mentation de l'allocateur sera pr√©sent√©e, qui peut √™tre utilis√©e sans probl√®me avec STL. L'algorithme d'allocation de m√©moire dans cet allocateur sera similaire √† l'algorithme utilis√© par l'allocateur standard. Je tiens √† noter imm√©diatement que je ne pr√©tends pas √™tre une impl√©mentation compl√®te de malloc, je n'en ai pris que les concepts de base avec l'ajout de ma logique √† certains endroits. Toutes ses subtilit√©s et nuances, bien s√ªr, n'ont pas √©t√© prises en compte dans cette impl√©mentation ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'algorithme est bas√© sur l'interaction avec des "morceaux" (ci-apr√®s il sera utilis√© comme une </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">section</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dans cette impl√©mentation, leur taille est statique et doit √™tre un multiple de quatre, ainsi que toutes les allocations de m√©moire de la m√©moire d'allocateur sont align√©es par un multiple de quatre), ce qui sera discut√© plus tard. Par exemple, prenez une section d'une taille de 16 octets. √Ä l'int√©rieur, il contiendra des pointeurs vers le d√©but ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©but</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et la fin ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) de la m√©moire, un pointeur vers le bloc de m√©moire maximum ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et plusieurs ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freeblocks)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), dans lequel les en-t√™tes des blocs libres seront stock√©s. La taille de l'en-t√™te dans cette impl√©mentation est de 4 octets, mais sa taille peut facilement varier selon les besoins. Par exemple, si vous savez avec certitude que la taille des blocs de m√©moire allou√©s ne sera pas sup√©rieure √† la valeur num√©rique maximale pouvant √™tre repr√©sent√©e dans une ou deux variables d'octet, vous pouvez utiliser un en-t√™te de 1 ou 2 octets. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nr/xq/3f/nrxq3fcbnoooxnu0hehls2dghim.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'op√©ration d'allocation de m√©moire √† partir d'une section, vous devez d'abord v√©rifier s'il y a suffisamment de m√©moire (dans cette impl√©mentation, il s'agit d'une op√©ration constante, nous la comparons simplement avec </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et si la taille de la m√©moire allou√©e est inf√©rieure au bloc maximum, alors nous avons assez de m√©moire pour cette allocation). S'il y a suffisamment de m√©moire, nous donnons simplement l'adresse m√©moire suivant l'en-t√™te, comme dans l'allocateur de pile, et supprimons √©galement l'en-t√™te pr√©c√©dent de l'ensemble des blocs libres et seulement apr√®s cela, ajoutons le nouvel en-t√™te au bloc de m√©moire nouvellement allou√©. Il est important de noter que si nous avons allou√© de la m√©moire √† partir du bloc maximum, nous devrons alors mettre √† jour la valeur du bloc maximum. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5m/lm/yw/5mlmywi79wh3uutr-ug7ko7s9em.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les s√©lections suivantes, tout se passe exactement de la m√™me mani√®re qu'√† l'√©tape pr√©c√©dente.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3m/2m/i9/3m2mi9xd9qmnf6ngnqjf8wfnzd0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais maintenant, d√®s que la m√©moire de la section est termin√©e, l'allocateur prend et cr√©e simplement une autre section de la m√™me taille ou plus grande (dans cette impl√©mentation, toutes les sections sont de la m√™me taille). Il est √©galement utile de s'assurer que la taille d'un √©ventuel bloc d'allocation ne d√©passe pas la taille du trac√© moins la taille de l'en-t√™te. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fy/fz/6g/fyfz6gthdrfysccjef_xcphihb0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, dans la nouvelle section, vous pouvez facilement allouer les blocs de m√©moire n√©cessaires. L'allocation de m√©moire se produira exactement dans le m√™me sc√©nario que dans la section pr√©c√©dente.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/al/eu/gc/aleugc_fka3uvpmju9gw66dpn1w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, expliquons pourquoi dans cette impl√©mentation, la taille du trac√© doit √™tre un multiple de quatre. La r√©ponse est tr√®s simple - cela est fait pour faciliter la mise en ≈ìuvre et la perception de l'algorithme. √âtant donn√© qu'une telle situation est possible, √† la fin de la section, il peut rester une zone de m√©moire, qui ne correspond tout simplement pas √† l'en-t√™te (un exemple de cela est illustr√© dans la figure suivante). Pour r√©soudre ce probl√®me, il sera possible de remplir cette m√©moire avec un alignement suppl√©mentaire, soit de r√©duire la taille de l'en-t√™te, soit d'utiliser des outils suppl√©mentaires pour suivre ce probl√®me possible, sinon cette m√©moire sera perdue et, plus important encore, √† l'avenir, la m√©moire perdue pourra s'accumuler!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rq/rp/mv/rqrpmvvpbx1thpxjfbqcictzq1o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de lib√©rer de la m√©moire, vous devez d√©terminer dans quelle section se trouve le bloc (dans l'impl√©mentation actuelle, cette op√©ration est d'une complexit√© lin√©aire par rapport au nombre total de sections, s'il est entendu qu'il y aura un grand nombre de sections, alors il peut √™tre rendu constant en ajoutant un index de section √† l'en-t√™te, dans lequel la m√©moire a √©t√© allou√©e). Dans ce qui suit, l'op√©ration de d√©sallocation est identique √† l'allocateur de pile, sauf que vous devrez ajouter l'adresse d'en-t√™te du bloc d√©sallou√© √† l'ensemble de blocs libres, ainsi que mettre √† jour </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si la taille du bloc qui vient d'√™tre publi√© est plus grande que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fw/sl/yl/fwslyluxwv00a8mwazxe2iakd00.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est important de noter que dans cette impl√©mentation, √† chaque lib√©ration de m√©moire ult√©rieure, une tentative de d√©fragmentation est effectu√©e dans la zone dont la m√©moire a √©t√© lib√©r√©e. La d√©fragmentation est n√©cessaire pour combiner des blocs libres en grands blocs. Par exemple, dans cette situation, comme dans la figure ci-dessous, nous ne pouvons pas allouer 6 octets, m√™me si la taille de la m√©moire libre nous permet de le faire, mais la fragmentation nous dit un ¬´non¬ª ferme et d√©cisif! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tm/ec/dp/tmecdpyhyynvn0ahzubdxltorvo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'op√©ration de d√©fragmentation est tr√®s primitive. Son essence r√©side dans le fait qu'apr√®s l'op√©ration de lib√©ration de m√©moire, il v√©rifie si deux blocs voisins √† gauche et √† droite des lib√©r√©s sont libres. Si deux blocs voisins sont libres, ils sont combin√©s en une seule unit√©.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jt/1u/hl/jt1uhl_a7d3xo2a3f9kedx_7waq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je voudrais √©galement noter que cette impl√©mentation sera d√©sastreusement horrible de travailler avec l'allocation de petits blocs de m√©moire, par exemple √©gaux √† 1 octet. </font><font style="vertical-align: inherit;">Dans cette situation, nous obtenons +7 octets suppl√©mentaires pour allouer un seul octet de m√©moire, car la taille de l'en-t√™te est de 4 octets et plus 3 octets pour supprimer les adresses qui doivent √™tre un multiple de quatre. </font><font style="vertical-align: inherit;">Par cela, je veux dire que vous ne devez pas utiliser aveugl√©ment un algorithme d'allocation de m√©moire, car au lieu de l'optimisation tant attendue, vous ne pouvez parfois obtenir que des co√ªts suppl√©mentaires. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/r2/ez/v3/r2ezv39toknyjxexeamoq05g3r8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je pense que la th√©orie sera suffisante et donc, comme l'a dit Linus Torvalds: ¬´ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chatter ne vaut rien. </font><font style="vertical-align: inherit;">Montrez-moi le code</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . " </font><font style="vertical-align: inherit;">Eh bien, commen√ßons ...</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la mise en oeuvre</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les exigences pour les allocateurs sont donn√©es dans la norme C ++ dans le chapitre " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exigences d'allocateur [allocator.requirements]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Sur la base de ces exigences, l'interface d'allocation la plus primitive pouvant √™tre utilis√©e dans STL devrait ressembler √† ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">Allocator</span> 
{</span>
    <span class="hljs-keyword">typedef</span> T value_type;<font></font>
    Allocator( );<font></font>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; 
    <span class="hljs-title">Allocator</span>(<span class="hljs-title">const</span> &lt;T&gt;&amp; <span class="hljs-title">other</span>);</span>
    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(T* ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">U</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>==(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T&gt;&amp;, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U&gt;&amp;);</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">U</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>!=(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T&gt;&amp;, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U&gt;&amp;);</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est suppos√© que les conteneurs STL n'acc√®dent pas directement √† l'allocateur, mais via le mod√®le std :: allocator_traits, qui fournit des valeurs telles que:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">typedef</span> T* pointer;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> T* const_pointer; <font></font>
‚Ä¶ <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, nous avons compris les exigences, maintenant nous commen√ßons enfin √† √©crire un allocateur. </font><font style="vertical-align: inherit;">Pour commencer, nous √©crirons une interface ou un adaptateur, en fait, il est difficile de les appeler tous les deux, alors que ce soit une sorte de "couche" dans laquelle, en utilisant des strat√©gies, nous pouvons facilement changer l'algorithme d'allocation de m√©moire √† certaines fins:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Common interface for interaction with STL</span>
<span class="hljs-comment">// containers and algorithms. You can manually change</span>
<span class="hljs-comment">// allocation algorithm with different 'AllocationStrategy'</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// In this implementation was not implented 'adress' and 'max_size'</span>
<span class="hljs-comment">// unnecessary functions for.</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">Allocator</span>
{</span>
    <span class="hljs-keyword">static_assert</span>(!<span class="hljs-built_in">std</span>::is_same_v&lt;T, <span class="hljs-keyword">void</span>&gt;, <span class="hljs-string">"Type of the allocator can not be void"</span>);
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> value_type = T;<font></font>
<font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocStrategy</span>&gt;
    <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">Allocator</span>;</span><font></font>
    <font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rebind</span>
    {</span>
        <span class="hljs-keyword">using</span> other = Allocator&lt;U, AllocationStrategy&gt;;<font></font>
    };<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    Allocator() = <span class="hljs-keyword">default</span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Allocator</span><span class="hljs-params">(AllocationStrategy&amp; strategy)</span> <span class="hljs-keyword">noexcept</span>
        : <span class="hljs-title">m_allocation_strategy</span><span class="hljs-params">(&amp;strategy)</span> </span>{}<font></font>
    <font></font>
    Allocator(<span class="hljs-keyword">const</span> Allocator&amp; other) <span class="hljs-keyword">noexcept</span><font></font>
        : m_allocation_strategy(other.m_allocation_strategy) {}<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-title">Allocator</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Allocator&lt;U, AllocationStrategy&gt;&amp; other)</span> <span class="hljs-keyword">noexcept</span>
        : <span class="hljs-title">m_allocation_strategy</span><span class="hljs-params">(other.m_allocation_strategy)</span> </span>{}<font></font>
    <font></font>
    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span>
    </span>{<font></font>
        assert(m_allocation_strategy &amp;&amp; <span class="hljs-string">"Not initialized allocation strategy"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(m_allocation_strategy-&gt;allocate(count_objects * <span class="hljs-keyword">sizeof</span>(T)));<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* memory_ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span>
    </span>{<font></font>
        assert(m_allocation_strategy &amp;&amp; <span class="hljs-string">"Not initialized allocation strategy"</span>);<font></font>
        m_allocation_strategy-&gt;deallocate(memory_ptr, count_objects * <span class="hljs-keyword">sizeof</span>(T));<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-keyword">typename</span>... Args&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(U* ptr, Args&amp;&amp;... args)</span>
    </span>{
        <span class="hljs-keyword">new</span> (<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(ptr)) U { <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)... };<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(U* ptr)</span>
    </span>{<font></font>
        ptr-&gt;~U();<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:<font></font>
    AllocationStrategy* m_allocation_strategy = <span class="hljs-literal">nullptr</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>==(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T, AllocationStrategy&gt;&amp; <span class="hljs-title">lhs</span>, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U, AllocationStrategy&gt;&amp; <span class="hljs-title">rhs</span>)
{</span>
    <span class="hljs-keyword">return</span> lhs.m_allocation_strategy == rhs.m_allocation_strategy;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>!=(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T, AllocationStrategy&gt;&amp; <span class="hljs-title">lhs</span>, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U, AllocationStrategy&gt;&amp; <span class="hljs-title">rhs</span>)
{</span>
    <span class="hljs-keyword">return</span> !(lhs == rhs);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gr√¢ce √† la strat√©gie d'allocation de m√©moire, nous pouvons faire quelque chose comme ceci:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> AllocatorForSmallObjects = Allocator&lt;T, StrategyForSmallObjects&gt;;
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> AllocatorForBigObjects = Allocator&lt;T, StrategyForBigObjects&gt;;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est-√†-dire que nous pouvons modifier de mani√®re flexible les algorithmes de distribution aux fins n√©cessaires dans une situation donn√©e. </font><font style="vertical-align: inherit;">La seule condition requise pour AllocationStrategy est qu'ils doivent avoir des </font><i><font style="vertical-align: inherit;">op√©rations d' </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allocation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©sallocation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-comment">// Strategy for manipulation memory chunks, like</span>
<span class="hljs-comment">// a primitive malloc allocator.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Warning: if you try to deallocate some random block</span>
<span class="hljs-comment">// of the memory, most of all it will be an undefined behavior,</span>
<span class="hljs-comment">// because current implementation doesn't check this possible situation.</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE = <span class="hljs-number">16'384u</span>&gt;<font></font>
class CustomAllocationStrategy<font></font>
{<font></font>
    <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE != <span class="hljs-number">0u</span>, <span class="hljs-string">"Chunk size must be more, than zero"</span>);
    <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE &lt;= <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;::max(),
        <span class="hljs-string">"Chunk size must be less or equal max value of the uint32_t"</span>);
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{<font></font>
        assert(size &lt; CHUNK_SIZE &amp;&amp; <span class="hljs-string">"Incorrect chunk size for future usage"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0u</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : m_chunks)<font></font>
        {<font></font>
            <span class="hljs-keyword">void</span>* allocated_block = chunk.tryReserveBlock(size);
            <span class="hljs-keyword">if</span> (allocated_block) <span class="hljs-comment">//if the block was not reserved, then memory in the chunk has run out</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> allocated_block;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        m_chunks.push_back(details::Chunk&lt;CHUNK_SIZE&gt;{});<font></font>
        <span class="hljs-keyword">auto</span>&amp; chunk = m_chunks.back();
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* allocated_block = chunk.tryReserveBlock(size);
        <span class="hljs-keyword">return</span> allocated_block;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* memory_ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-keyword">if</span> ( (!memory_ptr) || (size == <span class="hljs-number">0u</span>) )<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* deallocation_ptr = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(memory_ptr);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : m_chunks)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (chunk.isInside(deallocation_ptr))<font></font>
            {<font></font>
                chunk.releaseBlock(deallocation_ptr);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;details::Chunk&lt;CHUNK_SIZE&gt;&gt; m_chunks{ <span class="hljs-number">1u</span> };<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ci-apr√®s, des conteneurs standard sont utilis√©s. </font><font style="vertical-align: inherit;">Je suis d'accord qu'il y aura beaucoup d'allocations du tas. </font><font style="vertical-align: inherit;">Je pense que pour ceux qui √©criront leurs allocateurs, ce sera inacceptable. </font><font style="vertical-align: inherit;">Bien s√ªr, vous pouvez √©galement √©crire vos propres conteneurs ou utiliser ceux de quelqu'un d'autre, aff√ªt√©s pour certains besoins, mais dans cette mise en ≈ìuvre, j'ai essay√© de pr√©senter le mat√©riel aussi facilement que possible, donc mon choix s'est port√© sur des conteneurs standard.</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">namespace</span> details<font></font>
{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-title">getAlignmentPadding</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> not_aligned_address, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> alignment)</span>
    </span>{
        <span class="hljs-keyword">if</span> ( (alignment != <span class="hljs-number">0u</span>) &amp;&amp; (not_aligned_address % alignment != <span class="hljs-number">0u</span>) )<font></font>
        {<font></font>
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> multiplier = (not_aligned_address / alignment) + <span class="hljs-number">1u</span>;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> aligned_address = multiplier * alignment;
            <span class="hljs-keyword">return</span> aligned_address - not_aligned_address;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0u</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Current chunk implementation works only with size</span>
    <span class="hljs-comment">// aligned by 4 bytes, because HEADER_SIZE now also 4 bytes.</span>
    <span class="hljs-comment">// You can modify it with HEADER_SIZE without problems for your purposes.</span><font></font>
<font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE&gt;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chunk</span>
    {</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> HEADER_SIZE = <span class="hljs-number">4u</span>;
        <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE % HEADER_SIZE == <span class="hljs-number">0</span>, <span class="hljs-string">"CHUNK_SIZE must be multiple of the four"</span>);
        <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE &gt; HEADER_SIZE, <span class="hljs-string">"CHUNK_SIZE must be more than HEADER_SIZE"</span>);
    <span class="hljs-keyword">public</span>:<font></font>
        Chunk()<font></font>
        {<font></font>
            m_blocks.resize(CHUNK_SIZE);<font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* init_header = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(m_blocks.data());<font></font>
            *init_header = CHUNK_SIZE - HEADER_SIZE;<font></font>
            m_max_block = init_header;<font></font>
            m_free_blocks.insert(init_header);<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isInside</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* address)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
        </span>{
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* start_chunk_address = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(m_blocks.data());
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* end_chunk_address = start_chunk_address + CHUNK_SIZE;
            <span class="hljs-keyword">return</span> (start_chunk_address &lt;= address) &amp;&amp; (address &lt;= end_chunk_address);<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* <span class="hljs-title">tryReserveBlock</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> allocation_size)</span>
        </span>{
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> not_aligned_address = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt;(m_max_block) + allocation_size;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> alignment_padding = getAlignmentPadding(not_aligned_address, HEADER_SIZE);
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> allocation_size_with_alignment = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;(allocation_size + alignment_padding);
            <span class="hljs-keyword">if</span> ( (!m_max_block) || (allocation_size_with_alignment &gt; *m_max_block) ) <span class="hljs-comment">// Check on enaught memory for allocation</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-comment">// Find min available by size memory block</span>
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> min_it = <span class="hljs-built_in">std</span>::min_element(m_free_blocks.cbegin(), m_free_blocks.cend(), [allocation_size_with_alignment] (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* rhs)<font></font>
            {<font></font>
                <span class="hljs-keyword">if</span> (*rhs &lt; allocation_size_with_alignment)<font></font>
                {<font></font>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
                }<font></font>
                <font></font>
                <span class="hljs-keyword">return</span> (*lhs &lt; *rhs) &amp;&amp; (*lhs &gt;= allocation_size_with_alignment);<font></font>
            });<font></font>
            <font></font>
            assert(min_it != m_free_blocks.cend() &amp;&amp; <span class="hljs-string">"Internal logic error with reserve block, something wrong in implementation..."</span>);<font></font>
            assert(**min_it &gt;= allocation_size_with_alignment &amp;&amp; <span class="hljs-string">"Internal logic error with reserve block, something wrong in implementation..."</span>);<font></font>
            <font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* header_address = *min_it;
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* new_header_address =
                <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(header_address) + HEADER_SIZE + allocation_size_with_alignment);
            <span class="hljs-keyword">if</span> (m_free_blocks.find(new_header_address) == m_free_blocks.cend()) <span class="hljs-comment">// check if there is free memory in the current block</span><font></font>
            {<font></font>
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> old_block_size = *header_address;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> difference = old_block_size - HEADER_SIZE;
                <span class="hljs-keyword">if</span> (difference &gt;= allocation_size_with_alignment) <span class="hljs-comment">// check if there is enough space for another block</span><font></font>
                {<font></font>
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> new_block_size = difference - allocation_size_with_alignment;<font></font>
                    *new_header_address = new_block_size;<font></font>
                    m_free_blocks.insert(new_header_address);<font></font>
                }<font></font>
            }<font></font>
            <font></font>
            m_free_blocks.erase(header_address);<font></font>
            *header_address = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;(allocation_size);
            <span class="hljs-keyword">if</span> (header_address == m_max_block) <span class="hljs-comment">// if the maximum block were changed, then need to find the maximum block again</span><font></font>
            {<font></font>
                <span class="hljs-comment">// Find max block by size</span>
                <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> max_it = <span class="hljs-built_in">std</span>::max_element(m_free_blocks.cbegin(), m_free_blocks.cend(), [] (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* rhs)<font></font>
                {<font></font>
                    <span class="hljs-keyword">return</span> (*lhs) &lt; (*rhs);<font></font>
                });<font></font>
                <font></font>
                <span class="hljs-comment">// If there are no free blocks, therefore the memory in this chunk is over</span>
                m_max_block = (max_it != m_free_blocks.cend()) ? (*max_it) : (<span class="hljs-literal">nullptr</span>);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(header_address) + HEADER_SIZE;<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">releaseBlock</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* block_ptr)</span>
        </span>{
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* header_address = block_ptr - HEADER_SIZE;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> size_relized_block = *header_address;
            <span class="hljs-keyword">if</span> ( (!m_max_block) || (size_relized_block &gt; *m_max_block) ) <span class="hljs-comment">// if the relized block is greater than the maximum, then need to replace it</span><font></font>
            {<font></font>
                m_max_block = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address);<font></font>
            }<font></font>
                <font></font>
            m_free_blocks.insert(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address));
            <span class="hljs-keyword">auto</span> forward_it = m_free_blocks.find(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address));
            <span class="hljs-keyword">auto</span> backward_it = tryDefragment(forward_it, m_free_blocks.end());<font></font>
            tryDefragment(<span class="hljs-built_in">std</span>::make_reverse_iterator(backward_it), m_free_blocks.rend());<font></font>
        }<font></font>
    <span class="hljs-keyword">private</span>:
        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> DstIterator, <span class="hljs-keyword">typename</span> SrcIterator&gt;
        <span class="hljs-keyword">constexpr</span> DstIterator <span class="hljs-title">getIterator</span><span class="hljs-params">(SrcIterator it)</span> <span class="hljs-keyword">const</span>
        </span>{
            <span class="hljs-keyword">using</span> iterator = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::iterator;
            <span class="hljs-keyword">using</span> reverse_iterator = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::reverse_iterator;
            <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">( (<span class="hljs-built_in">std</span>::is_same_v&lt;SrcIterator, iterator&gt;) &amp;&amp; (<span class="hljs-built_in">std</span>::is_same_v&lt;DstIterator, reverse_iterator&gt;) )</span>
            </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_reverse_iterator(it);<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">constexpr</span> ( (<span class="hljs-built_in">std</span>::is_same_v&lt;SrcIterator, reverse_iterator&gt;) &amp;&amp; (<span class="hljs-built_in">std</span>::is_same_v&lt;DstIterator, iterator&gt;) )<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> it.base();<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> it;<font></font>
            }<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;
        Iterator <span class="hljs-title">tryDefragment</span><span class="hljs-params">(Iterator start_it, Iterator end_it)</span>
        </span>{
            <span class="hljs-comment">// primitive defragmentation algorithm - connects two neighboring</span>
            <span class="hljs-comment">// free blocks into one with linear complexity</span><font></font>
   <font></font>
            <span class="hljs-keyword">auto</span> current_it = start_it++;
            <span class="hljs-keyword">auto</span> next_it = start_it;
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* current_header_address = *current_it;
            <span class="hljs-keyword">if</span> ( (current_it != end_it) &amp;&amp; (next_it != end_it) )<font></font>
            {<font></font>
                <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* next_header_address = *next_it;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> current_block_size = *current_header_address;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* available_current_block_address =
                    <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(current_header_address) + HEADER_SIZE + current_block_size);
                <span class="hljs-keyword">if</span> (available_current_block_address == next_header_address)<font></font>
                {<font></font>
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> next_block_size = *next_header_address;
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> new_current_block_size = current_block_size + HEADER_SIZE + next_block_size;<font></font>
                    *current_header_address = new_current_block_size;<font></font>
                    <span class="hljs-keyword">if</span> (new_current_block_size &gt; *m_max_block)<font></font>
                    {<font></font>
                        m_max_block = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(current_header_address);<font></font>
                    }<font></font>
                            <font></font>
                    <span class="hljs-keyword">auto</span> delete_it = getIterator&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::iterator&gt;(next_it);
                    <span class="hljs-keyword">return</span> getIterator&lt;Iterator&gt;(m_free_blocks.erase(delete_it));<font></font>
                }<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-keyword">return</span> current_it;<font></font>
        }<font></font>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt; m_blocks;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt; m_free_blocks;
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* m_max_block;<font></font>
    };<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, un peu sur la fa√ßon de d√©corer l'utilisation d'allocateurs avec des conteneurs standard: </font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE = <span class="hljs-number">16'384u</span>&gt;
<span class="hljs-keyword">using</span> CustomAllocator = Allocator&lt;T, CustomAllocationStrategy&lt;CHUNK_SIZE&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> CustomAllocatorWithStackChunks = Allocator&lt;T, CustomAllocationStrategy&lt;<span class="hljs-number">1'024u</span>&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> CustomAllocatorWithHeapChunks = Allocator&lt;T, CustomAllocationStrategy&lt;<span class="hljs-number">16'384u</span>&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_vector = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_list = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;T, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_set = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;T, <span class="hljs-built_in">std</span>::less&lt;T&gt;, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_unordered_set = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_set</span>&lt;T, <span class="hljs-built_in">std</span>::hash&lt;T&gt;, <span class="hljs-built_in">std</span>::equal_to&lt;T&gt;, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-keyword">using</span> custom_map = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;K, V, <span class="hljs-built_in">std</span>::less&lt;K&gt;, CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">const</span> K, V&gt;&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-keyword">using</span> custom_unordered_map = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;K, <span class="hljs-built_in">std</span>::hash&lt;K&gt;, <span class="hljs-built_in">std</span>::equal_to&lt;K&gt;, CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">const</span> K, V&gt;&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">using</span> custom_string = <span class="hljs-built_in">std</span>::basic_string&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">std</span>::char_traits&lt;<span class="hljs-keyword">char</span>&gt;, CustomAllocator&lt;<span class="hljs-keyword">char</span>&gt;&gt;;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez √©galement utiliser des allocateurs avec des pointeurs intelligents, mais pour cela, vous devrez √©crire une petite couche: </font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_unique_ptr = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;T, <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(T*)&gt;&gt;;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Allocator, <span class="hljs-keyword">typename</span> T </span>= <span class="hljs-keyword">typename</span> Allocator::value_type, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-function">custom_unique_ptr&lt;T&gt; <span class="hljs-title">make_custom_unique</span><span class="hljs-params">(Allocator allocator, Args&amp;&amp;... args)</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> custom_deleter = [allocator](T* ptr) <span class="hljs-keyword">mutable</span><font></font>
    {<font></font>
        allocator.destroy(ptr);<font></font>
        allocator.deallocate(ptr, <span class="hljs-number">1u</span>);<font></font>
    };<font></font>
        <font></font>
    <span class="hljs-keyword">void</span>* memory_block = allocator.allocate(<span class="hljs-number">1u</span>);
    <span class="hljs-keyword">if</span> (memory_block)<font></font>
    {<font></font>
        T* object_block = <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(memory_block);<font></font>
        allocator.construct(object_block, <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...);
        <span class="hljs-keyword">return</span> custom_unique_ptr&lt;T&gt;{ object_block, custom_deleter };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien et maintenant, enfin, un exemple d'utilisation de tout cela:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span>
</span>{<font></font>
    CustomAllocationStrategy allocation_area{};<font></font>
<font></font>
    CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt; custom_int_allocator{ allocation_area };<font></font>
    custom_vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">vector</span>{ custom_int_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0u</span>; i &lt; <span class="hljs-number">100</span>; ++i)<font></font>
    {<font></font>
        <span class="hljs-built_in">vector</span>.push_back(i);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">vector</span>.at(i) &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-built_in">vector</span>.resize(<span class="hljs-number">16u</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : <span class="hljs-built_in">vector</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
<font></font>
CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt; custom_int_allocator_copy = <span class="hljs-built_in">vector</span>.get_allocator();<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr1 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">100</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr2 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">500</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr3 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">1000</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr4 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">1500</span>);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *ptr1 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr2 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr3 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr4 &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-keyword">float</span>&gt; custom_float_allocator { custom_int_allocator };<font></font>
    custom_list&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-built_in">list</span>{ { <span class="hljs-number">10.0f</span>, <span class="hljs-number">11.0f</span>, <span class="hljs-number">12.0f</span>, <span class="hljs-number">13.0f</span>, <span class="hljs-number">14.0f</span>, <span class="hljs-number">15.0f</span> }, custom_float_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">float</span> val : <span class="hljs-built_in">list</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; custom_pair_allocator{ allocation_area };<font></font>
    custom_map&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt; <span class="hljs-built_in">map</span>{ { { <span class="hljs-number">1.0</span>, <span class="hljs-number">100.0</span> }, { <span class="hljs-number">2.0</span>, <span class="hljs-number">200.0</span> } }, custom_pair_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; it : <span class="hljs-built_in">map</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"{"</span> &lt;&lt; it.first &lt;&lt; <span class="hljs-string">" : "</span> &lt;&lt; it.second &lt;&lt; <span class="hljs-string">"} "</span>;<font></font>
    }<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-keyword">double</span>&gt; custom_double_allocator{ allocation_area };<font></font>
    custom_set&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-built_in">set</span>{ { <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">3000.0</span> }, custom_double_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">double</span> val : <span class="hljs-built_in">set</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
<font></font>
    CustomAllocator&lt;<span class="hljs-keyword">char</span>&gt; custom_char_allocator{ allocation_area };<font></font>
    custom_string string1{ <span class="hljs-string">"First allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string string2{ <span class="hljs-string">"Second allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string string3{ <span class="hljs-string">"Third allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string result_string = string1 + string2 + string3;<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; result_string;<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je voudrais me concentrer sur le fait que cette impl√©mentation est la plus primitive, mais elle peut √™tre facilement √©tendue dans la direction dont vous avez besoin, donc tout est entre vos mains!</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Merci de votre attention, j'esp√®re vraiment que cet article a √©t√© utile √† quelqu'un. </font><font style="vertical-align: inherit;">Je souhaite √©galement √† tous le succ√®s dans leur interaction √©troite avec la m√©moire, et surtout, n'oubliez pas les mots tr√®s importants de Donald Knuth: " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'optimisation pr√©matur√©e est la racine de tous les maux</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ." </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lien vers le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©f√©rentiel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec l'impl√©mentation compl√®te de l'allocateur.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sources utilis√©es</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/en/post/274827</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/mtrebi/memory-allocators</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr505614/index.html">Les taux des d√©p√¥ts des plus grandes banques sont tomb√©s √† un minimum historique: comment cela affecte-t-il l'√©conomie et o√π change-t-il</a></li>
<li><a href="../fr505616/index.html">Reconnaissance de l'alphabet russe: de la collecte d'un ensemble de donn√©es √† la cr√©ation d'une interface graphique</a></li>
<li><a href="../fr505618/index.html">Mod√®les GRASP: Cr√©ateur</a></li>
<li><a href="../fr505620/index.html">HackTheBox. Nest pas √† pas. Flux NTFS, marche arri√®re C # et SMB</a></li>
<li><a href="../fr505624/index.html">Comment traiter une trame de donn√©es avec des milliards d'enregistrements en quelques secondes?</a></li>
<li><a href="../fr505634/index.html">Param√®tres de proxy pour WSL (Ubuntu)</a></li>
<li><a href="../fr505640/index.html">√âvaluation de la publication Objectivit√©</a></li>
<li><a href="../fr505642/index.html">Coroutines transparentes</a></li>
<li><a href="../fr505644/index.html">Les titulaires de droits d'auteur ont essay√©: les le√ßons de clips vid√©o de YouTube avec l'analyse des chansons d'autres personnes pourraient dispara√Ætre</a></li>
<li><a href="../fr505648/index.html">Les deux erreurs d'Einstein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>