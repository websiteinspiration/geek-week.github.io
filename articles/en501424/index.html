<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüöí üöî ‚õπÔ∏è From life with Kubernetes: How we removed DBMS (and not only) from review environments to static üìí üöØ üë≤üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note : this article does not claim to be a best practice. It describes the experience of a specific implementation of an infrastructure task in terms ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>From life with Kubernetes: How we removed DBMS (and not only) from review environments to static</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/501424/"><img src="https://habrastorage.org/webt/ae/yu/zw/aeyuzw9pz0k6d0pbc0g86pxkfd0.png"><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : this article does not claim to be a best practice. </font><font style="vertical-align: inherit;">It describes the experience of a specific implementation of an infrastructure task in terms of using Kubernetes and Helm, which can be useful in solving related problems. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using review environments in CI / CD can be very useful, both for developers and system engineers. </font><font style="vertical-align: inherit;">Let's first synchronize the general ideas about them:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Review environments can be created from separate branches in Git repositories defined by developers (the so-called feature branches).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">They can have separate DBMS instances, queue processors, caching services, etc. </font><font style="vertical-align: inherit;">- in general, everything for the full reproduction of the production environment.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">They allow parallel development, significantly accelerating the release of new features in the application. </font><font style="vertical-align: inherit;">At the same time, dozens of such environments may be required every day, which is why the speed of their creation is critical.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the intersection of the second and third points, difficulties often arise: since the infrastructure is very different, its components can be deployed for a long time. </font><font style="vertical-align: inherit;">This time spent, for example, includes restoring the database from an already prepared backup *. </font><font style="vertical-align: inherit;">The article is about the fascinating way we once went to solve such a problem.</font></font><a name="habracut"></a><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* By the way, specifically about large database dumps in this context, we already wrote in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">material about accelerating the bootstrap database</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .)</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem and the way to solve it</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In one of the projects, we were given the task of "creating a single entry point for developers and QA engineers." </font><font style="vertical-align: inherit;">This formulation hid technically the following:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To simplify the work of QA-engineers and some other employees, take out all the databases (and corresponding vhosts) used in the review, in a separate - static - environment. </font><font style="vertical-align: inherit;">For the reasons prevailing in the project, this way of interacting with them was optimal.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reduce the time it takes to create a review environment. </font><font style="vertical-align: inherit;">The whole process of their creation from scratch is implied, i.e. </font><font style="vertical-align: inherit;">including database cloning, migrations, etc.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From the point of view of implementation, the main problem is to ensure idempotency when creating and deleting review environments. To achieve this, we changed the mechanism for creating review environments by first migrating the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQL, MongoDB, and RabbitMQ services</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to a static environment. Static refers to such a ‚Äúpermanent‚Äù environment that will not be created at the request of the user (as is the case with review environments). </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Important!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The approach with a static environment is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">far from ideal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - for its specific shortcomings, see the end of the article. However, we share this experience in detail, since it can be more or less applicable in other tasks, and at the same time serve as an argument when discussing infrastructure design issues.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, the sequence of actions in the implementation:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When creating a review environment, the following should happen once: the creation of databases in two DBMSs (MongoDB and PostgreSQL), the restoration of databases from a backup / template, and the creation of vhost in RabbitMQ. </font><font style="vertical-align: inherit;">This will require a convenient way to load current dumps. </font><font style="vertical-align: inherit;">(If you had review environments before, then most likely you already have a ready-made solution for this.)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After completion of the review environment, you must delete the database and virtual host in RabbitMQ.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our case, the infrastructure operates within the framework of Kubernetes (using Helm). </font><font style="vertical-align: inherit;">Therefore, for the implementation of the above tasks, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Helm hooks were</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> excellent </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">They can be performed both before the creation of all other components in the Helm release, and / or after their removal. </font><font style="vertical-align: inherit;">Therefore:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for the initialization task, we will use a hook </font></font><code>pre-install</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to launch it before creating all the resources in the release;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for the delete task, a hook </font></font><code>post-delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's move on to implementation details.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Practical implementation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the original version, this project used only one Job, consisting of three containers. </font><font style="vertical-align: inherit;">Of course, this is not entirely convenient, as the result is a large manifest that is corny difficult to read. </font><font style="vertical-align: inherit;">Therefore, we divided it into three small jobs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following is a listing for PostgreSQL, and the other two (MongoDB and RabbitMQ) are identical in manifest structure:</font></font><br>
<br>
<pre><code class="plaintext hljs">{{- if .Values.global.review }}<font></font>
---<font></font>
apiVersion: batch/v1<font></font>
kind: Job<font></font>
metadata:<font></font>
  name: db-create-postgres-database<font></font>
  annotations:<font></font>
    "helm.sh/hook": "pre-install"<font></font>
    "helm.sh/hook-weight": "5"<font></font>
spec:<font></font>
  template:<font></font>
    metadata:<font></font>
      name: init-db-postgres<font></font>
    spec:<font></font>
      volumes:<font></font>
      - name: postgres-scripts<font></font>
        configMap:<font></font>
          defaultMode: 0755<font></font>
          name: postgresql-configmap<font></font>
      containers:<font></font>
      - name: init-postgres-database<font></font>
        image: private-registry/postgres <font></font>
        command: ["/docker-entrypoint-initdb.d/01-review-load-dump.sh"]<font></font>
        volumeMounts:<font></font>
        - name: postgres-scripts<font></font>
          mountPath: /docker-entrypoint-initdb.d/01-review-load-dump.sh<font></font>
          subPath: review-load-dump.sh<font></font>
        env:<font></font>
{{- include "postgres_env" . | indent 8 }}<font></font>
      restartPolicy: Never<font></font>
{{- end }}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comments on the contents of the manifest:</font></font><br>
<br>
<ol>
<li> Job    review-.  review   CI/CD       Helm- (. <code>if</code>  <code>.Values.global.review</code>    ).</li>
<li>  Job      ‚Äî , ConfigMap.       ,  ,       .       ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><code>hook-weight</code></a>.</li>
<li>      cURL   ,        PostgreSQL,       .</li>
<li>      PostgreSQL    :     ,     shell- .</li>
</ol><br>
<h3>PostgreSQL</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The most interesting is in the shell script ( </font></font><code>review-load-dump.sh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">already mentioned in the listing </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">What are the general options for restoring a database in PostgreSQL?</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Standard" recovery from backup;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recovery using </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">templates</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our case, the difference between the two approaches is primarily in the speed of creating a database for the new environment. </font><font style="vertical-align: inherit;">In the first - we load the database dump and restore it with </font></font><code>pg_restore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And with us this happens more slowly than the second method, so the corresponding choice was made. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using the second option ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recovery with templates</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) you can clone the database at the physical level without sending data to it remotely from the container in another environment - this reduces the recovery time. </font><font style="vertical-align: inherit;">However, there is a limitation: you cannot clone a database to which active connections remain. </font><font style="vertical-align: inherit;">Since we use stage as the static environment (and not a separate review environment), we need to create a second database and convert it to a template, updating it daily (for example, in the morning). </font><font style="vertical-align: inherit;">A small CronJob was prepared for this:</font></font><br>
<br>
<pre><code class="plaintext hljs">---<font></font>
apiVersion: batch/v1beta1<font></font>
kind: CronJob<font></font>
metadata:<font></font>
  name: update-postgres-template<font></font>
spec:<font></font>
  schedule: "50 4 * * *"<font></font>
  concurrencyPolicy: Forbid<font></font>
  successfulJobsHistoryLimit: 3<font></font>
  failedJobsHistoryLimit: 3<font></font>
  startingDeadlineSeconds: 600<font></font>
  jobTemplate:<font></font>
    spec:<font></font>
      template:<font></font>
        spec:<font></font>
          restartPolicy: Never<font></font>
          imagePullSecrets:<font></font>
          - name: registrysecret<font></font>
          volumes:<font></font>
          - name: postgres-scripts<font></font>
            configMap:<font></font>
              defaultMode: 0755<font></font>
              name: postgresql-configmap-update-cron<font></font>
          containers:<font></font>
          - name: cron<font></font>
            command: ["/docker-entrypoint-initdb.d/update-postgres-template.sh"]<font></font>
          image: private-registry/postgres <font></font>
            volumeMounts:<font></font>
            - name: postgres-scripts<font></font>
              mountPath: /docker-entrypoint-initdb.d/update-postgres-template.sh<font></font>
              subPath: update-postgres-template.sh<font></font>
            env:<font></font>
{{- include "postgres_env" . | indent 8 }}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The full ConfigMap manifest containing the script most likely does not make much sense (report in the comments if this is not the case). </font><font style="vertical-align: inherit;">Instead, I will give the most important thing - a bash script:</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-comment">#!/bin/bash -x</span><font></font>
<font></font>
CREDENTIALS=<span class="hljs-string">"postgresql://<span class="hljs-variable">${POSTGRES_USER}</span>:<span class="hljs-variable">${POSTGRES_PASSWORD}</span>@<span class="hljs-variable">${POSTGRES_HOST}</span>/postgres"</span><font></font>
<font></font>
psql -d <span class="hljs-string">"<span class="hljs-variable">${CREDENTIALS}</span>"</span> -w -c <span class="hljs-string">"REVOKE CONNECT ON DATABASE <span class="hljs-variable">${POSTGRES_DB_TEMPLATE}</span> FROM public"</span>
psql -d <span class="hljs-string">"<span class="hljs-variable">${CREDENTIALS}</span>"</span> -w -c <span class="hljs-string">"SELECT pg_terminate_backend(pg_stat_activity.pid) FROM pg_stat_activity WHERE pg_stat_activity.datname = '<span class="hljs-variable">${POSTGRES_DB_TEMPLATE}</span>'"</span><font></font>
<font></font>
curl --fail -vsL <span class="hljs-variable">${HOST_FORDEV}</span>/latest_<span class="hljs-variable">${POSTGRES_DB_STAGE}</span>.psql -o /tmp/<span class="hljs-variable">${POSTGRES_DB}</span>.psql<font></font>
<font></font>
psql -d <span class="hljs-string">"<span class="hljs-variable">${CREDENTIALS}</span>"</span> -w -c <span class="hljs-string">"ALTER DATABASE <span class="hljs-variable">${POSTGRES_DB_TEMPLATE}</span> WITH is_template false allow_connections true;"</span>
psql -d <span class="hljs-string">"<span class="hljs-variable">${CREDENTIALS}</span>"</span> -w -c <span class="hljs-string">"DROP DATABASE <span class="hljs-variable">${POSTGRES_DB_TEMPLATE}</span>;"</span> || <span class="hljs-literal">true</span>
psql -d <span class="hljs-string">"<span class="hljs-variable">${CREDENTIALS}</span>"</span> -w -c <span class="hljs-string">"CREATE DATABASE <span class="hljs-variable">${POSTGRES_DB_TEMPLATE}</span>;"</span> || <span class="hljs-literal">true</span>
pg_restore -U <span class="hljs-variable">${POSTGRES_USER}</span> -h <span class="hljs-variable">${POSTGRES_HOST}</span> -w -j 4 -d <span class="hljs-variable">${POSTGRES_DB_TEMPLATE}</span> /tmp/<span class="hljs-variable">${POSTGRES_DB}</span>.psql<font></font>
<font></font>
psql -d <span class="hljs-string">"<span class="hljs-variable">${CREDENTIALS}</span>"</span> -w -c <span class="hljs-string">"ALTER DATABASE <span class="hljs-variable">${POSTGRES_DB_TEMPLATE}</span> WITH is_template true allow_connections false;"</span><font></font>
<font></font>
rm -v /tmp/<span class="hljs-variable">${POSTGRES_DB}</span>.psql</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can restore several databases at once from one template without any conflicts. </font><font style="vertical-align: inherit;">The main thing is that database connections should be prohibited, and the database itself should be a template. </font><font style="vertical-align: inherit;">This is done in the penultimate step. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The manifest containing the shell script for restoring the database turned out like this:</font></font><br>
<br>
<pre><code class="plaintext hljs">---<font></font>
apiVersion: v1<font></font>
kind: ConfigMap<font></font>
metadata:<font></font>
  name: postgresql-configmap<font></font>
  annotations:<font></font>
    "helm.sh/hook": "pre-install"<font></font>
    "helm.sh/hook-weight": "1"<font></font>
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded<font></font>
data:<font></font>
  review-load-dump.sh: |<font></font>
    #!/bin/bash -x<font></font>
    <font></font>
 <font></font>
 <font></font>
    CREDENTIALS="postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${POSTGRES_HOST}/postgres"<font></font>
<font></font>
    if [ "$( psql -d "${CREDENTIALS}" -tAc "SELECT CASE WHEN EXISTS (SELECT * FROM pg_stat_activity WHERE datname = '${POSTGRES_DB}' LIMIT 1) THEN 1 ELSE 0 END;" )" = '1' ]<font></font>
      then<font></font>
          echo "Open connections has been found in ${POSTGRES_DB} database, will drop them"<font></font>
          psql -d "${CREDENTIALS}" -c "SELECT pg_terminate_backend(pg_stat_activity.pid) FROM pg_stat_activity WHERE pg_stat_activity.datname = '${POSTGRES_DB}' -- AND pid &lt;&gt; pg_backend_pid();"<font></font>
      else<font></font>
          echo "No open connections has been found ${POSTGRES_DB} database, skipping this stage"<font></font>
    fi<font></font>
<font></font>
    psql -d "${CREDENTIALS}" -c "DROP DATABASE ${POSTGRES_DB}"<font></font>
<font></font>
    if [ "$( psql -d "${CREDENTIALS}" -tAc "SELECT 1 FROM pg_database WHERE datname='${POSTGRES_DB}'" )" = '1' ]<font></font>
      then<font></font>
          echo "Database ${POSTGRES_DB} still exists, delete review job failed"<font></font>
          exit 1<font></font>
      else<font></font>
          echo "Database ${POSTGRES_DB} does not exist, skipping"<font></font>
    fi<font></font>
<font></font>
<font></font>
    psql ${CREDENTIALS} -d postgres -c 'CREATE DATABASE ${POSTGRES_DB} TEMPLATE "loot-stage-copy"'</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apparently, they are involved here </font></font><code>hook-delete-policy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Details on the application of these policies are written </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In the given manifest we use </font></font><code>before-hook-creation,hook-succeeded</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which allow to fulfill the following requirements: delete the previous object before creating a new hook and delete only when the hook was successful. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will delete the database in this ConfigMap:</font></font><br>
<br>
<pre><code class="plaintext hljs">---<font></font>
apiVersion: v1<font></font>
kind: ConfigMap<font></font>
metadata:<font></font>
  name: postgresql-configmap-on-delete<font></font>
  annotations:<font></font>
    "helm.sh/hook": "post-delete, pre-delete"<font></font>
    "helm.sh/hook-weight": "1"<font></font>
    "helm.sh/hook-delete-policy": before-hook-creation<font></font>
data:<font></font>
  review-delete-db.sh: |<font></font>
    #!/bin/bash -e<font></font>
<font></font>
    CREDENTIALS="postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${POSTGRES_HOST}/postgres"<font></font>
<font></font>
    psql -d "${CREDENTIALS}" -w postgres -c "DROP DATABASE ${POSTGRES_DB}"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although we moved it to a separate ConfigMap, it can be placed in a regular ConfigMap </font></font><code>command</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">After all, it can be made a one-liner without complicating the appearance of the manifest itself. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the option with PostgreSQL templates for some reason does not suit or does not fit, you can return to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"standard" recovery path</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mentioned above </font><b><font style="vertical-align: inherit;">using backup</font></b><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The algorithm will be trivial:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Every night, a database backup is made so that it can be downloaded from the local network of the cluster.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> At the time of creation of the review environment, the database is loaded and restored from the dump.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When the dump is deployed, all other actions are performed.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, the recovery script will become approximately as follows:</font></font><br>
<br>
<pre><code class="plaintext hljs">---<font></font>
apiVersion: v1<font></font>
kind: ConfigMap<font></font>
metadata:<font></font>
  name: postgresql-configmap<font></font>
  annotations:<font></font>
    "helm.sh/hook": "pre-install"<font></font>
    "helm.sh/hook-weight": "1"<font></font>
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded<font></font>
data:<font></font>
  review-load-dump.sh: |<font></font>
    #!/bin/bash -x<font></font>
<font></font>
    CREDENTIALS="postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${POSTGRES_HOST}/postgres"<font></font>
    psql -d "${CREDENTIALS}" -w -c "DROP DATABASE ${POSTGRES_DB}" || true<font></font>
    psql -d "${CREDENTIALS}" -w -c "CREATE DATABASE ${POSTGRES_DB}"<font></font>
<font></font>
    curl --fail -vsL ${HOST_FORDEV}/latest_${POSTGRES_DB_STAGE}.psql -o /tmp/${POSTGRES_DB}.psql<font></font>
<font></font>
    psql psql -d "${CREDENTIALS}" -w -c "CREATE EXTENSION ip4r;"<font></font>
    pg_restore -U ${POSTGRES_USER} -h ${POSTGRES_HOST} -w -j 4 -d ${POSTGRES_DB} /tmp/${POSTGRES_DB}.psql<font></font>
    rm -v /tmp/${POSTGRES_DB}.psql</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The procedure corresponds to what has already been described above. The only change is the removal of the psql file after all the work has been added. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : both in the recovery script and in the uninstall script, the database is deleted every time. This is done to avoid possible conflicts during the re-creation of review: you must make sure that the database is really deleted. Also, this problem can potentially be solved by adding a flag </font></font><code>--clean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the utility </font></font><code>pg_restore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but be careful: this flag clears the data of only those elements that are in the dump itself, so in our case this option does not work.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, we got a working mechanism that requires further improvements (up to replacing Bash scripts with more elegant code). </font><font style="vertical-align: inherit;">We will leave them outside the scope of the article (although comments on the topic, of course, are welcome).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mongodb</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The next component is MongoDB. </font><font style="vertical-align: inherit;">The main difficulty with it is that for this DBMS, the option of copying the database (as in PostgreSQL) exists rather nominally, because:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">He is in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a deprecated state</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">According to the results of our testing, we did not find a big difference in the time of database recovery compared to the usual one </font></font><code>mongo_restore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, I note that testing was carried out as part of one project - in your case, the results can be completely different.</font></font></i></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It turns out that in the case of a large database volume, a serious problem may arise: we save time on restoring the database in PgSQL, but at the same time restore the dump in Mongo for a very long time. </font><font style="vertical-align: inherit;">At the time of writing, and within the framework of the existing infrastructure, we saw three ways (by the way, they can be combined):</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recovery can take a long time, for example, if your DBMS is located on a network file system (for cases </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with production environment). </font><font style="vertical-align: inherit;">Then you can simply transfer the DBMS from stage to a separate node and use local storage. </font><font style="vertical-align: inherit;">Since this is not production, the speed of creating a review is more critical for us.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can take each Job recovery to a separate pod, allowing you to pre-execute migrations and other processes that depend on the operation of the DBMS. </font><font style="vertical-align: inherit;">So we save time by completing them in advance.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sometimes you can reduce the size of the dump by deleting old / irrelevant data - up to the point that it is enough to leave only the database structure. </font><font style="vertical-align: inherit;">Of course, this is not for those cases when a full dump is required (say, for QA testing tasks).</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you do not need to quickly create review environments, then all the described difficulties can be ignored. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We, being unable to copy the database similarly to PgSQL, will go the first way, i.e. </font><font style="vertical-align: inherit;">standard recovery from backup. </font><font style="vertical-align: inherit;">The algorithm is the same as with PgSQL. </font><font style="vertical-align: inherit;">This is easy to see if you look at the manifestos:</font></font><br>
<br>
<pre><code class="plaintext hljs">---<font></font>
apiVersion: v1<font></font>
kind: ConfigMap<font></font>
metadata:<font></font>
  name: mongodb-scripts-on-delete<font></font>
  annotations:<font></font>
    "helm.sh/hook": "post-delete, pre-delete"<font></font>
    "helm.sh/hook-weight": "1"<font></font>
    "helm.sh/hook-delete-policy": before-hook-creation<font></font>
data:<font></font>
  review-delete-db.sh: |<font></font>
    #!/bin/bash -x<font></font>
<font></font>
    mongo ${MONGODB_NAME} --eval "db.dropDatabase()" --host ${MONGODB_REPLICASET}/${MONGODB_HOST}<font></font>
---<font></font>
apiVersion: v1<font></font>
kind: ConfigMap<font></font>
metadata:<font></font>
  name: mongodb-scripts<font></font>
  annotations:<font></font>
    "helm.sh/hook": "pre-install"<font></font>
    "helm.sh/hook-weight": "1"<font></font>
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded<font></font>
data:<font></font>
  review-load-dump.sh: |<font></font>
    #!/bin/bash -x<font></font>
<font></font>
    curl --fail -vsL ${HOST_FORDEV}/latest_${MONGODB_NAME_STAGE}.gz -o /tmp/${MONGODB_NAME}.gz<font></font>
<font></font>
    mongo ${MONGODB_NAME} --eval "db.dropDatabase()" --host ${MONGODB_REPLICASET}/${MONGODB_HOST}<font></font>
    mongorestore --gzip --nsFrom "${MONGODB_NAME_STAGE}.*" --nsTo "${MONGODB_NAME}.*" --archive=/tmp/${MONGODB_NAME}.gz --host ${MONGODB_REPLICASET}/${MONGODB_HOST}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is an important detail here. In our case, MongoDB is in the cluster and you need to be sure that the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">connection always happens to the Primary node</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . If you specify, for example, the first host in the quorum, then after some time it may switch from Primary to Secondary, which will prevent the creation of a database. Therefore, you need to connect not to one host, but immediately to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReplicaSet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , listing all the hosts in it. For this reason alone, you need to make MongoDB as a StatefulSet so that host names are always the same (not to mention that MongoDB is a stateful application by nature). In this option, you are guaranteed to connect to the Primary node. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For MongoDB, we also delete the database before creating the review - this is done for the same reasons as in PostgreSQL.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Last nuance: since the database for review is in the same environment as stage, a separate name is required for the cloned database. </font><font style="vertical-align: inherit;">If the dump is not a BSON file, the following error will occur:</font></font><br>
<br>
<pre><code class="plaintext hljs">the --db and --collection args should only be used when restoring from a BSON file. Other uses are deprecated and will not exist in the future; use --nsInclude instead</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, in the example above, </font></font><code>--nsFrom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">are used </font></font><code>--nsTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We did not meet other problems with recovery. </font><font style="vertical-align: inherit;">In the end, I‚Äôll only add that the documentation for </font></font><code>copyDatabase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MongoDB is available </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - in case you want to try this option.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rabbitmq</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The last application on our list of requirements was RabbitMQ. </font><font style="vertical-align: inherit;">It‚Äôs simple with it: you need to create a new vhost on behalf of the user with whom the application will connect. </font><font style="vertical-align: inherit;">And then delete it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manifesto for creating and removing vhosts:</font></font><br>
<br>
<pre><code class="plaintext hljs">---<font></font>
apiVersion: v1<font></font>
kind: ConfigMap<font></font>
metadata:<font></font>
  name: rabbitmq-configmap<font></font>
  annotations:<font></font>
    "helm.sh/hook": "pre-install"<font></font>
    "helm.sh/hook-weight": "1"<font></font>
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded<font></font>
data:<font></font>
  rabbitmq-setup-vhost.sh: |<font></font>
    #!/bin/bash -x<font></font>
<font></font>
    /usr/local/bin/rabbitmqadmin -H ${RABBITMQ_HOST} -u ${RABBITMQ_USER} -p ${RABBITMQ_PASSWORD} declare vhost name=${RABBITMQ_VHOST}<font></font>
---<font></font>
apiVersion: v1<font></font>
kind: ConfigMap<font></font>
metadata:<font></font>
  name: rabbitmq-configmap-on-delete<font></font>
  annotations:<font></font>
    "helm.sh/hook": "post-delete, pre-delete"<font></font>
    "helm.sh/hook-weight": "1"<font></font>
    "helm.sh/hook-delete-policy": before-hook-creation<font></font>
data:<font></font>
  rabbitmq-delete-vhost.sh: |<font></font>
    #!/bin/bash -x<font></font>
<font></font>
    /usr/local/bin/rabbitmqadmin -H ${RABBITMQ_HOST} -u ${RABBITMQ_USER} -p ${RABBITMQ_PASSWORD} delete vhost name=${RABBITMQ_VHOST}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With big difficulties in RabbitMQ we (so far?) Have not encountered. </font><font style="vertical-align: inherit;">In general, the same approach can apply to any other services that do not have a critical tie for data.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disadvantages</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why does this decision not claim to be ‚Äúbest practices‚Äù?</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It turns out a single point of failure in the form of a stage environment.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If an application in a stage environment runs only in one replica, we become even more dependent on the host on which this application runs. </font><font style="vertical-align: inherit;">Accordingly, with an increase in the number of review environments, the load on the node proportionally increases without the ability to balance this load.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It was not possible to fully solve these two problems, taking into account the capabilities of the infrastructure of a particular project, however, clustering (adding new nodes) and vertical scaling can minimize potential damage. </font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As the application develops and with the increase in the number of developers, sooner or later, the load on review environments increases and new requirements are added to them. It is important for developers to deliver the next changes in production as quickly as possible, but to make this possible, we need dynamic review environments that make development ‚Äúparallel‚Äù. As a result, the load on the infrastructure is growing, and the time for creating such environments is increasing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This article was written based on real and rather specific experience. Only in exceptional cases do we isolate any services in static environments, and here it was specifically about him. Such a necessary measure allowed us to accelerate the development and debugging of the application - thanks to the ability to quickly create review environments from scratch.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When we started to do this task, it seemed very simple, but as we worked on it, we found many nuances. </font><font style="vertical-align: inherit;">It was they who were assembled in the final article: even if they are not universal, they can serve as an example for the basis / inspiration of their own decisions on accelerating review environments.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Read also in our blog:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äú </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes tips &amp; tricks: speeding up the bootstrap of large databases</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äú </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unobstructed RabbitMQ migration to Kubernetes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unobstructed MongoDB migration to Kubernetes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ";</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äú </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Running teams in the process of delivering a new application release to Kubernetes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .‚Äù</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en501412/index.html">Mobile eye-tracking on PyTorch</a></li>
<li><a href="../en501414/index.html">Configuring Debian, Nginx, and Gunicorn for a Django Project</a></li>
<li><a href="../en501416/index.html">A bit about WebRTC: what to use and the case from practice</a></li>
<li><a href="../en501418/index.html">Week 4 Marathon: Motivation</a></li>
<li><a href="../en501420/index.html">Online Mitapas and YouTube Shows: JUG Ru Group Stream Week</a></li>
<li><a href="../en501426/index.html">Unison: setting up and automating two-way synchronization of directories on two servers</a></li>
<li><a href="../en501430/index.html">Great Guide to Website Content Design and Planning</a></li>
<li><a href="../en501432/index.html">Two alternatives to JDBC</a></li>
<li><a href="../en501434/index.html">Security Week 20: hacking a computer through Thunderbolt</a></li>
<li><a href="../en501436/index.html">Number recognition algorithm on the image with a low probability of the second kind of error</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>