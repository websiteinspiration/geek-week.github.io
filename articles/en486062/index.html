<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéæ üî¶ üõçÔ∏è Simple zero-copy rendering of hardware accelerated video in QML üêº üèÇüèº üë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction
 

The purpose of this article is to demonstrate how you can make friends with third-party video buffers and QML. The main idea is to use...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Simple zero-copy rendering of hardware accelerated video in QML</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486062/"><h2 id="vvedenie"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introduction</font></font></h2><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The purpose of this article is to demonstrate how you can make friends with third-party video buffers and QML. </font><font style="vertical-align: inherit;">The main idea is to use the standard QML component of VideoOutput. </font><font style="vertical-align: inherit;">It allows you to palm off third-party sources, it is well documented and has a backend supporting GL_OES_EGL_image_external.</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The idea that this might suddenly be useful arose after I tried to run examples of working with the camera in Qt, and on the embedded platform they worked at a speed of 3-5 frames per second. It became clear that out of the box there was no question of any zero-copy, although the platform supports all this very well. In fairness, on the desktop, VideoOutput and Camera work, as expected, quickly and without unnecessary copying. But in my task, alas, it was impossible to do with the existing classes for capturing video, and I wanted to get video from a third-party source, which could be an arbitrary GStreamer pipeline for decoding video, for example, from a file or RTSP stream, or a third-party API that can be integrated into the base Qt's classes are somewhat dubious. You can, of course, once again reinvent the wheel and write your component with drawing through OpenGL,but it immediately seemed a deliberately dead end and complicated way.</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything led to the fact that you need to figure out how it really works, and write a small application confirming the theory.</font></font></p><a name="habracut"></a><br>
<h2 id="teoriya"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Theory</font></font></h2><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoOutput supports custom source, provided that </font></font></p><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the passed object can accept QAbstractVideoSurface directly through the videoSurface property </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or through mediaObject with QVideoRendererControl </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[link]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
</ol><br>
<p>     ,   QtMultimedia   QAbstractVideoBuffer     ,   QPixmap   GLTexture  EGLImage.      videonode_egl,          samplerExternalOES.  ,        QAbstractVideoBuffer  EGLImage,        videnode_egl.<br>
  EGLImage   ,         ,        .</p><br>
<h2 id="realizaciya"></h2><br>
<p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">Video Overview</a>.</p><br>
<p>   Qt   OpenGL ES  ,   Qt   .  ,     .</p><br>
<p>     ,        GStreamer :</p><br>
<pre><code class="bash hljs">v4l2src ! appsink</code></pre><br>
<p>  V4L2Source,        QAbstractVideoSurface.</p><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">V4L2Source</span> :</span> <span class="hljs-keyword">public</span> QQuickItem<font></font>
{<font></font>
    <span class="hljs-function">Q_OBJECT
    <span class="hljs-title">Q_PROPERTY</span><span class="hljs-params">(QAbstractVideoSurface* videoSurface READ videoSurface WRITE
                   setVideoSurface)</span>
    <span class="hljs-title">Q_PROPERTY</span><span class="hljs-params">(QString device MEMBER m_device READ device WRITE setDevice)</span>
    <span class="hljs-title">Q_PROPERTY</span><span class="hljs-params">(QString caps MEMBER m_caps)</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">V4L2Source</span><span class="hljs-params">(QQuickItem* parent = <span class="hljs-literal">nullptr</span>)</span></span>;
    <span class="hljs-keyword">virtual</span> ~V4L2Source();<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setVideoSurface</span><span class="hljs-params">(QAbstractVideoSurface* surface)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDevice</span><span class="hljs-params">(QString device)</span></span>;<font></font>
<font></font>
<span class="hljs-keyword">public</span> slots:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
<span class="hljs-keyword">private</span> slots:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setWindow</span><span class="hljs-params">(QQuickWindow* win)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sync</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
signals:<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">frameReady</span><span class="hljs-params">()</span></span>;<font></font>
...<font></font>
}</code></pre><br>
<p>  ,   setWinow() ‚Äî      QQuickItem::windowChanged()   callback  QQuickWindow::beforeSynchronizing().</p><br>
<p>   VideoOutput      EGLImage,     QAbstractVideoSurface     QAbstractVideoBuffer::HandleType  :</p><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">V4L2Source::setVideoSurface</span><span class="hljs-params">(QAbstractVideoSurface* surface)</span>
</span>{
    <span class="hljs-keyword">if</span> (m_surface != surface &amp;&amp; m_surface &amp;&amp; m_surface-&gt;isActive()) {<font></font>
        m_surface-&gt;stop();<font></font>
    }<font></font>
    m_surface = surface;<font></font>
    <span class="hljs-keyword">if</span> (surface<font></font>
            -&gt;supportedPixelFormats(<font></font>
                QAbstractVideoBuffer::HandleType::EGLImageHandle)<font></font>
            .size() &gt; <span class="hljs-number">0</span>) {<font></font>
        EGLImageSupported = <span class="hljs-literal">true</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        EGLImageSupported = <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (m_surface &amp;&amp; m_device.length() &gt; <span class="hljs-number">0</span>) {<font></font>
        start();<font></font>
    }<font></font>
}</code></pre><br>
<p>  ,    callback':</p><br>
<pre><code class="cpp hljs">GstAppSinkCallbacks V4L2Source::callbacks = {.eos = <span class="hljs-literal">nullptr</span>,<font></font>
                                             .new_preroll = <span class="hljs-literal">nullptr</span>,<font></font>
                                             .new_sample =<font></font>
                                                 &amp;V4L2Source::on_new_sample};<font></font>
<font></font>
V4L2Source::V4L2Source(QQuickItem* parent) : QQuickItem(parent)<font></font>
{<font></font>
    m_surface = <span class="hljs-literal">nullptr</span>;<font></font>
    connect(<span class="hljs-keyword">this</span>, &amp;QQuickItem::windowChanged, <span class="hljs-keyword">this</span>, &amp;V4L2Source::setWindow);<font></font>
<font></font>
    pipeline = gst_pipeline_new(<span class="hljs-string">"V4L2Source::pipeline"</span>);<font></font>
    v4l2src = gst_element_factory_make(<span class="hljs-string">"v4l2src"</span>, <span class="hljs-literal">nullptr</span>);<font></font>
    appsink = gst_element_factory_make(<span class="hljs-string">"appsink"</span>, <span class="hljs-literal">nullptr</span>);<font></font>
<font></font>
    GstPad* pad = gst_element_get_static_pad(appsink, <span class="hljs-string">"sink"</span>);<font></font>
    gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_QUERY_BOTH, appsink_pad_probe,<font></font>
                      <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<font></font>
    gst_object_unref(pad);<font></font>
<font></font>
    gst_app_sink_set_callbacks(GST_APP_SINK(appsink), &amp;callbacks, <span class="hljs-keyword">this</span>,
                               <span class="hljs-literal">nullptr</span>);<font></font>
<font></font>
    gst_bin_add_many(GST_BIN(pipeline), v4l2src, appsink, <span class="hljs-literal">nullptr</span>);<font></font>
    gst_element_link(v4l2src, appsink);<font></font>
<font></font>
    context = g_main_context_new();<font></font>
    loop = g_main_loop_new(context, FALSE);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">V4L2Source::setWindow</span><span class="hljs-params">(QQuickWindow* win)</span>
</span>{
    <span class="hljs-keyword">if</span> (win) {<font></font>
        connect(win, &amp;QQuickWindow::beforeSynchronizing, <span class="hljs-keyword">this</span>,<font></font>
                &amp;V4L2Source::sync, Qt::DirectConnection);<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-function">GstFlowReturn <span class="hljs-title">V4L2Source::on_new_sample</span><span class="hljs-params">(GstAppSink* sink, gpointer data)</span>
</span>{<font></font>
    Q_UNUSED(sink)<font></font>
    V4L2Source* self = (V4L2Source*)data;<font></font>
    <span class="hljs-function">QMutexLocker <span class="hljs-title">locker</span><span class="hljs-params">(&amp;self-&gt;mutex)</span></span>;<font></font>
    self-&gt;ready = <span class="hljs-literal">true</span>;<font></font>
    self-&gt;frameReady();<font></font>
    <span class="hljs-keyword">return</span> GST_FLOW_OK;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Request v4l2src allocator to add GstVideoMeta to buffers</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> GstPadProbeReturn
<span class="hljs-title">appsink_pad_probe</span><span class="hljs-params">(GstPad* pad, GstPadProbeInfo* info, gpointer user_data)</span>
</span>{
    <span class="hljs-keyword">if</span> (info-&gt;type &amp; GST_PAD_PROBE_TYPE_QUERY_BOTH) {<font></font>
        GstQuery* query = gst_pad_probe_info_get_query(info);<font></font>
        <span class="hljs-keyword">if</span> (GST_QUERY_TYPE(query) == GST_QUERY_ALLOCATION) {<font></font>
            gst_query_add_allocation_meta(query, GST_VIDEO_META_API_TYPE, <span class="hljs-literal">NULL</span>);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> GST_PAD_PROBE_OK;<font></font>
}</code></pre><br>
<p>       ,  GMainContext  GMainLoop      .</p><br>
<p>     Qt::DirectConnection  setWindow() ‚Äî    callback         ,       OpenGL . </p><br>
<p>V4L2Source::on_new_sample()       v4l2src   appsink        ,   VideoOutput    .</p><br>
<p>  sink   appsink ,    v4l2src         .     ,       /   .</p><br>
<p>   VideoOutput    sync():</p><br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Make sure this callback is invoked from rendering thread</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">V4L2Source::sync</span><span class="hljs-params">()</span>
</span>{<font></font>
    {<font></font>
        <span class="hljs-function">QMutexLocker <span class="hljs-title">locker</span><span class="hljs-params">(&amp;mutex)</span></span>;
        <span class="hljs-keyword">if</span> (!ready) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        <span class="hljs-comment">// reset ready flag</span>
        ready = <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// pull available sample and convert GstBuffer into a QAbstractVideoBuffer</span><font></font>
    GstSample* sample = gst_app_sink_pull_sample(GST_APP_SINK(appsink));<font></font>
    GstBuffer* buffer = gst_sample_get_buffer(sample);<font></font>
    GstVideoMeta* videoMeta = gst_buffer_get_video_meta(buffer);<font></font>
<font></font>
    <span class="hljs-comment">// if memory is DMABUF and EGLImage is supported by the backend,</span>
    <span class="hljs-comment">// create video buffer with EGLImage handle</span><font></font>
    videoFrame.reset();<font></font>
    <span class="hljs-keyword">if</span> (EGLImageSupported &amp;&amp; buffer_is_dmabuf(buffer)) {<font></font>
        videoBuffer.reset(<span class="hljs-keyword">new</span> GstDmaVideoBuffer(buffer, videoMeta));<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> support other memory types, probably GL textures?</span>
        <span class="hljs-comment">// just map memory</span>
        videoBuffer.reset(<span class="hljs-keyword">new</span> GstVideoBuffer(buffer, videoMeta));<font></font>
    }<font></font>
<font></font>
    QSize size = QSize(videoMeta-&gt;width, videoMeta-&gt;height);<font></font>
    QVideoFrame::PixelFormat format =<font></font>
        gst_video_format_to_qvideoformat(videoMeta-&gt;format);<font></font>
<font></font>
    videoFrame.reset(<span class="hljs-keyword">new</span> QVideoFrame(
        <span class="hljs-keyword">static_cast</span>&lt;QAbstractVideoBuffer*&gt;(videoBuffer.get()), size, format));<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (!m_surface-&gt;isActive()) {<font></font>
        m_format = QVideoSurfaceFormat(size, format);<font></font>
        Q_ASSERT(m_surface-&gt;start(m_format) == <span class="hljs-literal">true</span>);<font></font>
    }<font></font>
    m_surface-&gt;present(*videoFrame);<font></font>
    gst_sample_unref(sample);<font></font>
}</code></pre><br>
<p>          appsink,  GstVideoMeta           ( ,   ,  fallback  ,   -   ,  )   QAbstractVideoBuffer    : EGLImage (GstDmaVideoBuffer)  None (GstVideoBuffer).     QVideoFrame      .</p><br>
<p>  GstDmaVideoBuffer  GstVideoBuffer  :</p><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GST_BUFFER_GET_DMAFD(buffer, plane)                                    \
    (((plane) &lt; gst_buffer_n_memory((buffer))) ?                               \
         gst_dmabuf_memory_get_fd(gst_buffer_peek_memory((buffer), (plane))) : \
         gst_dmabuf_memory_get_fd(gst_buffer_peek_memory((buffer), 0)))</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GstDmaVideoBuffer</span> :</span> <span class="hljs-keyword">public</span> QAbstractVideoBuffer<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// This  should be called from renderer thread</span><font></font>
    GstDmaVideoBuffer(GstBuffer* buffer, GstVideoMeta* videoMeta) :<font></font>
        QAbstractVideoBuffer(HandleType::EGLImageHandle),<font></font>
        buffer(gst_buffer_ref(buffer)), m_videoMeta(videoMeta)<font></font>
<font></font>
    {<font></font>
        <span class="hljs-keyword">static</span> PFNEGLCREATEIMAGEKHRPROC eglCreateImageKHR =
            <span class="hljs-keyword">reinterpret_cast</span>&lt;PFNEGLCREATEIMAGEKHRPROC&gt;(<font></font>
                eglGetProcAddress(<span class="hljs-string">"eglCreateImageKHR"</span>));
        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<font></font>
        EGLint attribs[MAX_ATTRIBUTES_COUNT];<font></font>
<font></font>
        attribs[idx++] = EGL_WIDTH;<font></font>
        attribs[idx++] = m_videoMeta-&gt;width;<font></font>
        attribs[idx++] = EGL_HEIGHT;<font></font>
        attribs[idx++] = m_videoMeta-&gt;height;<font></font>
        attribs[idx++] = EGL_LINUX_DRM_FOURCC_EXT;<font></font>
        attribs[idx++] = gst_video_format_to_drm_code(m_videoMeta-&gt;format);<font></font>
        attribs[idx++] = EGL_DMA_BUF_PLANE0_FD_EXT;<font></font>
        attribs[idx++] = GST_BUFFER_GET_DMAFD(buffer, <span class="hljs-number">0</span>);<font></font>
        attribs[idx++] = EGL_DMA_BUF_PLANE0_OFFSET_EXT;<font></font>
        attribs[idx++] = m_videoMeta-&gt;offset[<span class="hljs-number">0</span>];<font></font>
        attribs[idx++] = EGL_DMA_BUF_PLANE0_PITCH_EXT;<font></font>
        attribs[idx++] = m_videoMeta-&gt;stride[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">if</span> (m_videoMeta-&gt;n_planes &gt; <span class="hljs-number">1</span>) {<font></font>
            attribs[idx++] = EGL_DMA_BUF_PLANE1_FD_EXT;<font></font>
            attribs[idx++] = GST_BUFFER_GET_DMAFD(buffer, <span class="hljs-number">1</span>);<font></font>
            attribs[idx++] = EGL_DMA_BUF_PLANE1_OFFSET_EXT;<font></font>
            attribs[idx++] = m_videoMeta-&gt;offset[<span class="hljs-number">1</span>];<font></font>
            attribs[idx++] = EGL_DMA_BUF_PLANE1_PITCH_EXT;<font></font>
            attribs[idx++] = m_videoMeta-&gt;stride[<span class="hljs-number">1</span>];<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (m_videoMeta-&gt;n_planes &gt; <span class="hljs-number">2</span>) {<font></font>
            attribs[idx++] = EGL_DMA_BUF_PLANE2_FD_EXT;<font></font>
            attribs[idx++] = GST_BUFFER_GET_DMAFD(buffer, <span class="hljs-number">2</span>);<font></font>
            attribs[idx++] = EGL_DMA_BUF_PLANE2_OFFSET_EXT;<font></font>
            attribs[idx++] = m_videoMeta-&gt;offset[<span class="hljs-number">2</span>];<font></font>
            attribs[idx++] = EGL_DMA_BUF_PLANE2_PITCH_EXT;<font></font>
            attribs[idx++] = m_videoMeta-&gt;stride[<span class="hljs-number">2</span>];<font></font>
        }<font></font>
        attribs[idx++] = EGL_NONE;<font></font>
<font></font>
        <span class="hljs-keyword">auto</span> m_qOpenGLContext = QOpenGLContext::currentContext();<font></font>
        QEGLNativeContext qEglContext =<font></font>
            qvariant_cast&lt;QEGLNativeContext&gt;(m_qOpenGLContext-&gt;nativeHandle());<font></font>
<font></font>
        EGLDisplay dpy = qEglContext.display();<font></font>
        Q_ASSERT(dpy != EGL_NO_DISPLAY);<font></font>
<font></font>
        image = eglCreateImageKHR(dpy, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT,<font></font>
                                  (EGLClientBuffer) <span class="hljs-literal">nullptr</span>, attribs);<font></font>
        Q_ASSERT(image != EGL_NO_IMAGE_KHR);<font></font>
    }<font></font>
<font></font>
...<font></font>
<font></font>
    <span class="hljs-comment">// This should be called from renderer thread</span>
    ~GstDmaVideoBuffer() <span class="hljs-keyword">override</span><font></font>
    {<font></font>
        <span class="hljs-keyword">static</span> PFNEGLDESTROYIMAGEKHRPROC eglDestroyImageKHR =
            <span class="hljs-keyword">reinterpret_cast</span>&lt;PFNEGLDESTROYIMAGEKHRPROC&gt;(<font></font>
                eglGetProcAddress(<span class="hljs-string">"eglDestroyImageKHR"</span>));<font></font>
<font></font>
        <span class="hljs-keyword">auto</span> m_qOpenGLContext = QOpenGLContext::currentContext();<font></font>
        QEGLNativeContext qEglContext =<font></font>
            qvariant_cast&lt;QEGLNativeContext&gt;(m_qOpenGLContext-&gt;nativeHandle());<font></font>
<font></font>
        EGLDisplay dpy = qEglContext.display();<font></font>
        Q_ASSERT(dpy != EGL_NO_DISPLAY);<font></font>
        eglDestroyImageKHR(dpy, image);<font></font>
        gst_buffer_unref(buffer);<font></font>
    }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
    EGLImage image;<font></font>
    GstBuffer* buffer;<font></font>
    GstVideoMeta* m_videoMeta;<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GstVideoBuffer</span> :</span> <span class="hljs-keyword">public</span> QAbstractPlanarVideoBuffer<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    GstVideoBuffer(GstBuffer* buffer, GstVideoMeta* videoMeta) :<font></font>
        QAbstractPlanarVideoBuffer(HandleType::NoHandle),<font></font>
        m_buffer(gst_buffer_ref(buffer)), m_videoMeta(videoMeta),<font></font>
        m_mode(QAbstractVideoBuffer::MapMode::NotMapped)<font></font>
    {<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">QVariant <span class="hljs-title">handle</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span>
    </span>{
        <span class="hljs-keyword">return</span> QVariant();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span>
    </span>{<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">map</span><span class="hljs-params">(MapMode mode,
            <span class="hljs-keyword">int</span>* numBytes,
            <span class="hljs-keyword">int</span> bytesPerLine[<span class="hljs-number">4</span>],
            uchar* data[<span class="hljs-number">4</span>])</span> <span class="hljs-keyword">override</span>
    </span>{
        <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">const</span> GstMapFlags flags =<font></font>
            GstMapFlags(((mode &amp; ReadOnly) ? GST_MAP_READ : <span class="hljs-number">0</span>) |<font></font>
                        ((mode &amp; WriteOnly) ? GST_MAP_WRITE : <span class="hljs-number">0</span>));
        <span class="hljs-keyword">if</span> (mode == NotMapped || m_mode != NotMapped) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_videoMeta-&gt;n_planes; i++) {<font></font>
                gst_video_meta_map(m_videoMeta, i, &amp;m_mapInfo[i],<font></font>
                                   (gpointer*)&amp;data[i], &amp;bytesPerLine[i],<font></font>
                                   flags);<font></font>
                size += m_mapInfo[i].size;<font></font>
            }<font></font>
        }<font></font>
        m_mode = mode;<font></font>
        *numBytes = size;<font></font>
        <span class="hljs-keyword">return</span> m_videoMeta-&gt;n_planes;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">MapMode <span class="hljs-title">mapMode</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span>
    </span>{
        <span class="hljs-keyword">return</span> m_mode;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unmap</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span>
    </span>{
        <span class="hljs-keyword">if</span> (m_mode != NotMapped) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_videoMeta-&gt;n_planes; i++) {<font></font>
                gst_video_meta_unmap(m_videoMeta, i, &amp;m_mapInfo[i]);<font></font>
            }<font></font>
        }<font></font>
        m_mode = NotMapped;<font></font>
    }<font></font>
<font></font>
    ~GstVideoBuffer() <span class="hljs-keyword">override</span><font></font>
    {<font></font>
        unmap();<font></font>
        gst_buffer_unref(m_buffer);<font></font>
    }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
    GstBuffer* m_buffer;<font></font>
    MapMode m_mode;<font></font>
    GstVideoMeta* m_videoMeta;<font></font>
    GstMapInfo m_mapInfo[<span class="hljs-number">4</span>];<font></font>
};</code></pre><br>
<p>      QML   :</p><br>
<pre><code class="json hljs">import QtQuick <span class="hljs-number">2.10</span>
import QtQuick.Window <span class="hljs-number">2.10</span>
import QtQuick.Layouts <span class="hljs-number">1.10</span>
import QtQuick.Controls <span class="hljs-number">2.0</span>
import QtMultimedia <span class="hljs-number">5.10</span>
import v4l2source <span class="hljs-number">1.0</span><font></font>
<font></font>
Window {<font></font>
    visible: <span class="hljs-literal">true</span>
    width: <span class="hljs-number">640</span>
    height: <span class="hljs-number">480</span>
    title: qsTr(<span class="hljs-string">"qml zero copy rendering"</span>)<font></font>
    color: <span class="hljs-string">"black"</span><font></font>
<font></font>
    CameraSource {<font></font>
        id: camera<font></font>
        device: <span class="hljs-string">"/dev/video0"</span><font></font>
        onFrameReady: videoOutput.update()<font></font>
    }<font></font>
<font></font>
    VideoOutput {<font></font>
        id: videoOutput<font></font>
        source: camera<font></font>
        anchors.fill: parent<font></font>
    }<font></font>
<font></font>
    onClosing: camera.stop()<font></font>
}</code></pre><br>
<h2 id="vyvody"></h2><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The purpose of this article was to show how to integrate an existing API that can produce hardware-accelerated video with QML and use existing components for rendering without copying (well, or in the worst case, with one, but without expensive software conversion to RGB).</font></font></p><br>
<p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code Link</font></font></a></p><br>
<h2 id="ssylki"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">References</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://habr.com/en/post/481540/</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://habr.com/en/post/254625/</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://doc.qt.io/qt-5/videooverview.html</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://doc.qt.io/qt-5/qml-qtmultimedia-videooutput.html</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://doc.qt.io/qt-5/qtquick-visualcanvas-scenegraph.html</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://doc.qt.io/qt-5.12/qtquick-scenegraph-openglunderqml-example.html</font></font></a></li>
</ul></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en486050/index.html">Webix JavaScript library through the eyes of a beginner. Part 3. Modules, diagrams, tree tables</a></li>
<li><a href="../en486052/index.html">Scorched Earth is the mother of all games. Interview with the creator</a></li>
<li><a href="../en486056/index.html">From scripts to our own platform: how we automated development at the Cyan Institute</a></li>
<li><a href="../en486058/index.html">Robot beasts, lesson plans, and new details: an overview of the LEGO Education SPIKE Prime</a></li>
<li><a href="../en486060/index.html">Find Order in the Chaos of IT: Organizing Your Own Development</a></li>
<li><a href="../en486064/index.html">Create an animated slideshow in pure CSS.</a></li>
<li><a href="../en486066/index.html">In the access area. Find the distance from a point to an area and reduce reverse geocoding requests</a></li>
<li><a href="../en486070/index.html">ACL switches in detail</a></li>
<li><a href="../en486072/index.html">SQL HowTo: write a while-loop directly in the query, or "Elementary three-way"</a></li>
<li><a href="../en486076/index.html">From Ground to FPV Quadcopter: Introduction</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>