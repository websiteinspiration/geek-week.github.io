<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏻 👂🏽 🍑 Auto test coverage visualization 🧑‍🤝‍🧑 🦉 🐠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modern coverage reports are in some cases rather useless, and the methods for measuring them are mainly suitable only for developers. You can always f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Auto test coverage visualization</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/491844/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modern coverage reports are in some cases rather useless, and the methods for measuring them are mainly suitable only for developers. </font><font style="vertical-align: inherit;">You can always find out the percentage of coverage or view the code that was not used during the tests, but what if you want visibility, simplicity and automation? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_r/ms/rr/_rmsrr9pfqqgiu7vvskxe93g2po.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Under the cut - video and transcript of a report by Artem Eroshenko from Qameta Software from the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heisenbug</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conference </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">He introduced several developed simple and elegant solutions that help the Yandex.Verticals team evaluate the coverage of tests written by test automation engineers. </font><font style="vertical-align: inherit;">Artem will tell you how to quickly find out what is covered, how covered, what tests have passed, and instantly see visual reports.</font></font><br>
<br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/N2k4LKPWuSw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My name is Artyom Eroshenko </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eroshenkoam</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, I have been doing test automation for over 10 years. </font><font style="vertical-align: inherit;">I was a testing automation manager, a tool development team manager, a tool developer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the moment I am a consultant in the field of testing automation, I work with several companies with whom we build processes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I am also the developer and secret manager of Allure Report. </font><font style="vertical-align: inherit;">We recently </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fixed a cool thing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : now in JUnit 5 there are fixtures.</font></font><br>
<br>
<h2><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atlas Framework</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My development is the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atlas Framework</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . If someone started to automate in 2012, when Java web drivers were just starting their way, at that moment I made an open source library called </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTML Elements</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Html Elements has its continuation and rethinking in the Atlas library, which is built on interfaces: there are no classes as such, no fields, a very convenient, lightweight and easily extensible library. If you have a desire to understand it, you can read the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or see the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">report</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My report is devoted to the problem of test automation and mainly to coatings. As a background, I would like to refer to how the testing processes are organized in Yandex.Verticals.</font></font><br>
<br>
<h2><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How does automation work in verticals?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are only four people in the Yandex.Verticals testing automation team who automate four services: Yandex.Avto, Work, Real Estate and Parts. </font><font style="vertical-align: inherit;">That is, this is a small team of automators who do a lot. </font><font style="vertical-align: inherit;">We automate the API, web interface, mobile applications and so on. </font><font style="vertical-align: inherit;">In total, we have somewhere around 15.5 thousand tests that are performed at different levels.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The stability of the tests in the team is about 97%, although some of my colleagues say about 99%. Such high stability is achieved precisely thanks to short tests on very native technologies. As a rule, our tests take about 15 minutes, which is very capacious, and we run them in approximately 800 threads. That is, we have 800 browsers starting at the same time - such a stress test of our testing. As iron we use Selenoid (Aerokube). You can learn more about testing automation in Yandex.Verticals by watching my 2017 report, which is still relevant.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/gwXpYB6ZayE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another feature of our team is that </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we automate everything</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , including manual testers, who make a great contribution to the development of test automation. For them, we organize schools, teach them tests, teach how to write tests for the API, the web interface, and often they help accompany the tests. Thus, the guys who are responsible for the release themselves can immediately correct the test, if necessary. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Verticals, test developers write tests, and they are so keen on test development that they compete with us. You can learn more about this process from the report </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“The full cycle of testing React applications”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, where Alexei Androsov and Natalya Stus talk about how they write Unit tests on Puppeteer in parallel with our Java end-to-end tests. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Test automation engineers also write tests in our team. </font><font style="vertical-align: inherit;">But often we are developing some new approaches to optimize them. </font><font style="vertical-align: inherit;">For example, we implemented screenshot testing, testing through moki, reduction of testing. </font><font style="vertical-align: inherit;">In general, our area is mainly software developer in test (SDET), we are more about how to write tests, and the test base is partially filled by us and is supported by manual testers.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Developers also help us, and that's cool.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The problem that arises within these processes is that we do not always understand what is already covered and what is not. </font><font style="vertical-align: inherit;">Looking through 15 thousand tests, it is not always clear what exactly we check. </font><font style="vertical-align: inherit;">This is especially true in the context of communication with managers, who, of course, do not test, but monitor and ask questions. </font><font style="vertical-align: inherit;">In particular, if the question arises whether a particular button has been tested in the interface or flow, then it is difficult to answer, because you need to go to the test code and look at this information.</font></font><br>
<br>
<h2><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is tested and what is not?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you have many tests in different languages ​​and are written by people with varying degrees of training, then sooner or later the question arises, are these tests not intersected at all? </font><font style="vertical-align: inherit;">In the context of this problem, the issue of coverage is becoming particularly relevant. </font><font style="vertical-align: inherit;">I will outline three key topics:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ways to effectively measure coverage.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coverage for API tests.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coverage for web tests.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First of all, let’s determine that there are two ways of covering: covering requirements and covering product code.</font></font><br>
<br>
<h4><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How requirements coverage is measured</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider the requirements coverage using auto.ru as an example. In place of the auto.ru tester, I would do the following. Firstly, I would google and immediately find a special requirements table. This is the basis of the requirements coverage. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nf/v6/fh/nfv6fhqm8ukolt_4bv6bxyycohm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this table, the names of the requirements are written on the left. In this case: account, ads, verification and payment, that is, verification of the announcement. In general, this is the coverage. The detail of the left part depends on the tester level. For example, engineers from Google have 49 types of coatings that are tested at different levels. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The right side of the table is the requirements attributes. We can use anything in the form of attributes, for example: priority, coverage and state. This may be the date of the last release.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ox/3a/kj/ox3akjf5fcmwxlmt_utf3uhnsas.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, some data appears in the table. You can use professional tools to maintain a requirements table, for example, TestRail. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is information about the tree on the right: the folders indicate what requirements we have, how they can be covered. There are test cases and so on. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wh/he/aj/whheajlxedwdqlmspx_iofg4wai.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the Verticals, this process looks like this: a manual tester describes the requirements and test cases, then passes them to the test automation, and the automated tool writes code for these tests. Moreover, earlier we were given detailed test cases in which the manual tester described the entire structure. Then someone made a commit on the github, and the test began to be beneficial.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What are the pros and cons of this approach? The plus is that this approach answers our questions. If the manager asks what we have covered, I will open the tablet and show what features are covered. On the other hand, these requirements must always be kept up to date, and they become obsolete very quickly. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When you have 15 thousand tests, looking at TestRail is like looking at a star in space: it exploded for a long time, and the light has reached you just now. You look at the current test case, and it is already outdated a long time and irrevocably.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This problem is difficult to solve. </font><font style="vertical-align: inherit;">For us, these are generally two different worlds: there is a world of automation that revolves according to its own laws, where every test that fails is immediately fixed, and there is a world of manual testing and requirements cards. </font><font style="vertical-align: inherit;">The wall between them is impenetrable, unless you use Allure Server. </font><font style="vertical-align: inherit;">We now just solve this problem for them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The third point of the “pros and cons” is the need for manual work. </font><font style="vertical-align: inherit;">In a new project, you need to re-create a requirements map, write all test cases, and so on. </font><font style="vertical-align: inherit;">It always requires manual work, and it is actually very sad.</font></font><br>
<br>
<h4><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How code coverage is measured</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An alternative to this approach is code coverage. </font><font style="vertical-align: inherit;">This seems to be the solution to our problem. </font><font style="vertical-align: inherit;">This is how the coverage of the product code looks: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5o/-c/oe/5o-coev_livsv-tudln9ztpau_e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It reflects the coverage of the package, or rather a small part of what is actually usually in the product. </font><font style="vertical-align: inherit;">The package is written on the left, as features were written before. </font><font style="vertical-align: inherit;">That is, our coating is finally attached to some tangible things, in this case - Package. </font><font style="vertical-align: inherit;">Attributes are written on the right: coverage by class, coverage by methods, coverage by code blocks and coverage by lines of code. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The process of collecting coverage is to understand which line of code the test passed and which didn’t. </font><font style="vertical-align: inherit;">This is a fairly simple task, but recently very relevant.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first mention of code coverage was back in 1963, but serious progress in this direction appears only now.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we have a test that interacts with the system. It doesn’t matter how he interacts with her: through the front-end, API or directly creeps into the back-end - we’ll just assume that we have it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then instrumentation should be done. This is some process that allows you to understand which lines of code were checked and which were not. You do not need to study it in detail, you just need to look for the name of your framework on which you write, say, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instrumentation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coverage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - these three words will help you understand how this is done. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When your tests check which line of code the test hit and which didn’t hit, they save files with information about which lines are covered. Based on this information, you have data.</font></font><br>
<br>
<h4><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What are the pros and cons of code coverage?</font></font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code coverage I would immediately call a minus</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">You will not come to the manager, you will not show this plate and you will not say that everyone has automated, because this data cannot be read, he will ask you to return clear data that you can quickly look at and understand everything. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code coverage report closer to development. </font><font style="vertical-align: inherit;">It cannot be used as a normal approach to providing all the data to a team if we want the whole team to be able to watch. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jm/kr/bw/jmkrbwezcyzyx90-qxgm4jrrlbm.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The advantage of this approach is that it always provides relevant data. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You do not have to do a lot of work, everything is automated for you. </font><font style="vertical-align: inherit;">Just plug in the library, your covers begin to take off - and it's really cool.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another advantage of this approach is that it requires only customization. There is nothing special to do there - just come with a specific instruction, adjust the coverage, and it works automatically. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Coverage of requirements allows you to identify unfulfilled requirements, but does not allow to evaluate the completeness in relation to the code. For example, you started writing a new feature “authorization”, just enter the “feature of authorization”, you start to throw test cases on it. You cannot immediately see this coverage in the code, even if you write some new class, there will still be no information - there is a gap. On the other hand, this is a requirement of authorization, even when it will already be implemented, when you count the coverage on it, this part cannot be relevant, it must be kept up to date manually.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, we had an idea: what if we take the best from everyone? </font><font style="vertical-align: inherit;">So that the coverage answered our questions, it was always relevant and required only customization. </font><font style="vertical-align: inherit;">We just need to look at the coating from a different angle, that is, take another system as the basis of the coating. </font><font style="vertical-align: inherit;">At the same time, make sure that it is collected completely automatically and brings a bunch of benefits. </font><font style="vertical-align: inherit;">And for this we will go into coverage for the API tests.</font></font><br>
<br>
<h2><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test Coverage API</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is the basis of coverage? </font><font style="vertical-align: inherit;">To do this, we use </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swagger</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - this is the documentation API. </font><font style="vertical-align: inherit;">Now I can not imagine my work without Swagger, it is a tool that I constantly use for testing. </font><font style="vertical-align: inherit;">If you do not use Swagger, I highly recommend visiting the site and familiarizing yourself. </font><font style="vertical-align: inherit;">There you will immediately see a very intuitive and understandable example of use. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, Swagger is the documentation that is generated by your service. </font><font style="vertical-align: inherit;">It contains:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List of requests.</font></font><br>
 <img src="https://habrastorage.org/webt/in/nc/pe/inncpekmy4a699gk-eh0o4be_jy.png"></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Request parameters: there is no need to pull the developer and ask what parameters are.</font></font><br>
<img src="https://habrastorage.org/webt/yz/48/yg/yz48yg1kw8nnqdb3wn7fdcq0g1o.png"></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Answer Codes</font></font><br>
<img src="https://habrastorage.org/webt/zz/y2/ku/zzy2kucjpovwr2xxue4zvct543o.png"><br>
</li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The principle of operation of Swagger is generation. It doesn’t matter which framework you use. Let's say Spring or Go Server, you use the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swagger </font></font></a><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codegen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> component </font><font style="vertical-align: inherit;">and generate </font><i><font style="vertical-align: inherit;">swagger.json</font></i><font style="vertical-align: inherit;"> . This is some specification, on the basis of which a beautiful UI is then drawn. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is important for us that </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swagger.json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is </font><i><font style="vertical-align: inherit;">used</font></i><font style="vertical-align: inherit;"> : its support is available for all widely used languages. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have the Open API specification </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swagger.json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It looks like this: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jn/hl/km/jnhlkmmo1pd-7vxllopdvjhbdr0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Requests look something like this: summary, description, response codes and a “handle” (path: / users). There is also information about the query parameter: everything is structured, there is a user ID parameter, it is in the path where there is required, such a description and type - integer.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3a/bs/7h/3abs7hrvpakohvaejel8utqdtc4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are response codes, they are also documented: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/so/3s/yq/so3syqf7mawlmlqomizvoqdj1-u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And the idea came to our mind: we have a service that Swagger generates, and we wanted to keep the same Swagger in the tests, so that we could compare them later. </font><font style="vertical-align: inherit;">In other words, when the tests run, they generate exactly the same Swagger, we throw it at the Swagger Diff, we understand what parameters, handles, status codes we have checked, and so on. </font><font style="vertical-align: inherit;">This is the same instrumentation, the same coverage, only finally in the requirements that we understand.</font></font><br>
<br>
<h2><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But what if you build a diff?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We turned to the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swagger diff</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">, which is what we need for this. Its principle of operation is something like this: you have version 1.0, with API version 1.1, they both generate </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swagger.json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then you throw them at Swagger diff and see the result. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The result looks something like this: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qk/qn/ls/qkqnlsxnssknuv8p8t9cg5ckryu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You have information that there is, for example, a new pen. You also have information about what is deleted. This means that it’s time to remove the tests, they are no longer relevant. With the appearance of information about changes, the parameters also change, so it is obvious that your tests will fall at that moment.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We liked this idea, and we started to implement. As we decided to do: we have a “reference” Swagger that generates from the developer code, we also have API tests that will generate our Swagger, and we will diff between them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we run tests for the service: we have </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rest Assured</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which itself accesses the services on the API. And we instrument it. There is an approach: you can make filters, the request goes to it - and it saves the information about the request in the form of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swagger.json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> directly for itself. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is the whole code that we needed to write, there were 69-70 lines - this is a very simple code.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6_/m6/ck/6_m6cka7jfewruree9d9561tayo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The funny thing is that we used the native client for Swagger, wrote right there. </font><font style="vertical-align: inherit;">We didn’t even need to create our binaries, we just filled out the Swagger specification. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lr/rl/fw/lrrlfwuiqrgykrprpjnxr1fcfmq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We got a lot of .json files with which we had to do something - they wrote a Swagger aggregator. </font><font style="vertical-align: inherit;">This is a very simple program that works according to the following principle:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">She meets a new request, if it is not in our database, she adds.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">She meets the request, he has a new parameter - adds.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Same thing with status codes.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, we get information about all the pens, parameters and status codes that we used. </font><font style="vertical-align: inherit;">In addition, here you can collect data with which these requests were performed: username, logins, and so on. </font><font style="vertical-align: inherit;">We have not yet figured out how to use this information, because everything is generated with us, but you can understand with what parameters certain requests were called.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we were almost a stone's throw from the victory, but as a result we refused Swagger Diff, because it works in a slightly different concept - in the concept of differential.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Swagger Diff says what has changed, not what is covered, but we wanted to display the result of the coverage. </font><font style="vertical-align: inherit;">There is a lot of extra data, it stores information about description, summary and other meta-information, but we do not have this information. </font><font style="vertical-align: inherit;">And when we make Diff, they write to us that “this pen does not have a description”, but it didn’t exist.</font></font><br>
<br>
<h2><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Own report</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We made our implementation, and it works as follows: we have many files that came from autotests, we have the Swagger service API, and we generate a report based on it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A simple report looks like this: above you can see information on how many pens (349) in total, information on which are fully covered (each parameter, status code, and so on). You can choose your own criteria, for example, cover several parameters. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is also information here that 40% is partially covered - this means that we already have tests for these pens, but some things are not covered yet, and you need to look carefully there. Empty coverage is also reflected. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pc/og/p5/pcogp5jnc8m88l8fylt2p2uc0eq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's go through the tabs. This is a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">full-coverage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we see all the parameters that we have, which are covered, status codes and so on.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9o/gl/2q/9ogl2q9tf_xb1xw9dl9j8sxsku0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then we have a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partial coverage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">We see that on the login-social handle one parameter is covered, and two are not. </font><font style="vertical-align: inherit;">And we can expand it and see what specific parameters and status codes are covered. </font><font style="vertical-align: inherit;">And at this moment it becomes very convenient for the developer: the versions of the application roll very quickly, and we often can forget some parameters. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fo/pf/sc/fopfscyojnuzokszhkw8ntgrqio.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This tool allows you to always be in good shape and understand what we have partially covered, which parameter is forgotten, and so on. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Last - Glory of shame, we still have to do it. </font><font style="vertical-align: inherit;">When you look at this page and see Empty there: 172 - your hands drop, and then you start teaching hand testers how to write autotests, that’s the point.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/p8/2k/o5/p82ko5nzine_u6odc8dtl9bho5s.png"><br>
<br>
<h4><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What benefit did we get when we rolled out our solution?</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, we began to write tests more meaningfully. </font><font style="vertical-align: inherit;">We understand that we are testing, and at the same time we have two strategies. </font><font style="vertical-align: inherit;">First, we automate something that is not there when manual testers come and say that for a particular service it is critical that one request is executed at least once, and we open Empty. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second option - we do not forget about the tails. </font><font style="vertical-align: inherit;">As I said, the APIs will be released very quickly, there may be some releases two or three times a day. </font><font style="vertical-align: inherit;">Some parameters are constantly added there: in five thousand tests it is impossible to understand what is checked and what is not. </font><font style="vertical-align: inherit;">Therefore, this is the only way to consciously choose a testing strategy and at least do something.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The third profit is a fully automatic process. </font><font style="vertical-align: inherit;">We have borrowed the approach, and automation works: we do not need to do anything, everything is collected automatically.</font></font><br>
<br>
<h4><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Development ideas</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Firstly, I really do not want to keep the second report, but I want to integrate it into Swagger UI. </font><font style="vertical-align: inherit;">This is my favorite “Photoshop Edition report”: a chip I’ve been developing lately. </font><font style="vertical-align: inherit;">Here immediately there is information about the parameters that we have tested and which are not. </font><font style="vertical-align: inherit;">And it would be cool to give this information right away with Swagger. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v6/ll/n8/v6lln82kyue5errknkoxj9mkq-k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, the front-end can see for himself what parameters have not been tested, prioritize and decide that while they do not need to be taken into development, it is not known how well they work. </font><font style="vertical-align: inherit;">Or the backend writes a new pen, sees red and kicks testers so that everything is green. </font><font style="vertical-align: inherit;">This is quite easy to do, we are going in this direction.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second idea is to support other tools. </font><font style="vertical-align: inherit;">In fact, I do not want to write filters for specific implementations: for Java, Python, and so on. </font><font style="vertical-align: inherit;">There is an idea to make a kind of proxy that will pass all requests through itself, and save Swagger information for itself. </font><font style="vertical-align: inherit;">Thus, we will have a universal library that can be used no matter what language you have. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The third development idea is integration with Allure Report. </font><font style="vertical-align: inherit;">I see it like this: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ym/b3/ad/ymb3adazpdly9uhljv8jjqpyg04.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a rule, when the parameter is “tested”, this does not always tell us how it is tested. </font><font style="vertical-align: inherit;">And I want to point at this parameter and see the specific steps of the test.</font></font><br>
<br>
<h4><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Web Testing Coverage</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The next point I want to talk about is coverage for Web tests. The coverage is based on the site you are testing, writing tests on the site. But you can make it a web interface to your coverage. For example, it will look like this: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vq/1k/tg/vq1ktgatdwq9v-v-fpzz1444hf0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you look at your site - this is some set of elements and ways to interact with them. This is a complete description: "an element is a way to interact with it." You can click on the link, you can copy the text, you can drive something into input. The site as a whole consists of elements and ways of their interaction: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/f3/07/z-/f307z-lt44swcsgdas_vsspvyrk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How tests run: they start from some point, then, for example, fill out some form, say, an authorization form, then scatter to other pages, then another to another and end .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the manager asks if a particular button is being tested, but this question is difficult to answer: you need to open the code or go to TestRail, then I want to see this solution to the problem: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hh/7q/mv/hh7qmvkk8gefu94bigbkofhdgak.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I want to point at this element and see all the tests that we have on this item. If there was such an instrument, I would be happy. When we started thinking about this idea, we first looked at Yandex.Metrica. They actually have roughly the same functionality as a link map. A good idea.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The bottom line is that they are highlighted exactly as if they already give the information we need. They say: “Here we have passed this link 14 times”, which in translation into the testing language means: “14 tests were tested in this link” and somehow passed through it. But this red link took as many as 120 tests, what interesting tests! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can draw all sorts of trends, add meta-information, but what happens if we take it all and draw from the point of view of testing? So, we have a task: to point at some element and get a note with a list of tests. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xa/hr/dj/xahrdjma8punc8jmujxg_vwtlvs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to implement this, you need to click on the icon, then write a note, and this is our whole test. We use Atlas at our place, and integration so far is only with it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atlas looks something like this:</font></font><br>
<br>
<pre><code class="java hljs">SearchPage.open ();<font></font>
SearchPage.offersList().should(hasSizeGreaterThan(<span class="hljs-number">0</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We want at least one result to be displayed, otherwise we will not test it. </font><font style="vertical-align: inherit;">Then we move the cursor to the element, then click on it.</font></font><br>
<br>
<pre><code class="java hljs">searchPage.offer(FIRST).moveCursor();<font></font>
searchPage.offer(FIRST).actionBar().note().click();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then we save in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">input User_Text</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and submit it.</font></font><br>
<br>
<pre><code class="java hljs">searchPage.offer(FIRST).addNoteInput().sendKeys(USER_TEXT);<font></font>
searchPage.offer(FIRST).saveNote().click();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After that, we check that the text is exactly the one that should have been.</font></font><br>
<br>
<pre><code class="java hljs"> searchPage.offer(FIRST).addNoteInput().should(hasValue(USER_TEXT));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tests run in a browser, Atlas is a proxy for this test, we apply the same approach here that everyone uses when collecting coverage: we will make a locator with .json. We will save there information about all page openings, all iterations with elements, who submitted, who did sendkey, who click, which IDs and so on - we will keep a complete log. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then we attach this log to Allure in the form of each test, and when we have a lot of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">locators.json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we generate </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meta.json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The scheme is the same for all elements. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have a plugin for Google Chrome. We wanted to make a decision in the form of a plugin. I specially made a curve screenshot so that one important detail was visible on the slide - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">path to locators.json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rx/kg/nz/rxkgnzghdmiw9syocwbkaqx27yy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you generated a report now, then there is a coverage map for today. If you take the report for the previous two weeks and paste it here, a coverage map for the period two weeks ago will appear. You have a time machine! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, when you plug in this plugin, it draws a not-so-friendly interface. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mx/q4/vx/mxq4vxhpjqlrewxte3xn_o75upm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each element has a number of tests that pass through it: it is clear that 40 tests pass through “buy an apartment”, header is tested one test at a time, it's cool, and the “apartment” option is also displayed. You get a complete coverage map. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you hover over some element, it will take the data and print your real tests from your tms, Allure Board and so on. The result is complete information about what is being tested and how.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Please note that from each test you can fail directly in the Allure report. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/he/nw/iy/henwiyzy6if8o1ak2ky1i9v2s-e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When you open any thing, it loads new selectors: if you have any tests that go through these selectors and you did something with the site, it will process and show the whole picture.</font></font><br>
<br>
<h2><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is the profit?</font></font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As soon as we implemented this simple approach, then, mainly, we began to understand what we tested in tests.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now anyone can go in and find any "thread" that leads to the script. For example, you assume that you need to test the payment. Payment, obviously, leads through the payment button: click - all the tests that go through the payment button appear. This is good! You go into any of them and view the script. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Moreover, you understand what has been tested before. We generate a static file, you can specify the path to it and indicate which tests were two weeks ago. If the manager says that there is a bug in production and asks if we tested this or that functionality a couple of weeks ago, you take the Allure report, say, for example, that you didn’t test it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another profit is the review after testing automation. Before that, we had a review before testing automation, now you can do your tests exactly as you see them. If you wanted to do a test - done, took some branch, launched Allure, dropped the link to the plug-in to a manual tester and asked to see the tests. This is exactly the process that will allow you to strengthen the Agile strategy: team lead makes code review, and manual testers do your tests (scripts). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another advantage of this approach is the frequently used elements. If we override this block, in which there are 87 tests, then all of them will fall. You begin to understand how flack your tests are.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/x3/jh/ye/x3jhyewo2z60_6-xi5iz6q-2rzs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And if the block “price from” is overturned, then it’s okay, one test will fall, a person will correct it. </font><font style="vertical-align: inherit;">If you change the block with 87 tests, then the coverage will sag considerably, because 87 tests will not pass and will not check any result. </font><font style="vertical-align: inherit;">This block needs increased attention. </font><font style="vertical-align: inherit;">Then you need to tell the developer that this block must be with an ID, because if it leaves, everything will fall apart.</font></font><br>
<br>
<h2><font color="#DB8E0D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How can you develop further?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, you can follow the path of developing support for other tools, for example, for Selenide. I would even like to support not a specific Selenide, but a driver implementation that will allow you to collect locators, regardless of the tool you use. This proxy will dump information and then display it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another idea is to display the current test result. For example, it’s convenient to immediately throw such a picture to a manual tester: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/e4/w-/q8/e4w-q8xjavk2dfern8u_fncyfu4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You don’t have to think which tests broke, because you can go to the site, click on the test and pass it by hand without checking other tests. This is easy, you can pick up this information from Allure and draw it right here.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can also add the Total Score, because everyone loves graphics, because I want to deal with duplicate tests that are very similar to each other, whose central part is the same, and the beginning and tail have changed a bit. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/op/lw/xq/oplwxqvq08hv-uaqs3c97owcuxy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I would also like to immediately see the number of duplicate selectors. If it is high, then on this page you need to do refactoring and run tests, otherwise they will fall in too large a bundle. The same goes for the number of elements we interacted with. This is some common symptom. However, as soon as you interact with the page, the figure will skip due to new elements and the total number of test cases, so you need to add some kind of analytics, it will not be superfluous.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can also add the distribution of tests by layers, because you want to see not just that we have these tests, but all the types of tests that are on this page, possibly even manual tests. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, if there are Java tests and tests on Puppeteer that another team writes, we can look at a specific page and immediately say where our tests intersect. That is, we will speak the same language with them, and we will not need to collect this information bit by bit. If we have a tool that shows everything in the web interface, then the task of comparing tests in Java and Puppeteer no longer seems unsolvable.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, let's talk about the general strategy. </font><font style="vertical-align: inherit;">We have already talked about what types of coverage are, named two, came up with a third type of coating, which we used as a result. </font><font style="vertical-align: inherit;">So we just took and looked at this problem from a different angle.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the one hand, there is coverage that has been kicked since 1963, on the other hand, there are manual testers who are used to living in a more real world than code. </font><font style="vertical-align: inherit;">It remains only to combine these two approaches.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Those interested can always join our community. </font><font style="vertical-align: inherit;">Here are two repositories of our guys that deal with the coverage problem:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swagger-coverage</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">locators-hotspots-chrome-plugin</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en491826/index.html">Bitrix Do-it-yourself audit</a></li>
<li><a href="../en491828/index.html">DataMatrix or how to label shoes correctly</a></li>
<li><a href="../en491832/index.html">8 pluses of Flutter in comparison with React Native</a></li>
<li><a href="../en491838/index.html">MIPT launches an open online course on sports programming</a></li>
<li><a href="../en491840/index.html">Visualization of the work of service workers</a></li>
<li><a href="../en491846/index.html">Verifying Isomorphism of Two Graphs and Searching for Isomorphic Subgraphs: An Approach Based on NB-Paths Analysis</a></li>
<li><a href="../en491848/index.html">Redux Toolkit is no longer needed?</a></li>
<li><a href="../en491852/index.html">Flask-DJ: Django (mvc) structure for a project on flask</a></li>
<li><a href="../en491854/index.html">Corporate phones for each of 31 thousand employees</a></li>
<li><a href="../en491856/index.html">LinkedIn for Students and Graduates: First Steps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>