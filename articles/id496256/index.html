<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚯 🍰 ↗️ Pembelajaran mesin pada R: teknik ahli untuk analisis prediktif 🧙🏻 🔳 🏇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, habrozhiteli! Bahasa R menawarkan serangkaian metode pembelajaran mesin yang kuat yang memungkinkan Anda untuk dengan cepat melakukan analisis d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Pembelajaran mesin pada R: teknik ahli untuk analisis prediktif</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/496256/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/lf/4u/ao/lf4uaojxjnbk8d6no9t-3j-v7ww.jpeg" align="left" alt="gambar"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo, habrozhiteli! Bahasa R menawarkan serangkaian metode pembelajaran mesin yang kuat yang memungkinkan Anda untuk dengan cepat melakukan analisis data non-sepele. Buku ini adalah panduan yang akan membantu menerapkan metode pembelajaran mesin untuk memecahkan masalah sehari-hari. Brett Lanz akan mengajarkan Anda semua yang Anda butuhkan untuk analisis data, peramalan, dan visualisasi data. Di sini Anda akan menemukan informasi tentang perpustakaan baru dan lebih baik, tips tentang aspek etis pembelajaran mesin dan masalah bias, serta pelatihan mendalam.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam buku ini - Dasar-dasar pembelajaran mesin dan fitur pelatihan komputer tentang contoh-contoh. </font><font style="vertical-align: inherit;">- Persiapan data untuk digunakan dalam pembelajaran mesin dengan menggunakan bahasa R. - Klasifikasi pentingnya hasil. </font><font style="vertical-align: inherit;">- Prediksi peristiwa menggunakan pohon keputusan, aturan, dan vektor referensi. </font><font style="vertical-align: inherit;">- Prediksi data numerik dan penilaian data keuangan menggunakan metode regresi. </font><font style="vertical-align: inherit;">- Pemodelan proses yang kompleks menggunakan jaringan saraf adalah dasar dari pembelajaran yang mendalam. </font><font style="vertical-align: inherit;">- Evaluasi model dan meningkatkan kinerja mereka. </font><font style="vertical-align: inherit;">- Teknologi terbaru untuk memproses data besar, khususnya R 3.6, Spark, H2O dan TensorFlow.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk siapa buku itu?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Buku ini ditujukan bagi mereka yang berharap untuk menggunakan data di area tertentu. </font><font style="vertical-align: inherit;">Anda mungkin sudah sedikit terbiasa dengan pembelajaran mesin, tetapi Anda belum pernah bekerja dengan bahasa R; </font><font style="vertical-align: inherit;">atau, sebaliknya, Anda tahu sedikit tentang R, tetapi hampir tidak tahu tentang pembelajaran mesin. </font><font style="vertical-align: inherit;">Bagaimanapun, buku ini akan membantu Anda memulai dengan cepat. </font><font style="vertical-align: inherit;">Akan bermanfaat untuk menyegarkan sedikit konsep dasar matematika dan pemrograman, tetapi tidak ada pengalaman sebelumnya yang diperlukan. </font><font style="vertical-align: inherit;">Yang Anda butuhkan adalah keinginan untuk belajar.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang akan Anda baca di publikasi</font></font></b><div class="spoiler_text"> 1 «   »    ,          ,      ,   ,     .<br>
<br>
 2 «    »            R.         ,   ,    .<br>
<br>
 3 « :      »      ,           :     .<br>
<br>
 4 « :      »     ,       .    ,      .<br>
<br>
 5 «  :       »    ,     ,    .      ,    .<br>
<br>
 6 «  :  »     ,    .        ,     ,     .<br>
<br>
 7 « “ ”:      »   ,     .        ,    ,    .<br>
<br>
 8 « :       »  ,    ,      .   -   ,         ,   ,      .<br>
<br>
 9 «  :   k-»      .         -.<br>
<br>
 10 «  »    ,                  .<br>
<br>
 11 «  »  ,  ,        .                ,         .<br>
<br>
 12 «   »    :        R.  ,        ,       R.<br>
</div></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh: memodelkan kekuatan beton menggunakan jaringan saraf</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bidang teknik sipil, sangat penting untuk memiliki perkiraan akurat tentang efektivitas bahan bangunan. </font><font style="vertical-align: inherit;">Penilaian ini diperlukan untuk mengembangkan aturan keselamatan yang mengatur penggunaan material dalam konstruksi bangunan, jembatan dan jalan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang menarik adalah penilaian kekuatan konkret. </font><font style="vertical-align: inherit;">Beton digunakan di hampir semua konstruksi, karakteristik kinerja beton sangat berbeda, karena terdiri dari sejumlah besar bahan yang berinteraksi dalam kompleks. </font><font style="vertical-align: inherit;">Akibatnya, sulit untuk mengatakan dengan tepat seperti apa kekuatan produk akhir itu. </font><font style="vertical-align: inherit;">Model yang memungkinkan penentuan kekuatan beton, dengan mempertimbangkan komposisi bahan awal, dapat memberikan tingkat keamanan yang lebih tinggi untuk lokasi konstruksi.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah 1. Pengumpulan data</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk analisis ini, kita akan menggunakan data kuat tekan konkret yang disediakan oleh I-Cheng Yeh ke Repositori Pembelajaran Mesin UCI (http://archive.ics.uci.edu/ml). </font><font style="vertical-align: inherit;">Karena Ai-Cheng Ye berhasil menggunakan jaringan saraf untuk memodelkan data ini, kami akan mencoba mereproduksi karyanya dengan menerapkan model sederhana jaringan saraf di R.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dilihat oleh situs, dataset ini berisi 1030 catatan tentang berbagai merek beton dengan delapan karakteristik yang menggambarkan komponen yang digunakan dalam komposisi campuran beton. </font><font style="vertical-align: inherit;">Dipercayai bahwa karakteristik ini mempengaruhi kuat tekan akhir. </font><font style="vertical-align: inherit;">Ini termasuk: jumlah (dalam kilogram per meter kubik) semen, air, berbagai aditif, agregat besar dan kecil seperti batu pecah dan pasir yang digunakan dalam produk jadi, serta pengaturan waktu (dalam hari).</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menjalankan contoh ini, unduh file concrete.csv dan simpan di direktori kerja R.</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah 2. Penelitian dan persiapan data</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti biasa, kami memulai analisis dengan memuat data ke objek-R menggunakan fungsi read.csv () dan memastikan bahwa hasilnya sesuai dengan struktur yang diharapkan:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete &lt;- read.csv(<span class="hljs-string">"concrete.csv"</span>)<font></font>
&gt; str(concrete)<font></font>
<span class="hljs-string">'data.frame'</span>:        <span class="hljs-number">1030</span> obs. of <span class="hljs-number">9</span> variables:<font></font>
$ cement       : num <span class="hljs-number">141</span> <span class="hljs-number">169</span> <span class="hljs-number">250</span> <span class="hljs-number">266</span> <span class="hljs-number">155</span> ...<font></font>
$ slag            : num <span class="hljs-number">212</span> <span class="hljs-number">42.2</span> <span class="hljs-number">0</span> <span class="hljs-number">114</span> <span class="hljs-number">183.4</span> ...<font></font>
$ ash             : num <span class="hljs-number">0</span> <span class="hljs-number">124.3</span> <span class="hljs-number">95.7</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> ...<font></font>
$ water          : num <span class="hljs-number">204</span> <span class="hljs-number">158</span> <span class="hljs-number">187</span> <span class="hljs-number">228</span> <span class="hljs-number">193</span> ...<font></font>
$ superplastic : num <span class="hljs-number">0</span> <span class="hljs-number">10.8</span> <span class="hljs-number">5.5</span> <span class="hljs-number">0</span> <span class="hljs-number">9.1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">6.4</span> <span class="hljs-number">0</span> <span class="hljs-number">9</span> ...<font></font>
$ coarseagg    : num <span class="hljs-number">972</span> <span class="hljs-number">1081</span> <span class="hljs-number">957</span> <span class="hljs-number">932</span> <span class="hljs-number">1047</span> ...<font></font>
$ fineagg        : num <span class="hljs-number">748</span> <span class="hljs-number">796</span> <span class="hljs-number">861</span> <span class="hljs-number">670</span> <span class="hljs-number">697</span> ...<font></font>
$ age             : <span class="hljs-keyword">int</span> <span class="hljs-number">28</span> <span class="hljs-number">14</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">90</span> <span class="hljs-number">7</span> <span class="hljs-number">56</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> ...<font></font>
$ strength      : num <span class="hljs-number">29.9</span> <span class="hljs-number">23.5</span> <span class="hljs-number">29.2</span> <span class="hljs-number">45.9</span> <span class="hljs-number">18.3</span> ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sembilan variabel dalam bingkai data sesuai dengan delapan karakteristik dan satu hasil yang diharapkan, tetapi menjadi jelas bahwa ada masalah. </font><font style="vertical-align: inherit;">Jaringan saraf bekerja paling baik ketika data input diskalakan ke rentang sempit yang berpusat di sekitar 0, dan di sini kita melihat nilai dalam kisaran dari 0 hingga lebih dari 1000.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biasanya, solusi untuk masalah ini adalah skala data menggunakan fungsi normalisasi atau standardisasi. Jika distribusi data sesuai dengan kurva berbentuk lonceng (distribusi normal, lihat bab 2), maka mungkin masuk akal untuk menggunakan standardisasi menggunakan fungsi skala built-in (). Jika distribusi data mendekati seragam atau sangat berbeda dari normal, maka normalisasi ke kisaran dari 0 hingga 1 mungkin lebih cocok. Dalam hal ini, kami akan menggunakan opsi yang terakhir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam bab 3, kami membuat fungsi normalisasi () kami sendiri:</font></font><br>
<br>
<pre><code class="java hljs">&gt; normalize &lt;- function(x) {
       <span class="hljs-keyword">return</span>((x - min(x)) / (max(x) — min(x)))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah kode ini dieksekusi, Anda dapat menerapkan fungsi normalize () ke semua kolom frame data yang dipilih menggunakan fungsi lapply (): </font></font><br>
<br>
<code>&gt; concrete_norm &lt;- as.data.frame(lapply(concrete, normalize))</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memverifikasi bahwa normalisasi telah berfungsi, Anda dapat memeriksa apakah nilai minimum dan maksimum atribut strength adalah 0 dan 1, masing-masing:</font></font><br>
<br>
<pre><code class="java hljs">&gt; summary(concrete_norm$strength)<font></font>
       Min.     <span class="hljs-number">1</span>st Qu.         Median     Mean      <span class="hljs-number">3</span>rd Qu.      Max.
   <span class="hljs-number">0.0000</span>     <span class="hljs-number">0.2664</span>         <span class="hljs-number">0.4001</span>  <span class="hljs-number">0.4172</span>      <span class="hljs-number">0.5457</span>   <span class="hljs-number">1.0000</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai perbandingan: nilai minimum awal dan maksimum atribut ini masing-masing adalah 2,33 dan 82,60:</font></font><br>
<br>
<pre><code class="java hljs">&gt; summary(concrete$strength)<font></font>
     Min.       <span class="hljs-number">1</span>st Qu.     Median       Mean      <span class="hljs-number">3</span>rd Qu.       Max.
    <span class="hljs-number">2.33</span>         <span class="hljs-number">23.71</span>       <span class="hljs-number">34.44</span>      <span class="hljs-number">35.82</span>        <span class="hljs-number">46.14</span>      <span class="hljs-number">82.60</span></code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap konversi yang diterapkan pada data sebelum melatih model selanjutnya harus diterapkan dalam urutan terbalik untuk mengubah atribut kembali ke unit aslinya. </font><font style="vertical-align: inherit;">Untuk memfasilitasi penskalaan, disarankan untuk menyimpan data sumber atau setidaknya ringkasan statistik dari data sumber.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengikuti skenario yang dijelaskan oleh Ye dalam artikel asli, kami akan membagi data menjadi satu set pelatihan, yang mencakup 75% dari semua contoh, dan satu set tes, yang terdiri dari 25%. </font><font style="vertical-align: inherit;">File CSV yang digunakan diurutkan dalam urutan acak, jadi kami hanya dapat membaginya menjadi dua bagian: </font><font style="vertical-align: inherit;">
Kami akan menggunakan dataset pelatihan untuk membangun jaringan saraf dan dataset uji untuk menilai seberapa baik model tersebut menggeneralisasi untuk hasil di masa depan. </font><font style="vertical-align: inherit;">Karena jaringan saraf mudah dibawa ke keadaan pelatihan ulang, langkah ini sangat penting.</font></font><br>
<br>
<code>&gt; concrete_train &lt;- concrete_norm[1:773, ]<br>
&gt; concrete_test &lt;- concrete_norm[774:1030, ]</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah 3. Pelatihan model tentang data</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memodelkan hubungan antara bahan-bahan yang digunakan dalam produksi beton dan kekuatan produk jadi, kami akan membangun jaringan saraf distribusi langsung multilayer. Paket neuralnet, yang dikembangkan oleh Stefan Fritsch dan Frauke Guenther, memberikan implementasi standar dan mudah digunakan jaringan tersebut. Paket ini juga mencakup fungsi untuk membangun topologi jaringan. Menerapkan neuralnet adalah cara yang baik untuk mendapatkan informasi tambahan tentang jaringan saraf, meskipun ini tidak berarti bahwa itu tidak dapat digunakan untuk melakukan pekerjaan nyata - karena Anda akan segera melihat, itu adalah alat yang agak kuat.</font></font><br>
<br>
<blockquote> R    ,       ,        .  nnet      R,  , ,      .       ,      .    —  RSNNS,       ,     ,     .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena paket neuralnet tidak termasuk dalam basis R, Anda perlu menginstalnya dengan mengetik install.packages ("neuralnet") dan mengunduhnya menggunakan perintah library (neuralnet). </font><font style="vertical-align: inherit;">Fungsi neuralnet () dalam paket dapat digunakan untuk melatih jaringan saraf dalam prediksi numerik menggunakan sintaks berikut.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaks jaringan saraf</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menggunakan fungsi neuralnet () dari paket neuralnet </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Membangun model:</font></font><br>
<br>
<pre><code class="java hljs">m &lt;- neuralnet(target ~ predictors, data = mydata,<font></font>
                       hidden = <span class="hljs-number">1</span>, act.fct = <span class="hljs-string">"logistic"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• target - model yang akan dibangun sebagai hasil pelatihan tentang kerangka data mydata; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• prediktor - rumus-R yang menentukan karakteristik dari bingkai data mydata yang akan digunakan dalam peramalan; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• data - kerangka data yang menjadi target dan prediktor; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• tersembunyi - jumlah neuron dalam lapisan tersembunyi (standarnya adalah 1). Catatan: untuk menggambarkan beberapa lapisan tersembunyi, vektor bilangan bulat digunakan, misalnya, c (2, 2); </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• act.fct - fungsi aktivasi: "logistik" atau "tanh". Catatan: fungsi terdiferensiasi lainnya juga dapat digunakan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi mengembalikan objek jaringan saraf yang dapat digunakan untuk peramalan. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prediksi:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
p &lt;- menghitung (m, tes)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• m - model yang dilatih menggunakan fungsi neuralnet (); </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• tes - kerangka data yang berisi data uji dengan karakteristik yang sama dengan data pelatihan yang digunakan untuk membangun pengklasifikasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi mengembalikan daftar yang terdiri dari dua komponen: $ neuron, di mana neuron disimpan untuk setiap lapisan jaringan, dan $ net.result, di mana nilai-nilai yang diprediksi menggunakan model ini disimpan.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh:</font></font></h4><br>
<br>
<pre><code class="java hljs">concrete_model &lt;- neuralnet(strength ~ cement + slag + ash,<font></font>
      data = concrete, hidden = c(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), act.fct = <span class="hljs-string">"tanh"</span>)<font></font>
model_results &lt;- compute(concrete_model, concrete_data)<font></font>
strength_predictions &lt;- model_results$net.result</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita mulai dengan melatih jaringan distribusi langsung multi-level paling sederhana dengan parameter default, yang hanya memiliki satu simpul tersembunyi:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete_model &lt;- neuralnet(strength ~ cement + slag<font></font>
         + ash + water + superplastic + coarseagg + fineagg + age,<font></font>
         data = concrete_train)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian, seperti yang ditunjukkan pada gambar. </font><font style="vertical-align: inherit;">7.11, Anda dapat memvisualisasikan topologi jaringan menggunakan fungsi plot () dan meneruskannya objek model yang dihasilkan:</font></font><br>
<br>
<code>&gt; plot(concrete_model)</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mt/qh/og/mtqhogfq-pcptln4uzbl9ofb8po.png" alt="gambar"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam model sederhana ini, ada satu simpul input untuk masing-masing dari delapan fitur, lalu ada satu simpul tersembunyi dan satu simpul keluaran, yang memberikan perkiraan kekuatan beton. </font><font style="vertical-align: inherit;">Diagram juga menunjukkan bobot untuk setiap koneksi dan nilai offset yang ditunjukkan untuk node yang ditandai dengan angka 1. Nilai offset adalah konstanta numerik yang memungkinkan Anda untuk menggeser nilai dalam node yang ditentukan ke atas atau ke bawah, kira-kira seperti pergeseran dalam persamaan linear.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebuah jaringan saraf dengan satu simpul tersembunyi dapat dianggap sebagai "sepupu" dari model regresi linier yang dibahas dalam Bab 6. Bobot antara simpul input dan simpul tersembunyi mirip dengan koefisien beta, dan bobot offset seperti pergeseran.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bagian bawah gambar, jumlah langkah pelatihan dan besarnya kesalahan ditampilkan - total kesalahan kuadrat rata-rata (Jumlah Kesalahan Kuadrat, SSE), yang, seperti yang diharapkan, adalah jumlah perbedaan kuadrat antara nilai yang diprediksi dan nilai aktual. </font><font style="vertical-align: inherit;">Semakin kecil SSE, semakin akurat model tersebut cocok dengan data pelatihan, yang menunjukkan keefektifan data ini, tetapi tidak banyak bicara tentang bagaimana model akan bekerja dengan data yang tidak diketahui.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah 4. Menilai efektivitas model</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diagram topologi jaringan memberikan kesempatan untuk melihat ke dalam "kotak hitam" dari jaringan saraf, tetapi tidak memberikan banyak informasi tentang seberapa baik model cocok dengan data masa depan. Untuk menghasilkan perkiraan pada set data uji, Anda dapat menggunakan fungsi compute (): </font></font><br>
<br>
<code>&gt; model_results &lt;- compute(concrete_model, concrete_test[1:8])</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi compute () bekerja sedikit berbeda dari fungsi predict () yang telah kami gunakan sejauh ini. Ini mengembalikan daftar yang terdiri dari dua komponen: $ neuron, di mana neuron disimpan untuk setiap lapisan jaringan, dan $ net.result, di mana nilai yang diprediksi disimpan. Ini $ net. Hasil yang kita butuhkan:</font></font><br>
<br>
<code>&gt; predicted_strength &lt;- model_results$net.result</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena kita memiliki tugas perkiraan numerik, dan bukan klasifikasi, kita tidak dapat menggunakan matriks inkonsistensi untuk memverifikasi keakuratan model. </font><font style="vertical-align: inherit;">Kami mengukur korelasi antara prediksi dan nilai sebenarnya dari kekuatan beton. </font><font style="vertical-align: inherit;">Jika nilai yang diprediksi dan aktual akan sangat berkorelasi, maka, mungkin, model akan berguna untuk menentukan kekuatan beton. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biarkan saya mengingatkan Anda bahwa untuk mendapatkan korelasi antara dua vektor angka, fungsi cor () digunakan:</font></font><br>
<br>
<pre><code class="java hljs">&gt; cor(predicted_strength, concrete_test$strength)<font></font>
                    [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.8064655576</span></code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jangan khawatir jika hasil Anda berbeda dengan kami. </font><font style="vertical-align: inherit;">Karena jaringan saraf mulai bekerja dengan bobot acak, prediksi yang disajikan dalam buku mungkin berbeda untuk model yang berbeda. </font><font style="vertical-align: inherit;">Jika Anda ingin mencocokkan hasilnya secara akurat, cobalah perintah set.seed (12345) sebelum Anda mulai membangun jaringan saraf.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika korelasinya mendekati 1, ini menunjukkan hubungan linear yang kuat antara kedua variabel. </font><font style="vertical-align: inherit;">Oleh karena itu, korelasi sekitar 0,806 menunjukkan hubungan yang agak kuat. </font><font style="vertical-align: inherit;">Ini berarti bahwa model bekerja cukup baik bahkan dengan satu simpul tersembunyi. </font><font style="vertical-align: inherit;">Karena kami hanya menggunakan satu simpul tersembunyi, kemungkinan kami dapat meningkatkan efisiensi model, yang akan kami coba lakukan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah 5. Meningkatkan Efisiensi Model</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena jaringan dengan topologi yang lebih kompleks dapat mempelajari konsep yang lebih kompleks, mari kita lihat apa yang terjadi jika Anda meningkatkan jumlah node tersembunyi menjadi lima. </font><font style="vertical-align: inherit;">Kami akan menggunakan fungsi neuralnet (), seperti sebelumnya, tetapi menambahkan parameter hidden = 5:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete_model2 &lt;- neuralnet(strength ~ cement + slag +<font></font>
                                               ash + water + superplastic +<font></font>
                                               coarseagg + fineagg + age,<font></font>
                                               data = concrete_train, hidden = <span class="hljs-number">5</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah membangun diagram jaringan lagi (Gbr. 7.12), kita akan melihat peningkatan tajam dalam jumlah koneksi. Bagaimana ini mempengaruhi efisiensi? </font></font><br>
<br>
<code>&gt; plot(concrete_model2)</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Harap dicatat bahwa kesalahan yang dihasilkan (diukur kembali sebagai SSE) menurun dari 5,08 pada model sebelumnya menjadi 1,63. Selain itu, jumlah tahapan pelatihan meningkat dari 4882 menjadi 86.849 - yang tidak mengejutkan, mengingat betapa rumitnya model ini. Semakin kompleks jaringan, semakin banyak iterasi yang diperlukan untuk menemukan bobot optimal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menerapkan langkah-langkah yang sama untuk membandingkan nilai yang diprediksi dengan yang benar, kami mendapatkan korelasi sekitar 0,92, yang jauh lebih baik dibandingkan dengan hasil sebelumnya dari 0,80 untuk jaringan dengan satu simpul tersembunyi:</font></font><br>
<br>
<pre><code class="java hljs">&gt; model_results2 &lt;- compute(concrete_model2, concrete_test[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>])<font></font>
&gt; predicted_strength2 &lt;- model_results2$net.result<font></font>
&gt; cor(predicted_strength2, concrete_test$strength)<font></font>
                  [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.9244533426</span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/x2/57/55/x25755f5wjbx5meuttyzyv0fczi.png" alt="gambar"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meskipun ada peningkatan signifikan, Anda dapat melangkah lebih jauh untuk meningkatkan efektivitas model. Secara khusus, dimungkinkan untuk memperkenalkan lapisan tersembunyi tambahan dan mengubah fungsi aktivasi jaringan. Dengan melakukan perubahan ini, kami meletakkan dasar untuk membangun jaringan saraf yang dalam dan sederhana. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pilihan fungsi aktivasi sangat penting untuk pembelajaran yang mendalam. Fungsi terbaik untuk tugas belajar tertentu biasanya ditemukan secara eksperimental, dan kemudian banyak digunakan oleh komunitas peneliti pembelajaran mesin.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baru-baru ini, fungsi aktivasi, yang disebut fungsi distilasi, atau penyearah, telah menjadi sangat populer karena aplikasi yang sukses dalam tugas-tugas kompleks, seperti pengenalan gambar. Node jaringan saraf di mana penyearah digunakan sebagai fungsi aktivasi disebut Rectified Linear Unit (ReLU). Seperti yang ditunjukkan pada gambar. 7.13, fungsi aktivasi tipe penyearah dijelaskan sedemikian rupa sehingga mengembalikan x jika x lebih besar dari atau sama dengan 0, dan 0 sebaliknya. Pentingnya fungsi ini adalah bahwa, di satu sisi, itu non-linear, dan di sisi lain, ia memiliki sifat matematika sederhana yang membuatnya murah secara komputasi dan sangat efisien untuk gradient descent. Sayangnya, untuk x = 0, turunan penyearah tidak ditentukan,oleh karena itu, penyearah tidak dapat digunakan bersamaan dengan fungsi neuralnet ().</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai gantinya, Anda dapat menggunakan perkiraan yang dihaluskan dari ReLU yang disebut softplus atau SmoothReLU, fungsi aktivasi yang didefinisikan sebagai log (1 + ex). </font><font style="vertical-align: inherit;">Seperti yang ditunjukkan pada gambar. </font><font style="vertical-align: inherit;">7.13, fungsi softplus mendekati nol untuk nilai x kurang dari 0 dan kira-kira sama dengan x untuk x lebih besar dari 0.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/k9/us/lu/k9uslumivm12vadxdm5d__dhzoq.png" alt="gambar"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mendefinisikan fungsi softplus () di R, kami menggunakan kode berikut: </font></font><br>
<br>
<code>&gt; softplus &lt;- function(x) { log(1 + exp(x)) }</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi aktivasi semacam itu dapat disediakan untuk input neuralnet () menggunakan parameter act.fct. </font><font style="vertical-align: inherit;">Selain itu, kami menambahkan lapisan tersembunyi kedua yang terdiri dari lima node, menetapkan parameter tersembunyi nilai vektor integer c (5, 5). </font><font style="vertical-align: inherit;">Hasilnya, kami mendapatkan jaringan dua lapis, yang masing-masing lapisannya memiliki lima simpul, dan semuanya menggunakan fungsi aktivasi softplus:</font></font><br>
<br>
<pre><code class="java hljs">&gt; set.seed(<span class="hljs-number">12345</span>)<font></font>
&gt; concrete_model3 &lt;- neuralnet(strength ~ cement + slag +<font></font>
                                               ash + water + superplastic +<font></font>
                                               coarseagg + fineagg + age,<font></font>
                                               data = concrete_train,<font></font>
                                               hidden = c(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>),<font></font>
                                               act.fct = softplus)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti sebelumnya, jaringan dapat divisualisasikan (Gbr. 7.14):</font></font><br>
<br>
<code>&gt; plot(concrete_model3)</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yw/yy/om/ywyyomaklvohzlzh-jp2ljggypi.png" alt="gambar"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Korelasi antara kekuatan beton yang diprediksi dan yang sebenarnya dapat dihitung sebagai berikut:</font></font><br>
<br>
<pre><code class="java hljs">&gt; model_results3 &lt;- compute(concrete_model3, concrete_test[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>])<font></font>
&gt; predicted_strength3 &lt;- model_results3$net.result<font></font>
&gt; cor(predicted_strength3, concrete_test$strength)<font></font>
                  [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.9348395359</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Korelasi antara kekuatan yang diprediksi dan yang sebenarnya adalah 0,935, yang merupakan indikator terbaik yang diperoleh sejauh ini. Menariknya, dalam publikasi asli, Ye melaporkan korelasi 0,885. Ini berarti bahwa, dengan usaha yang relatif sedikit, kami bisa mendapatkan hasil yang sebanding dan bahkan melampaui hasil ahli di bidang ini. Benar, hasil Ye diterbitkan pada tahun 1998, yang memberi kami awal lebih dari 20 tahun penelitian tambahan di bidang jaringan saraf! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Detail penting lainnya harus diperhitungkan: karena kami menormalkan data sebelum model dilatih, prakiraan juga dalam interval normal dari 0 hingga 1. Misalnya, kode berikut menunjukkan kerangka data yang membandingkan garis-demi-garis nilai kekuatan beton dari set data awal dengan prakiraan yang sesuai:</font></font><br>
<br>
<pre><code class="java hljs">&gt; strengths &lt;- data.frame(<font></font>
      actual = concrete$strength[<span class="hljs-number">774</span>:<span class="hljs-number">1030</span>],<font></font>
      pred = predicted_strength3<font></font>
   )<font></font>
&gt; head(strengths, n = <span class="hljs-number">3</span>)<font></font>
      actual        pred<font></font>
<span class="hljs-number">774</span> <span class="hljs-number">30.14</span> <span class="hljs-number">0.2860639091</span>
<span class="hljs-number">775</span> <span class="hljs-number">44.40</span> <span class="hljs-number">0.4777304648</span>
<span class="hljs-number">776</span> <span class="hljs-number">24.50</span> <span class="hljs-number">0.2840964250</span></code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan memeriksa korelasinya, kita melihat bahwa pilihan data yang dinormalisasi atau non-normal tidak mempengaruhi statistik kinerja yang dihitung - seperti sebelumnya, korelasinya adalah 0,935: </font><font style="vertical-align: inherit;">
Tetapi jika kita menghitung indikator kinerja yang berbeda, misalnya, perbedaan absolut antara nilai yang diprediksi dan nilai aktual, maka pilihan skala akan sangat penting. </font><font style="vertical-align: inherit;">
Dengan mengingat hal ini, Anda dapat membuat fungsi unormalize (), yang akan melakukan kebalikan dari normalisasi minimum, dan akan memungkinkan Anda untuk mengubah perkiraan normalisasi ke skala asli:</font></font><br>
<br>
<code>&gt; cor(strengths$pred, strengths$actual)<br>
[1] 0.9348395359</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="java hljs">&gt; unnormalize &lt;- function(x) {
     <span class="hljs-keyword">return</span>((x * (max(concrete$strength)) -<font></font>
           min(concrete$strength)) + min(concrete$strength))<font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menerapkan fungsi unormalize () yang kami tulis ke prakiraan, menjadi jelas bahwa skala prakiraan baru serupa dengan nilai awal dari kekuatan beton. </font><font style="vertical-align: inherit;">Ini memungkinkan Anda menghitung nilai bermakna kesalahan absolut. </font><font style="vertical-align: inherit;">Selain itu, korelasi antara nilai kekuatan abnormal dan awal tetap tidak berubah:</font></font><br>
<br>
<pre><code class="java hljs">&gt; strengths$pred_new &lt;- unnormalize(strengths$pred)<font></font>
&gt; strengths$error &lt;- strengths$pred_new — strengths$actual<font></font>
&gt; head(strengths, n = <span class="hljs-number">3</span>)<font></font>
           actual                pred             pred_new                    error<font></font>
<span class="hljs-number">774</span>          <span class="hljs-number">30.14</span>         <span class="hljs-number">0.2860639091</span>               <span class="hljs-number">23.62887889</span>      -<span class="hljs-number">6.511121108</span>
<span class="hljs-number">775</span>          <span class="hljs-number">44.40</span>         <span class="hljs-number">0.4777304648</span>               <span class="hljs-number">39.46053639</span>      -<span class="hljs-number">4.939463608</span>
<span class="hljs-number">776</span>          <span class="hljs-number">24.50</span>         <span class="hljs-number">0.2840964250</span>               <span class="hljs-number">23.46636470</span>      -<span class="hljs-number">1.033635298</span><font></font>
<font></font>
&gt; cor(strengths$pred_new, strengths$actual)<font></font>
[<span class="hljs-number">1</span>] <span class="hljs-number">0.9348395359</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menerapkan jaringan saraf pada proyek Anda, Anda harus mengikuti urutan langkah yang sama untuk mengembalikan data ke skala aslinya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda juga dapat menemukan bahwa jaringan saraf dengan cepat menjadi lebih kompleks karena mereka digunakan untuk tugas belajar yang semakin sulit. Misalnya, Anda mungkin mengalami masalah gradien kecil yang disebut "menghilang" dan masalah gradien "meledak" yang terkait erat, ketika algoritma propagasi belakang tidak menemukan solusi yang berguna, karena tidak menyatu dalam waktu yang wajar. Untuk mengatasi masalah ini, Anda dapat mencoba mengubah jumlah node tersembunyi, menerapkan berbagai fungsi aktivasi, seperti ReLU, menyesuaikan kecepatan belajar, dll. Pada halaman bantuan untuk fungsi neuralnet, Anda akan menemukan informasi tambahan tentang berbagai parameter yang dapat dikonfigurasi. Namun, ini mengarah ke masalah lain,ketika hambatan dalam membangun model yang sangat efisien adalah memeriksa sejumlah besar parameter. Ini adalah harga dari menggunakan jaringan saraf, dan bahkan jaringan pembelajaran yang lebih dalam: potensi besar mereka membutuhkan banyak waktu dan kekuatan pemrosesan.</font></font><br>
<br>
<blockquote>       ,  ML     .     ,   Amazon Web Services (AWS)  Microsoft Azure,          .       12.</blockquote><br>
<h3>  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode Support Vector Machine (SVM) dapat direpresentasikan sebagai permukaan yang membentuk batas antara titik data yang diplot dalam ruang multidimensi yang menggambarkan contoh dan nilai atributnya. Tujuan SVM adalah untuk membangun perbatasan datar - hyperplane yang membagi ruang sedemikian rupa sehingga kelompok-kelompok homogen terbentuk di kedua sisi. Dengan demikian, pelatihan SVM menggabungkan aspek-aspek baik pelatihan tetangga terdekat berdasarkan contoh yang dijelaskan dalam Bab 3 dan pemodelan regresi linier, dibahas dalam Bab 6. Ini adalah kombinasi yang sangat kuat yang memungkinkan SVM untuk memodelkan hubungan yang sangat kompleks.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terlepas dari kenyataan bahwa matematika dasar yang mendasari SVM telah ada selama beberapa dekade, minat terhadap metode ini telah tumbuh secara signifikan setelah mereka mulai diterapkan pada ML. Popularitas metode ini meningkat setelah kisah sukses profil tinggi dalam memecahkan masalah pembelajaran yang kompleks, serta setelah pengembangan algoritma SVM, yang diberikan dan diimplementasikan di perpustakaan yang didukung dengan baik dalam banyak bahasa pemrograman, termasuk R. Setelah itu, metode SVM diterima oleh khalayak luas. Kalau tidak, mungkin tidak mungkin untuk menerapkan matematika kompleks yang diperlukan untuk mengimplementasikan SVM. Berita baiknya adalah meskipun matematika mungkin kompleks, konsep dasarnya dapat dipahami.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode SVM dapat diadaptasi untuk menggunakan hampir semua jenis tugas pelatihan, termasuk klasifikasi dan peramalan numerik. </font><font style="vertical-align: inherit;">Banyak keberhasilan kunci dari algoritma ini berkaitan dengan pengenalan pola. </font><font style="vertical-align: inherit;">Aplikasi paling terkenal untuk metode ini meliputi yang berikut:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">klasifikasi data tentang ekspresi gen microarray dalam bioinformatika untuk deteksi kanker dan penyakit genetik lainnya;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kategorisasi teks, seperti menentukan bahasa yang digunakan dalam suatu dokumen, atau mengklasifikasikan dokumen berdasarkan topik;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deteksi peristiwa langka tapi penting, seperti kegagalan mesin pembakaran internal, pelanggaran keamanan, atau gempa bumi.</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode SVM paling mudah dipahami dengan menggunakan klasifikasi biner sebagai contoh - ini adalah cara mereka biasa digunakan. </font><font style="vertical-align: inherit;">Oleh karena itu, di bagian yang tersisa, kami hanya akan fokus pada pengklasifikasi SVM. </font><font style="vertical-align: inherit;">Prinsip-prinsip yang mirip dengan yang disajikan di sini juga digunakan ketika mengadaptasi metode SVM untuk peramalan numerik.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tentang Penulis</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brett Lantz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (@DataSpelunking) telah menggunakan teknik pemrosesan data inovatif untuk mempelajari perilaku manusia selama lebih dari satu dekade. </font><font style="vertical-align: inherit;">Menjadi seorang sosiolog melalui pelatihan, Brett pertama kali tertarik pada pembelajaran mesin sambil menjelajahi basis data besar profil remaja di jejaring sosial. </font><font style="vertical-align: inherit;">Brett adalah seorang guru di DataCamp dan sering membuat presentasi di konferensi pembelajaran mesin dan seminar di seluruh dunia. </font><font style="vertical-align: inherit;">Dia adalah penggemar terkenal di bidang aplikasi praktis ilmu data di bidang olahraga, kendaraan tak berawak, studi bahasa asing dan mode, serta di banyak industri lainnya. </font><font style="vertical-align: inherit;">Brett berharap suatu hari menulis tentang semua ini di datapelunking.com, pertukaran pengetahuan tentang menemukan pola dalam data.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentang Editor Sains</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raghav Bali</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Raghav Bali) - peneliti senior dari salah satu organisasi perawatan kesehatan terbesar di dunia. Dia terlibat dalam penelitian dan pengembangan solusi perusahaan berdasarkan pembelajaran mesin, pembelajaran mendalam dan pemrosesan bahasa alami untuk digunakan dalam perawatan kesehatan dan asuransi. Dalam posisi sebelumnya di Intel, ia berpartisipasi dalam inisiatif proaktif di bidang teknologi informasi, berdasarkan data besar, menggunakan pemrosesan bahasa alami, pembelajaran mendalam dan metode statistik tradisional. Di American Express, ia bekerja di perikatan digital dan retensi pelanggan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raghav adalah penulis beberapa buku yang diterbitkan oleh penerbit terkemuka. </font><font style="vertical-align: inherit;">Buku terbarunya adalah tentang studi transfer terbaru. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raghav lulus dari Institut Internasional Teknologi Informasi di Bangalore, memiliki gelar master (gelar kehormatan). </font><font style="vertical-align: inherit;">Di saat-saat langka ketika dia tidak sibuk menyelesaikan masalah ilmiah, Raghav suka membaca dan memotret semuanya secara berurutan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
»Informasi lebih lanjut tentang buku ini dapat ditemukan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di situs web penerbit</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isi</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kutipan</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Untuk Khabrozhiteley Diskon 25% pada kupon - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembelajaran Mesin</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Setelah pembayaran versi kertas buku, sebuah buku elektronik dikirim melalui email.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id496242/index.html">Cyberpunk sudah ada di sini: anak sekolah belajar di Minecraft, dan siswa mengambil tes fisik di CS: GO</a></li>
<li><a href="../id496248/index.html">Tantangan, kepala botak dan anggur. Bagaimana kami di HFLabs mengalami isolasi diri</a></li>
<li><a href="../id496250/index.html">Bagaimana kode aneh menyembunyikan kesalahan? Analisis TensorFlow.NET</a></li>
<li><a href="../id496252/index.html">Pesawat centering offset yang aerodinamis</a></li>
<li><a href="../id496254/index.html">Bagaimana Rostelecom salah mengarahkan lalu lintas ke Google, AWS, Cloudflare, dll.</a></li>
<li><a href="../id496258/index.html">Holivar online: format baru untuk pertukaran pengalaman. Sabtu ini</a></li>
<li><a href="../id496260/index.html">Kiat keamanan siber untuk bekerja dari rumah</a></li>
<li><a href="../id496262/index.html">Mendapatkan ID CVE</a></li>
<li><a href="../id496268/index.html">Produk dan solusi jaringan Huawei Enterprise untuk pelanggan perusahaan pada tahun 2020</a></li>
<li><a href="../id496272/index.html">Privasi diferensial: membandingkan perpustakaan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>