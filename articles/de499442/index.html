<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🎓 ☎️ 🤒 Erstellen eines Pseudo-3D-Rennspiels: Implementieren der Hügel und Beenden des Spiels ㊙️ 🙍🏼 👩🏽‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teil 3. Hügel
 
 Im vorherigen Teil haben wir ein einfaches pseudo-dreidimensionales Rennspiel erstellt , in dem gerade Straßen und Kurven realisiert ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines Pseudo-3D-Rennspiels: Implementieren der Hügel und Beenden des Spiels</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499442/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 3. Hügel</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/892/231/4e8/8922314e8acebdd3ae14fba511d17294.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im vorherigen Teil haben wir ein einfaches pseudo-dreidimensionales </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rennspiel erstellt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in dem gerade Straßen und Kurven realisiert wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Mal werden wir uns um die Hügel kümmern; </font><font style="vertical-align: inherit;">Zum Glück ist es viel einfacher als kurvige Straßen zu erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im ersten Teil haben wir das Gesetz ähnlicher Dreiecke verwendet, um eine dreidimensionale perspektivische Projektion zu erstellen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/949/0ab/47b/9490ab47bb570b61218e46e5913c18bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... was uns dazu brachte, die Gleichungen für die Projektion der Koordinaten der 3D-Welt in die Koordinate des 2D-Bildschirms zu erhalten.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/246/e18/edb246e187e7fe0eb027b53c58790c34.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... aber seitdem haben wir nur mit geraden Straßen gearbeitet, die Weltkoordinaten brauchten nur die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Komponente </font><font style="vertical-align: inherit;">, weil sowohl </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als auch </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gleich Null waren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies passt gut zu uns, da es zum Hinzufügen von Hügeln ausreicht, den Straßensegmenten die entsprechende Koordinate </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ungleich Null zu geben </font><font style="vertical-align: inherit;">, wonach die vorhandene Funktion auf </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">magische Weise funktioniert.</font></font><a name="habracut"></a><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ede/dc6/295/ededc629516e6f0d2c7f1ca6b111e17d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ja, das ist genug, um die Hügel zu erreichen. </font><font style="vertical-align: inherit;">Fügen Sie einfach die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Komponente zu den Weltkoordinaten jedes Straßensegments hinzu </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Änderungen in der Straßengeometrie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden die bestehenden Verfahren modifizieren , </font></font><code>addSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so dass die Funktion , die </font><font style="vertical-align: inherit;">sie aufrufen , </font><font style="vertical-align: inherit;">übergeben kann </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2.world.y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1.world.y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entsprechen würde </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2.world.y des</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vorherigen Segments:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params">curve, y</span>) </span>{
  <span class="hljs-keyword">var</span> n = segments.length;<font></font>
  segments.push({<font></font>
     <span class="hljs-attr">index</span>: n,
        <span class="hljs-attr">p1</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">y</span>: lastY(), <span class="hljs-attr">z</span>:  n   *segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
        <span class="hljs-attr">p2</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">y</span>: y,       <span class="hljs-attr">z</span>: (n+<span class="hljs-number">1</span>)*segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
     <span class="hljs-attr">curve</span>: curve,
     <span class="hljs-attr">color</span>: <span class="hljs-built_in">Math</span>.floor(n/rumbleLength)%<span class="hljs-number">2</span> ? COLORS.DARK : COLORS.LIGHT<font></font>
  });<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastY</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (segments.length == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : segments[segments.length<span class="hljs-number">-1</span>].p2.world.y;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen Sie Konstanten hinzu, um niedrige ( </font></font><code>LOW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), mittlere ( </font></font><code>MEDIUM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) und hohe ( </font></font><code>HIGH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Hügel zu bezeichnen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> ROAD = {
  <span class="hljs-attr">LENGTH</span>: { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">SHORT</span>:  <span class="hljs-number">25</span>, <span class="hljs-attr">MEDIUM</span>:  <span class="hljs-number">50</span>, <span class="hljs-attr">LONG</span>:  <span class="hljs-number">100</span> },
  <span class="hljs-attr">HILL</span>:   { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">LOW</span>:    <span class="hljs-number">20</span>, <span class="hljs-attr">MEDIUM</span>:  <span class="hljs-number">40</span>, <span class="hljs-attr">HIGH</span>:   <span class="hljs-number">60</span> },
  <span class="hljs-attr">CURVE</span>:  { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">EASY</span>:    <span class="hljs-number">2</span>, <span class="hljs-attr">MEDIUM</span>:   <span class="hljs-number">4</span>, <span class="hljs-attr">HARD</span>:    <span class="hljs-number">6</span> }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ändern Sie die vorhandene Methode </font></font><code>addRoad()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass sie das Argument </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erhält </font><font style="vertical-align: inherit;">, das zusammen mit den Glättungsfunktionen für den allmählichen Auf- und Abstieg vom Hügel verwendet wird:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRoad</span>(<span class="hljs-params">enter, hold, leave, curve, y</span>) </span>{
  <span class="hljs-keyword">var</span> startY   = lastY();
  <span class="hljs-keyword">var</span> endY     = startY + (Util.toInt(y, <span class="hljs-number">0</span>) * segmentLength);
  <span class="hljs-keyword">var</span> n, total = enter + hold + leave;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; enter ; n++)<font></font>
    addSegment(Util.easeIn(<span class="hljs-number">0</span>, curve, n/enter), Util.easeInOut(startY, endY, n/total));
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; hold  ; n++)<font></font>
    addSegment(curve, Util.easeInOut(startY, endY, (enter+n)/total));<font></font>
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; leave ; n++)<font></font>
    addSegment(Util.easeInOut(curve, <span class="hljs-number">0</span>, n/leave), Util.easeInOut(startY, endY, (enter+hold+n)/total));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ähnlich wie in Teil 2 </font></font><code>addSCurves()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">können wir außerdem alle Methoden festlegen, die wir zum Konstruieren der Geometrie benötigen, zum Beispiel:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addLowRollingHills</span>(<span class="hljs-params">num, height</span>) </span>{<font></font>
  num    = num    || ROAD.LENGTH.SHORT;<font></font>
  height = height || ROAD.HILL.LOW;<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  height/<span class="hljs-number">2</span>);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>, -height);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  height);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  height/<span class="hljs-number">2</span>);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>);<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Änderungen an der Aktualisierungsmethode</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dem von uns erstellten Arcade-Spiel werden wir nicht versuchen, die Realität zu simulieren, sodass die Hügel den Spieler oder die Spielwelt in keiner Weise beeinflussen, was bedeutet, dass </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keine Änderungen </font><font style="vertical-align: inherit;">an der Methode </font><font style="vertical-align: inherit;">erforderlich sind.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hill-Rendering</font></font></h2><br><font style="vertical-align: inherit;"></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auch </font><font style="vertical-align: inherit;">
bei der Methode </font><font style="vertical-align: inherit;">sind keine Änderungen erforderlich, da die Projektionsgleichungen ursprünglich so geschrieben wurden, dass die Straßensegmente mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinaten ungleich Null korrekt projiziert werden </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallax Scrolling Hintergrund</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zum Hinzufügen von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinaten zu allen Straßensegmenten </font><font style="vertical-align: inherit;">besteht die einzige Änderung in der Implementierung der vertikalen Verschiebung der Hintergrundebenen zusammen mit den Hügeln (genau wie sie sich horizontal entlang der Kurven bewegen). </font><font style="vertical-align: inherit;">Wir implementieren dies mit einem anderen Argument für die Hilfsfunktion </font></font><code>Render.background</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der einfachste Mechanismus ist die übliche Hintergrundverschiebung relativ zur Position </font></font><code>playerY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(die aus den Weltpositionen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y des</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aktuellen Spielersegments </font><font style="vertical-align: inherit;">interpoliert werden sollte </font><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist nicht das realistischste Verhalten, da es sich wahrscheinlich lohnt, die Steigung des aktuellen Abschnitts der Straße des Spielers zu berücksichtigen. Dieser Effekt ist jedoch einfach und eignet sich gut für eine einfache Demo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles, jetzt können wir die gefälschten Kurven mit echten Hügeln ergänzen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/892/231/4e8/8922314e8acebdd3ae14fba511d17294.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Arbeit, die wir im ersten Teil geleistet haben, einschließlich der Infrastruktur für das Hinzufügen real projizierter 3D-Hügel, habe ich Ihnen zuvor noch nicht erzählt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im letzten Teil des Artikels werden wir Sprites sowie Bäume und Werbetafeln entlang der Straßenränder hinzufügen. </font><font style="vertical-align: inherit;">Wir werden auch andere Autos hinzufügen, gegen die es möglich sein wird, zu konkurrieren, Kollisionen zu erkennen und den „Kreisrekord“ des Spielers zu korrigieren.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 4. Bereit Version</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/103/563/0d1/1035630d19106de2f85edebb24d0421f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Teil werden wir hinzufügen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Werbetafeln und Bäume</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Autos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kollisionserkennung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rudimentäre KI von Autos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schnittstelle mit Runden-Timer und Rundenrekord</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... und dies wird uns ein ausreichendes Maß an Interaktivität bieten, um unser Projekt schließlich als "Spiel" zu bezeichnen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis zur Codestruktur</font></font></h2><br>
<blockquote><em>     ,            /,         Javascript.</em></blockquote><br>
<blockquote><em>                .     () ,             ...</em></blockquote><br>
<blockquote><em>…      ,       ,           ,  ,         .</em></blockquote><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6f/111/acc/f6f111accbba448459e25c6fe761ff05.png"></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Teil 1 haben wir vor Beginn des Spielzyklus ein Sprite-Blatt hochgeladen, das alle Autos, Bäume und Werbetafeln enthält. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können ein Sprite-Blatt in jedem Bildeditor manuell erstellen. Es ist jedoch besser, die Speicherung von Bildern und die Berechnung von Koordinaten einem automatisierten Werkzeug anzuvertrauen. </font><font style="vertical-align: inherit;">In meinem Fall wurde das Sprite-Blatt durch eine kleine Rake-Aufgabe mit der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruby Gem-Sprite-Factory</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generiert </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Aufgabe generiert kombinierte Spritesheets aus separaten Bilddateien und berechnet auch die Koordinaten x, y, w, h, die in einer Konstanten gespeichert werden </font></font><code>SPRITES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> SPRITES = {
  <span class="hljs-attr">PALM_TREE</span>:   { <span class="hljs-attr">x</span>:    <span class="hljs-number">5</span>, <span class="hljs-attr">y</span>:    <span class="hljs-number">5</span>, <span class="hljs-attr">w</span>:  <span class="hljs-number">215</span>, <span class="hljs-attr">h</span>:  <span class="hljs-number">540</span> },
  <span class="hljs-attr">BILLBOARD08</span>: { <span class="hljs-attr">x</span>:  <span class="hljs-number">230</span>, <span class="hljs-attr">y</span>:    <span class="hljs-number">5</span>, <span class="hljs-attr">w</span>:  <span class="hljs-number">385</span>, <span class="hljs-attr">h</span>:  <span class="hljs-number">265</span> },<font></font>
<font></font>
  <span class="hljs-comment">// ... etc</span><font></font>
<font></font>
  <span class="hljs-attr">CAR04</span>:       { <span class="hljs-attr">x</span>: <span class="hljs-number">1383</span>, <span class="hljs-attr">y</span>:  <span class="hljs-number">894</span>, <span class="hljs-attr">w</span>:   <span class="hljs-number">80</span>, <span class="hljs-attr">h</span>:   <span class="hljs-number">57</span> },
  <span class="hljs-attr">CAR01</span>:       { <span class="hljs-attr">x</span>: <span class="hljs-number">1205</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1018</span>, <span class="hljs-attr">w</span>:   <span class="hljs-number">80</span>, <span class="hljs-attr">h</span>:   <span class="hljs-number">56</span> },<font></font>
};</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinzufügen von Werbetafeln und Bäumen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen Sie jedem Straßensegment ein Array hinzu, das Sprites von Objekten entlang der Straßenränder enthält. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes Sprite besteht </font></font><code>source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus der Sammlung </font></font><code>SPRITES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zusammen mit einem horizontalen Versatz </font></font><code>offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der so normalisiert ist, dass -1 den linken Straßenrand angibt und +1 den rechten Rand bedeutet, sodass wir uns nicht auf den Wert verlassen können </font></font><code>roadWidth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Sprites werden absichtlich platziert, andere werden zufällig ausgewählt.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params"></span>) </span>{<font></font>
  segments.push({<font></font>
    ...<font></font>
    sprites: [],<font></font>
    ...<font></font>
  });<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSprite</span>(<span class="hljs-params">n, sprite, offset</span>) </span>{<font></font>
  segments[n].sprites.push({ <span class="hljs-attr">source</span>: sprite, <span class="hljs-attr">offset</span>: offset });<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetSprites</span>(<span class="hljs-params"></span>) </span>{<font></font>
<font></font>
  addSprite(<span class="hljs-number">20</span>,  SPRITES.BILLBOARD07, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">40</span>,  SPRITES.BILLBOARD06, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">60</span>,  SPRITES.BILLBOARD08, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">80</span>,  SPRITES.BILLBOARD09, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">100</span>, SPRITES.BILLBOARD01, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">120</span>, SPRITES.BILLBOARD02, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">140</span>, SPRITES.BILLBOARD03, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">160</span>, SPRITES.BILLBOARD04, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">180</span>, SPRITES.BILLBOARD05, <span class="hljs-number">-1</span>);<font></font>
<font></font>
  addSprite(<span class="hljs-number">240</span>, SPRITES.BILLBOARD07, <span class="hljs-number">-1.2</span>);<font></font>
  addSprite(<span class="hljs-number">240</span>, SPRITES.BILLBOARD06,  <span class="hljs-number">1.2</span>);<font></font>
<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">250</span> ; n &lt; <span class="hljs-number">1000</span> ; n += <span class="hljs-number">5</span>) {<font></font>
    addSprite(n, SPRITES.COLUMN, <span class="hljs-number">1.1</span>);<font></font>
    addSprite(n + Util.randomInt(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>), SPRITES.TREE1, <span class="hljs-number">-1</span> - (<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>));<font></font>
    addSprite(n + Util.randomInt(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>), SPRITES.TREE2, <span class="hljs-number">-1</span> - (<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>));<font></font>
  }<font></font>
<font></font>
  ...<font></font>
}</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Wenn wir ein echtes Spiel erstellen würden, könnten wir einen Straßeneditor schreiben, um visuell eine Karte mit Hügeln und Kurven zu erstellen, sowie einen Mechanismus zum Anordnen von Sprites entlang der Straße hinzufügen ... aber für unsere Aufgaben können wir dies einfach programmgesteuert tun </font></font><code>addSprite()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maschinen hinzufügen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zu den Sprites von Objekten an den Straßenrändern werden wir eine Sammlung von Autos hinzufügen, die jedes Segment belegen, sowie eine separate Sammlung </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aller</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Autos auf der Autobahn.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> cars      = [];  <span class="hljs-comment">// array of cars on the road</span>
<span class="hljs-keyword">var</span> totalCars = <span class="hljs-number">200</span>; <span class="hljs-comment">// total number of cars on the road</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params"></span>) </span>{<font></font>
  segments.push({<font></font>
    ...<font></font>
    cars: [], <span class="hljs-comment">// array of cars within this segment</span><font></font>
    ...<font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch die Speicherung von zwei Fahrzeugdatenstrukturen können wir alle Fahrzeuge in einer Methode einfach iterativ umgehen </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und sie bei Bedarf von einem Segment in ein anderes verschieben. </font><font style="vertical-align: inherit;">Gleichzeitig können wir so </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur Maschinen auf sichtbaren Segmenten </font><font style="vertical-align: inherit;">ausführen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede Maschine erhält eine zufällige horizontale Verschiebung, z-Position, Sprite-Quelle und Geschwindigkeit:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetCars</span>(<span class="hljs-params"></span>) </span>{<font></font>
  cars = [];<font></font>
  <span class="hljs-keyword">var</span> n, car, segment, offset, z, sprite, speed;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span> ; n &lt; totalCars ; n++) {<font></font>
    offset = <span class="hljs-built_in">Math</span>.random() * Util.randomChoice([<span class="hljs-number">-0.8</span>, <span class="hljs-number">0.8</span>]);<font></font>
    z      = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * segments.length) * segmentLength;<font></font>
    sprite = Util.randomChoice(SPRITES.CARS);<font></font>
    speed  = maxSpeed/<span class="hljs-number">4</span> + <span class="hljs-built_in">Math</span>.random() * maxSpeed/(sprite == SPRITES.SEMI ? <span class="hljs-number">4</span> : <span class="hljs-number">2</span>);<font></font>
    car = { <span class="hljs-attr">offset</span>: offset, <span class="hljs-attr">z</span>: z, <span class="hljs-attr">sprite</span>: sprite, <span class="hljs-attr">speed</span>: speed };<font></font>
    segment = findSegment(car.z);<font></font>
    segment.cars.push(car);<font></font>
    cars.push(car);<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hill Rendering (Rückkehr)</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den vorherigen Abschnitten habe ich über das Rendern von Straßensegmenten gesprochen, einschließlich Kurven und Hügeln, aber es gab einige Codezeilen, die ich nicht berücksichtigt habe. Sie betrafen eine Variable </font></font><code>maxy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die am unteren Bildschirmrand beginnt, aber beim Rendern jedes Segments abnimmt, um festzustellen, welchen Teil des Bildschirms wir bereits gerendert haben:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; drawDistance ; n++) {<font></font>
<font></font>
  ...<font></font>
<font></font>
  if ((segment.p1.camera.z &lt;= cameraDepth) || <span class="hljs-comment">// behind us</span>
      (segment.p2.screen.y &gt;= maxy))          <span class="hljs-comment">// clip by (already rendered) segment</span>
    <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
  ...<font></font>
<font></font>
  maxy = segment.p2.screen.y;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise können wir Segmente beschneiden, die von bereits gerenderten Hügeln bedeckt sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim traditionellen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithmus des Künstlers erfolgt das</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendern normalerweise von hinten nach vorne, während engere Segmente die fernen überlappen. </font><font style="vertical-align: inherit;">Wir können jedoch keine Zeit damit verbringen, Polygone zu rendern, die eventuell überschrieben werden. Daher wird es einfacher, von vorne nach hinten zu rendern und entfernte Segmente zuzuschneiden, die von bereits gerenderten Segmenten abgedeckt werden, wenn ihre projizierten Koordinaten kleiner sind </font></font><code>maxy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Werbetafeln, Bäume und Autos rendern</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das iterative Durchlaufen von Straßensegmenten von vorne nach hinten funktioniert jedoch beim Rendern von Sprites nicht, da sie sich häufig überlappen und daher mit dem Algorithmus des Künstlers gerendert werden müssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies verkompliziert unsere Methode </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und zwingt uns, Straßensegmente in zwei Schritten zu umgehen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von vorne nach hinten für die Straßenwiedergabe</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zurück vorwärts zum Rendern von Sprites</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8db/7d3/347/8db7d3347ac49621e67b7bbe2028fc6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zu teilweise überlappenden Sprites müssen wir uns mit Sprites befassen, die aufgrund des Horizonts auf der Spitze des Hügels „leicht hervorstehen“. Wenn das Sprite hoch genug ist, sollten wir seinen oberen Teil sehen, auch wenn sich das Straßensegment, auf dem es sich befindet, auf der Rückseite des Hügels befindet und daher nicht gerendert wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können das letzte Problem lösen, indem wir den Wert </font></font><code>maxy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jedes Segments </font></font><code>clip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Schritt 1 </font><font style="vertical-align: inherit;">als Linie </font><font style="vertical-align: inherit;">speichern </font><font style="vertical-align: inherit;">. Dann können wir die Sprites dieses Segments </font></font><code>clip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Schritt 2 </font><font style="vertical-align: inherit;">entlang der Linie zuschneiden </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Rest der Renderlogik bestimmt, wie das Sprite basierend auf dem Koeffizienten </font></font><code>scale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und den Koordinaten </font></font><code>screen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Straßensegmente </font><font style="vertical-align: inherit;">skaliert und positioniert wird </font><font style="vertical-align: inherit;">(berechnet auf Stufe 1), aufgrund derer </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">in der zweiten Stufe der Methode </font><font style="vertical-align: inherit;">ungefähr Folgendes haben:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// back to front painters algorithm</span>
<span class="hljs-keyword">for</span>(n = (drawDistance<span class="hljs-number">-1</span>) ; n &gt; <span class="hljs-number">0</span> ; n--) {<font></font>
  segment = segments[(baseSegment.index + n) % segments.length];<font></font>
<font></font>
  <span class="hljs-comment">// render roadside sprites</span>
  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span> ; i &lt; segment.sprites.length ; i++) {<font></font>
    sprite      = segment.sprites[i];<font></font>
    spriteScale = segment.p1.screen.scale;<font></font>
    spriteX     = segment.p1.screen.x + (spriteScale * sprite.offset * roadWidth * width/<span class="hljs-number">2</span>);<font></font>
    spriteY     = segment.p1.screen.y;<font></font>
    Render.sprite(ctx, width, height, resolution, roadWidth, sprites, sprite.source, spriteScale, spriteX, spriteY, (sprite.offset &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, segment.clip);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// render other cars</span>
  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span> ; i &lt; segment.cars.length ; i++) {<font></font>
    car         = segment.cars[i];<font></font>
    sprite      = car.sprite;<font></font>
    spriteScale = Util.interpolate(segment.p1.screen.scale, segment.p2.screen.scale, car.percent);<font></font>
    spriteX     = Util.interpolate(segment.p1.screen.x,     segment.p2.screen.x,     car.percent) + (spriteScale * car.offset * roadWidth * width/<span class="hljs-number">2</span>);<font></font>
    spriteY     = Util.interpolate(segment.p1.screen.y,     segment.p2.screen.y,     car.percent);<font></font>
    Render.sprite(ctx, width, height, resolution, roadWidth, sprites, car.sprite, spriteScale, spriteX, spriteY, <span class="hljs-number">-0.5</span>, <span class="hljs-number">-1</span>, segment.clip);<font></font>
  }<font></font>
<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kollisionen mit Werbetafeln und Bäumen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt, da wir Objekt-Sprites entlang der Straßenränder hinzufügen und rendern können, müssen wir die Methode ändern, </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um festzustellen, ob der Spieler auf eines dieser Sprites in seinem aktuellen Segment gestoßen ist: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir verwenden eine Hilfsmethode, </font></font><code>Util.overlap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um die allgemeine Erkennung des Schnittpunkts von Rechtecken zu implementieren. </font><font style="vertical-align: inherit;">Wenn eine Kreuzung erkannt wird, halten wir das Auto an:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">if</span> ((playerX &lt; <span class="hljs-number">-1</span>) || (playerX &gt; <span class="hljs-number">1</span>)) {
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; playerSegment.sprites.length ; n++) {<font></font>
    sprite  = playerSegment.sprites[n];<font></font>
    spriteW = sprite.source.w * SPRITES.SCALE;<font></font>
    <span class="hljs-keyword">if</span> (Util.overlap(playerX, playerW, sprite.offset + spriteW/<span class="hljs-number">2</span> * (sprite.offset &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>), spriteW)) {
      <span class="hljs-comment">// stop the car</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Wenn Sie den tatsächlichen Code studieren, werden Sie feststellen, dass wir das Auto tatsächlich nicht anhalten, da es sich dann nicht seitwärts bewegen kann, um Hindernissen auszuweichen. </font><font style="vertical-align: inherit;">Als einfachen Hack legen wir ihre Position fest und lassen das Auto seitlich um das Sprite herum „rutschen“.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kollisionen mit Autos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zu Kollisionen mit Sprites entlang der Straßenränder müssen wir Kollisionen mit anderen Autos erkennen. Wenn eine Kreuzung erkannt wird, verlangsamen wir den Spieler, indem wir ihn hinter die Maschine zurückschieben, mit der er kollidierte:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; playerSegment.cars.length ; n++) {<font></font>
  car  = playerSegment.cars[n];<font></font>
  carW = car.sprite.w * SPRITES.SCALE;<font></font>
  <span class="hljs-keyword">if</span> (speed &gt; car.speed) {
    <span class="hljs-keyword">if</span> (Util.overlap(playerX, playerW, car.offset, carW, <span class="hljs-number">0.8</span>)) {
      <span class="hljs-comment">// slow the car</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maschinen-Update</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit sich andere Autos auf der Straße bewegen, geben wir ihnen die einfachste KI:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit konstanter Geschwindigkeit fahren</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gehen Sie beim Überholen automatisch um den Spieler herum</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Überholen automatisch um andere Autos herumfahren</font></font></li>
</ul><br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Wir müssen uns keine Sorgen machen, andere Autos entlang einer Kurve auf der Straße zu drehen, da die Kurven nicht real sind. </font><font style="vertical-align: inherit;">Wenn wir die Autos nur entlang der Straßensegmente bewegen, fahren sie automatisch entlang der Kurven.</font></font></em></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All dies geschieht während des Spielzyklus </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">während eines Anrufs, </font></font><code>updateCars()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bei dem wir jedes Auto mit konstanter Geschwindigkeit vorwärts bewegen und von einem Segment zum nächsten wechseln, wenn es sich in diesem Frame um eine ausreichende Strecke bewegt hat.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateCars</span>(<span class="hljs-params">dt, playerSegment, playerW</span>) </span>{
  <span class="hljs-keyword">var</span> n, car, oldSegment, newSegment;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; cars.length ; n++) {<font></font>
    car         = cars[n];<font></font>
    oldSegment  = findSegment(car.z);<font></font>
    car.offset  = car.offset + updateCarOffset(car, oldSegment, playerSegment, playerW);<font></font>
    car.z       = Util.increase(car.z, dt * car.speed, trackLength);<font></font>
    car.percent = Util.percentRemaining(car.z, segmentLength); <span class="hljs-comment">// useful for interpolation during rendering phase</span><font></font>
    newSegment  = findSegment(car.z);<font></font>
    <span class="hljs-keyword">if</span> (oldSegment != newSegment) {<font></font>
      index = oldSegment.cars.indexOf(car);<font></font>
      oldSegment.cars.splice(index, <span class="hljs-number">1</span>);<font></font>
      newSegment.cars.push(car);<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Methode </font></font><code>updateCarOffset()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bietet die Implementierung von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"künstlicher Intelligenz"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die es der Maschine ermöglicht, um den Spieler oder andere Maschinen herumzugehen. </font><font style="vertical-align: inherit;">Dies ist eine der komplexesten Methoden in der Codebasis, und in einem echten Spiel sollte es viel komplexer sein, damit die Maschinen viel realistischer erscheinen als in einer einfachen Demo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Projekt verwenden wir eine naive KI-Brute-Force, die jede Maschine zwingt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Freuen Sie sich auf 20 Segmente</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sie ein langsameres Auto vor sich findet, das ihren Weg kreuzt, dann gehe um sie herum</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biegen Sie rechts ab von Hindernissen auf der linken Straßenseite</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biegen Sie links von den Hindernissen auf der rechten Straßenseite ab</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drehen Sie sich so weit, dass Hindernisse in der verbleibenden Entfernung vermieden werden</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können auch mit Autos schummeln, die für den Spieler unsichtbar sind, so dass sie einfach nicht umeinander herumfahren und durchfahren können. </font><font style="vertical-align: inherit;">Sie sollten nur innerhalb der Sichtbarkeit des Spielers „klug“ erscheinen.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateCarOffset</span>(<span class="hljs-params">car, carSegment, playerSegment, playerW</span>) </span>{<font></font>
<font></font>
  <span class="hljs-keyword">var</span> i, j, dir, segment, otherCar, otherCarW, lookahead = <span class="hljs-number">20</span>, carW = car.sprite.w * SPRITES.SCALE;<font></font>
<font></font>
  <span class="hljs-comment">// optimization, dont bother steering around other cars when 'out of sight' of the player</span>
  <span class="hljs-keyword">if</span> ((carSegment.index - playerSegment.index) &gt; drawDistance)
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span> ; i &lt; lookahead ; i++) {<font></font>
    segment = segments[(carSegment.index+i)%segments.length];<font></font>
<font></font>
    <span class="hljs-keyword">if</span> ((segment === playerSegment) &amp;&amp; (car.speed &gt; speed) &amp;&amp; (Util.overlap(playerX, playerW, car.offset, carW, <span class="hljs-number">1.2</span>))) {
      <span class="hljs-keyword">if</span> (playerX &gt; <span class="hljs-number">0.5</span>)<font></font>
        dir = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (playerX &lt; <span class="hljs-number">-0.5</span>)<font></font>
        dir = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">else</span>
        dir = (car.offset &gt; playerX) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">return</span> dir * <span class="hljs-number">1</span>/i * (car.speed-speed)/maxSpeed; <span class="hljs-comment">// the closer the cars (smaller i) and the greater the speed ratio, the larger the offset</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span> ; j &lt; segment.cars.length ; j++) {<font></font>
      otherCar  = segment.cars[j];<font></font>
      otherCarW = otherCar.sprite.w * SPRITES.SCALE;<font></font>
      <span class="hljs-keyword">if</span> ((car.speed &gt; otherCar.speed) &amp;&amp; Util.overlap(car.offset, carW, otherCar.offset, otherCarW, <span class="hljs-number">1.2</span>)) {
        <span class="hljs-keyword">if</span> (otherCar.offset &gt; <span class="hljs-number">0.5</span>)<font></font>
          dir = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (otherCar.offset &lt; <span class="hljs-number">-0.5</span>)<font></font>
          dir = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span>
          dir = (car.offset &gt; otherCar.offset) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">return</span> dir * <span class="hljs-number">1</span>/i * (car.speed-otherCar.speed)/maxSpeed;<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den meisten Fällen funktioniert dieser Algorithmus recht gut, aber bei einer großen Anzahl von Autos vorne können wir feststellen, dass sich die Autos von links nach rechts und zurück bewegen und versuchen, sich in die Lücke zwischen den beiden anderen Maschinen zu quetschen. </font><font style="vertical-align: inherit;">Es gibt viele Möglichkeiten, die Zuverlässigkeit der KI zu verbessern. Sie können beispielsweise zulassen, dass Autos langsamer werden, wenn sie feststellen, dass nicht genügend Platz vorhanden ist, um Hindernissen auszuweichen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schnittstelle</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich werden wir eine rudimentäre HTML-Oberfläche erstellen:</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;div id = "hud"&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id = "speed" class = "hud"&gt; &lt;span id = "speed_value" class = "value"&gt; 0 &lt;/ span&gt; mph &lt;/ span&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id = "current_lap_time" class = "hud"&gt; Zeit: &lt;span id = "current_lap_time_value" class = "value"&gt; 0.0 &lt;/ span&gt; &lt;/ span&gt; </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id = "last_lap_time" class = "hud"&gt; Letzte Runde: &lt;span id = "last_lap_time_value" class = "value"&gt; 0.0 &lt;/ span&gt; &lt;/ span&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id = "fast_lap_time" class = "hud"&gt; Schnellste Runde: &lt;span id = "fast_lap_time_value" class = "value"&gt; 0.0 &lt;/ span&gt; &lt;/ span&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&lt;/ div&gt;</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... und fügen Sie CSS-Stil hinzu</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-id">#hud</span>                   { <span class="hljs-attribute">position</span>: absolute; <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>; <span class="hljs-attribute">width</span>: <span class="hljs-number">640px</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span> <span class="hljs-number">0</span>; <span class="hljs-attribute">font-family</span>: Verdana, Geneva, sans-serif; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.8em</span>; <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.4</span>); <span class="hljs-attribute">color</span>: black; <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">2px</span> solid black; <span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-attribute">-moz-box-sizing</span>: border-box; <span class="hljs-attribute">-webkit-box-sizing</span>: border-box; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-class">.hud</span>              { <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0.6</span>); <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>; <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black; <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">5px</span>; <span class="hljs-attribute">transition-property</span>: background-color; <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">2s</span>; <span class="hljs-attribute">-webkit-transition-property</span>: background-color; <span class="hljs-attribute">-webkit-transition-duration</span>: <span class="hljs-number">2s</span>; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#speed</span>            { <span class="hljs-attribute">float</span>: right; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#current_lap_time</span> { <span class="hljs-attribute">float</span>: left;  }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#last_lap_time</span>    { <span class="hljs-attribute">float</span>: left; <span class="hljs-attribute">display</span>: none;  }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#fast_lap_time</span>    { <span class="hljs-attribute">display</span>: block; <span class="hljs-attribute">width</span>: <span class="hljs-number">12em</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto; <span class="hljs-attribute">text-align</span>: center; <span class="hljs-attribute">transition-property</span>: background-color; <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">2s</span>; <span class="hljs-attribute">-webkit-transition-property</span>: background-color; <span class="hljs-attribute">-webkit-transition-duration</span>: <span class="hljs-number">2s</span>; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-class">.value</span>            { <span class="hljs-attribute">color</span>: black; <span class="hljs-attribute">font-weight</span>: bold; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-class">.fastest</span>          { <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">215</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>); }</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... und wir werden das Update () während des Spielzyklus ausführen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">if</span> (position &gt; playerZ) {
  <span class="hljs-keyword">if</span> (currentLapTime &amp;&amp; (startPosition &lt; playerZ)) {<font></font>
    lastLapTime    = currentLapTime;<font></font>
    currentLapTime = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (lastLapTime &lt;= Util.toFloat(Dom.storage.fast_lap_time)) {<font></font>
      Dom.storage.fast_lap_time = lastLapTime;<font></font>
      updateHud(<span class="hljs-string">'fast_lap_time'</span>, formatTime(lastLapTime));<font></font>
      Dom.addClassName(<span class="hljs-string">'fast_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
      Dom.addClassName(<span class="hljs-string">'last_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span> {<font></font>
      Dom.removeClassName(<span class="hljs-string">'fast_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
      Dom.removeClassName(<span class="hljs-string">'last_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
    }<font></font>
    updateHud(<span class="hljs-string">'last_lap_time'</span>, formatTime(lastLapTime));<font></font>
    Dom.show(<span class="hljs-string">'last_lap_time'</span>);<font></font>
  }<font></font>
  <span class="hljs-keyword">else</span> {<font></font>
    currentLapTime += dt;<font></font>
  }<font></font>
}<font></font>
<font></font>
updateHud(<span class="hljs-string">'speed'</span>,            <span class="hljs-number">5</span> * <span class="hljs-built_in">Math</span>.round(speed/<span class="hljs-number">500</span>));<font></font>
updateHud(<span class="hljs-string">'current_lap_time'</span>, formatTime(currentLapTime));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der Hilfsmethode </font></font><code>updateHud()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">können wir DOM-Elemente nur aktualisieren, wenn sich die Werte ändern, da eine solche Aktualisierung ein langsamer Prozess sein kann und wir sie nicht mit 60 fps durchführen sollten, wenn sich die Werte selbst nicht ändern.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHud</span>(<span class="hljs-params">key, value</span>) </span>{ <span class="hljs-comment">// accessing DOM can be slow, so only do it if value has changed</span>
  <span class="hljs-keyword">if</span> (hud[key].value !== value) {<font></font>
    hud[key].value = value;<font></font>
    Dom.set(hud[key].dom, value);<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/103/563/0d1/1035630d19106de2f85edebb24d0421f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fuh! </font><font style="vertical-align: inherit;">Der letzte Teil war lang, aber wir waren noch fertig und die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fertige Version</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erreichte das Stadium, in dem es als Spiel bezeichnet werden kann. </font><font style="vertical-align: inherit;">Sie ist noch weit vom </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fertigen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spiel entfernt, aber es ist immer noch ein Spiel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist erstaunlich, dass wir es wirklich geschafft haben, ein Spiel zu erstellen, wenn auch so einfach. </font><font style="vertical-align: inherit;">Ich habe nicht vor, dieses Projekt in einen vollständigen Zustand zu versetzen. </font><font style="vertical-align: inherit;">Es sollte lediglich als </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in das Thema der pseudo-dreidimensionalen Rennspiele betrachtet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird von github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> veröffentlicht und Sie können versuchen, daraus ein fortgeschritteneres Rennspiel zu machen. </font><font style="vertical-align: inherit;">Sie können auch versuchen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie Autos Soundeffekte hinzu</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Musiksynchronisation verbessern</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollbild implementieren</font></font></li>
<li>   (   , ,    ,  ..)</li>
<li>    </li>
<li>   (,   ..)</li>
<li>       </li>
<li> ,     </li>
<li> ,          -</li>
<li> ,     </li>
<li>   (   ,     ..)</li>
<li>    drawDistance</li>
<li>         x,y</li>
<li>     </li>
<li>      (   ,  )</li>
<li> </li>
<li> </li>
<li>     </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gabel- und Straßenverbindungen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Veränderung von Tag und Nacht</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wetterverhältnisse</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tunnel, Brücken, Wolken, Mauern, Gebäude</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stadt, Wüste, Ozean</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie Seattle und Space Needle zu den Hintergründen hinzu</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Schurken" - fügen Sie Konkurrenten hinzu, mit denen Sie konkurrieren können</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spielmodi - die schnellste Runde, eins zu eins Rennen (Münzen einsammeln?, auf Bösewichte schießen?)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tonnenweise Anpassungsoptionen für das Gameplay</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usw.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also sind wir fertig. </font><font style="vertical-align: inherit;">Ein weiteres „Wochenendprojekt“, das viel länger dauerte als erwartet, aber am Ende war das Ergebnis ziemlich gut.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginn einer Reihe von Artikeln, geraden Straßen und Kurven</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lou's Pseudo 3d Seite</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Links zu spielbaren Demos:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo auf gerader Straße</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo mit Kurven</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hills Demo</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fertige Version</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de499432/index.html">Autonomie von Unit-Tests in PHPUnit</a></li>
<li><a href="../de499434/index.html">So implementieren Sie Wissensmanagement: Nutzen Sie „Beutel“, „Papageienstrafen“ und Clip-Denken</a></li>
<li><a href="../de499436/index.html">Das ferngesteuerte Enzym beschleunigt die Behandlung von Schlaganfällen und Wirbelsäulenverletzungen</a></li>
<li><a href="../de499438/index.html">Stream für Tester und nicht nur</a></li>
<li><a href="../de499440/index.html">Da haben wir den coolsten Autopiloten der Welt für eine Rangierlok geschrieben</a></li>
<li><a href="../de499444/index.html">Postgres: Aufblähen, pg_repack und verzögerte Einschränkungen</a></li>
<li><a href="../de499446/index.html">Testen von Bootloadern im STEP-Format für VR</a></li>
<li><a href="../de499448/index.html">Implementierung von SOLID und Layered Architecture in Node.js mit TypeScript und InversifyJS</a></li>
<li><a href="../de499450/index.html">Auswahl der Ausrüstung für ein persisches Spiel unter Verwendung von Genetik / Evolution in Python</a></li>
<li><a href="../de499452/index.html">Alltag eines Augenarztes in der Klinik: Wenn Ärzte nicht genug sind</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>