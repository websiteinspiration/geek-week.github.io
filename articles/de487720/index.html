<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ï üíä üî∞ Zum Wettbewerbskorutinismus (am Beispiel der reaktiven Programmierung) üè¥‚Äç‚ò†Ô∏è üÖæÔ∏è ü§¶üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Einleitung
 Der Wettbewerb um die K√∂pfe, Stimmungen und Bestrebungen der Programmierer ist meines Erachtens ein moderner Trend in der Entwicklung d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Zum Wettbewerbskorutinismus (am Beispiel der reaktiven Programmierung)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487720/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Einleitung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Wettbewerb um die K√∂pfe, Stimmungen und Bestrebungen der Programmierer ist meines Erachtens ein moderner Trend in der Entwicklung der Programmierung. Wenn fast nichts vorgeschlagen wird, obwohl unter dem Motto des Kampfes daf√ºr. Es ist sehr, sehr schwierig, im Gedr√§nge von Software-Paradigmen etwas Neues zu erkennen, das sich in der Tat oft als recht bekannt und manchmal einfach veraltet herausstellt. Alles wird durch terminologische Freuden, ausf√ºhrliche Analysen und mehrzeilige Beispiele in vielen Programmiersprachen ‚Äûweggesp√ºlt‚Äú. Gleichzeitig werden Anfragen, den Hintergrund der L√∂sung zu √∂ffnen und / oder zu ber√ºcksichtigen, die Essenz von Innovationen hartn√§ckig vermieden, die Versuche herauszufinden, wie viel dies ben√∂tigt wird und was am Ende geben wird, was die Innovation qualitativ von bereits bekannten Ans√§tzen und Programmierwerkzeugen unterscheidet, im Keim vereitelt.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich erschien auf Habr√©, wie in einer der Diskussionen treffend bemerkt wurde, nach einem gewissen Einfrieren. Es wird mir nicht einmal etwas ausmachen. Zumindest ist der Eindruck anscheinend genau das. Daher stimme ich zu, ich gestehe, obwohl es, wenn es meine Schuld ist, nur teilweise ist. Ich gebe zu, ich lebe nach den Ideen der parallelen Programmierung, die in den 80er Jahren des letzten Jahrhunderts entstanden sind. Antike? K√∂nnte sein. Aber sagen Sie mir, was es Neues gibt, √ºber das die Wissenschaft der [parallelen] Programmierung damals noch nicht bekannt w√§re (siehe Details [1]). Zu dieser Zeit wurden parallele Programme in zwei Klassen unterteilt - parallel-seriell und asynchron. Wenn die ersteren bereits als archaisch angesehen wurden, dann die letzteren - fortgeschritten und wirklich parallel. Unter den letzteren wurden die Programmierung mit Ereignissteuerung (oder nur Ereignisprogrammierung), die Streamsteuerung und die dynamische Programmierung herausgegriffen.Das ist alles im Allgemeinen. Weitere Details bereits.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und was bietet die aktuelle Programmierung zus√§tzlich zu dem, was bereits vor mindestens 40 Jahren bekannt war? In meinem "erfrorenen Blick" - nichts. Wie sich herausstellte, werden Coroutinen jetzt Coroutinen oder sogar Goroutinen genannt, und die Begriffe Parallelit√§t und Wettbewerb scheinen nicht nur √úbersetzer zu bet√§uben. Und solche Beispiele gibt es nicht. Was ist beispielsweise der Unterschied zwischen reaktiver Programmierung (RP) und Ereignisprogrammierung oder Streaming? In welche der bekannten Kategorien und / oder Klassifikationen f√§llt es? Niemand scheint daran interessiert zu sein, und niemand kann dies klarstellen. Oder k√∂nnen Sie jetzt nach Namen klassifizieren? Dann sind Coroutinen und Coroutinen in der Tat verschiedene Dinge, und die parallele Programmierung muss sich einfach von der Konkurrenzprogrammierung unterscheiden. Was ist mit Zustandsautomaten? Was f√ºr eine Wundertechnik ist das?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ‚ÄûSpaghetti‚Äú im Kopf entstehen aus dem Vergessen der Theorie, dass ein neues Modell bei der Einf√ºhrung mit bereits bekannten und gut untersuchten Modellen verglichen wird. </font><font style="vertical-align: inherit;">Ob dies gut gemacht wird, k√∂nnen Sie zumindest herausfinden, da der Prozess formalisiert ist. </font><font style="vertical-align: inherit;">Aber wie kommt man dem auf den Grund, wenn man den Coroutinen einen neuen Spitznamen gibt und dann gleichzeitig den ‚ÄûMotorhaubencode‚Äú in f√ºnf Sprachen ausw√§hlt und zus√§tzlich die Aussicht auf eine Migration in Streams bewertet. </font><font style="vertical-align: inherit;">Und dies sind nur Coroutinen, die offen gesagt aufgrund ihrer elementaren Natur und ihres geringen Gebrauchs bereits vergessen werden sollten (es geht nat√ºrlich um meine Erfahrung).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Reaktive Programmierung und alles, alles, alles</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden uns nicht das Ziel setzen, das Konzept der ‚Äûreaktiven Programmierung‚Äú gr√ºndlich zu verstehen, obwohl wir das ‚Äûreaktive Beispiel‚Äú als Grundlage f√ºr weitere Diskussionen nehmen werden. </font><font style="vertical-align: inherit;">Sein formales Modell wird auf Basis des bekannten formalen Modells erstellt. </font><font style="vertical-align: inherit;">Ich hoffe, dies erm√∂glicht es uns, die Interpretation und Funktionsweise des urspr√ºnglichen Programms klar, genau und detailliert zu verstehen. </font><font style="vertical-align: inherit;">Inwieweit das erstellte Modell und seine Implementierung ‚Äûreaktiv‚Äú sein werden, entscheiden die Apologeten dieser Art der Programmierung. </font><font style="vertical-align: inherit;">Im Moment wird es ausreichen, dass das neue Modell alle Nuancen des urspr√ºnglichen Beispiels implementieren / modellieren muss. </font><font style="vertical-align: inherit;">Wenn etwas nicht ber√ºcksichtigt wird, dann hoffe ich, dass es diejenigen gibt, die mich korrigieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In [2] wurde daher ein Beispiel f√ºr ein reaktives Programm betrachtet, dessen Code in Listing 1 dargestellt ist.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 1. Reaktiver Programmcode</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">1. 1 = 2 <font></font>
2. 2 = 3 <font></font>
3. 3 = 1 + 2 <font></font>
4.  1, 2, 3 <font></font>
5. 1 = 4 <font></font>
6.  1, 2, 3</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Welt der reaktiven Programmierung unterscheidet sich das Ergebnis seiner Arbeit vom Ergebnis eines regul√§ren Programms derselben Art. Das allein ist schlecht, wenn nicht h√§sslich, weil Das Ergebnis des Programms sollte eindeutig sein und nicht von der Umsetzung abh√§ngen. Aber mehr verwirrt den anderen. Erstens ist es anscheinend kaum m√∂glich, einen regul√§ren √§hnlichen Code von einem reaktiven zu unterscheiden. Zweitens ist sich der Autor anscheinend der Arbeit des reaktiven Programms nicht ganz sicher und spricht √ºber das Ergebnis ‚Äûh√∂chstwahrscheinlich‚Äú. Und drittens, welches der Ergebnisse wird als richtig angesehen?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine solche Mehrdeutigkeit bei der Auslegung des Codes hat dazu gef√ºhrt, dass es nicht sofort m√∂glich ist, ihn zu ‚Äûschneiden‚Äú. </font><font style="vertical-align: inherit;">Aber dann, wie so oft, stellte sich heraus, dass alles viel einfacher war, als man erwartet h√§tte. </font><font style="vertical-align: inherit;">Abbildung 1 zeigt zwei Strukturdiagramme, die hoffentlich der Struktur entsprechen und die Funktionsweise des Beispiels erl√§utern. </font><font style="vertical-align: inherit;">Im oberen Diagramm organisieren die Bl√∂cke X1 und X2 die Dateneingabe und signalisieren dem Block X3 ihre √Ñnderung. </font><font style="vertical-align: inherit;">Letzterer f√ºhrt die Summierung durch und erm√∂glicht es dem Pr-Block, die aktuellen Werte der Variablen zu drucken. </font><font style="vertical-align: inherit;">Nach dem Drucken signalisiert der Pr-Block dem X3-Block dar√ºber hinaus ihm und nur ihm, dass er bereit ist, neue Werte zu drucken.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. </font><font style="vertical-align: inherit;">1. Zwei Strukturmodelle des Beispiels</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/tw/hs/rq/twhsrqxfdfuyxi4txtd9ciat6hs.jpeg" alt="image"><br>
</div></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite Schema ist im Vergleich zum ersten ziemlich elementar. Als Teil eines einzelnen Blocks werden Daten eingegeben und nacheinander implementiert: 1) Berechnen der Summe der Eingabedaten und 2) Drucken dieser Daten. Die interne F√ºllung des Blocks auf dieser Pr√§sentationsebene wird nicht offenbart. Obwohl gesagt werden kann, dass es sich auf struktureller Ebene um eine "Black Box mit einem Vier-Block-Schema" handeln kann. Trotzdem soll sein [algorithmisches] Ger√§t anders sein. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kommentar. Die Herangehensweise an das Programm als Black Box spiegelt im Wesentlichen die Einstellung des Benutzers dazu wider. Letzterer interessiert sich nicht f√ºr die Umsetzung, sondern f√ºr das Ergebnis der Arbeit. Ob es sich um ein reaktives Programm, ein Ereignisprogramm oder ein anderes handelt, aber das Ergebnis gem√§√ü der Theorie der Algorithmen sollte eindeutig und vorhersehbar sein.</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Abb. </font><font style="vertical-align: inherit;">2 pr√§sentiert algorithmische Modelle, die die interne [algorithmische] Struktur von Schaltungsbl√∂cken im Detail verdeutlichen. </font><font style="vertical-align: inherit;">Das obere Modell wird durch ein Netzwerk von Automaten dargestellt, wobei jede der Automaten ein algorithmisches Modell eines separaten Blocks ist. </font><font style="vertical-align: inherit;">Die Verbindungen zwischen den durch strichpunktierte B√∂gen dargestellten Automaten entsprechen den Verbindungen der Schaltung. </font><font style="vertical-align: inherit;">Ein Einzelautomatenmodell beschreibt den Betriebsalgorithmus eines Blockdiagramms, das aus einem Block besteht (siehe einen separaten Pr-Block in Abb. 1).</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. </font><font style="vertical-align: inherit;">2. Algorithmische Modelle f√ºr Strukturschemata</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/rj/4f/ds/rj4fdsx8kekihnbqqebmpji1y9e.jpeg" alt="image"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Automaten X1 und X2 (die Namen der Automaten und Bl√∂cke stimmen mit den Namen ihrer Variablen √ºberein) erkennen die √Ñnderungen und gehen, wenn der Automat X3 bereit ist, die Additionsoperation auszuf√ºhren (im Zustand "s0"), in den Zustand "s1", wobei der aktuelle Wert der Variablen gespeichert wird. Das X3-Ger√§t, das die Berechtigung zum Eingeben des Status "s1" erhalten hat, f√ºhrt die Additionsoperation aus und wartet bei Bedarf auf den Abschluss des Druckvorgangs der Variablen. ‚ÄûDruckmaschine‚Äú Pr kehrt nach Beendigung des Druckvorgangs in den Ausgangszustand ‚Äûp0‚Äú zur√ºck und wartet auf den n√§chsten Befehl. Beachten Sie, dass sein Zustand "p1" eine Kette von umgekehrten √úberg√§ngen startet - der Automat X3 in den Zustand "s0" und X1 und X2 in den Zustand "s0". Danach wird die Analyse der Eingabedaten, deren Summierung und anschlie√üendes Drucken wiederholt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Vergleich zum Automaten-Netzwerk ist der Algorithmus eines separaten Pr-Automaten recht einfach, aber wir stellen fest, dass er den gleichen Job macht und vielleicht sogar noch schneller. </font><font style="vertical-align: inherit;">Seine Pr√§dikate zeigen eine √Ñnderung der Variablen. </font><font style="vertical-align: inherit;">In diesem Fall erfolgt der √úbergang in den Zustand ‚Äûp1‚Äú mit dem Start der Aktion y1 (siehe Abb. 2), die die aktuellen Werte der Variablen zusammenfasst, w√§hrend sie sich merken. </font><font style="vertical-align: inherit;">Bei einem bedingungslosen √úbergang vom Zustand "p1" zum Zustand "p0" druckt die Aktion y2 die Variablen. </font><font style="vertical-align: inherit;">Danach kehrt der Prozess zur Analyse der Eingabedaten zur√ºck. </font><font style="vertical-align: inherit;">Der Implementierungscode f√ºr das neueste Modell ist in Listing 2 dargestellt.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 2. Implementierung des Pr-Automaten</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span>
<span class="hljs-keyword">extern</span> LArc TBL_PlusX3[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FPlusX3</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FPlusX3(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FPlusX3(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_PlusX3, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarY;        		<span class="hljs-comment">// </span>
    CVar *pVarX1;        		<span class="hljs-comment">// </span>
    CVar *pVarX2;        		<span class="hljs-comment">// </span>
    CVar *pVarX3;        		<span class="hljs-comment">// </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//   X1</span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//   X2</span>
    CVar *pVarStrNameX3;		<span class="hljs-comment">//   X3</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };
    <span class="hljs-keyword">double</span> dSaveX1{<span class="hljs-number">0</span>};
    <span class="hljs-keyword">double</span> dSaveX2{<span class="hljs-number">0</span>};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fplusx3.h"</span></span><font></font>
<font></font>
LArc TBL_PlusX3[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x2"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p1"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"--"</span>,  <span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FPlusX3::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"strY"</span>, CLocVar::vtString, <span class="hljs-string">"print of output string"</span>);			<span class="hljs-comment">//  </span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"dX1"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarX2 = CreateLocVar(<span class="hljs-string">"dX2"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarX3 = CreateLocVar(<span class="hljs-string">"dX3"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX3 = CreateLocVar(<span class="hljs-string">"strNameX3"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;<font></font>
    str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    str = pVarStrNameX3-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX3 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPlusX3::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1-&gt;GetDataSrc() != dSaveX1; }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPlusX3::x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX2-&gt;GetDataSrc() != dSaveX2; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FPlusX3::y1</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// X3 = X1 + X2</span>
    <span class="hljs-keyword">double</span> dX1 = pVarX1-&gt;GetDataSrc(); <span class="hljs-keyword">double</span> dX2 = pVarX2-&gt;GetDataSrc();
    <span class="hljs-keyword">double</span> dX3 = dX1 + dX2;<font></font>
    pVarX3-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, dX3);<font></font>
    dSaveX1 = dX1; dSaveX2 = dX2;<font></font>
<span class="hljs-comment">//  1, 2, 3</span><font></font>
    QString strX1; strX1.setNum(dX1); QString strX2; strX2.setNum(dX2);<font></font>
    QString strX3; strX3.setNum(dX3);<font></font>
    QString qstr = <span class="hljs-string">"X1="</span> + strX1 + <span class="hljs-string">", X2="</span> + strX2 + <span class="hljs-string">", X3="</span> + strX3;<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, qstr.toStdString(), <span class="hljs-literal">nullptr</span>);<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Codemenge ist eindeutig unvergleichlich gr√∂√üer als das urspr√ºngliche Beispiel. Beachten Sie jedoch, dass es keinen einzigen Code gibt. Die neue L√∂sung beseitigt alle Funktionsprobleme und l√§sst bei der Interpretation des Programms keine Fantasien zu. Ein Beispiel, das kompakt und elegant aussieht, von dem man aber "h√∂chstwahrscheinlich" sagen kann, verursacht beispielsweise keine positiven Emotionen und den Wunsch, damit zu arbeiten. Es sollte auch beachtet werden, dass es notwendig ist, tats√§chlich mit der Wirkung des Automaten y1 zu vergleichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Rest des Codes bezieht sich auf die Anforderungen der "automatischen Umgebung", die, wie ich bemerke, im Quellcode nicht gesprochen wird. Also, die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FCreationOfLinksForVariables</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode der </font><font style="vertical-align: inherit;">Basis Automaten Klasse </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LFsaAppl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellt lokale Variablen f√ºr den Computer und verkn√ºpft sie, wenn auf der Ebene der VKPA-Umgebung symbolische Namen der anderen ihnen zugeordneten Umgebungsvariablen angezeigt werden. Das erste Mal beginnt es beim Erstellen eines Automaten und dann im Rahmen der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FInit-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">(siehe Schritt y12), weil Beim Erstellen eines Objekts sind nicht alle Links bekannt. Die Maschine befindet sich im Status "st", bis alle erforderlichen Verkn√ºpfungen, die die x12-Pr√§dikatpr√ºfungen durchf√ºhren, initialisiert wurden. Ein Verweis auf eine Variable gibt, wenn ihr Name angegeben wird, die GetAddressVar-Methode zur√ºck.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um m√∂gliche Fragen zu entfernen, pr√§sentieren wir den Code des Automaten-Netzwerks. </font><font style="vertical-align: inherit;">Es ist in Listing 3 dargestellt und enth√§lt den Code f√ºr drei Automatenklassen. </font><font style="vertical-align: inherit;">Auf ihrer Grundlage werden viele Objekte erstellt, die dem in Abb. 1 gezeigten Strukturdiagramm des Netzwerks entsprechen. </font><font style="vertical-align: inherit;">1. Beachten Sie, dass die Objekte X1 und X2 von der allgemeinen Klasse FSynch abgeleitet sind.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3. Automatisierte Netzwerkklassen</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_Synch[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSynch</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dGetData</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX-&gt;GetDataSrc(); };
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FSynch(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FSynch(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Synch, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarX;			<span class="hljs-comment">// </span>
    CVar *pVarStrNameX;		<span class="hljs-comment">//   </span>
    CVar *pVarStrNameObject;<span class="hljs-comment">//  -</span>
    LFsaAppl *pL {<span class="hljs-literal">nullptr</span>};
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX-&gt;GetDataSrc() != dSaveX; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pL-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pL != <span class="hljs-literal">nullptr</span>; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span> </span>{ dSaveX = pVarX-&gt;GetDataSrc(); }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };
    <span class="hljs-keyword">double</span> dSaveX{<span class="hljs-number">0</span>};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
LArc TBL_Synch[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x2"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FSynch::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX = CreateLocVar(<span class="hljs-string">"x"</span>, CLocVar::vtDouble, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameObject = CreateLocVar(<span class="hljs-string">"strNameObject"</span>, CLocVar::vtString, <span class="hljs-string">"name of function"</span>);                   <span class="hljs-comment">//  </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX) {<font></font>
        str = pVarStrNameX-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    str = pVarStrNameObject-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pL = FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_X1X2X3[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FX1X2X3</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dGetData</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX3-&gt;GetDataSrc(); };
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FX1X2X3(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FX1X2X3(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_X1X2X3, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarX1{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarX2{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarX3{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarStrNameFX1;		<span class="hljs-comment">//  X1</span>
    CVar *pVarStrNameFX2;		<span class="hljs-comment">//  X2</span>
    CVar *pVarStrNameFPr;		<span class="hljs-comment">//  Pr</span>
    CVar *pVarStrNameX3;		<span class="hljs-comment">//   </span>
    FSynch *pLX1 {<span class="hljs-literal">nullptr</span>};<font></font>
    FSynch *pLX2 {<span class="hljs-literal">nullptr</span>};<font></font>
    LFsaAppl *pLPr {<span class="hljs-literal">nullptr</span>};
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX1-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX2-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x3</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLPr-&gt;FGetState() == <span class="hljs-string">"p1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLPr != <span class="hljs-literal">nullptr</span> &amp;&amp; pLX1 &amp;&amp; pLX2 &amp;&amp; pVarX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span> </span>{ pVarX3-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, pLX1-&gt;dGetData() + pLX2-&gt;dGetData()); }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };<font></font>
};<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fx1x2x3.h"</span></span><font></font>
<font></font>
LArc TBL_X1X2X3[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x2"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x3"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FX1X2X3::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX3 = CreateLocVar(<span class="hljs-string">"x"</span>, CLocVar::vtDouble, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameFX1 = CreateLocVar(<span class="hljs-string">"strNameFX1"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameFX2 = CreateLocVar(<span class="hljs-string">"strNameFX2"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameFPr = CreateLocVar(<span class="hljs-string">"strNameFPr"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameX3 = CreateLocVar(<span class="hljs-string">"strNameX3"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str; str = pVarStrNameFX1-&gt;strGetDataSrc();
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX1 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX2 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFPr-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLPr = FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_Print[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FX1X2X3</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FPrint</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FPrint(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FPrint(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Print, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarY;        		<span class="hljs-comment">// </span>
    CVar *pVarStrNameFX1;		<span class="hljs-comment">//    X1</span>
    CVar *pVarStrNameFX2;		<span class="hljs-comment">//    X2</span>
    CVar *pVarStrNameFX3;		<span class="hljs-comment">//    X3</span>
    FSynch *pLX1 {<span class="hljs-literal">nullptr</span>};     <span class="hljs-comment">//    X1</span>
    FSynch *pLX2 {<span class="hljs-literal">nullptr</span>};     <span class="hljs-comment">//    X2</span>
    FX1X2X3 *pLX3 {<span class="hljs-literal">nullptr</span>};    <span class="hljs-comment">//    X3</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX3 != <span class="hljs-literal">nullptr</span> &amp;&amp; pLX1 &amp;&amp; pLX2 &amp;&amp; pLX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };<font></font>
};<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fprint.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fx1x2x3.h"</span></span><font></font>
<font></font>
LArc TBL_Print[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p1"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FPrint::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"strY"</span>, CLocVar::vtString, <span class="hljs-string">"print of output string"</span>);			<span class="hljs-comment">//  </span>
    pVarStrNameFX1 = CreateLocVar(<span class="hljs-string">"strNameFX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameFX2 = CreateLocVar(<span class="hljs-string">"strNameFX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameFX3 = CreateLocVar(<span class="hljs-string">"strNameFX3"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(pr)"</span>);			<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;<font></font>
    str = pVarStrNameFX1-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX1 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX2 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX3-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX3 = (FX1X2X3*)FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPrint::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX3-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FPrint::y1</span><span class="hljs-params">()</span> </span>{<font></font>
    QString strX1; strX1.setNum(pLX1-&gt;dGetData());<font></font>
    QString strX2; strX2.setNum(pLX2-&gt;dGetData());<font></font>
    QString strX3; strX3.setNum(pLX3-&gt;dGetData());<font></font>
    QString qstr = <span class="hljs-string">"X1="</span> + strX1 + <span class="hljs-string">", X2="</span> + strX2 + <span class="hljs-string">", X3="</span> + strX3;<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, qstr.toStdString(), <span class="hljs-literal">nullptr</span>);<font></font>
}<font></font>
</code></pre> <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code unterscheidet sich von Listing 1, wie ein Bild eines Flugzeugs aus der Konstruktionsdokumentation. Aber ich denke, wir sind in erster Linie Programmierer, und einige Designer werden ihnen nicht beleidigt. Unser "Design Code" sollte leicht zu verstehen und eindeutig zu interpretieren sein, damit unser "Flugzeug" beim ersten Flug nicht abst√ºrzt. Und wenn ein solches Ungl√ºck passiert ist und dies bei Programmen h√§ufiger vorkommt als bei Flugzeugen, kann der Grund leicht und schnell gefunden werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Anbetracht von Listing 3 m√ºssen Sie sich daher vorstellen, dass die Anzahl der Klassen nicht direkt mit der Anzahl der entsprechenden Objekte im Parallelprogramm zusammenh√§ngt. Der Code spiegelt nicht die Beziehung zwischen Objekten wider, sondern enth√§lt die Mechanismen, mit denen sie erstellt werden. Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSynch-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">enth√§lt also einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pL-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeiger </font><font style="vertical-align: inherit;">auf ein Objekt vom Typ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LFsaAppl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Der Name dieses Objekts wird durch eine lokale Variable bestimmt, die in der VKPa-Umgebung einer Automatenvariablen mit dem Namen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strNameObject entspricht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ein Zeiger ist erforderlich, um mit der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FGetState-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">den aktuellen Status eines </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatenobjekts vom</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Typ </font><i><font style="vertical-align: inherit;">FSynch zu</font></i><font style="vertical-align: inherit;"> √ºberwachen </font><font style="vertical-align: inherit;">(siehe Pr√§dikatcode x2). √Ñhnliche Zeiger auf Objekte, Variablen zum Angeben der Namen von Objekten und Pr√§dikate zum Organisieren von Beziehungen enthalten andere Klassen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun ein paar Worte zum ‚ÄûAufbau‚Äú eines Parallelprogramms in der VKPA-Umgebung. Es wird beim Laden der Programmkonfiguration erstellt. In diesem Fall werden erste Objekte auf der Basis von Klassen aus thematischen dynamischen Bibliotheken eines Automatentyps erstellt (ihre Menge wird durch die Konfiguration der Anwendung / des Programms bestimmt). Erstellte Objekte werden anhand ihrer Namen identifiziert (nennen wir sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">automatische Variablen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Anschlie√üend werden die erforderlichen Werte in die lokalen Variablen der Automaten geschrieben. </font><font style="vertical-align: inherit;">In unserem Fall werden Variablen mit einem Zeichenfolgentyp auf die Variablennamen anderer Objekte und / oder die Namen der Objekte gesetzt. </font><font style="vertical-align: inherit;">Auf diese Weise werden Verbindungen zwischen Objekten eines Parallelautomatenprogramms hergestellt (siehe Abb. 1). </font><font style="vertical-align: inherit;">Durch √Ñndern der Werte der Eingabevariablen (mithilfe einzelner Objektsteuerungsdialoge oder der Standarddialoge / Umgebungsdialoge zum Festlegen von Werten f√ºr Umgebungsvariablen) wird das Ergebnis korrigiert. </font><font style="vertical-align: inherit;">Es kann mithilfe eines Standardumgebungsdialogs angezeigt werden, um die Werte von Variablen anzuzeigen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Zur Analyse paralleler Programme</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úber die Funktionsweise eines Parallelprogramms ist es sehr, sehr schwierig, etwas Konkretes zu sagen, es sei denn, es ist ganz einfach sequentiell parallel. Das betrachtete Netzwerk von Automaten ist keine Ausnahme. Als n√§chstes werden wir dies sehen und verstehen, was von ihm erwartet werden kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der resultierende Automat und das Netzwerk, f√ºr das er aufgebaut ist, sind in Abb. 2 dargestellt. </font><font style="vertical-align: inherit;">3. Aus dem Netzwerk in Abb. </font><font style="vertical-align: inherit;">2 zeichnet sich neben der Umbenennung seiner Elemente - Automaten, Eingangs- und Ausgangssignale - durch das Fehlen einer ‚ÄûDruckmaschine‚Äú von Variablen aus. </font><font style="vertical-align: inherit;">Letzteres ist f√ºr den Betrieb des Netzwerks nicht unbedingt erforderlich. Durch Umbenennen k√∂nnen Sie die Kompositionsoperation verwenden, um den resultierenden Automaten zu erstellen. </font><font style="vertical-align: inherit;">Um k√ºrzere Namen zu erstellen, wurde zus√§tzlich die Codierung eingef√ºhrt, wenn beispielsweise der Zustand "a0" des Automaten A durch das Symbol "0" und "a1" durch das Symbol "1" dargestellt wird. </font><font style="vertical-align: inherit;">√Ñhnliches gilt f√ºr andere Maschinen. </font><font style="vertical-align: inherit;">In diesem Fall wird dem Komponentenstatus des Netzwerks, z. B. "a1b0c1", der Name "101" zugewiesen. </font><font style="vertical-align: inherit;">In √§hnlicher Weise werden Namen f√ºr alle Komponentenzust√§nde des Netzwerks gebildet, deren Anzahl durch das Produkt der Zust√§nde von Komponentenautomaten bestimmt wird.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. </font><font style="vertical-align: inherit;">3. Der resultierende Netzwerkautomat</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/a8/oc/9k/a8oc9kfwbbm3apemxhjzpbz5mxw.jpeg" alt="image"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Der resultierende Automat kann nat√ºrlich rein formal berechnet werden, aber daf√ºr brauchen wir einen geeigneten ‚ÄûTaschenrechner‚Äú. Ist dies nicht der Fall, k√∂nnen Sie einen recht einfachen intuitiven Algorithmus verwenden. Innerhalb seines Rahmens wird der eine oder andere Komponentenzustand des Netzwerks aufgezeichnet, und dann werden die Zielkomponentenzust√§nde durch "Handles" bestimmt, indem alle m√∂glichen Eingabesituationen sortiert werden. Nachdem also der Zustand "000" festgelegt wurde, der den aktuellen Zust√§nden der Komponentenautomaten - "a0", "b0", "c0" - entspricht, werden √úberg√§nge f√ºr Konjunktionen von Eingangsvariablen ^ x1 ^ x2, ^ x1x2, x1 ^ x2, x1x2 bestimmt. Wir erhalten die √úberg√§nge jeweils in gibt "a0b0c0", "a0b1c0", "a1b0c0", "a1b1c0" an, die auf der resultierenden Maschine mit "000", "010", "100" und "110" gekennzeichnet sind. Schleifendie nicht mit Aktionen geladen sind, k√∂nnen aus dem Diagramm ausgeschlossen werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was wir "im trockenen R√ºckstand" haben. Wir haben die Hauptsache erreicht - wir haben den resultierenden Automaten erhalten, der den Betrieb des Netzwerks genau beschreibt. Wir haben herausgefunden, dass von acht m√∂glichen Netzwerkzust√§nden einer nicht zug√§nglich (isoliert) ist - Zustand ‚Äû001‚Äú. Dies bedeutet, dass die Summierungsoperation unter keinen Umst√§nden f√ºr Eingabevariablen ausgel√∂st wird, die den aktuellen Wert nicht ge√§ndert haben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was st√∂rend ist, obwohl das Testen keine Fehler ergab. In der Grafik des resultierenden Automaten wurden √úberg√§nge gefunden, die bei Ausgabeaktionen in Konflikt stehen. Sie sind mit einer Kombination der Aktionen y1y3 und y2y3 gekennzeichnet. Die Aktionen y1 und y2 werden ausgel√∂st, wenn sich die Eingabedaten √§ndern, und dann berechnet eine andere Aktion y3 die Summe der Variablen parallel zu ihnen. Mit welchen Werten wird es arbeiten - alt oder nur durch neue ge√§ndert? Um Mehrdeutigkeiten zu beseitigen, k√∂nnen Sie einfach die Aktionen von y3 und y4 √§ndern. In diesem Fall lautet ihr Code wie folgt: X3 = X1Sav + X2Sav und print (X1Sav, X2Sav, X3).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit. </font><font style="vertical-align: inherit;">Die Konstruktion des resultierenden Automaten ergab offensichtliche Probleme im erstellten Parallelmodell. </font><font style="vertical-align: inherit;">Ob sie im reaktiven Programm erscheinen, ist eine Frage. </font><font style="vertical-align: inherit;">Alles wird anscheinend von der Herangehensweise an die Umsetzung der Parallelit√§t im reaktiven Paradigma abh√§ngen. </font><font style="vertical-align: inherit;">In jedem Fall muss eine solche Abh√§ngigkeit ber√ºcksichtigt und irgendwie beseitigt werden. </font><font style="vertical-align: inherit;">Bei einem automatisierten Netzwerk ist es einfacher, die ge√§nderte Version zu verlassen, als zu versuchen, das Netzwerk zu √§ndern. </font><font style="vertical-align: inherit;">Es ist in Ordnung, wenn zuerst die "alten" Daten gedruckt werden, die den Netzwerkbetrieb initiiert haben, und dann die aktuellen Daten als n√§chstes gedruckt werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Schlussfolgerung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede der betrachteten L√∂sungen hat ihre Vor- und Nachteile. Das erste ist sehr einfach, das Netzwerk ist komplizierter und wird auf der Basis einer einzelnen Maschine erstellt. Erst nach der Visualisierung werden die Eingabedaten analysiert. Aufgrund seiner Parallelit√§t startet dasselbe automatische Netzwerk die Analyse der Eingabedaten vor dem Ende des Druckvorgangs. Und wenn die Visualisierungszeit lang ist, dies jedoch bei der Summierungsoperation der Fall ist, ist das Netzwerk unter dem Gesichtspunkt der Eingabesteuerung schneller. Jene. Eine Bewertung auf der Grundlage einer Sch√§tzung der Code-Menge bei parallelen Programmen ist nicht immer objektiv. Einfacher ausgedr√ºckt ist das Netzwerk parallel, die Einkomponentenl√∂sung ist weitgehend sequentiell (ihre Pr√§dikate und Aktionen sind parallel). Und wir sprechen zun√§chst von parallelen Programmen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Netzwerkmodell ist auch ein Beispiel f√ºr eine flexible L√∂sung. Erstens k√∂nnen Komponenten unabh√§ngig voneinander entworfen werden. Zweitens kann jede Komponente durch eine andere ersetzt werden. Und drittens kann jede Netzwerkkomponente ein Element einer Bibliothek automatischer Prozesse sein und wird in einer anderen Netzwerkl√∂sung verwendet. Und dies sind nur die offensichtlichsten Vorteile einer parallelen L√∂sung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber zur√ºck zur reaktiven Programmierung. Betrachtet RP alle Programmanweisungen zun√§chst als parallel? Wir k√∂nnen nur davon ausgehen, dass es ohne dies schwierig ist, √ºber ein Programmierparadigma zu sprechen, das ‚Äûauf Datenfl√ºsse und die Ausbreitung von √Ñnderungen ausgerichtet ist‚Äú (siehe die Definition der reaktiven Programmierung in [3]). Aber was ist dann der Unterschied zur Programmierung mit Streaming-Steuerung (f√ºr weitere Details siehe [1])? Wir kehren also zu unserem Ausgangspunkt zur√ºck: Wie klassifiziert man reaktive Programmierung im Rahmen bekannter Klassifikationen? Und wenn RP etwas Besonderes ist, was unterscheidet es dann von den bekannten Programmierparadigmen?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, √ºber die Theorie. Ohne sie w√§re die Analyse paralleler Algorithmen nicht nur schwierig - unm√∂glich. Der Analyseprozess zeigt manchmal Probleme auf, die selbst bei einem sorgf√§ltigen und nachdenklichen Blick auf das Programm, wie √ºbrigens auf das ‚ÄûDesigndokument‚Äú, nicht zu erraten sind. Auf jeden Fall bin ich daf√ºr, dass Flugzeuge sowohl im √ºbertragenen als auch im anderen Sinne nicht abst√ºrzen. Dies ist f√ºr mich die Tatsache, dass Sie nat√ºrlich nach Einfachheit und Anmut der Form streben m√ºssen, aber ohne Qualit√§tsverlust. Wir Programmierer ‚Äûzeichnen‚Äú nicht nur Programme, sondern kontrollieren oft, was dort verborgen ist, auch durch Flugzeuge!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ja, ich h√§tte es fast vergessen. Ich w√ºrde die automatische Programmierung (AP) als Programmierung mit dynamischer Steuerung klassifizieren. Was die Asynchronit√§t betrifft - ich wette. Vorausgesetzt, dass die Basis des AP-Steuerungsmodells ein Netzwerk in einer einzigen Zeit ist, d.h. synchrone Netzwerke von Automaten, dann ist es synchron. Da die VKPa-Umgebung jedoch auch viele Netzwerke durch das Konzept der ‚ÄûAutomatenwelten‚Äú implementiert, ist sie vollst√§ndig asynchron. Im Allgemeinen bin ich gegen einen sehr starren Klassifizierungsrahmen, aber nicht f√ºr Anarchie. In diesem Sinne hoffe ich, dass in VKPa ein gewisser Kompromiss zwischen der Starrheit der seriell-parallelen Programmierung und einem gewissen asynchronen Anarchismus erzielt wurde. Angesichts der Tatsache, dass die automatische Programmierung auch die Klasse der Ereignisprogramme abdeckt (siehe [4]) und Stream-Programme darin leicht modelliert werden k√∂nnen,Von welcher Programmierung kannst du noch tr√§umen? Sicher - f√ºr mich.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literatur</font></font></b><div class="spoiler_text">1.   /.. , .. , .. , .. ;  . .. . ‚Äì .:   , 1983. ‚Äì 240.<br>
2.      . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr.com/ru/post/486632</a> . . . (  07.02.2020).<br>
3.  . . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">ru.wikipedia.org/wiki/_</a> . . . (  07.02.2020).<br>
4.  ‚Äî  ? [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr.com/ru/post/483610</a> . . . (  07.02.2020).<br>
</div></div></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de487698/index.html">Digitale Veranstaltungen in St. Petersburg vom 10. bis 16. Februar</a></li>
<li><a href="../de487702/index.html">Eine Auswahl von Artikeln zum maschinellen Lernen: Fallstudien, Leitf√§den und Forschungsergebnisse f√ºr Januar 2020</a></li>
<li><a href="../de487704/index.html">Wie wir auf der SSRS 2014 dynamische Berichte erstellt haben</a></li>
<li><a href="../de487706/index.html">Service Discovery in verteilten Systemen anhand des Consul-Beispiels. Alexander Sigachev</a></li>
<li><a href="../de487716/index.html">Perfekt SAST. Parser</a></li>
<li><a href="../de487724/index.html">BlazingPizza: Blazor App von Anfang bis Ende. Teil 2. F√ºgen Sie eine Komponente hinzu</a></li>
<li><a href="../de487728/index.html">@ Pythonetc-Zusammenstellung, Januar 2020</a></li>
<li><a href="../de487730/index.html">Verarbeitung nat√ºrlicher Sprache. Ergebnisse 2019 und Trends f√ºr 2020</a></li>
<li><a href="../de487734/index.html">Beschleunigung des Entity Framework-Kerns</a></li>
<li><a href="../de487738/index.html">Schemaanimation in SCADA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>