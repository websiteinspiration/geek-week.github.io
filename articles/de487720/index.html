<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤕 💊 🔰 Zum Wettbewerbskorutinismus (am Beispiel der reaktiven Programmierung) 🏴‍☠️ 🅾️ 🤦🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Einleitung
 Der Wettbewerb um die Köpfe, Stimmungen und Bestrebungen der Programmierer ist meines Erachtens ein moderner Trend in der Entwicklung d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Zum Wettbewerbskorutinismus (am Beispiel der reaktiven Programmierung)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487720/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Einleitung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Wettbewerb um die Köpfe, Stimmungen und Bestrebungen der Programmierer ist meines Erachtens ein moderner Trend in der Entwicklung der Programmierung. Wenn fast nichts vorgeschlagen wird, obwohl unter dem Motto des Kampfes dafür. Es ist sehr, sehr schwierig, im Gedränge von Software-Paradigmen etwas Neues zu erkennen, das sich in der Tat oft als recht bekannt und manchmal einfach veraltet herausstellt. Alles wird durch terminologische Freuden, ausführliche Analysen und mehrzeilige Beispiele in vielen Programmiersprachen „weggespült“. Gleichzeitig werden Anfragen, den Hintergrund der Lösung zu öffnen und / oder zu berücksichtigen, die Essenz von Innovationen hartnäckig vermieden, die Versuche herauszufinden, wie viel dies benötigt wird und was am Ende geben wird, was die Innovation qualitativ von bereits bekannten Ansätzen und Programmierwerkzeugen unterscheidet, im Keim vereitelt.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich erschien auf Habré, wie in einer der Diskussionen treffend bemerkt wurde, nach einem gewissen Einfrieren. Es wird mir nicht einmal etwas ausmachen. Zumindest ist der Eindruck anscheinend genau das. Daher stimme ich zu, ich gestehe, obwohl es, wenn es meine Schuld ist, nur teilweise ist. Ich gebe zu, ich lebe nach den Ideen der parallelen Programmierung, die in den 80er Jahren des letzten Jahrhunderts entstanden sind. Antike? Könnte sein. Aber sagen Sie mir, was es Neues gibt, über das die Wissenschaft der [parallelen] Programmierung damals noch nicht bekannt wäre (siehe Details [1]). Zu dieser Zeit wurden parallele Programme in zwei Klassen unterteilt - parallel-seriell und asynchron. Wenn die ersteren bereits als archaisch angesehen wurden, dann die letzteren - fortgeschritten und wirklich parallel. Unter den letzteren wurden die Programmierung mit Ereignissteuerung (oder nur Ereignisprogrammierung), die Streamsteuerung und die dynamische Programmierung herausgegriffen.Das ist alles im Allgemeinen. Weitere Details bereits.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und was bietet die aktuelle Programmierung zusätzlich zu dem, was bereits vor mindestens 40 Jahren bekannt war? In meinem "erfrorenen Blick" - nichts. Wie sich herausstellte, werden Coroutinen jetzt Coroutinen oder sogar Goroutinen genannt, und die Begriffe Parallelität und Wettbewerb scheinen nicht nur Übersetzer zu betäuben. Und solche Beispiele gibt es nicht. Was ist beispielsweise der Unterschied zwischen reaktiver Programmierung (RP) und Ereignisprogrammierung oder Streaming? In welche der bekannten Kategorien und / oder Klassifikationen fällt es? Niemand scheint daran interessiert zu sein, und niemand kann dies klarstellen. Oder können Sie jetzt nach Namen klassifizieren? Dann sind Coroutinen und Coroutinen in der Tat verschiedene Dinge, und die parallele Programmierung muss sich einfach von der Konkurrenzprogrammierung unterscheiden. Was ist mit Zustandsautomaten? Was für eine Wundertechnik ist das?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die „Spaghetti“ im Kopf entstehen aus dem Vergessen der Theorie, dass ein neues Modell bei der Einführung mit bereits bekannten und gut untersuchten Modellen verglichen wird. </font><font style="vertical-align: inherit;">Ob dies gut gemacht wird, können Sie zumindest herausfinden, da der Prozess formalisiert ist. </font><font style="vertical-align: inherit;">Aber wie kommt man dem auf den Grund, wenn man den Coroutinen einen neuen Spitznamen gibt und dann gleichzeitig den „Motorhaubencode“ in fünf Sprachen auswählt und zusätzlich die Aussicht auf eine Migration in Streams bewertet. </font><font style="vertical-align: inherit;">Und dies sind nur Coroutinen, die offen gesagt aufgrund ihrer elementaren Natur und ihres geringen Gebrauchs bereits vergessen werden sollten (es geht natürlich um meine Erfahrung).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Reaktive Programmierung und alles, alles, alles</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden uns nicht das Ziel setzen, das Konzept der „reaktiven Programmierung“ gründlich zu verstehen, obwohl wir das „reaktive Beispiel“ als Grundlage für weitere Diskussionen nehmen werden. </font><font style="vertical-align: inherit;">Sein formales Modell wird auf Basis des bekannten formalen Modells erstellt. </font><font style="vertical-align: inherit;">Ich hoffe, dies ermöglicht es uns, die Interpretation und Funktionsweise des ursprünglichen Programms klar, genau und detailliert zu verstehen. </font><font style="vertical-align: inherit;">Inwieweit das erstellte Modell und seine Implementierung „reaktiv“ sein werden, entscheiden die Apologeten dieser Art der Programmierung. </font><font style="vertical-align: inherit;">Im Moment wird es ausreichen, dass das neue Modell alle Nuancen des ursprünglichen Beispiels implementieren / modellieren muss. </font><font style="vertical-align: inherit;">Wenn etwas nicht berücksichtigt wird, dann hoffe ich, dass es diejenigen gibt, die mich korrigieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In [2] wurde daher ein Beispiel für ein reaktives Programm betrachtet, dessen Code in Listing 1 dargestellt ist.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 1. Reaktiver Programmcode</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">1. 1 = 2 <font></font>
2. 2 = 3 <font></font>
3. 3 = 1 + 2 <font></font>
4.  1, 2, 3 <font></font>
5. 1 = 4 <font></font>
6.  1, 2, 3</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Welt der reaktiven Programmierung unterscheidet sich das Ergebnis seiner Arbeit vom Ergebnis eines regulären Programms derselben Art. Das allein ist schlecht, wenn nicht hässlich, weil Das Ergebnis des Programms sollte eindeutig sein und nicht von der Umsetzung abhängen. Aber mehr verwirrt den anderen. Erstens ist es anscheinend kaum möglich, einen regulären ähnlichen Code von einem reaktiven zu unterscheiden. Zweitens ist sich der Autor anscheinend der Arbeit des reaktiven Programms nicht ganz sicher und spricht über das Ergebnis „höchstwahrscheinlich“. Und drittens, welches der Ergebnisse wird als richtig angesehen?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine solche Mehrdeutigkeit bei der Auslegung des Codes hat dazu geführt, dass es nicht sofort möglich ist, ihn zu „schneiden“. </font><font style="vertical-align: inherit;">Aber dann, wie so oft, stellte sich heraus, dass alles viel einfacher war, als man erwartet hätte. </font><font style="vertical-align: inherit;">Abbildung 1 zeigt zwei Strukturdiagramme, die hoffentlich der Struktur entsprechen und die Funktionsweise des Beispiels erläutern. </font><font style="vertical-align: inherit;">Im oberen Diagramm organisieren die Blöcke X1 und X2 die Dateneingabe und signalisieren dem Block X3 ihre Änderung. </font><font style="vertical-align: inherit;">Letzterer führt die Summierung durch und ermöglicht es dem Pr-Block, die aktuellen Werte der Variablen zu drucken. </font><font style="vertical-align: inherit;">Nach dem Drucken signalisiert der Pr-Block dem X3-Block darüber hinaus ihm und nur ihm, dass er bereit ist, neue Werte zu drucken.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. </font><font style="vertical-align: inherit;">1. Zwei Strukturmodelle des Beispiels</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/tw/hs/rq/twhsrqxfdfuyxi4txtd9ciat6hs.jpeg" alt="image"><br>
</div></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite Schema ist im Vergleich zum ersten ziemlich elementar. Als Teil eines einzelnen Blocks werden Daten eingegeben und nacheinander implementiert: 1) Berechnen der Summe der Eingabedaten und 2) Drucken dieser Daten. Die interne Füllung des Blocks auf dieser Präsentationsebene wird nicht offenbart. Obwohl gesagt werden kann, dass es sich auf struktureller Ebene um eine "Black Box mit einem Vier-Block-Schema" handeln kann. Trotzdem soll sein [algorithmisches] Gerät anders sein. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kommentar. Die Herangehensweise an das Programm als Black Box spiegelt im Wesentlichen die Einstellung des Benutzers dazu wider. Letzterer interessiert sich nicht für die Umsetzung, sondern für das Ergebnis der Arbeit. Ob es sich um ein reaktives Programm, ein Ereignisprogramm oder ein anderes handelt, aber das Ergebnis gemäß der Theorie der Algorithmen sollte eindeutig und vorhersehbar sein.</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Abb. </font><font style="vertical-align: inherit;">2 präsentiert algorithmische Modelle, die die interne [algorithmische] Struktur von Schaltungsblöcken im Detail verdeutlichen. </font><font style="vertical-align: inherit;">Das obere Modell wird durch ein Netzwerk von Automaten dargestellt, wobei jede der Automaten ein algorithmisches Modell eines separaten Blocks ist. </font><font style="vertical-align: inherit;">Die Verbindungen zwischen den durch strichpunktierte Bögen dargestellten Automaten entsprechen den Verbindungen der Schaltung. </font><font style="vertical-align: inherit;">Ein Einzelautomatenmodell beschreibt den Betriebsalgorithmus eines Blockdiagramms, das aus einem Block besteht (siehe einen separaten Pr-Block in Abb. 1).</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. </font><font style="vertical-align: inherit;">2. Algorithmische Modelle für Strukturschemata</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/rj/4f/ds/rj4fdsx8kekihnbqqebmpji1y9e.jpeg" alt="image"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Automaten X1 und X2 (die Namen der Automaten und Blöcke stimmen mit den Namen ihrer Variablen überein) erkennen die Änderungen und gehen, wenn der Automat X3 bereit ist, die Additionsoperation auszuführen (im Zustand "s0"), in den Zustand "s1", wobei der aktuelle Wert der Variablen gespeichert wird. Das X3-Gerät, das die Berechtigung zum Eingeben des Status "s1" erhalten hat, führt die Additionsoperation aus und wartet bei Bedarf auf den Abschluss des Druckvorgangs der Variablen. „Druckmaschine“ Pr kehrt nach Beendigung des Druckvorgangs in den Ausgangszustand „p0“ zurück und wartet auf den nächsten Befehl. Beachten Sie, dass sein Zustand "p1" eine Kette von umgekehrten Übergängen startet - der Automat X3 in den Zustand "s0" und X1 und X2 in den Zustand "s0". Danach wird die Analyse der Eingabedaten, deren Summierung und anschließendes Drucken wiederholt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Vergleich zum Automaten-Netzwerk ist der Algorithmus eines separaten Pr-Automaten recht einfach, aber wir stellen fest, dass er den gleichen Job macht und vielleicht sogar noch schneller. </font><font style="vertical-align: inherit;">Seine Prädikate zeigen eine Änderung der Variablen. </font><font style="vertical-align: inherit;">In diesem Fall erfolgt der Übergang in den Zustand „p1“ mit dem Start der Aktion y1 (siehe Abb. 2), die die aktuellen Werte der Variablen zusammenfasst, während sie sich merken. </font><font style="vertical-align: inherit;">Bei einem bedingungslosen Übergang vom Zustand "p1" zum Zustand "p0" druckt die Aktion y2 die Variablen. </font><font style="vertical-align: inherit;">Danach kehrt der Prozess zur Analyse der Eingabedaten zurück. </font><font style="vertical-align: inherit;">Der Implementierungscode für das neueste Modell ist in Listing 2 dargestellt.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 2. Implementierung des Pr-Automaten</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span>
<span class="hljs-keyword">extern</span> LArc TBL_PlusX3[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FPlusX3</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FPlusX3(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FPlusX3(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_PlusX3, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarY;        		<span class="hljs-comment">// </span>
    CVar *pVarX1;        		<span class="hljs-comment">// </span>
    CVar *pVarX2;        		<span class="hljs-comment">// </span>
    CVar *pVarX3;        		<span class="hljs-comment">// </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//   X1</span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//   X2</span>
    CVar *pVarStrNameX3;		<span class="hljs-comment">//   X3</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };
    <span class="hljs-keyword">double</span> dSaveX1{<span class="hljs-number">0</span>};
    <span class="hljs-keyword">double</span> dSaveX2{<span class="hljs-number">0</span>};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fplusx3.h"</span></span><font></font>
<font></font>
LArc TBL_PlusX3[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x2"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p1"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"--"</span>,  <span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FPlusX3::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"strY"</span>, CLocVar::vtString, <span class="hljs-string">"print of output string"</span>);			<span class="hljs-comment">//  </span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"dX1"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarX2 = CreateLocVar(<span class="hljs-string">"dX2"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarX3 = CreateLocVar(<span class="hljs-string">"dX3"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX3 = CreateLocVar(<span class="hljs-string">"strNameX3"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;<font></font>
    str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    str = pVarStrNameX3-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX3 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPlusX3::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1-&gt;GetDataSrc() != dSaveX1; }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPlusX3::x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX2-&gt;GetDataSrc() != dSaveX2; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FPlusX3::y1</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// X3 = X1 + X2</span>
    <span class="hljs-keyword">double</span> dX1 = pVarX1-&gt;GetDataSrc(); <span class="hljs-keyword">double</span> dX2 = pVarX2-&gt;GetDataSrc();
    <span class="hljs-keyword">double</span> dX3 = dX1 + dX2;<font></font>
    pVarX3-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, dX3);<font></font>
    dSaveX1 = dX1; dSaveX2 = dX2;<font></font>
<span class="hljs-comment">//  1, 2, 3</span><font></font>
    QString strX1; strX1.setNum(dX1); QString strX2; strX2.setNum(dX2);<font></font>
    QString strX3; strX3.setNum(dX3);<font></font>
    QString qstr = <span class="hljs-string">"X1="</span> + strX1 + <span class="hljs-string">", X2="</span> + strX2 + <span class="hljs-string">", X3="</span> + strX3;<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, qstr.toStdString(), <span class="hljs-literal">nullptr</span>);<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Codemenge ist eindeutig unvergleichlich größer als das ursprüngliche Beispiel. Beachten Sie jedoch, dass es keinen einzigen Code gibt. Die neue Lösung beseitigt alle Funktionsprobleme und lässt bei der Interpretation des Programms keine Fantasien zu. Ein Beispiel, das kompakt und elegant aussieht, von dem man aber "höchstwahrscheinlich" sagen kann, verursacht beispielsweise keine positiven Emotionen und den Wunsch, damit zu arbeiten. Es sollte auch beachtet werden, dass es notwendig ist, tatsächlich mit der Wirkung des Automaten y1 zu vergleichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Rest des Codes bezieht sich auf die Anforderungen der "automatischen Umgebung", die, wie ich bemerke, im Quellcode nicht gesprochen wird. Also, die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FCreationOfLinksForVariables</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode der </font><font style="vertical-align: inherit;">Basis Automaten Klasse </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LFsaAppl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellt lokale Variablen für den Computer und verknüpft sie, wenn auf der Ebene der VKPA-Umgebung symbolische Namen der anderen ihnen zugeordneten Umgebungsvariablen angezeigt werden. Das erste Mal beginnt es beim Erstellen eines Automaten und dann im Rahmen der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FInit-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">(siehe Schritt y12), weil Beim Erstellen eines Objekts sind nicht alle Links bekannt. Die Maschine befindet sich im Status "st", bis alle erforderlichen Verknüpfungen, die die x12-Prädikatprüfungen durchführen, initialisiert wurden. Ein Verweis auf eine Variable gibt, wenn ihr Name angegeben wird, die GetAddressVar-Methode zurück.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um mögliche Fragen zu entfernen, präsentieren wir den Code des Automaten-Netzwerks. </font><font style="vertical-align: inherit;">Es ist in Listing 3 dargestellt und enthält den Code für drei Automatenklassen. </font><font style="vertical-align: inherit;">Auf ihrer Grundlage werden viele Objekte erstellt, die dem in Abb. 1 gezeigten Strukturdiagramm des Netzwerks entsprechen. </font><font style="vertical-align: inherit;">1. Beachten Sie, dass die Objekte X1 und X2 von der allgemeinen Klasse FSynch abgeleitet sind.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3. Automatisierte Netzwerkklassen</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_Synch[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSynch</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dGetData</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX-&gt;GetDataSrc(); };
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FSynch(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FSynch(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Synch, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarX;			<span class="hljs-comment">// </span>
    CVar *pVarStrNameX;		<span class="hljs-comment">//   </span>
    CVar *pVarStrNameObject;<span class="hljs-comment">//  -</span>
    LFsaAppl *pL {<span class="hljs-literal">nullptr</span>};
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX-&gt;GetDataSrc() != dSaveX; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pL-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pL != <span class="hljs-literal">nullptr</span>; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span> </span>{ dSaveX = pVarX-&gt;GetDataSrc(); }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };
    <span class="hljs-keyword">double</span> dSaveX{<span class="hljs-number">0</span>};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
LArc TBL_Synch[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x2"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FSynch::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX = CreateLocVar(<span class="hljs-string">"x"</span>, CLocVar::vtDouble, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameObject = CreateLocVar(<span class="hljs-string">"strNameObject"</span>, CLocVar::vtString, <span class="hljs-string">"name of function"</span>);                   <span class="hljs-comment">//  </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX) {<font></font>
        str = pVarStrNameX-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    str = pVarStrNameObject-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pL = FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_X1X2X3[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FX1X2X3</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dGetData</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX3-&gt;GetDataSrc(); };
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FX1X2X3(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FX1X2X3(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_X1X2X3, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarX1{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarX2{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarX3{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarStrNameFX1;		<span class="hljs-comment">//  X1</span>
    CVar *pVarStrNameFX2;		<span class="hljs-comment">//  X2</span>
    CVar *pVarStrNameFPr;		<span class="hljs-comment">//  Pr</span>
    CVar *pVarStrNameX3;		<span class="hljs-comment">//   </span>
    FSynch *pLX1 {<span class="hljs-literal">nullptr</span>};<font></font>
    FSynch *pLX2 {<span class="hljs-literal">nullptr</span>};<font></font>
    LFsaAppl *pLPr {<span class="hljs-literal">nullptr</span>};
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX1-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX2-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x3</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLPr-&gt;FGetState() == <span class="hljs-string">"p1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLPr != <span class="hljs-literal">nullptr</span> &amp;&amp; pLX1 &amp;&amp; pLX2 &amp;&amp; pVarX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span> </span>{ pVarX3-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, pLX1-&gt;dGetData() + pLX2-&gt;dGetData()); }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };<font></font>
};<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fx1x2x3.h"</span></span><font></font>
<font></font>
LArc TBL_X1X2X3[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x2"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x3"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FX1X2X3::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX3 = CreateLocVar(<span class="hljs-string">"x"</span>, CLocVar::vtDouble, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameFX1 = CreateLocVar(<span class="hljs-string">"strNameFX1"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameFX2 = CreateLocVar(<span class="hljs-string">"strNameFX2"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameFPr = CreateLocVar(<span class="hljs-string">"strNameFPr"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameX3 = CreateLocVar(<span class="hljs-string">"strNameX3"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str; str = pVarStrNameFX1-&gt;strGetDataSrc();
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX1 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX2 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFPr-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLPr = FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_Print[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FX1X2X3</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FPrint</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FPrint(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FPrint(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Print, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarY;        		<span class="hljs-comment">// </span>
    CVar *pVarStrNameFX1;		<span class="hljs-comment">//    X1</span>
    CVar *pVarStrNameFX2;		<span class="hljs-comment">//    X2</span>
    CVar *pVarStrNameFX3;		<span class="hljs-comment">//    X3</span>
    FSynch *pLX1 {<span class="hljs-literal">nullptr</span>};     <span class="hljs-comment">//    X1</span>
    FSynch *pLX2 {<span class="hljs-literal">nullptr</span>};     <span class="hljs-comment">//    X2</span>
    FX1X2X3 *pLX3 {<span class="hljs-literal">nullptr</span>};    <span class="hljs-comment">//    X3</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX3 != <span class="hljs-literal">nullptr</span> &amp;&amp; pLX1 &amp;&amp; pLX2 &amp;&amp; pLX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };<font></font>
};<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fprint.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fx1x2x3.h"</span></span><font></font>
<font></font>
LArc TBL_Print[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p1"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FPrint::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"strY"</span>, CLocVar::vtString, <span class="hljs-string">"print of output string"</span>);			<span class="hljs-comment">//  </span>
    pVarStrNameFX1 = CreateLocVar(<span class="hljs-string">"strNameFX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameFX2 = CreateLocVar(<span class="hljs-string">"strNameFX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameFX3 = CreateLocVar(<span class="hljs-string">"strNameFX3"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(pr)"</span>);			<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;<font></font>
    str = pVarStrNameFX1-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX1 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX2 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX3-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX3 = (FX1X2X3*)FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPrint::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX3-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FPrint::y1</span><span class="hljs-params">()</span> </span>{<font></font>
    QString strX1; strX1.setNum(pLX1-&gt;dGetData());<font></font>
    QString strX2; strX2.setNum(pLX2-&gt;dGetData());<font></font>
    QString strX3; strX3.setNum(pLX3-&gt;dGetData());<font></font>
    QString qstr = <span class="hljs-string">"X1="</span> + strX1 + <span class="hljs-string">", X2="</span> + strX2 + <span class="hljs-string">", X3="</span> + strX3;<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, qstr.toStdString(), <span class="hljs-literal">nullptr</span>);<font></font>
}<font></font>
</code></pre> <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code unterscheidet sich von Listing 1, wie ein Bild eines Flugzeugs aus der Konstruktionsdokumentation. Aber ich denke, wir sind in erster Linie Programmierer, und einige Designer werden ihnen nicht beleidigt. Unser "Design Code" sollte leicht zu verstehen und eindeutig zu interpretieren sein, damit unser "Flugzeug" beim ersten Flug nicht abstürzt. Und wenn ein solches Unglück passiert ist und dies bei Programmen häufiger vorkommt als bei Flugzeugen, kann der Grund leicht und schnell gefunden werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Anbetracht von Listing 3 müssen Sie sich daher vorstellen, dass die Anzahl der Klassen nicht direkt mit der Anzahl der entsprechenden Objekte im Parallelprogramm zusammenhängt. Der Code spiegelt nicht die Beziehung zwischen Objekten wider, sondern enthält die Mechanismen, mit denen sie erstellt werden. Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSynch-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">enthält also einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pL-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeiger </font><font style="vertical-align: inherit;">auf ein Objekt vom Typ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LFsaAppl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Der Name dieses Objekts wird durch eine lokale Variable bestimmt, die in der VKPa-Umgebung einer Automatenvariablen mit dem Namen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strNameObject entspricht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ein Zeiger ist erforderlich, um mit der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FGetState-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">den aktuellen Status eines </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatenobjekts vom</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Typ </font><i><font style="vertical-align: inherit;">FSynch zu</font></i><font style="vertical-align: inherit;"> überwachen </font><font style="vertical-align: inherit;">(siehe Prädikatcode x2). Ähnliche Zeiger auf Objekte, Variablen zum Angeben der Namen von Objekten und Prädikate zum Organisieren von Beziehungen enthalten andere Klassen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun ein paar Worte zum „Aufbau“ eines Parallelprogramms in der VKPA-Umgebung. Es wird beim Laden der Programmkonfiguration erstellt. In diesem Fall werden erste Objekte auf der Basis von Klassen aus thematischen dynamischen Bibliotheken eines Automatentyps erstellt (ihre Menge wird durch die Konfiguration der Anwendung / des Programms bestimmt). Erstellte Objekte werden anhand ihrer Namen identifiziert (nennen wir sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">automatische Variablen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Anschließend werden die erforderlichen Werte in die lokalen Variablen der Automaten geschrieben. </font><font style="vertical-align: inherit;">In unserem Fall werden Variablen mit einem Zeichenfolgentyp auf die Variablennamen anderer Objekte und / oder die Namen der Objekte gesetzt. </font><font style="vertical-align: inherit;">Auf diese Weise werden Verbindungen zwischen Objekten eines Parallelautomatenprogramms hergestellt (siehe Abb. 1). </font><font style="vertical-align: inherit;">Durch Ändern der Werte der Eingabevariablen (mithilfe einzelner Objektsteuerungsdialoge oder der Standarddialoge / Umgebungsdialoge zum Festlegen von Werten für Umgebungsvariablen) wird das Ergebnis korrigiert. </font><font style="vertical-align: inherit;">Es kann mithilfe eines Standardumgebungsdialogs angezeigt werden, um die Werte von Variablen anzuzeigen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Zur Analyse paralleler Programme</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Über die Funktionsweise eines Parallelprogramms ist es sehr, sehr schwierig, etwas Konkretes zu sagen, es sei denn, es ist ganz einfach sequentiell parallel. Das betrachtete Netzwerk von Automaten ist keine Ausnahme. Als nächstes werden wir dies sehen und verstehen, was von ihm erwartet werden kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der resultierende Automat und das Netzwerk, für das er aufgebaut ist, sind in Abb. 2 dargestellt. </font><font style="vertical-align: inherit;">3. Aus dem Netzwerk in Abb. </font><font style="vertical-align: inherit;">2 zeichnet sich neben der Umbenennung seiner Elemente - Automaten, Eingangs- und Ausgangssignale - durch das Fehlen einer „Druckmaschine“ von Variablen aus. </font><font style="vertical-align: inherit;">Letzteres ist für den Betrieb des Netzwerks nicht unbedingt erforderlich. Durch Umbenennen können Sie die Kompositionsoperation verwenden, um den resultierenden Automaten zu erstellen. </font><font style="vertical-align: inherit;">Um kürzere Namen zu erstellen, wurde zusätzlich die Codierung eingeführt, wenn beispielsweise der Zustand "a0" des Automaten A durch das Symbol "0" und "a1" durch das Symbol "1" dargestellt wird. </font><font style="vertical-align: inherit;">Ähnliches gilt für andere Maschinen. </font><font style="vertical-align: inherit;">In diesem Fall wird dem Komponentenstatus des Netzwerks, z. B. "a1b0c1", der Name "101" zugewiesen. </font><font style="vertical-align: inherit;">In ähnlicher Weise werden Namen für alle Komponentenzustände des Netzwerks gebildet, deren Anzahl durch das Produkt der Zustände von Komponentenautomaten bestimmt wird.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. </font><font style="vertical-align: inherit;">3. Der resultierende Netzwerkautomat</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/a8/oc/9k/a8oc9kfwbbm3apemxhjzpbz5mxw.jpeg" alt="image"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Der resultierende Automat kann natürlich rein formal berechnet werden, aber dafür brauchen wir einen geeigneten „Taschenrechner“. Ist dies nicht der Fall, können Sie einen recht einfachen intuitiven Algorithmus verwenden. Innerhalb seines Rahmens wird der eine oder andere Komponentenzustand des Netzwerks aufgezeichnet, und dann werden die Zielkomponentenzustände durch "Handles" bestimmt, indem alle möglichen Eingabesituationen sortiert werden. Nachdem also der Zustand "000" festgelegt wurde, der den aktuellen Zuständen der Komponentenautomaten - "a0", "b0", "c0" - entspricht, werden Übergänge für Konjunktionen von Eingangsvariablen ^ x1 ^ x2, ^ x1x2, x1 ^ x2, x1x2 bestimmt. Wir erhalten die Übergänge jeweils in gibt "a0b0c0", "a0b1c0", "a1b0c0", "a1b1c0" an, die auf der resultierenden Maschine mit "000", "010", "100" und "110" gekennzeichnet sind. Schleifendie nicht mit Aktionen geladen sind, können aus dem Diagramm ausgeschlossen werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was wir "im trockenen Rückstand" haben. Wir haben die Hauptsache erreicht - wir haben den resultierenden Automaten erhalten, der den Betrieb des Netzwerks genau beschreibt. Wir haben herausgefunden, dass von acht möglichen Netzwerkzuständen einer nicht zugänglich (isoliert) ist - Zustand „001“. Dies bedeutet, dass die Summierungsoperation unter keinen Umständen für Eingabevariablen ausgelöst wird, die den aktuellen Wert nicht geändert haben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was störend ist, obwohl das Testen keine Fehler ergab. In der Grafik des resultierenden Automaten wurden Übergänge gefunden, die bei Ausgabeaktionen in Konflikt stehen. Sie sind mit einer Kombination der Aktionen y1y3 und y2y3 gekennzeichnet. Die Aktionen y1 und y2 werden ausgelöst, wenn sich die Eingabedaten ändern, und dann berechnet eine andere Aktion y3 die Summe der Variablen parallel zu ihnen. Mit welchen Werten wird es arbeiten - alt oder nur durch neue geändert? Um Mehrdeutigkeiten zu beseitigen, können Sie einfach die Aktionen von y3 und y4 ändern. In diesem Fall lautet ihr Code wie folgt: X3 = X1Sav + X2Sav und print (X1Sav, X2Sav, X3).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit. </font><font style="vertical-align: inherit;">Die Konstruktion des resultierenden Automaten ergab offensichtliche Probleme im erstellten Parallelmodell. </font><font style="vertical-align: inherit;">Ob sie im reaktiven Programm erscheinen, ist eine Frage. </font><font style="vertical-align: inherit;">Alles wird anscheinend von der Herangehensweise an die Umsetzung der Parallelität im reaktiven Paradigma abhängen. </font><font style="vertical-align: inherit;">In jedem Fall muss eine solche Abhängigkeit berücksichtigt und irgendwie beseitigt werden. </font><font style="vertical-align: inherit;">Bei einem automatisierten Netzwerk ist es einfacher, die geänderte Version zu verlassen, als zu versuchen, das Netzwerk zu ändern. </font><font style="vertical-align: inherit;">Es ist in Ordnung, wenn zuerst die "alten" Daten gedruckt werden, die den Netzwerkbetrieb initiiert haben, und dann die aktuellen Daten als nächstes gedruckt werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Schlussfolgerung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede der betrachteten Lösungen hat ihre Vor- und Nachteile. Das erste ist sehr einfach, das Netzwerk ist komplizierter und wird auf der Basis einer einzelnen Maschine erstellt. Erst nach der Visualisierung werden die Eingabedaten analysiert. Aufgrund seiner Parallelität startet dasselbe automatische Netzwerk die Analyse der Eingabedaten vor dem Ende des Druckvorgangs. Und wenn die Visualisierungszeit lang ist, dies jedoch bei der Summierungsoperation der Fall ist, ist das Netzwerk unter dem Gesichtspunkt der Eingabesteuerung schneller. Jene. Eine Bewertung auf der Grundlage einer Schätzung der Code-Menge bei parallelen Programmen ist nicht immer objektiv. Einfacher ausgedrückt ist das Netzwerk parallel, die Einkomponentenlösung ist weitgehend sequentiell (ihre Prädikate und Aktionen sind parallel). Und wir sprechen zunächst von parallelen Programmen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Netzwerkmodell ist auch ein Beispiel für eine flexible Lösung. Erstens können Komponenten unabhängig voneinander entworfen werden. Zweitens kann jede Komponente durch eine andere ersetzt werden. Und drittens kann jede Netzwerkkomponente ein Element einer Bibliothek automatischer Prozesse sein und wird in einer anderen Netzwerklösung verwendet. Und dies sind nur die offensichtlichsten Vorteile einer parallelen Lösung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber zurück zur reaktiven Programmierung. Betrachtet RP alle Programmanweisungen zunächst als parallel? Wir können nur davon ausgehen, dass es ohne dies schwierig ist, über ein Programmierparadigma zu sprechen, das „auf Datenflüsse und die Ausbreitung von Änderungen ausgerichtet ist“ (siehe die Definition der reaktiven Programmierung in [3]). Aber was ist dann der Unterschied zur Programmierung mit Streaming-Steuerung (für weitere Details siehe [1])? Wir kehren also zu unserem Ausgangspunkt zurück: Wie klassifiziert man reaktive Programmierung im Rahmen bekannter Klassifikationen? Und wenn RP etwas Besonderes ist, was unterscheidet es dann von den bekannten Programmierparadigmen?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, über die Theorie. Ohne sie wäre die Analyse paralleler Algorithmen nicht nur schwierig - unmöglich. Der Analyseprozess zeigt manchmal Probleme auf, die selbst bei einem sorgfältigen und nachdenklichen Blick auf das Programm, wie übrigens auf das „Designdokument“, nicht zu erraten sind. Auf jeden Fall bin ich dafür, dass Flugzeuge sowohl im übertragenen als auch im anderen Sinne nicht abstürzen. Dies ist für mich die Tatsache, dass Sie natürlich nach Einfachheit und Anmut der Form streben müssen, aber ohne Qualitätsverlust. Wir Programmierer „zeichnen“ nicht nur Programme, sondern kontrollieren oft, was dort verborgen ist, auch durch Flugzeuge!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ja, ich hätte es fast vergessen. Ich würde die automatische Programmierung (AP) als Programmierung mit dynamischer Steuerung klassifizieren. Was die Asynchronität betrifft - ich wette. Vorausgesetzt, dass die Basis des AP-Steuerungsmodells ein Netzwerk in einer einzigen Zeit ist, d.h. synchrone Netzwerke von Automaten, dann ist es synchron. Da die VKPa-Umgebung jedoch auch viele Netzwerke durch das Konzept der „Automatenwelten“ implementiert, ist sie vollständig asynchron. Im Allgemeinen bin ich gegen einen sehr starren Klassifizierungsrahmen, aber nicht für Anarchie. In diesem Sinne hoffe ich, dass in VKPa ein gewisser Kompromiss zwischen der Starrheit der seriell-parallelen Programmierung und einem gewissen asynchronen Anarchismus erzielt wurde. Angesichts der Tatsache, dass die automatische Programmierung auch die Klasse der Ereignisprogramme abdeckt (siehe [4]) und Stream-Programme darin leicht modelliert werden können,Von welcher Programmierung kannst du noch träumen? Sicher - für mich.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literatur</font></font></b><div class="spoiler_text">1.   /.. , .. , .. , .. ;  . .. . – .:   , 1983. – 240.<br>
2.      . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr.com/ru/post/486632</a> . . . (  07.02.2020).<br>
3.  . . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">ru.wikipedia.org/wiki/_</a> . . . (  07.02.2020).<br>
4.  —  ? [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr.com/ru/post/483610</a> . . . (  07.02.2020).<br>
</div></div></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de487698/index.html">Digitale Veranstaltungen in St. Petersburg vom 10. bis 16. Februar</a></li>
<li><a href="../de487702/index.html">Eine Auswahl von Artikeln zum maschinellen Lernen: Fallstudien, Leitfäden und Forschungsergebnisse für Januar 2020</a></li>
<li><a href="../de487704/index.html">Wie wir auf der SSRS 2014 dynamische Berichte erstellt haben</a></li>
<li><a href="../de487706/index.html">Service Discovery in verteilten Systemen anhand des Consul-Beispiels. Alexander Sigachev</a></li>
<li><a href="../de487716/index.html">Perfekt SAST. Parser</a></li>
<li><a href="../de487724/index.html">BlazingPizza: Blazor App von Anfang bis Ende. Teil 2. Fügen Sie eine Komponente hinzu</a></li>
<li><a href="../de487728/index.html">@ Pythonetc-Zusammenstellung, Januar 2020</a></li>
<li><a href="../de487730/index.html">Verarbeitung natürlicher Sprache. Ergebnisse 2019 und Trends für 2020</a></li>
<li><a href="../de487734/index.html">Beschleunigung des Entity Framework-Kerns</a></li>
<li><a href="../de487738/index.html">Schemaanimation in SCADA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>