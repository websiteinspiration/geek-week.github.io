<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏽 🤜🏿 🎨 データベースの書き込みと読み取りのバランス 🌀 🕚 💃🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前回の記事では、リレーショナルデータベースのようなテーブルやフィールドではなく、関数に基づいて構築されたデータベースの概念と実装について説明しました。これは、このアプローチがクラシックよりも優れていることを示す多くの例を示しています。多くの人が十分に説得力がないと感じました。
 
 この記事では、こ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>データベースの書き込みと読み取りのバランス</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lsfusion/blog/459066/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/0w/wi/gl/0wwiglioocbaxcpjodrzg5x1ocs.jpeg" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前回の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、リレーショナルデータベースのようなテーブルやフィールドではなく、関数に基づいて構築されたデータベースの概念と実装について説明しました。</font><font style="vertical-align: inherit;">これは、このアプローチがクラシックよりも優れていることを示す多くの例を示しています。</font><font style="vertical-align: inherit;">多くの人が十分に説得力がないと感じました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、この概念を使用して、作業のロジックを変更せずに、データベースへの書き込みと読み取りのバランスを迅速かつ便利に実現する方法を示します。</font><font style="vertical-align: inherit;">彼らは同様の機能を現代の商用DBMS（特にOracleとMicrosoft SQL Server）に実装しようとしました。</font><font style="vertical-align: inherit;">記事の最後で、私は彼らに何が起こったのかを示します。非常にではなく、穏やかに言います。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前と同様に、理解を深めるために、例から説明を始めます。従業員の数と給与の合計を含む部門のリストを返すロジックを実装する必要があるとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能データベースでは、次のようになります。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#a626a4">CLASS</font>&nbsp;Department&nbsp;‘’;<br>
name&nbsp;‘’&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">STRING</font>[<font color="#986801">100</font>]&nbsp;(Department);<br>
<br>
<font color="#a626a4">CLASS</font>&nbsp;Employee&nbsp;‘’;<br>
department&nbsp;‘’&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;Department&nbsp;(Employee);<br>
salary&nbsp;‘’&nbsp;=&nbsp;&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">NUMERIC</font>[<font color="#986801">10</font>,<font color="#986801">2</font>]&nbsp;(Employee);<br>
<br>
countEmployees&nbsp;‘-&nbsp;’&nbsp;(Department&nbsp;d)&nbsp;=&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">GROUP</font>&nbsp;<font color="#a626a4">SUM</font>&nbsp;<font color="#986801">1</font>&nbsp;<font color="#a626a4">IF</font>&nbsp;department(Employee&nbsp;e)&nbsp;=&nbsp;d;<br>
salarySum&nbsp;‘&nbsp;’&nbsp;(Department&nbsp;d)&nbsp;=&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">GROUP</font>&nbsp;<font color="#a626a4">SUM</font>&nbsp;salary(Employee&nbsp;e)&nbsp;<font color="#a626a4">IF</font>&nbsp;department(e)&nbsp;=&nbsp;d;<br>
<br>
SELECT&nbsp;name(Department&nbsp;d),&nbsp;countEmployees(d),&nbsp;salarySum(d);<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この計算では従業員のテーブル全体をスキャンしてから部門ごとにグループ化する必要があるため、</font><font style="vertical-align: inherit;">DBMSでこのクエリを実行する複雑さは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（従業員数）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">相当し</font><font style="vertical-align: inherit;">ます。また、選択した計画</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（従業員のログ数）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font><font style="vertical-align: inherit;">グループ化の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（部門数</font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">）</font></i><font style="vertical-align: inherit;">など</font><font style="vertical-align: inherit;">に応じて、いくつかの小さな（部門よりもはるかに多くの従業員がいると思われます）追加があり</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行のオーバーヘッドはDBMSによって異なる場合があることは明らかですが、複雑さはまったく変わりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提案された実装では、機能DBMSが1つのサブクエリを形成し、部門に必要な値を計算してから、部門テーブルとのJOINを作成して名前を取得します。ただし、関数ごとに、宣言時に特別なMATERIALIZEDマーカーを設定することができます。システムは、そのような機能ごとに適切なフィールドを自動的に作成します。関数の値を変更すると、フィールドの値も同じトランザクションで変更されます。この機能にアクセスすると、計算済みフィールドが既にアピールされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に、関数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">countEmployees</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font><i><font style="vertical-align: inherit;">salarySumに</font></i><font style="vertical-align: inherit;"> MATERIALIZEDを設定した場合</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次に、部門のリストを含むテーブルに2つのフィールドが追加されます。このフィールドには、従業員数とその給与の合計が格納されます。従業員、その給与、または部門への所属に変更があると、システムはこれらのフィールドの値を自動的に変更します。上記のクエリはこれらのフィールドに直接アクセスし始め、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（部門数）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に対して実行され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
制限は何ですか？ 1つだけ：そのような関数には、その値が定義されている有限数の入力値が必要です。そうしないと、すべての値を格納するテーブルを作成することができなくなります。これは、行数が無限のテーブルは存在できないためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>employeesCount&nbsp;‘&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;N’&nbsp;(Department&nbsp;d,&nbsp;<font color="#a626a4">NUMERIC</font>[<font color="#986801">10</font>,<font color="#986801">2</font>]&nbsp;N)&nbsp;=&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">GROUP</font>&nbsp;<font color="#a626a4">SUM</font>&nbsp;salary(Employee&nbsp;e)&nbsp;<font color="#a626a4">IF</font>&nbsp;department(e)&nbsp;=&nbsp;d&nbsp;<font color="#a626a4">AND</font>&nbsp;salary(e)&nbsp;&gt;&nbsp;N;<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この関数は、Nという無限の数の値に対して定義されます（たとえば、負の値が適切です）。したがって、MATERIALIZEDにすることはできません。したがって、これは論理的であり、技術的な制限ではありません（つまり、これを実装できなかったためではありません）。それ以外の場合、制限はありません。グループ化、並べ替え、ANDおよびOR、PARTITION、再帰などを使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、前の記事のタスク2.2では、両方の関数にMATERIALIZEDを設定できます。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>bought&nbsp;<font color="#50a14f">''</font>&nbsp;(Customer&nbsp;c,&nbsp;Product&nbsp;p,&nbsp;<font color="#a626a4">INTEGER</font>&nbsp;y)&nbsp;=&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">GROUP</font>&nbsp;<font color="#a626a4">SUM</font>&nbsp;sum(Detail&nbsp;d)&nbsp;<font color="#a626a4">IF</font>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;customer(order(d))&nbsp;=&nbsp;c&nbsp;<font color="#a626a4">AND</font>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product(d)&nbsp;=&nbsp;p&nbsp;<font color="#a626a4">AND</font>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extractYear(date(order(d)))&nbsp;=&nbsp;y&nbsp;<font color="#a626a4">MATERIALIZED</font>;<br>
rating&nbsp;<font color="#50a14f">''</font>&nbsp;(Customer&nbsp;c,&nbsp;Product&nbsp;p,&nbsp;<font color="#a626a4">INTEGER</font>&nbsp;y)&nbsp;=&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">PARTITION</font>&nbsp;<font color="#a626a4">SUM</font>&nbsp;<font color="#986801">1</font>&nbsp;<font color="#a626a4">ORDER</font>&nbsp;<font color="#a626a4">DESC</font>&nbsp;bought(c,&nbsp;p,&nbsp;y),&nbsp;p&nbsp;<font color="#a626a4">BY</font>&nbsp;c,&nbsp;y&nbsp;<font color="#a626a4">MATERIALIZED</font>;<br>
SELECT&nbsp;contactName(Customer&nbsp;c),&nbsp;name(Product&nbsp;p)&nbsp;<font color="#a626a4">WHERE</font>&nbsp;rating(c,&nbsp;p,&nbsp;<font color="#986801">1997</font>)&nbsp;&lt;&nbsp;<font color="#986801">3</font>;<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システム自体は</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Customer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Product</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INTEGERの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプのキーを持つ1つのテーブルを作成し</font><font style="vertical-align: inherit;">、それに2つのフィールドを追加して、それらのフィールド値を変更して更新します。</font><font style="vertical-align: inherit;">これらの関数をさらに呼び出すと、それらは計算されませんが、対応するフィールドの値が読み取られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメカニズムを使用すると、たとえば、クエリの再帰（CTE）を取り除くことができます。</font><font style="vertical-align: inherit;">特に、子と親の関係を使用してツリーを構成するグループを検討してください（各グループには親へのリンクがあります）。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>parent&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;Group&nbsp;(Group);<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 機能データベースでは、再帰ロジックは次のように定義できます。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>level&nbsp;(Group&nbsp;child,&nbsp;Group&nbsp;parent)&nbsp;=&nbsp;<font color="#a626a4">RECURSION</font>&nbsp;<font color="#986801">1l</font>&nbsp;<font color="#a626a4">IF</font>&nbsp;child&nbsp;<font color="#a626a4">IS</font>&nbsp;Group&nbsp;<font color="#a626a4">AND</font>&nbsp;parent&nbsp;==&nbsp;child<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a626a4">STEP</font>&nbsp;<font color="#986801">2l</font>&nbsp;<font color="#a626a4">IF</font>&nbsp;parent&nbsp;==&nbsp;parent($parent);<br>
isParent&nbsp;(Group&nbsp;child,&nbsp;Group&nbsp;parent)&nbsp;=&nbsp;<font color="#a626a4">TRUE</font>&nbsp;<font color="#a626a4">IF</font>&nbsp;level(child,&nbsp;parent)&nbsp;<font color="#a626a4">MATERIALIZED</font>;<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MATERIALIZEDは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isParent</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数に付加されているため、</font><font style="vertical-align: inherit;">2つのキー（グループ）を持つテーブルが作成され</font><font style="vertical-align: inherit;">、最初のキーが2番目のキーの子孫である場合にのみ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isParent</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールド</font><font style="vertical-align: inherit;">がtrueになります。</font><font style="vertical-align: inherit;">このテーブルのエントリ数は、グループの数にツリーの平均深度を掛けたものに等しくなります。</font><font style="vertical-align: inherit;">たとえば、特定のグループの子孫の数を計算する必要がある場合は、次の関数にアクセスできます。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code>childrenCount&nbsp;(Group&nbsp;g)&nbsp;=&nbsp;<font color="#a626a4">GROUP</font>&nbsp;<font color="#a626a4">SUM</font>&nbsp;<font color="#986801">1</font>&nbsp;<font color="#a626a4">IF</font>&nbsp;isParent(Group&nbsp;child,&nbsp;g);<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLクエリにはCTEはありません。</font><font style="vertical-align: inherit;">代わりに、単純なGROUP BYがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメカニズムを使用すると、必要に応じてデータベースを簡単に非正規化することもできます。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><code><font color="#a626a4">CLASS</font>&nbsp;Order&nbsp;<font color="#50a14f">''</font>;<br>
date&nbsp;<font color="#50a14f">''</font>&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;<font color="#a626a4">DATE</font>&nbsp;(Order);<br>
<br>
<font color="#a626a4">CLASS</font>&nbsp;OrderDetail&nbsp;<font color="#50a14f">'&nbsp;'</font>;<br>
order&nbsp;<font color="#50a14f">''</font>&nbsp;=&nbsp;<font color="#a626a4">DATA</font>&nbsp;Order&nbsp;(OrderDetail);<br>
date&nbsp;<font color="#50a14f">''</font>&nbsp;(OrderDetail&nbsp;d)&nbsp;=&nbsp;date(order(d))&nbsp;<font color="#a626a4">MATERIALIZED</font>&nbsp;<font color="#a626a4">INDEXED</font>;<br>
</code></td>
</tr>
</tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注文</font><font style="vertical-align: inherit;">明細の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">日付</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を呼び出す</font><font style="vertical-align: inherit;">と、インデックスがあるフィールドの注文明細を含むテーブルから読み取りが行われます。</font><font style="vertical-align: inherit;">注文日を変更すると、システム自体が行の非正規化された日付を自動的に再計算します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">利点</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこのメカニズム全体が必要なのですか？従来のDBMSでは、クエリを書き換えることなく、開発者またはDBAはインデックスの変更、統計の決定、およびクエリプランナーへの実行方法の通知のみを実行できます（さらに、HINTは商用DBMSでのみ使用できます）。どんなに頑張って</font><font style="vertical-align: inherit;">も、リクエストを変更してトリガーを追加しない</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">O（部門数）</font></i><font style="vertical-align: inherit;">に関する記事の最初のリクエストを処理できません</font><font style="vertical-align: inherit;">。提案されたスキームでは、開発段階で、データストレージの構造や使用する集計について考える必要はありません。これらすべては、稼働中に直接、オンザフライで簡単に変更できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には次のようになります。一部の人々は、タスクに基づいて直接ロジックを開発します。これらは、アルゴリズムとその複雑さ、実行計画、join'ovのタイプ、その他の技術コンポーネントには精通していません。これらの人々は開発者よりもビジネスアナリストです。その後、すべてテストまたは運用に入ります。長いクエリのロギングが有効になっています。長い要求が検出されると、他の人（より技術的な-実際にはDBA）によって、いくつかの中間機能でMATERIALIZEDを有効にする決定が行われます。これにより、（トランザクションで追加フィールドを更新する必要があるため）記録が少し遅くなります。ただし、このリクエストは大幅に加速されるだけでなく、この機能を使用する他のすべてのリクエストも高速化されます。この場合、決定はどの関数を具体化するかは比較的簡単に取ることができます。 2つの主要なパラメーター：可能な入力値の数（対応するテーブルに記録されるレコードの正確な数）、および他の関数で使用される頻度。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナログ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最新の商用DBMSにも同様のメカニズムがあります。FASTREFRESHを備えたMATERIALIZED VIEW（Oracle）とINDEXED VIEW（Microsoft SQL Server）です。</font><font style="vertical-align: inherit;">PostgreSQLでは、MATERIALIZED VIEWはトランザクションで更新することはできませんが、オンデマンドで（そして非常に厳しい制限がある場合でも）のみ更新できるため、考慮しません。</font><font style="vertical-align: inherit;">しかし、それらにはいくつかの問題があり、その使用が大幅に制限されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、通常のVIEWをすでに作成している場合にのみ、マテリアライズを有効にできます。</font><font style="vertical-align: inherit;">それ以外の場合、このマテリアライズを使用するには、新しく作成されたビューにアクセスするための残りのリクエストを書き換える必要があります。</font><font style="vertical-align: inherit;">またはそのままにしておいても、既に計算済みのデータがある場合は少なくとも効果はありませんが、多くのクエリは常にそれらを使用するわけではなく、再度計算します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二に、それらには非常に多くの制限があります：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オラクル</font></font></b><div class="spoiler_text"><blockquote><h5>5.3.8.4 General Restrictions on Fast Refresh</h5><br>
 The defining query of the materialized view is restricted as follows:<br>
 <ul>
<li>The materialized view must not contain references to non-repeating expressions like <code>SYSDATE</code> and <code>ROWNUM</code>.</li>
<li>The materialized view must not contain references to <code>RAW</code> or <code>LONG</code> <code>RAW</code> data types.</li>
<li>It cannot contain a <code>SELECT</code> list subquery.</li>
<li>It cannot contain analytic functions (for example, <code>RANK</code>) in the <code>SELECT</code> clause.</li>
<li>It cannot reference a table on which an <code>XMLIndex</code> index is defined. </li>
<li>It cannot contain a <code>MODEL</code> clause. </li>
<li>It cannot contain a <code>HAVING</code> clause with a subquery. </li>
<li>It cannot contain nested queries that have <code>ANY</code>, <code>ALL</code>, or <code>NOT</code> <code>EXISTS</code>.</li>
<li>It cannot contain a <code>[START WITH …] CONNECT BY</code> clause.</li>
<li>It cannot contain multiple detail tables at different sites.</li>
<li><code>ON</code> <code>COMMIT</code> materialized views cannot have remote detail tables.</li>
<li>Nested materialized views must have a join or aggregate.</li>
<li>Materialized join views and materialized aggregate views with a <code>GROUP</code> <code>BY</code> clause cannot select from an index-organized table.</li>
</ul><br>
<h5>5.3.8.5 Restrictions on Fast Refresh on Materialized Views with Joins Only</h5><br>
 Defining queries for materialized views with joins only and no aggregates have the following restrictions on fast refresh:<br>
 <ul>
<li>All restrictions from "<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">General Restrictions on Fast Refresh</a>".</li>
<li>They cannot have <code>GROUP</code> <code>BY</code> clauses or aggregates.</li>
<li>Rowids of all the tables in the <code>FROM</code> list must appear in the <code>SELECT</code> list of the query.</li>
<li>Materialized view logs must exist with rowids for all the base tables in the <code>FROM</code> list of the query.</li>
<li>You cannot create a fast refreshable materialized view from multiple tables with simple joins that include an object type column in the <code>SELECT</code> statement.</li>
</ul><br>
 Also, the refresh method you choose will not be optimally efficient if:<br>
 <ul>
<li>The defining query uses an outer join that behaves like an inner join. If the defining query contains such a join, consider rewriting the defining query to contain an inner join.</li>
<li>The <code>SELECT</code> list of the materialized view contains expressions on columns from multiple tables.</li>
</ul><br>
 <h5>5.3.8.6 Restrictions on Fast Refresh on Materialized Views with Aggregates</h5><br>
 Defining queries for materialized views with aggregates or joins have the following restrictions on fast refresh:<br>
 <ul>
<li>All restrictions from "<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">General Restrictions on Fast Refresh</a>".</li>
</ul><br>
 Fast refresh is supported for both <code>ON</code> <code>COMMIT</code> and <code>ON</code> <code>DEMAND</code> materialized views, however the following restrictions apply:<br>
 <ul>
<li>All tables in the materialized view must have materialized view logs, and the materialized view logs must:<br>
 <ul>
<li>Contain all columns from the table referenced in the materialized view. </li>
<li>Specify with <code>ROWID</code> and <code>INCLUDING</code> <code>NEW</code> <code>VALUES</code>.</li>
<li>Specify the <code>SEQUENCE</code> clause if the table is expected to have a mix of inserts/direct-loads, deletes, and updates.</li>
</ul><br>
 </li>
<li>Only <code>SUM</code>, <code>COUNT</code>, <code>AVG</code>, <code>STDDEV</code>, <code>VARIANCE</code>, <code>MIN</code> and <code>MAX</code> are supported for fast refresh.</li>
<li><code>COUNT(*)</code> must be specified.</li>
<li>Aggregate functions must occur only as the outermost part of the expression. That is, aggregates such as <code>AVG(AVG(x))</code> or <code>AVG(x)</code>+ <code>AVG(x)</code> are not allowed.</li>
<li>For each aggregate such as <code>AVG(expr)</code>, the corresponding <code>COUNT(expr)</code> must be present. Oracle recommends that <code>SUM(expr)</code> be specified.</li>
<li>If <code>VARIANCE(expr)</code> or <code>STDDEV(expr</code>) is specified, <code>COUNT(expr)</code> and <code>SUM(expr)</code> must be specified. Oracle recommends that <code>SUM(expr *expr)</code> be specified.</li>
<li>The <code>SELECT</code> column in the defining query cannot be a complex expression with columns from multiple base tables. A possible workaround to this is to use a nested materialized view.</li>
<li>The <code>SELECT</code> list must contain all <code>GROUP</code> <code>BY</code> columns.</li>
<li>The materialized view is not based on one or more remote tables.</li>
<li>If you use a <code>CHAR</code> data type in the filter columns of a materialized view log, the character sets of the master site and the materialized view must be the same.</li>
<li>If the materialized view has one of the following, then fast refresh is supported only on conventional DML inserts and direct loads.<br>
 <ul>
<li>Materialized views with <code>MIN</code> or <code>MAX</code> aggregates</li>
<li>Materialized views which have <code>SUM(expr)</code> but no <code>COUNT(expr)</code></li>
<li>Materialized views without <code>COUNT(*)</code></li>
</ul><br>
 Such a materialized view is called an insert-only materialized view.</li>
<li>A materialized view with <code>MAX</code> or <code>MIN</code> is fast refreshable after delete or mixed DML statements if it does not have a <code>WHERE</code> clause.<br>
 The max/min fast refresh after delete or mixed DML does not have the same behavior as the insert-only case. It deletes and recomputes the max/min values for the affected groups. You need to be aware of its performance impact.</li>
<li>Materialized views with named views or subqueries in the <code>FROM</code> clause can be fast refreshed provided the views can be completely merged. For information on which views will merge, see <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Oracle Database SQL Language Reference</a>.</li>
<li>If there are no outer joins, you may have arbitrary selections and joins in the <code>WHERE</code> clause.</li>
<li>Materialized aggregate views with outer joins are fast refreshable after conventional DML and direct loads, provided only the outer table has been modified. Also, unique constraints must exist on the join columns of the inner join table. If there are outer joins, all the joins must be connected by <code>AND</code>s and must use the equality (<code>=</code>) operator.</li>
<li>For materialized views with <code>CUBE</code>, <code>ROLLUP</code>, grouping sets, or concatenation of them, the following restrictions apply:<br>
 <ul>
<li>The <code>SELECT</code> list should contain grouping distinguisher that can either be a <code>GROUPING_ID</code> function on all <code>GROUP</code> <code>BY</code> expressions or <code>GROUPING</code> functions one for each <code>GROUP</code> <code>BY</code> expression. For example, if the <code>GROUP</code> <code>BY</code> clause of the materialized view is "<code>GROUP</code> <code>BY</code> <code>CUBE(a, b)</code>", then the <code>SELECT</code> list should contain either "<code>GROUPING_ID(a, b)</code>" or "<code>GROUPING(a)</code> <code>AND</code> <code>GROUPING(b)</code>" for the materialized view to be fast refreshable.</li>
<li><code>GROUP</code> <code>BY</code> should not result in any duplicate groupings. For example, "<code>GROUP BY a, ROLLUP(a, b)</code>" is not fast refreshable because it results in duplicate groupings "<code>(a), (a, b), AND (a)</code>".</li>
</ul></li>
</ul><br>
 <h5>5.3.8.7 Restrictions on Fast Refresh on Materialized Views with UNION ALL</h5><br>
 Materialized views with the <code>UNION</code> <code>ALL</code> set operator support the <code>REFRESH</code> <code>FAST</code> option if the following conditions are satisfied:<br>
 <ul>
<li>The defining query must have the <code>UNION</code> <code>ALL</code> operator at the top level.<br>
 <br>
 The <code>UNION</code> <code>ALL</code> operator cannot be embedded inside a subquery, with one exception: The <code>UNION</code> <code>ALL</code> can be in a subquery in the <code>FROM</code> clause provided the defining query is of the form <code>SELECT * FROM</code> (view or subquery with <code>UNION</code> <code>ALL</code>) as in the following example:<br>
 <pre>CREATE VIEW view_with_unionall AS<font></font>
(SELECT c.rowid crid, c.cust_id, 2 umarker<font></font>
 FROM customers c WHERE c.cust_last_name = 'Smith'<font></font>
 UNION ALL<font></font>
 SELECT c.rowid crid, c.cust_id, 3 umarker<font></font>
 FROM customers c WHERE c.cust_last_name = 'Jones');<font></font>
<font></font>
CREATE MATERIALIZED VIEW unionall_inside_view_mv<font></font>
REFRESH FAST ON DEMAND AS<font></font>
SELECT * FROM view_with_unionall;<font></font>
</pre>Note that the view <code>view_with_unionall</code> satisfies the requirements for fast refresh.</li>
<li>Each query block in the <code>UNION</code> <code>ALL</code> query must satisfy the requirements of a fast refreshable materialized view with aggregates or a fast refreshable materialized view with joins.<br>
 <br>
 The appropriate materialized view logs must be created on the tables as required for the corresponding type of fast refreshable materialized view.<br>
 Note that the Oracle Database also allows the special case of a single table materialized view with joins only provided the <code>ROWID</code> column has been included in the <code>SELECT</code> list and in the materialized view log. This is shown in the defining query of the view <code>view_with_unionall</code>.</li>
<li>The <code>SELECT</code> list of each query must include a <code>UNION</code> <code>ALL</code> marker, and the <code>UNION</code> <code>ALL</code> column must have a distinct constant numeric or string value in each <code>UNION</code> <code>ALL</code> branch. Further, the marker column must appear in the same ordinal position in the <code>SELECT</code> list of each query block. See "<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">UNION ALL Marker and Query Rewrite</a>" for more information regarding <code>UNION</code> <code>ALL</code> markers.</li>
<li>Some features such as outer joins, insert-only aggregate materialized view queries and remote tables are not supported for materialized views with <code>UNION</code> <code>ALL</code>. Note, however, that materialized views used in replication, which do not contain joins or aggregates, can be fast refreshed when <code>UNION</code> <code>ALL</code> or remote tables are used.</li>
<li>The compatibility initialization parameter must be set to 9.2.0 or higher to create a fast refreshable materialized view with <code>UNION</code> <code>ALL</code>.</li>
</ul></blockquote></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はオラクルのファンを怒らせたくありませんが、制限のリストから判断すると、このメカニズムはある種のモデルを使用した一般的なケースでは書かれていないようですが、何千人ものインディアンが、誰もが独自のスレッドを書くことを許可されており、それぞれが可能でしたしました。</font><font style="vertical-align: inherit;">このメカニズムを実際のロジックに使用することは、地雷原を歩くようなものです。</font><font style="vertical-align: inherit;">いつでも、地雷を手に入れ、明らかではない制限の1つに達することができます。</font><font style="vertical-align: inherit;">これがどのように機能するかもまた別の問題ですが、それはこの記事の範囲外です。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft SQL Server</font></font></b><div class="spoiler_text"><blockquote><h3>Additional Requirements</h3><br>
In addition to the SET options and deterministic function requirements, the following requirements must be met:<br>
<ul>
<li>The user that executes <code>CREATE INDEX</code> must be the owner of the view.</li>
<li>When you create the index, the <code>IGNORE_DUP_KEY</code> option must be set to OFF (the default setting).</li>
<li>Tables must be referenced by two-part names, <em>schema</em><strong>.</strong><em>tablename</em> in the view definition.</li>
<li>User-defined functions referenced in the view must be created by using the <code>WITH SCHEMABINDING</code> option.</li>
<li>Any user-defined functions referenced in the view must be referenced by two-part names, <em>&lt;schema&gt;</em><strong>.</strong><em>&lt;function&gt;</em>.</li>
<li>The data access property of a user-defined function must be <code>NO SQL</code>, and external access property must be <code>NO</code>.</li>
<li>Common language runtime (CLR) functions can appear in the select list of the view, but cannot be part of the definition of the clustered index key. CLR functions cannot appear in the WHERE clause of the view or the ON clause of a JOIN operation in the view.</li>
<li>CLR functions and methods of CLR user-defined types used in the view definition must have the properties set as shown in the following table.<br>
<div class="scrollable-table"><table>
<thead>
<tr>
<th>Property</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>DETERMINISTIC = TRUE</td>
<td>Must be declared explicitly as an attribute of the Microsoft .NET Framework method.</td>
</tr>
<tr>
<td>PRECISE = TRUE</td>
<td>Must be declared explicitly as an attribute of the .NET Framework method.</td>
</tr>
<tr>
<td>DATA ACCESS = NO SQL</td>
<td>Determined by setting DataAccess attribute to DataAccessKind.None and SystemDataAccess attribute to SystemDataAccessKind.None.</td>
</tr>
<tr>
<td>EXTERNAL ACCESS = NO</td>
<td>This property defaults to NO for CLR routines.</td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table></div></li>
<li>The view must be created by using the <code>WITH SCHEMABINDING</code> option.</li>
<li>The view must reference only base tables that are in the same database as the view. The view cannot reference other views.</li>
<li>The SELECT statement in the view definition must not contain the following Transact-SQL elements:<br>
<div class="scrollable-table"><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>COUNT</code></td>
<td>ROWSET functions (<code>OPENDATASOURCE</code>, <code>OPENQUERY</code>, <code>OPENROWSET</code>, AND <code>OPENXML</code>)</td>
<td><code>OUTER</code> joins (<code>LEFT</code>, <code>RIGHT</code>, or <code>FULL</code>)</td>
</tr>
<tr>
<td>Derived table (defined by specifying a <code>SELECT</code> statement in the <code>FROM</code> clause)</td>
<td>Self-joins</td>
<td>Specifying columns by using <code>SELECT *</code> or <code>SELECT &lt;table_name&gt;.*</code></td>
</tr>
<tr>
<td><code>DISTINCT</code></td>
<td><code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>, <code>VARP</code>, or <code>AVG</code></td>
<td>Common table expression (CTE)</td>
</tr>
<tr>
<td><strong>float</strong><sup>1</sup>, <strong>text</strong>, <strong>ntext</strong>, <strong>image</strong>, <strong>XML</strong>, or <strong>filestream</strong> columns</td>
<td>Subquery</td>
<td><code>OVER</code> clause, which includes ranking or aggregate window functions</td>
</tr>
<tr>
<td>Full-text predicates (<code>CONTAINS</code>, <code>FREETEXT</code>)</td>
<td><code>SUM</code> function that references a nullable expression</td>
<td><code>ORDER BY</code></td>
</tr>
<tr>
<td>CLR user-defined aggregate function</td>
<td><code>TOP</code></td>
<td><code>CUBE</code>, <code>ROLLUP</code>, or <code>GROUPING SETS</code> operators</td>
</tr>
<tr>
<td><code>MIN</code>, <code>MAX</code></td>
<td><code>UNION</code>, <code>EXCEPT</code>, or <code>INTERSECT</code> operators</td>
<td><code>TABLESAMPLE</code></td>
</tr>
<tr>
<td>Table variables</td>
<td><code>OUTER APPLY</code> or <code>CROSS APPLY</code></td>
<td><code>PIVOT</code>, <code>UNPIVOT</code></td>
</tr>
<tr>
<td>Sparse column sets</td>
<td>Inline (TVF) or multi-statement table-valued functions (MSTVF)</td>
<td><code>OFFSET</code></td>
</tr>
<tr>
<td><code>CHECKSUM_AGG</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td> </td>
<td> </td>
<td> </td>
</tr>
</tbody>
</table></div><br>
<sup>1</sup> The indexed view can contain <strong>float</strong> columns; however, such columns cannot be included in the clustered index key.</li>
<li>If <code>GROUP BY</code> is present, the VIEW definition must contain <code>COUNT_BIG(*)</code> and must not contain <code>HAVING</code>. These <code>GROUP BY</code> restrictions are applicable only to the indexed view definition. A query can use an indexed view in its execution plan even if it does not satisfy these <code>GROUP BY</code> restrictions.</li>
<li>If the view definition contains a <code>GROUP BY</code> clause, the key of the unique clustered index can reference only the columns specified in the <code>GROUP BY</code> clause.</li>
</ul></blockquote></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、インド人は「私たちはほとんど何もしませんが、良いことをする」という計画に従って行うことに決めたので、惹かれていませんでした。</font><font style="vertical-align: inherit;">つまり、彼らはフィールド上により多くの鉱山を持っていますが、彼らの場所はより透明です。</font><font style="vertical-align: inherit;">最も悲惨なことはこの制限です：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビューは、ビューと同じデータベースにある基本テーブルのみを参照する必要があります。</font><font style="vertical-align: inherit;">ビューは他のビューを参照できません。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの用語では、これは関数が別の実体化された関数にアクセスできないことを意味します。</font><font style="vertical-align: inherit;">芽のイデオロギー全体をカットします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、この制限（さらに本文では）により、ユースケースが大幅に削減されます。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビュー定義のSELECTステートメントには、次のTransact-SQL要素を含めることはできません。</font></font><br>
<div class="scrollable-table"><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>COUNT</code></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能ROWSET（ 、</font><font style="vertical-align: inherit;">、</font></font><code>OPENDATASOURCE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> </font><font style="vertical-align: inherit;">、AND </font><font style="vertical-align: inherit;">）</font></font><code>OPENQUERY</code><font style="vertical-align: inherit;"></font><code>OPENROWSET</code><font style="vertical-align: inherit;"></font><code>OPENXML</code><font style="vertical-align: inherit;"></font></td>
<td><code>OUTER</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（参加する</font></font><code>LEFT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>RIGHT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>FULL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">派生テーブル（</font><font style="vertical-align: inherit;">句に</font></font><code>SELECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステートメントを</font><font style="vertical-align: inherit;">指定して定義</font></font><code>FROM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自己結合</font></font></td>
<td><font style="vertical-align: inherit;"></font><code>SELECT *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font><font style="vertical-align: inherit;">を使用して列を指定する</font></font><code>SELECT &lt;table_name&gt;.*</code></td>
</tr>
<tr>
<td><code>DISTINCT</code></td>
<td><code>STDEV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>STDEVP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>VAR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>VARP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、または、</font></font><code>AVG</code></td>
<td>Common table expression (CTE)</td>
</tr>
<tr>
<td><strong>float</strong><sup>1</sup>, <strong>text</strong>, <strong>ntext</strong>, <strong>image</strong>, <strong>XML</strong>, or <strong>filestream</strong> columns</td>
<td>Subquery</td>
<td><code>OVER</code> clause, which includes ranking or aggregate window functions</td>
</tr>
<tr>
<td>Full-text predicates (<code>CONTAINS</code>, <code>FREETEXT</code>)</td>
<td><code>SUM</code> function that references a nullable expression</td>
<td><code>ORDER BY</code></td>
</tr>
<tr>
<td>CLR user-defined aggregate function</td>
<td><code>TOP</code></td>
<td><code>CUBE</code>, <code>ROLLUP</code>, or <code>GROUPING SETS</code> operators</td>
</tr>
<tr>
<td><code>MIN</code>, <code>MAX</code></td>
<td><code>UNION</code>, <code>EXCEPT</code>, or <code>INTERSECT</code> operators</td>
<td><code>TABLESAMPLE</code></td>
</tr>
<tr>
<td>Table variables</td>
<td><code>OUTER APPLY</code> or <code>CROSS APPLY</code></td>
<td><code>PIVOT</code>, <code>UNPIVOT</code></td>
</tr>
<tr>
<td>Sparse column sets</td>
<td>Inline (TVF) or multi-statement table-valued functions (MSTVF)</td>
<td><code>OFFSET</code></td>
</tr>
<tr>
<td><code>CHECKSUM_AGG</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td> </td>
<td> </td>
<td> </td>
</tr>
</tbody>
</table></div></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OUTER JOINS、UNION、ORDER BY、その他は禁止されています。</font><font style="vertical-align: inherit;">おそらく、使用できるものよりも使用できるものを示す方が簡単でした。</font><font style="vertical-align: inherit;">リストはおそらくはるかに小さいでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要約すると、LGPLテクノロジーでは、各DBMS（商用ではない）に大きな制限があり、DBMSには何もありません（技術的ではなく論理的な1つを除いて）。</font><font style="vertical-align: inherit;">ただし、リレーショナルロジックでこのメカニズムを実装することは、説明した機能よりもやや複雑であることに注意してください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使い方？</font><font style="vertical-align: inherit;">PostgreSQLは「仮想マシン」として使用されます。</font><font style="vertical-align: inherit;">内部には、クエリを構築する複雑なアルゴリズムがあります。</font><font style="vertical-align: inherit;">これが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコード</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">そして、ifの束を持つヒューリスティックの大規模なセットだけではありません。</font><font style="vertical-align: inherit;">したがって、2、3か月勉強する場合は、アーキテクチャを理解してみることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
効率的に機能しますか？効果的に十分。残念ながら、これを証明することは困難です。大規模なアプリケーションにある何千ものリクエストを考慮すると、平均的には優れた開発者よりも効果的であると言えます。優れたSQLプログラマーは、任意のクエリをより効率的に作成できますが、1,000クエリを使用すると、これを行う動機も時間もありません。有効性の証拠として私が今</font><font style="vertical-align: inherit;">言えることは</font><font style="vertical-align: inherit;">、このDBMSに基づいて構築されたプラットフォームに基づいて、数</font><font style="vertical-align: inherit;">千のユーザーと数億のレコードが機能するテラバイトデータベースを備えた数千の異なるMATERIALIZED関数が存在する</font><font style="vertical-align: inherit;">いくつかの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ERPシステム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクト</font><font style="vertical-align: inherit;">が機能することです。通常のデュアルプロセッササーバー。ただし、誰でもダウンロードして有効性を確認/反駁することができます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLクエリのログ記録を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有効にし</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そこでロジックとデータを変更しようとすることにより、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">プラットフォーム</font></a><font style="vertical-align: inherit;">とPostgreSQL </font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の記事では、関数の制限をハングする方法、変更セッションを操作する方法などについても説明します。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja459046/index.html">2つのステップで（存在の証明）を独立して実装する方法</a></li>
<li><a href="../ja459050/index.html">強力なVuexタイピングモジュール</a></li>
<li><a href="../ja459052/index.html">比較方法：「すばらしい車」と「醜い小屋」、マーケティング調査とビッグデータ</a></li>
<li><a href="../ja459054/index.html">クリックのヒートマップ-サイトでのユーザーの行動</a></li>
<li><a href="../ja459062/index.html">モバイル＃305開発者向けの興味深い資料のダイジェスト（7月1〜7日）</a></li>
<li><a href="../ja459068/index.html">Windows Server 2008 R2-王は死んでいる、王は長生きする</a></li>
<li><a href="../ja459070/index.html">Unityでタワーディフェンスを作成する：タワーと敵を撃つ</a></li>
<li><a href="../ja459074/index.html">ささいな喜び＃7：1つの価格で3つ-コンソールアニメーション、アルゴリズム、デバッグ</a></li>
<li><a href="../ja459078/index.html">CERNがオープンソースソフトウェアに切り替わりました-なぜですか？</a></li>
<li><a href="../ja459080/index.html">java.netのHttpUrlConnectionの機能</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>