<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßîüèø üòª üç≠ Blending und Unity Terrain: So entfernen Sie Kreuzungen und lassen Ihre Augen nicht mehr weh tun ‚óÄÔ∏è üèÇüèº üò®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um eine realistische Welt im Spiel zu erhalten, ist es notwendig, die Interaktion verschiedener Landformen untereinander und mit anderen Modellen zu b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Blending und Unity Terrain: So entfernen Sie Kreuzungen und lassen Ihre Augen nicht mehr weh tun</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/490226/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um eine realistische Welt im Spiel zu erhalten, ist es notwendig, die Interaktion verschiedener Landformen untereinander und mit anderen Modellen zu ber√ºcksichtigen. </font><font style="vertical-align: inherit;">Und wenn die sichtbaren Schnittlinien zwischen den 3D-Modellen die Integrit√§t des Bildes beeintr√§chtigen, sollten Sie √ºberlegen, wie Sie sie beseitigen k√∂nnen. </font><font style="vertical-align: inherit;">Der h√§ufigste Fall solcher Linien, der vielen bekannt sein mag, ist der Schnittpunkt von Werbetafeln aus Partikeln mit undurchsichtiger Geometrie. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ja/va/g2/javag2i9gc9lhkwohebgbyklsjc.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres Beispiel ist die st√∂rende nat√ºrliche Zusammensetzung des Schnittpunkts von Felsen und Vegetation mit der Oberfl√§che der Landschaft in ‚ÄûOutdoor‚Äú -Szenen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v0/k6/s9/v0k6s98hdon17qotuaryat0vogs.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zus√§tzlich zu verschiedenen Gl√§ttungsmethoden (SSAA, MSAA, CSAA, FXAA, NFAA, CMAA, DLAA, TAA usw.), die zwar das trotzige Auftreten solcher Schnittlinien mildern, die Situation jedoch nicht vollst√§ndig korrigieren, gibt es effektivere Techniken. </font><font style="vertical-align: inherit;">Wir werden sie ber√ºcksichtigen.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiefenmischung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unity verf√ºgt √ºber eine integrierte L√∂sung, um sichtbare Schnittpunkte zwischen transparenten Partikeln und undurchsichtiger Geometrie zu vermeiden, die als weiche Partikel bezeichnet werden. </font><font style="vertical-align: inherit;">Die Shader, die diesen Effekt unterst√ºtzen, verbessern die Transparenz der Partikel weiter, je nachdem, wie gering der Unterschied zwischen der Tiefe des Partikelfragments und der Tiefe der opaken Geometrie ist. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mz/wx/9k/mzwx9kecz9hkjps0laijveek-54.png" alt="Bild"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Funktionsprinzip weicher Partikel</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
F√ºr den korrekten Betrieb </font><i><font style="vertical-align: inherit;">weicher Partikel ist</font></i><font style="vertical-align: inherit;"> nat√ºrlich ein Tiefenpuffer erforderlich. </font><font style="vertical-align: inherit;">Im Fall einer verz√∂gerten Schattierung wird der Tiefenpuffer im Stadium des Renderns von Vollbildpuffern gebildet, und unter Ber√ºcksichtigung der MRT (Multiple Render Targets, nicht Magnetresonanztomographie) wird sein Vorhandensein nicht in zus√§tzlichen Berechnungskosten ausgedr√ºckt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Vorw√§rtsschattierung und Verwendung der Unity Legacy-Pipeline war ein zus√§tzlicher Durchgang erforderlich, um die undurchsichtige Geometrie in den Tiefenpuffer zu rendern </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dieser Durchlauf wird aktiviert, indem der Eigenschaft Camera.depthTextureMode der entsprechende Wert zugewiesen wird. </font><font style="vertical-align: inherit;">Diese Eigenschaft ist im Inspektorfenster nicht verf√ºgbar, jedoch in der API </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt k√∂nnen Sie Ihre eigene Version der Scriptable Render Pipeline mit Forward Shading implementieren, die mit Hilfe von MRT gleichzeitig sowohl den Tiefenpuffer als auch den Farbpuffer rendern kann. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7z/-b/1l/7z-b1lg9zs8xbsywe6evbmanfiw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminieren von Schnittlinien in Shadern, die weiche Partikel unterst√ºtzen</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Im Allgemeinen gibt es keine technischen Hindernisse f√ºr die Verwendung der Tiefenmischmethode, um sichtbare Schnittpunkte von 3D-Modellen mit der Landschaft zu eliminieren:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code anzeigen</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Blending</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">depth</span> <span class="hljs-selector-tag">buffer</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendStart</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendEnd</span>;
<span class="hljs-selector-tag">UNITY_DECLARE_DEPTH_TEXTURE</span>(_<span class="hljs-selector-tag">CameraDepthTexture</span>);<font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
    // ...<font></font>
<font></font>
    half4 <span class="hljs-attribute">projPos </span>: TEXCOORD0;<font></font>
};<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
<font></font>
    // ...<font></font>
<font></font>
    o.projPos = ComputeScreenPos(o.pos);<font></font>
    COMPUTE_EYEDEPTH(o.projPos.z);<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">fixed4</span> <span class="hljs-selector-tag">frag</span>(<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">i</span>) : <span class="hljs-selector-tag">COLOR</span><font></font>
{     <font></font>
    fixed4 result = 0;<font></font>
      <font></font>
    // ... <font></font>
<font></font>
    float depth = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.projPos));<font></font>
    float sceneZ = LinearEyeDepth(depth);<font></font>
    float partZ = i.projPos.z;<font></font>
    float fade = saturate( sceneZ - partZ );<font></font>
    result.a = smoothstep( BlendStart, BlendEnd, fade );<font></font>
<font></font>
    // ... <font></font>
       <font></font>
    return result; <font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Ansatz hat jedoch mehrere Nachteile. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste Nachteil h√§ngt mit der Leistung zusammen. Das Tiefenmischen funktioniert in der Phase des Hardware-Pipe-Mischens, dh unmittelbar nach der Rasterung und Berechnung des Fragment-Shaders. In diesem Stadium wird das Ergebnis der Ausf√ºhrung des Fragment-Shaders mit dem im Ausgabepuffer </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] [4] [5]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufgezeichneten Ergebnis </font><font style="vertical-align: inherit;">gem√§√ü der Formel </font><font style="vertical-align: inherit;">gemischt </font><font style="vertical-align: inherit;">, die durch die Aufrufe der API </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[6] [7] [8] [9]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vordefiniert wurde </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist der am wenigsten fortschrittliche Teil einer Hardware-Pipeline in dem Sinne, dass sie genau so funktioniert wie ihr Vorg√§nger vor zwanzig Jahren. Die GPU liest den Wert aus dem Speicher, mischt ihn mit dem Wert des Fragment-Shaders und schreibt ihn zur√ºck in den Speicher.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt auch einen Unterschied, ob die Tiefenmischung f√ºr vollst√§ndig transparente oder teilweise transparente 3D-Modelle verwendet werden soll. Transparent - zum Beispiel Partikelwerbetafeln - ist der gesamte Render transparent, auch ohne in die Tiefe zu mischen. Bei undurchsichtigen 3D-Modellen wird die reale, greifbare, sichtbare Transparenz beim Mischen in der Tiefe nur mit einer sehr geringen Anzahl von Fragmenten versehen, w√§hrend die √ºberwiegende Mehrheit von ihnen undurchsichtig bleibt. Letzteres bedeutet jedoch keineswegs, dass das Mischen nicht f√ºr das Rendern verwendet wird - es funktioniert einfach im Leerlauf.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite Nachteil h√§ngt damit zusammen, wie die Farbe zum Mischen ausgew√§hlt wird. Kurz gesagt, alle Fragmente, die in einem bestimmten Bildschirmpixel gemischt werden, liegen auf einem Strahl, der von der Weltposition der Kamera ausgeht und durch die Weltposition dieses Bildschirmpixels geht. Dies bedeutet wiederum, dass bei jeder √Ñnderung der Kameraposition oder -ausrichtung eine Parallaxe beobachtet wird: Fragmente des 3D-Modells, die sich n√§her an der Kamera befinden, bewegen sich schneller als Fragmente der Landschaft, die sich weiter von der Kamera entfernt befinden </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[10] [11]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies macht sich insbesondere aus der N√§he bei konstanter seitlicher Verschiebung der Kamera bemerkbar. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hz/sc/78/hzsc78n3vvddbvvlgrb3hqkfwxc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seitliche Parallaxe beim Bewegen der Kamera: Fragmente des 3D-Modells werden im Vergleich zu Fragmenten der Landschaft um eine gr√∂√üere Entfernung verschoben</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/5v/zf/wj/5vzfwjmabznaiprchenxb9eqy3q.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seitliche Parallaxe beim Bewegen der Kamera: Wenn Sie die Kamera auf einem Fragment der Landschaft fixieren, wird deutlich, wie schnell sich die Fragmente des Modells bewegen.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn die Kamera gedreht wird, wird die Parallaxe sofort entlang zweier Achsen der Bildschirmkoordinaten beobachtet. In der Dynamik ist dies jedoch weniger offensichtlich als die laterale Parallaxe. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qs/ew/jn/qsewjnfucpdriai47zh9032fwcm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Azimutale Parallaxe bei verschobener Kamera: F√ºr das Gehirn ist es schwieriger, das Parallaxenmuster zu erkennen, wenn die Fragmente entlang zweier</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Achsen </font><i><font style="vertical-align: inherit;">verschoben werden.</font></i><font style="vertical-align: inherit;"> Am auff√§lligsten ist jedoch, dass sich das Erscheinungsbild der Tiefenmischung in Abh√§ngigkeit von dem Winkel √§ndert, in dem der Betrachter auf die Oberfl√§che der Landschaft schaut. Die Mischzone wird fast unsichtbar, wenn die Blickrichtung senkrecht zur Normalen zur Landschaftsoberfl√§che verl√§uft. Die Gr√∂√üe dieser Zone nimmt jedoch schnell zu, wenn Sie die Kamera nach unten neigen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hd/r8/gs/hdr8gs_ha63gspkr_eaxowjosna.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern der Breite der Mischzone beim Neigen der Kamera</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
in die Tiefe Das Mischen ist m√∂glicherweise eine gute Option, um die Schnittlinien von 3D-Modellen mit der Landschaft zu entfernen, wenn nicht die Vielzahl der damit verbundenen Artefakte. </font><font style="vertical-align: inherit;">Diese Methode eignet sich besser f√ºr Partikeleffekte, die nicht statisch sind und in der Regel keine sehr detaillierten Texturen enthalten. Daher werden in ihrem Fall keine Parallaxeneffekte beobachtet.</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√∂henkartenmischung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine weitere Option zum Implementieren der Landschafts√ºberblendung ist die Verwendung einer H√∂henkarte, auf die Unity √ºber die TerrainData-API zugreifen kann </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[12]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die Position des Terrain-Objekts und die Abmessungen des in TerrainData angegebenen Terrains kennen und eine "H√∂henkarte" zur Hand haben, k√∂nnen Sie die H√∂he des Terrains an jedem in Weltkoordinaten angegebenen Punkt berechnen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ga/69/za/ga69zap3c3xnluhjfm68g4_roto.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gel√§ndeparameter, die zum Abtasten der H√∂henkarte erforderlich sind</font></font></i><br>
<br>
<pre><code class="css hljs">// <span class="hljs-selector-tag">Setting</span> <span class="hljs-selector-tag">up</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">heightmap</span> <span class="hljs-selector-tag">and</span> <span class="hljs-selector-tag">uniforms</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">use</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">shaders</span>... <font></font>
<font></font>
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalTexture</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.TerrainHeightmap</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.terrainData</span><span class="hljs-selector-class">.heightmapTexture</span>);
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalVector</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.HeightmapScale</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.terrainData</span><span class="hljs-selector-class">.heightmapScale</span>);
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalVector</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.TerrainSize</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.terrainData</span><span class="hljs-selector-class">.size</span>);
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalVector</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.TerrainPos</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.transform</span><span class="hljs-selector-class">.position</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, nachdem Sie die H√∂he der Landschaft berechnet haben, k√∂nnen Sie auch die UV-Koordinaten im Shader berechnen, um die Karte der H√∂hen der Landschaft in Weltkoordinaten abzutasten.</font></font><br>
<br>
<pre><code class="css hljs">// <span class="hljs-selector-tag">Computes</span> <span class="hljs-selector-tag">UV</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">sampling</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">heightmap</span>... <font></font>
<font></font>
<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">TerrainUV</span>(<span class="hljs-selector-tag">float3</span> <span class="hljs-selector-tag">worldPos</span>)<font></font>
{<font></font>
    return (worldPos.xz - TerrainPos.xz) / TerrainSize.xz;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um denselben Code in Fragment- und Vertex-Shadern verwenden zu k√∂nnen, wird die tex2Dlod-Funktion zum Abtasten verwendet. </font><font style="vertical-align: inherit;">Dar√ºber hinaus hat die H√∂henkarte keine Mip-Pegel, sodass das Abtasten mit der tex2D-Funktion, die den Mip-Pegel automatisch berechnet, grunds√§tzlich bedeutungslos ist.</font></font><br>
<br>
<pre><code class="css hljs">// <span class="hljs-selector-tag">Returns</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">height</span> <span class="hljs-selector-tag">of</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">given</span> <span class="hljs-selector-tag">position</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">world</span> <span class="hljs-selector-tag">space</span>... <font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">TerrainHeight</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">terrainUV</span>)<font></font>
{<font></font>
    float heightmapSample = tex2Dlod(TerrainHeightmap, float4(terrainUV,0,0));<font></font>
    return TerrainPos.y + UnpackHeightmap(heightmapSample) * HeightmapScale.y * 2;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen versuchen, die Beseitigung von Schnittpunkten durch Transparenz zu reproduzieren, ohne einen Tiefenpuffer zu verwenden. </font><font style="vertical-align: inherit;">Dies l√∂st keine anderen mit dieser Methode verbundenen Probleme, erm√∂glicht jedoch die √úberpr√ºfung der Funktionsf√§higkeit des Mischens mithilfe einer H√∂henkarte.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code anzeigen</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Blending</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">heightmap</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendStart</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendEnd</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainHeightmap</span>; 
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">HeightmapScale</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainSize</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainPos</span>;        <font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
   // ...<font></font>
<font></font>
   float3 <span class="hljs-attribute">worldPos </span>: TEXCOORD0;<font></font>
   float2 <span class="hljs-attribute">heightMapUV </span>: TEXCOORD1;<font></font>
<font></font>
   // ...<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
   <font></font>
    // ...<font></font>
    <font></font>
    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<font></font>
    o.heightMapUV = TerrainUV(o.worldPos);<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">fixed4</span> <span class="hljs-selector-tag">frag</span>(<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">i</span>) : <span class="hljs-selector-tag">COLOR</span><font></font>
{<font></font>
    fixed4 result = 0;<font></font>
<font></font>
    // ... <font></font>
<font></font>
    half height = TerrainHeight(i.heightMapUV);<font></font>
    half deltaHeight = i.worldPos.y - height;<font></font>
    result.a = smoothstep( BlendStart, BlendEnd, deltaHeight );<font></font>
<font></font>
    // ... <font></font>
       <font></font>
    return result; <font></font>
}</code></pre><br>
</div></div><br>
<br>
<img src="https://habrastorage.org/webt/zl/fl/nz/zlflnzwmh3tl6z_dhlvxowot4he.png"><br>
<img src="https://habrastorage.org/webt/-k/qc/f8/-kqcf8fgcmkjj7kt3gxmfpz31zu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiefenmischung und H√∂henmischung. </font><font style="vertical-align: inherit;">Die Breite der Mischzone unterscheidet sich bei gleichen Shader-Parametern.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In den Abbildungen werden f√ºr beide Methoden identische Mischparameter verwendet. </font><font style="vertical-align: inherit;">Die Breite der Mischzonen ist optisch unterschiedlich, da das Mischen mit einer H√∂henkarte nicht vom Winkel zwischen dem Blick des Betrachters und der Normalen zur Landschaft abh√§ngt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das √úberblenden mit einer H√∂henkarte ist zumindest in einer Hinsicht besser als das √úberblenden in der Tiefe: Es korrigiert die Abh√§ngigkeit des √úberblendens, die mit blo√üem Auge sichtbar ist, von dem Winkel, in dem die Kamera die Landschaft betrachtet. </font><font style="vertical-align: inherit;">Leider wird der Parallaxeeffekt immer noch beobachtet.</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vermischung der Landschaftsgestaltung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Parallaxe zu beseitigen, m√ºssen Sie ein Fragment des 3D-Modells mit einem Fragment der Landschaft mischen, das sich vertikal darunter befindet (die Farbauswahl zum Mischen h√§ngt in diesem Fall nicht von der Position und Ausrichtung der Kamera ab). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/h8/en/8t/h8en8tgwnrmjvhnunm0wkgcr3cu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So beheben Sie die Parallaxe: Ausw√§hlen eines Landschaftsfragments zum Mischen</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nat√ºrlich sprechen wir hier mehr √ºber ein virtuelles Landschaftsfragment. Abh√§ngig von der Position der Kamera ist eine Situation m√∂glich, in der ein Fragment der Landschaft, mit dem ein Fragment eines 3D-Modells gemischt werden muss, nicht einmal in das Sichtfeld der Kamera f√§llt. Ein √§hnliches Problem besteht beim Rendern lokaler Reflexionen im Bildschirmbereich (SSLR). Es besteht darin, dass es unm√∂glich ist, die Reflexion eines Fragments zu rendern, das sich nicht auf dem Bildschirm befindet </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[13]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Fall der Landschaft kann die Farbe des virtuellen Fragments mit Hilfe der von der Unity-API bereitgestellten Hilfstexturen mit hoher Genauigkeit rekonstruiert werden: normale Karte </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[14]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , helle Karte </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[15]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , gewichtete Texturen zum Mischen von Ebenen </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[16]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und enthaltene Texturen Zusammensetzung der Schichten </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[17]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ff/hu/zr/ffhuzriatn-pfjxf-nendtckscm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rekonstruktion eines Fragmentes der Landschaft</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Alle Texturen, aus denen sich die Landschaft zusammensetzt, werden mit dem gleichen UV-Wert wie die H√∂henkarte abgetastet. </font><font style="vertical-align: inherit;">Bei Ebenen werden die Koordinaten f√ºr die Abtastung durch die f√ºr eine bestimmte Ebene angegebenen Kachelparameter angepasst </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[18] [19]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code anzeigen</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Blending</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">reconstructed</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">fragments</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendStart</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendEnd</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainHeightmapTexture</span>;
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainNormalTexture</span>;
<span class="hljs-selector-tag">sampler2D</span> <span class="hljs-selector-tag">TerrainAlphaMap</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">HeightmapScale</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainSize</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainPos</span>;
<span class="hljs-selector-tag">Float4</span> <span class="hljs-selector-tag">TerrainLightmap_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap0</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap0</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap0_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap1</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap1</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap1_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap2</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap2</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap2_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap3</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap3</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap3_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
   // ...<font></font>
<font></font>
   float3 <span class="hljs-attribute">worldPos </span>: TEXCOORD0;<font></font>
   float2 <span class="hljs-attribute">heightMapUV </span>: TEXCOORD1;<font></font>
#if defined(LIGHTMAP_ON)<font></font>
   float2 <span class="hljs-attribute">modelLightMapUV </span>: TEXCOORD2;<font></font>
   float2 <span class="hljs-attribute">terrainLightMapUV </span>: TEXCOORD3;<font></font>
#endif<font></font>
<font></font>
   // ...<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
   <font></font>
    // ...<font></font>
    <font></font>
    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<font></font>
    o.heightMapUV = TerrainUV(o.worldPos);<font></font>
<font></font>
#if defined(LIGHTMAP_ON)<font></font>
    o.modelLightMapUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;<font></font>
    o.terrainLightMapUV = o.heightMapUV * TerrainLightmap_ST.xy + TerrainLightmap_ST.zw;<font></font>
#endif<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}<font></font>
<span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">TerrainNormal</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">terrainUV</span>)<font></font>
{<font></font>
    return tex2Dlod( TerrainNormalTexture, float4(terrainUV,0,0) ).xyz * 2.0 - 1.0;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv0</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv1</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv2</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv3</span>, <span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">control</span>)<font></font>
{<font></font>
    half4 splat0 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap0, TerrainSplatMap0, uv0);<font></font>
    half4 splat1 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap1, TerrainSplatMap1, uv1);<font></font>
    half4 splat2 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap2, TerrainSplatMap2, uv2);<font></font>
    half4 splat3 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap3, TerrainSplatMap3, uv3);         <font></font>
    half4 result = splat0 * control.r + <font></font>
                   splat1 * control.g + <font></font>
                   splat2 * control.b + <font></font>
                   splat3 * control.a;<font></font>
    return result;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">TerrainNormalMap</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv0</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv1</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv2</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv3</span>, <span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">control</span>)<font></font>
{<font></font>
    half4 n0 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap0, TerrainSplatMap0, uv0);<font></font>
    half4 n1 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap1, TerrainSplatMap1, uv1);<font></font>
    half4 n2 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap2, TerrainSplatMap2, uv2);<font></font>
    half4 n3 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap3, TerrainSplatMap3, uv3);<font></font>
    half3 result = UnpackNormalWithScale(n0, 1.0) * control.r +<font></font>
                   UnpackNormalWithScale(n1, 1.0) * control.g +<font></font>
                   UnpackNormalWithScale(n2, 1.0) * control.b +<font></font>
                   UnpackNormalWithScale(n3, 1.0) * control.a;<font></font>
    result.z += 1e-5;<font></font>
    return result;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">TerrainLightmap</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv</span>, <span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">normal</span>)<font></font>
{<font></font>
#if defined(LIGHTMAP_ON)<font></font>
#if defined(DIRLIGHTMAP_COMBINED)<font></font>
    half4 lm = UNITY_SAMPLE_TEX2D(unity_Lightmap, uv);<font></font>
    half4 lmd = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, uv);<font></font>
    half3 result = DecodeLightmapRGBM(lm, unity_Lightmap_HDR);<font></font>
    result = DecodeDirectionalLightmap(result, lmd, normal);<font></font>
#else<font></font>
    half4 lm = UNITY_SAMPLE_TEX2D(unity_Lightmap, uv);<font></font>
    half3 result = DecodeLightmapRGBM(lm, unity_Lightmap_HDR);<font></font>
#endif                <font></font>
#else<font></font>
    half3 result = UNITY_LIGHTMODEL_AMBIENT.rgb;<font></font>
#endif<font></font>
    return result;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">fixed4</span> <span class="hljs-selector-tag">frag</span>(<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">i</span>) : <span class="hljs-selector-tag">COLOR</span><font></font>
{<font></font>
    fixed4 result = 0;<font></font>
<font></font>
    // ...<font></font>
<font></font>
    // compute model color and put it to the result<font></font>
<font></font>
    // ... <font></font>
<font></font>
    // reconstruction of terrain fragment<font></font>
<font></font>
    float2 splatUV0 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap0);<font></font>
    float2 splatUV1 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap1);<font></font>
    float2 splatUV2 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap2);<font></font>
    float2 splatUV3 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap3);<font></font>
<font></font>
    half4 control = tex2D(_TerrainAlphaMap, i.heightMapUV);<font></font>
    half4 terrainColor = TerrainSplatMap(splatUV0, splatUV1, splatUV2, splatUV3, control);<font></font>
<font></font>
    half3 terrainSurfaceNormal = TerrainNormal(i.heightMapUV);<font></font>
    half3 terrainSurfaceTangent = cross(terrainSurfaceNormal, float3(0,0,1));<font></font>
    half3 terrainSurfaceBitangent = cross(terrainSurfaceTangent, terrainSurfaceNormal);<font></font>
<font></font>
    half3 terrainNormal = TerrainNormalMap(splatUV0, splatUV1, splatUV2, splatUV3, control);<font></font>
    terrainNormal = terrainNormal.x * terrainSurfaceTangent + <font></font>
                    terrainNormal.y * terrainSurfaceBitangent + <font></font>
                    terrainNormal.z * terrainSurfaceNormal;<font></font>
    <font></font>
    half3 terrainLightmapColor = TerrainLightmap(i.heightMapUV, terrainNormal);<font></font>
    terrainColor *= terrainLightmapColor;<font></font>
<font></font>
    // blend model color &amp; terrain color<font></font>
<font></font>
    half height = TerrainHeight(i.heightMapUV);<font></font>
    half deltaHeight = i.worldPos.y - height;<font></font>
    half blendingWeight = smoothstep(BlendStart, BlendEnd, deltaHeight);<font></font>
<font></font>
    result.rgb = lerp(result.rgb, terrainColor, blendingFactor);<font></font>
       <font></font>
    return result; <font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Mischen mit der Rekonstruktion von Landschaftsfragmenten behebt also alle Probleme, die f√ºr das Tiefenmischen und das Mischen mit einer H√∂henkarte, einschlie√ülich Parallaxe, typisch sind. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mf/pb/0s/mfpb0sfkav-hj-i5xhpll305drc.png"><br>
<img src="https://habrastorage.org/webt/ba/-z/x6/ba-zx6icghn-mnbreobdnekbjay.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vermischung der Landschaftsgestaltung</font></font></i><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rekonstruktionsleistung von Gel√§ndefragmenten</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An diesem Punkt ist es Zeit zu fragen, was diese Art von Kompromiss wert ist. Auf den ersten Blick √ºbersteigt die Ressourcenintensit√§t der Rekonstruktion von Landschaftsfragmenten die Ressourcenintensit√§t der Alpha-Mischung bei weitem. F√ºr die Rekonstruktion ist es notwendig, mit einem Dutzend zus√§tzlicher Leseoperationen aus dem Speicher durchzuf√ºhren. F√ºr das Alpha-Blending ben√∂tigen Sie nur eine Leseoperation aus dem Speicher und eine Schreiboperation in den Speicher. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Wirklichkeit h√§ngt alles von den Funktionen der Hardwareplattform ab. Die Fragmentrekonstruktion wird durch Texturkomprimierung, Mip-Mapping, GPU-Kernverarbeitungsleistung und spezifische Hardware-Tiefenpipeline-Optimierungen (fr√ºhe Tiefenunterdr√ºckung) beg√ºnstigt. Und gegen die Alpha-Mischung wird die oben bereits erw√§hnte Tatsache spielen, dass es der am wenigsten progressive Teil einer GPU ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt jedoch immer Raum f√ºr Optimierungen. </font><font style="vertical-align: inherit;">Bei der Rekonstruktion der Farbe der Landschaft ist diese Rekonstruktion beispielsweise nur f√ºr einen schmalen Streifen von Fragmenten des 3D-Modells erforderlich, der sich nicht h√∂her als eine bestimmte H√∂he √ºber der Oberfl√§che der Landschaft befindet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dynamische Verzweigungen in Shadern k√∂nnen zu schlecht vorhersehbaren Leistungsergebnissen f√ºhren. Es gibt jedoch zwei Punkte, die ber√ºcksichtigt werden sollten:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das √úberspringen unn√∂tiger Berechnungen beim Verzweigen durch eine Bedingung sollte durchgef√ºhrt werden, wenn diese Bedingung in einem wesentlichen Teil der F√§lle nicht erf√ºllt ist.</font></font></li>
<li>       .   ,             ( ,  ),      GPU.    ‚Äï   (branch granularity),  , , ,          ,      .         ,    ,       .  ,   GPU  ,     ,       . ,      GPU,   ,  1 (PowerVR SGX).</li>
</ol><br>
<img src="https://habrastorage.org/webt/i7/8y/x9/i78yx9mn7egjmojcmxl67crz1kc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualisierung unterschiedlicher Koh√§renzgrade</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Bei der Rekonstruktion von Fragmenten werden diese beiden Punkte ber√ºcksichtigt: Die Verzweigungsbedingung erm√∂glicht es in den meisten F√§llen, die Implementierung ressourcenintensiver Operationen zur Rekonstruktion der Farbe der Landschaft abzuschneiden, und diese Bedingung ist koh√§rent, mit Ausnahme einer sehr kleinen Anzahl von Fragmenten (in der Abbildung sind dies Fragmente, die liegen an der Grenze zwischen den Zonen ‚Äûrot‚Äú und ‚Äûgr√ºn‚Äú). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/k3/do/ic/k3doicnobaqmuv82xbdfvq_kgas.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koh√§renz der Rekonstruktion von Landschaftsfragmenten Es</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
bleiben noch einige Anmerkungen zu dieser Mischmethode hinzuzuf√ºgen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity bietet nur dann alle erforderlichen Texturen, wenn f√ºr die Landschaft der Modus "Instanz zeichnen" aktiviert ist </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[20]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Andernfalls ist die normale Karte nicht verf√ºgbar, sodass Sie die Landschaftsbeleuchtung f√ºr die √úberblendung nicht korrekt rekonstruieren k√∂nnen.</font></font></li>
<li> Unity API    ,      (base map)         . -          .</li>
<li>         ,   API          (, Metal   16  ). </li>
<li>    3D-  ,     Terrain,     SRP.</li>
<li> 3D-      ,       3D-    . </li>
<li>,   ¬´¬ª ,     ¬´¬ª  .    ,  ¬´¬ª      ,             .  ¬´¬ª          .</li>
</ol><br>
<img src="https://habrastorage.org/webt/9z/yi/y-/9zyiy-6z47y7pxyonhwrl31zyoc.png"><br>
<i>    </i><br>
<br>
<br>
<h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Gestaltung von 3D-Modellen kann die Vielfalt der Gel√§ndereliefs, mit denen diese Modelle verwendet werden sollen, nicht ber√ºcksichtigt werden. Oft m√ºssen 3D-Modelle tief in der Landschaft ‚Äûversenkt‚Äú oder gedreht werden, um hervorstehende Teile zu verbergen, oder umgekehrt, um versteckte Teile anzuzeigen, die sichtbar sein sollten. Erw√§rmungsmodelle schr√§nken ihre Anwendbarkeit ein. Wenn 3D-Modelle fr√ºher als die Landschaft gerendert werden, f√ºhrt dies auch zu einem √úberzeichnungseffekt. Die Kurve wiederum ist auch bei weitem nicht f√ºr alle 3D-Modelle geeignet (z. B. nicht f√ºr H√§user und B√§ume). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ue/tg/8y/uetg8yx5ctdsn80stvnnezplgh4.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die hervorstehenden Elemente des 3D-Modells auszublenden, muss es in der Landschaft ‚Äûertrinken‚Äú</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Snapping ist ein Begriff, der Benutzern von Grafikeditoren bekannt ist. Dies ist eine Funktion, mit der Kontrollpunkte an den Knoten des r√§umlichen Gitters und in 3D-Editoren an den Fl√§chen und Oberfl√§chen anderer Objekte ‚Äûhaften‚Äú k√∂nnen. Das Aufrufen der Karte der H√∂hen der Landschaft im Vertex-Shader kann die Gestaltung von Szenen erheblich vereinfachen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/4w/1t/xw/4w1txwi3vaczzpne7ewajozlymo.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3D-Modell ohne Einrasten. 3D-Modell mit Vertex-Snapping. 3D-Modell mit Scheitelpunktfang und -√ºberblendung. 3D-Modell mit Vertex-Snapping, Blending und statischer Beleuchtung</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptschwierigkeit bei der Implementierung des Fangens besteht darin, dass Sie herausfinden m√ºssen, welche Eckpunkte des 3D-Modells Sie an der H√∂henkarte fangen m√ºssen und welche nicht wert sind. </font><font style="vertical-align: inherit;">Scheitelpunkte enthalten nur Informationen √ºber die lokale Natur der Oberfl√§che (was nicht ausreicht) und enthalten keine Informationen √ºber ihre Topologie (was erforderlich ist). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie in anderen Anwendungsf√§llen ist dieses Problem in der Modellierungsphase am einfachsten zu l√∂sen, indem die erforderlichen Parameter direkt in den Scheitelpunkten implementiert werden. </font><font style="vertical-align: inherit;">Als solchen Parameter sollten Sie ein intuitives Attribut ausw√§hlen - zum Beispiel den Gewichtungsfaktor f√ºr das Einrasten (und nicht den Abstand zum Rand einer offenen Oberfl√§che, wie wir es aus Gr√ºnden der Flexibilit√§t w√ºnschen). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7b/gq/2b/7bgq2bdhdlr13qgeqpgcocvo0q8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gewichtungscodierung f√ºr das Einrasten</font></font></i><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code anzeigen</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Per-vertex</span> <span class="hljs-selector-tag">snapping</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">heightmap</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainHeightmapTexture</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">HeightmapScale</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainSize</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainPos</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
<font></font>
   // ...<font></font>
<font></font>
   float3 <span class="hljs-attribute">worldPos </span>: TEXCOORD0;<font></font>
   float2 <span class="hljs-attribute">heightMapUV </span>: TEXCOORD1;<font></font>
<font></font>
   // ...<font></font>
<font></font>
};<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
   <font></font>
    // ...<font></font>
    <font></font>
    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<font></font>
    o.heightMapUV = TerrainUV(o.worldPos);<font></font>
    float snappingWeight = v.color.r;                <font></font>
    half height = TerrainHeight( o.heightMapUV );                <font></font>
    o.worldPos.y = lerp( o.worldPos.y, height, snappingWeight );<font></font>
    o.pos = UnityWorldToClipPos( half4( o.worldPos, 1 ) );<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anwendbarkeit des Vertex-Schnappens ist durch die allgemeine Entsprechung zwischen dem Gel√§nde und der Oberfl√§che des 3D-Modells begrenzt. </font><font style="vertical-align: inherit;">Um ihre signifikanten Unterschiede auszugleichen, m√ºssen andere, ressourcenintensivere Methoden verwendet werden - beispielsweise 3D-Modelle mit Skinning.</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptidee, die aus dem Artikel herausgenommen werden sollte: Jeder ausreichend komplexe und potenziell skalierbare Shader ben√∂tigt Basisdaten. </font><font style="vertical-align: inherit;">Die Aufgabe des Entwicklers besteht darin, zu verstehen, wie das Grafiksystem bedient werden kann: Welche Daten werden bereitgestellt, wie k√∂nnen sie miteinander kombiniert werden und wie werden sie in Shadern verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im allgemeinen Fall k√∂nnen wir den Schluss ziehen, dass die einzige M√∂glichkeit, den Rahmen zu √ºberwinden, durch den die M√∂glichkeiten von Grafikeffekten begrenzt sind, darin besteht, die Ergebnisse verschiedener Shader zu kombinieren.</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links anzeigen</font></font></b><div class="spoiler_text"><sup>[1]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/Manual/SL-CameraDepthTexture.html</a><br>
<sup>[2]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/ScriptReference/Camera-depthTextureMode.html</a><br>
<sup>[3]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/ScriptReference/RenderTexture.html</a><br>
<sup>[4]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.khronos.org/opengl/wiki/Framebuffer_Object</a><br>
<sup>[5]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.microsoft.com/en-us/windows/win32/api/d3d11/nf-d3d11-id3d11device-createrendertargetview</a><br>
<sup>[6]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/ScriptReference/Rendering.BlendMode.html</a><br>
<sup>[7]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/ScriptReference/Rendering.BlendOp.html</a><br>
<sup>[8]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.khronos.org/opengl/wiki/Blending</a><br>
<sup>[9]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.microsoft.com/en-us/windows/win32/direct3d11/d3d10-graphics-programming-guide-blend-state</a><br>
<sup>[10]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">en.wikipedia.org/wiki/Parallax</a><br>
<sup>[11]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">en.wikipedia.org/wiki/Parallax_scrolling</a><br>
<sup>[12]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainData-heightmapTexture.html</a><br>
<sup>[13]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pdfs.semanticscholar.org/ce6c/fcafe3581a7e4d7184a9727cc504bdc6b295.pdf</a><br>
<sup>[14]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/Terrain-normalmapTexture.html</a><br>
<sup>[15]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/Terrain-lightmapIndex.html</a><br>
<sup>[16]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainData-alphamapTextures.html</a><br>
<sup>[17]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainData-terrainLayers.html</a><br>
<sup>[18]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainLayer-tileSize.html</a><br>
<sup>[19]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainLayer-tileOffset.html</a><br>
<sup>[20]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/Terrain-drawInstanced.html</a><br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de490204/index.html">Die Zusammenfassung der Ereignisse f√ºr Personal- und IT-Personalvermittler im M√§rz 2020</a></li>
<li><a href="../de490208/index.html">Backend-Bereich auf DUMP2020: Banter, Fan, Fail</a></li>
<li><a href="../de490210/index.html">Das Frontend beschleunigen. Wenn viele Serveranforderungen gut sind</a></li>
<li><a href="../de490222/index.html">Standardbibliothek zum Todestag</a></li>
<li><a href="../de490224/index.html">Modische Stealth</a></li>
<li><a href="../de490242/index.html">GSM-Ortungsdienst von SIM800x-Modulen und seine Arbeit mit der Yandex.Locator-API</a></li>
<li><a href="../de490244/index.html">Python-Code-Optimierung mit ctypes</a></li>
<li><a href="../de490246/index.html">Kreml-T√ºrme in Hydras Umarmung: Hydra 2020 Parallel and Distributed Computing Conference</a></li>
<li><a href="../de490248/index.html">Webinar ‚ÄûWinnum CNC: √úberwachung, die funktioniert‚Äú</a></li>
<li><a href="../de490250/index.html">Horror Set.removeAll</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>