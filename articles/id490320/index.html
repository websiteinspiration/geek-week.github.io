<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¬ ğŸ‘©ğŸ¼â€âš–ï¸ ğŸ’‚ Membuat POSTGRESQL COUNT Lebih Cepat (*) ğŸ‘¨ğŸ¼â€ğŸ”¬ ğŸ™† ğŸ‘©ğŸ¾â€ğŸ”§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sering mengeluh bahwa hitungan (*) di PostgreSQL sangat lambat. 
 
 Pada artikel ini, saya ingin menjelajahi opsi sehingga Anda mendapatkan hasilnya s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Membuat POSTGRESQL COUNT Lebih Cepat (*)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490320/"><img src="https://habrastorage.org/webt/gd/v7/vr/gdv7vrlvosn5rd46igghex_2ofe.png" height="60%" width="60%"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sering mengeluh bahwa hitungan (*) di PostgreSQL sangat lambat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada artikel ini, saya ingin menjelajahi opsi sehingga Anda mendapatkan hasilnya secepat mungkin.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa hitung (*) begitu lambat?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kebanyakan orang mengerti tanpa masalah bahwa permintaan berikut ini akan dieksekusi dengan lambat:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">count</span>(*)
<span class="hljs-keyword">FROM</span> <span class="hljs-comment">/*   */</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimanapun, ini adalah kueri yang kompleks, dan PostgreSQL harus menghitung hasilnya sebelum ia tahu berapa banyak baris yang akan dikandungnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi banyak orang terkejut ketika mereka mengetahui bahwa permintaan berikut ini lambat:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">FROM</span> large_table;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, jika Anda berpikir lagi, semua hal di atas berlaku: PostgreSQL harus menghitung hasil yang ditetapkan sebelum dapat menghitungnya. </font><font style="vertical-align: inherit;">Karena "penghitung baris ajaib" tidak disimpan dalam tabel (seperti pada MyISAM MySQL), satu-satunya cara untuk menghitung baris adalah dengan melihatnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, count (*) biasanya melakukan pemindaian tabel sekuensial, yang bisa sangat mahal.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah "*" dalam hitungan (*) masalah?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"*" Dalam SELECT * FROM ... berlaku untuk semua kolom. </font><font style="vertical-align: inherit;">Oleh karena itu, banyak orang menemukan bahwa menggunakan count (*) tidak efisien, dan sebagai gantinya menggunakan count (id) atau count (1) sebagai gantinya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi "*" dalam hitungan (*) sama sekali berbeda, itu hanya berarti "string" dan tidak berkembang sama sekali (pada kenyataannya, itu adalah "agregat dengan argumen nol"). </font><font style="vertical-align: inherit;">Penghitungan notasi (1) atau penghitungan (id) sebenarnya lebih lambat daripada penghitungan (*), karena harus diperiksa apakah argumennya NULL atau tidak (hitungan, seperti kebanyakan agregat, mengabaikan argumen NULL). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi Anda tidak akan mencapai apa pun dengan menghindari "*".</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya pemindaian indeks</font></font></i></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sangat menggoda untuk memindai indeks kecil, bukan seluruh tabel, untuk menghitung jumlah baris. Namun, ini tidak begitu sederhana di PostgreSQL karena strategi manajemen konkurensi multi-versi. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap versi baris ("tuple") berisi informasi tentang snapshot basis data mana yang terlihat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tetapi informasi (redundan) ini tidak disimpan dalam indeks. Oleh karena itu, biasanya tidak cukup untuk menghitung entri dalam indeks, karena PostgreSQL harus melihat entri tabel ("heap tuple") untuk memastikan bahwa entri indeks terlihat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengurangi masalah ini, PostgreSQL telah menerapkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peta visibilitas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , struktur data yang menyimpan informasi tentang apakah semua tupel dalam blok tabel dapat dilihat oleh semua orang atau tidak.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika sebagian besar blok dalam tabel terlihat sepenuhnya, maka pemindaian indeks tidak perlu sering mengunjungi sekelompok tupel untuk menentukan visibilitas. </font><font style="vertical-align: inherit;">Pemindaian indeks semacam itu disebut "pemindaian indeks saja," dan seringkali lebih cepat untuk memindai indeks untuk menghitung baris. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang VACUUM yang mendukung peta visibilitas, jadi pastikan autovacuum cukup sering dilakukan jika Anda ingin menggunakan indeks kecil untuk mempercepat hitungan (*).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan tabel pivot</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menulis di atas bahwa PostgreSQL tidak menyimpan jumlah baris dalam sebuah tabel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mempertahankan jumlah baris seperti itu merupakan biaya overhead yang besar, karena peristiwa ini terjadi pada setiap modifikasi data dan tidak membuahkan hasil. Itu akan menjadi transaksi yang buruk. Selain itu, karena permintaan yang berbeda dapat melihat versi string yang berbeda, penghitung juga harus diversi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi tidak ada yang menghalangi Anda untuk menerapkan penghitung garis seperti itu sendiri. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan Anda ingin melacak jumlah baris dalam mytable. Anda dapat melakukannya sebagai berikut:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<font></font>
 <font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> mytable_count(c <span class="hljs-built_in">bigint</span>);<font></font>
 <font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> mytable_count() <span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">trigger</span>
   <span class="hljs-keyword">LANGUAGE</span> plpgsql <span class="hljs-keyword">AS</span>
$$<span class="hljs-keyword">BEGIN</span>
   <span class="hljs-keyword">IF</span> TG_OP = <span class="hljs-string">'INSERT'</span> <span class="hljs-keyword">THEN</span>
      <span class="hljs-keyword">UPDATE</span> mytable_count <span class="hljs-keyword">SET</span> c = c + <span class="hljs-number">1</span>;<font></font>
 <font></font>
      RETURN NEW;<font></font>
   ELSIF TG_OP = '<span class="hljs-keyword">DELETE</span><span class="hljs-string">' THEN
      UPDATE mytable_count SET c = c - 1;
 
      RETURN OLD;
   ELSE
      UPDATE mytable_count SET c = 0;
 
      RETURN NULL;
   END IF;
END;$$;
 
CREATE CONSTRAINT TRIGGER mytable_count_mod
   AFTER INSERT OR DELETE ON mytable
   DEFERRABLE INITIALLY DEFERRED
   FOR EACH ROW EXECUTE PROCEDURE mytable_count();
 
-- TRUNCATE triggers must be FOR EACH STATEMENT
CREATE TRIGGER mytable_count_trunc AFTER TRUNCATE ON mytable
   FOR EACH STATEMENT EXECUTE PROCEDURE mytable_count();
 
-- initialize the counter table
INSERT INTO mytable_count
   SELECT count(*) FROM mytable;
 
COMMIT;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami melakukan segalanya dalam satu transaksi sehingga tidak ada perubahan data pada transaksi bersamaan dapat "hilang" karena kondisi dering. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini dijamin oleh perintah CREATE TRIGGER yang mengunci tabel dalam mode SHARE ROW EXCLUSIVE, yang mencegah semua perubahan bersamaan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelemahannya adalah bahwa semua modifikasi data paralel harus menunggu sampai penghitungan SELECT (*) dijalankan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini memberi kita alternatif yang sangat cepat untuk menghitung (*), tetapi dengan biaya memperlambat semua perubahan data dalam tabel. Menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pemicu kendala yang ditangguhkan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memastikan bahwa kunci baris di mytable_count sesingkat mungkin untuk meningkatkan concurrency. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meskipun tabel counter ini dapat menerima banyak pembaruan, tidak ada bahaya</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada "kembung tabel"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , karena semua ini akan menjadi pembaruan "panas" (pembaruan HOT).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda benar-benar perlu menghitung (*)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terkadang solusi terbaik adalah mencari alternatif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seringkali perkiraannya cukup baik dan Anda tidak perlu jumlah yang tepat. </font><font style="vertical-align: inherit;">Dalam hal ini, Anda dapat menggunakan skor yang digunakan PostgreSQL untuk menjadwalkan pertanyaan:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> reltuples::<span class="hljs-built_in">bigint</span>
<span class="hljs-keyword">FROM</span> pg_catalog.pg_class
<span class="hljs-keyword">WHERE</span> relname = <span class="hljs-string">'mytable'</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nilai ini diperbarui oleh autovacuum dan autoanalisis, sehingga tidak boleh melebihi 10%. </font><font style="vertical-align: inherit;">Anda dapat mengurangi autovacuum_analyze_scale_factor untuk tabel ini sehingga analisis otomatis berjalan di sana lebih sering.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memperkirakan jumlah hasil kueri</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejauh ini, kami telah mengeksplorasi cara mempercepat penghitungan baris tabel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi kadang-kadang Anda perlu tahu berapa banyak baris pernyataan SELECT akan kembali tanpa benar-benar mengeksekusi kueri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jelas, satu-satunya cara untuk mendapatkan jawaban yang akurat untuk pertanyaan ini adalah dengan melengkapi permintaan. </font><font style="vertical-align: inherit;">Tetapi jika nilainya cukup baik, Anda dapat menggunakan pengoptimal PostgreSQL untuk mendapatkannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi sederhana berikut menggunakan SQL dinamis dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPLAIN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk mendapatkan rencana eksekusi permintaan yang dilewati sebagai argumen, dan mengembalikan perkiraan jumlah baris:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> row_estimator(<span class="hljs-keyword">query</span> <span class="hljs-built_in">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-built_in">bigint</span>
   <span class="hljs-keyword">LANGUAGE</span> plpgsql <span class="hljs-keyword">AS</span>
$$<span class="hljs-keyword">DECLARE</span><font></font>
   plan jsonb;<font></font>
<span class="hljs-keyword">BEGIN</span>
   <span class="hljs-keyword">EXECUTE</span> <span class="hljs-string">'EXPLAIN (FORMAT JSON) '</span> || <span class="hljs-keyword">query</span> <span class="hljs-keyword">INTO</span> plan;<font></font>
 <font></font>
   RETURN (plan-&gt;0-&gt;'Plan'-&gt;&gt;'Plan Rows')::bigint;<font></font>
<span class="hljs-keyword">END</span>;$$;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jangan gunakan fungsi ini untuk memproses pernyataan SQL yang tidak dipercaya, karena secara inheren rentan terhadap injeksi SQL.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id490302/index.html">Belajar untuk menggunakan layanan microser. Bagian 3. Helm</a></li>
<li><a href="../id490306/index.html">Bagaimana kami membuat maket teknologi ruang angkasa untuk Moscow Aviation Institute</a></li>
<li><a href="../id490310/index.html">Hukum Faraday atau bagaimana magnet terjebak dalam pipa tembaga</a></li>
<li><a href="../id490314/index.html">RE: 23 menit. Pembenaran yang cerdik</a></li>
<li><a href="../id490318/index.html">Prostesis bionik saat ini</a></li>
<li><a href="../id490322/index.html">Namibia: infrastruktur dan apa yang perlu diketahui sebelum bepergian</a></li>
<li><a href="../id490324/index.html">Bagaimana kami menemukan kesalahan yang tidak terlihat dalam antarmuka tugas online untuk anak-anak</a></li>
<li><a href="../id490328/index.html">Profesi: Penguji</a></li>
<li><a href="../id490332/index.html">Kami membuat klon dari layanan pengiriman makanan menggunakan Nuxt.js, GraphQL, Strapi dan Stripe. Bagian 2/7</a></li>
<li><a href="../id490336/index.html">Saluran Anatomi dalam Go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>