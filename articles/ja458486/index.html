<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😁 🔖 👴🏻 ゲームでファブリックを操作する秘訣アランウェイク ⛱️ 🛀🏽 🌃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[救済アニメーションプログラマーのヘンリックエンキストは、彼のチームがホラースリラーアランウェイクの主人公の魅力的なツイードジャケットシミュレーションを作成した方法を説明しました。]
 
 私たちのアクションスリラーの主人公は、彼と戦わなければならない悪夢のライター暗黒の力と彼の妻の失踪の謎を解きま...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ゲームでファブリックを操作する秘訣アランウェイク</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458486/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/18e/a10/c1818ea10be738aafeb51e0157ad247b.jpg"></div><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[救済アニメーションプログラマーのヘンリックエンキストは、彼のチームがホラースリラーアランウェイクの主人公の魅力的なツイードジャケットシミュレーションを作成した方法を説明しました。]</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
私たちのアクションスリラーの主人公は、彼と戦わなければならない悪夢のライター暗黒の力と彼の妻の失踪の謎を解きます。彼はよく訓練されたアクションヒーローではなく、普通の人です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャラクターを強調するために、私たちのアートディレクターは、肘にパッチを当てた古いツイードジャケットで彼を着たいと思っていました。ゲームは実世界の側近で行われるため、ファンタジーゲームやスペースシューティングゲームとは異なり、使用するツールに制限があります。そしてこれは私たちのキャラクターの服がはるかに重要になることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スリラーな雰囲気の錯覚を伝えるために、アランウェイクのジャケットはできるだけ信じられるべきです。</font><font style="vertical-align: inherit;">ジャケットは風になびき、森の中を移動する際にキャラクターに補助的な動きを加えます。</font><font style="vertical-align: inherit;">プログラマーとして、私はすぐに組織シミュレーションの使用について考え始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの前の多くのゲームでファブリックシミュレーションが使用されていましたが、そこでよく使用されるテクニックは、シルクやゴムのような感覚を与えました。</font><font style="vertical-align: inherit;">ごく最近、サードパーティ企業の非常に優れた組織シミュレーションシステムが登場し始めましたが、安定したソリューションが必要だった当時、そのようなツールはまだ存在していなかったか、ニーズを満たしていませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、私たちが直面しなければならない問題と、独自の組織シミュレーションを作成するためのソリューションについて説明します。</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジャケットリグ</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジャケットは通常のスキニングメッシュのように残りのキャラクターでモデル化されました。</font><font style="vertical-align: inherit;">ジャケットメッシュを制御するボーンは、通常のスケルトンの上にある別のレイヤーです。</font><font style="vertical-align: inherit;">ジャケットの袖は、通常の肩と前腕のパターンを使用しています。</font><font style="vertical-align: inherit;">肩と前腕の両方が1つの主要な骨と1つの曲がった骨に分かれています。</font><font style="vertical-align: inherit;">ジャケットの上部はルックアットコンストレイントによって制御され、下部はVerletシミュレーションによって制御されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c2/6a6/63c/0c26a663c171f554b18e4bd555601477.png"></div><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図1.通常のゲームスケルトンの上にあるリグジャケット。</font></font></strong> <br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジャケットトップ</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジャケットのボーンには、上から下に階層構造があります（下のボーンは上のボーンの子です）。そのため、上のボーンが移動すると、下のボーンがそれに追従します。</font><font style="vertical-align: inherit;">下の骨を直接胸に向けて娘にしようと誘惑されましたが、キャラクターが肩を上げると、動き、特に垂直方向の動きが失われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジャケットの上部で、肩のパッドの動きをシミュレートし、ルックアットコンストレイントを使用して、肩のボーンに向かって肩のボーンを動かします。</font><font style="vertical-align: inherit;">これのおかげで、パッドは肩に続き、手を上げると、本物のジャケットのように、パッドが残りの骨を持ち上げます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルックアットコストレイン制約はどのように見えるか</font></font></b><div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/206/2a0/3af/2062a03af21d6458b3d9b2a278223b83.gif" alt="image"></div><br>
<b>Look-at costraint    </b></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チェーンの次のボーンは、ジャケットの上部とシミュレートされた下部の間のレイヤーです。これらのボーンは、肩によって作成される回転を補正するために、ルックアットコンストレイントによって直接下に駆動されます。また、左右のボーン間に位置制約を追加して、肩パッドが動くときに発生するストレッチを補正しました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/085/686/dc2/085686dc265664fe90ab7659a199f7e0.png"></div><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2.手を上げるときの骨の動き。</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、アニメーションのエクスポーターに制限を実装し、アニメーションデータの結果をベイクするには十分ですが、ゲームエンジンのボーンをリアルタイムで制御することを試みました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このおかげで、アニメーションデータに数バイトを節約できるだけでなく、ジャケットの有無に関係なく、キャラクター間でアニメーションを簡単に転送できました。</font><font style="vertical-align: inherit;">さらに、リアルタイムコンストレイントを解決するときに、ゲームのインバースキネマティクス（たとえば、照準時）によって生成される肩の動きが正しく適用されます。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジャケットの底</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジャケットの上部の問題を解決したので、下部のシミュレーションを開始しました。ファブリックのほとんどのゲームシミュレーションでは、組織シミュレーションの頂点とレンダリングされたメッシュの頂点の間で1対1のバインディングを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラマーが定義した制限に干渉しないように、ジャケットメッシュの精度を維持したいと考えました。たとえば、レンダリングと同じメッシュをファブリックシミュレーションに使用することを決定した場合、ポケットとジャケットの前面のシルエットが失われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノーマルマップはジャケットにボリュームを与えるために使用できますが、それでは十分ではないと感じました。</font><font style="vertical-align: inherit;">私たちはアーティストにジャケットを思い通りにモデル化し、失われたジオメトリを補うのではなく、法線マップを使用して折り目やその他の詳細を追加できるようにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この決定に至りました。低解像度のファブリックのメッシュを作成してジャケットをシミュレートし、それをスキニングメッシュの制御に使用されるスケルトンのボーンにアタッチします。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/011/cf3/4e2/011cf34e28fedf303ecc5a62ee15a7b0.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f4/bd8/582/2f4bd8582bc2c876c24a6a0663784938.png"></div><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3.同じ頂点を持つジャケットとファブリックのシルエットのシミュレーションによる比較。</font></font></strong> <br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Physics Werle</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初にVerletの物理を調べ、次にボーンのシミュレーション用の一致を作成する方法を学びます。 VerléPhysicsは現在、ゲームでファブリックをシミュレーションするための標準的なソリューションです。ヴェレテクニックに慣れていない場合は、まず、ガマストラ：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">悪魔の青いファセットドレス：リアルタイムの布のアニメーション</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高度なキャラクターの物理</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に関するこれらの記事のいずれかを読むことをお勧めし</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c62/348/0d0/c623480d0de44a9ae1041f6c2ba9a5e0.png"></div><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図4. 4x4頂点のグリッドと頂点の1つに対する制約。</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
残りについては、私は仕事の原則を簡単に繰り返します。図4は、ファブリックメッシュとその頂点の1つに対するスプリングコンストレイントを示しています。図からわかるように、各メッシュの頂点は、隣接するすべての頂点と隣接する頂点に接続されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
隣接するものからの制約はストレッチ制約と呼ばれ、青色で示されます。赤で示された長い拘束は、せん断/曲げ拘束と呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの制限は2つのグループに格納することが重要です。後で異なるパラメーターを使用してそれらを解決するためです。ジャケットでは、一番上の列のファブリックポイントはスキニングによってキャラクターに関連付けられており、シミュレーションでは制御されないことに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッシュメッシュの存在はアルゴリズム自体の要件ではありませんが、このようなトポロジでファブリックをシミュレーションするには、最も簡単に操作できます。組織シミュレーションの基礎は2つの部分で構成されています。最初の部分はVerlet統合で、各頂点の速度を計算し、それを位置に適用します。</font></font><br>
<br>
<pre><code class="cpp hljs">Vector3 vVelocity = vertex.vCurrentPosition - vertex.vPreviousPosition;<font></font>
vertex.vPreviousPosition = vertex.vCurrentPosition;<font></font>
vertex.vCurrentPosition += vVelocity * ( <span class="hljs-number">1.0f</span> - fDampingFactor ) + vAcceleration * fDeltaTime * fDeltaTime;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのプロジェクトでは</font></font><code>vAcceleration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、重力と風の合計を考えました。減衰は、ジャケットの外観を調整し、シミュレーションを安定させるために使用されました。減衰</font></font><code>fDampingFactor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が大きいと、非常に軽い生地の感触が得られ、ゆっくりと滑らかに下降します。減衰が小さいと、ジャケットは重くなり、移動後の揺れ/振動が長くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムの2番目の部分は、ばね拘束の解決です（このプロセスは緩和と呼ばれます）。制約ごとに、頂点を互いに引き付けるかまたは反発させて、元の長さを満たすようにします。以下は、読みやすいコードスニペットです。</font></font><br>
<br>
<pre><code class="cpp hljs">Vector3 vDelta = constraint.m_vertex1.m_vCurPos - constraint.m_vertex0.m_vCurPos;
<span class="hljs-keyword">float</span> fLength = vDelta.length();<font></font>
vDelta.normalize();<font></font>
Vector3 vOffset = vDelta * ( fLength - constraint.m_fRestLength );<font></font>
constraint.m_vertex0.m_vCurrentPosition += vOffset / <span class="hljs-number">2.0f</span>;<font></font>
constraint.m_vertex1.m_vCurrentPosition -= vOffset / <span class="hljs-number">2.0f</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストレッチコンストレイントはファブリックの上部をまとめて保持し、チルト/ベンドコンストレイントはファブリックの形状を維持するのに役立ちます。</font><font style="vertical-align: inherit;">ご覧のとおり、このシステムの理想的なソリューションでは、ファブリックの動きが強すぎます。</font><font style="vertical-align: inherit;">そのため、新しい位置を解決する前に、傾き/曲げの制約に係数を追加します。</font></font><br>
<br>
<pre><code class="cpp hljs">vOffset *= fStiffness;<font></font>
constraint.m_vertex0.m_vCurrentPosition += vOffset / <span class="hljs-number">2.0f</span>;<font></font>
constraint.m_vertex1.m_vCurrentPosition -= vOffset / <span class="hljs-number">2.0f</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
剛性係数が1.0の場合、ファブリックは非柔軟性になり、0.0の場合、ファブリックは制限なしに曲がります。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">固定時間ステップ</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verlet統合が前のタイムステップが現在のタイムステップとまったく同じであることを示唆していることにすでに気付いているはずです。そうしないと、計算された速度が正しくなくなります。 Verlet統合を使用する場合、可変時間ステップを省略できますが、制約の解決は時間ステップの変化に非常に敏感です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソルバーは制限を繰り返し回避することで問題を解決するため、理想的に解決することはできません。ゲームでは、この不正確さはストレッチとして現れます。タイムステップが短いほど、プレーヤーに表示されるストレッチは少なくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終的に、これは精度と衣服に費やすことができるプロセッサー時間との間の妥協点になります。</font><font style="vertical-align: inherit;">時間ステップが一定でない場合、衣服の伸張が変化し、システムに不要な振動が導入されます。</font><font style="vertical-align: inherit;">さらに重要なのは、タイムステップが剛性インデックスと他のファブリックパラメータに影響を与えることです。タイムステップが短いほど、同じ剛性係数を使用した場合でも、ファブリックの剛性が高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、これは、ファブリックパラメーターを使用して衣服の外観をカスタマイズする前に、固定の時間ステップを決定する必要があることを意味します。</font><font style="vertical-align: inherit;">物理演算に可変時間ステップが使用されるゲームがあることは知っていますが、私の個人的な経験から、物理演算とゲームロジックの両方で時間ステップが固定されていると、人生がはるかに楽になることがわかります。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フード</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
組織シミュレーションの詳細に入る前に、フードのシミュレーション方法を簡単に見てみましょう。</font><font style="vertical-align: inherit;">フードメッシュの上部にスキンを適用するために、エクストラボーンを使用しました。</font><font style="vertical-align: inherit;">骨の中心からボンネットの後ろの位置まで振り子を作成しました。</font><font style="vertical-align: inherit;">振り子の終わりは、Verlet物理学によって制御される1つの粒子です。</font><font style="vertical-align: inherit;">次に、ルックアット拘束を使用して、骨を振り子に向けます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/090/fdf/57a/090fdf57a84edb44d5db943b1430f2b8.png"></div><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図5.フードと振り子。</font></font></strong> <br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボーンマトリックスの作成</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フードは、ジャケットの底で次に何をすべきかについてのヒントを与えてくれます。シミュレーションされたメッシュの頂点の位置を使用して、ボーンの変換を計算します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず最初に、ボーンをマッピングして、各ボーンのヒンジをシミュレートされたメッシュの上部に一致させます。このため、変位に関連するマトリックスの部分のタスクは簡単なプロセスになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、3x3回転行列を計算する必要があります。各行（またはマトリックスの構成に応じて列）は、ボーンのx、y、z軸によって定義されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ボーンのx軸をベース頂点からその下の次の頂点への方向として定義します。次に、y軸は、左側の頂点から右側の頂点へのベクトルによって定義されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0d/ba1/428/c0dba1428673d304dc5119e43e96e92e.png"></div><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図6.ファブリックメッシュに取り付けられた骨。</font></font></strong> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
図6では、x軸が赤で、y軸が緑で示されています。次に、これらのベクトルのベクトル積としてz軸が計算されます。最後に、マトリックスを正規直交化して、変位データの歪みを取り除きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のように、垂直方向では、ファブリックメッシュの各行（最後を除く）を使用してボーンを調整しますが、水平方向では2列ごとにのみ使用します。上記の芸術的な利点を提供することに加えて、この方法も非常に高速です。これにより、GPU側で従来のスキニングテクニックを使用してメッシュをレンダリングできます。これを行わないと、巨大な動的頂点バッファーを更新する必要があるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファブリックメッシュの解像度はかなり低くなり、CPUの負荷が軽減されます。</font><font style="vertical-align: inherit;">私たちのソリューションの唯一の追加コストは、低解像度シミュレーションを高解像度メッシュに変換することですが、私たちのスキームでは、これらのコストは他のシミュレーションと比較してごくわずかです。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">衝突</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
脚と体で組織をトリミングする問題を解決するために、楕円体と粒子の間の衝突の認識を使用します。</font><font style="vertical-align: inherit;">図7は、キャラクターモデルによるジャケットのトランケーションを解決するために必要な楕円体を示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4a/277/f0c/a4a277f0c2991b0a013d821a8879ecea.jpg"></div><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図7. Wakeモデルの楕円体システム。</font></font></strong> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
楕円体と粒子の衝突の認識は非常に高速です。衝突は、楕円体と粒子が存在する空間を変換して楕円体を球に変えることで解決できます。次に、球と粒子のクイック衝突テストを実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、これには、楕円体の長さ、幅、高さに基づく逆変換の作成と、その粒子位置への適用が伴います。ここでの唯一の問題は、元の座標系に変換した後で発生する通常の衝突が歪んでいることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
衝突の方向を計算する際に、多少の不正確さで妥協できると判断しました。</font><font style="vertical-align: inherit;">強く伸ばされた楕円体が不正確な反応を引き起こす可能性がある場合は、それをさらに2つの均一な楕円体に分割しました。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">粒子までの最大距離</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決する必要がある別の問題は、ジャケットの安定性でした。動きの速いファブリックは、ノードの作成を引き起こしたり、衝突のボリュームの反対側に現れたり、ボディを通過したりする可能性があります。この問題は、シミュレーションされた組織の各頂点に安全な距離を設定することで解決しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
頂点ごとに、スキニングによる初期の静止位置が最も近いボーンにアタッチされ、それを基準点として使用します。シミュレーションがしきい値を超えた場合は、頂点を参照点に近づけるだけです。設計では、下のピークが肩に近いピークよりも長い距離を移動できるようにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ピークを移動できる最大距離は約40 cmです。この値を超えると、まれにノットやトランケーションが発生し始めます。</font><font style="vertical-align: inherit;">また、衝突平面などの他の手法を使用することも試みましたが、最大距離法が最適であることが判明しました。</font><font style="vertical-align: inherit;">それは速く、セットアップが簡単で、顕著なエラーがファブリックに現れるようになる前に、最大の動きの自由をもたらしました。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ツイードを増やし、ゴムを減らす</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、目標を達成するための良い方法を見つけることができました。</font><font style="vertical-align: inherit;">私たちのアーティストは彼のジャケットを好きなようにモデル化しました。</font><font style="vertical-align: inherit;">ジャケットをアニメーション化するために、すべてがゲームでシミュレートされたため、アニメーターは必要ありませんでした。プロセッサーには、他のゲーム内計算に十分なリソースがあることを嬉しく思いました。</font><font style="vertical-align: inherit;">しかし、一つ気になったのは、生地がゴムのように見えたことです。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストレッチング</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、ストレッチを取り除く必要があります。上で述べたように、ストレッチングの現象は、アルゴリズムの反復的な性質が原因で発生するエラーによって引き起こされます。これは人気のある研究トピックであり、この問題を解決する多くの方法を見つけることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、利用可能なすべてのソリューションでは、組織計算にはるかに少ないCPUリソースを割り当てる必要があります。したがって、いわゆる「ハードコンストレイント」が適用される組織シミュレーションに最後のステップを追加することで、ストレッチングの問題を解決しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストレッチの制限を厳しく制限しました（すべて垂直方向に向けられています）。これらの制限は上から下に並べられ、肩の近くの制限が脚の近くの制限に解決されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上から制約を反復するので、ペアの一番上の頂点は既に解決されており、ストレッチが発生していないことがわかっているので、一番下の頂点を一番上に移動する必要があります。これにより、1回の反復の後、上から下までの長さが静止時の長さと正確に同じになることが確実になりました。</font></font><br>
<br>
<pre><code class="cpp hljs">Vector3 vDelta = constraint.m_vertexTop.m_vCurPos - constraint.m_vertexDown.m_vCurPos;
<span class="hljs-keyword">float</span> fLength = vDelta.length();<font></font>
vDelta.normalize();<font></font>
Vector3 vOffset = vDelta * ( fLength - constraint.m_fRestLength );<font></font>
constraint.m_vertexDown.m_vCurrentPosition += vOffset;</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7e/84c/a2a/c7e84ca2afe73e36a6c4c89a01fbec14.png"></div><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図8.厳しい制限。</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、ジャケットの横方向の伸縮は考慮されていません。</font><font style="vertical-align: inherit;">水平方向に厳密な制限を適用することは不可能です。この場合、頂点は2回解決されるため、つまり、垂直計算ステージの結果が失われ、ファブリックの長さが静止しなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ジャケットの場合、実際には水平方向のストレッチが人間の目に見えないままであり、垂直方向のストレッチが原因で、ジャケットの外観が非常に悪いことに気付きました。</font><font style="vertical-align: inherit;">このソリューションは非常に優れていることがわかりました。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジャケットの端</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ジャケットの端を他の端より少しだけ動かしたかったのです。</font><font style="vertical-align: inherit;">たとえば、開いたジャケットを実行すると、空気抵抗が中央部分よりもジャケットの端に影響を与えることに気づくでしょう。</font><font style="vertical-align: inherit;">これは、体がジャケットの残りの部分を風から覆っているからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エッジは、接続されている制約の数によって簡単に見つけることができます。</font><font style="vertical-align: inherit;">ストレッチ拘束が4つ未満の頂点はエッジです。</font><font style="vertical-align: inherit;">したがって、これらの頂点にマークを付けて、他のパラメーターでシミュレートできます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">減衰の低減。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地球風はより大きな影響を与えます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワールドスペースでの動きの影響は大きくなります（ワールドスペースでの動きの詳細については、以下を参照してください）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大許容安全距離は高くなります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このため、エッジの内部周波数はジャケットの他の部分とは異なります。</font><font style="vertical-align: inherit;">これで、ジャケット全体が大きな振り子のような衝撃に反応せず、エッジのみがムーブメントに美しい補助ムーブメントを追加します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d8/31a/db6/8d831adb6fe8481e9b05830abf71e555.png"></div><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図9.エッジの上部。</font></font></strong> <br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワールド空間とローカル空間での動き</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、キャラクターを動かすとき、ワールドスペース内の動きがシミュレーションにかなり大きな影響を与える一方で、小さなローカルボディのターンや肩の動きは気付かれないことに気づきました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
従来の組織シミュレーションでは、頂点の位置はワールド空間でシミュレーションされます。</font><font style="vertical-align: inherit;">誰かが組織をシミュレートすることは正しいと言うかもしれませんが、それは不自然に感じます。</font><font style="vertical-align: inherit;">そのため、ローカル空間のキャラクターのジャケットをシミュレートし、ワールド空間に少し動きを追加しました。</font><font style="vertical-align: inherit;">必要な結果は、スケルトンのローカルアニメーションが100％、ワールド空間で10〜30％の動きで得られることに気付きました。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摩擦</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、ゆっくりとした動きと速い動きのジャケットのコントラストを誇張したかったのです。</font><font style="vertical-align: inherit;">歩くときにジャケットが比較的動かないようにしたかったので、アランがジャンプしたりかわしたりすると、動きがより活発になるはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジャケットが体に触れると、ジャケットとシャツの摩擦で動きが少なくなり、ジャケットが上がると動きが制限されるので動きが激しくなります。</font><font style="vertical-align: inherit;">楕円体に接する各頂点に減衰値の増加を適用することにより、これをシミュレートしました。</font><font style="vertical-align: inherit;">このおかげで、身体に触れるトップスは少しべたつくように見え、通常の状況と速い動きでジャケットとの間に十分なコントラストが生まれます。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論とさらなる作業</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
組織シミュレーションの最初の実施形態は、実装が非常に簡単でした。ゲーム開発の文献で「ファブリック」という単語を検索し、見つかったアルゴリズムを適用しただけです。ツイードジャケットの説得力のある感覚を実現しようとした2番目の段階では、科学論文の研究、多くの試行錯誤、さらにはコードの一部の削除さえ必要でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、いつでも何かを改善することができます。たとえば、低解像度のシミュレーションを使用し、それを高解像度のメッシュにリンクすると、すべての切り捨ての問題に対するソリューションが複雑になります。他の細かい部分に十分な時間はありませんでした。たとえば、ジャケットの折り目の場所にある折りたたみカードや、ジャケットと竜巻の間の正しい相互作用の実装です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終的に、私たちの努力は報われました-私たちの生地は他のゲームの組織シミュレーションとは非常に異なります。</font><font style="vertical-align: inherit;">彼女はシルクやゴムよりもツイードのように見えます。</font><font style="vertical-align: inherit;">さらに、私たちのシステムは非常に柔軟であることがわかり、他のファブリック、たとえばバリーウィーラーのダウンジャケットやおばあさんのベールをシミュレートできるようになりました。</font><font style="vertical-align: inherit;">パラメータを調整することで、シミュレーションやその他の種類の組織を実現できるようです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/18e/a10/c1818ea10be738aafeb51e0157ad247b.jpg"></div><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図10.ツイードジャケット。</font></font></strong></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja458470/index.html">テクスチャリング、またはSurfaceアーティストになるために知っておくべきこと。パート2.マスクとテクスチャ</a></li>
<li><a href="../ja458472/index.html">オープンデータを使用した熱ポテンシャル法による地域の評価の編集</a></li>
<li><a href="../ja458474/index.html">HighLoad ++ 2018を使用した最高のレポート</a></li>
<li><a href="../ja458482/index.html">パート3：LinuxをSDカードからRocketChipにほぼ出荷する</a></li>
<li><a href="../ja458484/index.html">PSR規格</a></li>
<li><a href="../ja458488/index.html">データサイエンスダイジェスト（2019年7月）</a></li>
<li><a href="../ja458490/index.html">ハンドルをしっかり握って…ドライバーの状態をモニタリングするプロジェクト</a></li>
<li><a href="../ja458492/index.html">«Мы всегда верили в конкуренцию и право выбора пользователя» © Яндекс</a></li>
<li><a href="../ja458494/index.html">Vueのレンダリング機能を使用する実用的な例：設計システム用の活版印刷グリッドの作成</a></li>
<li><a href="../ja458496/index.html">大規模なReactアプリケーションを開発するための実用的なガイドライン。計画、アクション、データソース、およびAPI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>