<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏽‍🤝‍🧑🏽 🧘🏻 💻 关于竞争性的白痴症（以反应性编程为例） 🚦 🐰 🐰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1.简介
 在我看来，针对程序员的思想，情绪和愿望的竞争是编程开发的一种现代趋势。当几乎没有提出任何建议时，尽管是为此奋斗的口号。在软件范式的迷恋中很难识别出一些新事物，而事实上，新事物通常是众所周知的，有时甚至已经过时了。许多编程语言中的术语愉悦，冗长的分析和多行示例将一切“洗劫了”。同时，要求开...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>关于竞争性的白痴症（以反应性编程为例）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487720/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.简介</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我看来，针对程序员的思想，情绪和愿望的竞争是编程开发的一种现代趋势。当几乎没有提出任何建议时，尽管是为此奋斗的口号。在软件范式的迷恋中很难识别出一些新事物，而事实上，新事物通常是众所周知的，有时甚至已经过时了。许多编程语言中的术语愉悦，冗长的分析和多行示例将一切“洗劫了”。同时，要求开放和/或考虑解决方案的背景，顽固地避免了创新的本质，试图找出需要多少以及最终将带来什么结果的尝试，这些创新定性地将创新与已知的方法和编程工具区分开来。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
经过一番讨论后，我在哈布雷（Habré）出现，正如其中一次讨论所恰当指出的那样。我什至不介意。至少，显然，印象就是这样。因此，我承认，虽然是我的错，但这只是部分原因。我承认，我依靠上世纪80年代形成的关于并行编程的思想。古代？也许。但是，请告诉我有什么新消息，关于那方面的并行编程科学尚不为人所知（请参阅详细信息[1]）。当时，并行程序分为两类-并行串行和异步。如果前者已经被认为是过时的，那么后者-将会是真正的平行。在后者中，带有事件控制的编程（或仅是事件编程），流控制和动态编程被挑出来。一般而言。已经有更多细节。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了至少40年前已经知道的内容之外，当前的编程还提供什么？在我的“冻僵的表情”中-什么都没有。事实证明，协程现在被称为协程，甚至称为goroutine；并发和竞争这两个术语都变成了昏昏欲睡的人，似乎不仅仅是翻译。而且没有这样的例子。例如，反应式编程（RP）与事件编程或流传输之间有什么区别？它属于哪个已知类别和/或分类？似乎没有人对此感兴趣，也没有人可以澄清这一点。或者您现在可以按名称分类？然后，确实，协程和协程是不同的东西，并且并行编程只是必须不同于竞争程序。那状态机呢？这是什么样的奇迹技术？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
头部中的“意大利面条”源自该理论的遗忘，在该理论中，当引入新模型时，会将其与已知的和经过研究的模型进行比较。</font><font style="vertical-align: inherit;">这样做是否会做得好，但至少您可以弄清楚，因为该过程已正式化。</font><font style="vertical-align: inherit;">但是，如果给协程命名一个新的昵称，然后同时用五种语言选择“引擎罩代码”，那么如何深入了解它，还评估了向流迁移的前景。</font><font style="vertical-align: inherit;">而且，这些只是协程，坦率地说，由于它们的基本性质和较小的用途（当然，这与我的经验有关），应该已经将它们遗忘了。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.反应式编程以及所有，所有，一切</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管我们将以“反应性示例”作为进一步讨论的基础，但我们不会为自己设定透彻理解“反应性编程”概念的目标。</font><font style="vertical-align: inherit;">他的正式模型将在众所周知的正式模型的基础上创建。</font><font style="vertical-align: inherit;">我希望，这将使我们能够清楚，准确，详细地了解原始程序的解释和操作。</font><font style="vertical-align: inherit;">但是，所创建的模型及其实现将是“反应性的”多少取决于这种类型的编程的辩护者来决定。</font><font style="vertical-align: inherit;">目前，新模型将必须实现/建模原始示例的所有细微差别。</font><font style="vertical-align: inherit;">如果没有考虑到某些因素，那么我希望有人能纠正我。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，在[2]中，考虑了一个反应式程序的示例，其代码如清单1所示。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清单1.反应性程序代码</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">1. 1 = 2 <font></font>
2. 2 = 3 <font></font>
3. 3 = 1 + 2 <font></font>
4.  1, 2, 3 <font></font>
5. 1 = 4 <font></font>
6.  1, 2, 3</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在反应式编程领域，其工作结果将与同类常规程序的结果不同。如果不说丑陋，仅此而已是不好的，因为计划的结果应该是明确的，而不取决于执行情况。但是更多的混淆了对方。首先，在外观上几乎不可能将常规相似代码与反应性代码区分开。其次，显然，作者本人并不完全确定反应式程序的工作，而是说结果“最可能”。第三，哪个结果被认为是正确的？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代码解释中的这种歧义导致了这样一个事实，即不可能立即“切入”该代码。</font><font style="vertical-align: inherit;">但是，然后，正如通常发生的那样，一切都变得比预期的要简单得多。</font><font style="vertical-align: inherit;">图1显示了两个结构图，它们希望与该结构相对应并说明示例的操作。</font><font style="vertical-align: inherit;">在上图中，块X1和X2组织数据输入，向块X3发送有关其更改的信号。</font><font style="vertical-align: inherit;">后者执行求和并允许Pr块打印变量的当前值。</font><font style="vertical-align: inherit;">打印后，Pr块将向X3块发出信号，并不仅向他发出信号，而且还向他发出信号，表示他准备打印新值。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。</font><font style="vertical-align: inherit;">1.示例的两个结构模型</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/tw/hs/rq/twhsrqxfdfuyxi4txtd9ciat6hs.jpeg" alt="image"><br>
</div></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与第一种方案相比，第二种方案非常基础。作为单个块的一部分，它输入数据并按顺序实现：1）计算输入数据的总和，以及2）打印它们。没有公开在此呈现级别的块的内部填充。尽管可以说在结构层面上它可以是一个“黑匣子，包括四个区块的方案。但是，他的[算法]装置应该有所不同。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">评论。该程序作为黑匣子的方法实质上反映了用户对其的态度。后者对它的实施不感兴趣，但是对工作的结果感兴趣。无论是响应式程序，事件程序还是其他程序，但是根据算法理论得出的结果都应该是明确且可预测的。</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在图。</font><font style="vertical-align: inherit;">图2给出了详细阐明电路模块内部[算法]结构的算法模型。</font><font style="vertical-align: inherit;">上层模型由自动机网络表示，其中每个自动机是单独块的算法模型。</font><font style="vertical-align: inherit;">虚线圆弧所示的自动机之间的连接对应于电路的连接。</font><font style="vertical-align: inherit;">单自动机模型描述了由一个块组成的框图的操作算法（请参见图1中的另一个Pr块）。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。</font><font style="vertical-align: inherit;">2.结构方案的算法模型</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/rj/4f/ds/rj4fdsx8kekihnbqqebmpji1y9e.jpeg" alt="image"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自动机X1和X2（自动机和块的名称与它们的变量的名称一致），检测更改，如果自动机X3准备执行加法操作（在状态``s0''），则进入状态``s1''，记住变量的当前值。已获得进入状态“ s1”的许可的X3机器执行加法操作，并在必要时等待变量的打印完成。完成打印的“打印机” Pr返回初始状态“ p0”，在此等待下一个命令。请注意，其状态“ p1”开始反向转换链-自动机X3进入状态“ s0”，X1和X2进入状态“ s0”。之后，将对输入数据进行分析，然后对其求和并随后进行打印。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与自动机网络相比，单独的Pr自动机的算法非常简单，但是，我们注意到，它可以完成相同的工作，甚至更快。</font><font style="vertical-align: inherit;">它的谓词揭示了变量的变化。</font><font style="vertical-align: inherit;">如果发生这种情况，则从动作y1的开始执行到状态``p1''的转换（见图2），该动作在记住变量的同时总结变量的当前值。</font><font style="vertical-align: inherit;">然后，在从状态“ p1”到状态“ p0”的无条件转换时，动作y2打印变量。</font><font style="vertical-align: inherit;">之后，处理返回到输入数据的分析。</font><font style="vertical-align: inherit;">清单2显示了最新模型的实现代码。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清单2. Pr自动机的实现</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span>
<span class="hljs-keyword">extern</span> LArc TBL_PlusX3[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FPlusX3</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FPlusX3(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FPlusX3(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_PlusX3, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarY;        		<span class="hljs-comment">// </span>
    CVar *pVarX1;        		<span class="hljs-comment">// </span>
    CVar *pVarX2;        		<span class="hljs-comment">// </span>
    CVar *pVarX3;        		<span class="hljs-comment">// </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//   X1</span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//   X2</span>
    CVar *pVarStrNameX3;		<span class="hljs-comment">//   X3</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };
    <span class="hljs-keyword">double</span> dSaveX1{<span class="hljs-number">0</span>};
    <span class="hljs-keyword">double</span> dSaveX2{<span class="hljs-number">0</span>};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fplusx3.h"</span></span><font></font>
<font></font>
LArc TBL_PlusX3[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x2"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p1"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"--"</span>,  <span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FPlusX3::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"strY"</span>, CLocVar::vtString, <span class="hljs-string">"print of output string"</span>);			<span class="hljs-comment">//  </span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"dX1"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarX2 = CreateLocVar(<span class="hljs-string">"dX2"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarX3 = CreateLocVar(<span class="hljs-string">"dX3"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX3 = CreateLocVar(<span class="hljs-string">"strNameX3"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;<font></font>
    str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    str = pVarStrNameX3-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX3 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPlusX3::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1-&gt;GetDataSrc() != dSaveX1; }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPlusX3::x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX2-&gt;GetDataSrc() != dSaveX2; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FPlusX3::y1</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// X3 = X1 + X2</span>
    <span class="hljs-keyword">double</span> dX1 = pVarX1-&gt;GetDataSrc(); <span class="hljs-keyword">double</span> dX2 = pVarX2-&gt;GetDataSrc();
    <span class="hljs-keyword">double</span> dX3 = dX1 + dX2;<font></font>
    pVarX3-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, dX3);<font></font>
    dSaveX1 = dX1; dSaveX2 = dX2;<font></font>
<span class="hljs-comment">//  1, 2, 3</span><font></font>
    QString strX1; strX1.setNum(dX1); QString strX2; strX2.setNum(dX2);<font></font>
    QString strX3; strX3.setNum(dX3);<font></font>
    QString qstr = <span class="hljs-string">"X1="</span> + strX1 + <span class="hljs-string">", X2="</span> + strX2 + <span class="hljs-string">", X3="</span> + strX3;<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, qstr.toStdString(), <span class="hljs-literal">nullptr</span>);<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代码量显然比原始示例大得多。但是，请注意，不是一个单一的代码。新的解决方案消除了所有功能上的问题，不允许在解释程序时遇到幻想。看起来紧凑而优雅，但是您可以说“最有可能”的示例并不会引起积极的情绪和与之合作的渴望。还应注意，有必要将实际值与自动机y1的作用进行比较。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其余代码与“自动环境”的要求有关，我注意到，在源代码中并未提及。因此，</font><font style="vertical-align: inherit;">基本自动机类</font><i><font style="vertical-align: inherit;">LFsaAppl</font></i><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FCreationOfLinksForVariables</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当在VKPA环境级别指示与它们关联的其他环境变量的符号名称时，为机器创建本地变量并链接到它们。它是在创建自动机时首次启动，然后在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FInit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法的框架内</font><i><font style="vertical-align: inherit;">启动</font></i><font style="vertical-align: inherit;">（请参见步骤y12），因为创建对象时并非所有链接都是已知的。机器将处于“ st”状态，直到初始化x12谓词检查的所有必要链接。如果给定变量名，则返回该变量的GetAddressVar方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了消除可能的问题，我们介绍了自动机网络的代码。</font><font style="vertical-align: inherit;">清单3中显示了它，其中包括三个自动机类的代码。</font><font style="vertical-align: inherit;">以此为基础，创建了许多对象，它们对应于图1中所示的网络结构图。</font><font style="vertical-align: inherit;">1.请注意，对象X1和X2派生自通用类FSynch。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清单3.自动化网络类</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_Synch[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSynch</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dGetData</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX-&gt;GetDataSrc(); };
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FSynch(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FSynch(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Synch, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarX;			<span class="hljs-comment">// </span>
    CVar *pVarStrNameX;		<span class="hljs-comment">//   </span>
    CVar *pVarStrNameObject;<span class="hljs-comment">//  -</span>
    LFsaAppl *pL {<span class="hljs-literal">nullptr</span>};
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX-&gt;GetDataSrc() != dSaveX; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pL-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pL != <span class="hljs-literal">nullptr</span>; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span> </span>{ dSaveX = pVarX-&gt;GetDataSrc(); }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };
    <span class="hljs-keyword">double</span> dSaveX{<span class="hljs-number">0</span>};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
LArc TBL_Synch[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x2"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FSynch::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX = CreateLocVar(<span class="hljs-string">"x"</span>, CLocVar::vtDouble, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameObject = CreateLocVar(<span class="hljs-string">"strNameObject"</span>, CLocVar::vtString, <span class="hljs-string">"name of function"</span>);                   <span class="hljs-comment">//  </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX) {<font></font>
        str = pVarStrNameX-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    str = pVarStrNameObject-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pL = FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_X1X2X3[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FX1X2X3</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dGetData</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX3-&gt;GetDataSrc(); };
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FX1X2X3(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FX1X2X3(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_X1X2X3, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarX1{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarX2{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarX3{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarStrNameFX1;		<span class="hljs-comment">//  X1</span>
    CVar *pVarStrNameFX2;		<span class="hljs-comment">//  X2</span>
    CVar *pVarStrNameFPr;		<span class="hljs-comment">//  Pr</span>
    CVar *pVarStrNameX3;		<span class="hljs-comment">//   </span>
    FSynch *pLX1 {<span class="hljs-literal">nullptr</span>};<font></font>
    FSynch *pLX2 {<span class="hljs-literal">nullptr</span>};<font></font>
    LFsaAppl *pLPr {<span class="hljs-literal">nullptr</span>};
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX1-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX2-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x3</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLPr-&gt;FGetState() == <span class="hljs-string">"p1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLPr != <span class="hljs-literal">nullptr</span> &amp;&amp; pLX1 &amp;&amp; pLX2 &amp;&amp; pVarX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span> </span>{ pVarX3-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, pLX1-&gt;dGetData() + pLX2-&gt;dGetData()); }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };<font></font>
};<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fx1x2x3.h"</span></span><font></font>
<font></font>
LArc TBL_X1X2X3[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x2"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x3"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FX1X2X3::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX3 = CreateLocVar(<span class="hljs-string">"x"</span>, CLocVar::vtDouble, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameFX1 = CreateLocVar(<span class="hljs-string">"strNameFX1"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameFX2 = CreateLocVar(<span class="hljs-string">"strNameFX2"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameFPr = CreateLocVar(<span class="hljs-string">"strNameFPr"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameX3 = CreateLocVar(<span class="hljs-string">"strNameX3"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str; str = pVarStrNameFX1-&gt;strGetDataSrc();
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX1 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX2 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFPr-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLPr = FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_Print[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FX1X2X3</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FPrint</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FPrint(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FPrint(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Print, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarY;        		<span class="hljs-comment">// </span>
    CVar *pVarStrNameFX1;		<span class="hljs-comment">//    X1</span>
    CVar *pVarStrNameFX2;		<span class="hljs-comment">//    X2</span>
    CVar *pVarStrNameFX3;		<span class="hljs-comment">//    X3</span>
    FSynch *pLX1 {<span class="hljs-literal">nullptr</span>};     <span class="hljs-comment">//    X1</span>
    FSynch *pLX2 {<span class="hljs-literal">nullptr</span>};     <span class="hljs-comment">//    X2</span>
    FX1X2X3 *pLX3 {<span class="hljs-literal">nullptr</span>};    <span class="hljs-comment">//    X3</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX3 != <span class="hljs-literal">nullptr</span> &amp;&amp; pLX1 &amp;&amp; pLX2 &amp;&amp; pLX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };<font></font>
};<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fprint.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fx1x2x3.h"</span></span><font></font>
<font></font>
LArc TBL_Print[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p1"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FPrint::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"strY"</span>, CLocVar::vtString, <span class="hljs-string">"print of output string"</span>);			<span class="hljs-comment">//  </span>
    pVarStrNameFX1 = CreateLocVar(<span class="hljs-string">"strNameFX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameFX2 = CreateLocVar(<span class="hljs-string">"strNameFX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameFX3 = CreateLocVar(<span class="hljs-string">"strNameFX3"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(pr)"</span>);			<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;<font></font>
    str = pVarStrNameFX1-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX1 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX2 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX3-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX3 = (FX1X2X3*)FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPrint::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX3-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FPrint::y1</span><span class="hljs-params">()</span> </span>{<font></font>
    QString strX1; strX1.setNum(pLX1-&gt;dGetData());<font></font>
    QString strX2; strX2.setNum(pLX2-&gt;dGetData());<font></font>
    QString strX3; strX3.setNum(pLX3-&gt;dGetData());<font></font>
    QString qstr = <span class="hljs-string">"X1="</span> + strX1 + <span class="hljs-string">", X2="</span> + strX2 + <span class="hljs-string">", X3="</span> + strX3;<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, qstr.toStdString(), <span class="hljs-literal">nullptr</span>);<font></font>
}<font></font>
</code></pre> <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该代码与清单1不同，例如其设计文档中的飞机图片。但是，我认为我们主要是程序员，有些设计师不会告诉他们。我们的“设计代码”应易于理解且明确解释，以使我们的“飞机”不会在首次飞行时坠毁。而且，如果发生了这样的不幸，并且与程序相比，发生这种情况的机会比飞机多得多，那么可以轻松迅速地找到原因。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，考虑清单3，您需要假设类的数量与并行程序中相应对象的数量没有直接关系。该代码不反映对象之间的关系，但是包含创建对象的机制。因此，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSynch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">包含指向</font><font style="vertical-align: inherit;">类型为对象的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指针</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LFsaAppl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。该对象的名称由局部变量确定，该局部变量在VKPa环境中将与名称为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strNameObject</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的自动机变量相对应</font><font style="vertical-align: inherit;">。必须有一个指针才能使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FGetState</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">监视</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSynch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型的自动机对象的当前状态</font><font style="vertical-align: inherit;">（请参阅谓词代码x2）。指向对象的类似指针，用于指定对象名称的变量以及组织关系所必需的谓词包含其他类。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，简单介绍一下VKPA环境中并行程序的“构造”。它是在加载程序配置期间创建的。在这种情况下，第一个对象是根据自动机类型的主题动态库中的类创建的（它们的集合由应用程序/程序的配置确定）。创建的对象由它们的名称标识（我们称它们为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自动变量</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">然后，将必要的值写入自动机的局部变量。</font><font style="vertical-align: inherit;">在我们的例子中，将字符串类型的变量设置为其他对象的变量名称和/或对象的名称。</font><font style="vertical-align: inherit;">这样，在并行自动机程序的对象之间建立了连接（参见图1）。</font><font style="vertical-align: inherit;">此外，更改输入变量的值（使用单个对象控制对话框或标准对话框/环境对话框来设置环境变量的值），我们可以固定结果。</font><font style="vertical-align: inherit;">可以使用标准的环境对话框来显示变量的值。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.对并行程序的分析</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于并行程序的功能，除非非常简单的顺序并行，否则很难说出具体的东西。所考虑的自动机网络也不例外。接下来，我们将看到这一点，了解可以从中得到什么。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生成的自动机和为其构建的网络如图2所示。</font><font style="vertical-align: inherit;">3.从图中的网络。</font><font style="vertical-align: inherit;">如图2所示，除了重命名其元素-自动机，输入和输出信号外，它还以没有变量的“印刷机”为特色。</font><font style="vertical-align: inherit;">后者对于网络的运行不是必需的，重命名使您可以使用合成操作来构建生成的自动机。</font><font style="vertical-align: inherit;">另外，为了创建较短的名称，例如当自动机A的状态“ a0”由符号“ 0”表示，而“ a1”由符号“ 1”表示时，引入了编码。</font><font style="vertical-align: inherit;">其他机器也一样。</font><font style="vertical-align: inherit;">在这种情况下，网络的组件状态（例如“ a1b0c1”）被分配为名称“ 101”。</font><font style="vertical-align: inherit;">类似地，为网络的所有组件状态形成名称，其数量由组件自动机状态的乘积确定。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。</font><font style="vertical-align: inherit;">3.产生的网络自动机</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/a8/oc/9k/a8oc9kfwbbm3apemxhjzpbz5mxw.jpeg" alt="image"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 生成的自动机当然可以以纯粹形式的方式来计算，但是为此，我们需要一个适当的“计算器”。但是，如果不是这样，则可以使用相当简单的直观算法。在其框架内，记录网络的一个或另一种组件状态，然后对所有可能的输入情况进行分类，由“句柄”确定目标组件状态。因此，在固定了与组件自动机的当前状态相对应的状态“ 000”-“ a0”，“ b0”，“ c0”之后，确定了输入变量^ x1 ^ x2，^ x1x2，x1 ^ x2，x1x2的合取的过渡。状态“ a0b0c0”，“ a0b1c0”，“ a1b0c0”，“ a1b1c0”，在生成的机器上分别标记为“ 000”，“ 010”，“ 100”和“ 110”，对于所有可达到的状态，必须依次重复此操作。循环可以从图中排除未加载操作的操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们所拥有的“干残渣中”。我们达到了主要目的-我们收到了自动机，它可以准确地描述网络的运行。我们发现，在八个可能的网络状态中，一个是不可访问的（隔离的）状态-“ 001”。这意味着在任何情况下都不会为未更改当前值的输入变量触发求和操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管测试没有发现错误，但是这令人不安。在生成的自动机图上，发现输出动作中发生冲突的过渡。它们用动作y1y3和y2y3的组合标记。输入数据更改时，将触发动作y1和y2，然后另一个动作y3并行计算变量的总和。它会以什么价值运作-旧的或刚刚被新的改变？为了消除歧义，您可以简单地更改y3和y4的动作。在这种情况下，它们的代码如下：X3 = X1Sav + X2Sav并打印（X1Sav，X2Sav，X3）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所以。</font><font style="vertical-align: inherit;">生成的自动机的构造在创建的并行模型中显示出明显的问题。</font><font style="vertical-align: inherit;">它们是否出现在反应式程序中是一个问题。</font><font style="vertical-align: inherit;">显然，一切都将取决于在反应性范例中实现并行性的方法。</font><font style="vertical-align: inherit;">在任何情况下，都必须考虑并以某种方式消除这种依赖性。</font><font style="vertical-align: inherit;">对于自动网络，保留更改的版本比尝试更改网络更容易。</font><font style="vertical-align: inherit;">可以先打印启动网络操作的“旧”数据，然后再打印当前数据。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4。结论 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所考虑的每个解决方案都有其优点和缺点。最初的非常简单，网络更复杂，并且是在单台机器的基础上创建的，只有在可视化之后，它才会开始分析输入数据。由于其并行性，同一自动网络将在打印过程结束之前开始分析输入数据。而且如果可视化时间很长，但是对于求和运算将是这种情况，那么从输入控制的角度来看，网络将更快。那些。在并行程序的情况下，基于对代码量的估计的评估并不总是客观的。简单来说，网络是并行的，单组件解决方案在很大程度上是顺序的（其谓词和操作是并行的）。首先，我们正在谈论并行程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
网络模型也是灵活解决方案的一个示例。首先，组件可以彼此独立设计。其次，任何组件都可以替换为另一个组件。第三，任何网络组件都可以是自动过程库的元素，并可以在另一个网络解决方案中使用。而这些仅仅是并行解决方案最明显的好处。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是回到反应式编程。 RP是否认为所有程序语句最初都是并行的？我们只能假设没有这个，就很难谈论“面向数据流和变化传播”的编程范式（参见[3]中的反应式编程的定义）。但是，它与使用流控制进行编程有什么区别（有关更多详细信息，请参见[1]）？因此，我们回到开始的地方：如何在知名分类框架内对反应式编程进行分类？而且，如果RP是某种特殊的编程，那么它与已知的编程范例有什么不同？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，关于理论。没有它，并行算法的分析将不仅困难，而且不可能。分析过程有时会发现一些问题，即使对程序进行了仔细和周到的考虑（顺便说一下，在“设计文档”中），也无法猜测。无论如何，我认为飞机无论是具有象征意义还是从其他意义上来说都不会坠毁。这是我的事实，当然，您需要努力争取形式的简洁和优雅，但又不失质量。我们，程序员，不仅是“绘制”程序，而且还经常控制飞机上隐藏的内容！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是的，我差点忘了。我将自动编程（AP）归类为具有动态控制的编程。至于异步-我敢打赌。假设AP控制模型的基础是单一时间的网络，即同步网络的自动机，那么它就是同步的。但是由于VKPa环境还通过“自动机世界”的概念实现了许多网络，因此它是完全异步的。总的来说，我反对任何非常严格的分类框架，但不反对无政府状态。从这个意义上讲，我希望在VKPa中，可以在串行并行编程的刚性和某种异步无政府状态之间达成某种折衷。鉴于自动编程还涵盖事件程序的类（请参见[4]），并且流程序很容易在其中建模，您仍然梦想着什么编程？当然-对我来说。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文献</font></font></b><div class="spoiler_text">1.   /.. , .. , .. , .. ;  . .. . – .:   , 1983. – 240.<br>
2.      . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">habr.com/ru/post/486632</a> . . . (  07.02.2020).<br>
3.  . . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">ru.wikipedia.org/wiki/_</a> . . . (  07.02.2020).<br>
4.  —  ? [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">habr.com/ru/post/483610</a> . . . (  07.02.2020).<br>
</div></div></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN487698/index.html">2月10日至16日在圣彼得堡举行的数字活动</a></li>
<li><a href="../zh-CN487702/index.html">机器学习文章精选：案例研究，指南和2020年1月的研究</a></li>
<li><a href="../zh-CN487704/index.html">我们如何在SSRS 2014上构建动态报告</a></li>
<li><a href="../zh-CN487706/index.html">使用Consul示例的分布式系统中的服务发现。亚历山大·西加切夫（Alexander Sigachev）</a></li>
<li><a href="../zh-CN487716/index.html">完美的SAST。解析器</a></li>
<li><a href="../zh-CN487724/index.html">BlazingPizza：Blazor应用程序从头到尾。第2部分。添加组件</a></li>
<li><a href="../zh-CN487728/index.html">@Pythonetc汇编，2020年1月</a></li>
<li><a href="../zh-CN487730/index.html">自然语言处理。2019年业绩和2020年趋势</a></li>
<li><a href="../zh-CN487734/index.html">加速实体框架核心</a></li>
<li><a href="../zh-CN487738/index.html">SCADA中的模式动画</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>