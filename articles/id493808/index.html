<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏢 🍌 🚤 Melinierisasi kode asinkron dengan corutin 👂 🤦🏻 👋🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selain menggunakan coroutine untuk membuat generator, Anda dapat mencoba menggunakannya untuk membuat linierisasi kode asinkron yang ada. Mari kita co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Melinierisasi kode asinkron dengan corutin</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/493808/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98e/c7c/314/98ec7c314c49b57c2d8af8d53508b211.jpg" alt="gambar"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain menggunakan coroutine untuk membuat generator, Anda dapat mencoba menggunakannya untuk membuat linierisasi kode asinkron yang ada. </font><font style="vertical-align: inherit;">Mari kita coba lakukan ini dengan contoh kecil. </font><font style="vertical-align: inherit;">Ambil kode yang ditulis pada kerangka aktor dan tulis ulang satu fungsi kode ini di coroutine. </font><font style="vertical-align: inherit;">Untuk membangun proyek, kita akan menggunakan gcc dari cabang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coroutines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tujuan kami adalah mendapatkan panggilan balik dari mie:</font></font><br>
<br>
<pre><code class="cpp hljs">    abActor.getA(ABActor::GetACallback([<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
        abActor.getB(ABActor::GetBCallback([a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {<font></font>
            abActor.saveAB(a - b, a + b, ABActor::SaveABCallback([<span class="hljs-keyword">this</span>](){<font></font>
                abActor.getA(ABActor::GetACallback([<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
                    abActor.getB(ABActor::GetBCallback([a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {
                        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
                    }));<font></font>
                }));<font></font>
            }));<font></font>
        }));<font></font>
    }));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semacam:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync();
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync();
<span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync(a - b, a + b);
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newA = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync();
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newB = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync();
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi mari kita mulai.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memulainya, kita perlu membuat kerangka aktor sederhana. </font><font style="vertical-align: inherit;">Membuat kerangka aktor penuh adalah tugas yang sulit dan besar, jadi kami hanya mengimplementasikannya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, buat kelas dasar:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Actor</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> Task = <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>()&gt;;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~Actor();
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Task &amp;task)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tryRunTask</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt;Task&gt; <span class="hljs-built_in">queue</span>;
    <span class="hljs-keyword">mutable</span> <span class="hljs-built_in">std</span>::mutex mutex;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Idenya pada dasarnya sederhana: kami menempatkan tugas yang merupakan objek fungsional dalam antrian, dan ketika kami mencobaRunTask, kami mencoba menyelesaikan tugas ini. </font><font style="vertical-align: inherit;">Implementasi kelas menegaskan niat kami:</font></font><br>
<br>
<pre><code class="cpp hljs">Actor::~Actor() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Actor::addTask</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Task &amp;task)</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>;
    <span class="hljs-built_in">queue</span>.push(task);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Actor::tryRunTask</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>.empty()) {
        <span class="hljs-keyword">return</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">const</span> Task task = <span class="hljs-built_in">queue</span>.front();
    <span class="hljs-built_in">queue</span>.pop();<font></font>
    lock.unlock();<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::invoke(task);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas berikutnya adalah "utas" di mana aktor kita akan berada:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Actor</span>;</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActorThread</span> {</span>
<span class="hljs-keyword">public</span>:<font></font>
    ~ActorThread();<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addActor</span><span class="hljs-params">(Actor &amp;actor)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::reference_wrapper&lt;Actor&gt;&gt; actors;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya juga sederhana di sini: di awal program, kami “mengikat” aktor kami ke utas menggunakan metode addActor, dan kemudian kami memulai utas menggunakan metode jalankan.</font></font><br>
<br>
<pre><code class="cpp hljs">ActorThread::~ActorThread() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ActorThread::addActor</span><span class="hljs-params">(Actor &amp;actor)</span> </span>{<font></font>
    actors.emplace_back(actor);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ActorThread::run</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">for</span> (Actor &amp;actor: actors) {<font></font>
            actor.tryRunTask();<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat memulai utas, kami memasuki loop tak terbatas dan mencoba melakukan satu tugas dari masing-masing aktor. </font><font style="vertical-align: inherit;">Bukan solusi terbaik, tetapi akan dilakukan untuk demonstrasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita lihat perwakilan dari kelas aktor:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABActor</span>:</span> <span class="hljs-keyword">public</span> Actor {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> GetACallback = Callback&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> result)&gt;;
    <span class="hljs-keyword">using</span> GetBCallback = Callback&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> result)&gt;;
    <span class="hljs-keyword">using</span> SaveABCallback = Callback&lt;<span class="hljs-keyword">void</span>()&gt;;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getA</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetACallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getB</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetBCallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveAB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> SaveABCallback &amp;callback)</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getAProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetACallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getBProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetBCallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveABProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> SaveABCallback &amp;callback)</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas ini menyimpan 2 angka dalam dirinya sendiri - a dan b, dan, atas permintaan, mengembalikan nilai mereka atau menimpanya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai panggilan balik, ia menerima objek fungsional dengan parameter yang diperlukan. </font><font style="vertical-align: inherit;">Tapi mari kita perhatikan fakta bahwa aktor yang berbeda dapat diluncurkan di utas yang berbeda. </font><font style="vertical-align: inherit;">Dan oleh karena itu, jika pada akhir pekerjaan kami hanya memanggil callback yang diteruskan ke metode, panggilan balik ini akan dipanggil di utas yang dapat dieksekusi saat ini, dan bukan di utas yang memanggil metode kami dan membuat panggilan balik ini. </font><font style="vertical-align: inherit;">Karena itu, kita perlu membuat pembungkus atas callback yang akan menyelesaikan situasi ini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Callback</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Functor&gt;
    <span class="hljs-title">Callback</span><span class="hljs-params">(Actor &amp;sender, <span class="hljs-keyword">const</span> Functor &amp;callback)</span>
        : <span class="hljs-title">sender</span><span class="hljs-params">(sender)</span>
        , <span class="hljs-title">callback</span><span class="hljs-params">(callback)</span>
    </span>{}
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Args&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(Args&amp;&amp; ...args)</span> <span class="hljs-keyword">const</span> </span>{<font></font>
        sender.addTask(<span class="hljs-built_in">std</span>::bind(callback, <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...));<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:<font></font>
    Actor &amp;sender;<font></font>
    <span class="hljs-built_in">std</span>::function&lt;C&gt; callback;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wrapper ini mengingat aktor asli, dan ketika Anda mencoba mengeksekusi diri Anda sendiri, ia hanya menambahkan panggilan balik nyata ke antrian tugas aktor asli. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akibatnya, implementasi kelas ABActor terlihat seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getA</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetACallback &amp;callback)</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getAProcess, <span class="hljs-keyword">this</span>, callback));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getAProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ABActor::GetACallback &amp;callback)</span> </span>{
    <span class="hljs-built_in">std</span>::invoke(callback, a);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getB</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetBCallback &amp;callback)</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getBProcess, <span class="hljs-keyword">this</span>, callback));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getBProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ABActor::GetBCallback &amp;callback)</span> </span>{
    <span class="hljs-built_in">std</span>::invoke(callback, b);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::saveAB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> SaveABCallback &amp;callback)</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::saveABProcess, <span class="hljs-keyword">this</span>, a, b, callback));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::saveABProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> ABActor::SaveABCallback &amp;callback)</span> </span>{
    <span class="hljs-keyword">this</span>-&gt;a = a;
    <span class="hljs-keyword">this</span>-&gt;b = b;
    <span class="hljs-built_in">std</span>::invoke(callback);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam metode antarmuka kelas, kami hanya mengikat argumen yang diteruskan ke "slot" yang sesuai kelas, sehingga membuat tugas, dan menempatkan tugas ini dalam antrian tugas kelas ini. </font><font style="vertical-align: inherit;">Ketika utas tugas mulai melakukan tugas, dengan demikian ia akan memanggil "slot" yang benar, yang akan melakukan semua tindakan yang diperlukan dan memanggil panggilan balik, yang pada gilirannya akan mengirim panggilan balik nyata ke antrian tugas yang menyebabkannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita menulis aktor yang akan menggunakan kelas ABActor:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABActor</span>;</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WokrerActor</span>:</span> <span class="hljs-keyword">public</span> Actor {
<span class="hljs-keyword">public</span>:<font></font>
    WokrerActor(ABActor &amp;actor)<font></font>
        : abActor(actor)<font></font>
    {}<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">workProcess</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:<font></font>
    ABActor &amp;abActor;<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::work</span><span class="hljs-params">()</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;WokrerActor::workProcess, <span class="hljs-keyword">this</span>));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workProcess</span><span class="hljs-params">()</span> </span>{<font></font>
    abActor.getA(ABActor::GetACallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    }));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan kumpulkan semuanya:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<font></font>
    ABActor abActor;<font></font>
    <span class="hljs-function">WokrerActor <span class="hljs-title">workerActor</span><span class="hljs-params">(abActor)</span></span>;<font></font>
<font></font>
    ActorThread thread;<font></font>
    thread.addActor(abActor);<font></font>
    thread.addActor(workerActor);<font></font>
<font></font>
    workerActor.work();<font></font>
<font></font>
    thread.run();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita ikuti seluruh rantai kode. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada awalnya, kami membuat objek yang diperlukan dan membangun koneksi di antara mereka. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian kita menambahkan tugas workProcess ke antrian tugas Worker aktor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika utas dimulai, ia akan menemukan tugas kami dalam antrian dan mulai melaksanakannya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam proses eksekusi, kami memanggil metode getA dari kelas ABActor, dengan demikian menempatkan tugas yang sesuai dalam antrian kelas ABActor, dan menyelesaikan eksekusi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, utas akan mengambil tugas yang baru dibuat dari kelas ABActor dan menjalankannya, yang akan mengarah pada pelaksanaan kode getAProcess.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode ini akan memanggil panggilan balik, meneruskan argumen yang diperlukan ke dalamnya - variabel a. Tetapi karena panggilan balik yang ia miliki adalah pembungkus, pada kenyataannya, panggilan balik nyata dengan parameter yang diisi akan dimasukkan ke dalam antrian kelas Pekerja. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan ketika, pada iterasi siklus berikutnya, utas menarik dan mengeksekusi panggilan balik kita dari kelas Pekerja, kita akan melihat output dari baris “Hasil 10”</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kerangka kerja aktor adalah cara yang cukup mudah untuk berinteraksi kelas yang tersebar di aliran fisik yang berbeda satu sama lain. Keunikan desain kelas, seperti yang seharusnya Anda yakini, adalah bahwa dalam setiap aktor individu semua tindakan dilakukan sepenuhnya dan dalam satu utas. Satu-satunya titik sinkronisasi stream dibuat dalam detail implementasi kerangka aktor dan tidak terlihat oleh programmer. Dengan demikian, seorang programmer dapat menulis kode single-threaded tanpa khawatir tentang membungkus mutex dan melacak situasi balapan, kebuntuan dan sakit kepala lainnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sayangnya, solusi ini ada harganya. Karena hasil mengeksekusi aktor lain hanya dapat diakses dari callback, cepat atau lambat kode aktor berubah menjadi seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs">    abActor.getA(ABActor::GetACallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
        abActor.getB(ABActor::GetBCallback(*<span class="hljs-keyword">this</span>, [a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {<font></font>
            abActor.saveAB(a - b, a + b, ABActor::SaveABCallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](){<font></font>
                abActor.getA(ABActor::GetACallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
                    abActor.getB(ABActor::GetBCallback(*<span class="hljs-keyword">this</span>, [a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {
                        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
                    }));<font></font>
                }));<font></font>
            }));<font></font>
        }));<font></font>
    }));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat apakah kita dapat menghindari ini menggunakan inovasi C ++ 20 - coroutine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi pertama-tama, kami akan menentukan batasannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara alami, kita sama sekali tidak dapat mengubah kode kerangka aktor. </font><font style="vertical-align: inherit;">Selain itu, kami tidak dapat mengubah tanda tangan metode publik dan pribadi untuk instance dari kelas Aktor - ABActor dan WorkerActor. </font><font style="vertical-align: inherit;">Mari kita lihat apakah kita bisa keluar dari situasi ini.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutine. </font><font style="vertical-align: inherit;">Bagian 1. Penunggu</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gagasan utama corutin adalah bahwa ketika membuat coroutine, frame stack terpisah dibuat untuk itu di heap, dari mana kita dapat "keluar" kapan saja, sambil mempertahankan posisi eksekusi saat ini, register prosesor dan informasi lain yang diperlukan. Kemudian kita juga dapat kapan saja kembali ke eksekusi coroutine yang ditangguhkan dan menyelesaikannya sampai akhir atau sampai suspensi berikutnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objek std :: coroutine_handle &lt;&gt; bertanggung jawab untuk mengelola data ini, yang pada dasarnya mewakili sebuah pointer ke frame stack (dan data lain yang diperlukan), dan yang memiliki metode resume (atau analognya, operator ()), yang mengembalikan kita ke eksekusi coroutine . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berdasarkan data ini, pertama mari kita menulis fungsi getAAsync, dan kemudian mencoba untuk menggeneralisasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, misalkan kita sudah memiliki instance dari kelas std :: coroutine_handle &lt;&gt; coro, apa yang perlu kita lakukan? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda harus memanggil metode yang sudah ada ABActor :: getA, yang akan menyelesaikan situasi sesuai kebutuhan, tetapi pertama-tama Anda harus membuat panggilan balik untuk metode getA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita ingat bahwa panggilan balik dikembalikan ke metode panggilan balik getA - hasil dari metode getA. Selain itu, panggilan balik ini disebut dalam utas Pekerja utas. Dengan demikian, dari panggilan balik ini, kita dapat dengan aman melanjutkan menjalankan coroutine, yang dibuat hanya dari utas Pekerja dan yang akan terus melakukan urutan tindakannya. Tetapi juga, kita harus di suatu tempat menyimpan hasil yang dikembalikan dalam panggilan balik, itu, tentu saja, akan berguna bagi kita lebih lanjut.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> callback = GetACallback(returnCallbackActor, [&amp;value, coro](<span class="hljs-keyword">int</span> result) {<font></font>
        value = result;<font></font>
        <span class="hljs-built_in">std</span>::invoke(coro);<font></font>
 });<font></font>
getA(callback);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, sekarang Anda perlu mengambil contoh objek coroutine_handle dari suatu tempat dan tautan tempat Anda dapat menyimpan hasil kami. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di masa depan, kita akan melihat bahwa coroutine_handle diberikan kepada kita sebagai akibat dari memanggil fungsi. </font><font style="vertical-align: inherit;">Dengan demikian, yang bisa kita lakukan dengannya adalah meneruskannya ke beberapa fungsi lain. </font><font style="vertical-align: inherit;">Mari kita siapkan fungsi ini sebagai lambda. </font><font style="vertical-align: inherit;">(Kami akan meneruskan tautan ke variabel tempat hasil panggilan balik akan disimpan ke perusahaan).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> storeCoroToQueue = [&amp;returnCallbackActor, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">auto</span> &amp;value, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro) {
    <span class="hljs-keyword">auto</span> callback=GetACallback(returnCallbackActor, [&amp;value, coro](<span class="hljs-keyword">int</span> result){<font></font>
        value = result;<font></font>
        <span class="hljs-built_in">std</span>::invoke(coro);<font></font>
    });<font></font>
    getA(callback);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan menyimpan fungsi ini di kelas berikutnya.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ActorAwaiterSimple</span> {</span>
    <span class="hljs-keyword">int</span> value;<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> &amp;value,<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; forwardCoroToCallback;<font></font>
<font></font>
    ActorAwaiterSimple(<font></font>
        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> &amp;value, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; &amp;forwardCoroToCallback<font></font>
    )<font></font>
        : forwardCoroToCallback(forwardCoroToCallback)<font></font>
    {}<font></font>
<font></font>
    ActorAwaiterSimple(<span class="hljs-keyword">const</span> ActorAwaiterSimple &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiterSimple&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> ActorAwaiterSimple &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiterSimple(ActorAwaiterSimple &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiterSimple&amp; <span class="hljs-keyword">operator</span>=(ActorAwaiterSimple &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
<span class="hljs-comment">// ...</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain objek fungsional, kami juga akan menahan di sini memori (dalam bentuk nilai variabel) untuk nilai yang menunggu kami di callback. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena kami memegang memori di bawah nilai di sini, kami tidak ingin instance kelas ini disalin atau dipindahkan ke suatu tempat. Bayangkan, misalnya, seseorang menyalin kelas ini, menyimpan nilai di bawah variabel nilai di instance kelas yang lama, dan kemudian mencoba membacanya dari instance baru. Dan tentu saja tidak ada di sana, karena penyalinan terjadi sebelum menyimpan. Tidak menyenangkan. Oleh karena itu, kami melindungi diri dari masalah ini dengan melarang konstruktor dan menyalin dan memindahkan operator. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lanjutkan menulis kelas ini. Metode selanjutnya yang kita butuhkan adalah:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dia menjawab pertanyaan apakah makna kita siap untuk dikeluarkan. </font><font style="vertical-align: inherit;">Secara alami, pada panggilan pertama, nilai kami belum siap, dan di masa depan tidak ada yang akan bertanya kepada kami tentang hal ini, jadi kembalikan saja salah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh coroutine_handle akan dikirimkan kepada kami dalam metode void await_suspend (std :: coroutine_handle &lt;&gt; coro), jadi mari kita panggil functor kami yang sudah siap di dalamnya, lewat di sana juga ada tautan memori di bawah nilai:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro)</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-built_in">std</span>::invoke(forwardCoroToCallback, <span class="hljs-built_in">std</span>::ref(value), coro);<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasil dari eksekusi fungsi akan ditanyakan pada waktu yang tepat dengan memanggil metode await_resume. </font><font style="vertical-align: inherit;">Kami tidak akan menolak pemohon:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-keyword">return</span> value;<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang metode kami dapat dipanggil menggunakan kata kunci co_await:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang akan terjadi di sini, kami sudah mewakili secara kasar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, objek bertipe ActorAwaiterSimple akan dibuat, yang akan ditransfer ke "input" dari co_await. Dia pertama-tama akan bertanya (dengan menelepon await_ready) apakah kita secara tidak sengaja memiliki hasil yang selesai (kita tidak punya), kemudian memanggil await_suspend, meneruskan dalam konteks (pada kenyataannya, sebuah penunjuk ke kerangka tumpukan coroutine saat ini) dan menghentikan eksekusi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di masa depan, ketika aktor ABActor menyelesaikan pekerjaannya dan memanggil panggilan balik hasil, hasil ini (sudah ada di utas thread Pekerja) akan disimpan dalam satu-satunya (sisa pada tumpukan coroutine) dari ActorAwaiterSimple contoh dan kelanjutan dari coroutine akan dimulai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Corutin akan melanjutkan eksekusi, mengambil hasil yang disimpan dengan memanggil metode await_resume, dan meneruskan hasil ini ke variabel a</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat ini, batasan dari Awaiter saat ini adalah bahwa ia hanya dapat bekerja dengan callback dengan satu parameter tipe int. </font><font style="vertical-align: inherit;">Mari kita coba untuk memperluas aplikasi Awaiter:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ActorAwaiter</span> {</span><font></font>
<font></font>
    <span class="hljs-built_in">std</span>::tuple&lt;T...&gt; values;<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-built_in">std</span>::tuple&lt;T...&gt; &amp;values, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; storeHandler;<font></font>
<font></font>
    ActorAwaiter(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-built_in">std</span>::tuple&lt;T...&gt; &amp;values, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; &amp;storeHandler)<font></font>
        : storeHandler(storeHandler)<font></font>
    {}<font></font>
<font></font>
    ActorAwaiter(<span class="hljs-keyword">const</span> ActorAwaiter &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiter&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> ActorAwaiter &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiter(ActorAwaiter &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiter&amp; <span class="hljs-keyword">operator</span>=(ActorAwaiter &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro)</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-built_in">std</span>::invoke(storeHandler, <span class="hljs-built_in">std</span>::ref(values), coro);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//   bool B  ,</span>
    <span class="hljs-comment">//   sfinae      </span>
    <span class="hljs-keyword">template</span>&lt;
        <span class="hljs-keyword">bool</span> B=<span class="hljs-literal">true</span>,<span class="hljs-keyword">size_t</span> len=<span class="hljs-keyword">sizeof</span>...(T),<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;len==<span class="hljs-number">0</span> &amp;&amp; B, <span class="hljs-keyword">int</span>&gt;=<span class="hljs-number">0</span><font></font>
    &gt;<font></font>
    <span class="hljs-keyword">void</span> await_resume() <span class="hljs-keyword">noexcept</span> {<font></font>
<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//   bool B  ,</span>
    <span class="hljs-comment">//   sfinae      </span>
    <span class="hljs-keyword">template</span>&lt;
        <span class="hljs-keyword">bool</span> B=<span class="hljs-literal">true</span>,<span class="hljs-keyword">size_t</span> len=<span class="hljs-keyword">sizeof</span>...(T),<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;len==<span class="hljs-number">1</span> &amp;&amp; B, <span class="hljs-keyword">int</span>&gt;=<span class="hljs-number">0</span><font></font>
    &gt;<font></font>
    <span class="hljs-keyword">auto</span> await_resume() <span class="hljs-keyword">noexcept</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">0</span>&gt;(values);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//   bool B  ,</span>
    <span class="hljs-comment">//   sfinae      </span>
    <span class="hljs-keyword">template</span>&lt;
        <span class="hljs-keyword">bool</span> B=<span class="hljs-literal">true</span>,<span class="hljs-keyword">size_t</span> len=<span class="hljs-keyword">sizeof</span>...(T),<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;len!=<span class="hljs-number">1</span> &amp;&amp; len!=<span class="hljs-number">0</span> &amp;&amp; B, <span class="hljs-keyword">int</span>&gt;=<span class="hljs-number">0</span><font></font>
    &gt;<font></font>
    <span class="hljs-built_in">std</span>::tuple&lt;T...&gt; await_resume() <span class="hljs-keyword">noexcept</span> {
        <span class="hljs-keyword">return</span> values;<font></font>
    }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita menggunakan std :: tuple untuk dapat menyimpan beberapa variabel sekaligus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sfinae dikenakan pada metode await_resume sehingga dimungkinkan untuk tidak mengembalikan tuple dalam semua kasus, tetapi bergantung pada jumlah nilai yang terletak di tuple, mengembalikan batal, tepat 1 argumen atau seluruh tupel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pembungkus untuk membuat Awaiter sendiri sekarang terlihat seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> MakeCallback, <span class="hljs-keyword">typename</span>... ReturnArgs, <span class="hljs-keyword">typename</span> Func&gt;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">makeCoroCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Func &amp;func, Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">return</span> [&amp;returnCallback, func](<span class="hljs-keyword">auto</span> &amp;values, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro) {
        <span class="hljs-keyword">auto</span> callback = MakeCallback(returnCallback, [&amp;values, coro](ReturnArgs&amp;&amp; ...result) {<font></font>
            values = <span class="hljs-built_in">std</span>::make_tuple(<span class="hljs-built_in">std</span>::forward&lt;ReturnArgs&gt;(result)...);
            <span class="hljs-built_in">std</span>::invoke(coro);<font></font>
        });<font></font>
        func(callback);<font></font>
    };<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> MakeCallback, <span class="hljs-keyword">typename</span>... ReturnArgs, <span class="hljs-keyword">typename</span> Func&gt;
<span class="hljs-keyword">static</span> ActorAwaiter&lt;ReturnArgs...&gt; <span class="hljs-title">makeActorAwaiter</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Func &amp;func, Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> storeCoroToQueue = makeCoroCallback&lt;MakeCallback, ReturnArgs...&gt;(func, returnCallback);
    <span class="hljs-keyword">return</span> ActorAwaiter&lt;ReturnArgs...&gt;(storeCoroToQueue);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ActorAwaiter&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ABActor::getAAsync</span><span class="hljs-params">(Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">return</span> makeActorAwaiter&lt;GetACallback, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getA, <span class="hljs-keyword">this</span>, _1), returnCallback);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ActorAwaiter&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ABActor::getBAsync</span><span class="hljs-params">(Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">return</span> makeActorAwaiter&lt;GetBCallback, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getB, <span class="hljs-keyword">this</span>, _1), returnCallback);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ActorAwaiter&lt;&gt; <span class="hljs-title">ABActor::saveABAsync</span><span class="hljs-params">(Actor &amp;returnCallback, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> makeActorAwaiter&lt;SaveABCallback&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::saveAB, <span class="hljs-keyword">this</span>, a, b, _1), returnCallback);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita cari tahu cara menggunakan tipe yang dibuat secara langsung di coroutine.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutine. </font><font style="vertical-align: inherit;">Bagian 2. Resumable</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari sudut pandang C ++, fungsi yang berisi kata-kata co_await, co_yield atau co_return dianggap sebagai coroutine. Tetapi juga fungsi seperti itu harus mengembalikan tipe tertentu. Kami sepakat bahwa kami tidak akan mengubah tanda tangan dari fungsi-fungsi (di sini saya maksudkan bahwa tipe pengembalian juga mengacu pada tanda tangan), jadi kami harus keluar darinya entah bagaimana caranya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita membuat coroutine lambda dan menyebutnya dari fungsi kita:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workProcess</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> coroutine = [](WokrerActor &amp;actor) -&gt; ActorResumable {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync(actor, a - b, a + b);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newA = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newB = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
<font></font>
    coroutine(*<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Mengapa tidak menangkap ini dalam daftar penangkapan lambda? Maka semua kode di dalamnya akan keluar sedikit lebih mudah. ​​Tetapi kebetulan, tampaknya, lambda-coroutine di kompiler belum sepenuhnya didukung, sehingga kode ini tidak akan berfungsi.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, kami kode panggilan balik menakutkan sekarang telah berubah menjadi kode linier yang cukup bagus. </font><font style="vertical-align: inherit;">Yang tersisa bagi kita adalah menciptakan kelas ActorResumable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ActorResumable</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">promise_type</span> {</span>
        <span class="hljs-keyword">using</span> coro_handle = <span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt;;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>{ 
            <span class="hljs-comment">//  ,    ActorResumable   promise_type</span>
            <span class="hljs-keyword">return</span> coro_handle::from_promise(*<span class="hljs-keyword">this</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">//      </span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::suspend_never();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">//      . </span>
            <span class="hljs-comment">// ,     </span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::suspend_never();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">//   ,       </span>
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">terminate</span>();<font></font>
        }<font></font>
    };<font></font>
<font></font>
    ActorResumable(<span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt;) {}<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode pseudocor corutin yang dihasilkan dari lambda kami terlihat seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">ActorResumable <span class="hljs-title">coro</span><span class="hljs-params">()</span> </span>{<font></font>
    promise_type promise;<font></font>
    ActorResumable retobj = promise.get_return_object();<font></font>
    <span class="hljs-keyword">auto</span> intial_suspend = promise.initial_suspend();
    <span class="hljs-keyword">if</span> (initial_suspend == <span class="hljs-built_in">std</span>::suspend_always)  {
          <span class="hljs-comment">// yield</span><font></font>
    }<font></font>
    <span class="hljs-keyword">try</span> { 
        <span class="hljs-comment">//  .</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    } <span class="hljs-keyword">catch</span>(...) { <font></font>
        promise.unhandled_exception();<font></font>
    }<font></font>
final_suspend:<font></font>
    <span class="hljs-keyword">auto</span> final_suspend = promise.final_suspend();
    <span class="hljs-keyword">if</span> (final_suspend == <span class="hljs-built_in">std</span>::suspend_always)  {
         <span class="hljs-comment">// yield</span>
    } <span class="hljs-keyword">else</span> {<font></font>
         cleanup();<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini hanya kode semu, beberapa hal sengaja disederhanakan. </font><font style="vertical-align: inherit;">Meskipun demikian, mari kita lihat apa yang terjadi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama kita buat janji dan ActorResumable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah initial_suspend () kami tidak berhenti, tetapi beralih. </font><font style="vertical-align: inherit;">Kami mulai melaksanakan bagian utama dari program ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika kita sampai pada co_await, kita memahami bahwa kita perlu berhenti sebentar. </font><font style="vertical-align: inherit;">Kami telah memeriksa situasi ini di bagian sebelumnya, Anda dapat kembali ke situ dan memeriksanya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah kami melanjutkan eksekusi dan menampilkan hasilnya di layar, eksekusi coroutine berakhir. </font><font style="vertical-align: inherit;">Kami memeriksa final_suspend, dan menghapus seluruh konteks coroutine.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutine. </font><font style="vertical-align: inherit;">Bagian 3. Tugas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita ingat tahap apa yang sekarang kita capai.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workProcess</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> coroutine = [](WokrerActor &amp;actor) -&gt; ActorResumable {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync(actor, a - b, a + b);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newA = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newB = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
<font></font>
    coroutine(*<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu terlihat bagus, tetapi mudah untuk melihat bahwa kodenya:</font></font><br>
<br>
<pre><code class="cpp hljs">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
diulang 2 kali. </font><font style="vertical-align: inherit;">Apakah mungkin untuk memperbaiki momen ini dan memasukkannya ke dalam fungsi yang terpisah? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita gambarkan bagaimana tampilannya:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">CoroTask&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">WokrerActor::readAB</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> abActor.getAAsync2(*<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> abActor.getBAsync2(*<span class="hljs-keyword">this</span>);
    <span class="hljs-function"><span class="hljs-keyword">co_return</span> <span class="hljs-title">std::make_pair</span><span class="hljs-params">(a, b)</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workCoroProcess</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> coroutine = [](WokrerActor &amp;actor) -&gt; ActorResumable {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> [a, b] = <span class="hljs-keyword">co_await</span> actor.readAB();
        <span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync2(actor, a - b, a + b);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> [newA, newB] = <span class="hljs-keyword">co_await</span> actor.readAB();
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
<font></font>
    coroutine(*<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang tersisa bagi kita adalah menciptakan tipe CoroTask. </font><font style="vertical-align: inherit;">Mari kita pikirkan. </font><font style="vertical-align: inherit;">Pertama, co_return digunakan di dalam fungsi readAB, yang berarti CoroTask harus memenuhi antarmuka Resumable. </font><font style="vertical-align: inherit;">Tetapi juga, objek kelas ini digunakan untuk memasukkan co_await dari coroutine lain. </font><font style="vertical-align: inherit;">Ini berarti bahwa kelas CoroTask juga harus memenuhi antarmuka yang ditunggu-tunggu. </font><font style="vertical-align: inherit;">Mari kita terapkan kedua antarmuka ini di kelas CoroTask:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-keyword">void</span>&gt;<font></font>
struct CoroTask {<font></font>
    struct promise_type {<font></font>
        T result;<font></font>
        <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; waiter;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> CoroTask{*<span class="hljs-keyword">this</span>};<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">return_value</span><span class="hljs-params">(T value)</span> </span>{<font></font>
            result = value;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">terminate</span>();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-built_in">std</span>::suspend_always <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> {};<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">final_awaiter</span> {</span>
                <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>{}
                <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt; me)</span> </span>{
                    <span class="hljs-keyword">return</span> me.promise().waiter;<font></font>
                }<font></font>
            };<font></font>
            <span class="hljs-keyword">return</span> final_awaiter{};<font></font>
        }<font></font>
    };<font></font>
<font></font>
    CoroTask(CoroTask &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    CoroTask&amp; <span class="hljs-keyword">operator</span>=(CoroTask&amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    CoroTask(<span class="hljs-keyword">const</span> CoroTask&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    CoroTask&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> CoroTask&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
    ~CoroTask() {<font></font>
        <span class="hljs-keyword">if</span> (h) {<font></font>
            h.destroy();<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">CoroTask</span><span class="hljs-params">(promise_type &amp; p)</span>
        : <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt;::from_promise(p))</span>
    </span>{}<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">T <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">auto</span> &amp;result = h.promise().result;
        <span class="hljs-keyword">return</span> result;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; waiter)</span> </span>{<font></font>
        h.promise().waiter = waiter;<font></font>
        h.resume();<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt; h;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Saya sangat menyarankan membuka gambar latar belakang posting ini. Di masa depan, ini akan sangat membantu Anda.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, mari kita lihat apa yang terjadi di sini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Pergi ke coroutine lambda dan segera buat WokrerActor :: readAB coroutine. Tetapi setelah membuat coroutine ini, kami tidak mulai menjalankannya (initial_suspend == suspend_always), yang memaksa kami untuk menyela dan kembali ke coroutine lambda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. co_await lambda memeriksa untuk melihat apakah readAB siap. Hasilnya tidak siap (await_ready == false), yang memaksanya meneruskan konteksnya ke metode CoroTask :: await_suspend. Konteks ini disimpan di CoroTask, dan resume dari readAB </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3 </font><font style="vertical-align: inherit;">coroutine diluncurkan </font><font style="vertical-align: inherit;">. Setelah readAB coroutine telah menyelesaikan semua tindakan yang diperlukan, ia mencapai baris:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">co_return</span> <span class="hljs-title">std::make_pair</span><span class="hljs-params">(a, b)</span></span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sebagai hasilnya, metode CoroTask :: janji_type :: return_value dipanggil dan pasangan angka yang dibuat disimpan di dalam CoroTask :: janji_type </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. Karena metode co_return dipanggil, eksekusi coroutine berakhir, yang berarti saatnya memanggil metode CoroTask :: janji_type :: final_suspend . Metode ini mengembalikan struktur yang ditulis sendiri (jangan lupa untuk melihat gambar), yang memaksa Anda untuk memanggil metode final_awaiter :: await_suspend, yang mengembalikan konteks lambda coroutine yang disimpan dalam langkah 2.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa kami tidak bisa mengembalikan suspend_always saja di sini? Lagipula, dalam kasus initial_suspend kelas ini, apakah kita berhasil? Faktanya adalah bahwa pada initial_suspend kami berhasil karena coroutine ini dipanggil oleh lambda coroutine kami, dan kami kembali ke sana. Tetapi pada saat kami mencapai panggilan final_suspend, coroutine kami kemungkinan besar berlanjut dari tumpukan lain (khususnya, dari lambda yang disiapkan oleh fungsi makeCoroCallback), dan jika kami mengembalikan suspend_always di sini, kami akan kembali ke sana, dan tidak ke metode workCoroProcess. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5. Karena metode final_awaiter :: await_suspend mengembalikan konteks kepada kami, ini memaksa program untuk terus mengeksekusi konteks yang dikembalikan, yaitu, coroutine lambda. Karena eksekusi kembali ke titik:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> [a, b] = <span class="hljs-keyword">co_await</span> actor.readAB();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
maka kita perlu mengisolasi hasil yang disimpan dengan memanggil metode CoroTask :: await_resume. Hasilnya diterima, diteruskan ke variabel a dan b, dan sekarang instance CoroTask dihancurkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6. Contoh CoroTask dihancurkan, tetapi apa yang terjadi pada konteks WokrerActor :: readAB? Jika kita dari CoroTask :: janji_type :: final_suspend akan mengembalikan suspend_never (lebih tepatnya, akan mengembalikannya ke pertanyaan await_ready akan kembali benar), maka pada saat itu konteks coroutine akan dibersihkan. Tetapi karena kami tidak melakukannya, kewajiban untuk menghapus konteks dialihkan kepada kami. Kami akan menghapus konteks ini di destruktor CoroTask, pada titik ini sudah aman. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7. Bacaan coroutine dijalankan, hasilnya diperoleh dari itu, konteksnya dihapus, lambda coroutine terus berjalan ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fiuh, semacam mengatasinya. </font><font style="vertical-align: inherit;">Apakah Anda ingat bahwa dari metode ABActor :: getAAsync () dan sejenisnya, kami mengembalikan struktur yang ditulis sendiri? </font><font style="vertical-align: inherit;">Bahkan, metode getAAsync juga dapat diubah menjadi coroutine dengan menggabungkan pengetahuan yang diperoleh dari implementasi kelas CoroTask dan ActorAwaiter dan mendapatkan sesuatu seperti:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">CoroTaskActor&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ABActor::getAAsync</span><span class="hljs-params">(Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">co_return</span> makeCoroCallback&lt;GetACallback, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getA, <span class="hljs-keyword">this</span>, _1), returnCallback);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tetapi ini saya akan pergi untuk analisis diri.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temuan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, dengan bantuan coroutine, Anda dapat dengan baik mem-linearkan kode panggilan balik yang tidak sinkron. </font><font style="vertical-align: inherit;">Benar, proses penulisan jenis dan fungsi tambahan sepertinya belum terlalu intuitif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua kode tersedia di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositori. Saya</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
juga menyarankan Anda melihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kuliah ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk perendaman yang lebih lengkap dalam topik ini </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejumlah besar contoh tentang topik coroutine dari penulis yang sama ada di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan Anda juga bisa menonton </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">kuliah</font></a><font style="vertical-align: inherit;"> ini </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id493796/index.html">4 pola desain terbaik untuk pengujian otomatis (dan 86 lainnya)</a></li>
<li><a href="../id493798/index.html">Tidak ada desain di 1C UX / UI</a></li>
<li><a href="../id493800/index.html">Peluang empiris</a></li>
<li><a href="../id493802/index.html">Memahami launchMode Android Activity: standard, singleTop, singleTask dan singleInstance</a></li>
<li><a href="../id493804/index.html">Pemain yang berbicara di raspberry</a></li>
<li><a href="../id493810/index.html">Lima tahun pengembangan intensif pasar untuk pengenalan dokumen</a></li>
<li><a href="../id493814/index.html">Bagaimana kami melakukan wawancara di Barcelona</a></li>
<li><a href="../id493816/index.html">Panduan Git Bagian nomor 1: semua yang perlu Anda ketahui tentang direktori .git</a></li>
<li><a href="../id493818/index.html">Panduan Git Bagian nomor 2: aturan emas dan dasar-dasar rebase lainnya</a></li>
<li><a href="../id493820/index.html">Kubernet memuat load balancing dan menskalakan koneksi yang berumur panjang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>