<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💳 🍛 ✈️ 与环境对象创建简单的AI交互 ⚜️ 😇 🕰️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在为视频游戏创建人工智能时，最重要的方面之一就是它的位置。 AI角色的位置可以完全改变他的行为类型和未来的决策。在本教程中，我们将了解游戏环境如何影响AI以及如何正确使用AI。
 
 本文摘自Michael Dagrack撰写并由Packt Publishing出版的《Practical Game ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>与环境对象创建简单的AI交互</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496080/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b5/840/cec/6b5840cec8e3b42adad879472c47930d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在为视频游戏创建人工智能时，最重要的方面之一就是它的位置。 AI角色的位置可以完全改变他的行为类型和未来的决策。在本教程中，我们将了解游戏环境如何影响AI以及如何正确使用AI。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文摘自</font><font style="vertical-align: inherit;">Michael Dagrack撰写并由Packt Publishing出版</font><font style="vertical-align: inherit;">的《</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Practical Game AI Programming</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">》一书</font><font style="vertical-align: inherit;">。本书可让您学习如何创建游戏AI并从头开始实施最先进的AI算法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
视觉互动是基本的操作，它们不会直接影响游戏玩法，但可以通过将它们纳入我们创造的环境中来使您改善视频游戏及其角色，从而极大地影响玩家对游戏的沉浸感。</font><font style="vertical-align: inherit;">这向我们证明了环境成为游戏一部分的重要性，而不仅仅是帮助填充屏幕上的空间。</font><font style="vertical-align: inherit;">在游戏中越来越发现类似的互动，玩家希望看到它们。</font><font style="vertical-align: inherit;">如果游戏中有一个对象，那么它必须履行某些功能，尽管不是最重要的功能。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与环境互动的第一个例子可以在1986年为任天堂娱乐系统发行的第一部《恶魔城》中找到。</font><font style="vertical-align: inherit;">从一开始，玩家就可以使用鞭子破坏蜡烛和火，这些蜡烛和火原本是背景的一部分。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90c/a93/19c/90ca9319cffa8e665c51bc56297876a5.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就现代人对游戏中角色背景和环境的感知而言，这段时间以及当时的一些游戏打开了许多大门和机会。</font><font style="vertical-align: inherit;">显然，由于那一代控制台的硬件限制，要创建当前标准普遍接受的简单内容要困难得多。</font><font style="vertical-align: inherit;">但是每一代游戏机都带来了新功能，开发人员使用它们来创造出色的游戏。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们第一个视觉交互的示例是背景上的一个对象，可以在不直接影响游戏玩法的情况下对其进行破坏。</font><font style="vertical-align: inherit;">在许多游戏中都可以找到这种互动方式。</font><font style="vertical-align: inherit;">实现起来很简单，只要在对象受到攻击时对其进行动画处理即可。</font><font style="vertical-align: inherit;">之后，我们可以决定是否应该从对象中丢弃任何奖励玩家探索游戏的点或对象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们可以继续下一个示例-游戏中具有动画效果的对象，或者当角色通过它们时移动的对象。此处的原理与可破坏对象相同，但是这次的交互更加微妙-它要求角色移动到对象所在的位置。这可以应用于游戏的各种元素，从草地，灰尘或水的运动到飞鸟或做出有趣手势的人；可能性是无止境。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在分析这些交互时，我们可以轻松地确定它们不一定使用AI，并且在大多数情况下，它只是根据某些给定操作激活的布尔函数。但是它们是环境的一部分，因此在实现环境与AI之间的高质量交互时应予以考虑。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与环境进行简单的交互</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正如我们已经看到的，环境曾经成为游戏玩法的一部分，这为未来的游戏带来了许多新的概念和想法。</font><font style="vertical-align: inherit;">下一步是整合游戏过程中的这些小变化，以及将其用于改变玩家在游戏中的行为。</font><font style="vertical-align: inherit;">这无疑对视频游戏的历史产生了积极的影响，因为场景中的所有元素逐渐开始栩栩如生，并且玩家开始意识到环境的丰富程度。</font><font style="vertical-align: inherit;">使用环境实现游戏内目标已成为游戏的一部分。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/0c6/39f/ad20c639fd190d338f6e2e72847338b1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了演示一个直接影响游戏玩法的环境示例，我们将举一个很好的例子-《古墓丽影》系列。在此示例中，我们的角色Lara Croft必须推动立方体，直到它落在标记的区域上。这将改变环境并开辟新的道路，使玩家可以在水平上进一步移动。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在许多游戏中都可以找到这样的难题：您必须在地图上的特定位置执行一个动作，以便在其中的另一部分发生某些事情，这可以用来实现游戏中的某些目标。通常，我们需要更改环境本身才能进一步提高水平。因此，开发人员在计划地图或关卡时，会考虑到这一点并创建与每个交互相关的所有规则。例如：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(cube.transform.position == mark.transform.position)<font></font>
{<font></font>
  openDoor = <span class="hljs-literal">true</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在想象一下，劳拉·克罗夫特（Lara Croft）有一个盟友角色，其主要任务是帮助她将盒子放置在原处。</font><font style="vertical-align: inherit;">在本章中，我们将只考虑这种类型的交互：AI角色了解环境如何工作以及如何使用它。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古墓丽影的移动环境</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们直接转到这种情况，并尝试重新创建一种可以帮助玩家实现目标的AI角色。</font><font style="vertical-align: inherit;">在此示例中，我们将想象一个被困的玩家，他无法从中访问可以释放他的交互式对象。</font><font style="vertical-align: inherit;">我们创建的角色必须能够找到多维数据集并将其推向正确的方向。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b5/840/cec/6b5840cec8e3b42adad879472c47930d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们有了所有的角色和对象。让我们计划一下在这种情况下AI角色应该如何表现。首先，他应该看到玩家在附近，以便他可以开始搜索并将多维数据集移动到所需位置。假设如果立方体在标记处，则沙子上会出现一个新的方块，从而使玩家可以进一步提升水平。一个AI角色可以在四个方向上推立方体：左，右，前进和后退，从而使其与位置标记完全吻合。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/804/463/982/8044639827005d84bcf50014f095b46e.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AI角色必须验证并验证此行为树中显示的每个动作。继续执行任务的首要也是最重要的一点是，角色必须确保玩家​​位于自己的标记上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果玩家尚未到达那里，那么我们的角色必须等待并留在原地。如果玩家已经到达标记，那么AI角色会继续执行并问自己距立方体对象有多远。如果不是，则角色应该向立方体移动，一旦确认该动作，他就应该问同样的问题。当答案是肯定的，并且角色在立方体旁边时，他需要弄清楚必须先按哪种方式推立方体。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，他开始沿Y轴或X轴推动多维数据集，直到其与标记位置匹配，任务完成。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueYplayerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们开始在代码中添加信息，以允许角色检查玩家是否在其标记位置附近。为此，我们创建了所有必要的变量，以计算玩家与其应处于的位置之间的距离。</font></font><code>playerMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指玩家的3D模型，我们从中提取他的位置并将其用作</font></font><code>currentPlayerPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要知道它是否接近标记，我们需要一个代表标记位置的变量，在我们的示例中，我们创建了一个变量</font></font><code>playerMark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，可以在其中写入玩家应该放置的位置。然后，我们添加了三个变量，让我们知道玩家是否在附近。</font></font><code>proximityValueX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将计算播放器与X轴标记</font></font><code>proximityValueY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间的距离</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">计算播放器与Y轴标记之间的距离。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，我们</font></font><code>nearValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以确定AI角色何时可以开始努力实现目标，从而确定玩家离标记位置有多远。玩家接近标记后，布尔变量</font></font><code>playerOnMark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将值更改为</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要计算玩家与标记之间的距离，我们使用以下方法：玩家与标记之间的距离，相似</font></font><code>(mark.position - player.position)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，要确定AI字符是否在立方体附近，我们通过计算AI与立方体之间的距离来计算相同的方程式。另外，我们在两个标记（玩家和立方体）上的位置上补充了代码：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
   Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
   Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
   nearValue = <span class="hljs-number">0.5f</span>;<font></font>
   nearCube = <span class="hljs-number">0.5f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们的AI角色知道他是否在立方体旁边，这使我们能够回答问题并确定他是否可以继续进行我们计划的下一个分支。</font><font style="vertical-align: inherit;">但是，当角色不在立方体旁边时会发生什么？</font><font style="vertical-align: inherit;">他将需要接近立方体。</font><font style="vertical-align: inherit;">因此，我们将其添加到代码中：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform cubeMesh;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> Finding;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
   Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
   Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
   nearValue = <span class="hljs-number">0.5f</span>;<font></font>
   nearCube = <span class="hljs-number">0.5f</span>;<font></font>
   speed = <span class="hljs-number">1.3f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  { <font></font>
      playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
      cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
      cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">false</span> &amp;&amp; Finding == <span class="hljs-literal">false</span>)<font></font>
  {<font></font>
     PositionChanging();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">true</span>)<font></font>
  {<font></font>
     Finding = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PositionChanging</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  Finding = <span class="hljs-literal">true</span>;<font></font>
  Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
  Vector3 positionB = cubeMesh.transform.position;<font></font>
  <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
到目前为止，我们的AI角色已经能够计算自己与立方体之间的距离。</font><font style="vertical-align: inherit;">如果它们相距太远，则他将转到立方体。</font><font style="vertical-align: inherit;">完成此任务后，他可以进入下一个阶段并开始推动多维数据集。</font><font style="vertical-align: inherit;">他需要计算的最后一件事是立方体离标记的位置有多远，然后他考虑标记靠近立方体的哪一侧来决定推入哪种方式。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de1/be5/bf7/de1be5bf7e65540dfaeb6ab186a8e3c8.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
只能沿X和Z轴推动多维数据集，并且多维数据集的旋转对我们而言并不重要，因为在将多维数据集安装到多维数据集后，该按钮便被激活。鉴于所有这些，AI角色必须计算立方体距X上标记位置和Z上标记位置的距离。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后他比较两个轴上的两个值并选择距离所需位置更远的那个值，然后开始沿此方向推动轴。角色将继续朝这个方向推动，直到立方体与标记的位置对齐，然后切换到另一侧，并将其推动直到完全超过标记的位置：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform cubeMesh;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeMarkProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeMarkProximityZ;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> Finding;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
        Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
        nearValue = <span class="hljs-number">0.5f</span>;<font></font>
        nearCube = <span class="hljs-number">0.5f</span>;<font></font>
        speed = <span class="hljs-number">1.3f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">false</span> &amp;&amp; Finding == <span class="hljs-literal">false</span>)<font></font>
  {<font></font>
      PositionChanging();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">true</span>)<font></font>
  {<font></font>
      Finding = <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
   cubeMarkProximityX = cubeMark.transform.position.x - currentCubePosition.transform.position.x;<font></font>
   cubeMarkProximityZ = cubeMark.transform.position.z - currentCubePosition.transform.position.z;<font></font>
<font></font>
   <span class="hljs-keyword">if</span>(cubeMarkProximityX &gt; cubeMarkProximityZ)<font></font>
   {<font></font>
     PushX();<font></font>
   }<font></font>
<font></font>
   <span class="hljs-keyword">if</span>(cubeMarkProximityX &lt; cubeMarkProximityZ)<font></font>
   {<font></font>
     PushZ();<font></font>
   }<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PositionChanging</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  Finding = <span class="hljs-literal">true</span>;<font></font>
  Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
  Vector3 positionB = cubeMesh.transform.position;<font></font>
  <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在代码中添加了最新的动作之后，角色必须学会确定自己的目标，找到并将立方体推到所需位置，以便玩家可以完成并完成关卡。</font><font style="vertical-align: inherit;">在此示例中，我们集中于如何计算场景对象与角色之间的距离。</font><font style="vertical-align: inherit;">这将帮助我们创建类似类型的交互，其中需要将游戏对象放置在特定位置。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该示例演示了一个友好的AI角色，该角色可以帮助玩家，但是如果我们需要相反的效果（如果角色是敌人），则可以应用相同的原理，其中角色需要尽快找到立方体以阻止玩家。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以帝国时代为例，在环境中设置障碍物</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如前所述，您可以在游戏中使用或移动对象来达成目标，但是如果某些对象阻塞了角色的路径会发生什么呢？对象可以由玩家放置，也可以由设计师简单地放置在地图的此位置。无论如何，AI角色应该能够确定在这种情况下需要做什么。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，我们可以在Ensemble Studios开发的称为帝国时代II的策略中观察到这种行为。每当游戏角色由于被坚固的城墙包围而无法到达敌方领土时，AI会切换到破坏城墙的一部分以继续进行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种交互方式也非常聪明和重要，因为否则角色将只是沿着墙壁徘徊以寻找入口，这看起来不像是合理的行为。</font><font style="vertical-align: inherit;">由于加固墙是由玩家创建的，因此可以将其放置在任何位置并具有任何形状。</font><font style="vertical-align: inherit;">因此，在开发敌方AI时需要考虑这一点。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/137/655/f44137655e3220988033bcb97db85b96.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个例子也与我们的文章主题有关，因为在计划阶段，当我们创建行为树时，我们需要考虑如果某些东西阻碍了角色并且他无法实现目标，将会发生什么。</font><font style="vertical-align: inherit;">我们将在本书的下一章中详细考虑这方面，但是现在我们简化了情况并分析了如果环境对象阻止AI角色实现目标，AI角色应该如何表现。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfb/464/89b/dfb46489b482f383bc95662246308536.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的示例中，AI角色必须进入房屋，但是当他走近时，他意识到自己被木栅栏所包围，您不能通过它。我们希望角色在此阶段选择一个目标，然后开始进攻，直到篱笆的这一部分被破坏，他才能进入房屋。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此示例中，我们需要根据给定的距离和栅栏的当前健康状况，计算角色应该攻击哪个栅栏。 HP较低的篱笆应比HP较高的篱笆具有更高的攻击优先级，因此我们在计算时会考虑到这一点。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/223/23f/ac4/22323fac4373a3556b58383bfb6b36fe.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们想在角色周围设置邻域，在该邻域内最近的栅栏将其信息传递给人工智能，以便它可以确定哪个更容易破坏。这可以通过多种方式实现，要么使用围栏与玩家的碰撞识别，要么迫使他们计算围栏/物体与玩家之间的距离。我们设置玩家开始感知围栏状态的距离值。在我们的示例中，我们将计算距离并将其用于通知角色有关HP围栏的信息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从创建将应用到fence对象的代码开始；它们都将具有相同的脚本：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> HP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> distanceValue;
<span class="hljs-keyword">private</span> Transform characterPosition;
<span class="hljs-keyword">private</span> GameObject characterMesh;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-comment">// Use this for initialization</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  HP = <span class="hljs-number">100f</span>;<font></font>
  distanceValue = <span class="hljs-number">1.5f</span>;<font></font>
<font></font>
  <span class="hljs-comment">// Find the Character Mesh</span>
  characterMesh = GameObject.Find(<span class="hljs-string">"AICharacter"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Update is called once per frame</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Obtain the Character Mesh Position</span><font></font>
  characterPosition = characterMesh.transform;<font></font>
<font></font>
  <span class="hljs-comment">//Calculate the distance between this object and the AI Character</span>
  proximityValueX = characterPosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  proximityValueY = characterPosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  nearValue = proximityValueX + proximityValueY;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此脚本中，我们添加了有关HP和距离的基本信息，这些信息将用于与AI字符连接。这次我们不将距离计算脚本添加到角色，而是添加到环境对象。这使对象更具活力，并允许我们创造更多机会。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，如果游戏中的角色也参与围栏的创建，则它们将具有不同的状态，例如“正在建设中”，“已完成”或“已损坏”；那么角色将能够接收此信息并将其用于自己的目的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们设置与环境对象交互的角色。他的主要目标是进入房屋，但是当他接近房屋时，他意识到由于自己被木栅栏包围，因此无法进入房屋。我们希望，在分析了情况之后，我们的角色会破坏篱笆以实现他的目标并进入房屋。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在角色脚本中，我们将添加一个静态函数，栅栏将能够在该输入中传输有关其当前“健康状况”的信息；这将帮助角色选择最适合破坏的围栏。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> fenceHP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> lowerFenceHP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> fencesAnalyzed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject bestFence;<font></font>
<font></font>
<span class="hljs-keyword">private</span> Transform House;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> timeWasted;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;<font></font>
<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        fenceHP = <span class="hljs-number">100f</span>;<font></font>
        lowerFenceHP = fenceHP;<font></font>
        fencesAnalyzed = <span class="hljs-number">0</span>;<font></font>
        speed = <span class="hljs-number">0.8</span>;<font></font>
<font></font>
        Vector3 House = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">300.2f</span>, <span class="hljs-number">83.3f</span>, <span class="hljs-number">-13.3f</span>);<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        timeWasted += Time.deltaTime;<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(fenceHP &gt; lowerFenceHP)<font></font>
        {<font></font>
            lowerFenceHP = fenceHP;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(timeWasted &gt; <span class="hljs-number">30f</span>)<font></font>
        {<font></font>
            GoToFence();  <font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GoToFence</span><span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
        Vector3 positionB = bestFence.transform.position;<font></font>
        <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/970/af0/7a8970af0c9b5aa303ba32d6dc021ec8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们已经为角色添加了最基本的信息。</font></font><code>fenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将是一个静态变量，落入角色邻域半径内的每个围栏都将记录有关当前HP的信息。然后AI角色分析收到的信息，并将其与HP最少的栅栏进行比较</font></font><code>lowerFenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
角色有一个变量，</font></font><code>timeWasted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示他已经花费了几秒钟来寻找合适的栅栏来摧毁。</font></font><code>fencesAnalyzed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将用于查找代码中是否已经有围栏，如果没有，则添加角色找到的第一个围栏；如果围栏具有相同的HP值，角色将首先攻击它们。现在，我们添加围栏的代码，以便围栏可以访问角色的脚本并输入有用的信息。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> HP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> distanceValue;
<span class="hljs-keyword">private</span> Transform characterPosition;
<span class="hljs-keyword">private</span> GameObject characterMesh;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> nearValue;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        HP = <span class="hljs-number">100f</span>;<font></font>
        distanceValue = <span class="hljs-number">1.5f</span>;<font></font>
<font></font>
        <span class="hljs-comment">// Find the Character Mesh</span>
        characterMesh = GameObject.Find(<span class="hljs-string">"AICharacter"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        <span class="hljs-comment">// Obtain the Character Mesh Position</span><font></font>
        characterPosition = characterMesh.transform;<font></font>
<font></font>
        <span class="hljs-comment">//Calculate the distance between this object and the AI Character</span>
        proximityValueX = characterPosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
        proximityValueY = characterPosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
        nearValue = proximityValueX + proximityValueY;<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(nearValue &lt;= distanceValue){
            <span class="hljs-keyword">if</span>(AICharacter.fencesAnalyzed == <span class="hljs-number">0</span>){<font></font>
                AICharacter.fencesAnalyzed = <span class="hljs-number">1</span>;<font></font>
                AICharacter.bestFence = <span class="hljs-keyword">this</span>.gameObject;<font></font>
            }<font></font>
<font></font>
            AICharacter.fenceHP = HP;<font></font>
<font></font>
            <span class="hljs-keyword">if</span>(HP &lt; AICharacter.lowerFenceHP){<font></font>
                AICharacter.bestFence = <span class="hljs-keyword">this</span>.gameObject;<font></font>
            }<font></font>
        }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们终于完成了这个例子。</font><font style="vertical-align: inherit;">现在，围栏将其当前HP与角色的数据（</font></font><code>lowerFenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）进行比较，如果其HP小于角色拥有的最小值，则将考虑该围栏</font></font><code>bestFence</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该示例演示了如何使AI角色适应游戏中的各种动态对象。</font><font style="vertical-align: inherit;">可以扩展相同的原理，并将其与几乎任何对象进行交互。</font><font style="vertical-align: inherit;">当使用对象与角色交互，链接对象之间的信息时，它也是适用和有用的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我们探索了与环境互动的各种方式。</font><font style="vertical-align: inherit;">本章中演示的技术可以扩展到许多不同类型的游戏，并可以用于在AI角色和环境之间进行简单而复杂的交互。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN496050/index.html">老虎和狮子在纽约感染冠状病毒</a></li>
<li><a href="../zh-CN496052/index.html">服务公司如何避免客户罚款？过程自动化的几个明显优势</a></li>
<li><a href="../zh-CN496056/index.html">数字化：数字和术语如何欺骗我们</a></li>
<li><a href="../zh-CN496058/index.html">为什么要对农业联合收割机进行机械化，有哪些困难？两年内我们如何做到</a></li>
<li><a href="../zh-CN496064/index.html">激光“冲击波”操作模型</a></li>
<li><a href="../zh-CN496082/index.html">数据工程师和数据科学家：有什么区别？</a></li>
<li><a href="../zh-CN496084/index.html">Blazor客户端在线商店：第6部分-创建订单和使用补偿性操作</a></li>
<li><a href="../zh-CN496086/index.html">使用Zextras Digital Jobs组织远程工作</a></li>
<li><a href="../zh-CN496088/index.html">4月21日直播！Badoo本地化聚会</a></li>
<li><a href="../zh-CN496090/index.html">用Zyxel删除</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>