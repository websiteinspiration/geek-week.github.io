<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌓 🌚 #⃣ EvilParcelの脆弱性分析 📟 🧠 🧕🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前書き
 4月中旬に、Android OSのいくつかの重大な脆弱性を悪用したAndroid.InfectionAds.1トロイの木馬に関するニュースを公開しました。それらの1つ-CVE-2017-13156（別名Janus）-悪意のあるプログラムがAPKファイルにデジタル署名を損なうことなく感染させ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>EvilParcelの脆弱性分析</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/drweb/blog/457558/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4月中旬</font><font style="vertical-align: inherit;">に、Android OSのいくつかの重大な脆弱性を悪用し</font><font style="vertical-align: inherit;">た</font><b><font style="vertical-align: inherit;">Android.InfectionAds.1</font></b><font style="vertical-align: inherit;">トロイの木馬</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に関するニュース</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">公開し</font></a><font style="vertical-align: inherit;">ました。それらの1つ-CVE-2017-13156（別名</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Janus</font></a><font style="vertical-align: inherit;">）-悪意のあるプログラムがAPKファイルにデジタル署名を損なうことなく感染させることができます。</font><font style="vertical-align: inherit;">
もう1つはCVE-2017-13315です。トロイの木馬に高度な権限を与え、アプリケーションを個別にインストールおよび削除できます。</font><b><font style="vertical-align: inherit;">Android.InfectionAds.1</font></b><font style="vertical-align: inherit;">の詳細な分析は</font><font style="vertical-align: inherit;">、弊社のウイルスライブラリで利用でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">こちら</font></a><font style="vertical-align: inherit;">で確認でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。脆弱性CVE-2017-13315について詳しく説明し、それがどのようなものかを確認します。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CVE-2017-13315は、一般的な名前EvilParcelを受け取った脆弱性のグループに属しています。</font><font style="vertical-align: inherit;">これらは、Android OSのさまざまなシステムクラスにあります。</font><font style="vertical-align: inherit;">アプリケーションとシステム間でデータを交換する際の後者のエラーにより、このデータを置き換えることが可能になります。</font><font style="vertical-align: inherit;">EvilParcelの脆弱性を悪用する悪意のあるプログラムは、より高い特権を受け取り、その助けを借りて次のことを行うことができます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーの確認なしに、権限のあるアプリケーションをインストールおよびアンインストールします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他の脆弱性と組み合わせて使用​​した場合、デバイスにインストールされているプログラムに感染し、「クリーン」なオリジナルを感染したコピーで置き換えます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Androidデバイスの画面ロックコードをリセットする</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Androidデバイスのロック画面のPINをリセットします。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、このタイプの7つの脆弱性が知られています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2017年10月に公開されたCVE-2017-0806（GateKeeperResponseクラスのエラー）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CVE-2017-13286（2018年4月に公開されたOutputConfigurationクラスのエラー;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CVE-2017-13287（VerifyCredentialResponseクラスのエラー）、2018年4月に公開されました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2018年4月に公開されたCVE-2017-13288（PeriodicAdvertizingReportクラスのエラー）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2018年4月に公開されたCVE-2017-13289（ParcelableRttResultsクラスのバグ）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CVE-2017-13311（SparseMappingTableクラスのバグ）、2018年5月に公開;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CVE-2017-13315（DcParamObjectクラスのエラー）、2018年5月に公開されました。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらのすべては、2018年5月以降のセキュリティアップデートがインストールされていないAndroid OSバージョン5.0〜8.1を実行しているデバイスを脅かしています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EvilParcelの脆弱性の前提条件</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EvilParcelの脆弱性がどのように発生するかを見てみましょう。まず、Androidアプリケーションの機能のいくつかの機能を検討します。 Android OSでは、すべてのプログラムは、Intentタイプのオブジェクトを送受信することにより、オペレーティングシステム自体と同様に相互にやり取りします。これらのオブジェクトには、Bundleタイプのオブジェクト内に任意の数のキーと値のペアを含めることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Intentを送信すると、BundleオブジェクトはParcelでラップされたバイト配列に変換（シリアル化）され、シリアル化されたBundleからキーと値を読み取ると、自動的に逆シリアル化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バンドルでは、文字列がキーであり、値はほとんど何でもかまいません。たとえば、プリミティブ型、文字列、またはプリミティブ型または文字列を含むコンテナ。また、Parcelableタイプのオブジェクトにすることもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、バンドルでは、Parcelableインターフェースを実装する任意のタイプのオブジェクトを配置できます。これを行うには、writeToParcel（）およびcreateFromParcel（）メソッドを実装して、オブジェクトをシリアライズおよびデシリアライズする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
良い例として、単純なシリアル化されたバンドルを作成しましょう。 Bundleに3つのキーと値のペアを配置してシリアル化するコードを記述します</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。Bundle demo = new Bundle（）; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
demo.putString（ "String"、 "Hello、World！"）; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
demo.putInt（ "整数"、42）; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
demo.putByteArray（ "ByteArray"、新しいバイト[] {1、2、3、4、5、6、7、8}）; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーセルパーセル= Parcel.obtain（）; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
parcel.writeBundle（デモ）; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードを実行すると、次の形式のバンドルが取得され</font></font><br>
<br>
<img src="https://habrastorage.org/webt/53/gn/x5/53gnx5bjhjfdaqjr5isxgva6fzg.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。図1。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シリアル化されたBundleオブジェクトの構造。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bundleシリアライゼーションの次の機能に注目してみましょう。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのキーと値のペアは次々と書き込まれます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各値の前にそのタイプが示されます（バイト配列の場合は13、整数の場合は1、文字列の場合は0など）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可変長のデータの前に、そのサイズが示されます（文字列の長さ、配列のバイト数）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての値は4バイトのアライメントで書き込まれます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bundle内のすべてのキーと値が順番に書き込まれるため、シリアル化されたBundleオブジェクトのキーまたは値にアクセスすると、それに含まれるすべてのParcelableオブジェクトの初期化を含め、後者は完全に逆シリアル化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何が問題なのでしょうか？</font><font style="vertical-align: inherit;">また、Parcelableを実装する一部のシステムクラスでは、createFromParcel（）およびwriteToParcel（）メソッドでエラーが発生する場合があるためです。</font><font style="vertical-align: inherit;">これらのクラスでは、createFromParcel（）メソッドで読み取られるバイト数は、writeToParcel（）メソッドで書き込まれるバイト数とは異なります。</font><font style="vertical-align: inherit;">そのようなクラスのオブジェクトをバンドル内に配置すると、再シリアル化後のバンドル内のオブジェクトの境界が変化します。</font><font style="vertical-align: inherit;">そして、これがEvilParcelの脆弱性を悪用するための条件が作成される場所です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様のエラーのあるクラスの例を示します。 </font></font><br>
 <br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Parcelable</span> </span>{
    <span class="hljs-keyword">byte</span>[] data;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">0</span>];<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Demo</span><span class="hljs-params">(Parcel in)</span> </span>{
      <span class="hljs-keyword">int</span> length = in.readInt();<font></font>
      data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];
      <span class="hljs-keyword">if</span> (length &gt; <span class="hljs-number">0</span>) {<font></font>
         in.readByteArray(data);<font></font>
      }<font></font>
     }<font></font>
     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Creator&lt;Demo&gt; CREATOR = <span class="hljs-keyword">new</span> Creator&lt;Demo&gt;() {
       <span class="hljs-meta">@Override</span>
       <span class="hljs-function"><span class="hljs-keyword">public</span> Demo <span class="hljs-title">createFromParcel</span><span class="hljs-params">(Parcel in)</span> </span>{
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Demo(in);<font></font>
       }<font></font>
     };<font></font>
     <span class="hljs-meta">@Override</span>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeToParcel</span><span class="hljs-params">(Parcel parcel, <span class="hljs-keyword">int</span> i)</span> </span>{<font></font>
       parcel.writeInt(data.length);<font></font>
       parcel.writeByteArray(data);<font></font>
     }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ配列のサイズが0の場合、createFromParcel（）でオブジェクトを作成すると、1つのint（4バイト）が読み取られ、2つのint（8バイト）がwriteToParcel（）に書き込まれます。最初のintは、writeIntの明示的な呼び出しで書き込まれます。 2番目のintは、writeByteArray（）が呼び出されたときに書き込まれます。これは、長さが常にParcelの配列の前に書き込まれるためです（図1を参照）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ配列のサイズが0である状況はまれです。ただし、これが発生した場合でも、一度に1つのオブジェクトだけがシリアル化された形式で送信されると（この例では、Demoオブジェクト）、プログラムは引き続き機能します。したがって、そのようなエラーは、原則として気付かれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、配列の長さがゼロのDemoオブジェクトをバンドルに配置してみましょう</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2y/2v/i0/2y2vi0ftdkartg9i01cc-b858g0.png"><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。図2。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バンドルに長さゼロのDemoオブジェクトを追加した結果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトをシリアル化します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hv/tw/if/hvtwifj9curkc7ip6jplbdlk-yc.png"><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シリアル化後のBundleオブジェクト。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それを逆シリアル化してみましょう：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_u/a1/k4/_ua1k4hp34wknsvnppv8zla0jei.png"><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図4.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bundleオブジェクトを逆シリアル化した後。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果はどうですか？パーセルフラグメントについて考えてみ</font></font><br>
<br>
<img src="https://habrastorage.org/webt/g0/qs/y4/g0qsy4cigykwv2gxgpizo2qsu7u.png"><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。図5.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バンドルの逆シリアル化後のパーセル構造。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図4および5から、逆シリアル化中に、以前に書き込まれた2つの整数ではなく、1つのintがcreateFromParcelメソッドで読み取られたことがわかります。したがって、バンドルからの後続のすべての値が正しく読み取られませんでした。アドレス0x60の値0x0が次のキーの長さとして読み取られました。また、アドレス0x64の値0x1がキーとして読み取られました。この場合、アドレス0x68の値0x31が値のタイプとして読み取られました。タイプが0x31のParcelには値がないため、readFromParcel（）はエラーを例外なく報告しました（例外）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを実際にどのように使用して脆弱性にすることができますか？見てみよう！上記のParcelableシステムクラスで説明されているエラーを使用すると、バンドルを構築できます。これは、最初のデシリアライゼーションと繰り返されるデシリアライゼーションで異なる場合があります。これを実証するには、前の例を変更します。</font></font><br>
<br>
<pre><code class="java hljs">Parcel data = Parcel.obtain();<font></font>
data.writeInt(<span class="hljs-number">3</span>); <span class="hljs-comment">// 3 entries</span>
data.writeString(<span class="hljs-string">"vuln_class"</span>);<font></font>
data.writeInt(<span class="hljs-number">4</span>); <span class="hljs-comment">// value is Parcelable</span>
data.writeString(<span class="hljs-string">"com.drweb.testbundlemismatch.Demo"</span>);<font></font>
data.writeInt(<span class="hljs-number">0</span>); <span class="hljs-comment">// data.length</span>
data.writeInt(<span class="hljs-number">1</span>); <span class="hljs-comment">// key length -&gt; key value</span>
data.writeInt(<span class="hljs-number">6</span>); <span class="hljs-comment">// key value -&gt; value is long</span>
data.writeInt(<span class="hljs-number">0xD</span>); <span class="hljs-comment">// value is bytearray -&gt; low(long)</span>
data.writeInt(-<span class="hljs-number">1</span>); <span class="hljs-comment">// bytearray length dummy -&gt; high(long)</span>
<span class="hljs-keyword">int</span> startPos = data.dataPosition();<font></font>
data.writeString(<span class="hljs-string">"hidden"</span>); <span class="hljs-comment">// bytearray data -&gt; hidden key</span>
data.writeInt(<span class="hljs-number">0</span>); <span class="hljs-comment">// value is string</span>
data.writeString(<span class="hljs-string">"Hi there"</span>); <span class="hljs-comment">// hidden value</span>
<span class="hljs-keyword">int</span> endPos = data.dataPosition();
<span class="hljs-keyword">int</span> triggerLen = endPos - startPos;<font></font>
data.setDataPosition(startPos - <span class="hljs-number">4</span>);<font></font>
data.writeInt(triggerLen); <span class="hljs-comment">// overwrite dummy value with the real value</span><font></font>
data.setDataPosition(endPos);<font></font>
data.writeString(<span class="hljs-string">"A padding"</span>);<font></font>
data.writeInt(<span class="hljs-number">0</span>); <span class="hljs-comment">// value is string</span>
data.writeString(<span class="hljs-string">"to match pair count"</span>);
<span class="hljs-keyword">int</span> length = data.dataSize();<font></font>
Parcel bndl = Parcel.obtain();<font></font>
bndl.writeInt(length);<font></font>
bndl.writeInt(<span class="hljs-number">0x4C444E42</span>); <span class="hljs-comment">// bundle magic</span>
bndl.appendFrom(data, <span class="hljs-number">0</span>, length);<font></font>
bndl.setDataPosition(<span class="hljs-number">0</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは、脆弱なクラスを含むシリアル化されたバンドルを作成します。このコードを実行した結果を見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tc/ke/wf/tckewffnaop28wllxnrt7pagdvs.png"><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図6.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">脆弱なクラスを持つバンドルの作成。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の逆シリアル化の後、このバンドルには次のキーが含まれます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cj/si/l0/cjsil0--g_jsoew8ht-oxely1u4.png"><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図7.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">脆弱なクラスでバンドルを逆シリアル化した結果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、結果のバンドルを再度シリアライズしてから、再度デシリアライズして、キーのリストを確認します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uw/e1/mj/uwe1mjdtywr59oyshaah2q1gkus.png"><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図8.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">脆弱なクラスを使用したバンドルのシリアライズとデシリアライズを繰り返した結果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何が見えますか？非表示のキー（文字列値「Hi there！」）がバンドルに表示されましたが、これは以前にはありませんでした。これがなぜ起こったかを理解するために、このバンドルのパーセルフラグメントを検討してください：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cx/za/dz/cxzadza4tugyeemlefk1lmlkdbu.png"><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図9。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つのシリアル化/逆シリアル化サイクル後の脆弱なクラスを持つBundleオブジェクトのパーセル構造。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでEvilParcelの脆弱性の本質がより明確になります。</font><font style="vertical-align: inherit;">脆弱なクラスを含む特別な形式のバンドルを作成することが可能です。</font><font style="vertical-align: inherit;">このクラスの境界を変更すると、任意のオブジェクトをこのバンドルに配置できます。たとえば、インテントは、2回目の逆シリアル化の後でのみバンドルに表示されます。</font><font style="vertical-align: inherit;">これにより、オペレーティングシステムの保護メカニズムからインテントを隠すことができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーションEvilParcel</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
感染したデバイスの所有者の介入なしにCVE-2017-13315を使用してAndroid.InfectionAds.1をインストールおよびアンインストールしたプログラム。しかし、これはどうですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2013年には、</font><font style="vertical-align: inherit;">Launch AnyWhereとしても知られる</font><font style="vertical-align: inherit;">エラー</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7699048</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も</font><font style="vertical-align: inherit;">発見さ</font><font style="vertical-align: inherit;">れました。これにより、サードパーティのアプリケーションは、より特権の高いユーザーシステムに代わって任意のアクティビティを実行できました。以下の図は、そのアクションのメカニズムを示してい</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dg/no/n9/dgnon92txtobknvvgr5eo2cmi54.png"><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。図10.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラー7699048のスキーム。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この脆弱性により、エクスプロイトアプリケーションは、新しいアカウントをオペレーティングシステムに追加するように設計されたAccountAuthenticatorサービスを実装できます。バグ7699048のおかげで、このエクスプロイトは、アプリケーションのインストール、アンインストール、置き換え、PINまたはパターンロックのリセット、その他の不快な操作を実行するアクティビティを実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Googleは、AccountManagerからの任意のアクティビティの起動を禁止することにより、このギャップを修正しました。現在、AccountManagerは同じアプリケーションからのアクティビティの起動のみを許可しています。これを行うには、アクティビティの開始を開始したプログラムのデジタル署名をチェックし、起動されたアクティビティが配置されているアプリケーションの署名と比較します。次のようになります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>
   &amp;&amp; (intent = result.getParcelable(AccountManager.KEY_INTENT)) != <span class="hljs-keyword">null</span>) {
   <span class="hljs-comment">/*
    * The Authenticator API allows third party authenticators to
    * supply arbitrary intents to other apps that they can run,
    * this can be very bad when those apps are in the system like
    * the System Settings.
    */</span>
   <span class="hljs-keyword">int</span> authenticatorUid = Binder.getCallingUid();
   <span class="hljs-keyword">long</span> bid = Binder.clearCallingIdentity();
   <span class="hljs-keyword">try</span> {<font></font>
     PackageManager pm = mContext.getPackageManager();<font></font>
     ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, <span class="hljs-number">0</span>, mAccounts.userId);
     <span class="hljs-keyword">int</span> targetUid = resolveInfo.activityInfo.applicationInfo.uid;
     <span class="hljs-keyword">if</span> (PackageManager.SIGNATURE_MATCH !=<font></font>
           pm.checkSignatures(authenticatorUid, targetUid)) {<font></font>
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SecurityException(
              <span class="hljs-string">"Activity to be started with KEY_INTENT must "</span> +
              <span class="hljs-string">"share Authenticator's signatures"</span>);<font></font>
     }<font></font>
   } <span class="hljs-keyword">finally</span> {<font></font>
     Binder.restoreCallingIdentity(bid);<font></font>
   }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は解決されたようですが、ここですべてがスムーズであるとは限りません。この修正は、有名な脆弱性EvilParcel CVE-2017-13315を使用して回避できることが判明しました！すでにご存じのように、Launch AnyWhereを修正した後、システムはアプリケーションのデジタル署名をチェックします。このチェックが成功すると、BundleがIAccountManagerResponse.onResult（）に渡されます。同時に、IPCメカニズムを介してonResult（）が呼び出されるため、バンドルは再度シリアル化されます。 onResult（）実装では、次のことが起こります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">/** Handles the responses from the AccountManager */</span>
<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Response</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IAccountManagerResponse</span>.<span class="hljs-title">Stub</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResult</span><span class="hljs-params">(Bundle bundle)</span> </span>{<font></font>
      Intent intent = bundle.getParcelable(KEY_INTENT);<font></font>
      <span class="hljs-keyword">if</span> (intent != <span class="hljs-keyword">null</span> &amp;&amp; mActivity != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// since the user provided an Activity we will silently start intents</span>
        <span class="hljs-comment">// that we see</span><font></font>
        mActivity.startActivity(intent);<font></font>
        <span class="hljs-comment">// leave the Future running to wait for the real response to this request</span><font></font>
      }<font></font>
      <span class="hljs-comment">//&lt;.....&gt;</span><font></font>
     }<font></font>
     <span class="hljs-comment">//&lt;.....&gt;</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、バンドルがインテントキーを抽出し、アクティビティはチェックなしで起動されます。その結果、システム権限で任意のアクティビティを開始するには、最初の逆シリアル化中にインテントフィールドが非表示になり、逆シリアル化が繰り返されるときに表示されるようにバンドルを構築するだけで十分です。そして、すでに見てきたように、EvilParcelの脆弱性が満たすのはまさにこのタスクです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、このタイプのすべての既知の脆弱性は、脆弱なParcelableクラス自体の修正によって修正されています。ただし、将来的に脆弱なクラスが再び出現する可能性も否定できません。バンドルの実装と新しいアカウントを追加するメカニズムは、以前と同じです。それでも、脆弱なParcelableクラス（または新しい）を発見したときに、まったく同じエクスプロイトを作成できます。さらに、これらのクラスの実装は依然として手動で行われ、プログラマーはシリアル化されたParcelableオブジェクトの一定の長さに注意する必要があります。そして、これはすべての結果を伴う人的要因です。ただし、このようなエラーができるだけ少なくなり、EvilParcelの脆弱性がAndroidデバイスのユーザーの邪魔にならないことを願っています。</font></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dr.Web Security Space</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
アンチウイルスを使用して、モバイルデバイスのEvilParcelの脆弱性をチェックできます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">組み込みの「セキュリティ監査人」は、特定された問題について報告し、それらを解決するための推奨事項を提供します。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja457542/index.html">暗号化をハッキングして保護するLUKS</a></li>
<li><a href="../ja457546/index.html">デモ日：なぜこれがすべてであり、それを行う方法UPD + Broadcast</a></li>
<li><a href="../ja457548/index.html">TMS320F28027での多相PWM信号の生成</a></li>
<li><a href="../ja457550/index.html">デジタル業界を保護する必要があるもの</a></li>
<li><a href="../ja457552/index.html">ザファサディのクライマー。ラフタセンタータワーのプロマルプの仕組み</a></li>
<li><a href="../ja457560/index.html">トークン化された株式：IPOに行く前にゲットインベスターになる方法</a></li>
<li><a href="../ja457562/index.html">Ivideon Counter 3D：誰が、どのように、そしてなぜ訪問者をカウントするか</a></li>
<li><a href="../ja457564/index.html">会社のITシステムコストの見積もり</a></li>
<li><a href="../ja457566/index.html">圧力は問題ありません：なぜデータセンターは気圧制御が必要なのですか？ </a></li>
<li><a href="../ja457568/index.html">未来の議会：未来の伝道者のアカウントの選択</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>