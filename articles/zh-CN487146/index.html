<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👢 😛 🌞 ResizeObserver-适应性强的新功能强大的工具 👥 🐛 👌🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="朋友们，美好的一天！
 
 响应式是Web开发的标准之一。屏幕分辨率很多，并且这个数字一直在增加。我们努力支持所有可能的屏幕尺寸，同时保持友好的用户界面。媒体查询（媒体查询）是解决此问题的绝佳方法。但是网络组件呢？现代Web开发基于组件，我们需要一种使它们响应的方法。今天，我想谈谈ResizeObs...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ResizeObserver-适应性强的新功能强大的工具</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487146/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">朋友们，美好的一天！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
响应式是Web开发的标准之一。</font><font style="vertical-align: inherit;">屏幕分辨率很多，并且这个数字一直在增加。</font><font style="vertical-align: inherit;">我们努力支持所有可能的屏幕尺寸，同时保持友好的用户界面。</font><font style="vertical-align: inherit;">媒体查询（媒体查询）是解决此问题的绝佳方法。</font><font style="vertical-align: inherit;">但是网络组件呢？</font><font style="vertical-align: inherit;">现代Web开发基于组件，我们需要一种使它们响应的方法。</font><font style="vertical-align: inherit;">今天，我想谈谈ResizeObserver API，它允许您监视（观察）特定元素（而不是整个视口）的大小变化，而不是像媒体查询那样监视整个视口。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一点历史</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前，我们只有媒体查询可供使用-一种CSS解决方案，基于媒体设备的屏幕大小，类型和分辨率（媒体设备指的是计算机，电话或平板电脑）。</font><font style="vertical-align: inherit;">媒体查询非常灵活且易于使用。</font><font style="vertical-align: inherit;">长期以来，媒体查询仅在CSS中可用，现在它们也通过window.matchMedia（mediaQueryString）在JS中可用。</font><font style="vertical-align: inherit;">现在，我们可以检查从哪个设备查看了该页面，还可以监视查看区域大小的变化（我们正在谈论</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MediaQueryList.addListener（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">-大约。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元素查询</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们缺少的功能是监视单个DOM元素的大小，而不仅仅是整个视口的大小。</font><font style="vertical-align: inherit;">多年来，开发人员一直对此抱怨。</font><font style="vertical-align: inherit;">这是最令人期待的功能之一。</font><font style="vertical-align: inherit;">在2015年，甚至提出了一个提案-集装箱尺寸要求（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集装箱查询</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开发人员在调整其父容器大小时通常需要具有样式元素的能力，而无论其查看区域是什么。</font><font style="vertical-align: inherit;">集装箱尺寸的要求给了他们这个机会。</font><font style="vertical-align: inherit;">CSS用法示例：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.element：媒体（最小宽度：30em）屏幕{***}</font></font><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">听起来不错，但浏览器供应商有充分的理由拒绝该建议-循环依赖（循环依赖）（当一种尺寸定义另一种尺寸时，这会导致无限循环（有关更多信息，请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">））。</font><font style="vertical-align: inherit;">还有什么其他选择？</font><font style="vertical-align: inherit;">我们可以使用window.resize（回调），但这是“昂贵的乐趣”-每当事件发生时都会调用回调，并且我们将需要进行大量计算才能确定组件的大小确实发生了变化。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用ResizeObserver API调整监视元素的大小</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
符合</font><font style="vertical-align: inherit;">Chrome </font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ResizeObserver API</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ResizeObserver API是用于跟踪元素大小调整的接口。</font><font style="vertical-align: inherit;">这是元素的window.resize事件的一种类似形式。</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ResizeObserver API是实时草案。</font><font style="vertical-align: inherit;">它已经在PC的Chrome，Firefox和Safari中实现。</font><font style="vertical-align: inherit;">移动支持并不那么令人印象深刻-仅支持Android和Chrome浏览器和Chrome浏览器。</font><font style="vertical-align: inherit;">不幸的是，不存在成熟的多聚体。</font><font style="vertical-align: inherit;">可用的多聚体包含一些限制（例如，对调整大小的响应较慢或缺少对平滑过渡的支持）。</font><font style="vertical-align: inherit;">但是，这不应阻止我们测试此API。</font><font style="vertical-align: inherit;">让我们开始吧！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示例：在调整元素大小时更改文本</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
想象一下以下情况-元素内的文本应根据元素的大小而变化。</font><font style="vertical-align: inherit;">ResizeObserver API提供了两个工具-ResizeObserver和ResizeObserverEntry。</font><font style="vertical-align: inherit;">ResizeObserver用于跟踪项目的大小，而ResizeObserverEntry包含有关已调整大小的项目的信息。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代码很简单：</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> size <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span> boring text <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
</code></pre><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> ro = <span class="hljs-keyword">new</span> ResizeObserver(<span class="hljs-function"><span class="hljs-params">entries</span> =&gt;</span> {
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> entries){
        <span class="hljs-keyword">const</span> width = entry.contentBoxSize<font></font>
        ? entry.contentBoxSize.inlineSize<font></font>
        : entry.contentRect.width<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(entry.target.tagName === <span class="hljs-string">'H1'</span>){<font></font>
            entry.target.textContent = width &lt; <span class="hljs-number">1000</span> <span class="hljs-string">'small'</span> : <span class="hljs-string">'big'</span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(entry.target.tagName === <span class="hljs-string">'H2'</span> &amp;&amp; width &lt; <span class="hljs-number">500</span>){<font></font>
            entry.target.textContent = <span class="hljs-string">`I won't change anymore`</span>
            ro.unobserve(entry.target) <span class="hljs-comment">//  ,     500px</span><font></font>
        }<font></font>
    }<font></font>
})<font></font>
<font></font>
<span class="hljs-comment">//       </span>
ro.observe(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'h1'</span>))<font></font>
ro.observe(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'h2'</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，创建一个ResizeObserver对象，并将回调函数作为参数传递给它：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> resizeObserver = <span class="hljs-keyword">new</span> ResizeObserver(<span class="hljs-function">(<span class="hljs-params">entries, observer</span>) =&gt;</span> {
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> entries){
        <span class="hljs-comment">// </span><font></font>
    }<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每次调整ResizeObserverEntries中包含的元素之一的大小时，都会调用该函数。</font><font style="vertical-align: inherit;">回调函数的第二个参数是观察者本身。</font><font style="vertical-align: inherit;">我们可以使用它来例如在满足特定条件时停止跟踪。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回调获取ResizeObserverEntry数组。</font><font style="vertical-align: inherit;">每个条目均包含观察元素（目标）的尺寸。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> entries){
    <span class="hljs-keyword">const</span> width = entry.contentBoxSize<font></font>
    ? entry.contentBoxSize.inlineSize<font></font>
    : entry.contentRect.width<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(entry.target.tagName === <span class="hljs-string">'H1'</span>){<font></font>
        entry.target.textContent = width &lt; <span class="hljs-number">1000</span> ? <span class="hljs-string">'small'</span> : <span class="hljs-string">'big'</span><font></font>
    }<font></font>
    ...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们具有三个描述元素大小的属性-borderBoxSize，contentBoxSize和contentRect。</font><font style="vertical-align: inherit;">它们代表元素的盒模型，我们将在后面讨论。</font><font style="vertical-align: inherit;">现在谈谈支持。</font><font style="vertical-align: inherit;">大多数浏览器都支持contentRect，但是显然，此属性将被弃用：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contentRect出现在ResizeObserver的初步开发阶段，仅出于当前兼容性的考虑而添加。</font><font style="vertical-align: inherit;">将来可能会认为它已过时。</font></font><br>
</blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我强烈建议将contentRect与bordeBoxSize和contentBoxSize结合使用。</font><font style="vertical-align: inherit;">ResizeObserverSize包括两个属性：inlineSize和blockSize，它们可以解释为宽度和高度（前提是我们在文本的水平方向上工作-书写模式：水平）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元素观察</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后要做的是开始跟踪该项目。</font><font style="vertical-align: inherit;">为此，我们调用ResizeObserver.observe（）。</font><font style="vertical-align: inherit;">此方法将新目标添加到观察项目列表。</font><font style="vertical-align: inherit;">我们可以一次将一个或几个元素添加到此列表中：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// resizeObserver(target, options)</span>
ro.observe(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'h1'</span>))<font></font>
ro.observe(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'h2'</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个参数是“可选”。</font><font style="vertical-align: inherit;">迄今为止，唯一可用的选项是box，它定义了块模型。</font><font style="vertical-align: inherit;">可能的值是content-box（默认），border-box和device-pixel-content-box（仅Chrome）。</font><font style="vertical-align: inherit;">在一台ResizeObserver中只能定义一个块模型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要停止监视，请使用ResizeObserver.unobserve（目标）。</font><font style="vertical-align: inherit;">要停止跟踪所有元素，请使用ResizeObserver.disconnect（）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">块模型</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内容框是块的内容，不带填充，边框和边距。</font><font style="vertical-align: inherit;">边框包括填充和边框（无边距）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xb/qz/ma/xbqzmaedk8mdsymljkcc8ud33wu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
设备像素内容框是元素的内容，以物理像素为单位。</font><font style="vertical-align: inherit;">我没有看到使用此模型的示例，但似乎在使用画布时可能会派上用场。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Github上有关此主题</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">的</font></a><font style="vertical-align: inherit;">有趣讨论。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">观察者什么时候能发现变化？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每次调整目标元素的大小时都会调用一个回调。</font><font style="vertical-align: inherit;">规格说明如下：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从DOM中添加/删除被观察项时，将触发观察。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当被观察元素的显示属性设置为none时，将触发观察。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">观察不适用于“未取代”的线元素。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">观察不适用于CSS转换。</font></font></li>
<li>    ,   , ..  ,     0,0.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据第一段，我们可以确定更改其子级时父容器中的更改。</font><font style="vertical-align: inherit;">ResizeObserver API的这种用法的一个很好的例子是在添加新消息时向下滚动聊天窗口。</font><font style="vertical-align: inherit;">一个例子可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看到</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还记得我之前提到的容器大小查询吗？</font><font style="vertical-align: inherit;">关于他的循环依赖问题？</font><font style="vertical-align: inherit;">因此，ResizeObserver API具有内置的解决方案，可以防止“调整大小”的无限循环。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
感谢您的关注。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有用的链接：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">MDN </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">CanIUse </font></a></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规范</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">开发团队的第一篇文章</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">最受欢迎的polyfil</font></a></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN487132/index.html">我们如何将数百人的分布式团队转移到SAAS</a></li>
<li><a href="../zh-CN487136/index.html">TypeScript的干净代码-第3部分</a></li>
<li><a href="../zh-CN487138/index.html">机器学习中的图论最小</a></li>
<li><a href="../zh-CN487140/index.html">在Swift Combine中节省业务逻辑。第1部分</a></li>
<li><a href="../zh-CN487144/index.html">测试Jabra Panacast全景相机的可视角度为180°（视频）</a></li>
<li><a href="../zh-CN487154/index.html">探索《 Journey》游戏的沙着色器</a></li>
<li><a href="../zh-CN487158/index.html">应用程序界面的手势控制（Keras + CoreML）</a></li>
<li><a href="../zh-CN487162/index.html">现代商人和公司需要隐私吗？</a></li>
<li><a href="../zh-CN487168/index.html">有毒的祖父界面故事“仪器垃圾”（s1 e2）</a></li>
<li><a href="../zh-CN487172/index.html">DeepPavlov的创建者基于cs224n课程开设的“ NLP深度学习”开放课程</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>