<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äç‚öñÔ∏è üçØ üôéüèº Asynchronen Code mit Corutin linearisieren üë©‚Äç‚úàÔ∏è üêÆ üò´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sie k√∂nnen nicht nur Coroutine zum Erstellen von Generatoren verwenden, sondern auch versuchen, vorhandenen asynchronen Code zu linearisieren. Versuch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Asynchronen Code mit Corutin linearisieren</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/493808/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98e/c7c/314/98ec7c314c49b57c2d8af8d53508b211.jpg" alt="Bild"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen nicht nur Coroutine zum Erstellen von Generatoren verwenden, sondern auch versuchen, vorhandenen asynchronen Code zu linearisieren. </font><font style="vertical-align: inherit;">Versuchen wir dies anhand eines kleinen Beispiels. </font><font style="vertical-align: inherit;">Nehmen Sie den auf dem Actor-Framework geschriebenen Code und schreiben Sie eine Funktion dieses Codes auf Coroutinen neu. </font><font style="vertical-align: inherit;">Um das Projekt zu erstellen, verwenden wir gcc aus dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutinen-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zweig </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Ziel ist es, R√ºckrufe von Nudeln zu erhalten:</font></font><br>
<br>
<pre><code class="cpp hljs">    abActor.getA(ABActor::GetACallback([<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
        abActor.getB(ABActor::GetBCallback([a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {<font></font>
            abActor.saveAB(a - b, a + b, ABActor::SaveABCallback([<span class="hljs-keyword">this</span>](){<font></font>
                abActor.getA(ABActor::GetACallback([<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
                    abActor.getB(ABActor::GetBCallback([a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {
                        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
                    }));<font></font>
                }));<font></font>
            }));<font></font>
        }));<font></font>
    }));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Art von:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync();
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync();
<span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync(a - b, a + b);
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newA = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync();
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newB = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync();
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also lasst uns anfangen.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauspieler</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst m√ºssen wir ein einfaches Schauspieler-Framework erstellen. </font><font style="vertical-align: inherit;">Das Erstellen eines vollwertigen Rahmens f√ºr Schauspieler ist eine schwierige und gro√üe Aufgabe, daher implementieren wir nur eine Art davon. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie zun√§chst eine Basisklasse:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Actor</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> Task = <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>()&gt;;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~Actor();
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Task &amp;task)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tryRunTask</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt;Task&gt; <span class="hljs-built_in">queue</span>;
    <span class="hljs-keyword">mutable</span> <span class="hljs-built_in">std</span>::mutex mutex;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee ist im Grunde einfach: Wir stellen Aufgaben, die funktionale Objekte sind, in eine Warteschlange, und wenn wir RunTask versuchen, versuchen wir, diese Aufgabe abzuschlie√üen. </font><font style="vertical-align: inherit;">Die Implementierung der Klasse best√§tigt unsere Absichten:</font></font><br>
<br>
<pre><code class="cpp hljs">Actor::~Actor() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Actor::addTask</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Task &amp;task)</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>;
    <span class="hljs-built_in">queue</span>.push(task);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Actor::tryRunTask</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>.empty()) {
        <span class="hljs-keyword">return</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">const</span> Task task = <span class="hljs-built_in">queue</span>.front();
    <span class="hljs-built_in">queue</span>.pop();<font></font>
    lock.unlock();<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::invoke(task);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die n√§chste Klasse ist der "Faden", zu dem unsere Schauspieler geh√∂ren werden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Actor</span>;</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActorThread</span> {</span>
<span class="hljs-keyword">public</span>:<font></font>
    ~ActorThread();<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addActor</span><span class="hljs-params">(Actor &amp;actor)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::reference_wrapper&lt;Actor&gt;&gt; actors;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auch hier ist alles einfach: Ganz am Anfang des Programms ‚Äûbinden‚Äú wir unsere Akteure mit der addActor-Methode an den Thread und starten den Thread dann mit der run-Methode.</font></font><br>
<br>
<pre><code class="cpp hljs">ActorThread::~ActorThread() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ActorThread::addActor</span><span class="hljs-params">(Actor &amp;actor)</span> </span>{<font></font>
    actors.emplace_back(actor);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ActorThread::run</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">for</span> (Actor &amp;actor: actors) {<font></font>
            actor.tryRunTask();<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir den Thread starten, treten wir in eine Endlosschleife ein und versuchen, von jedem Akteur eine Aufgabe auszuf√ºhren. </font><font style="vertical-align: inherit;">Nicht die beste L√∂sung, aber f√ºr eine Demonstration. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns nun den Vertreter der Schauspielerklasse an:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABActor</span>:</span> <span class="hljs-keyword">public</span> Actor {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> GetACallback = Callback&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> result)&gt;;
    <span class="hljs-keyword">using</span> GetBCallback = Callback&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> result)&gt;;
    <span class="hljs-keyword">using</span> SaveABCallback = Callback&lt;<span class="hljs-keyword">void</span>()&gt;;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getA</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetACallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getB</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetBCallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveAB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> SaveABCallback &amp;callback)</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getAProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetACallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getBProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetBCallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveABProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> SaveABCallback &amp;callback)</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Klasse speichert zwei Zahlen in sich selbst - a und b - und gibt auf Anfrage ihre Werte zur√ºck oder √ºberschreibt sie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als R√ºckruf akzeptiert es ein Funktionsobjekt mit den notwendigen Parametern. </font><font style="vertical-align: inherit;">Aber achten wir darauf, dass verschiedene Akteure in verschiedenen Threads gestartet werden k√∂nnen. </font><font style="vertical-align: inherit;">Wenn wir am Ende der Arbeit nur den an die Methode √ºbergebenen R√ºckruf aufrufen, wird dieser R√ºckruf im aktuellen ausf√ºhrbaren Thread aufgerufen und nicht in dem Thread, der unsere Methode aufgerufen und diesen R√ºckruf erstellt hat. </font><font style="vertical-align: inherit;">Daher m√ºssen wir √ºber den R√ºckruf einen Wrapper erstellen, der diese Situation l√∂st:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Callback</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Functor&gt;
    <span class="hljs-title">Callback</span><span class="hljs-params">(Actor &amp;sender, <span class="hljs-keyword">const</span> Functor &amp;callback)</span>
        : <span class="hljs-title">sender</span><span class="hljs-params">(sender)</span>
        , <span class="hljs-title">callback</span><span class="hljs-params">(callback)</span>
    </span>{}
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Args&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(Args&amp;&amp; ...args)</span> <span class="hljs-keyword">const</span> </span>{<font></font>
        sender.addTask(<span class="hljs-built_in">std</span>::bind(callback, <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...));<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:<font></font>
    Actor &amp;sender;<font></font>
    <span class="hljs-built_in">std</span>::function&lt;C&gt; callback;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Wrapper merkt sich den urspr√ºnglichen Akteur, und wenn Sie versuchen, sich selbst auszuf√ºhren, f√ºgt er der Aufgabenwarteschlange des urspr√ºnglichen Akteurs einfach einen echten R√ºckruf hinzu. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen sieht die Implementierung der ABActor-Klasse folgenderma√üen aus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getA</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetACallback &amp;callback)</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getAProcess, <span class="hljs-keyword">this</span>, callback));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getAProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ABActor::GetACallback &amp;callback)</span> </span>{
    <span class="hljs-built_in">std</span>::invoke(callback, a);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getB</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetBCallback &amp;callback)</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getBProcess, <span class="hljs-keyword">this</span>, callback));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getBProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ABActor::GetBCallback &amp;callback)</span> </span>{
    <span class="hljs-built_in">std</span>::invoke(callback, b);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::saveAB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> SaveABCallback &amp;callback)</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::saveABProcess, <span class="hljs-keyword">this</span>, a, b, callback));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::saveABProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> ABActor::SaveABCallback &amp;callback)</span> </span>{
    <span class="hljs-keyword">this</span>-&gt;a = a;
    <span class="hljs-keyword">this</span>-&gt;b = b;
    <span class="hljs-built_in">std</span>::invoke(callback);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Schnittstellenmethode der Klasse binden wir die √ºbergebenen Argumente einfach an den entsprechenden ‚ÄûSlot‚Äú der Klasse, erstellen so eine Aufgabe und stellen diese Aufgabe in die Warteschlange der Aufgaben dieser Klasse. </font><font style="vertical-align: inherit;">Wenn der Task-Thread beginnt, die Task auszuf√ºhren, ruft er den richtigen ‚ÄûSlot‚Äú auf, der alle erforderlichen Aktionen ausf√ºhrt, und ruft den R√ºckruf auf, der wiederum den tats√§chlichen R√ºckruf an die Warteschlange der Aufgabe sendet, die ihn verursacht hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schreiben wir einen Schauspieler, der die ABActor-Klasse verwendet:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABActor</span>;</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WokrerActor</span>:</span> <span class="hljs-keyword">public</span> Actor {
<span class="hljs-keyword">public</span>:<font></font>
    WokrerActor(ABActor &amp;actor)<font></font>
        : abActor(actor)<font></font>
    {}<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">workProcess</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:<font></font>
    ABActor &amp;abActor;<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::work</span><span class="hljs-params">()</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;WokrerActor::workProcess, <span class="hljs-keyword">this</span>));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workProcess</span><span class="hljs-params">()</span> </span>{<font></font>
    abActor.getA(ABActor::GetACallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    }));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und alles zusammen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<font></font>
    ABActor abActor;<font></font>
    <span class="hljs-function">WokrerActor <span class="hljs-title">workerActor</span><span class="hljs-params">(abActor)</span></span>;<font></font>
<font></font>
    ActorThread thread;<font></font>
    thread.addActor(abActor);<font></font>
    thread.addActor(workerActor);<font></font>
<font></font>
    workerActor.work();<font></font>
<font></font>
    thread.run();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Folgen wir der gesamten Codekette. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Anfang erstellen wir die notwendigen Objekte und stellen Verbindungen zwischen ihnen her. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anschlie√üend f√ºgen wir die workProcess-Task zur Warteschlange der Actor Worker-Task hinzu. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Thread startet, findet er unsere Aufgabe in der Warteschlange und beginnt, sie auszuf√ºhren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend der Ausf√ºhrung rufen wir die getA-Methode der ABActor-Klasse auf, stellen die entsprechende Aufgabe in die Warteschlange der ABActor-Klasse und schlie√üen die Ausf√ºhrung ab. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als N√§chstes nimmt der Thread die neu erstellte Aufgabe aus der ABActor-Klasse und f√ºhrt sie aus, was zur Ausf√ºhrung des getAProcess-Codes f√ºhrt.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code ruft einen R√ºckruf auf und √ºbergibt das erforderliche Argument - die Variable a. Da der R√ºckruf, den er besitzt, ein Wrapper ist, wird tats√§chlich ein echter R√ºckruf mit gef√ºllten Parametern in die Warteschlange der Worker-Klasse gestellt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wenn der Thread bei der n√§chsten Iteration des Zyklus unseren R√ºckruf von der Worker-Klasse abzieht und ausf√ºhrt, wird die Ausgabe der Zeile "Ergebnis 10" angezeigt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Actor Framework ist eine recht bequeme M√∂glichkeit, Klassen, die √ºber verschiedene physische Streams verteilt sind, miteinander zu interagieren. Die Besonderheit des Klassendesigns besteht, wie Sie davon √ºberzeugt sein sollten, darin, dass innerhalb jedes einzelnen Akteurs alle Aktionen vollst√§ndig und in einem einzigen Thread ausgef√ºhrt werden. Der einzige Punkt f√ºr die Synchronisation von Streams liegt in den Implementierungsdetails des Actor Frameworks und ist f√ºr den Programmierer nicht sichtbar. Auf diese Weise kann ein Programmierer Single-Threaded-Code schreiben, ohne sich Gedanken √ºber das Einpacken von Mutexen und das Verfolgen von Rennsituationen, Deadlocks und anderen Kopfschmerzen machen zu m√ºssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider hat diese L√∂sung einen Preis. Da das Ergebnis der Ausf√ºhrung eines anderen Akteurs nur √ºber den R√ºckruf zug√§nglich ist, wird der Akteurcode fr√ºher oder sp√§ter wie folgt:</font></font><br>
<br>
<pre><code class="cpp hljs">    abActor.getA(ABActor::GetACallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
        abActor.getB(ABActor::GetBCallback(*<span class="hljs-keyword">this</span>, [a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {<font></font>
            abActor.saveAB(a - b, a + b, ABActor::SaveABCallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](){<font></font>
                abActor.getA(ABActor::GetACallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
                    abActor.getB(ABActor::GetBCallback(*<span class="hljs-keyword">this</span>, [a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {
                        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
                    }));<font></font>
                }));<font></font>
            }));<font></font>
        }));<font></font>
    }));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, ob wir dies mit der Innovation von C ++ 20 - Coroutinen vermeiden k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber zuerst werden wir die Einschr√§nkungen spezifizieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nat√ºrlich k√∂nnen wir den Code des Actor Frameworks in keiner Weise √§ndern. </font><font style="vertical-align: inherit;">Au√üerdem k√∂nnen wir die Signaturen √∂ffentlicher und privater Methoden von Instanzen der Actor-Klasse - ABActor und WorkerActor - nicht √§ndern. </font><font style="vertical-align: inherit;">Mal sehen, ob wir aus dieser Situation herauskommen k√∂nnen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutinen. </font><font style="vertical-align: inherit;">Teil 1. Kellner</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptidee von corutin ist, dass beim Erstellen von coroutine ein separater Stapelrahmen f√ºr diesen auf dem Heap erstellt wird, von dem wir jederzeit "beenden" k√∂nnen, w√§hrend die aktuelle Ausf√ºhrungsposition, Prozessorregister und andere notwendige Informationen beibehalten werden. Dann k√∂nnen wir auch jederzeit zur Ausf√ºhrung der suspendierten Coroutine zur√ºckkehren und diese bis zum Ende oder bis zur n√§chsten Suspendierung abschlie√üen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Objekt std :: coroutine_handle &lt;&gt; ist f√ºr die Verwaltung dieser Daten verantwortlich, die im Wesentlichen einen Zeiger auf den Stapelrahmen (und andere erforderliche Daten) darstellen und √ºber eine Wiederaufnahmemethode (oder deren Analogon, den Operator ()) verf√ºgen, die uns zur Ausf√ºhrung der Coroutine zur√ºckf√ºhrt . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf diesen Daten schreiben wir zuerst die Funktion getAAsync und versuchen dann zu verallgemeinern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben bereits eine Instanz der Klasse std :: coroutine_handle &lt;&gt; coro. Was m√ºssen wir tun? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie m√ºssen die bereits vorhandene Methode ABActor :: getA aufrufen, um die Situation nach Bedarf zu beheben. Zun√§chst m√ºssen Sie jedoch einen R√ºckruf f√ºr die Methode getA erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erinnern wir uns, dass ein R√ºckruf an den R√ºckruf der getA-Methode zur√ºckgegeben wird - das Ergebnis der getA-Methode. Dar√ºber hinaus wird dieser R√ºckruf im Worker-Thread des Threads aufgerufen. Somit k√∂nnen wir von diesem R√ºckruf aus sicher die Coroutine ausf√ºhren, die nur aus dem Worker-Thread erstellt wurde und die weiterhin ihre Abfolge von Aktionen ausf√ºhrt. Aber wir m√ºssen auch irgendwo das im R√ºckruf zur√ºckgegebene Ergebnis speichern, es wird uns nat√ºrlich weiter n√ºtzlich sein.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> callback = GetACallback(returnCallbackActor, [&amp;value, coro](<span class="hljs-keyword">int</span> result) {<font></font>
        value = result;<font></font>
        <span class="hljs-built_in">std</span>::invoke(coro);<font></font>
 });<font></font>
getA(callback);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt m√ºssen Sie eine Instanz des coroutine_handle-Objekts von irgendwoher nehmen und einen Link, √ºber den Sie unser Ergebnis speichern k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Zukunft werden wir sehen, dass coroutine_handle als Ergebnis des Aufrufs der Funktion an uns √ºbergeben wird. </font><font style="vertical-align: inherit;">Dementsprechend k√∂nnen wir es nur an eine andere Funktion √ºbergeben. </font><font style="vertical-align: inherit;">Bereiten wir diese Funktion als Lambda vor. </font><font style="vertical-align: inherit;">(Wir werden den Link an die Variable √ºbergeben, in der das Ergebnis des R√ºckrufs an das Unternehmen gespeichert wird.)</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> storeCoroToQueue = [&amp;returnCallbackActor, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">auto</span> &amp;value, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro) {
    <span class="hljs-keyword">auto</span> callback=GetACallback(returnCallbackActor, [&amp;value, coro](<span class="hljs-keyword">int</span> result){<font></font>
        value = result;<font></font>
        <span class="hljs-built_in">std</span>::invoke(coro);<font></font>
    });<font></font>
    getA(callback);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden diese Funktion in der n√§chsten Klasse speichern.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ActorAwaiterSimple</span> {</span>
    <span class="hljs-keyword">int</span> value;<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> &amp;value,<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; forwardCoroToCallback;<font></font>
<font></font>
    ActorAwaiterSimple(<font></font>
        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> &amp;value, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; &amp;forwardCoroToCallback<font></font>
    )<font></font>
        : forwardCoroToCallback(forwardCoroToCallback)<font></font>
    {}<font></font>
<font></font>
    ActorAwaiterSimple(<span class="hljs-keyword">const</span> ActorAwaiterSimple &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiterSimple&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> ActorAwaiterSimple &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiterSimple(ActorAwaiterSimple &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiterSimple&amp; <span class="hljs-keyword">operator</span>=(ActorAwaiterSimple &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
<span class="hljs-comment">// ...</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neben dem Funktionsobjekt wird hier auch der Speicher (in Form des Variablenwerts) f√ºr den Wert gespeichert, der uns im R√ºckruf erwartet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da wir den Speicher hier unter dem Wert halten, m√∂chten wir kaum, dass die Instanz dieser Klasse kopiert oder irgendwohin verschoben wird. Stellen Sie sich zum Beispiel vor, jemand hat diese Klasse kopiert, den Wert unter dem Variablenwert in der alten Instanz der Klasse gespeichert und dann versucht, ihn aus der neuen Instanz zu lesen. Und es ist nat√ºrlich nicht da, da vor dem Speichern kopiert wurde. Unangenehm. Daher sch√ºtzen wir uns vor diesen Problemen, indem wir Konstruktoren verbieten und Operatoren kopieren und verschieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns diese Klasse weiter schreiben. Die n√§chste Methode, die wir brauchen, ist:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Er beantwortet die Frage, ob unsere Bedeutung zur Ausgabe bereit ist. </font><font style="vertical-align: inherit;">Nat√ºrlich ist unser Wert beim ersten Anruf noch nicht fertig, und in Zukunft wird uns niemand mehr danach fragen. Geben Sie also einfach false zur√ºck. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die coroutine_handle-Instanz wird in der void await_suspend-Methode (std :: coroutine_handle &lt;&gt; coro) an uns √ºbergeben. Rufen wir also unseren vorbereiteten Funktor darin auf und √ºbergeben dort auch eine Speicherverkn√ºpfung unter value:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro)</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-built_in">std</span>::invoke(forwardCoroToCallback, <span class="hljs-built_in">std</span>::ref(value), coro);<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis der Funktionsausf√ºhrung wird zum richtigen Zeitpunkt durch Aufrufen der Methode await_resume abgefragt. </font><font style="vertical-align: inherit;">Wir werden dem Antragsteller nicht verweigern:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-keyword">return</span> value;<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt kann unsere Methode mit dem Schl√ºsselwort co_await aufgerufen werden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was hier passieren wird, stellen wir bereits grob dar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst wird ein Objekt vom Typ ActorAwaiterSimple erstellt, das an die "Eingabe" von co_await √ºbertragen wird. Er fragt zuerst (indem er await_ready aufruft), ob wir versehentlich ein fertiges Ergebnis haben (wir haben es nicht), ruft dann await_suspend auf, √ºbergibt einen Kontext (tats√§chlich einen Zeiger auf den aktuellen Coroutine-Stack-Frame) und unterbricht die Ausf√ºhrung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der ABActor-Akteur in Zukunft seine Arbeit beendet und den Ergebnisr√ºckruf aufruft, wird dieses Ergebnis (bereits im Worker-Thread-Thread) in der einzigen (auf dem Coroutine-Stapel verbleibenden) Instanz von ActorAwaiterSimple gespeichert und die Fortsetzung der Coroutine wird gestartet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Corutin setzt die Ausf√ºhrung fort, nimmt das gespeicherte Ergebnis durch Aufrufen der Methode await_resume und √ºbergibt dieses Ergebnis an die Variable a</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Derzeit besteht die Einschr√§nkung des aktuellen Kellners darin, dass er nur mit R√ºckrufen mit einem Parameter vom Typ int arbeiten kann. </font><font style="vertical-align: inherit;">Versuchen wir, die Anwendung von Awaiter zu erweitern:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ActorAwaiter</span> {</span><font></font>
<font></font>
    <span class="hljs-built_in">std</span>::tuple&lt;T...&gt; values;<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-built_in">std</span>::tuple&lt;T...&gt; &amp;values, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; storeHandler;<font></font>
<font></font>
    ActorAwaiter(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-built_in">std</span>::tuple&lt;T...&gt; &amp;values, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; &amp;storeHandler)<font></font>
        : storeHandler(storeHandler)<font></font>
    {}<font></font>
<font></font>
    ActorAwaiter(<span class="hljs-keyword">const</span> ActorAwaiter &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiter&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> ActorAwaiter &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiter(ActorAwaiter &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiter&amp; <span class="hljs-keyword">operator</span>=(ActorAwaiter &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro)</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-built_in">std</span>::invoke(storeHandler, <span class="hljs-built_in">std</span>::ref(values), coro);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//   bool B  ,</span>
    <span class="hljs-comment">//   sfinae      </span>
    <span class="hljs-keyword">template</span>&lt;
        <span class="hljs-keyword">bool</span> B=<span class="hljs-literal">true</span>,<span class="hljs-keyword">size_t</span> len=<span class="hljs-keyword">sizeof</span>...(T),<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;len==<span class="hljs-number">0</span> &amp;&amp; B, <span class="hljs-keyword">int</span>&gt;=<span class="hljs-number">0</span><font></font>
    &gt;<font></font>
    <span class="hljs-keyword">void</span> await_resume() <span class="hljs-keyword">noexcept</span> {<font></font>
<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//   bool B  ,</span>
    <span class="hljs-comment">//   sfinae      </span>
    <span class="hljs-keyword">template</span>&lt;
        <span class="hljs-keyword">bool</span> B=<span class="hljs-literal">true</span>,<span class="hljs-keyword">size_t</span> len=<span class="hljs-keyword">sizeof</span>...(T),<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;len==<span class="hljs-number">1</span> &amp;&amp; B, <span class="hljs-keyword">int</span>&gt;=<span class="hljs-number">0</span><font></font>
    &gt;<font></font>
    <span class="hljs-keyword">auto</span> await_resume() <span class="hljs-keyword">noexcept</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">0</span>&gt;(values);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//   bool B  ,</span>
    <span class="hljs-comment">//   sfinae      </span>
    <span class="hljs-keyword">template</span>&lt;
        <span class="hljs-keyword">bool</span> B=<span class="hljs-literal">true</span>,<span class="hljs-keyword">size_t</span> len=<span class="hljs-keyword">sizeof</span>...(T),<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;len!=<span class="hljs-number">1</span> &amp;&amp; len!=<span class="hljs-number">0</span> &amp;&amp; B, <span class="hljs-keyword">int</span>&gt;=<span class="hljs-number">0</span><font></font>
    &gt;<font></font>
    <span class="hljs-built_in">std</span>::tuple&lt;T...&gt; await_resume() <span class="hljs-keyword">noexcept</span> {
        <span class="hljs-keyword">return</span> values;<font></font>
    }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier verwenden wir std :: tuple, um mehrere Variablen gleichzeitig speichern zu k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sfinae wird der Methode await_resume auferlegt, damit nicht in allen F√§llen ein Tupel zur√ºckgegeben werden kann. Abh√§ngig von der Anzahl der im Tupel liegenden Werte wird void, genau 1 Argument oder das gesamte Tupel zur√ºckgegeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Wrapper zum Erstellen von Awaiter selbst sehen jetzt folgenderma√üen aus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> MakeCallback, <span class="hljs-keyword">typename</span>... ReturnArgs, <span class="hljs-keyword">typename</span> Func&gt;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">makeCoroCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Func &amp;func, Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">return</span> [&amp;returnCallback, func](<span class="hljs-keyword">auto</span> &amp;values, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro) {
        <span class="hljs-keyword">auto</span> callback = MakeCallback(returnCallback, [&amp;values, coro](ReturnArgs&amp;&amp; ...result) {<font></font>
            values = <span class="hljs-built_in">std</span>::make_tuple(<span class="hljs-built_in">std</span>::forward&lt;ReturnArgs&gt;(result)...);
            <span class="hljs-built_in">std</span>::invoke(coro);<font></font>
        });<font></font>
        func(callback);<font></font>
    };<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> MakeCallback, <span class="hljs-keyword">typename</span>... ReturnArgs, <span class="hljs-keyword">typename</span> Func&gt;
<span class="hljs-keyword">static</span> ActorAwaiter&lt;ReturnArgs...&gt; <span class="hljs-title">makeActorAwaiter</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Func &amp;func, Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> storeCoroToQueue = makeCoroCallback&lt;MakeCallback, ReturnArgs...&gt;(func, returnCallback);
    <span class="hljs-keyword">return</span> ActorAwaiter&lt;ReturnArgs...&gt;(storeCoroToQueue);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ActorAwaiter&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ABActor::getAAsync</span><span class="hljs-params">(Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">return</span> makeActorAwaiter&lt;GetACallback, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getA, <span class="hljs-keyword">this</span>, _1), returnCallback);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ActorAwaiter&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ABActor::getBAsync</span><span class="hljs-params">(Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">return</span> makeActorAwaiter&lt;GetBCallback, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getB, <span class="hljs-keyword">this</span>, _1), returnCallback);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ActorAwaiter&lt;&gt; <span class="hljs-title">ABActor::saveABAsync</span><span class="hljs-params">(Actor &amp;returnCallback, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> makeActorAwaiter&lt;SaveABCallback&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::saveAB, <span class="hljs-keyword">this</span>, a, b, _1), returnCallback);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun herausfinden, wie der erstellte Typ direkt in Coroutine verwendet wird.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutinen. </font><font style="vertical-align: inherit;">Teil 2. Wiederaufnahmef√§hig</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus Sicht von C ++ wird eine Funktion, die die W√∂rter co_await, co_yield oder co_return enth√§lt, als Coroutine betrachtet. Aber auch eine solche Funktion sollte einen bestimmten Typ zur√ºckgeben. Wir waren uns einig, dass wir die Signatur der Funktionen nicht √§ndern werden (hier meine ich, dass sich der R√ºckgabetyp auch auf die Signatur bezieht), also m√ºssen wir irgendwie raus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns eine Lambda-Coroutine erstellen und sie von unserer Funktion aus aufrufen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workProcess</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> coroutine = [](WokrerActor &amp;actor) -&gt; ActorResumable {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync(actor, a - b, a + b);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newA = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newB = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
<font></font>
    coroutine(*<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Warum erfassen Sie dies nicht in der Lambda-Erfassungsliste? Dann w√ºrde der gesamte darin enthaltene Code etwas einfacher herauskommen. Es kam jedoch vor, dass die Lambda-Coroutinen im Compiler anscheinend noch nicht vollst√§ndig unterst√ºtzt werden, sodass dieser Code nicht funktioniert.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, </font><font style="vertical-align: inherit;">funktioniert </font><font style="vertical-align: inherit;">unser </font><font style="vertical-align: inherit;">Code </font><font style="vertical-align: inherit;">Der be√§ngstigende R√ºckrufcode hat sich jetzt in einen h√ºbschen linearen Code verwandelt. </font><font style="vertical-align: inherit;">Wir m√ºssen nur noch die ActorResumable-Klasse erfinden. Schauen </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
wir uns das an.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ActorResumable</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">promise_type</span> {</span>
        <span class="hljs-keyword">using</span> coro_handle = <span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt;;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>{ 
            <span class="hljs-comment">//  ,    ActorResumable   promise_type</span>
            <span class="hljs-keyword">return</span> coro_handle::from_promise(*<span class="hljs-keyword">this</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">//      </span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::suspend_never();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">//      . </span>
            <span class="hljs-comment">// ,     </span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::suspend_never();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">//   ,       </span>
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">terminate</span>();<font></font>
        }<font></font>
    };<font></font>
<font></font>
    ActorResumable(<span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt;) {}<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Pseudocode des aus unserem Lambda erzeugten Corutins sieht ungef√§hr so ‚Äã‚Äãaus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">ActorResumable <span class="hljs-title">coro</span><span class="hljs-params">()</span> </span>{<font></font>
    promise_type promise;<font></font>
    ActorResumable retobj = promise.get_return_object();<font></font>
    <span class="hljs-keyword">auto</span> intial_suspend = promise.initial_suspend();
    <span class="hljs-keyword">if</span> (initial_suspend == <span class="hljs-built_in">std</span>::suspend_always)  {
          <span class="hljs-comment">// yield</span><font></font>
    }<font></font>
    <span class="hljs-keyword">try</span> { 
        <span class="hljs-comment">//  .</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    } <span class="hljs-keyword">catch</span>(...) { <font></font>
        promise.unhandled_exception();<font></font>
    }<font></font>
final_suspend:<font></font>
    <span class="hljs-keyword">auto</span> final_suspend = promise.final_suspend();
    <span class="hljs-keyword">if</span> (final_suspend == <span class="hljs-built_in">std</span>::suspend_always)  {
         <span class="hljs-comment">// yield</span>
    } <span class="hljs-keyword">else</span> {<font></font>
         cleanup();<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist nur Pseudocode, einige Dinge werden absichtlich vereinfacht. </font><font style="vertical-align: inherit;">Mal sehen, was passiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst erstellen wir ein Versprechen und ActorResumable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach initial_suspend () machen wir keine Pause, sondern fahren fort. </font><font style="vertical-align: inherit;">Wir beginnen mit der Durchf√ºhrung des Hauptteils des Programms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir zu co_await kommen, verstehen wir, dass wir innehalten m√ºssen. </font><font style="vertical-align: inherit;">Wir haben diese Situation bereits im vorherigen Abschnitt untersucht. Sie k√∂nnen darauf zur√ºckkommen und sie √ºberpr√ºfen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir die Ausf√ºhrung fortgesetzt und das Ergebnis auf dem Bildschirm angezeigt haben, endet die Coroutine-Ausf√ºhrung. </font><font style="vertical-align: inherit;">Wir √ºberpr√ºfen final_suspend und l√∂schen den gesamten Kontext der Coroutine.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutinen. </font><font style="vertical-align: inherit;">Teil 3. Aufgabe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erinnern wir uns, welches Stadium wir jetzt erreicht haben.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workProcess</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> coroutine = [](WokrerActor &amp;actor) -&gt; ActorResumable {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync(actor, a - b, a + b);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newA = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newB = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
<font></font>
    coroutine(*<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sieht gut aus, aber es ist leicht zu erkennen, dass der Code:</font></font><br>
<br>
<pre><code class="cpp hljs">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 mal wiederholt. </font><font style="vertical-align: inherit;">Ist es m√∂glich, diesen Moment umzugestalten und in eine separate Funktion zu stellen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns skizzieren, wie dies aussehen k√∂nnte:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">CoroTask&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">WokrerActor::readAB</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> abActor.getAAsync2(*<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> abActor.getBAsync2(*<span class="hljs-keyword">this</span>);
    <span class="hljs-function"><span class="hljs-keyword">co_return</span> <span class="hljs-title">std::make_pair</span><span class="hljs-params">(a, b)</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workCoroProcess</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> coroutine = [](WokrerActor &amp;actor) -&gt; ActorResumable {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> [a, b] = <span class="hljs-keyword">co_await</span> actor.readAB();
        <span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync2(actor, a - b, a + b);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> [newA, newB] = <span class="hljs-keyword">co_await</span> actor.readAB();
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
<font></font>
    coroutine(*<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir m√ºssen nur noch den CoroTask-Typ erfinden. </font><font style="vertical-align: inherit;">Lass es uns √ºberlegen. </font><font style="vertical-align: inherit;">Zun√§chst wird co_return in der Funktion readAB verwendet, was bedeutet, dass CoroTask die Schnittstelle Resumable erf√ºllen muss. </font><font style="vertical-align: inherit;">Ein Objekt dieser Klasse wird aber auch verwendet, um co_await einer anderen Coroutine einzugeben. </font><font style="vertical-align: inherit;">Dies bedeutet, dass die CoroTask-Klasse auch die Awaitable-Schnittstelle erf√ºllen muss. </font><font style="vertical-align: inherit;">Implementieren wir diese beiden Schnittstellen in der CoroTask-Klasse:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-keyword">void</span>&gt;<font></font>
struct CoroTask {<font></font>
    struct promise_type {<font></font>
        T result;<font></font>
        <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; waiter;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> CoroTask{*<span class="hljs-keyword">this</span>};<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">return_value</span><span class="hljs-params">(T value)</span> </span>{<font></font>
            result = value;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">terminate</span>();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-built_in">std</span>::suspend_always <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> {};<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">final_awaiter</span> {</span>
                <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>{}
                <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt; me)</span> </span>{
                    <span class="hljs-keyword">return</span> me.promise().waiter;<font></font>
                }<font></font>
            };<font></font>
            <span class="hljs-keyword">return</span> final_awaiter{};<font></font>
        }<font></font>
    };<font></font>
<font></font>
    CoroTask(CoroTask &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    CoroTask&amp; <span class="hljs-keyword">operator</span>=(CoroTask&amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    CoroTask(<span class="hljs-keyword">const</span> CoroTask&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    CoroTask&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> CoroTask&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
    ~CoroTask() {<font></font>
        <span class="hljs-keyword">if</span> (h) {<font></font>
            h.destroy();<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">CoroTask</span><span class="hljs-params">(promise_type &amp; p)</span>
        : <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt;::from_promise(p))</span>
    </span>{}<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">T <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">auto</span> &amp;result = h.promise().result;
        <span class="hljs-keyword">return</span> result;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; waiter)</span> </span>{<font></font>
        h.promise().waiter = waiter;<font></font>
        h.resume();<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt; h;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Ich empfehle dringend, das Hintergrundbild dieses Beitrags zu √∂ffnen. In Zukunft wird dies Ihnen sehr helfen.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns also sehen, was hier passiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Gehen Sie zur Lambda-Coroutine und erstellen Sie sofort die WokrerActor :: readAB-Coroutine. Nachdem wir diese Coroutine erstellt haben, beginnen wir nicht mit der Ausf√ºhrung (initial_suspend == suspend_always), was uns zwingt, die Coroutine Lambda zu unterbrechen und zur√ºckzukehren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. co_await lambda pr√ºft, ob readAB bereit ist. Das Ergebnis ist nicht bereit (await_ready == false), wodurch es gezwungen wird, seinen Kontext an die CoroTask :: await_suspend-Methode zu √ºbergeben. Dieser Kontext wird in CoroTask gespeichert und die Wiederaufnahme der readAB </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3- </font><font style="vertical-align: inherit;">Coroutinen wird gestartet </font><font style="vertical-align: inherit;">. Nachdem die readAB-Coroutine alle erforderlichen Aktionen ausgef√ºhrt hat, erreicht sie die folgende Zeile:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">co_return</span> <span class="hljs-title">std::make_pair</span><span class="hljs-params">(a, b)</span></span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen wird die CoroTask :: Versprechen_Typ :: R√ºckgabewert-Methode aufgerufen und das erstellte Zahlenpaar in CoroTask :: Versprechen_Typ </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4 </font><font style="vertical-align: inherit;">gespeichert. </font><font style="vertical-align: inherit;">Da die Co_Return-Methode aufgerufen wurde, wird die Ausf√ºhrung der Coroutine beendet, was bedeutet, dass es Zeit ist, die CoroTask :: Versprechen_Typ :: Final_Suspend-Methode aufzurufen . Diese Methode gibt eine selbstgeschriebene Struktur zur√ºck (vergessen Sie nicht, das Bild zu betrachten), die Sie zwingt, die Methode final_awaiter :: await_suspend aufzurufen, von der der in Schritt 2 gespeicherte Coroutine-Lambda-Kontext zur√ºckgegeben wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum k√∂nnen wir suspend_always nicht einfach hierher zur√ºckgeben? Haben wir im Fall von initial_suspend dieser Klasse Erfolg gehabt? Tatsache ist, dass wir in initial_suspend erfolgreich waren, weil diese Coroutine von unserer Lambda-Coroutine aufgerufen wurde und wir dorthin zur√ºckgekehrt sind. Aber in dem Moment, als wir den Aufruf final_suspend erreichten, wurde unsere Coroutine h√∂chstwahrscheinlich von einem anderen Stapel aus fortgesetzt (insbesondere von dem Lambda, das die Funktion makeCoroCallback vorbereitet hat), und wenn wir suspend_always hier zur√ºckgeben w√ºrden, w√ºrden wir zu diesem und nicht zur workCoroProcess-Methode zur√ºckkehren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5. Da die Methode final_awaiter :: await_suspend den Kontext an uns zur√ºckgegeben hat, wird das Programm gezwungen, den zur√ºckgegebenen Kontext, dh das Coroutine-Lambda, weiter auszuf√ºhren. Da die Ausf√ºhrung auf den Punkt zur√ºckgekehrt ist:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> [a, b] = <span class="hljs-keyword">co_await</span> actor.readAB();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann m√ºssen wir das gespeicherte Ergebnis isolieren, indem wir die CoroTask :: await_resume-Methode aufrufen. Das Ergebnis wird empfangen, an die Variablen a und b √ºbergeben, und jetzt wird die CoroTask-Instanz zerst√∂rt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6. Die CoroTask-Instanz wurde zerst√∂rt, aber was ist mit dem WokrerActor :: readAB-Kontext passiert? Wenn wir von CoroTask :: versprechen_Typ :: final_suspend suspend_never zur√ºckgeben w√ºrden (genauer gesagt, w√ºrde dies auf die Frage await_ready zur√ºckgeben w√ºrde true zur√ºckgeben), w√ºrde in diesem Moment der Coroutine-Kontext bereinigt. Da wir dies jedoch nicht getan haben, wird die Verpflichtung zur Kl√§rung des Kontexts auf uns √ºbertragen. Wir werden diesen Kontext im CoroTask-Destruktor l√∂schen. Zu diesem Zeitpunkt ist er bereits sicher. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7. Die Coroutine readAB wird ausgef√ºhrt, das Ergebnis wird daraus erhalten, der Kontext wird gel√∂scht, die Ausf√ºhrung der Lambda-Coroutine wird fortgesetzt ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puh, habe es irgendwie gekl√§rt. </font><font style="vertical-align: inherit;">Erinnern Sie sich, dass wir mit den Methoden ABActor :: getAAsync () und dergleichen eine selbstgeschriebene Struktur zur√ºckgeben? </font><font style="vertical-align: inherit;">Tats√§chlich kann die getAAsync-Methode auch in eine Coroutine umgewandelt werden, indem das aus der Implementierung der Klassen CoroTask und ActorAwaiter gewonnene Wissen kombiniert und wie folgt abgerufen wird:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">CoroTaskActor&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ABActor::getAAsync</span><span class="hljs-params">(Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">co_return</span> makeCoroCallback&lt;GetACallback, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getA, <span class="hljs-keyword">this</span>, _1), returnCallback);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aber das werde ich zur Selbstanalyse lassen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, k√∂nnen Sie mit Hilfe von Coroutine den asynchronen R√ºckrufcode ziemlich gut linearisieren. </font><font style="vertical-align: inherit;">Der Prozess des Schreibens von Hilfstypen und -funktionen scheint zwar noch nicht allzu intuitiv zu sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der gesamte Code ist im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verf√ºgbar </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">. Ich</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
empfehle au√üerdem, dass Sie sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese Vorlesungen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ansehen, um ein vollst√§ndigeres Eintauchen in das Thema zu erhalten </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Vielzahl von Beispielen zum Thema Coroutine desselben Autors finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und Sie k√∂nnen diesen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Vortrag</font></a><font style="vertical-align: inherit;"> auch sehen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de493796/index.html">4 besten Entwurfsmuster f√ºr automatisierte Tests (und 86 weitere)</a></li>
<li><a href="../de493798/index.html">In 1C UX / UI gibt es kein Design</a></li>
<li><a href="../de493800/index.html">Empirische Wahrscheinlichkeit</a></li>
<li><a href="../de493802/index.html">Grundlegendes zur Android-Aktivit√§t von launchMode: Standard, SingleTop, SingleTask und SingleInstance</a></li>
<li><a href="../de493804/index.html">Sprechender Spieler auf Himbeere</a></li>
<li><a href="../de493810/index.html">F√ºnf Jahre intensive Entwicklung des Marktes f√ºr Dokumentenerkennung</a></li>
<li><a href="../de493814/index.html">Wie wir Interviews in Barcelona f√ºhren</a></li>
<li><a href="../de493816/index.html">Git Guide Teilenummer 1: Alles, was Sie √ºber das .git-Verzeichnis wissen m√ºssen</a></li>
<li><a href="../de493818/index.html">Git Guide Teil Nummer 2: Die goldene Regel und andere Grundlagen der Rebase</a></li>
<li><a href="../de493820/index.html">Kubernetes Load Balancing und Skalierung langlebiger Verbindungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>