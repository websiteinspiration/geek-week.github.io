<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍⚖️ 🍯 🙎🏼 Asynchronen Code mit Corutin linearisieren 👩‍✈️ 🐮 😫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sie können nicht nur Coroutine zum Erstellen von Generatoren verwenden, sondern auch versuchen, vorhandenen asynchronen Code zu linearisieren. Versuch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Asynchronen Code mit Corutin linearisieren</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/493808/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98e/c7c/314/98ec7c314c49b57c2d8af8d53508b211.jpg" alt="Bild"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können nicht nur Coroutine zum Erstellen von Generatoren verwenden, sondern auch versuchen, vorhandenen asynchronen Code zu linearisieren. </font><font style="vertical-align: inherit;">Versuchen wir dies anhand eines kleinen Beispiels. </font><font style="vertical-align: inherit;">Nehmen Sie den auf dem Actor-Framework geschriebenen Code und schreiben Sie eine Funktion dieses Codes auf Coroutinen neu. </font><font style="vertical-align: inherit;">Um das Projekt zu erstellen, verwenden wir gcc aus dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutinen-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zweig </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Ziel ist es, Rückrufe von Nudeln zu erhalten:</font></font><br>
<br>
<pre><code class="cpp hljs">    abActor.getA(ABActor::GetACallback([<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
        abActor.getB(ABActor::GetBCallback([a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {<font></font>
            abActor.saveAB(a - b, a + b, ABActor::SaveABCallback([<span class="hljs-keyword">this</span>](){<font></font>
                abActor.getA(ABActor::GetACallback([<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
                    abActor.getB(ABActor::GetBCallback([a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {
                        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
                    }));<font></font>
                }));<font></font>
            }));<font></font>
        }));<font></font>
    }));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Art von:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync();
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync();
<span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync(a - b, a + b);
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newA = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync();
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newB = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync();
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also lasst uns anfangen.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauspieler</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst müssen wir ein einfaches Schauspieler-Framework erstellen. </font><font style="vertical-align: inherit;">Das Erstellen eines vollwertigen Rahmens für Schauspieler ist eine schwierige und große Aufgabe, daher implementieren wir nur eine Art davon. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie zunächst eine Basisklasse:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Actor</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> Task = <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>()&gt;;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~Actor();
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Task &amp;task)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tryRunTask</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt;Task&gt; <span class="hljs-built_in">queue</span>;
    <span class="hljs-keyword">mutable</span> <span class="hljs-built_in">std</span>::mutex mutex;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee ist im Grunde einfach: Wir stellen Aufgaben, die funktionale Objekte sind, in eine Warteschlange, und wenn wir RunTask versuchen, versuchen wir, diese Aufgabe abzuschließen. </font><font style="vertical-align: inherit;">Die Implementierung der Klasse bestätigt unsere Absichten:</font></font><br>
<br>
<pre><code class="cpp hljs">Actor::~Actor() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Actor::addTask</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Task &amp;task)</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>;
    <span class="hljs-built_in">queue</span>.push(task);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Actor::tryRunTask</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>.empty()) {
        <span class="hljs-keyword">return</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">const</span> Task task = <span class="hljs-built_in">queue</span>.front();
    <span class="hljs-built_in">queue</span>.pop();<font></font>
    lock.unlock();<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::invoke(task);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die nächste Klasse ist der "Faden", zu dem unsere Schauspieler gehören werden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Actor</span>;</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActorThread</span> {</span>
<span class="hljs-keyword">public</span>:<font></font>
    ~ActorThread();<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addActor</span><span class="hljs-params">(Actor &amp;actor)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::reference_wrapper&lt;Actor&gt;&gt; actors;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auch hier ist alles einfach: Ganz am Anfang des Programms „binden“ wir unsere Akteure mit der addActor-Methode an den Thread und starten den Thread dann mit der run-Methode.</font></font><br>
<br>
<pre><code class="cpp hljs">ActorThread::~ActorThread() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ActorThread::addActor</span><span class="hljs-params">(Actor &amp;actor)</span> </span>{<font></font>
    actors.emplace_back(actor);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ActorThread::run</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">for</span> (Actor &amp;actor: actors) {<font></font>
            actor.tryRunTask();<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir den Thread starten, treten wir in eine Endlosschleife ein und versuchen, von jedem Akteur eine Aufgabe auszuführen. </font><font style="vertical-align: inherit;">Nicht die beste Lösung, aber für eine Demonstration. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns nun den Vertreter der Schauspielerklasse an:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABActor</span>:</span> <span class="hljs-keyword">public</span> Actor {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> GetACallback = Callback&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> result)&gt;;
    <span class="hljs-keyword">using</span> GetBCallback = Callback&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> result)&gt;;
    <span class="hljs-keyword">using</span> SaveABCallback = Callback&lt;<span class="hljs-keyword">void</span>()&gt;;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getA</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetACallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getB</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetBCallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveAB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> SaveABCallback &amp;callback)</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getAProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetACallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getBProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetBCallback &amp;callback)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveABProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> SaveABCallback &amp;callback)</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Klasse speichert zwei Zahlen in sich selbst - a und b - und gibt auf Anfrage ihre Werte zurück oder überschreibt sie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Rückruf akzeptiert es ein Funktionsobjekt mit den notwendigen Parametern. </font><font style="vertical-align: inherit;">Aber achten wir darauf, dass verschiedene Akteure in verschiedenen Threads gestartet werden können. </font><font style="vertical-align: inherit;">Wenn wir am Ende der Arbeit nur den an die Methode übergebenen Rückruf aufrufen, wird dieser Rückruf im aktuellen ausführbaren Thread aufgerufen und nicht in dem Thread, der unsere Methode aufgerufen und diesen Rückruf erstellt hat. </font><font style="vertical-align: inherit;">Daher müssen wir über den Rückruf einen Wrapper erstellen, der diese Situation löst:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Callback</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Functor&gt;
    <span class="hljs-title">Callback</span><span class="hljs-params">(Actor &amp;sender, <span class="hljs-keyword">const</span> Functor &amp;callback)</span>
        : <span class="hljs-title">sender</span><span class="hljs-params">(sender)</span>
        , <span class="hljs-title">callback</span><span class="hljs-params">(callback)</span>
    </span>{}
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Args&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(Args&amp;&amp; ...args)</span> <span class="hljs-keyword">const</span> </span>{<font></font>
        sender.addTask(<span class="hljs-built_in">std</span>::bind(callback, <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...));<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:<font></font>
    Actor &amp;sender;<font></font>
    <span class="hljs-built_in">std</span>::function&lt;C&gt; callback;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Wrapper merkt sich den ursprünglichen Akteur, und wenn Sie versuchen, sich selbst auszuführen, fügt er der Aufgabenwarteschlange des ursprünglichen Akteurs einfach einen echten Rückruf hinzu. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen sieht die Implementierung der ABActor-Klasse folgendermaßen aus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getA</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetACallback &amp;callback)</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getAProcess, <span class="hljs-keyword">this</span>, callback));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getAProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ABActor::GetACallback &amp;callback)</span> </span>{
    <span class="hljs-built_in">std</span>::invoke(callback, a);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getB</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GetBCallback &amp;callback)</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getBProcess, <span class="hljs-keyword">this</span>, callback));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::getBProcess</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ABActor::GetBCallback &amp;callback)</span> </span>{
    <span class="hljs-built_in">std</span>::invoke(callback, b);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::saveAB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> SaveABCallback &amp;callback)</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::saveABProcess, <span class="hljs-keyword">this</span>, a, b, callback));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ABActor::saveABProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">const</span> ABActor::SaveABCallback &amp;callback)</span> </span>{
    <span class="hljs-keyword">this</span>-&gt;a = a;
    <span class="hljs-keyword">this</span>-&gt;b = b;
    <span class="hljs-built_in">std</span>::invoke(callback);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Schnittstellenmethode der Klasse binden wir die übergebenen Argumente einfach an den entsprechenden „Slot“ der Klasse, erstellen so eine Aufgabe und stellen diese Aufgabe in die Warteschlange der Aufgaben dieser Klasse. </font><font style="vertical-align: inherit;">Wenn der Task-Thread beginnt, die Task auszuführen, ruft er den richtigen „Slot“ auf, der alle erforderlichen Aktionen ausführt, und ruft den Rückruf auf, der wiederum den tatsächlichen Rückruf an die Warteschlange der Aufgabe sendet, die ihn verursacht hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schreiben wir einen Schauspieler, der die ABActor-Klasse verwendet:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABActor</span>;</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WokrerActor</span>:</span> <span class="hljs-keyword">public</span> Actor {
<span class="hljs-keyword">public</span>:<font></font>
    WokrerActor(ABActor &amp;actor)<font></font>
        : abActor(actor)<font></font>
    {}<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">workProcess</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:<font></font>
    ABActor &amp;abActor;<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::work</span><span class="hljs-params">()</span> </span>{<font></font>
    addTask(<span class="hljs-built_in">std</span>::bind(&amp;WokrerActor::workProcess, <span class="hljs-keyword">this</span>));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workProcess</span><span class="hljs-params">()</span> </span>{<font></font>
    abActor.getA(ABActor::GetACallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    }));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und alles zusammen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<font></font>
    ABActor abActor;<font></font>
    <span class="hljs-function">WokrerActor <span class="hljs-title">workerActor</span><span class="hljs-params">(abActor)</span></span>;<font></font>
<font></font>
    ActorThread thread;<font></font>
    thread.addActor(abActor);<font></font>
    thread.addActor(workerActor);<font></font>
<font></font>
    workerActor.work();<font></font>
<font></font>
    thread.run();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Folgen wir der gesamten Codekette. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Anfang erstellen wir die notwendigen Objekte und stellen Verbindungen zwischen ihnen her. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anschließend fügen wir die workProcess-Task zur Warteschlange der Actor Worker-Task hinzu. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Thread startet, findet er unsere Aufgabe in der Warteschlange und beginnt, sie auszuführen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während der Ausführung rufen wir die getA-Methode der ABActor-Klasse auf, stellen die entsprechende Aufgabe in die Warteschlange der ABActor-Klasse und schließen die Ausführung ab. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Nächstes nimmt der Thread die neu erstellte Aufgabe aus der ABActor-Klasse und führt sie aus, was zur Ausführung des getAProcess-Codes führt.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code ruft einen Rückruf auf und übergibt das erforderliche Argument - die Variable a. Da der Rückruf, den er besitzt, ein Wrapper ist, wird tatsächlich ein echter Rückruf mit gefüllten Parametern in die Warteschlange der Worker-Klasse gestellt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wenn der Thread bei der nächsten Iteration des Zyklus unseren Rückruf von der Worker-Klasse abzieht und ausführt, wird die Ausgabe der Zeile "Ergebnis 10" angezeigt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Actor Framework ist eine recht bequeme Möglichkeit, Klassen, die über verschiedene physische Streams verteilt sind, miteinander zu interagieren. Die Besonderheit des Klassendesigns besteht, wie Sie davon überzeugt sein sollten, darin, dass innerhalb jedes einzelnen Akteurs alle Aktionen vollständig und in einem einzigen Thread ausgeführt werden. Der einzige Punkt für die Synchronisation von Streams liegt in den Implementierungsdetails des Actor Frameworks und ist für den Programmierer nicht sichtbar. Auf diese Weise kann ein Programmierer Single-Threaded-Code schreiben, ohne sich Gedanken über das Einpacken von Mutexen und das Verfolgen von Rennsituationen, Deadlocks und anderen Kopfschmerzen machen zu müssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider hat diese Lösung einen Preis. Da das Ergebnis der Ausführung eines anderen Akteurs nur über den Rückruf zugänglich ist, wird der Akteurcode früher oder später wie folgt:</font></font><br>
<br>
<pre><code class="cpp hljs">    abActor.getA(ABActor::GetACallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
        abActor.getB(ABActor::GetBCallback(*<span class="hljs-keyword">this</span>, [a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {<font></font>
            abActor.saveAB(a - b, a + b, ABActor::SaveABCallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](){<font></font>
                abActor.getA(ABActor::GetACallback(*<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> a) {<font></font>
                    abActor.getB(ABActor::GetBCallback(*<span class="hljs-keyword">this</span>, [a, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> b) {
                        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
                    }));<font></font>
                }));<font></font>
            }));<font></font>
        }));<font></font>
    }));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, ob wir dies mit der Innovation von C ++ 20 - Coroutinen vermeiden können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber zuerst werden wir die Einschränkungen spezifizieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich können wir den Code des Actor Frameworks in keiner Weise ändern. </font><font style="vertical-align: inherit;">Außerdem können wir die Signaturen öffentlicher und privater Methoden von Instanzen der Actor-Klasse - ABActor und WorkerActor - nicht ändern. </font><font style="vertical-align: inherit;">Mal sehen, ob wir aus dieser Situation herauskommen können.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutinen. </font><font style="vertical-align: inherit;">Teil 1. Kellner</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptidee von corutin ist, dass beim Erstellen von coroutine ein separater Stapelrahmen für diesen auf dem Heap erstellt wird, von dem wir jederzeit "beenden" können, während die aktuelle Ausführungsposition, Prozessorregister und andere notwendige Informationen beibehalten werden. Dann können wir auch jederzeit zur Ausführung der suspendierten Coroutine zurückkehren und diese bis zum Ende oder bis zur nächsten Suspendierung abschließen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Objekt std :: coroutine_handle &lt;&gt; ist für die Verwaltung dieser Daten verantwortlich, die im Wesentlichen einen Zeiger auf den Stapelrahmen (und andere erforderliche Daten) darstellen und über eine Wiederaufnahmemethode (oder deren Analogon, den Operator ()) verfügen, die uns zur Ausführung der Coroutine zurückführt . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf diesen Daten schreiben wir zuerst die Funktion getAAsync und versuchen dann zu verallgemeinern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben bereits eine Instanz der Klasse std :: coroutine_handle &lt;&gt; coro. Was müssen wir tun? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie müssen die bereits vorhandene Methode ABActor :: getA aufrufen, um die Situation nach Bedarf zu beheben. Zunächst müssen Sie jedoch einen Rückruf für die Methode getA erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erinnern wir uns, dass ein Rückruf an den Rückruf der getA-Methode zurückgegeben wird - das Ergebnis der getA-Methode. Darüber hinaus wird dieser Rückruf im Worker-Thread des Threads aufgerufen. Somit können wir von diesem Rückruf aus sicher die Coroutine ausführen, die nur aus dem Worker-Thread erstellt wurde und die weiterhin ihre Abfolge von Aktionen ausführt. Aber wir müssen auch irgendwo das im Rückruf zurückgegebene Ergebnis speichern, es wird uns natürlich weiter nützlich sein.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> callback = GetACallback(returnCallbackActor, [&amp;value, coro](<span class="hljs-keyword">int</span> result) {<font></font>
        value = result;<font></font>
        <span class="hljs-built_in">std</span>::invoke(coro);<font></font>
 });<font></font>
getA(callback);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen Sie eine Instanz des coroutine_handle-Objekts von irgendwoher nehmen und einen Link, über den Sie unser Ergebnis speichern können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Zukunft werden wir sehen, dass coroutine_handle als Ergebnis des Aufrufs der Funktion an uns übergeben wird. </font><font style="vertical-align: inherit;">Dementsprechend können wir es nur an eine andere Funktion übergeben. </font><font style="vertical-align: inherit;">Bereiten wir diese Funktion als Lambda vor. </font><font style="vertical-align: inherit;">(Wir werden den Link an die Variable übergeben, in der das Ergebnis des Rückrufs an das Unternehmen gespeichert wird.)</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> storeCoroToQueue = [&amp;returnCallbackActor, <span class="hljs-keyword">this</span>](<span class="hljs-keyword">auto</span> &amp;value, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro) {
    <span class="hljs-keyword">auto</span> callback=GetACallback(returnCallbackActor, [&amp;value, coro](<span class="hljs-keyword">int</span> result){<font></font>
        value = result;<font></font>
        <span class="hljs-built_in">std</span>::invoke(coro);<font></font>
    });<font></font>
    getA(callback);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden diese Funktion in der nächsten Klasse speichern.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ActorAwaiterSimple</span> {</span>
    <span class="hljs-keyword">int</span> value;<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> &amp;value,<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; forwardCoroToCallback;<font></font>
<font></font>
    ActorAwaiterSimple(<font></font>
        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span> &amp;value, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; &amp;forwardCoroToCallback<font></font>
    )<font></font>
        : forwardCoroToCallback(forwardCoroToCallback)<font></font>
    {}<font></font>
<font></font>
    ActorAwaiterSimple(<span class="hljs-keyword">const</span> ActorAwaiterSimple &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiterSimple&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> ActorAwaiterSimple &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiterSimple(ActorAwaiterSimple &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiterSimple&amp; <span class="hljs-keyword">operator</span>=(ActorAwaiterSimple &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
<span class="hljs-comment">// ...</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neben dem Funktionsobjekt wird hier auch der Speicher (in Form des Variablenwerts) für den Wert gespeichert, der uns im Rückruf erwartet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da wir den Speicher hier unter dem Wert halten, möchten wir kaum, dass die Instanz dieser Klasse kopiert oder irgendwohin verschoben wird. Stellen Sie sich zum Beispiel vor, jemand hat diese Klasse kopiert, den Wert unter dem Variablenwert in der alten Instanz der Klasse gespeichert und dann versucht, ihn aus der neuen Instanz zu lesen. Und es ist natürlich nicht da, da vor dem Speichern kopiert wurde. Unangenehm. Daher schützen wir uns vor diesen Problemen, indem wir Konstruktoren verbieten und Operatoren kopieren und verschieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns diese Klasse weiter schreiben. Die nächste Methode, die wir brauchen, ist:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Er beantwortet die Frage, ob unsere Bedeutung zur Ausgabe bereit ist. </font><font style="vertical-align: inherit;">Natürlich ist unser Wert beim ersten Anruf noch nicht fertig, und in Zukunft wird uns niemand mehr danach fragen. Geben Sie also einfach false zurück. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die coroutine_handle-Instanz wird in der void await_suspend-Methode (std :: coroutine_handle &lt;&gt; coro) an uns übergeben. Rufen wir also unseren vorbereiteten Funktor darin auf und übergeben dort auch eine Speicherverknüpfung unter value:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro)</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-built_in">std</span>::invoke(forwardCoroToCallback, <span class="hljs-built_in">std</span>::ref(value), coro);<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis der Funktionsausführung wird zum richtigen Zeitpunkt durch Aufrufen der Methode await_resume abgefragt. </font><font style="vertical-align: inherit;">Wir werden dem Antragsteller nicht verweigern:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-keyword">return</span> value;<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt kann unsere Methode mit dem Schlüsselwort co_await aufgerufen werden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was hier passieren wird, stellen wir bereits grob dar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst wird ein Objekt vom Typ ActorAwaiterSimple erstellt, das an die "Eingabe" von co_await übertragen wird. Er fragt zuerst (indem er await_ready aufruft), ob wir versehentlich ein fertiges Ergebnis haben (wir haben es nicht), ruft dann await_suspend auf, übergibt einen Kontext (tatsächlich einen Zeiger auf den aktuellen Coroutine-Stack-Frame) und unterbricht die Ausführung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der ABActor-Akteur in Zukunft seine Arbeit beendet und den Ergebnisrückruf aufruft, wird dieses Ergebnis (bereits im Worker-Thread-Thread) in der einzigen (auf dem Coroutine-Stapel verbleibenden) Instanz von ActorAwaiterSimple gespeichert und die Fortsetzung der Coroutine wird gestartet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Corutin setzt die Ausführung fort, nimmt das gespeicherte Ergebnis durch Aufrufen der Methode await_resume und übergibt dieses Ergebnis an die Variable a</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Derzeit besteht die Einschränkung des aktuellen Kellners darin, dass er nur mit Rückrufen mit einem Parameter vom Typ int arbeiten kann. </font><font style="vertical-align: inherit;">Versuchen wir, die Anwendung von Awaiter zu erweitern:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ActorAwaiter</span> {</span><font></font>
<font></font>
    <span class="hljs-built_in">std</span>::tuple&lt;T...&gt; values;<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-built_in">std</span>::tuple&lt;T...&gt; &amp;values, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; storeHandler;<font></font>
<font></font>
    ActorAwaiter(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-built_in">std</span>::tuple&lt;T...&gt; &amp;values, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt;)&gt; &amp;storeHandler)<font></font>
        : storeHandler(storeHandler)<font></font>
    {}<font></font>
<font></font>
    ActorAwaiter(<span class="hljs-keyword">const</span> ActorAwaiter &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiter&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> ActorAwaiter &amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiter(ActorAwaiter &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    ActorAwaiter&amp; <span class="hljs-keyword">operator</span>=(ActorAwaiter &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro)</span> <span class="hljs-keyword">noexcept</span> </span>{
        <span class="hljs-built_in">std</span>::invoke(storeHandler, <span class="hljs-built_in">std</span>::ref(values), coro);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//   bool B  ,</span>
    <span class="hljs-comment">//   sfinae      </span>
    <span class="hljs-keyword">template</span>&lt;
        <span class="hljs-keyword">bool</span> B=<span class="hljs-literal">true</span>,<span class="hljs-keyword">size_t</span> len=<span class="hljs-keyword">sizeof</span>...(T),<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;len==<span class="hljs-number">0</span> &amp;&amp; B, <span class="hljs-keyword">int</span>&gt;=<span class="hljs-number">0</span><font></font>
    &gt;<font></font>
    <span class="hljs-keyword">void</span> await_resume() <span class="hljs-keyword">noexcept</span> {<font></font>
<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//   bool B  ,</span>
    <span class="hljs-comment">//   sfinae      </span>
    <span class="hljs-keyword">template</span>&lt;
        <span class="hljs-keyword">bool</span> B=<span class="hljs-literal">true</span>,<span class="hljs-keyword">size_t</span> len=<span class="hljs-keyword">sizeof</span>...(T),<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;len==<span class="hljs-number">1</span> &amp;&amp; B, <span class="hljs-keyword">int</span>&gt;=<span class="hljs-number">0</span><font></font>
    &gt;<font></font>
    <span class="hljs-keyword">auto</span> await_resume() <span class="hljs-keyword">noexcept</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">0</span>&gt;(values);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//   bool B  ,</span>
    <span class="hljs-comment">//   sfinae      </span>
    <span class="hljs-keyword">template</span>&lt;
        <span class="hljs-keyword">bool</span> B=<span class="hljs-literal">true</span>,<span class="hljs-keyword">size_t</span> len=<span class="hljs-keyword">sizeof</span>...(T),<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;len!=<span class="hljs-number">1</span> &amp;&amp; len!=<span class="hljs-number">0</span> &amp;&amp; B, <span class="hljs-keyword">int</span>&gt;=<span class="hljs-number">0</span><font></font>
    &gt;<font></font>
    <span class="hljs-built_in">std</span>::tuple&lt;T...&gt; await_resume() <span class="hljs-keyword">noexcept</span> {
        <span class="hljs-keyword">return</span> values;<font></font>
    }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier verwenden wir std :: tuple, um mehrere Variablen gleichzeitig speichern zu können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sfinae wird der Methode await_resume auferlegt, damit nicht in allen Fällen ein Tupel zurückgegeben werden kann. Abhängig von der Anzahl der im Tupel liegenden Werte wird void, genau 1 Argument oder das gesamte Tupel zurückgegeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Wrapper zum Erstellen von Awaiter selbst sehen jetzt folgendermaßen aus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> MakeCallback, <span class="hljs-keyword">typename</span>... ReturnArgs, <span class="hljs-keyword">typename</span> Func&gt;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">makeCoroCallback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Func &amp;func, Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">return</span> [&amp;returnCallback, func](<span class="hljs-keyword">auto</span> &amp;values, <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; coro) {
        <span class="hljs-keyword">auto</span> callback = MakeCallback(returnCallback, [&amp;values, coro](ReturnArgs&amp;&amp; ...result) {<font></font>
            values = <span class="hljs-built_in">std</span>::make_tuple(<span class="hljs-built_in">std</span>::forward&lt;ReturnArgs&gt;(result)...);
            <span class="hljs-built_in">std</span>::invoke(coro);<font></font>
        });<font></font>
        func(callback);<font></font>
    };<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> MakeCallback, <span class="hljs-keyword">typename</span>... ReturnArgs, <span class="hljs-keyword">typename</span> Func&gt;
<span class="hljs-keyword">static</span> ActorAwaiter&lt;ReturnArgs...&gt; <span class="hljs-title">makeActorAwaiter</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Func &amp;func, Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> storeCoroToQueue = makeCoroCallback&lt;MakeCallback, ReturnArgs...&gt;(func, returnCallback);
    <span class="hljs-keyword">return</span> ActorAwaiter&lt;ReturnArgs...&gt;(storeCoroToQueue);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ActorAwaiter&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ABActor::getAAsync</span><span class="hljs-params">(Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">return</span> makeActorAwaiter&lt;GetACallback, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getA, <span class="hljs-keyword">this</span>, _1), returnCallback);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ActorAwaiter&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ABActor::getBAsync</span><span class="hljs-params">(Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">return</span> makeActorAwaiter&lt;GetBCallback, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getB, <span class="hljs-keyword">this</span>, _1), returnCallback);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ActorAwaiter&lt;&gt; <span class="hljs-title">ABActor::saveABAsync</span><span class="hljs-params">(Actor &amp;returnCallback, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> makeActorAwaiter&lt;SaveABCallback&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::saveAB, <span class="hljs-keyword">this</span>, a, b, _1), returnCallback);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun herausfinden, wie der erstellte Typ direkt in Coroutine verwendet wird.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutinen. </font><font style="vertical-align: inherit;">Teil 2. Wiederaufnahmefähig</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus Sicht von C ++ wird eine Funktion, die die Wörter co_await, co_yield oder co_return enthält, als Coroutine betrachtet. Aber auch eine solche Funktion sollte einen bestimmten Typ zurückgeben. Wir waren uns einig, dass wir die Signatur der Funktionen nicht ändern werden (hier meine ich, dass sich der Rückgabetyp auch auf die Signatur bezieht), also müssen wir irgendwie raus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns eine Lambda-Coroutine erstellen und sie von unserer Funktion aus aufrufen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workProcess</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> coroutine = [](WokrerActor &amp;actor) -&gt; ActorResumable {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync(actor, a - b, a + b);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newA = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newB = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
<font></font>
    coroutine(*<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Warum erfassen Sie dies nicht in der Lambda-Erfassungsliste? Dann würde der gesamte darin enthaltene Code etwas einfacher herauskommen. Es kam jedoch vor, dass die Lambda-Coroutinen im Compiler anscheinend noch nicht vollständig unterstützt werden, sodass dieser Code nicht funktioniert.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, </font><font style="vertical-align: inherit;">funktioniert </font><font style="vertical-align: inherit;">unser </font><font style="vertical-align: inherit;">Code </font><font style="vertical-align: inherit;">Der beängstigende Rückrufcode hat sich jetzt in einen hübschen linearen Code verwandelt. </font><font style="vertical-align: inherit;">Wir müssen nur noch die ActorResumable-Klasse erfinden. Schauen </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
wir uns das an.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ActorResumable</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">promise_type</span> {</span>
        <span class="hljs-keyword">using</span> coro_handle = <span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt;;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>{ 
            <span class="hljs-comment">//  ,    ActorResumable   promise_type</span>
            <span class="hljs-keyword">return</span> coro_handle::from_promise(*<span class="hljs-keyword">this</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">//      </span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::suspend_never();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">//      . </span>
            <span class="hljs-comment">// ,     </span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::suspend_never();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">//   ,       </span>
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">terminate</span>();<font></font>
        }<font></font>
    };<font></font>
<font></font>
    ActorResumable(<span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt;) {}<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Pseudocode des aus unserem Lambda erzeugten Corutins sieht ungefähr so ​​aus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">ActorResumable <span class="hljs-title">coro</span><span class="hljs-params">()</span> </span>{<font></font>
    promise_type promise;<font></font>
    ActorResumable retobj = promise.get_return_object();<font></font>
    <span class="hljs-keyword">auto</span> intial_suspend = promise.initial_suspend();
    <span class="hljs-keyword">if</span> (initial_suspend == <span class="hljs-built_in">std</span>::suspend_always)  {
          <span class="hljs-comment">// yield</span><font></font>
    }<font></font>
    <span class="hljs-keyword">try</span> { 
        <span class="hljs-comment">//  .</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    } <span class="hljs-keyword">catch</span>(...) { <font></font>
        promise.unhandled_exception();<font></font>
    }<font></font>
final_suspend:<font></font>
    <span class="hljs-keyword">auto</span> final_suspend = promise.final_suspend();
    <span class="hljs-keyword">if</span> (final_suspend == <span class="hljs-built_in">std</span>::suspend_always)  {
         <span class="hljs-comment">// yield</span>
    } <span class="hljs-keyword">else</span> {<font></font>
         cleanup();<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist nur Pseudocode, einige Dinge werden absichtlich vereinfacht. </font><font style="vertical-align: inherit;">Mal sehen, was passiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst erstellen wir ein Versprechen und ActorResumable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach initial_suspend () machen wir keine Pause, sondern fahren fort. </font><font style="vertical-align: inherit;">Wir beginnen mit der Durchführung des Hauptteils des Programms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir zu co_await kommen, verstehen wir, dass wir innehalten müssen. </font><font style="vertical-align: inherit;">Wir haben diese Situation bereits im vorherigen Abschnitt untersucht. Sie können darauf zurückkommen und sie überprüfen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir die Ausführung fortgesetzt und das Ergebnis auf dem Bildschirm angezeigt haben, endet die Coroutine-Ausführung. </font><font style="vertical-align: inherit;">Wir überprüfen final_suspend und löschen den gesamten Kontext der Coroutine.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutinen. </font><font style="vertical-align: inherit;">Teil 3. Aufgabe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erinnern wir uns, welches Stadium wir jetzt erreicht haben.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workProcess</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> coroutine = [](WokrerActor &amp;actor) -&gt; ActorResumable {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync(actor, a - b, a + b);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newA = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> newB = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
<font></font>
    coroutine(*<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sieht gut aus, aber es ist leicht zu erkennen, dass der Code:</font></font><br>
<br>
<pre><code class="cpp hljs">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> actor.abActor.getAAsync(actor);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> actor.abActor.getBAsync(actor);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 mal wiederholt. </font><font style="vertical-align: inherit;">Ist es möglich, diesen Moment umzugestalten und in eine separate Funktion zu stellen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns skizzieren, wie dies aussehen könnte:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">CoroTask&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">WokrerActor::readAB</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-keyword">co_await</span> abActor.getAAsync2(*<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-keyword">co_await</span> abActor.getBAsync2(*<span class="hljs-keyword">this</span>);
    <span class="hljs-function"><span class="hljs-keyword">co_return</span> <span class="hljs-title">std::make_pair</span><span class="hljs-params">(a, b)</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WokrerActor::workCoroProcess</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> coroutine = [](WokrerActor &amp;actor) -&gt; ActorResumable {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> [a, b] = <span class="hljs-keyword">co_await</span> actor.readAB();
        <span class="hljs-keyword">co_await</span> actor.abActor.saveABAsync2(actor, a - b, a + b);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> [newA, newB] = <span class="hljs-keyword">co_await</span> actor.readAB();
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Result "</span> &lt;&lt; newA &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; newB &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
    };<font></font>
<font></font>
    coroutine(*<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir müssen nur noch den CoroTask-Typ erfinden. </font><font style="vertical-align: inherit;">Lass es uns überlegen. </font><font style="vertical-align: inherit;">Zunächst wird co_return in der Funktion readAB verwendet, was bedeutet, dass CoroTask die Schnittstelle Resumable erfüllen muss. </font><font style="vertical-align: inherit;">Ein Objekt dieser Klasse wird aber auch verwendet, um co_await einer anderen Coroutine einzugeben. </font><font style="vertical-align: inherit;">Dies bedeutet, dass die CoroTask-Klasse auch die Awaitable-Schnittstelle erfüllen muss. </font><font style="vertical-align: inherit;">Implementieren wir diese beiden Schnittstellen in der CoroTask-Klasse:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-keyword">void</span>&gt;<font></font>
struct CoroTask {<font></font>
    struct promise_type {<font></font>
        T result;<font></font>
        <span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; waiter;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> CoroTask{*<span class="hljs-keyword">this</span>};<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">return_value</span><span class="hljs-params">(T value)</span> </span>{<font></font>
            result = value;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">terminate</span>();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-built_in">std</span>::suspend_always <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> {};<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">final_awaiter</span> {</span>
                <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>{}
                <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt; me)</span> </span>{
                    <span class="hljs-keyword">return</span> me.promise().waiter;<font></font>
                }<font></font>
            };<font></font>
            <span class="hljs-keyword">return</span> final_awaiter{};<font></font>
        }<font></font>
    };<font></font>
<font></font>
    CoroTask(CoroTask &amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    CoroTask&amp; <span class="hljs-keyword">operator</span>=(CoroTask&amp;&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    CoroTask(<span class="hljs-keyword">const</span> CoroTask&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
    CoroTask&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> CoroTask&amp;) = <span class="hljs-keyword">delete</span>;<font></font>
<font></font>
    ~CoroTask() {<font></font>
        <span class="hljs-keyword">if</span> (h) {<font></font>
            h.destroy();<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">CoroTask</span><span class="hljs-params">(promise_type &amp; p)</span>
        : <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt;::from_promise(p))</span>
    </span>{}<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">T <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">auto</span> &amp;result = h.promise().result;
        <span class="hljs-keyword">return</span> result;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::coroutine_handle&lt;&gt; waiter)</span> </span>{<font></font>
        h.promise().waiter = waiter;<font></font>
        h.resume();<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::coroutine_handle&lt;promise_type&gt; h;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Ich empfehle dringend, das Hintergrundbild dieses Beitrags zu öffnen. In Zukunft wird dies Ihnen sehr helfen.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns also sehen, was hier passiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Gehen Sie zur Lambda-Coroutine und erstellen Sie sofort die WokrerActor :: readAB-Coroutine. Nachdem wir diese Coroutine erstellt haben, beginnen wir nicht mit der Ausführung (initial_suspend == suspend_always), was uns zwingt, die Coroutine Lambda zu unterbrechen und zurückzukehren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. co_await lambda prüft, ob readAB bereit ist. Das Ergebnis ist nicht bereit (await_ready == false), wodurch es gezwungen wird, seinen Kontext an die CoroTask :: await_suspend-Methode zu übergeben. Dieser Kontext wird in CoroTask gespeichert und die Wiederaufnahme der readAB </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3- </font><font style="vertical-align: inherit;">Coroutinen wird gestartet </font><font style="vertical-align: inherit;">. Nachdem die readAB-Coroutine alle erforderlichen Aktionen ausgeführt hat, erreicht sie die folgende Zeile:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">co_return</span> <span class="hljs-title">std::make_pair</span><span class="hljs-params">(a, b)</span></span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen wird die CoroTask :: Versprechen_Typ :: Rückgabewert-Methode aufgerufen und das erstellte Zahlenpaar in CoroTask :: Versprechen_Typ </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4 </font><font style="vertical-align: inherit;">gespeichert. </font><font style="vertical-align: inherit;">Da die Co_Return-Methode aufgerufen wurde, wird die Ausführung der Coroutine beendet, was bedeutet, dass es Zeit ist, die CoroTask :: Versprechen_Typ :: Final_Suspend-Methode aufzurufen . Diese Methode gibt eine selbstgeschriebene Struktur zurück (vergessen Sie nicht, das Bild zu betrachten), die Sie zwingt, die Methode final_awaiter :: await_suspend aufzurufen, von der der in Schritt 2 gespeicherte Coroutine-Lambda-Kontext zurückgegeben wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum können wir suspend_always nicht einfach hierher zurückgeben? Haben wir im Fall von initial_suspend dieser Klasse Erfolg gehabt? Tatsache ist, dass wir in initial_suspend erfolgreich waren, weil diese Coroutine von unserer Lambda-Coroutine aufgerufen wurde und wir dorthin zurückgekehrt sind. Aber in dem Moment, als wir den Aufruf final_suspend erreichten, wurde unsere Coroutine höchstwahrscheinlich von einem anderen Stapel aus fortgesetzt (insbesondere von dem Lambda, das die Funktion makeCoroCallback vorbereitet hat), und wenn wir suspend_always hier zurückgeben würden, würden wir zu diesem und nicht zur workCoroProcess-Methode zurückkehren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5. Da die Methode final_awaiter :: await_suspend den Kontext an uns zurückgegeben hat, wird das Programm gezwungen, den zurückgegebenen Kontext, dh das Coroutine-Lambda, weiter auszuführen. Da die Ausführung auf den Punkt zurückgekehrt ist:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> [a, b] = <span class="hljs-keyword">co_await</span> actor.readAB();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann müssen wir das gespeicherte Ergebnis isolieren, indem wir die CoroTask :: await_resume-Methode aufrufen. Das Ergebnis wird empfangen, an die Variablen a und b übergeben, und jetzt wird die CoroTask-Instanz zerstört. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6. Die CoroTask-Instanz wurde zerstört, aber was ist mit dem WokrerActor :: readAB-Kontext passiert? Wenn wir von CoroTask :: versprechen_Typ :: final_suspend suspend_never zurückgeben würden (genauer gesagt, würde dies auf die Frage await_ready zurückgeben würde true zurückgeben), würde in diesem Moment der Coroutine-Kontext bereinigt. Da wir dies jedoch nicht getan haben, wird die Verpflichtung zur Klärung des Kontexts auf uns übertragen. Wir werden diesen Kontext im CoroTask-Destruktor löschen. Zu diesem Zeitpunkt ist er bereits sicher. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7. Die Coroutine readAB wird ausgeführt, das Ergebnis wird daraus erhalten, der Kontext wird gelöscht, die Ausführung der Lambda-Coroutine wird fortgesetzt ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puh, habe es irgendwie geklärt. </font><font style="vertical-align: inherit;">Erinnern Sie sich, dass wir mit den Methoden ABActor :: getAAsync () und dergleichen eine selbstgeschriebene Struktur zurückgeben? </font><font style="vertical-align: inherit;">Tatsächlich kann die getAAsync-Methode auch in eine Coroutine umgewandelt werden, indem das aus der Implementierung der Klassen CoroTask und ActorAwaiter gewonnene Wissen kombiniert und wie folgt abgerufen wird:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">CoroTaskActor&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ABActor::getAAsync</span><span class="hljs-params">(Actor &amp;returnCallback)</span> </span>{
    <span class="hljs-keyword">co_return</span> makeCoroCallback&lt;GetACallback, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">std</span>::bind(&amp;ABActor::getA, <span class="hljs-keyword">this</span>, _1), returnCallback);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aber das werde ich zur Selbstanalyse lassen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, können Sie mit Hilfe von Coroutine den asynchronen Rückrufcode ziemlich gut linearisieren. </font><font style="vertical-align: inherit;">Der Prozess des Schreibens von Hilfstypen und -funktionen scheint zwar noch nicht allzu intuitiv zu sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der gesamte Code ist im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verfügbar </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">. Ich</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
empfehle außerdem, dass Sie sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese Vorlesungen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ansehen, um ein vollständigeres Eintauchen in das Thema zu erhalten </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Vielzahl von Beispielen zum Thema Coroutine desselben Autors finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und Sie können diesen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Vortrag</font></a><font style="vertical-align: inherit;"> auch sehen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de493796/index.html">4 besten Entwurfsmuster für automatisierte Tests (und 86 weitere)</a></li>
<li><a href="../de493798/index.html">In 1C UX / UI gibt es kein Design</a></li>
<li><a href="../de493800/index.html">Empirische Wahrscheinlichkeit</a></li>
<li><a href="../de493802/index.html">Grundlegendes zur Android-Aktivität von launchMode: Standard, SingleTop, SingleTask und SingleInstance</a></li>
<li><a href="../de493804/index.html">Sprechender Spieler auf Himbeere</a></li>
<li><a href="../de493810/index.html">Fünf Jahre intensive Entwicklung des Marktes für Dokumentenerkennung</a></li>
<li><a href="../de493814/index.html">Wie wir Interviews in Barcelona führen</a></li>
<li><a href="../de493816/index.html">Git Guide Teilenummer 1: Alles, was Sie über das .git-Verzeichnis wissen müssen</a></li>
<li><a href="../de493818/index.html">Git Guide Teil Nummer 2: Die goldene Regel und andere Grundlagen der Rebase</a></li>
<li><a href="../de493820/index.html">Kubernetes Load Balancing und Skalierung langlebiger Verbindungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>