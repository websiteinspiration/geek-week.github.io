<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游 游 游뚠 Primera impresi칩n de conceptos. 游냗 游닞 游닍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Decid칤 tratar con la nueva caracter칤stica C ++ 20: conceptos. 
 
 Los conceptos (o conceptos , como escribe el Wiki de habla rusa) es una caracter칤sti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Primera impresi칩n de conceptos.</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495396/"><img src="https://habrastorage.org/webt/qd/ja/kc/qdjakcxd4173w_juzv5fx3bf0_o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Decid칤 tratar con la nueva caracter칤stica C ++ 20: conceptos. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los conceptos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conceptos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , como escribe el Wiki de habla rusa) es una caracter칤stica muy interesante y 칰til que ha faltado durante mucho tiempo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esencialmente, est치 escribiendo argumentos de plantilla. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El principal problema de las plantillas antes de C ++ 20 es que podr칤a sustituir cualquier cosa en ellas, incluso algo para lo que no fueron dise침adas. Es decir, el sistema de plantillas estaba completamente sin tipo. Como resultado, se produjeron mensajes de error incre칤blemente largos y completamente ilegibles al pasar el par치metro incorrecto a la plantilla. Intentaron luchar contra esto con la ayuda de diferentes hacks de idiomas, que ni siquiera quiero mencionar (aunque tuve que lidiar).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los conceptos est치n dise침ados para corregir este malentendido. </font><font style="vertical-align: inherit;">A침aden un sistema de mecanograf칤a a las plantillas, y es muy poderoso. </font><font style="vertical-align: inherit;">Y ahora, entendiendo las caracter칤sticas de este sistema, comenc칠 a estudiar los materiales disponibles en Internet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Francamente, estoy un poco sorprendido :) C ++ es un lenguaje ya complicado, pero al menos hay una excusa: sucedi칩. </font><font style="vertical-align: inherit;">La metaprogramaci칩n en plantillas se descubri칩, no se estableci칩, al dise침ar un lenguaje. </font><font style="vertical-align: inherit;">Y luego, al desarrollar las pr칩ximas versiones del lenguaje, se vieron obligados a adaptarse a este "descubrimiento", ya que se hab칤a escrito mucho c칩digo en el mundo. </font><font style="vertical-align: inherit;">Los conceptos son una oportunidad fundamentalmente nueva. </font><font style="vertical-align: inherit;">Y, me parece, ya hay algo de opacidad en su implementaci칩n. </font><font style="vertical-align: inherit;">쯈uiz치s esto es una consecuencia de la necesidad de tener en cuenta la gran cantidad de capacidades heredadas? </font><font style="vertical-align: inherit;">Tratemos de resolverlo ...</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informaci칩n general</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un concepto es una nueva entidad de lenguaje basada en la sintaxis de la plantilla. </font><font style="vertical-align: inherit;">Un concepto tiene un nombre, par치metros y un cuerpo, un predicado que devuelve un valor l칩gico constante (es decir, calculado en la etapa de compilaci칩n) dependiendo de los par치metros del concepto. </font><font style="vertical-align: inherit;">Me gusta esto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt; 
<span class="hljs-keyword">concept</span> Even = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;  <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> FourByte = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
T칠cnicamente, los conceptos son muy similares a las expresiones constexpr de plantilla como bool:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> EvenX = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> FourByteX = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incluso puede usar conceptos en expresiones comunes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Even&lt;<span class="hljs-number">2</span>&gt;; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizando</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea principal de los conceptos es que se pueden usar en lugar del nombre de tipo o las palabras clave de clase en las plantillas. </font><font style="vertical-align: inherit;">Al igual que los metatipos ("tipos para tipos"). </font><font style="vertical-align: inherit;">Por lo tanto, la escritura est치tica se introduce en las plantillas.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;FourByte T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp; t)</span> </span>{}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, si usamos int como par치metro de plantilla, entonces el c칩digo en la gran mayor칤a de los casos se compilar치; </font><font style="vertical-align: inherit;">y si es doble, se emitir치 un mensaje de error breve y comprensible. </font><font style="vertical-align: inherit;">Escritura simple y clara de plantillas, hasta ahora todo est치 bien.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requiere</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es una nueva palabra clave "contextual" C ++ 20 con un doble prop칩sito: requiere cl치usula y requiere expresi칩n. </font><font style="vertical-align: inherit;">Como se mostrar치 m치s adelante, este extra침o ahorro de palabras clave genera cierta confusi칩n.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requiere expresi칩n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, considerar requiere expresi칩n. </font><font style="vertical-align: inherit;">La idea es bastante buena: esta palabra tiene un bloque entre llaves, cuyo c칩digo se eval칰a para su compilaci칩n. </font><font style="vertical-align: inherit;">Es cierto que el c칩digo no debe estar escrito </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en C ++, sino en un lenguaje especial, cercano a C ++, pero que tiene sus propias caracter칤sticas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (esta es la primera rareza, era muy posible hacer solo c칩digo C ++). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si el c칩digo es correcto, la expresi칩n requiere devuelve verdadero, de lo contrario es falso. </font><font style="vertical-align: inherit;">El c칩digo en s칤, por supuesto, nunca entra en la generaci칩n de c칩digo, al igual que las expresiones en sizeof o decltype. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desafortunadamente, la palabra es contextual y funciona solo dentro de las plantillas, es decir, fuera de la plantilla, esto no compila:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b = <span class="hljs-keyword">requires</span> { <span class="hljs-number">3.14</span> &gt;&gt; <span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y en la plantilla, por favor:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> Shiftable = <span class="hljs-keyword">requires</span>(T i) { i&gt;&gt;<span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y funcionar치:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Shiftable&lt;<span class="hljs-keyword">int</span>&gt;; <span class="hljs-comment">// true</span>
<span class="hljs-keyword">bool</span> b2 = Shiftable&lt;<span class="hljs-keyword">double</span>&gt;; <span class="hljs-comment">// false</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El uso principal de requiere expresi칩n es la creaci칩n de conceptos. </font><font style="vertical-align: inherit;">Por ejemplo, as칤 es como puede verificar la presencia de campos y m칠todos en un tipo. </font><font style="vertical-align: inherit;">Un caso muy popular.</font></font><br>
<br>
<pre><code class="plaintext hljs">template &lt;typename T&gt;<font></font>
concept Machine = <font></font>
  requires(T m) {  //   `m` ,   Machine<font></font>
	m.start();     //    `m.start()` <font></font>
	m.stop();      //   `m.stop()`<font></font>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto, todas las variables que pueden ser necesarias en el c칩digo probado (no solo los par치metros de la plantilla) deben declararse entre par칠ntesis requiere expresi칩n. </font><font style="vertical-align: inherit;">Por alguna raz칩n, declarar una variable simplemente no es posible.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La verificaci칩n de tipo en el interior requiere</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu칤 es donde comienzan las diferencias entre el c칩digo requerido y el est치ndar C ++. </font><font style="vertical-align: inherit;">Para verificar los tipos devueltos, se utiliza una sintaxis especial: el objeto se toma entre llaves, se coloca una flecha y despu칠s se escribe un concepto que el tipo debe satisfacer. </font><font style="vertical-align: inherit;">Adem치s, el uso de tipos directamente no est치 permitido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compruebe que el retorno de la funci칩n se puede convertir a int:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">int</span>&gt;;<font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verifique que la funci칩n de retorno sea exactamente int:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::same_as&lt;<span class="hljs-keyword">int</span>&gt;; <font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(std :: same_as y std :: convertible_to son conceptos de la biblioteca est치ndar). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si no encierra una expresi칩n cuyo tipo est치 marcado entre llaves, el compilador no entiende lo que quiere de 칠l e interpreta toda la cadena como una sola expresi칩n que debe verificarse para la compilaci칩n.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requiere adentro requiere</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La palabra clave require tiene un significado especial en el interior requiere expresiones. </font><font style="vertical-align: inherit;">Las expresiones obligatorias anidadas (ya sin llaves) se comprueban no para la compilaci칩n, sino para la igualdad de verdadero o falso. </font><font style="vertical-align: inherit;">Si dicha expresi칩n resulta ser falsa, entonces la expresi칩n que lo encierra resulta ser falsa inmediatamente (y se interrumpe el an치lisis posterior de la compilaci칩n). </font><font style="vertical-align: inherit;">Forma general:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> { <font></font>
  expression;         <span class="hljs-comment">// expression is valid</span>
  <span class="hljs-keyword">requires</span> predicate; <span class="hljs-comment">// predicate is true</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como predicado, por ejemplo, se pueden utilizar conceptos o rasgos de tipo previamente definidos. </font><font style="vertical-align: inherit;">Ejemplo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(Iter it) {
  <span class="hljs-comment">//     (   Iter   *  ++)</span><font></font>
  *it++;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_convertible_v&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al mismo tiempo, se permiten expresiones obligatorias anidadas con c칩digo entre llaves, que se verifica para verificar su validez. </font><font style="vertical-align: inherit;">Sin embargo, si simplemente escribe una expresi칩n requerida dentro de otra, entonces se verificar치 la validez de la expresi칩n anidada (todo en su conjunto, incluida la palabra clave requerida anidada):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">typename</span> T::value_type x) { ++x; }; <span class="hljs-comment">//     , </span>
												<span class="hljs-comment">//     !</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, surgi칩 una forma extra침a con doble:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span> <span class="hljs-params">(<span class="hljs-keyword">typename</span> T::value_type x)</span> </span>{ ++x; }; <span class="hljs-comment">//       "++x"</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu칤 hay una secuencia de escape tan divertida de "requiere". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto, otra combinaci칩n de dos requisitos es esta cl치usula de tiempo (ver m치s abajo) y expresi칩n:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span><span class="hljs-params">(T x, T y)</span> </span>{ <span class="hljs-keyword">bool</span>(x &lt; y); }
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">equivalent</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; x, T <span class="hljs-keyword">const</span>&amp; y)</span>
</span>{
  <span class="hljs-keyword">return</span> !(x &lt; y) &amp;&amp; !(y &lt; x);<font></font>
};</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requiere cl치usula</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora pasemos a otro uso de la palabra requiere: declarar restricciones de un tipo de plantilla. </font><font style="vertical-align: inherit;">Esta es una alternativa al uso de nombres de concepto en lugar de typename. </font><font style="vertical-align: inherit;">En el siguiente ejemplo, los tres m칠todos son equivalentes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  require</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
	<span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span></span>;<font></font>
<font></font>
<span class="hljs-comment">//   require (  )</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span> <span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;</span>;<font></font>
<font></font>
<span class="hljs-comment">//    typename</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;Sortable Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span>  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La declaraci칩n requerida puede usar varios predicados combinados por operadores l칩gicos.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s;<font></font>
 <font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// ok</span>
  fun(s);  <span class="hljs-comment">// compiler error</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, solo invierta una de las condiciones, ya que se produce un error de compilaci칩n:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; !is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu칤 hay un ejemplo que tampoco compilar치</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> !<span class="hljs-function">is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;	</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La raz칩n de esto son las ambig칲edades que surgen al analizar algunas expresiones. </font><font style="vertical-align: inherit;">Por ejemplo, en dicha plantilla:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">bool</span>)&amp;<span class="hljs-function">T::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
no est치 claro a qu칠 atribuir sin firmar: el operador o el prototipo de la funci칩n foo (). </font><font style="vertical-align: inherit;">Por lo tanto, los desarrolladores decidieron que sin par칠ntesis, ya que los argumentos requieren una cl치usula, solo se puede usar un conjunto muy limitado de entidades: literales verdaderos o falsos, nombres de campo del tipo bool del valor del formulario, valor, T :: valor, ns :: trait :: value, Nombres de concepto del tipo Concepto y requiere expresiones. </font><font style="vertical-align: inherit;">Todo lo dem치s debe estar entre par칠ntesis:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!is_trivial_v&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora sobre las caracter칤sticas del predicado en la cl치usula require</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere otro ejemplo.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, require utiliza un rasgo que depende del tipo value_type anidado. </font><font style="vertical-align: inherit;">No se sabe de antemano si un tipo arbitrario tiene un tipo anidado que se puede pasar a la plantilla. </font><font style="vertical-align: inherit;">Si pasa, por ejemplo, un tipo int simple a dicha plantilla, habr치 un error de compilaci칩n, sin embargo, si tenemos dos especializaciones de la plantilla, entonces no habr치 error; </font><font style="vertical-align: inherit;">solo se elegir치 otra especializaci칩n.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"1"</span>; } <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"2"</span>; } <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// displays: "2"</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, la especializaci칩n se descarta no solo cuando el predicado de la cl치usula require devuelve falso, sino tambi칠n cuando resulta ser incorrecto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los par칠ntesis alrededor del predicado son un recordatorio importante de que en la cl치usula require el inverso del predicado no es lo opuesto al predicado en s칤. </font><font style="vertical-align: inherit;">Entonces,</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
significa que el rasgo es correcto y devuelve verdadero. </font><font style="vertical-align: inherit;">Donde</font></font><br>
<br>
<pre><code class="cpp hljs">!is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
significar칤a "el rasgo es correcto y devuelve falso" La </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
inversi칩n l칩gica real del primer predicado NO es ("el rasgo es correcto y devuelve verdadero") == "el rasgo es INCORRECTO o devuelve falso" - esto se logra de una manera un poco m치s compleja - a trav칠s de una definici칩n expl칤cita del concepto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> value_type_valid_and_trivial <font></font>
  = is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;; <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!value_type_valid_and_trivial&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conjunci칩n y disyunci칩n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los operadores l칩gicos de conjunci칩n y disyunci칩n se ven como de costumbre, pero en realidad funcionan un poco diferente que en C ++ normal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere dos fragmentos de c칩digo muy similares. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primero es un predicado sin par칠ntesis:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		|| <span class="hljs-function"><span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo es con par칠ntesis:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> (<span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		 || <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diferencia est치 solo entre par칠ntesis. </font><font style="vertical-align: inherit;">Pero debido a esto, en la segunda plantilla, no hay dos restricciones unidas por una "cl치usula de exigencia", sino una unida por un OR l칩gico habitual. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta diferencia es la siguiente. </font><font style="vertical-align: inherit;">Considera el c칩digo</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::optional&lt;<span class="hljs-keyword">int</span>&gt; oi {};
<span class="hljs-keyword">int</span> i {};<font></font>
fun(i, oi);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu칤 la plantilla se instancia por los tipos int y std :: opcional. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el primer caso, el tipo int :: value_type no es v치lido y, por lo tanto, la primera limitaci칩n no se cumple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero el tipo opcional :: value_type es v치lido, el segundo rasgo devuelve verdadero, y dado que hay un operador OR entre las restricciones, todo el predicado se satisface como un todo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el segundo caso, esta es una expresi칩n 칰nica que contiene un tipo no v치lido, por lo que no es v치lido en general y el predicado no est치 satisfecho. </font><font style="vertical-align: inherit;">Entonces, los corchetes simples cambian imperceptiblemente el significado de lo que est치 sucediendo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En conclusi칩n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, no todas las caracter칤sticas de los conceptos se muestran aqu칤. Simplemente no fui m치s all치. Pero como primera impresi칩n, una idea muy interesante y una implementaci칩n confusa algo extra침a. Y una sintaxis divertida con repeticiones requiere, lo que realmente confunde. 쮿ay realmente tan pocas palabras en ingl칠s que tuvo que usar una palabra para prop칩sitos completamente diferentes? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea con el c칩digo compilado es definitivamente buena. Incluso es algo similar a "cuasi-citando" en macros de sintaxis. 쯇ero vali칩 la pena mezclar la sintaxis especial para verificar los tipos de retorno? En mi humilde opini칩n, para esto simplemente ser칤a necesario hacer una palabra clave por separado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mezcla impl칤cita de los conceptos "verdadero / falso" y "compila / no compila" en un mont칩n, y como resultado, las bromas entre par칠ntesis tambi칠n est치n mal. </font><font style="vertical-align: inherit;">Estos son conceptos diferentes, y deben existir estrictamente en diferentes contextos (aunque entiendo de d칩nde vino, de la regla SFINAE, donde el c칩digo no compilado excluy칩 silenciosamente la especializaci칩n de la consideraci칩n). </font><font style="vertical-align: inherit;">Pero si el objetivo de los conceptos es hacer que el c칩digo sea lo m치s expl칤cito posible, 쯨ali칩 la pena arrastrar todas estas cosas impl칤citas a nuevas caracter칤sticas? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El art칤culo est치 escrito principalmente sobre la base de </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/01/29/requires-expression </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/03/26/requires-clause</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
(hay muchos m치s ejemplos y caracter칤sticas interesantes) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
con mis adiciones de otras fuentes, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
todos los ejemplos se pueden consultar</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wandbox.org</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es495380/index.html">Gran cortafuegos egipcio</a></li>
<li><a href="../es495384/index.html">Mi experiencia de pasant칤a en Microsoft Redmond y obtener una oferta</a></li>
<li><a href="../es495388/index.html">Programa de televisi칩n de la d칠cada de 1970 que se convirti칩 en un antepasado de los eSports</a></li>
<li><a href="../es495390/index.html">Vale la pena probar STM32CubeMonitor</a></li>
<li><a href="../es495392/index.html">C칩mo buscar errores en el front-end: 4 etapas principales</a></li>
<li><a href="../es495398/index.html">Ro.Ri.Re</a></li>
<li><a href="../es495400/index.html">Trabaja con tarjeta SD a trav칠s de la interfaz SPI. Implementaci칩n de VHDL</a></li>
<li><a href="../es495402/index.html">El a침o pasado, finalmente fotografiamos un agujero negro. 쮸hora que?</a></li>
<li><a href="../es495404/index.html">쯃as acciones ca칤das son prometedoras? Analicemos con python</a></li>
<li><a href="../es495408/index.html"># 02 - Y un byte completo no es suficiente ... | La cruz de los cambios.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>