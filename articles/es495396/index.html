<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍿 🆎 🚅 Primera impresión de conceptos. 🐨 📸 📦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Decidí tratar con la nueva característica C ++ 20: conceptos. 
 
 Los conceptos (o conceptos , como escribe el Wiki de habla rusa) es una característi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Primera impresión de conceptos.</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495396/"><img src="https://habrastorage.org/webt/qd/ja/kc/qdjakcxd4173w_juzv5fx3bf0_o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Decidí tratar con la nueva característica C ++ 20: conceptos. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los conceptos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conceptos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , como escribe el Wiki de habla rusa) es una característica muy interesante y útil que ha faltado durante mucho tiempo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esencialmente, está escribiendo argumentos de plantilla. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El principal problema de las plantillas antes de C ++ 20 es que podría sustituir cualquier cosa en ellas, incluso algo para lo que no fueron diseñadas. Es decir, el sistema de plantillas estaba completamente sin tipo. Como resultado, se produjeron mensajes de error increíblemente largos y completamente ilegibles al pasar el parámetro incorrecto a la plantilla. Intentaron luchar contra esto con la ayuda de diferentes hacks de idiomas, que ni siquiera quiero mencionar (aunque tuve que lidiar).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los conceptos están diseñados para corregir este malentendido. </font><font style="vertical-align: inherit;">Añaden un sistema de mecanografía a las plantillas, y es muy poderoso. </font><font style="vertical-align: inherit;">Y ahora, entendiendo las características de este sistema, comencé a estudiar los materiales disponibles en Internet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Francamente, estoy un poco sorprendido :) C ++ es un lenguaje ya complicado, pero al menos hay una excusa: sucedió. </font><font style="vertical-align: inherit;">La metaprogramación en plantillas se descubrió, no se estableció, al diseñar un lenguaje. </font><font style="vertical-align: inherit;">Y luego, al desarrollar las próximas versiones del lenguaje, se vieron obligados a adaptarse a este "descubrimiento", ya que se había escrito mucho código en el mundo. </font><font style="vertical-align: inherit;">Los conceptos son una oportunidad fundamentalmente nueva. </font><font style="vertical-align: inherit;">Y, me parece, ya hay algo de opacidad en su implementación. </font><font style="vertical-align: inherit;">¿Quizás esto es una consecuencia de la necesidad de tener en cuenta la gran cantidad de capacidades heredadas? </font><font style="vertical-align: inherit;">Tratemos de resolverlo ...</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Información general</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un concepto es una nueva entidad de lenguaje basada en la sintaxis de la plantilla. </font><font style="vertical-align: inherit;">Un concepto tiene un nombre, parámetros y un cuerpo, un predicado que devuelve un valor lógico constante (es decir, calculado en la etapa de compilación) dependiendo de los parámetros del concepto. </font><font style="vertical-align: inherit;">Me gusta esto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt; 
<span class="hljs-keyword">concept</span> Even = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;  <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> FourByte = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Técnicamente, los conceptos son muy similares a las expresiones constexpr de plantilla como bool:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> EvenX = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> FourByteX = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incluso puede usar conceptos en expresiones comunes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Even&lt;<span class="hljs-number">2</span>&gt;; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizando</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea principal de los conceptos es que se pueden usar en lugar del nombre de tipo o las palabras clave de clase en las plantillas. </font><font style="vertical-align: inherit;">Al igual que los metatipos ("tipos para tipos"). </font><font style="vertical-align: inherit;">Por lo tanto, la escritura estática se introduce en las plantillas.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;FourByte T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp; t)</span> </span>{}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, si usamos int como parámetro de plantilla, entonces el código en la gran mayoría de los casos se compilará; </font><font style="vertical-align: inherit;">y si es doble, se emitirá un mensaje de error breve y comprensible. </font><font style="vertical-align: inherit;">Escritura simple y clara de plantillas, hasta ahora todo está bien.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requiere</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es una nueva palabra clave "contextual" C ++ 20 con un doble propósito: requiere cláusula y requiere expresión. </font><font style="vertical-align: inherit;">Como se mostrará más adelante, este extraño ahorro de palabras clave genera cierta confusión.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requiere expresión</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, considerar requiere expresión. </font><font style="vertical-align: inherit;">La idea es bastante buena: esta palabra tiene un bloque entre llaves, cuyo código se evalúa para su compilación. </font><font style="vertical-align: inherit;">Es cierto que el código no debe estar escrito </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en C ++, sino en un lenguaje especial, cercano a C ++, pero que tiene sus propias características</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (esta es la primera rareza, era muy posible hacer solo código C ++). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si el código es correcto, la expresión requiere devuelve verdadero, de lo contrario es falso. </font><font style="vertical-align: inherit;">El código en sí, por supuesto, nunca entra en la generación de código, al igual que las expresiones en sizeof o decltype. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desafortunadamente, la palabra es contextual y funciona solo dentro de las plantillas, es decir, fuera de la plantilla, esto no compila:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b = <span class="hljs-keyword">requires</span> { <span class="hljs-number">3.14</span> &gt;&gt; <span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y en la plantilla, por favor:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> Shiftable = <span class="hljs-keyword">requires</span>(T i) { i&gt;&gt;<span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y funcionará:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Shiftable&lt;<span class="hljs-keyword">int</span>&gt;; <span class="hljs-comment">// true</span>
<span class="hljs-keyword">bool</span> b2 = Shiftable&lt;<span class="hljs-keyword">double</span>&gt;; <span class="hljs-comment">// false</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El uso principal de requiere expresión es la creación de conceptos. </font><font style="vertical-align: inherit;">Por ejemplo, así es como puede verificar la presencia de campos y métodos en un tipo. </font><font style="vertical-align: inherit;">Un caso muy popular.</font></font><br>
<br>
<pre><code class="plaintext hljs">template &lt;typename T&gt;<font></font>
concept Machine = <font></font>
  requires(T m) {  //   `m` ,   Machine<font></font>
	m.start();     //    `m.start()` <font></font>
	m.stop();      //   `m.stop()`<font></font>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto, todas las variables que pueden ser necesarias en el código probado (no solo los parámetros de la plantilla) deben declararse entre paréntesis requiere expresión. </font><font style="vertical-align: inherit;">Por alguna razón, declarar una variable simplemente no es posible.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La verificación de tipo en el interior requiere</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí es donde comienzan las diferencias entre el código requerido y el estándar C ++. </font><font style="vertical-align: inherit;">Para verificar los tipos devueltos, se utiliza una sintaxis especial: el objeto se toma entre llaves, se coloca una flecha y después se escribe un concepto que el tipo debe satisfacer. </font><font style="vertical-align: inherit;">Además, el uso de tipos directamente no está permitido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compruebe que el retorno de la función se puede convertir a int:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">int</span>&gt;;<font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verifique que la función de retorno sea exactamente int:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::same_as&lt;<span class="hljs-keyword">int</span>&gt;; <font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(std :: same_as y std :: convertible_to son conceptos de la biblioteca estándar). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si no encierra una expresión cuyo tipo está marcado entre llaves, el compilador no entiende lo que quiere de él e interpreta toda la cadena como una sola expresión que debe verificarse para la compilación.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requiere adentro requiere</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La palabra clave require tiene un significado especial en el interior requiere expresiones. </font><font style="vertical-align: inherit;">Las expresiones obligatorias anidadas (ya sin llaves) se comprueban no para la compilación, sino para la igualdad de verdadero o falso. </font><font style="vertical-align: inherit;">Si dicha expresión resulta ser falsa, entonces la expresión que lo encierra resulta ser falsa inmediatamente (y se interrumpe el análisis posterior de la compilación). </font><font style="vertical-align: inherit;">Forma general:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> { <font></font>
  expression;         <span class="hljs-comment">// expression is valid</span>
  <span class="hljs-keyword">requires</span> predicate; <span class="hljs-comment">// predicate is true</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como predicado, por ejemplo, se pueden utilizar conceptos o rasgos de tipo previamente definidos. </font><font style="vertical-align: inherit;">Ejemplo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(Iter it) {
  <span class="hljs-comment">//     (   Iter   *  ++)</span><font></font>
  *it++;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_convertible_v&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al mismo tiempo, se permiten expresiones obligatorias anidadas con código entre llaves, que se verifica para verificar su validez. </font><font style="vertical-align: inherit;">Sin embargo, si simplemente escribe una expresión requerida dentro de otra, entonces se verificará la validez de la expresión anidada (todo en su conjunto, incluida la palabra clave requerida anidada):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">typename</span> T::value_type x) { ++x; }; <span class="hljs-comment">//     , </span>
												<span class="hljs-comment">//     !</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, surgió una forma extraña con doble:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span> <span class="hljs-params">(<span class="hljs-keyword">typename</span> T::value_type x)</span> </span>{ ++x; }; <span class="hljs-comment">//       "++x"</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí hay una secuencia de escape tan divertida de "requiere". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto, otra combinación de dos requisitos es esta cláusula de tiempo (ver más abajo) y expresión:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span><span class="hljs-params">(T x, T y)</span> </span>{ <span class="hljs-keyword">bool</span>(x &lt; y); }
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">equivalent</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; x, T <span class="hljs-keyword">const</span>&amp; y)</span>
</span>{
  <span class="hljs-keyword">return</span> !(x &lt; y) &amp;&amp; !(y &lt; x);<font></font>
};</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requiere cláusula</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora pasemos a otro uso de la palabra requiere: declarar restricciones de un tipo de plantilla. </font><font style="vertical-align: inherit;">Esta es una alternativa al uso de nombres de concepto en lugar de typename. </font><font style="vertical-align: inherit;">En el siguiente ejemplo, los tres métodos son equivalentes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  require</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
	<span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span></span>;<font></font>
<font></font>
<span class="hljs-comment">//   require (  )</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span> <span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;</span>;<font></font>
<font></font>
<span class="hljs-comment">//    typename</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;Sortable Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span>  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La declaración requerida puede usar varios predicados combinados por operadores lógicos.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s;<font></font>
 <font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// ok</span>
  fun(s);  <span class="hljs-comment">// compiler error</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, solo invierta una de las condiciones, ya que se produce un error de compilación:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; !is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí hay un ejemplo que tampoco compilará</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> !<span class="hljs-function">is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;	</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La razón de esto son las ambigüedades que surgen al analizar algunas expresiones. </font><font style="vertical-align: inherit;">Por ejemplo, en dicha plantilla:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">bool</span>)&amp;<span class="hljs-function">T::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
no está claro a qué atribuir sin firmar: el operador o el prototipo de la función foo (). </font><font style="vertical-align: inherit;">Por lo tanto, los desarrolladores decidieron que sin paréntesis, ya que los argumentos requieren una cláusula, solo se puede usar un conjunto muy limitado de entidades: literales verdaderos o falsos, nombres de campo del tipo bool del valor del formulario, valor, T :: valor, ns :: trait :: value, Nombres de concepto del tipo Concepto y requiere expresiones. </font><font style="vertical-align: inherit;">Todo lo demás debe estar entre paréntesis:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!is_trivial_v&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora sobre las características del predicado en la cláusula require</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere otro ejemplo.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, require utiliza un rasgo que depende del tipo value_type anidado. </font><font style="vertical-align: inherit;">No se sabe de antemano si un tipo arbitrario tiene un tipo anidado que se puede pasar a la plantilla. </font><font style="vertical-align: inherit;">Si pasa, por ejemplo, un tipo int simple a dicha plantilla, habrá un error de compilación, sin embargo, si tenemos dos especializaciones de la plantilla, entonces no habrá error; </font><font style="vertical-align: inherit;">solo se elegirá otra especialización.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"1"</span>; } <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"2"</span>; } <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// displays: "2"</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, la especialización se descarta no solo cuando el predicado de la cláusula require devuelve falso, sino también cuando resulta ser incorrecto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los paréntesis alrededor del predicado son un recordatorio importante de que en la cláusula require el inverso del predicado no es lo opuesto al predicado en sí. </font><font style="vertical-align: inherit;">Entonces,</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
significa que el rasgo es correcto y devuelve verdadero. </font><font style="vertical-align: inherit;">Donde</font></font><br>
<br>
<pre><code class="cpp hljs">!is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
significaría "el rasgo es correcto y devuelve falso" La </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
inversión lógica real del primer predicado NO es ("el rasgo es correcto y devuelve verdadero") == "el rasgo es INCORRECTO o devuelve falso" - esto se logra de una manera un poco más compleja - a través de una definición explícita del concepto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> value_type_valid_and_trivial <font></font>
  = is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;; <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!value_type_valid_and_trivial&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conjunción y disyunción</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los operadores lógicos de conjunción y disyunción se ven como de costumbre, pero en realidad funcionan un poco diferente que en C ++ normal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere dos fragmentos de código muy similares. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primero es un predicado sin paréntesis:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		|| <span class="hljs-function"><span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo es con paréntesis:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> (<span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		 || <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diferencia está solo entre paréntesis. </font><font style="vertical-align: inherit;">Pero debido a esto, en la segunda plantilla, no hay dos restricciones unidas por una "cláusula de exigencia", sino una unida por un OR lógico habitual. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta diferencia es la siguiente. </font><font style="vertical-align: inherit;">Considera el código</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::optional&lt;<span class="hljs-keyword">int</span>&gt; oi {};
<span class="hljs-keyword">int</span> i {};<font></font>
fun(i, oi);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí la plantilla se instancia por los tipos int y std :: opcional. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el primer caso, el tipo int :: value_type no es válido y, por lo tanto, la primera limitación no se cumple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero el tipo opcional :: value_type es válido, el segundo rasgo devuelve verdadero, y dado que hay un operador OR entre las restricciones, todo el predicado se satisface como un todo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el segundo caso, esta es una expresión única que contiene un tipo no válido, por lo que no es válido en general y el predicado no está satisfecho. </font><font style="vertical-align: inherit;">Entonces, los corchetes simples cambian imperceptiblemente el significado de lo que está sucediendo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En conclusión</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, no todas las características de los conceptos se muestran aquí. Simplemente no fui más allá. Pero como primera impresión, una idea muy interesante y una implementación confusa algo extraña. Y una sintaxis divertida con repeticiones requiere, lo que realmente confunde. ¿Hay realmente tan pocas palabras en inglés que tuvo que usar una palabra para propósitos completamente diferentes? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea con el código compilado es definitivamente buena. Incluso es algo similar a "cuasi-citando" en macros de sintaxis. ¿Pero valió la pena mezclar la sintaxis especial para verificar los tipos de retorno? En mi humilde opinión, para esto simplemente sería necesario hacer una palabra clave por separado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mezcla implícita de los conceptos "verdadero / falso" y "compila / no compila" en un montón, y como resultado, las bromas entre paréntesis también están mal. </font><font style="vertical-align: inherit;">Estos son conceptos diferentes, y deben existir estrictamente en diferentes contextos (aunque entiendo de dónde vino, de la regla SFINAE, donde el código no compilado excluyó silenciosamente la especialización de la consideración). </font><font style="vertical-align: inherit;">Pero si el objetivo de los conceptos es hacer que el código sea lo más explícito posible, ¿valió la pena arrastrar todas estas cosas implícitas a nuevas características? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El artículo está escrito principalmente sobre la base de </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/01/29/requires-expression </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/03/26/requires-clause</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
(hay muchos más ejemplos y características interesantes) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
con mis adiciones de otras fuentes, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
todos los ejemplos se pueden consultar</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wandbox.org</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es495380/index.html">Gran cortafuegos egipcio</a></li>
<li><a href="../es495384/index.html">Mi experiencia de pasantía en Microsoft Redmond y obtener una oferta</a></li>
<li><a href="../es495388/index.html">Programa de televisión de la década de 1970 que se convirtió en un antepasado de los eSports</a></li>
<li><a href="../es495390/index.html">Vale la pena probar STM32CubeMonitor</a></li>
<li><a href="../es495392/index.html">Cómo buscar errores en el front-end: 4 etapas principales</a></li>
<li><a href="../es495398/index.html">Ro.Ri.Re</a></li>
<li><a href="../es495400/index.html">Trabaja con tarjeta SD a través de la interfaz SPI. Implementación de VHDL</a></li>
<li><a href="../es495402/index.html">El año pasado, finalmente fotografiamos un agujero negro. ¿Ahora que?</a></li>
<li><a href="../es495404/index.html">¿Las acciones caídas son prometedoras? Analicemos con python</a></li>
<li><a href="../es495408/index.html"># 02 - Y un byte completo no es suficiente ... | La cruz de los cambios.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>