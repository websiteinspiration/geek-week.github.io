<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎵 🤹 🍎 高速かつ簡単なボリュームレンダリングアルゴリズム 🔨 🔲 😁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私は最近、シンプルなボリュームレンダリングを行う小さなShaderToyを書いた後、その作業を説明する投稿を公開することにしました。インタラクティブなShaderToy自体はここで見ることができます。電話またはラップトップから読んでいる場合は、このクイックバージョンをご覧になることをお勧めします。S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>高速かつ簡単なボリュームレンダリングアルゴリズム</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500914/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/8r/iy/wc/8riywca1jhipnzh4e3ycjritfec.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は最近、シンプルなボリュームレンダリングを行う小さなShaderToyを書いた後、その作業を説明する投稿を公開することにしました。</font><font style="vertical-align: inherit;">インタラクティブなShaderToy自体は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で見ることができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">電話またはラップトップから読んでいる場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クイックバージョン</font><font style="vertical-align: inherit;">をご覧になることをお勧めし</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">ShaderToyのパフォーマンスの概要を理解するのに役立つコードスニペットを投稿に含めましたが、詳細はすべてではありません。</font><font style="vertical-align: inherit;">さらに詳しく知りたい場合は、ShaderToyコードを確認することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のShaderToyには3つの主要なタスクがありました：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リアルタイム実行</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シンプルさ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物理的な正確さ（...またはそのようなもの）</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この空のコードシーンから始めます。</font><font style="vertical-align: inherit;">実装はあまり興味深いものではないため、ここでは詳しく説明しませんが、どこから始めればよいかを簡単に説明します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不透明なオブジェクトのレイトレーシング。</font><font style="vertical-align: inherit;">すべてのオブジェクトは、光線との単純な交差（1つの平面と3つの球）を持つプリミティブです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライティングを計算するために、Phongシェーディングが使用され、3つの球形光源では、カスタムの光減衰係数が使用されます。</font><font style="vertical-align: inherit;">平面のみを照明するため、影の光線は必要ありません。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba8/4dc/f82/ba84dcf8277762a067454fb786d266be.jpg" alt="ShaderToyスクリーンショット"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ボリュームを不透明なシーンとミックスする別のパッセージとしてレンダリングします。</font><font style="vertical-align: inherit;">これは、すべてのリアルタイムレンダリングエンジンが不透明および半透明のサーフェスを個別に処理する方法に似ています。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート1：ボリュームのシミュレーション</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、最初に、ボリュームレンダリングを開始する前に、これと同じボリュームが必要です。ボリュームをシミュレートするために、符号付き距離関数（SDF）を使用することにしました。なぜ距離場の関数は正確に？私はアーティストではありませんが、数行のコードで非常に有機的なフォームを作成できます。 Inigo Kilesはすでにそれらについて素晴らしい説明をしているので、距離記号の機能については記号で詳しく説明しません。あなたが興味があるならば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そこに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">符号距離と修飾子の異なるFUNCのションの偉大なリストです。そして、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここでは</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらのraymarchingのSDFについての別の記事です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シンプルなものから始めて、ここに球を追加します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c03/5c4/536/c035c45368ef0cd0e232041b4ca2eec4.jpg" alt="ShaderToyスクリーンショット"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、別の球を追加し、滑らかな共役を使用して球の距離関数をマージします。</font><font style="vertical-align: inherit;">このコードはInigoページから直接取得しましたが、わかりやすくするために、ここに挿入します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Taken from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdSmoothUnion</span><span class="hljs-params">( <span class="hljs-keyword">float</span> d1, <span class="hljs-keyword">float</span> d2, <span class="hljs-keyword">float</span> k )</span> 
</span>{
    <span class="hljs-keyword">float</span> h = clamp( <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>*(d2-d1)/k, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> );
    <span class="hljs-keyword">return</span> mix( d2, d1, h ) - k*h*(<span class="hljs-number">1.0</span>-h); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スムーズペアリングは非常に強力なツールです。単純な形状といくつか組み合わせるだけで、非常に興味深いものを得ることができます。</font><font style="vertical-align: inherit;">私の滑らかな共役球の多くは次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/c3c/4b4/ddcc3c4b4f6d38d509b69cae63088c4a.jpg" alt="ShaderToyスクリーンショット"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで、ティアドロップ型のものが得られましたが、ドロップではなく雲のようなものが必要です。 SDFの優れた機能は、SDFに少しのノイズを追加するだけで、表面を簡単に歪めることができることです。そこで、位置を使用してフラクタルブラウン運動（fBM）オーバーヘッドを追加し、ノイズ関数にインデックスを付けます。 Inigo Kilesも</font><font style="vertical-align: inherit;">、fBMノイズに関する</font><font style="vertical-align: inherit;">素晴らしい</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">このトピックを取り上げました</font><font style="vertical-align: inherit;">。 fBMノイズを重ねた画像は次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a47/bd6/bbd/a47bd6bbd487a37bc5e07a8f65e6436d.jpg" alt="ShaderToyスクリーンショット"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いいね！</font><font style="vertical-align: inherit;">fBMノイズのおかげで、オブジェクトは突然、はるかに興味深く見え始めました！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ボリュームが地球の平面と相互作用するような錯覚を作成する必要があります。</font><font style="vertical-align: inherit;">これを行うために、グラウンドプレーンの少し下に符号付きプレーンの距離を追加し、スムーズペアリングと非常にアグレッシブなペアリング値（パラメーターk）の組み合わせを再利用しました。</font><font style="vertical-align: inherit;">その後、私たちはこの写真を得ました：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/7e9/863/8d27e9863fb9637575e23a4cf593f90e.jpg" alt="ShaderToyスクリーンショット"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のタッチは、時間の経過に伴うfBMノイズのxzインデックスの変化です。そのため、ボリュームは渦巻く霧のように見えます。</font><font style="vertical-align: inherit;">移動中、とても​​よく見えます！</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/2d6/6fa/1672d66fa4b2760e9e57bd6062281cc2.gif" alt="ShaderToyスクリーンショット"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
雲のようなものができました。</font><font style="vertical-align: inherit;">SDF計算コードも非常にコンパクトです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">QueryVolumetricDistanceField</span><span class="hljs-params">( in vec3 pos)</span>
</span>{    <font></font>
    vec3 fbmCoord = (pos + <span class="hljs-number">2.0</span> * vec3(iTime, <span class="hljs-number">0.0</span>, iTime)) / <span class="hljs-number">1.5f</span>;
    <span class="hljs-keyword">float</span> sdfValue = sdSphere(pos, vec3(<span class="hljs-number">-8.0</span>, <span class="hljs-number">2.0</span> + <span class="hljs-number">20.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">-1</span>), <span class="hljs-number">5.6</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue,sdSphere(pos, vec3(<span class="hljs-number">8.0</span>, <span class="hljs-number">8.0</span> + <span class="hljs-number">12.0</span> * <span class="hljs-built_in">cos</span>(iTime), <span class="hljs-number">3</span>), <span class="hljs-number">5.6</span>), <span class="hljs-number">3.0f</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdSphere(pos, vec3(<span class="hljs-number">5.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">3.0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">8.0</span>), <span class="hljs-number">3.0</span>) + <span class="hljs-number">7.0</span> * fbm_4(fbmCoord / <span class="hljs-number">3.2</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdPlane(pos + vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0</span>)), <span class="hljs-number">22.0</span>);
    <span class="hljs-keyword">return</span> sdfValue;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは不透明なオブジェクトをレンダリングするだけです。美しい壮大な霧が必要です！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不透明なオブジェクトではなく、ボリュームの形でそれをどのようにレンダリングしますか？まず、シミュレーションする物理学について話しましょう。ボリュームは、空間の特定の領域にある膨大な数のパーティクルです。そして、「巨大」とは、「巨大」を意味します。今日のこれらの各パーティクルのモデリングは、オフラインレンダリングであっても不可能です。この良い例は、火、霧、雲です。厳密に言えば、すべてがボリュームですが、計算速度を上げるために、これに目を閉じて、そうでないふりをすることは簡単です。これらの粒子の蓄積を、通常はある種の3Dグリッド（または、たとえばOpenVDBなどのより複雑なもの）に格納される密度値として表します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
光がボリュームを通過するとき、光と粒子の衝突で2つの現象が発生する可能性があります。</font><font style="vertical-align: inherit;">散乱して反対方向に進むか、光の一部が粒子に吸収されて溶解するかのいずれかです。</font><font style="vertical-align: inherit;">リアルタイム実行要件に準拠するために、いわゆる単一散乱を実行します。</font><font style="vertical-align: inherit;">これは次のことを意味します。光が粒子に衝突してカメラに向かって飛ぶとき、光は一度だけ散乱すると仮定します。</font><font style="vertical-align: inherit;">つまり、遠くにあるオブジェクトが通常より曖昧に見えるフォグなどの多重散乱の影響をシミュレートすることはできません。</font><font style="vertical-align: inherit;">しかし、私たちのシステムではこれで十分です。</font><font style="vertical-align: inherit;">レイマーチング時のシングルスキャッタリングは次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2d/19e/00f/f2d19e00fa758b0addc4ca447c0b024e.jpg" alt="ShaderToyスクリーンショット"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのための疑似コードは次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> n steps along the camera ray:<font></font>
   Calculate what % <span class="hljs-function">of your ray hit <span class="hljs-title">particles</span> <span class="hljs-params">(i.e. were absorbed)</span> <span class="hljs-keyword">and</span> needs lighting
   <span class="hljs-keyword">for</span> m lights:
      <span class="hljs-keyword">for</span> k steps towards the light:
         Calculate % of light that were absorbe in <span class="hljs-keyword">this</span> step
      Calculate lighting based on how much light is visible
Blend results on top of opaque objects pass based on % of your ray that made it through the volume</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、複雑さO（n * m * k）の計算を扱っています。</font><font style="vertical-align: inherit;">したがって、GPUは一生懸命働く必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吸収を計算します</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、カメラビームに沿ったボリューム内の光の吸収を見てみましょう（つまり、まだ光源の方向にレイマーチを実行していません）。</font><font style="vertical-align: inherit;">これを行うには、2つのアクションが必要です。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボリューム内でレイマーチングを実行する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各ステップで吸収/照明を計算します</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ポイントで吸収される光の量を計算するために</font><font style="vertical-align: inherit;">、材料を通過するときの光の減衰を表す</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブーゲール–ランバート–ビールの法則</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">し</font></a><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">計算は驚くほど簡単です：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">BeerLambert</span><span class="hljs-params">(<span class="hljs-keyword">float</span> absorptionCoefficient, <span class="hljs-keyword">float</span> distanceTraveled)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span>(-absorptionCoefficient * distanceTraveled);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
吸収係数は材料パラメータです。</font><font style="vertical-align: inherit;">たとえば、水などの透明なボリュームでは、この値は低くなり、ミルクなどの厚いものでは、係数は高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ボリュームレイマーチングを実行するには、ビームに沿って固定サイズのステップを実行し、すべてのステップで吸収を得ます。</font><font style="vertical-align: inherit;">球をトレースするなど、何かを速くする代わりに固定ステップを実行する理由が理解できない場合もありますが、ボリューム内の密度が不均一であることを覚えている場合は、すべてが明確になります。</font><font style="vertical-align: inherit;">以下は、レイマーチングと累積吸収コードです。</font><font style="vertical-align: inherit;">一部の変数はこのコードスニペットの範囲外であるため、ShaderToyの完全な実装を確認してください。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> opaqueVisiblity = <span class="hljs-number">1.0f</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> marchSize = <span class="hljs-number">0.6f</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_VOLUME_MARCH_STEPS; i++) {<font></font>
	volumeDepth += marchSize;<font></font>
	<span class="hljs-keyword">if</span>(volumeDepth &gt; opaqueDepth) <span class="hljs-keyword">break</span>;<font></font>
	<font></font>
	vec3 position = rayOrigin + volumeDepth*rayDirection;<font></font>
	<span class="hljs-keyword">bool</span> isInVolume = QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0f</span>;
	<span class="hljs-keyword">if</span>(isInVolume) 	{
		<span class="hljs-keyword">float</span> previousOpaqueVisiblity = opaqueVisiblity;<font></font>
		opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
		<span class="hljs-keyword">float</span> absorptionFromMarch = previousOpaqueVisiblity - opaqueVisiblity;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> lightIndex = <span class="hljs-number">0</span>; lightIndex &lt; NUM_LIGHTS; lightIndex++) {
			<span class="hljs-keyword">float</span> lightDistance = length((GetLight(lightIndex).Position - position));<font></font>
			vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance);  <font></font>
			volumetricColor += absorptionFromMarch * volumeAlbedo * lightColor;<font></font>
		}<font></font>
		volumetricColor += absorptionFromMarch * volumeAlbedo * GetAmbientLight();<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これは私たちがこれで得るものです：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/14e/a86/c8714ea862797c656d9c64105c7befed.jpg" alt="ShaderToyスクリーンショット"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャンディーフロスみたい！</font><font style="vertical-align: inherit;">おそらくいくつかのエフェクトではこれで十分でしょう！</font><font style="vertical-align: inherit;">しかし、私たちは自己の陰に欠けています。</font><font style="vertical-align: inherit;">光はボリュームのすべての部分に等しく到達します。</font><font style="vertical-align: inherit;">しかし、これは物理的に正しくありません。レンダリングされたポイントと光源の間のボリュームのサイズに応じて、異なる量の入射光を受け取ります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルフシャドウイング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはすでに最も難しいことをしました。</font><font style="vertical-align: inherit;">カメラの光線に沿った吸収を計算するために行ったのと同じことをする必要がありますが、光線に沿ったものだけです。</font><font style="vertical-align: inherit;">各ポイントに到達する光の量を計算するコードは基本的にコードの繰り返しですが、それを複製することは、必要な再帰を得るためにHLSLをハッキングするよりも簡単です。</font><font style="vertical-align: inherit;">だからここにそれがどのように見えるかです：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetLightVisiblity</span><span class="hljs-params">(in vec3 rayOrigin, in vec3 rayDirection, in <span class="hljs-keyword">float</span> maxT, in <span class="hljs-keyword">int</span> maxSteps, in <span class="hljs-keyword">float</span> marchSize)</span> </span>{
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0.0f</span>;
    <span class="hljs-keyword">float</span> lightVisiblity = <span class="hljs-number">1.0f</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxSteps; i++) {                       <font></font>
        t += marchSize;<font></font>
        <span class="hljs-keyword">if</span>(t &gt; maxT) <span class="hljs-keyword">break</span>;<font></font>
<font></font>
        vec3 position = rayOrigin + t*rayDirection;<font></font>
        <span class="hljs-keyword">if</span>(QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0</span>) {<font></font>
            lightVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> lightVisiblity;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自己シャドウイングを追加すると、次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/6e0/96e/a4f6e096e2250a9aa17594b59cc7e25d.jpg" alt="ShaderToyスクリーンショット"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エッジを柔らかくする</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現時点では、私はすでにボリュームをかなり気に入っています。</font><font style="vertical-align: inherit;">私は彼をThe CoalitionのVFX部門の有能なリーダーであるJames Sharpに見せました。</font><font style="vertical-align: inherit;">彼はすぐに、ボリュームのエッジが鋭すぎるように見えることに気づきました。</font><font style="vertical-align: inherit;">そしてこれは絶対に本当です-雲のようなオブジェクトは常にそれらの周りのスペースに散らばっているので、それらのエッジはボリュームの周りの空のスペースと混ざり、非常に滑らかなエッジの作成につながるはずです。</font><font style="vertical-align: inherit;">ジェームズは私に素晴らしいアイデアを提供しました-エッジにどれだけ近いかによって密度を減らすことです。</font><font style="vertical-align: inherit;">そして、私たちは記号付きの距離関数で作業しているので、実装は非常に簡単です！</font><font style="vertical-align: inherit;">そこで、ボリュームの任意の時点で密度を要求するために使用できる関数を追加してみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">return</span> sdfMultiplier;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、それを単純に吸収値に折りたたみます。</font></font><br>
<br>
<pre><code class="cpp hljs">opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position), marchSize);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、それはそれがどのように見えるかです：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/7b3/ab5/7887b3ab53afcfc69c33e12bd473de9d.gif" alt="ShaderToyスクリーンショット"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">密度関数</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで密度関数ができたので、ボリュームに小さなノイズを簡単に追加して、ボリュームに細部と素晴らしさを追加できます。</font><font style="vertical-align: inherit;">この場合、ボリュームの形状を調整するために使用したfBM関数を再利用します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
   <span class="hljs-keyword">return</span> sdfMultiplier * <span class="hljs-built_in">abs</span>(fbm_4(position / <span class="hljs-number">6.0</span>) + <span class="hljs-number">0.5</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、私たちは以下を得ました：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b9/c0a/1e6/1b9c0a1e68d020206e9567b9044317d9.jpg" alt="ShaderToyスクリーンショット"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不透明なセルフシャドウ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ボリュームはすでにかなりきれいに見えます！</font><font style="vertical-align: inherit;">しかし、それでも少しの光が漏れています。</font><font style="vertical-align: inherit;">ここでは、ボリュームが確実に吸収するはずの場所に緑色が浸透する様子を示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/e16/dbf/051e16dbfa5d9f307c635a6293dcc69f.jpg" alt="ShaderToyスクリーンショット"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ボリュームがレンダリングされる前に不透明なオブジェクトがレンダリングされるために発生し、ボリュームによって発生するシェーディングは考慮されません。</font><font style="vertical-align: inherit;">これは非常に簡単に修正できます。シェーディングの計算に使用できるGetLightVisiblity関数があるため、不透明なオブジェクトを照らすために呼び出すだけです。</font><font style="vertical-align: inherit;">以下を取得します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cda/1c4/99d/cda1c499d05729265b374378e3da9481.gif" alt="ShaderToyスクリーンショット"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
美しい多色の影を作成することに加えて、これは影を改善し、シーンにボリュームを構築するのに役立ちます。</font><font style="vertical-align: inherit;">さらに、厳密に言えば、イルミネーションの点光源を使用するという事実にもかかわらず、ボリュームの滑らかなエッジのおかげで、ソフトシャドウが得られます。</font><font style="vertical-align: inherit;">それで全部です！</font><font style="vertical-align: inherit;">ここではもっと多くのことができますが、例の比較的単純さを維持しながら、必要な視覚的品質を達成したように思えます。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適化</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、可能ないくつかの最適化を簡単にリストします。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">光源の方向にレイマーチングを実行する前に、この光のかなりの量が問題のポイントに本当に到達しているかどうかを、光の消光の値で確認する必要があります。</font><font style="vertical-align: inherit;">私の実装では、マテリアルのアルベドを掛けた光の明るさを見て、レイマーチングを実行するのに十分な値であることを確認します。</font></font></li>
<li>      ,     ,     raymarching   </li>
<li>        raymarching .      ,        .           ,       raymarching ,     .</li>
</ol><br>
<h1></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで全部です！</font><font style="vertical-align: inherit;">個人的には、このように少量のコード（約500行）で、物理的にかなり正しいものを作成できることに驚きました。</font><font style="vertical-align: inherit;">お読みいただき、ありがとうございました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてもう1つの注意：ここに楽しい変更があります-SDF距離に基づいて発光を追加して爆発エフェクトを作成しました。</font><font style="vertical-align: inherit;">結局のところ、爆発は決して多くありません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/2f1/ab0/c642f1ab0fbc3df3b35cfafa97f9c694.gif" alt="ShaderToyスクリーンショット"></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja500896/index.html">検疫で何を確認しますか？テクノストリームからの厳選された資料（パート3）</a></li>
<li><a href="../ja500898/index.html">クレイジーSpaceXムーンプラン？U / S_Hirangy（reddit）によるプログラム評価</a></li>
<li><a href="../ja500902/index.html">モバイル開発者向けの興味深い資料の要約＃343（4月27日-5月3日）</a></li>
<li><a href="../ja500904/index.html">誰が支払いエコシステム2020にいるのか。パート1</a></li>
<li><a href="../ja500910/index.html">中国長距離宇宙通信システム</a></li>
<li><a href="../ja500918/index.html">A / B検定の統計的有意性を計算するときに注意すること</a></li>
<li><a href="../ja500920/index.html">骨董品：ZXスペクトルと古代イグロジュール</a></li>
<li><a href="../ja500922/index.html">羊の服を着たオオカミ：通常のユーザーになりすましているハッカーを捕まえる方法</a></li>
<li><a href="../ja500924/index.html">Evgeny Borisovとのオンライン会議JUG.ru "Spring-builder"</a></li>
<li><a href="../ja500926/index.html">動的型付けは開発ツールではありません。これはナンセンスです（ひどい）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>