<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖🏽 ♒️ 👹 Fonctionnement du rendu de jeu 3D: texturation et filtrage de texture 😧 👨🏻‍💻 🧐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans le troisième article sur le rendu dans les jeux 3D, nous découvrirons ce qui arrive au monde 3D après avoir traité le traitement des vertex et pi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Fonctionnement du rendu de jeu 3D: texturation et filtrage de texture</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499540/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a4/fee/0c7/2a4fee0c701c2b2200faf2b8c6929832.jpg" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le troisième article sur le rendu dans les jeux 3D, nous découvrirons ce qui arrive au monde 3D après avoir traité le traitement des vertex et pixellisé la scène. </font><font style="vertical-align: inherit;">La texturation est l'une des étapes les plus importantes du rendu, malgré le fait qu'elle calcule et modifie uniquement les couleurs d'une grille bidimensionnelle de blocs multicolores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La plupart des effets visuels des jeux modernes se résument à une utilisation délibérée des textures - sans eux, les jeux sembleraient ennuyeux et sans vie. </font><font style="vertical-align: inherit;">Voyons donc comment tout cela fonctionne! </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 1: traitement des sommets </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 2: tramage et lancer de rayons</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commençons par un simple</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez prendre tous les jeux à trois dimensions les plus vendus au cours de la dernière année et dire avec confiance qu'ils ont tous quelque chose en commun: ils utilisent </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des cartes de texture</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ou simplement des </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">textures</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). C'est un terme si courant que lorsque l'on pense aux textures, la plupart des gens présentent la même image: un simple carré plat ou rectangle contenant une image d'une surface (herbe, pierre, métal, tissu, visage, etc.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais lorsqu'elles sont utilisées et combinées à l'aide de calculs complexes, de telles images simples dans une scène 3D peuvent créer des images incroyablement réalistes. Pour comprendre comment cela est possible, désactivons-les complètement et voyons à quoi ressembleront les objets du monde 3D sans textures.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme nous l'avons vu dans les articles précédents, le monde 3D est composé de sommets - des formes simples qui se déplacent puis se colorisent. Ils sont ensuite utilisés pour créer des primitives, qui à leur tour sont compressées en une grille bidimensionnelle de pixels. Comme nous n'utiliserons pas de textures, nous devons coloriser ces pixels. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'une des méthodes pouvant être appliquées est appelée </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ombrage plat</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : la couleur du premier sommet de la primitive est prise, puis cette couleur est appliquée à tous les pixels couverts par la figure dans le raster. Cela ressemble à ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/f5c/61b/a0bf5c61be539c776d00fa1b11177ced.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De toute évidence, la bouilloire semble irréaliste, notamment en raison des couleurs de surface irrégulières. Les couleurs sautent d'un niveau à l'autre, il n'y a pas de transitions fluides. Une solution au problème pourrait être d'utiliser l' </font></font><em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ombrage Gouraud</font></font></a></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce processus, les couleurs des sommets sont prises, après quoi le changement de couleur le long de la surface du triangle est calculé. Pour cela, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une interpolation linéaire est utilisée</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cela semble compliqué, mais en réalité, cela signifie que si, par exemple, un côté de la primitive a une couleur de 0,2 rouge et l'autre 0,8 rouge, le milieu de la figure aura une couleur au milieu entre 0,2 et 0,8 (soit 0,5).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce processus est assez simple, et c'est son principal avantage, car la simplicité signifie la vitesse. De nombreux jeux 3D plus anciens utilisaient cette technique car l'équipement informatique était limité dans ses capacités.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/128/447/3c8/1284473c8e1e2ce7d32dbf2202065afe.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barrett et Cloud dans toute la grandeur de l'ombrage Gouraud (Final Fantasy VII, 1997)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Mais même une telle solution a des problèmes - si la lumière tombe en plein milieu du triangle, alors ses coins (et sommets) peuvent ne pas transmettre cette propriété. </font><font style="vertical-align: inherit;">Cela signifie que l'éblouissement créé par la lumière peut être complètement perdu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien que l'ombrage plat et l'ombrage de Gouraud aient pris la place qui leur revient dans les outils de rendu, les exemples ci-dessus sont des candidats clairs pour l'amélioration de la texture. </font><font style="vertical-align: inherit;">Et pour bien comprendre ce qui se passe lorsque la texture se superpose à la surface, on va remonter dans le temps ... déjà en 1996.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Histoire du jeu et du GPU en bref</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a environ 23 ans, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">id Software a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sorti Quake, et c'est devenu une étape importante. </font><font style="vertical-align: inherit;">Bien que ce ne soit pas le premier jeu à utiliser des polygones et des textures 3D pour rendre des environnements, il a certainement été l'un des premiers à les utiliser efficacement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais elle a fait autre chose aussi - elle a montré ce qui peut être fait en utilisant OpenGL (cette API graphique était alors dans la première version), et a également beaucoup aidé la première génération de cartes graphiques comme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendition Verite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3Dfx Voodoo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a86/9a9/667/a869a966718cfc8ddf4b6d7618b2fdbf.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pics d'éclairage et textures simples. </font><font style="vertical-align: inherit;">Nettoyez 1996, nettoyez Quake. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selon les normes modernes, Voodoo était extrêmement simple: pas de support graphique 2D, pas de traitement de vertex, seulement le traitement de pixels le plus simple. </font><font style="vertical-align: inherit;">Cependant, elle était belle:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66c/509/911/66c5099113c9b08098b73ce31436ecb8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Musée VGA</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Elle avait une puce entière (TMU) pour obtenir un pixel d'une texture et une autre puce (FBI) pour le mélanger plus tard avec un pixel raster. La carte pourrait effectuer quelques processus supplémentaires, par exemple, la mise en œuvre d'effets de brouillard ou de transparence, mais cela a essentiellement mis fin à ses capacités. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous regardons l'architecture sous-jacente à la structure et au fonctionnement de la carte graphique, nous verrons comment ces processus fonctionnent.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/c83/ee4/064c83ee4f63da2be0d5a968c33df0d5.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spécification 3Dfx. Source: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falconfly Central</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
La puce FBI a reçu deux valeurs de couleur et les a mélangées; l'un d'eux pourrait être une valeur d'une texture. Le processus de mélange est mathématiquement assez simple, mais varie légèrement en fonction de ce qui est mélangé et de l'API utilisée pour exécuter les instructions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous regardez ce que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direct3D nous offre en ce</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui concerne les fonctions et les opérations de mixage, nous verrons que chaque pixel est d'abord multiplié par un nombre de 0,0 à 1,0. Cela détermine dans quelle mesure la couleur du pixel affectera le résultat final. Ensuite, deux couleurs de pixels modifiées sont ajoutées, soustraites ou multipliées; dans certaines fonctions, une opération logique est effectuée dans laquelle, par exemple, le pixel le plus lumineux est toujours sélectionné.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/c8b/c8a/aa1c8bc8a2e35a1867c5f6028d958fa8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog technologique Taking Initiative</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
L'image ci-dessus montre comment cela fonctionne dans la pratique; notez que la valeur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alpha</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> du pixel est utilisée comme coefficient pour le </font><font style="vertical-align: inherit;">pixel </font><font style="vertical-align: inherit;">gauche </font><font style="vertical-align: inherit;">. Ce nombre indique le degré de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transparence du</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À d'autres étapes, la valeur de brouillard est appliquée (elle est tirée de la table créée par le programmeur, puis les mêmes calculs de mélange sont effectués); effectuer des contrôles et des changements de visibilité et de transparence; à la fin, la couleur du pixel est écrite dans la mémoire de la carte graphique.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi avez-vous besoin de cette excursion dans l'histoire? </font><font style="vertical-align: inherit;">Eh bien, malgré la relative simplicité de la conception (en particulier par rapport aux monstres modernes), ce processus décrit les principes fondamentaux de la texturation: nous prenons les valeurs des couleurs et les mélangeons afin que les modèles et les environnements se présentent comme ils le devraient dans une situation particulière. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les jeux modernes font la même chose, la seule différence est le nombre de textures utilisées et la complexité des calculs de mixage. </font><font style="vertical-align: inherit;">Ensemble, ils simulent les effets visuels trouvés dans les films ou l'interaction de l'éclairage avec différents matériaux et surfaces.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notions de base sur la texturation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour nous, une texture est une image 2D plate superposée aux polygones qui composent la structure 3D du cadre. Cependant, pour un ordinateur, ce n'est qu'un petit bloc de mémoire sous la forme d'un tableau 2D. Chaque élément du tableau indique la valeur de couleur de l'un des pixels de l'image de texture (communément appelés </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">texels</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - pixels de texture). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque sommet du polygone a un ensemble de deux coordonnées (généralement notées </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), indiquant à l'ordinateur quel pixel de la texture lui est associé. Le sommet lui-même a un ensemble de trois coordonnées ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x, y, z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), et le processus de liaison des texels aux sommets est appelé </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mappage de texture</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour voir comment cela se produit, tournons-nous vers l'outil que nous avons déjà utilisé plusieurs fois dans cette série d'articles - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu en temps réel WebGL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pour l'instant, nous supprimons également la coordonnée </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des </font><font style="vertical-align: inherit;">sommets et considérons tout sur un plan plat.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/d20/fbb/8e1d20fbb308d78a19a2e54d5da96900.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De gauche à droite: les coordonnées </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la </font><font style="vertical-align: inherit;">texture, directement liées aux coordonnées </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x, y</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des </font><font style="vertical-align: inherit;">sommets des coins. Dans la deuxième image, les coordonnées </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont augmentées aux sommets supérieurs </font><font style="vertical-align: inherit;">, mais comme la texture y est toujours attachée, elle s'étire verticalement. La texture a déjà été modifiée dans l'image de droite: les valeurs </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ont augmenté, mais en conséquence, la texture a été compressée puis répétée.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Cela s'est produit parce que, malgré le fait qu'en fait, la texture est devenue plus élevée en raison de la valeur accrue de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , elle devrait toujours tenir dans la primitive - en fait, la texture partiellement répétée. C'est une façon d'implémenter l'effet que l'on retrouve souvent dans les jeux 3D: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">répéter les textures</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Des exemples de cet effet peuvent être vus dans des scènes avec des paysages pierreux ou herbeux, ainsi qu'avec des murs de briques. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modifions maintenant la scène pour qu'il y ait plus de primitives, et retournons à nouveau la profondeur de la scène. La vue paysage classique est illustrée ci-dessous, mais maintenant la texture de la boîte est copiée et répétée pour toutes les primitives.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/9e1/0cb/a9e9e10cb533b78330f90fd7eaea3891.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La texture de la boîte dans son format gif d'origine a une taille de 66 Ko et une résolution de 256 x 256 pixels. La résolution initiale de la partie du cadre couverte par les textures de boîte est de 1900 x 680, c'est-à-dire du point de vue de la «zone» de pixels, une telle zone ne devrait afficher que 20 textures de boîte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais il est évident que nous voyons beaucoup plus de vingt boîtes, ce qui signifie que la texture de la boîte au loin doit être </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beaucoup</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plus petite que 256 x 256 pixels. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En effet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ils ont subi un processus appelé </font><em><font style="vertical-align: inherit;">«minification de texture»</font></em><font style="vertical-align: inherit;"> (oui, un tel mot existe en anglais!). Maintenant, répétons, mais cette fois rapprochez l'appareil photo de l'un des tiroirs.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/404/c02/f70/404c02f70291916245ec931642c79860.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N'oubliez pas que la texture a une taille de seulement 256 x 256 pixels, mais ici nous voyons une texture qui est plus grande que la moitié de l'image avec une largeur de 1900 pixels. </font><font style="vertical-align: inherit;">Cette texture a été soumise à une opération de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"grossissement de texture"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces deux processus de texture se produisent constamment dans les jeux 3D, car lorsque la caméra se déplace autour de la scène, les modèles s'approchent ou s'éloignent, et toutes les textures appliquées aux primitives doivent évoluer avec les polygones. </font><font style="vertical-align: inherit;">Du point de vue des mathématiques, c'est un petit problème, en fait, même les puces graphiques intégrées les plus simples peuvent facilement faire un tel travail. </font><font style="vertical-align: inherit;">Cependant, la réduction et l'agrandissement des textures sont de nouveaux défis qui doivent être résolus d'une manière ou d'une autre.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des mini-copies de textures apparaissent sur la scène</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier problème à résoudre pour les textures est la distance. Si nous revenons à la première image avec un paysage de boîtes, alors les boîtes situées près de l'horizon n'ont en fait qu'une taille de quelques pixels. Par conséquent, essayer de compresser une image de 256 x 256 pixels dans un si petit espace est inutile pour deux raisons. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, la texture plus petite occupe moins de mémoire de la carte graphique, ce qui est pratique, car vous pouvez essayer de l'intégrer dans un cache plus petit. Cela signifie qu'il est moins susceptible d'être supprimé du cache, c'est-à-dire qu'une utilisation répétée de cette texture fournira des performances accrues, car les données seront en mémoire fermée. Pour la deuxième raison, nous reviendrons bientôt, car il est associé au même problème qui se pose dans les textures proches de la caméra.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La solution standard au problème de la nécessité de compresser de grandes textures en petites primitives est d'utiliser </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des textures mip (mipmaps)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ce sont des versions réduites de la texture d'origine; ils peuvent être générés par le moteur lui-même (à l'aide des commandes API appropriées) ou pré-créés par les concepteurs de jeux. Chaque niveau de texture de mip suivant a une demi-taille par rapport au précédent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, pour la texture de la boîte, les dimensions seront: 256 x 256 → 128 x 128 → 64 x 64 → 32 x 32 → 16 x 16 → 8 x 8 → 4 x 4 → 2 x 2 → 1 x 1.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/074/973/1ea/0749731eae53d112d545c0297ac14584.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toutes les textures de mip sont emballées ensemble, donc la texture a le même nom de fichier, mais devient plus grande. La texture est compressée de telle manière que les coordonnées </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> déterminent non seulement quel texel est superposé au pixel dans le cadre, mais aussi avec quelle texture de mip. Ensuite, les programmeurs écrivent un rendu, basé sur la valeur de la profondeur de pixel de l'image, qui détermine la texture de mip à utiliser. Par exemple, si la valeur est très élevée, le pixel est loin, ce qui signifie que vous pouvez utiliser une petite texture de mip.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les lecteurs attentifs pourraient remarquer le manque de textures MIP - ils doivent les payer en augmentant la taille des textures. La texture d'origine de la boîte était de 256 x 256 pixels, mais comme vous pouvez le voir dans l'image ci-dessus, la texture avec des textures de mip a maintenant une taille de 384 x 256. Oui, elle a beaucoup d'espace vide, mais peu importe comment nous emballons des textures plus petites, en général la taille de la texture d'un côté augmentera d'au moins 50%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais cela n'est vrai que pour les textures mip précédemment créées; si le moteur de jeu est programmé pour les générer correctement, l'augmentation ne dépasse pas 33% de la taille de texture d'origine. Par conséquent, en raison d'une petite augmentation de la quantité de mémoire pour stocker les textures MIP, nous obtenons un gain en performances et en qualité visuelle.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous trouverez ci-dessous une comparaison d'images avec des textures MIP désactivées / activées:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e96/b67/e71/e96b67e71c3f41aed3ce09ed728f98ea.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur le côté gauche de l'image, les textures des boîtes ont été utilisées «telles quelles», ce qui a conduit à l'apparition de granularité et du soi-disant </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moiré</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au loin. </font><font style="vertical-align: inherit;">À droite, l'utilisation de textures de mip a permis des transitions plus douces, et à l'horizon la texture de la boîte est floue dans une couleur uniforme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, qui veut des textures floues pour gâcher les arrière-plans de leur jeu préféré?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bilinéaire, trilinéaire, anisotrope - tout cela est pour moi une lettre chinoise</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le processus de sélection d'un pixel dans une texture pour le superposer sur un pixel dans un cadre est appelé </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">échantillonnage de textures</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et dans un monde idéal, il y aurait une texture qui correspond idéalement à la primitive pour laquelle il est conçu, indépendamment de la taille, de la position, de la direction, etc. </font><font style="vertical-align: inherit;">En d'autres termes, l'échantillonnage de la texture serait un simple mappage de pixels texel un à un. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais comme ce n'est pas le cas, il y a plusieurs facteurs à considérer lors de l'échantillonnage des textures:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La texture a-t-elle été réduite ou agrandie?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La texture est-elle une texture source ou mip?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sous quel angle la texture est-elle affichée?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Analysons-les dans l'ordre. Le premier facteur est assez évident: si la texture a été augmentée, alors dans la primitive, il y aura plus de texels couvrant le pixel dans la primitive que nécessaire; en diminuant, l'inverse est vrai - chaque texel devrait maintenant couvrir plusieurs pixels. Et c'est un problème. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxième facteur ne pose pas de problème, car les textures mip sont utilisées pour contourner le problème d'échantillonnage des textures des primitives lointaines, de sorte que la seule tâche consiste à afficher les textures sous un angle. Et oui, c'est aussi un problème. Pourquoi? Parce que toutes les textures sont des images générées pour une visualisation «strictement en face». Parlant dans un langage mathématique, la texture de surface normale correspond à la surface nominale sur laquelle la texture est actuellement affichée.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, s'il y a trop peu ou trop de texels, ou s'ils sont situés à un angle, alors un processus supplémentaire appelé </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filtrage de texture</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est requis </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si ce processus n'est pas utilisé, nous obtenons ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/792/a12/552/792a125529b7f3baa79c072fdf42acba.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous avons remplacé la texture de la boîte par une texture avec la lettre R, pour montrer plus clairement dans quel désordre l'image se transforme sans filtrer les textures! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les API graphiques telles que Direct3D, OpenGL et Vulkan fournissent le même ensemble de types de filtrage, mais utilisent des noms différents pour eux. </font><font style="vertical-align: inherit;">En fait, ils se résument tous à ce qui suit:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Échantillonnage au point proche</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filtrage de texture linéaire</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filtrage de texture anisotrope</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, l' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">échantillonnage de l'échantillonnage ponctuel le plus proche n'est</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas un filtre, car avec lui seul le texel le plus proche du pixel de texture requis est échantillonné (par exemple, copié de la mémoire), puis il est mélangé avec la couleur d'origine du pixel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici le filtrage linéaire vient à notre aide. Les coordonnées de </font><font style="vertical-align: inherit;">texel </font><font style="vertical-align: inherit;">requises </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont transférées à l'équipement d'échantillonnage, mais au lieu de prendre le texel le plus proche de ces coordonnées, l'échantillonneur prend </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quatre</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texels. Ce sont des texels situés au-dessus, en dessous, à gauche et à droite du texel qui est sélectionné en échantillonnant les points les plus proches. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces quatre texels sont ensuite mélangés en utilisant une formule avec des poids. Dans Vulkan, par exemple, la formule ressemble à ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/9bb/63c/57b9bb63cc81fa5721b007717f6b200a.png"></div><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> désigne la couleur du texel, où </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le résultat de la filtration, et 1-4 est la couleur de quatre texels échantillonnés. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> valeurs </font><em><font style="vertical-align: inherit;">alpha</font></em><font style="vertical-align: inherit;"> et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bêta</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont prises en fonction de la distance entre le point de coordonnées </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v et</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> le milieu de la texture. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heureusement pour ceux impliqués dans les graphiques 3D, cela se produit automatiquement dans la puce graphique. En fait, c'est exactement ce qu'a fait la puce TMU de la carte 3dfx Voodoo: elle a échantillonné quatre texels puis les a mélangés. Dans Direct3D, ce processus a un nom étrange </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour le filtrage bilinéaire.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais depuis l'époque de Quake et de la puce TMU, les cartes graphiques ont déjà appris à effectuer un filtrage bilinéaire en un seul cycle d'horloge (bien sûr, si la texture est déjà située dans la mémoire la plus proche). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le filtrage linéaire peut être utilisé avec des textures mip, et si vous voulez compliquer le filtrage, vous pouvez prendre quatre texels de la texture, puis quatre autres du niveau suivant de texture mip, en les mélangeant tous. Et comment ça s'appelle dans Direct3D? </font><font style="vertical-align: inherit;">Filtrage </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trilinéaire</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . D'où viennent les </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«trois»</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans ce processus </font><font style="vertical-align: inherit;">? Nous ne savons donc pas ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La dernière méthode de filtrage qui mérite d'être mentionnée est </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anisotrope</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il s'agit en fait d'une amélioration du processus effectué par filtrage bilinéaire ou trilinéaire. Initialement, il calcule</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le degré d'anisotropie de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la surface primitive (et c'est </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un processus étonnamment complexe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - cette valeur augmente le changement du rapport d'aspect de la primitive en raison de son orientation:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/247/dfe/e60/247dfee60846988a5e94a1020d9ecef6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La figure ci-dessus montre la même primitive carrée avec des longueurs de côté égales; mais en tournant progressivement, il se transforme en rectangle, et sa largeur change plus que sa hauteur. Par conséquent, la primitive de droite a un degré d'anisotropie supérieur à celui de gauche (et dans le cas d'un carré, le degré est nul). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De nombreux jeux 3D modernes vous permettent d'activer le filtrage anisotrope puis de changer son niveau (de 1x à 16x), mais qu'est-ce que cela change vraiment? Ce paramètre contrôle le nombre maximal d'échantillons de texels supplémentaires prélevés dans chaque échantillon linéaire initial. Supposons qu'un filtrage bilinéaire anisotrope de 8x soit activé dans le jeu. Cela signifie qu'au lieu de quatre valeurs de texel, il obtiendra 32 valeurs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La différence lors de l'utilisation du filtrage anisotrope est clairement perceptible:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/302/372/df7302372c6dc0d34730ba572f695063.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Montez simplement sur l'image ci-dessus et comparez l'échantillonnage des points les plus proches avec un filtrage trilinéaire anisotrope 16x maximum. Étonnamment lisse! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais pour cette beauté lisse des textures, vous devez payer avec les performances: aux paramètres maximaux, le filtrage trilinéaire anisotrope recevra 128 échantillons de la texture pour chaque pixel du rendu. Même avec les meilleurs GPU modernes, cela ne peut pas être réalisé en un seul cycle d'horloge. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous prenez, par exemple, AMD </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Radeon RX 5700 XT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, alors chacun des blocs de texturation à l'intérieur du processeur peut utiliser jusqu'à 32 adresses de texel dans un cycle d'horloge, puis dans le cycle d'horloge suivant charger 32 valeurs de texel à partir de la mémoire (dont chacune a une taille de 32 bits), puis mélanger quatre d'entre elles en une de plus tact. C'est-à-dire que mélanger 128 échantillons de texels en un seul nécessite au moins 16 cycles d'horloge.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/abf/cf4/fa4abfcf4411b6cc2622c8e77986ab3c.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU AMD RDNA Radeon RX 5700 avec technologie de processus à 7 nanomètres</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Si la vitesse d'horloge du 5700 XT est de 1605 MHz, alors seize cycles ne prennent que 10 </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nanosecondes</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . L'exécution de ces cycles pour chaque pixel d'une image 4K en utilisant une </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seule</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unité de texture ne prendra que 70 millisecondes. Super, on dirait que la performance n'est pas un gros problème! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Même en 1996, 3Dfx Voodoo et les cartes similaires se sont rapidement adaptées aux textures. Au maximum, ils pouvaient donner 1 texel avec filtrage bilinéaire par cycle, et avec une fréquence de puce TMU de 50 MHz, cela signifiait que 50 millions de texels pouvaient être traités par seconde. Un jeu fonctionnant à 800 x 600 et 30 fps ne nécessite que 14 millions de texels avec filtrage bilinéaire par seconde.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, cela n'est vrai que dans l'hypothèse où toutes les textures sont dans la mémoire la plus proche et qu'un seul texel correspond à chaque pixel. </font><font style="vertical-align: inherit;">Il y a vingt ans, l'idée de la nécessité de superposer plusieurs textures sur une primitive était complètement étrangère, mais aujourd'hui c'est un standard. </font><font style="vertical-align: inherit;">Voyons pourquoi tout cela change.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajouter un éclairage</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour comprendre pourquoi la texturation est devenue si importante, jetez un œil à cette scène de Quake:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/dcf/ee4/bdadcfee4354ea561b9239e1ca5a143b.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est une image sombre, car l'obscurité était l'atmosphère du jeu, mais nous voyons que l'obscurité n'est pas la même partout - certains fragments de murs et de sols sont plus légers que d'autres, ce qui crée une sensation de légèreté dans ces zones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les primitives qui composent les murs et le sol sont superposées avec les mêmes textures, mais il existe une autre texture appelée </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«light map»</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mélangée aux valeurs des texels avant qu'elles ne soient appliquées aux pixels du cadre. À l'époque de Quake, les cartes d'éclairage ont été calculées à l'avance et créées par le moteur de jeu. Ils ont été utilisés pour générer des niveaux d'éclairage statiques et dynamiques.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'avantage de leur utilisation est que les calculs d'éclairage complexes ont été effectués avec des textures plutôt qu'avec des sommets, ce qui a considérablement amélioré l'apparence de la scène au détriment des coûts à faible vitesse. Évidemment, l'image est imparfaite: au sol, on remarque que la frontière entre les zones éclairées et les ombres est très nette. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À bien des égards, une lightmap n'est qu'une autre texture (n'oubliez pas que ce sont tous des jeux de données 2D normaux), donc cette scène est l'un des premiers exemples d'utilisation du </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">multitexturing</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Comme son nom l'indique, il s'agit d'un processus dans lequel deux textures ou plus sont superposées à une primitive. L'utilisation de cartes d'éclairage dans Quake est devenue un moyen de surmonter les limites de l'ombrage Gouraud, mais dans le processus d'augmentation de la gamme de capacités des cartes graphiques, les méthodes d'application du multitexturing se sont également étendues. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3Dfx Voodoo, comme beaucoup d'autres cartes de cette époque, était limité dans la quantité d'opérations qu'il pouvait effectuer en une seule </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passe de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rendu. En fait, une passe est un cycle de rendu complet: du traitement des sommets à la pixellisation de l'image, puis la modification des pixels et leur écriture dans le tampon d'image fini. Il y a vingt ans, les jeux utilisaient presque toujours le rendu en une seule passe.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a55/0b6/bc9/a550b6bc98c07f1c90276e1aa3721819.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nvidia GeForce 2 Ultra, vers la fin de 2000. Image: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikimedia</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Cela s'est produit parce que le deuxième traitement de sommet juste pour appliquer des textures supplémentaires était trop coûteux en termes de performances. Après Voodoo, nous avons dû attendre quelques années lorsque les cartes graphiques ATI Radeon et Nvidia GeForce 2 sont apparues, capables de multitexturing en un seul passage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces GPU avaient plusieurs unités de texture dans la zone de traitement des pixels (c'est-à-dire dans le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pipeline</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), donc obtenir un texel avec filtrage bilinéaire à partir de deux textures distinctes est devenu la tâche la plus simple. Cela a encore accru la popularité des cartes d'éclairage et a permis aux jeux de les rendre entièrement dynamiques, en changeant les valeurs d'éclairage en fonction des conditions de l'environnement de jeu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais avec quelques textures, beaucoup plus pourrait être fait, alors explorons leurs capacités.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changer la hauteur est normal</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cette série d'articles sur le rendu 3D, nous n'avons pas parlé de la façon dont le rôle du GPU affecte l'ensemble du processus (nous en parlerons, mais pas maintenant!). Mais si vous revenez à la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partie 1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et lisez tout le processus complexe de traitement des sommets, vous pourriez penser que c'est la partie la plus difficile de tout le travail que le GPU doit faire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendant longtemps, c'était le cas, et les programmeurs de jeux ont fait tout leur possible pour réduire cette charge. Ils ont dû recourir à toutes sortes d'astuces pour garantir la même qualité d'image que lors de l'utilisation de plusieurs sommets, mais ne les traitent pas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La plupart de ces astuces utilisaient des textures appelées </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cartes de hauteur</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cartes normales.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ces deux concepts sont liés par le fait que ces derniers peuvent être créés à partir des premiers, mais pour l'instant, ne regardons qu'une technique appelée </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«bump mapping»</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/db2/5b6/1e3db25b6ecefc0dd3f75c84f767800c.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Images créées dans un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rendu de démonstration par Emil Persson</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La texturation en relief est désactivée / activée. La texturation en relief</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
utilise un tableau 2D appelé «carte de hauteur» qui ressemble à une version étrange de la texture d'origine. </font><font style="vertical-align: inherit;">Par exemple, l'image ci-dessus montre une texture de brique réaliste superposée sur deux surfaces planes. </font><font style="vertical-align: inherit;">La texture et sa carte de hauteur ressemblent à ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/87f/221/7a187f2215bcf0723bd4d4f820350858.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les couleurs de la carte des hauteurs indiquent les normales de la surface des briques (nous avons décrit les normales dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partie 1 d'une</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> série d'articles). Lorsque le processus de rendu atteint le stade d'application de la texture de brique à la surface, une série de calculs est effectuée pour modifier la couleur de la texture de brique en fonction de ses normales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conséquence, les briques elles-mêmes semblent plus tridimensionnelles, malgré le fait qu'elles continuent de rester complètement plates. Si vous regardez attentivement, en particulier sur les bords des briques, vous pouvez voir les limites de cette technique: la texture semble légèrement déformée. Mais c'est une astuce rapide qui vous permet d'ajouter plus de détails sur la surface, donc la texturation en relief est très populaire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une carte normale est similaire à une carte de hauteur, seules les couleurs de texture sont les normales elles-mêmes. En d'autres termes, les calculs pour convertir la carte de hauteur en normale ne sont pas nécessaires. Vous pouvez poser une question: comment les couleurs peuvent-elles décrire un vecteur dans l'espace? La réponse est simple: chaque texel a un ensemble de valeurs </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r, g, b</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (rouge, vert, bleu) et ces valeurs correspondent directement aux valeurs </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x, y, z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> du vecteur normal.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1f/105/c3b/c1f105c3b93c455ba7661489770172c9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le diagramme de gauche montre le changement de direction des normales sur une surface inégale. Pour décrire les mêmes normales avec une texture plate (contour central), nous leur attribuons des couleurs. Dans ce cas, nous avons utilisé les valeurs </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r, g, b</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (0,255,0) pour le vecteur dirigé directement vers le haut, puis augmenté la valeur du rouge pour l'inclinaison vers la gauche et du bleu pour l'inclinaison vers la droite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gardez à l'esprit que cette couleur ne se mélange pas avec le pixel d'origine, elle indique simplement au processeur dans quelle direction la normale indique afin qu'il puisse calculer correctement les angles entre la caméra, les sources de lumière et la surface texturée.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les avantages de la texturation en relief et des cartes normales sont pleinement visibles lorsque l'éclairage dynamique est utilisé dans la scène et lorsque le processus de rendu calcule l'effet du changement d'éclairage pixel par pixel, et non pour chaque sommet. Aujourd'hui, les jeux modernes utilisent un ensemble de textures pour améliorer la qualité de cette astuce.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ef/d59/660/3efd596604528593b16923297f10f044.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ryan Benno</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Étonnamment, ce mur d'aspect réaliste n'est qu'une surface plane, les détails des briques et du ciment de maçonnerie ne sont pas fabriqués à l'aide de millions de polygones. Au lieu de cela, seulement cinq textures et l'utilisation réfléchie des calculs suffisent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une carte de hauteur a été utilisée pour générer une projection d'ombre avec des briques, et une carte normale a été utilisée pour simuler tous les changements mineurs de surface. La texture de rugosité a été utilisée pour changer la façon dont la lumière est réfléchie par divers éléments du mur (par exemple, la brique lisse réfléchit la lumière plus uniformément que le ciment brut).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La dernière carte, nommée dans l'image AO, crée une partie du processus appelé occlusion ambiante: nous examinerons cette technique plus en détail dans les articles suivants, mais pour l'instant, disons qu'elle aide à augmenter le réalisme des ombres.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cartographie des textures est un processus critique.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La texturation est absolument essentielle lors du développement de jeux. Prenons, par exemple, le jeu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kingdom Come: Deliverance</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2019 </font><font style="vertical-align: inherit;">, un RPG à la première personne qui se déroule en Bohême au XVe siècle. Les concepteurs ont cherché à créer le monde le plus réaliste de cette période. Et pour plonger le joueur dans la vie d'il y a des centaines d'années, il est préférable de mettre en œuvre un paysage, des bâtiments, des vêtements, des coiffures, des objets de tous les jours historiquement précis et bien plus encore. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque texture de cette image du jeu a été créée manuellement par des artistes, et aussi grâce à un moteur de rendu contrôlé par des programmeurs. Certains d'entre eux sont petits, avec des détails simples, et sont donc légèrement filtrés ou traités avec d'autres textures (par exemple, des ailes de poulet).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2e/7d0/24a/e2e7d024ad0c700d26390940caf339ed.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'autres ont une haute résolution et de nombreux petits détails; </font><font style="vertical-align: inherit;">ils subissent un filtrage et un mélange anisotropes avec des cartes normales et d'autres textures - il suffit de regarder le visage de la personne au premier plan. </font><font style="vertical-align: inherit;">La différence dans les exigences de texturation de chaque objet de scène est prise en compte par les programmeurs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout cela se produit aujourd'hui dans de nombreux jeux, car les joueurs attendent des niveaux de détail et de réalisme toujours plus élevés. </font><font style="vertical-align: inherit;">Les textures deviennent plus grandes et de plus en plus se superposent à la surface, mais le processus d'échantillonnage des texels et de leur superposition sur les pixels reste essentiellement le même qu'à l'époque de Quake. </font><font style="vertical-align: inherit;">Les meilleures technologies ne meurent jamais, quel que soit leur âge!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr499524/index.html">Quarkus: mises à niveau d'applications utilisant l'exemple helloworld de JBoss EAP Quickstart</a></li>
<li><a href="../fr499528/index.html">Un pont mathématique "étonnant" qui s'étend au-delà du grand théorème de Fermat</a></li>
<li><a href="../fr499532/index.html">Les mots en chiffres: blog gratuit analytics habravebinary avec Yandex.Metrica</a></li>
<li><a href="../fr499534/index.html">Guide de développement du service backend Python</a></li>
<li><a href="../fr499536/index.html">Growbox comme méthode de se connaître</a></li>
<li><a href="../fr499542/index.html">Top Fakapov Cyan</a></li>
<li><a href="../fr499544/index.html">Apprenez les réseaux de neurones dans Google Sheets</a></li>
<li><a href="../fr499546/index.html">Développement de firmware pour une caméra vidéo analogique EVR-Y2022F</a></li>
<li><a href="../fr499548/index.html">Masque - prendre soin des autres ou une illusion de sécurité?</a></li>
<li><a href="../fr499550/index.html">Solutions éco-low-code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>