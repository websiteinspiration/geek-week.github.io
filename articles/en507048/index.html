<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üà∑Ô∏è üçß üë®üèæ‚Äçüéì Olya, tests and factory - the path to beautiful architecture and clean code üêò üëÇüèΩ üñï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In test automation, there are many different approaches, solutions, and methods. The most common and indispensable is the Page Object (Screen Object) ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Olya, tests and factory - the path to beautiful architecture and clean code</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/507048/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In test automation, there are many different approaches, solutions, and methods. </font><font style="vertical-align: inherit;">The most common and indispensable is the Page Object (Screen Object) pattern. </font><font style="vertical-align: inherit;">I came across two approaches when working with this pattern: with a factory for my page objects and without it. </font><font style="vertical-align: inherit;">In this article, by the example of our autotests, we compare both approaches, their pros and cons. </font><font style="vertical-align: inherit;">Let me show you what our factory of page objects looks like. </font><font style="vertical-align: inherit;">I will also talk about the problems that we encountered in auto tests with the factory and how they were solved. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will cite all the examples in the article in Swift, but for Android autotests everything works the same way.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ci/5e/br/ci5ebr0v9onedivfawpjjy-ux0c.png"></div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To start</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hi my name is Olya. I am a mobile application tester at hh.ru. For two years with a tail, we transferred 90% of manual testing to automated. During this time, we managed to stumble upon various pitfalls many times, argue hundreds of disputes, and now I want to share our experience with the world. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We write autotests on android (Kotlin, Kaspresso) and on iOS (Swift, XCUITest). We try to make UI tests small, checking only individual scripts. The benefit of iron is enough for this, and the regression of ~ 300-400 UI auto-tests on each platform takes an average of 30-40 minutes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our autotests we use the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Page Object</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pattern </font><font style="vertical-align: inherit;">. Thousands of articles have been written about him, so we will not dwell on it in more detail.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Historically, when creating the first autotests on iOS and Android, we chose different approaches for working with page objects. </font><font style="vertical-align: inherit;">On Android, we just follow the pattern, and on iOS we also made a factory of page objects. </font><font style="vertical-align: inherit;">A factory is the place where all page objects are initialized. </font><font style="vertical-align: inherit;">Using it, in the methods of our screens, we can transfer other page objects, thereby building chains of interactions similar to the behavior of the application.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Does the factory need page objects?&nbsp;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After creating hundreds of test cases, we came to the conclusion that using the factory of page objects is a matter of taste for the tester who will write autotests. There is no difference in performance and stability when working with different approaches. But in order not to suffer from native code in the future, you need to decide as soon as possible whether there will be a place for the factory of page objects in the architecture of autotests or not. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For clarity, I will give two examples of the same test: written with and without a factory.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What this test does: from the main screen of the application, the user tries to go to the profile tab. In the profile, he selects ‚ÄúLogin‚Äù, then the login method by login and enters his username and password, and then clicks on the ‚ÄúLogin‚Äù button.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//   </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{
   <span class="hljs-keyword">let</span> mainScreen = <span class="hljs-type">MainScreen</span>()
   <span class="hljs-keyword">let</span> profileScreen = <span class="hljs-type">ProfileScreen</span>()
   <span class="hljs-keyword">let</span> authorizationScreen = <span class="hljs-type">AuthorizationScreen</span>()
   <span class="hljs-keyword">let</span> loginScreen = <span class="hljs-type">LoginScreen</span>()<font></font>
 <font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser()<font></font>
 <font></font>
        mainScreen.openProfileTab()<font></font>
        profileScreen.goToAuthorization()<font></font>
        authorizationScreen.goToLogin()<font></font>
        loginScreen<font></font>
           .enterLogin(user.login)<font></font>
           .enterPassword(user.password)<font></font>
           .logIn()   <font></font>
   }<font></font>
}<font></font>
</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-comment">//   </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser()<font></font>
 <font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openProfileTab()<font></font>
            .goToAuthorization()<font></font>
            .goToLogin()<font></font>
            .enterLogin(user.login)<font></font>
            .enterPassword(user.password)<font></font>
            .logIn()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If after this example you decide that tests without a factory look good, just grab and write without it. </font><font style="vertical-align: inherit;">This tip is especially relevant if you do not have a very large application, with different non-repeating content and elements. </font><font style="vertical-align: inherit;">Or if you write tests in which no more than 10-15 steps. </font><font style="vertical-align: inherit;">In this case, the factory will not do the weather.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But if this is not the case, or if the factory tests have responded in your heart, then this article is for you.&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qe/g4/zc/qeg4zcjbcn8z9yrhq83bmteoz8k.jpeg"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What does our factory look like?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's figure out what the page object factory is for, what it looks like and what it does. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A standard test case is a set of steps:</font></font><br>
<blockquote><ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Launch the application</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open Profile screen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tap on ‚ÄúLogin‚Äù</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Choose a login method using login and password</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enter user data (username and password)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tap the ‚ÄúLogin‚Äù button</font></font></li>
</ol><br>
</blockquote><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Screencast test</font></font></b>
                        <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/nYHsgZiJgo8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each step of the test case corresponds to a step in the autotest. You can also say that each step is a separate page object method of the corresponding screen.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we want to repeat this test case in the autotest exactly in steps, to build the same uninterrupted chain of method calls, it is necessary that each method returns the page object of the next screen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When creating a page object, it needs to be initialized. It turns out that if we want to create page objects inside others, there will be many identical initializations in each page object. In order not to do this, initializations of all page objects are moved to the factory - pageObjectFactory (or screenFactory, etc.). At the end of each method, we ask the factory to create the screen we need.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfilePageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goToAuthScreen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AuthPageObject</span> {<font></font>
        openAuthButton.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeAuthPageObject()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All page objects are inherited from BasePageObject, which contains the main parameters. </font><font style="vertical-align: inherit;">In it, we must prescribe a required constructor so that the factory can create any of its heirs. </font><font style="vertical-align: inherit;">In our case, the base class looks like this:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePageObject</span> </span>{
    <span class="hljs-keyword">let</span> pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>
    <span class="hljs-keyword">let</span> application: <span class="hljs-type">XCUIApplication</span><font></font>
 <font></font>
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>,<font></font>
                       application: <span class="hljs-type">XCUIApplication</span>) {
        <span class="hljs-keyword">self</span>.pageObjectsFactory = pageObjectsFactory
        <span class="hljs-keyword">self</span>.application = application<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And the initialization of screens in the factory as a result looks like this:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageObjectsFactory</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initializePageObject</span>&lt;PageObject: BasePageObject&gt;<span class="hljs-params">(ofType type: PageObject.<span class="hljs-keyword">Type</span>)</span></span> -&gt; <span class="hljs-type">PageObject</span> {
        <span class="hljs-keyword">return</span> type.<span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-keyword">self</span>, application: application)<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeAuthPageObject</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AuthPageObject</span> {
        <span class="hljs-keyword">return</span> initializePageObject(ofType: <span class="hljs-type">AuthPageObject</span>.<span class="hljs-keyword">self</span>)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, in the method of any page object, we can call the factory method of creating a screen that initializes it.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pluses of life of a tester without a factory</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. From the test it is always clear on which screen the action is performed</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Without a factory, in each line of </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only the</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> test </font><s><font style="vertical-align: inherit;">point,</font></s><font style="vertical-align: inherit;"> the screen and the action that takes place on it are clearly registered. </font><font style="vertical-align: inherit;">This allows you to not read the entire test code from the very beginning, for example, during debugging and fixes. </font><font style="vertical-align: inherit;">The lack of a factory adds readability especially when actions or checks are performed on one screen.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span> : <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
<font></font>
    <span class="hljs-comment">//   ,   </span>
    <span class="hljs-keyword">let</span> mainScreen = <span class="hljs-type">MainScreen</span>()
    <span class="hljs-keyword">let</span> profileScreen = <span class="hljs-type">ProfileScreen</span>()
    <span class="hljs-keyword">let</span> authorizationScreen = <span class="hljs-type">AuthorizationScreen</span>()
    <span class="hljs-keyword">let</span> loginScreen = <span class="hljs-type">LoginScreen</span>()<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser() <span class="hljs-comment">//   </span><font></font>
 <font></font>
        mainScreen.openProfileTab() <span class="hljs-comment">//      </span>
        profileScreen.goToAuthorization() <span class="hljs-comment">//     ""</span>
        authorizationScreen.goToLogin() <span class="hljs-comment">//          </span>
        loginScreen <span class="hljs-comment">//           </span><font></font>
            .enterLogin(user.login)<font></font>
            .enterPassword(user.password)<font></font>
            .login()   <font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Even if you are not very immersed in all the intricacies of the application, then from the example above it will immediately be clear that the actions enterLogin / enterPassword are performed on the same screen. </font><font style="vertical-align: inherit;">The test with the factory will not be so clear - you might think that the enterLogin action transferred the user to the next screen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. It is more convenient to write tests with actions that can lead to different screens</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When writing tests without a factory, you don‚Äôt need to think about the fact that any user action, depending on the state of the application, can behave differently, you just describe the logic of what is happening:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//        </span><font></font>
    vacancyScreen.tapResponseButton()<font></font>
    authScreen.authUser(user)<font></font>
    responseScreen.checkScreenIsOpened()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
or</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//       	</span><font></font>
    vacancyScreen.tapResponseButton()<font></font>
    responseScreen.checkScreenIsOpened()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the case of factory page objects, you‚Äôll have to think about how, depending on the authorization of the user, to return the desired screen in the tapResponseButton () method (or duplicate a method like tapResponseButtonAndLogin ())</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    ‚Ä¶<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tapResponseButton</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ResponseSendPageObject</span> {<font></font>
        responseButton.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeResponseSendPageObject()<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tapResponseButtonAndLogin</span><span class="hljs-params">(login: String)</span></span> -&gt; <span class="hljs-type">ResponseSendPageObject</span> {<font></font>
        responseButton.tap()<font></font>
        pageObjectsFactory<font></font>
            .makeAuthorizationPageObject()<font></font>
            .goToLogin()<font></font>
            .logIn(login)<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeResponseSendPageObject()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have 6 similar methods on this screen, despite the fact that they all tap on the same button.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. No need to wrap each action and each check in a separate method</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Methods of page objects without a factory do not need to return the next screen to continue the chain, respectively, for individual actions, you can not create separate methods.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, a tap on a button in a test without a factory might look like this:</font></font><br>
<br>
<pre><code class="swift hljs">    vacancyScreen.responseButton.tap()</code></pre><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Do not have to think about complex solutions, additionally think through the architecture of page objects</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In my experience, when writing autotests without a factory, there are practically no problems with page objects. </font><font style="vertical-align: inherit;">Describing a new page object is an easy and fast process. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The factory, along with its capabilities, adds some difficulties, which I will discuss later.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The undoubted advantages of the factory</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. While writing a test, there is no way to skip a step</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All methods of page objects are links of one chain. Each new link (method) should interlock with the following. This is due to the fact that all methods return a page-object (themselves or another), which is why when writing a test we have no way to choose the method of any screen, only the following.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Firstly, it significantly speeds up the writing of your first autotest by a new tester. The IDE itself tells you what actions and on which screen you can carry out further. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secondly, this architecture of autotests allows you to recognize the application through their writing, and not vice versa. (again - a good motivation for young testers).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thirdly, there is no way to skip a step, because the desired method simply will not appear until you pass the script correctly. </font><font style="vertical-align: inherit;">Such omissions are quite common when writing tests without a factory, and you will only find out about them when running the test.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. If you change the signature of the page object method, the IDE will force you to change all the tests associated with the object</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This item follows from the previous one. </font><font style="vertical-align: inherit;">All page object methods repeat the logic and behavior of the application. </font><font style="vertical-align: inherit;">If the application changes the logic of transitions between screens or adds new ones, we will correct the method we need and change its return. </font><font style="vertical-align: inherit;">In factory self-tests, in order to find all the tests that are affected by this change, you do not have to run all the tests. </font><font style="vertical-align: inherit;">The IDE itself will point to all the places in which the "chain" broke. </font><font style="vertical-align: inherit;">Tests without a factory do not follow this.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Architecture and code cleanliness do not suffer from the creation of superfluous screen objects&nbsp;</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you do not use a factory, and the test passes through the script through dozens of screens, then at the beginning of the class with the test you will have to write a whole block for creating objects of each screen. </font><font style="vertical-align: inherit;">And you need to do this every time for each class of tests. </font><font style="vertical-align: inherit;">Even worse if you write multiple tests in the same class. </font><font style="vertical-align: inherit;">Then the size of this ‚Äúblock‚Äù with the creation of all page objects is increased significantly.&nbsp;&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An example from a real test, in which the user responds to a vacancy, logs out and logs in to another user. </font><font style="vertical-align: inherit;">This block moves from class to class with minor changes for all similar tests.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterUpdateAfterOtherUserLoginTest</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> mainScreen = <span class="hljs-type">MainScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> vacanciesScreen = <span class="hljs-type">VacanciesScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> responseToVacancyScreen = <span class="hljs-type">ResponseToVacancyBottomSheet</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> successResponseBottomSheet = <span class="hljs-type">SuccessResponseBottomSheet</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> settingsScreen = <span class="hljs-type">UserSettingsScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> chooseAuthScreen = <span class="hljs-type">ChooseAuthScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> authScreen = <span class="hljs-type">NativeAuthScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> navigation = <span class="hljs-type">NavigationPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> moreScreen = <span class="hljs-type">MoreScreenPageObject</span>()<font></font>
<font></font>
    ...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is an option to make the initialization of all page objects in the base class of tests using lazy initialization. </font><font style="vertical-align: inherit;">Then in each test all screens will be available and unnecessary objects will not be created. </font><font style="vertical-align: inherit;">But the problem with listing many screens will return when we want to create page objects in the page objects themselves if we need to write a method that will go through another screen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The factory takes on the task of initializing the necessary page objects when they are needed.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. A great opportunity to dive deeper into the application code, study its architecture, modules, their interaction, etc.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having a factory of page objects requires wrapping all actions with the screen in methods that will return the next screen. </font><font style="vertical-align: inherit;">Because of this, page objects are expanding greatly, which makes you wonder how to make everything more beautiful and accurate. </font><font style="vertical-align: inherit;">For the sake of this, you are trying to use architectural techniques, watch the implementation of various screens in the application code, trace the interaction of modules in order to build a similar system in your autotests, which will be pleasant and convenient to use. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a bonus, we gain knowledge about how the application works from the inside. </font><font style="vertical-align: inherit;">At a minimum, this is useful for overall development, and often helps a lot when testing.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. The test code looks very neat and clean.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are no comments, this is really flavoring. </font><font style="vertical-align: inherit;">About how for you "more accurate and cleaner" can be decided by the very first example.</font></font><br>
<br>
<p></p><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pitfalls // how they stumbled and went around</font></font></h1><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gd/4a/jz/gd4ajzpobkjvg6t4tq1vy-3a-ws.jpeg" width="60%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We can conclude that it is better to use the factory of page objects when writing autotests. </font><font style="vertical-align: inherit;">Ask no one why they use the factory, there is always one answer: "And you try to write a test without it and compare." </font><font style="vertical-align: inherit;">The factory really takes on a significant part of the tasks, responsibility for the absence of errors in the sequence of the autotest, and so on. </font><font style="vertical-align: inherit;">It also opens up some interesting opportunities that I wrote about above.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But I want to note that everything is not always rosy with these capabilities. </font><font style="vertical-align: inherit;">During automation with the factory, we encountered very unpleasant problems, but in the end we solved them.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protocols and elements common to the entire application</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are elements in any mobile application that can be accessed from any screen. For example, you can take a tabbar (menu). The question arises: how, without interrupting the chain of calls to page object methods, get access to the methods of the tabbar at any time in the test?&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The most obvious and our initial decision is to make the extension of the base class of page objects with these methods.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> XCTest<font></font>
 <font></font>
<span class="hljs-comment">/*
      .
 */</span>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> tabBar = application.tabBars[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.identifier].firstMatch
    <span class="hljs-keyword">var</span> searchTab =  tabBar.buttons[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.searchTab].firstMatch<font></font>
    ‚Ä¶<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span> {<font></font>
        searchTab.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory.makeMainScreenPageObject()<font></font>
    }<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
During the discussion, we realized that the tabbar is not the only element that is needed on all screens, and came to the conclusion that by adding more and more extensions, we will quickly clutter up the base class. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another disadvantage of this solution is that the methods become available for all page objects, which is wrong. This breaks the contract for successor classes, which, in theory, should contain only methods specific to them. For example, for page alert objects, tabbar methods are not needed.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our final solution - we made the TabBarUsable protocol from Tabbar‚Äôs page object (the interface for Kotlin is similar). And they wrote its extension (extension, implementation), which allows you to not duplicate the code, and at the same time replace inheritance with the composition.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> XCTest<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TabBarUsable</span> </span>{
    <span class="hljs-keyword">var</span> searchTab: <span class="hljs-type">XCUIElement</span> { <span class="hljs-keyword">get</span> }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span><font></font>
    ‚Ä¶<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">TabBarUsable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> tabBar: <span class="hljs-type">XCUIElement</span> { application.tabBars[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.identifier].firstMatch }
    <span class="hljs-keyword">var</span> searchTab: <span class="hljs-type">XCUIElement</span> { tabBar.buttons[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.searchTab].firstMatch }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span> {<font></font>
        searchTab.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory.makeMainScreenPageObject()<font></font>
    }<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For all screens that have a tabbar, we add compliance with this protocol (conform).</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span> </span>{<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Accordingly, all methods of working with a tabbar become available on all of these screens.&nbsp;</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleTabbarTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleOpenSearchTab</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy() <span class="hljs-comment">//   .makeVacancyPageObject()</span>
            .openSearchTab() <span class="hljs-comment">//   TabBarUsable </span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the same time, the architecture does not break, the methods of the tabbar are available only for the screens we need, and the code of the same methods is not duplicated.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protocols and Code Revision</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As mentioned earlier, when using the page object factory, all actions and all checks are wrapped in methods. </font><font style="vertical-align: inherit;">After a while, creating the next autotest, you begin to notice that you write the same methods for each page object, which do not even differ in elements. </font><font style="vertical-align: inherit;">Examples of such methods include checking zeroscreens, working with the same list items on different screens, and so on.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/a2/xg/ic/a2xgiczqetidmsoqa2rl2aandjo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is a logical thought: ‚ÄúI‚Äôll make it easier for me ?!‚Äù. How to stop duplicating code? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first method that I already wrote about is to put all such methods into the base class. It is possible, but very carefully. Firstly, this process is very fascinating. It seems that one method in the base class will not ruin anything, but sooner or later the base class will turn into an unbearable, unstructured, cluttered-up monster, in short, it becomes completely unsuitable. We tried, we know. Getting rid of this monster is even harder than immediately doing it right.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Over time, we realized that the DRY (Don't Repeat Yourself) principle was invented for a reason. We began to look for the same methods that are used in many page objects. Having found them, they discussed for a long time whether these methods are really used the same everywhere, have the same logic. And finally, they decided that if the methods are used in 80% of cases the same way, then they should be taken out in a separate protocol.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the very first methods rendered was the waitView () method. We have described the special protocol ViewWaitable and its implementation in the protocol extension, and now, in order for this method to be available in the page object, you just need to add conformance to the protocol (conform). Since the view identifiers are different for all screens, all page objects using the protocol must declare a view in themselves.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewWaitable</span> </span>{
    <span class="hljs-keyword">var</span> view: <span class="hljs-type">XCUIElement</span> { <span class="hljs-keyword">get</span> }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewWaitable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-meta">@discardableResult</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">waitView</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> {<font></font>
        testWaiter.waitForElementToAppear(view)<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span>, <span class="hljs-title">ViewWaitable</span> </span>{<font></font>
 <font></font>
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> view = application.otherElements[<span class="hljs-type">Accessibility</span>.view].firstMatch<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another example from our hh.ru application: we have a list of vacancies that can be found on many different screens, with the only difference being the view identifier on which this list is displayed. A lot of actions and a ton of checks are associated with this list. Multiply them by about 10 (by the number of screens this list appears on) to estimate the scale of code duplication.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The solution was again the protocols. To make the protocols even more understandable and enjoyable to use, we divided the list elements (VacancyListContainig), the cell elements (VacancyCellContainig), the methods with checks (asserts, checks) and the interaction methods (actions). This separation perfectly solved the problem of readability of the contents of a huge page object. The final architecture looks like this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/sx/zw/_j/sxzw_jfnqwufs2snkgohmzxawb4.png" width="50%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Page objects on which there is a list of vacancies can add compliance to the VacancyListPageObject protocol. </font><font style="vertical-align: inherit;">Thus, all methods from the implementation of this protocol become available to the screen without duplication of code.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchResultPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">ViewWaitable</span>, <span class="hljs-title">VacancyListPageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> view = application<font></font>
        .otherElements[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">SearchResults</span>.view].firstMatch
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> listView = application<font></font>
        .tables[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">SearchResults</span>.tableView].firstMatch<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, due to following the DRY principle, we have very clean, neat page objects, the same method names, and the lack of extra code.&nbsp;</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same alerts on different screens // Sources</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
System errors, alerts, bottom sheets are an integral part of regressions, which I certainly want to cover with automatic tests. Errors and alerts occur on different screens, in different cases, differ in different application states, but the elements themselves, basically, have the same identifiers and behavior. Obviously, the same type of alert with two buttons (for example, Ok / Cancel) = one separate page object.&nbsp;&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We return to the desire not to interrupt the chain of method calls. We have - dozens of screens from which we can open the same alert. When closing such an alert, we must return to the page object from which it was opened. At the same time, we do not want to write these same dozens of duplicate methods in the page object of such an alert, which will differ from each other only in the returned page object.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The simplest solution is to score and break the test once. </font><font style="vertical-align: inherit;">There is nothing wrong with that either. </font><font style="vertical-align: inherit;">And so life is much simpler.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExample</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy()<font></font>
            .openAlert()<font></font>
            .closeAlert() <span class="hljs-comment">//      ,     </span><font></font>
        pageObjectFactory<font></font>
            .makeVacancyPageObject() <span class="hljs-comment">//   </span><font></font>
        ‚Ä¶<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our solution is more complicated, but how beautiful it is! </font><font style="vertical-align: inherit;">We added the page object of the alert type parameter ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), it will be the type of the page object from which we open the alert. </font><font style="vertical-align: inherit;">In this case, the page object of this screen is passed to the page object alert upon initialization and is stored as a generic source variable.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
More about how this works: when you open (and initialize) an alert, we pass the desired screen in the source generic variable. </font><font style="vertical-align: inherit;">This is done in the page object method, which opens the alert:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    ‚Ä¶<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openAlert</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AlertPageObject</span>&lt;<span class="hljs-type">VacancyPageObject</span>&gt; {<font></font>
        button.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeAlertPageObject(from: <span class="hljs-keyword">self</span>) <span class="hljs-comment">//  source VacancyPageObject</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, this source (in this example, VacancyPageObject) passes through all the methods needed in the test and ends up in the final dismissAlert (). </font><font style="vertical-align: inherit;">As a result, the alert closing method returns the screen we need, on which we can immediately continue the test.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlertPageObject</span>&lt;<span class="hljs-title">Source</span>: <span class="hljs-title">BasePageObject</span>&gt;: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dismissAlert</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Source</span> {<font></font>
        cancelButton.tap()<font></font>
        <span class="hljs-keyword">return</span> source <span class="hljs-comment">//  ,     ‚Äî VacancyPageObject</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As I have already said, so that the page object can receive and return the necessary screens (sources), it needs to assign a generic type limited to the base type of page objects and initialize it using a page object, which will need to be returned at the very end :</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlertPageObject</span>&lt;<span class="hljs-title">Source</span>: <span class="hljs-title">BasePageObject</span>&gt;: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-comment">// generic-          </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> source: <span class="hljs-type">Source</span><font></font>
 <font></font>
    <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>,<font></font>
         application: <span class="hljs-type">XCUIApplication</span>,<font></font>
         source: <span class="hljs-type">Source</span>) {
        <span class="hljs-keyword">self</span>.source = source
        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(pageObjectsFactory: pageObjectsFactory, application: application)<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-comment">//  BasePageObject   ,      </span>
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>, application: <span class="hljs-type">XCUIApplication</span>) {
        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"init(pageObjectsFactory:application:) has not been implemented. Use another init"</span>)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialization of the generic page object in the factory will look like this:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageObjectsFactory</span> </span>{<font></font>
    ‚Ä¶<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeAlertPageObject</span>&lt;Source: BasePageObject&gt;<span class="hljs-params">(
        from source: Source
    )</span></span> -&gt; <span class="hljs-type">AlertPageObject</span>&lt;<span class="hljs-type">Source</span>&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-type">AlertPageObject</span>(pageObjectsFactory: <span class="hljs-keyword">self</span>,<font></font>
                                          application: application,<font></font>
                                          source: source)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ta-daa! </font><font style="vertical-align: inherit;">Everything is ready, and now we can continue the test without breaking the call chain.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleSourcesTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleSource</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy()<font></font>
            .openAlert()<font></font>
            .dismissAlert()<font></font>
            .checkVacancyScreenIsOpened() <span class="hljs-comment">//       ,         </span><font></font>
        ‚Ä¶<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gn/rt/hs/gnrthsrb0jerc7jtimpsmfqeryw.jpeg" width="70%"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huge page object, how to understand it</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are screens (though there are), which host a lot of different content, various interface elements, individual logical blocks. At the same time, they are all on the same screen, and I want to interact with them through the page object, which describes this screen.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, take the main screen of our mobile application.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/2a/bc/v8/2abcv8sw0r9idx5m53mrj7hcf8u.jpeg" width="40%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This screen can be divided into three completely independent sections: the search bar, the search history block and the tabs with job listings. It would be possible to describe everything in one page object-e (after all, this is a separate full-fledged screen), but it will not be very convenient to use it, since each section has its own logic, its own checks, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also, in expanding page objects, sooner or later, the problem of method names arises. There are many different cells, titles, subtitles, etc., as a result, instead of simple names, you have to give long ones, with clarifications to what exactly they relate. Writing tests becomes very inconvenient and difficult. Each time you select a method in the test, you need to open the page object code and carefully delve into it so as not to make a mistake.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyListPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    ‚Ä¶<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertHistoryListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertHistoryListCellByTitleExists</span><span class="hljs-params">(title: String)</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertRecommendationsListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertVacancyNearbyListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }<font></font>
    ‚Ä¶  <font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/ia/_g/zwia_gz_wjygrw7tpmis1_gnx8q.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The simplest solution is not to see the problem. No matter how big the page object may be, you can still use it (especially if you get used to it). But I don‚Äôt want to get used to it, but I want it to be beautiful and comfortable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus, these "sections" can be different modules in the code, which means that they can be reused on different screens of the application. If we build a similar architecture with page objects, we can also reuse them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We made a strong-willed decision - now for such sections we are writing different classes of page objects. To each of them we add correspondence to the unifying empty MainScreenSection protocol: BasePageObject {}. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, take the search history section on the main screen. Its page object will look like this:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchHistoryPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">MainScreenSection</span> </span>{
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basically, the page object of MainScreenPageObject, which describes the main screen, we made a method by which we say from the test in which section we are going to do something now. </font><font style="vertical-align: inherit;">It looks like this.&nbsp;</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainScreenPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span> </span>{<font></font>
    ‚Ä¶<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">section</span>&lt;Section: MainScreenSection&gt;<span class="hljs-params">(<span class="hljs-number">_</span> section: Section.<span class="hljs-keyword">Type</span>)</span></span> -&gt; <span class="hljs-type">Section</span> {
        <span class="hljs-keyword">return</span> section.<span class="hljs-keyword">init</span>(pageObjectsFactory: pageObjectsFactory, application: application)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this method, we pass the type of section, inside we initialize the page object using the generic factory method.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, we got an uninterrupted test, lack of unnecessary initializations of huge page objects, and code readability.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//        ‚Äú ‚Äù</span>
    .openSearchTab() <span class="hljs-comment">//   MainScreenPageObject</span>
    .section(<span class="hljs-type">SearchHistoryPageObject</span>.<span class="hljs-keyword">self</span>) <span class="hljs-comment">//     </span>
    .waitHistoryIsLoad() <span class="hljs-comment">//   page object-  </span>
    .section(<span class="hljs-type">MainScreenPageObject</span>.<span class="hljs-keyword">self</span>) <span class="hljs-comment">//       </span>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summarize</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can write autotests without a factory of page objects. Page objects with this approach are written very quickly and simply, especially if they do not need complex initialization. But, on the other hand, when writing a test, you need to be extremely careful. The responsibility for the sequence of steps in the test, the initialization of page objects, the lack of a wrapper over some actions, etc. lies with the tester. If your application is not very complicated, then it may not be worth complicating, and all of the problems listed will be generally invisible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If, at the very beginning, you sit a bit over the creation of the factory, then in the future it will, firstly, take upon itself all of the above responsibilities, and secondly, it will make the process of writing autotests very simple and almost without a chance of error.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/uc/i6/ta/uci6takmotdv_r0ujdl5kbv3_3a.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since there is no single right decision, it is up to you to decide. </font><font style="vertical-align: inherit;">We continue to use both approaches, and everyone is comfortable and well. </font><font style="vertical-align: inherit;">Good luck and beautiful autotests!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Useful links:</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Article about the Page Object pattern</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cool article on the role of architecture in automation</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kotlin DSL, Fixtures and elegant UI tests in Android</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interfaces, Protocols, and Extensions / Swift vs. </font><font style="vertical-align: inherit;">Kotlin</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The power of generics in Swift</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en507032/index.html">Book ‚ÄúSell your portfolio. What is not taught in design schools "</a></li>
<li><a href="../en507034/index.html">Webstorm NodeJs interpreter from Docker container</a></li>
<li><a href="../en507040/index.html">How to reduce the registration of damage under compulsory motor liability insurance from a few days to 60 minutes</a></li>
<li><a href="../en507042/index.html">I want to gamedev: 27 replies from 8 pros</a></li>
<li><a href="../en507044/index.html">The most affordable board for experimenting with SoC'om MCU & FPGA</a></li>
<li><a href="../en507050/index.html">Analysis of the Hollow Knight game design. Part 1. Forgotten Crossroads</a></li>
<li><a href="../en507052/index.html">The coolest Data Scientist does not waste time on statistics</a></li>
<li><a href="../en507058/index.html">Joel Spolsky: Gamification Role in Stack Overflow Success</a></li>
<li><a href="../en507066/index.html">10 Ways to Automate Ads on Google Ads</a></li>
<li><a href="../en507068/index.html">Windows Management Instrumentation (WMI) Guide: Understanding WMI Attacks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>