<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍴 🐓 👨🏻‍🚒 MySQLのGoドライバーの3つのバグ 🌼 🌞 ➗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rubyの初期実装の速度と信頼性に満足できなかったため、過去数年にわたって、RailsモノリスGitHub.comから重要な機能を徐々に削除し、Goのコードの一部を書き直しました。たとえば、昨年のGithub Satelliteで、サービスを使用した「より制御された承認」の可能性を発表し、実装しまし...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>MySQLのGoドライバーの3つのバグ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/503586/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rubyの初期実装の速度と信頼性に満足できなかったため、過去数年にわたって、RailsモノリスGitHub.comから重要な機能を徐々に削除し、Goのコードの一部を書き直しました。たとえば、昨年のGithub Satelliteで、サービスを使用した「より制御された承認」の可能性を発表し、実装しました</font></font><code>authzd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業それが</font></font><code>authzd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">判明</font><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">、それがWeb要求中に生産上のMySQLデータベースからデータを読み込むと協力のために行くの私たちの最初のサービスだったので、私たちにとって非常に興味深く、重要な作業になります。他のMySQLベースのデータベースサービスをGoにデプロイした経験はありましたが、これらは内部制御サービス（クラスター検索エンジン）でした</font></font><code>manticore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、または非同期バッチジョブ（Gitバックアップオーケストレーター</font></font><code>gitbackups</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><code>authzd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Railsモノリスへの通常のリクエストではこのサービスを複数回呼び出すため、</font><font style="vertical-align: inherit;">パフォーマンスと信頼性の要件</font><font style="vertical-align: inherit;">は、重大度の増加によって区別されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、KubernetesクラスターでTCP接続を開くときに長い遅延が発生する問題は、Go MySQLドライバーの接続プールに特に影響しました。これは、私たちがデプロイしたKubernetesにあったため、作業が追加されました</font></font><code>authzd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この点に関してプログラマーの最も危険な自己欺瞞の1つは、ネットワークの信頼性への信念です。なぜなら、そうです、ほとんどの場合、ネットワークは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本当に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信頼できます...しかし</font><font style="vertical-align: inherit;">、ネットワークが</font><font style="vertical-align: inherit;">遅くなったりジャンクになったりするとすぐに、同じ基本ライブラリーの基本的な問題に追いつき、すべてが崩れ始めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで</font></font><code>authzd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、SQLを介して、さらにはアクセシビリティの目標に従ってさえ、すべての作業トラフィックを処理</font><font style="vertical-align: inherit;">する準備をする</font><font style="vertical-align: inherit;">のにどれ</font><font style="vertical-align: inherit;">くらいの費用がかかりました</font><font style="vertical-align: inherit;">か？</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">秋</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2年以上前、私は最初に、MySQLである既知のすべてのバグから最もわかりにくいzareportilを発見しました</font></font><code>"Invalid connection (unexpected EOF)"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">バックアップオーケストラ（</font></font><code>gitbackups</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">のオリジナルバージョンの本番環境への展開中に初めて遭遇したとき、</font><font style="vertical-align: inherit;">MySQLドライバーに同行しているチームがバグを修正する方法を決定できなかったため、アプリケーションコードを編集して問題を回避せざるを得ませんでした。</font><font style="vertical-align: inherit;">このバグは昨年、再び</font></font><code>authzd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本番</font><font style="vertical-align: inherit;">環境</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">の最初の展開中に現れました。</font><font style="vertical-align: inherit;">誤った応答の頻度は、</font><font style="vertical-align: inherit;">1分あたり</font></font><code>authzd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数百から数百のエラーを背景に急激に増加しました</font></font><code>Invalid connection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">システムのこの動作により、再びバグを取り上げる必要があり、アプリケーションコードを変更する必要がないこの問題の修正を最終的に開発しました。</font><font style="vertical-align: inherit;">それを詳しく見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題の解決策</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go SQLドライバーの目標は、「SQL接続」を提供すること</font></font><code>database/sql</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。これ</font><font style="vertical-align: inherit;">は、標準のGoライブラリに含まれるパッケージの一般的なプリミティブ</font><font style="vertical-align: inherit;">です。ドライバーはステートフルな接続を提供し、MySQLやPostrgresを含むすべての大規模なSQLサーバーでは、これらの接続を並行して行うことはできません。パッケージは</font></font><code>database/sql</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そのような接続のアクセスと期間を制御し、SQLデータベースで実行されるすべての可能な操作のエントリポイントであり、その構造</font></font><code>DB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ドライバーによって提供される個々の接続のプールを抽象化したものです。したがって、フォーム</font></font><code>(*DB).Query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>(*DB).Exec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には複雑なロジックが必要です。最初に、接続プールからアクティブで空きのある接続を選択するか、他のすべてがビジーなときにメインドライバーを呼び出して新しい接続を作成し、コマンドまたは要求を実行して接続をプールに戻すか、プールがすでにいっぱいになったときに接続をリセットします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
で作業するたびに</font></font><code>gitbackups</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>authzd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちはプールから接続を取って、要求を行った、私たちは「予期しないEOF」エラーが発生しました、そして、ログによると、MySQLサーバは、接続が行くプールで長時間タイムアウトし閉じ</font></font><code>sql.(*DB)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。同時に、接続が多すぎないようにするため、本番環境でのMySQLクラスターの待機時間は厳密に制限されています-30秒以内。それでも、エラーが常に通知されると、かなり困惑しました。深刻な問題でした。サービスが原因でサービスが常に低下していたからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TCP接続の中断に異常はありません。特別なドライバーの実装の助けを借りて、パッケージ</font></font><code>database/sql</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、プールからの何百もの同時接続の任意の時点での中断を処理できます</font></font><code>(*DB)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。閉じているか、パッケージが悪いか、SQL接続に問題があるかどうかに関係なく、ドライバーは</font></font><code>driver.ErrBadConn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考えられるさまざまな理由のいずれかでドライバー接続が異常になったことに気づいたら、接続内のメソッドの次の呼び出し。</font></font><br>
<br>
<code>ErrBadConn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これは</font></font><code>database/sql</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、接続が状態の維持と無関係で</font><font style="vertical-align: inherit;">あることをパケットに示すような魔法の信号</font><font style="vertical-align: inherit;">です。接続がプール内にあった場合は、そこから削除する必要があり、要求を実行するためにすでに選択されている場合は、現在の接続をドロップして、新しい接続を選択または作成する必要があります。この動作を前提とする</font></font><code>(*DB).Query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、「無効な接続」エラーが原因で落下</font><font style="vertical-align: inherit;">することはありません。</font><font style="vertical-align: inherit;">リターンを使用すると、</font></font><code>driver.ErrBadConn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リクエストは新しい接続で静かに再生されるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、これらの無効な接続エラーの原因は</font></font><code>authzd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その上にあるTCPプロトコルとMySQLプロトコルの間には非常に微妙な相違があります。完全な双方向TCP接続では、データは相互に独立して双方向に自由に送信されますが、MySQLプロトコルがコマンドフェーズにある場合、クライアント側が完全に制御します。これは、MySQLサーバーがクライアントからのパッケージに応答してのみMySQLパッケージをクライアントに転送するためです。たとえばタイムアウトやビュープロセスの接続をアクティブに切断する障害が原因で、サーバーがコマンドフェーズでアクティブな接続を閉じると</font></font><code>pt-kill</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、この状況が問題につながります。ネットワークダイアグラムを見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ac/vt/go/acvtgo950p2opsbromaxsv3ou_k.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図1：ネットワークダイアグラムは、MySQLサーバーとMySQLクライアント間のパケット転送を示しています。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このバグの視覚化では、標準のTCPハンドシェイクと、MySQLレベルでのリクエストとレスポンスの次のペアを観察できます。 MySQLサーバーへの新しいリクエストなしの長い中断の後、サーバーのタイムアウトが発生し、サーバーはアクティブなソケットを閉じます</font></font><code>close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 TCPサーバーがソケットを閉じると、そのコアはペアをクライアント</font></font><code>[FIN, ACK]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に送信します。これは、サーバーがデータの送信を完了したことを意味します。クライアントのコアは</font></font><code>[FIN, ACK]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">応答</font></font><code>[ACK]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">確認します</font><font style="vertical-align: inherit;">が、接続の側面はまだ閉じていません。これは「完全な双方向接続」を意味します。クライアントの記録側-&gt;サーバー接続は独立しており</font></font><code>close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、クライアントからの</font><font style="vertical-align: inherit;">呼び出しによって明示的に閉じる必要が</font><font style="vertical-align: inherit;">あります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアント</font></font><code>read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はサーバーから読み取り、受信するとすぐに</font></font><code>[SYN, ACK]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次の読み取りではエラーが返されます</font></font><code>EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、サーバーがこの接続にデータを書き込まないことをカーネルが認識しているため、この状況では通常、TCP経由のほとんどのプロトコルで問題は発生しません。我々は先に述べたようにしかし、クライアントはサーバーからデータを読み込み</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">後</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すぐにMySQLの接続は、そのコマンドフェーズにあるようとして、MySQLのプロトコルは、クライアントによって制御されるため、サーバーは、唯一のクライアントからの要求に応じてデータを送信するので、要求を送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような接続の結果は、図にはっきりと表示されています。待機期間の後、</font></font><code>write</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接続側がまだ開いているので、</font><font style="vertical-align: inherit;">サーバー</font><font style="vertical-align: inherit;">にリクエスト</font><font style="vertical-align: inherit;">を正常に送信</font><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。応答として、サーバーはパケットを送信します</font></font><code>[RST]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、サーバーはすでに閉じられているため、これはまだわかりません。その後、クライアントはMySQLサーバーからの応答を読み込もうとし、エラー</font></font><code>EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">受け取り</font><font style="vertical-align: inherit;">、接続が中断されたことを遅らせます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、MySQL接続が中断された理由（関係がなくなります）はわかりましたが、その後のアプリケーションクラッシュの理由はわかりません。中断したときにMySQLドライバーが返されないのはなぜ</font></font><code>driver.ErrBadConn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですか？そして、なぜそれ</font></font><code>database/sql</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が新しい接続を介してリクエストを転送する</font><font style="vertical-align: inherit;">ことを許可しないの</font><font style="vertical-align: inherit;">ですか？残念ながら、オープンリクエストの転送は安全ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の図のように、イベントが頻繁に発生します。本番環境のMySQLクラスターは、毎分数千のケースを記録します。多くの場合、サービスがアイドル状態でタイムアウトしている最混雑していない時間帯です。ただし、タイムアウトだけではなく、接続が中断される可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正常に接続し</font></font><code>UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、MySQLがそれを実行し、サーバーが応答する前にネットワークがシャットダウンするとどうなりますか？ Goを書き込む実際のリクエストの後、MySQLドライバーも応答</font></font><code>EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として</font><font style="vertical-align: inherit;">エラーを受け取り</font><font style="vertical-align: inherit;">ますが</font></font><code>driver.ErrBadConn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">返された場合</font></font><code>database/sql</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は起動します</font></font><code>UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい接続。しかし、これはデータの破損です！典型的な場合（MySQLが接続を強制終了した場合）、恐れることなくリクエストをリダイレクトできることがわかっているようです。リクエストをネットワークに書き込むときにエラーは発生せず、MySQLはそれを受信しなかったことがわかります。 。しかし、そのような状況では、最悪の事態を予想して、リクエストがまだサーバーに到達しているという事実から先に進む必要があります。そしてそれが帰国が</font></font><code>driver.ErrBadConn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">ない</font><font style="vertical-align: inherit;">理由</font><font style="vertical-align: inherit;">です。なんて卑劣な状況なのでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これをどのように処理できますか？最も簡単な解決策-しばらく使用した-を</font></font><code>gitbackups</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントに呼び出し</font></font><code>(*DB).SetConnMaxLifetime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そのような接続の継続時間のしきい値をMySQLクラスタの待機タイムアウト未満に設定しました。同様の方法は理想とはほど遠い：</font><i><font style="vertical-align: inherit;">全体として</font></i></font><code>SetConnMaxLifetime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大期間</font><i><font style="vertical-align: inherit;">を</font></i><font style="vertical-align: inherit;">設定する</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待機時間</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ではなく</font><font style="vertical-align: inherit;">。このため、</font></font><code>database/sql</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接続アクティビティのステータスやサーバーがタイムアウトによって中断する準備ができているかどうかに関係なく、タイマーに従って厳密に接続を中断します。すべてのサーバーが保留タイムアウトの概念を実装し</font></font><code>database/sql</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ているわけではない</font><font style="vertical-align: inherit;">ため、パッケージに</font><font style="vertical-align: inherit;">は「最大待機時間」のAPIがありません。ああ、抽象化の範囲...実際には、MySQLサーバーがアクティブに接続を切断するネットワークの再接続やケースを考慮しない場合、この方法はそれらを検出しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最適なオプションは、化合物がプールから取得された後、</font></font><code>write</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要求が送信される</font><font style="vertical-align: inherit;">前に、化合物のヘルスステータスを確認</font><font style="vertical-align: inherit;">することです。残念ながら、インターフェースの前</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><code>SessionResetter</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go 1.10では、いつ接続がプールに戻ったかを知ることは不可能でした。そのため、バグは適切な修正なしに約2年間ハングしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような接続のヘルスステータスは、MySQLレベルとTCPレベルの2つの方法で確認できます。 MySQLレベルでのテストには、パッケージの送信</font></font><code>PING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と応答の待機が</font><font style="vertical-align: inherit;">含まれます。</font><font style="vertical-align: inherit;">また</font></font><code>PING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、MySQLで書き込み操作を実行しないため（私はそう思います）、この場合は安全に返すことができます。</font></font><code>driver.ErrBadConn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。一方、この方法の明らかな欠点は、プールからの最初の接続操作にランダムな遅延が追加されることです。その結果、MySQLサーバーはNCPレベルで接続を閉じるかどうかを確認することにしました。これは、Goアプリケーションでは接続がプールに追加されたりプールから削除されたりすることが多く、別のメソッドの追加の遅延が少し面倒です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TCPレベルでのチェックは非常にシンプルで、リソースに要求がありません。レコードを作成する前に、接続の非ブロッキング読み取りを実行するだけで済みます。接続がまだ開いている場合、</font></font><code>EWOULDBLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（まだ）読み取りデータがないため、</font><font style="vertical-align: inherit;">すぐにエラーが発生</font><font style="vertical-align: inherit;">します。サーバーが接続の側を閉じている場合は、すぐに使い慣れた回答が返されます</font></font><code>EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。さらに、Goプログラムのすべてのソケットは、すでに非ブロッキングモードに設定されています。しかし、エレガントなGoroutines抽象化にだまされないでください。その美しいGoファサードの下で、スケジューラは非同期イベントループを使用してGoroutinesを落ち着かせ、データを読み取ったときにだけそれらを起動します。 （異常ですよね？）残念ながら、ビューメソッドを使用してノンブロッキングの読み取りを行うことはできません</font></font><code>net.Conn.Read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。そうしないと、スケジューラによってスリープ状態になります（ここでも、エレガントなGoroutines抽象化）。正しいノンブロッキングリードインターフェースはGo 1.9で最初に登場し</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><code>(*TCPConn).SyscallConn</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました。メインのファイル記述子にアクセスでき、システムコールを直接使用できます</font></font><code>read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいAPIで武装し、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5マイクロ秒未満のping </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">で「廃止された接続」の問題を解決した、接続のヘルスチェックを実装することができました</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これはそれらの本質であり、ブロックしないことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソリューションを運用環境に導入すると、すべての「無効な接続」のジャンプがすぐになくなり、サービスの可用性が初めて9ポイントに達しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bt/4o/el/bt4oelevoxhxceszgjm_sacofta.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2：</font></font><code>authzd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロダクション</font><font style="vertical-align: inherit;">に入った後のクライアント側でのジャンプと再試行</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制作のヒント</font></font></h3><br>
<ul>
<li>  MySQL         ,      <code>(*DB).SetConnMaxLifetime</code>,          .           ,     .</li>
<li>  <code>sql.(*DB)</code>  (<code>(*DB).SetMaxIdleConns</code>  <code>(*DB).SetMaxOpenConns)</code>  ,         ,         MySQL.   ,      MySQL     :        .</li>
</ul><br>
<h2></h2><br><font style="vertical-align: inherit;"></font><code>authzd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モノリスの標準リクエストルートに依存関係</font><font style="vertical-align: inherit;">
などのサービスを追加すると</font><font style="vertical-align: inherit;">、その応答時間は、アプリケーションのすべてのリクエストまたは1つまたは別の認証方法を使用したリクエストの合計レスポンス時間に追加されます。クエリ処理時間</font></font><code>authzd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">長すぎると</font><font style="vertical-align: inherit;">、パフォーマンスが大幅に低下する可能性があるため、割り当てられた時間内にクエリが完了するようにすることが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Railsの側では、サービスのRPCリクエストをどのように実行するか、およびそれらを時間内に追跡する方法に非常に注意する必要があります。 Goのサーバー側では、これは1つのことだけを意味します- </font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 API</font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは数年前から個別のライブラリとして利用可能でしたが、Go 1.7でのみ標準ライブラリに導入されました。このパッケージの考え方は簡単です</font></font><code>context.Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。サービスリクエストのサービスライフサイクルに関連するすべての機能を</font><font style="vertical-align: inherit;">転送することにより、サービスにリクエストのゼロ化を認識させること</font><font style="vertical-align: inherit;">です。各着信HTTP要求は</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、クライアントが早期に切断された場合にリセットされる</font><font style="vertical-align: inherit;">オブジェクト</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">提供します</font><font style="vertical-align: inherit;">。これにより、単一のAPIを介して早期ゼロ化と要求タイムアウトを使用できます。また、</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">締め切りを延長</font><font style="vertical-align: inherit;">することができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいサービスの開発を担当するエンジニアのチームは、</font></font><code>authzd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">転送の</font><font style="vertical-align: inherit;">すべての方法を確実にするという素晴らしい仕事をしました</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、MySQLにクエリを送信するメソッドを含みます。これは、リソースの観点から見ると、リクエストのライフサイクルの中で最もコストがかかる部分なので</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、リクエストメソッド</font><font style="vertical-align: inherit;">に渡すことが基本的に重要</font></font><code>database/sql</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。これらのメソッド</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が処理に時間がかかりすぎる場合に備えて、MySQLクエリをすばやくゼロ</font><font style="vertical-align: inherit;">にできるようにする必要があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、実際には、すべてが</font></font><code>authzd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リクエストのゼロ化やタイムアウトを考慮し</font><font style="vertical-align: inherit;">て</font><font style="vertical-align: inherit;">いない</font><font style="vertical-align: inherit;">かのように見えました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4d/hl/lp/4dhllp-enjbssp8z3ykqgv23bd0.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3：サービス間デプロイメントの応答時間</font></font><code>authzd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。認識機能のタイムアウトは1000ミリ秒に設定されました。これは赤い破線で理解できますが、ランダムジャンプでは理解できず、良好な5000ミリ秒に達しています。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これらのメトリックを一目見れば十分理解できます。</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションコード全体を介してのリクエストの場合、それらの一部のライフサイクルでは、ゼロ化が単に無視される場所があります。 Go MySQLドライバーを合理的に疑っている場合でも、コードを調べてそのような場所を見つけるのは非常に時間がかかるプロセスです。この状況で、コードがブロックされている場所を見つけたいので、何度か試してみましたが、本番ホストから実際のスタックトレースをキャッチしました。呼び出しでブロックされたものをキャッチするとすぐに、すべてが明らかになりました</font></font><code>QueryContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">0</span>  <span class="hljs-number">0x00000000007704cb</span> in net.(*sysDialer).doDialTCP<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/net/tcpsock_posix.<span class="hljs-keyword">go</span>:<span class="hljs-number">64</span>
 <span class="hljs-number">1</span>  <span class="hljs-number">0x000000000077041a</span> in net.(*sysDialer).dialTCP<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/net/tcpsock_posix.<span class="hljs-keyword">go</span>:<span class="hljs-number">61</span>
 <span class="hljs-number">2</span>  <span class="hljs-number">0x00000000007374de</span> in net.(*sysDialer).dialSingle<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/net/dial.<span class="hljs-keyword">go</span>:<span class="hljs-number">571</span>
 <span class="hljs-number">3</span>  <span class="hljs-number">0x0000000000736d03</span> in net.(*sysDialer).dialSerial<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/net/dial.<span class="hljs-keyword">go</span>:<span class="hljs-number">539</span>
 <span class="hljs-number">4</span>  <span class="hljs-number">0x00000000007355ad</span> in net.(*Dialer).DialContext<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/net/dial.<span class="hljs-keyword">go</span>:<span class="hljs-number">417</span>
 <span class="hljs-number">5</span>  <span class="hljs-number">0x000000000073472c</span> in net.(*Dialer).Dial<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/net/dial.<span class="hljs-keyword">go</span>:<span class="hljs-number">340</span>
 <span class="hljs-number">6</span>  <span class="hljs-number">0x00000000008fe651</span> in github.com/github/authzd/vendor/github.com/<span class="hljs-keyword">go</span>-sql-driver/mysql.MySQLDriver.Open<font></font>
    at /home/vmg/src/gopath/src/github.com/github/authzd/vendor/github.com/<span class="hljs-keyword">go</span>-sql-driver/mysql/driver.<span class="hljs-keyword">go</span>:<span class="hljs-number">77</span>
 <span class="hljs-number">7</span>  <span class="hljs-number">0x000000000091f0ff</span> in github.com/github/authzd/vendor/github.com/<span class="hljs-keyword">go</span>-sql-driver/mysql.(*MySQLDriver).Open<font></font>
    at &lt;autogenerated&gt;:<span class="hljs-number">1</span>
 <span class="hljs-number">8</span>  <span class="hljs-number">0x0000000000645c60</span> in database/sql.dsnConnector.Connect<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/database/sql/sql.<span class="hljs-keyword">go</span>:<span class="hljs-number">636</span>
 <span class="hljs-number">9</span>  <span class="hljs-number">0x000000000065b10d</span> in database/sql.(*dsnConnector).Connect<font></font>
    at &lt;autogenerated&gt;:<span class="hljs-number">1</span>
<span class="hljs-number">10</span>  <span class="hljs-number">0x000000000064968f</span> in database/sql.(*DB).conn<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/database/sql/sql.<span class="hljs-keyword">go</span>:<span class="hljs-number">1176</span>
<span class="hljs-number">11</span>  <span class="hljs-number">0x000000000065313e</span> in database/sql.(*Stmt).connStmt<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/database/sql/sql.<span class="hljs-keyword">go</span>:<span class="hljs-number">2409</span>
<span class="hljs-number">12</span>  <span class="hljs-number">0x0000000000653a44</span> in database/sql.(*Stmt).QueryContext<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/database/sql/sql.<span class="hljs-keyword">go</span>:<span class="hljs-number">2461</span>
[...]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちが思ったほど要求を</font><font style="vertical-align: inherit;">広めなかったこと</font><font style="vertical-align: inherit;">です。 SQLを実行するときには、我々が合格問い合わせると仮定</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するために</font></font><code>QueryContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、このコンテキストは、SQLクエリを実行し、タイムアウトするために使用され、私たちはAPIで極端なケースを欠場</font></font><code>database/sql/driver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。クエリを実行しようとしたときに、プールにSQL接続が1つもない場合は、呼び出しによって</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><code>driver.Driver.Open()</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい</font><font style="vertical-align: inherit;">接続を</font><font style="vertical-align: inherit;">作成する必要がありますが、このインターフェイスメソッドは</font></font><code>context.Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前のスタックトレースは、（8）での配布を停止し</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、単に</font></font><code>(*MysqlDriver).Open()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DSNを介してデータベースに。 MySQL接続を開くことは負荷の高い操作です。TCP、SSL通信（SSLを使用している場合）、MySQLハンドシェイクと認証、および基本的な接続オプションの設定が含まれます。合計で、少なくとも</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6つの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なるネットワーク接続</font><font style="vertical-align: inherit;">がタイムアウトルールに準拠していません</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらはすべて</font><font style="vertical-align: inherit;">、認識</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">不足しているためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで何をしようか？私たちの最初の試みは</font></font><code>timeout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、接続のDSNの</font><font style="vertical-align: inherit;">値を変更すること</font><font style="vertical-align: inherit;">でした。</font></font><code>(*MySQLDriver).Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCPを開きます。オープンTCPは接続を初期化するための最初のステップにすぎないため、これでは不十分でした。以降の手順（MySQLハンドシェイク、認証など）はタイムアウトに従わなかったため、1000ミリ秒を超えるリクエストはどこにも行きませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正しいソリューションでは、Go MySQLドライバーの大きなチャンクをリファクタリングする必要がありました。主な問題は、API </font></font><code>QueryContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">との</font><font style="vertical-align: inherit;">実装に伴うGo 1.8で発生しました</font></font><code>ExecContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。正式にはSQLクエリを無効にすることができましたが、その</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">認識に</font><font style="vertical-align: inherit;">もかかわらず</font><font style="vertical-align: inherit;">、メソッドは</font></font><code>driver.Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引数を取得するように更新されませんでした</font></font><code>context.Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Go 1.10の2つのパッチのみが新しいインターフェースを追加し、</font><i><font style="vertical-align: inherit;">個別</font></i></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><code>Connector</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に実装</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する必要がありました。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドライバー自体から。その結果、Go MySQLドライバーに同行するチームは、主に上記の問題と、古いインターフェースの可用性に関する潜在的な問題に関する情報の欠如により、新しいインターフェースの実装に煩わされませんでした。古いインターフェース</font><font style="vertical-align: inherit;">と新しい</font><font style="vertical-align: inherit;">インターフェースの</font></font><code>Driver.Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">両方をサポートするに</font><font style="vertical-align: inherit;">は、SQLドライバーの構造を大幅に変更する必要があったためです。 。</font><font style="vertical-align: inherit;">
幸いにも、そのようなリファクタリングには時間と忍耐の両方が必要でした。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">の新しいインターフェイスを使用</font></a><font style="vertical-align: inherit;">し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">て最終的なドライバーをアンロードした後</font></a><font style="vertical-align: inherit;">、スタックのトラックで、</font><font style="vertical-align: inherit;">新しいMySQL接続</font><font style="vertical-align: inherit;">を使用したコンテキストの正しい配布を確認しました</font><font style="vertical-align: inherit;">。</font></font><code>driver.Driver</code><font style="vertical-align: inherit;"></font><code>driver.Connector</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><code>Connector</code></a><font style="vertical-align: inherit;"></font><code>authzd</code><font style="vertical-align: inherit;"></font><code>QueryContext</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">0</span>  <span class="hljs-number">0x000000000076facb</span> in net.(*sysDialer).doDialTCP<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/net/tcpsock_posix.<span class="hljs-keyword">go</span>:<span class="hljs-number">64</span>
 <span class="hljs-number">1</span>  <span class="hljs-number">0x000000000076fa1a</span> in net.(*sysDialer).dialTCP<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/net/tcpsock_posix.<span class="hljs-keyword">go</span>:<span class="hljs-number">61</span>
 <span class="hljs-number">2</span>  <span class="hljs-number">0x0000000000736ade</span> in net.(*sysDialer).dialSingle<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/net/dial.<span class="hljs-keyword">go</span>:<span class="hljs-number">571</span>
 <span class="hljs-number">3</span>  <span class="hljs-number">0x0000000000736303</span> in net.(*sysDialer).dialSerial<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/net/dial.<span class="hljs-keyword">go</span>:<span class="hljs-number">539</span>
 <span class="hljs-number">4</span>  <span class="hljs-number">0x0000000000734bad</span> in net.(*Dialer).DialContext<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/net/dial.<span class="hljs-keyword">go</span>:<span class="hljs-number">417</span>
 <span class="hljs-number">5</span>  <span class="hljs-number">0x00000000008fdf3e</span> in github.com/github/authzd/vendor/github.com/<span class="hljs-keyword">go</span>-sql-driver/mysql.(*connector).Connect<font></font>
    at /home/vmg/src/gopath/src/github.com/github/authzd/vendor/github.com/<span class="hljs-keyword">go</span>-sql-driver/mysql/connector.<span class="hljs-keyword">go</span>:<span class="hljs-number">43</span>
 <span class="hljs-number">6</span>  <span class="hljs-number">0x00000000006491ef</span> in database/sql.(*DB).conn<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/database/sql/sql.<span class="hljs-keyword">go</span>:<span class="hljs-number">1176</span>
 <span class="hljs-number">7</span>  <span class="hljs-number">0x0000000000652c9e</span> in database/sql.(*Stmt).connStmt<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/database/sql/sql.<span class="hljs-keyword">go</span>:<span class="hljs-number">2409</span>
 <span class="hljs-number">8</span>  <span class="hljs-number">0x00000000006535a4</span> in database/sql.(*Stmt).QueryContext<font></font>
    at /usr/local/<span class="hljs-keyword">go</span>/src/database/sql/sql.<span class="hljs-keyword">go</span>:<span class="hljs-number">2461</span>
[...]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のドライバーをバイパスして、ドライバー</font></font><code>(*DB).conn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のインターフェイスを直接呼び出す</font><font style="vertical-align: inherit;">
方法に注意して</font></font><code>Connector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ください</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">さらに、グローバルリクエストタイムアウトがすべてのリクエストに適用されることが明らかになりました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ic/de/ft/icdeftwekixdpd39j6ep8cpsdtq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図4：タイムアウトが90msのRecognizer応答時間。</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">99パーセンタイルはグラフというよりバーコードのようなものなので、無視されない</font><font style="vertical-align: inherit;">ことは確かです</font><font style="vertical-align: inherit;">。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制作のヒント</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"></font><code>sql.(*DB)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいAPIを使用するために</font><font style="vertical-align: inherit;">初期化を変更する必要はありません</font></font><code>sql.OpenDB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>sql.Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go 1.10で</font><font style="vertical-align: inherit;">呼び出さ</font><font style="vertical-align: inherit;">れた</font><font style="vertical-align: inherit;">場合でも</font><font style="vertical-align: inherit;">、パケット</font></font><code>database/sql</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はインターフェイス</font></font><code>Connector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">通知</font><font style="vertical-align: inherit;">され、新しい接続が作成され、</font><font style="vertical-align: inherit;">通知</font><font style="vertical-align: inherit;">され</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></li>
<li>  ,      <code>sql.OpenDB</code>   <code>mysql.NewConnector</code>     ,         MySQL    <code>mysql.Config</code>,    DSN.</li>
<li>    MySQL  <code>?timeout=</code> (   <code>mysql.(Config).Timeout</code>),   ,               . </li>
<li>      <code>QueryContext</code> / <code>ExecContext</code>  SQL   .       <code>Context</code>       ,         .</li>
</ul><br>
<h2></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終的には、データの競合によって引き起こされる、非常に深刻で潜行性のあるセキュリティ上の問題が発生します。何について話し合いました。</font></font><code>sql.(*DB)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは状態ストレージ接続のプールのラッパーにすぎませんが、まだ触れていない詳細が1つあります。 SQLクエリを作成することは、最も一般的なデータベース操作の1つであり</font></font><code>(*DB).Query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、を通じて</font></font><code>(*DB).QueryContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">およびを通じて</font><font style="vertical-align: inherit;">、実際</font><font style="vertical-align: inherit;">にプールから接続を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">盗み</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">データベースからデータを返さない</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純な呼び出しとは異なり、</font><font style="vertical-align: inherit;">1つ以上の行を返します。アプリケーションのコードから読み取るために、サーバーがこれらの行を書き込む状態ストレージとの接続を制御する必要があります。これは、</font><font style="vertical-align: inherit;">各呼び出しの後に戻る</font><font style="vertical-align: inherit;">構造</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">私たちを助ける場所です。</font></font><code>(*DB).Exec</code><font style="vertical-align: inherit;"></font><code>(*DB).Query</code><font style="vertical-align: inherit;"></font><code>sql.(*Rows)</code><font style="vertical-align: inherit;"></font><code>Query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、</font></font><code>QueryContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼女はプールから盗んだ接続をラップして、そこから個々の行を読み取ります</font></font><code>Row</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。クエリ結果の処理が完了したときに呼び出されない</font></font><code>(*Rows).Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、盗まれた接続はプールに戻りません。</font><font style="vertical-align: inherit;">Goの最初の安定版リリース以降</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、通常のSQLクエリ間のデータ交換は</font></font><code>databaseb/sql</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更され</font><font style="vertical-align: inherit;">て</font><font style="vertical-align: inherit;">いません。</font></font><br>
<br>
<pre><code class="go hljs">rows, err := db.Query(<span class="hljs-string">"SELECT a, b FROM some_table"</span>)
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">return</span> err<font></font>
}<font></font>
<span class="hljs-keyword">defer</span> rows.Close()<font></font>
<font></font>
<span class="hljs-keyword">for</span> rows.Next() {
    <span class="hljs-keyword">var</span> a, b <span class="hljs-keyword">string</span>
    <span class="hljs-keyword">if</span> err := rows.Scan(&amp;a, &amp;b); err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> err<font></font>
    }<font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、このアプローチは単純です。それ</font></font><code>(*DB).Query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はを返し</font></font><code>sql.(*Rows)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、要求を行った接続をSQLプールから盗みます。後続の呼び出し</font></font><code>(*Rows).Next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は接続から最後の行を読み取り、最終</font></font><code>(*Rows).Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的にを呼び出すまで</font><font style="vertical-align: inherit;">呼び出しによってその内容を抽出でき</font><font style="vertical-align: inherit;">ます。</font></font><code>(*Rows).Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その後、後続のすべての呼び出し</font></font><code>Next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が返され</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、すべての呼び出し</font></font><code>Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がエラーを返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、メインドライバーを使用した実装はより複雑に見え</font></font><code>sql.(*Rows)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font><code>Rows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ドライバーは</font><font style="vertical-align: inherit;">インターフェースに</font><font style="vertical-align: inherit;">ラップされた独自のドライバーを返し</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。ただし、最適化のため、</font></font><code>Rows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドライバーに</font></font><code>Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">メソッドではなく</font><font style="vertical-align: inherit;">イテレーターがあります</font></font><code>Next(dest []Value) error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。イテレータは</font></font><code>Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLクエリの各列の</font><font style="vertical-align: inherit;">オブジェクト</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">返す</font><font style="vertical-align: inherit;">ため、呼び出し</font></font><code>sql.(*Rows).Next</code><font style="vertical-align: inherit;"></font><code>driver.Rows.Next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドライバーが返す値へのポインターを保持したまま、</font><font style="vertical-align: inherit;">このすべての下で呼び出すだけ</font><font style="vertical-align: inherit;">です。次に、ユーザーがを呼び出す</font></font><code>sql.(*Rows).Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、標準ライブラリは</font></font><code>Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドライバー</font><font style="vertical-align: inherit;">オブジェクト</font><font style="vertical-align: inherit;">をへの引数としてユーザー定義のターゲットタイプに</font><font style="vertical-align: inherit;">変換</font><font style="vertical-align: inherit;">し</font></font><code>Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。これは、ドライバーが引数を変換する必要がないことを意味し（Go標準ライブラリがこれを処理します）、新しい値を指定する代わりに、</font></font><code>Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドライバーは盗んだメモリーを文字列イテレーターから返すことができ、メソッドはとにかく</font></font><code>Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリーを変換します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご想像のとおり、セキュリティの問題は</font><i><font style="vertical-align: inherit;">メモリの盗難</font></i><font style="vertical-align: inherit;">が原因</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。契約では、ドライバーは一時メモリを返すことが強く推奨されています。この重要な最適化は実際にはMySQLに適合しており、接続バッファーへのポインターを返して結果を直接読み取ることができます。情報は、SQLクエリー文字列に送達されると、それはによって転送することができる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スキャン</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザにライン表示を解析し、予想されるタイプ（</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>bool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">など）。この安全なメソッドは、データレースを呼び出しません。これは、ユーザーによる新しい呼び出しがなければ、</font></font><code>sql.(*Rows).Next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファーを書き換えないためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...つまり、少なくともGo 1.8 APIまではそうでした</font></font><code>QueryContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。新しいインターフェースを使用する</font></font><code>db.QueryContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、オブジェクトで</font><font style="vertical-align: inherit;">呼び出すことができ</font><font style="vertical-align: inherit;">ます</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、これはリクエストをより早く中断します-これについてはすでに詳しく調べました。ただし、結果をスキャンするときにタイムアウトによってリクエストを中断または無効にすると、深刻なセキュリティ上の脆弱性が生じます。 SQLクエリが呼び出しの途中で中断されるとすぐ</font></font><code>sql.(*Rows).Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、ドライバーはMySQL接続のメインバッファーを上書きし、</font></font><code>Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破損したデータ</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような動作は予期しないように見えるかもしれませんが、ゼロ化する</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことは</font><i><font style="vertical-align: inherit;">、クライアント上の</font></i><font style="vertical-align: inherit;"> SQLクエリ</font><i><font style="vertical-align: inherit;">を</font></i><font style="vertical-align: inherit;">ゼロ</font><font style="vertical-align: inherit;">化する</font><font style="vertical-align: inherit;">ことを意味</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">します</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MySQLサーバー上ではなく、状況がより明確になります。サーバーはアクティブなMySQL接続を介してクエリ結果を発行し続けるため、クエリをゼロにする場所で接続を復元したい場合は、最初にサーバーから送信されたすべての結果パケットを「空にする」必要があります。リクエストに残っている行を空にして破棄するには、これらのパケットを接続バッファーに読み込む必要があります。リクエストと同時にリクエストをゼロにリセットできる</font></font><code>Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため</font></font><code>Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ユーザーが検索する</font><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">対応する</font><font style="vertical-align: inherit;">メモリ</font><font style="vertical-align: inherit;">を書き換え</font><font style="vertical-align: inherit;">ます。その結果、データが破損する可能性が非常に高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このデータレースはすでに威圧的に聞こえますが、主な問題は次のとおりです。実際には、アプリケーションでデータレースが発生したかどうかは明らかです。前の使用例で</font></font><code>rows.Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、エラーチェックにもかかわらず</font><font style="vertical-align: inherit;">、期限切れのためにSQLクエリが無効にされた</font><font style="vertical-align: inherit;">かどうかを確認する</font><font style="vertical-align: inherit;">信頼できる方法はありません</font><font style="vertical-align: inherit;">。</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出し内で</font><font style="vertical-align: inherit;">null </font><font style="vertical-align: inherit;">が発生した</font><font style="vertical-align: inherit;">場合</font></font><code>rows.Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（たとえば、データレースを開始するのに便利な場所）、行の値がスキャンされ、破損した可能性のあるデータが含まれます。エラーは返されません。</font></font><code>rows.Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これ</font><i><font style="vertical-align: inherit;">は、関数の入力時に</font></i><font style="vertical-align: inherit;">行の終了を一度だけチェックする</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ためです。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。したがって、データレースでは、エラーを返さずにデータが破損し、次の呼び出しを行うまでリクエストがゼロにリセットされたかどうかを判断できません</font></font><code>rows.Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。しかし、この呼び出しは、</font><font style="vertical-align: inherit;">エラー</font></font><code>rows.Next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を返さ</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ずに</font><font style="vertical-align: inherit;">を返す</font><font style="vertical-align: inherit;">ため、決して発生しません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">SQLクエリの行のスキャンが正しく完了したことを確認する唯一の方法は</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、呼び出しの戻り値を確認することですが</font></font><code>rows.Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ステートメントで行が閉じられているため、この呼び出しは行いません</font></font><code>defer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。さらに、</font><font style="vertical-align: inherit;">Githubで</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><code>rows.Close()</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">すばやく検索すると、コード</font></a><font style="vertical-align: inherit;">の戻り値を明示的に確認する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はほとんどい</font><i><font style="vertical-align: inherit;">ない</font></i><font style="vertical-align: inherit;">ことがわかり</font></font><code>rows.Close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。 API以前は</font></font><code>QueryContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このアプローチは安全でしたが、Go 1.8以降では</font></font><code>rows.Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十分ではない。</font></font><code>rows.Close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go MySQLドライバーでこのデータ競合を排除した後でも</font><font style="vertical-align: inherit;">、戻り値をチェックし</font><font style="vertical-align: inherit;">ないと、SQLクエリのすべての行をスキャンしたかどうかがわかりません。だからあなたの糸くずを更新します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このデータ競合を解消するいくつかの方法を知っています。最も明白な-そして最も遅い-は、から戻るときに常にメモリのクローンを提供します</font></font><code>driver.Rows.Next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ユーザーが呼び出すまでメモリ割り当てが遅延するため</font></font><code>sql.(*Rows).Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、driver.Rowsを呼び出すときにドライバーがメモリを割り当てる必要はありません。次に、これはまさにドライバーコントラクトのアイデアです。 Nextで割り当てを開始すると、各行にメモリを2回割り当てるため、パフォーマンスが大幅に低下します。 Go MySQLの同行チームも私も、この状況に満足していませんでした。</font><font style="vertical-align: inherit;">sqlを</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出すときにメイン接続バッファーを切り捨てる</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">など、他の同様のメソッド</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><code>(*Rows).Close</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、同じ理由で拒否されました-呼び出しごとにメモリを割り当てる可能性があります</font></font><code>Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。その結果、重大なバグは修正なしで6か月間たわみました。チームに適した回答が見つからなかったためです。個人的には、非常に危険なバグが長時間垂れ下がる状況を非常に恐れているため、ホストにリグレッションを引き起こさずに問題を修正するために、まったく新しいものを考え出す必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、メインの接続バッファーを使用せずにMySQL接続を「空」にしようとしました。これは、バッファーに書き込みを行わないとデータ競合が発生しないためです。しかし、MySQLは空にするために必要な多くのパッケージを送信でき、これらのパッケージのさまざまなサイズはヘッダーによって決定されるため、私の試みはすぐに悪夢のようなスパゲッティコードに変わりました。バッファなしで部分的にヘッダーを解析することは非常に不愉快です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はしばらくの間この問題について考えました、そしてある瞬間、それは私に気づきました-ダブルバッファリング。このソリューションは非常にシンプルで、さらにフリーズするほど高速であることがわかりました。昔のコンピュータグラフィックススタックの時代に戻ると、そのようなスタックは個々のピクセルを直接フレームバッファーに記録し、同時にモニターはそのフレームレートでピクセルを読み取りました。スタックが画面を読み取っているのと同時にフレームバッファーにデータを書き込んだときに、ちらつきが観察されました。これは古いグラフィックの不具合です。基本的に、フリッカーは肉眼で見えるデータレースとして定義できます。それ自体、かなり興味深い概念です。ちらつきをなくす最も簡単な方法は、2つのフレームバッファーです。画面（フロントバッファー）は1つのバッファーからデータを読み取ります。GPU（バックバッファー）が別のデータを書き込みます。 GPUがフレームのレンダリングを完了すると、フロントバッファーとリアバッファーが自動的にスワップされるため、モニターはフレームが不完全であると見なしません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/r_/uv/vx/r_uvvxzyia2pryibs5ormhu4jxu.gif"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図5：Nintendo 64グラフィックススタックのダブルバッファリングマリオで十分であれば、MySQLドライバーで十分です。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
私たちの問題とこの状況は非常によく似ているため、2つのバッファーを使用する手法を使用できます。私たちの場合、</font><font style="vertical-align: inherit;">リクエストの早期ゼロ化により</font><font style="vertical-align: inherit;">構造</font><font style="vertical-align: inherit;">が閉じた</font><font style="vertical-align: inherit;">ときに、接続バッファーをバックバッファーと</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交換し</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><code>driver.Rows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したがって、MySQL接続をバッ​​クバッファーに排出している間、ユーザーは引き続き</font></font><code>sql.Rows.Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロントに</font><font style="vertical-align: inherit;">呼び出すことができ</font><font style="vertical-align: inherit;">ます。次回、SQLクエリが同じ接続に到着したとき、バックバッファーからの読み取りを続けます。</font></font><code>Rows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再び閉じたり、バッファーを元に戻したりすることはありません。この非常に些細な実装は、SQL接続ごとに1回メモリを割り当て、生産性の損失を緩和します。極端なケースでは、最初にデータを空にする必要があるまでバックバッファーへの割り当てを遅らせることで状況を改善することができました。そのため、MySQL接続の通常の状況では、リクエストが早くリセットされず、追加のメモリ割り当てはありません。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">いくつかのパフォーマンステストを慎重に組み立てた</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
後</font><font style="vertical-align: inherit;">、いずれの場合もダブルバッファリングの回帰は検出されませんでし</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">た。</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">残念ながら、このバグの機能では、破損したメモリの読み取り頻度を確認することはできませんが、再現は簡単であるため、そのような読み取りが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多数</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あった可能性が</font><i><font style="vertical-align: inherit;">あり</font></i><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制作のヒント</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しで返されるエラーの明示的なチェックを常に実行し</font></font><code>(*Rows).Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。スキャン中にSQLクエリが妨害されたかどうかをチェックする方法は他にありません。</font><font style="vertical-align: inherit;">ただし、アプリケーションから呼び出しを削除しない</font><font style="vertical-align: inherit;">でください。</font></font><code>defer rows.Close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何かが発生した</font></font><code>panic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、またはスキャン中に早期に復帰した</font><font style="vertical-align: inherit;">場合にのみ、回線を閉じることができ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">何度か電話をしても安全</font></font><code>(*Rows).Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font></li>
<li>   <code>(*Rows).Scan</code>    <code>sql.RawBytes</code>.   Go MySQL     ,      <code>RawBytes</code>       SQL .   ,        .     <code>[]byte</code>  <code>sql.RawBytes</code>  ,  raw    ,        data race  Context– .</li>
</ul><br>
<h2></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特にGithubスケールで、本番環境に新しいプログラミング言語でコードをデプロイすることは常に課題です。</font><font style="vertical-align: inherit;">MySQLの使用パターンのパフォーマンスと複雑さは、長年にわたってRuby用にMySQLクライアントを微調整してきたことを反映しており、Go MySQLドライバーでも同じことができるようになりました。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リリース1.5.0</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Go MySQLドライバーには、Goの最初のデプロイ中に渡された修正がすべて含まれており、現在パブリックドメインにあります。</font><font style="vertical-align: inherit;">本番環境でのGoの使用の拡大と並行して、ドライバーの修正を導入し、その機能を拡張していきます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go MySQLサポートチーム、@メタンと@julienschmidtのパッチに対する支援に感謝します！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja503574/index.html">フロントエンドのカザフスタン共和国の電子政府の文書のQRコードの内容の分析</a></li>
<li><a href="../ja503576/index.html">「合格者」：ロシア語を話すサイトでスタートアップとテクノロジーについて話し合うのを忘れたトピック</a></li>
<li><a href="../ja503578/index.html">優れたプログラマーがコピーし、優れたプログラマーが盗む</a></li>
<li><a href="../ja503580/index.html">ビッグデータとは？</a></li>
<li><a href="../ja503582/index.html">Azure Analytics：瞬く間に明快さ</a></li>
<li><a href="../ja503588/index.html">ビル・ゲイツ：COVID-19ワクチンについて知っておくべきこと</a></li>
<li><a href="../ja503594/index.html">リモートオブザーバー</a></li>
<li><a href="../ja503596/index.html">.NETを使用したWeb開発：Blazor WebAssembly 3.2.0の紹介</a></li>
<li><a href="../ja503598/index.html">FOSSニュースNo. 17-2020年5月18〜24日の無料およびオープンソースニュースのレビュー</a></li>
<li><a href="../ja503600/index.html">STM32MP1：U-Boot、Buildroot、Arch LinuxおよびDebianの一部</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>