<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏻 🏹 🚤 Sebuah siklus tanpa akhir yang bukan: kisah serangga Cawan Suci 🏝️ 🕞 👩‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekali waktu ada permainan untuk GBA disebut Hello Kitty Collection: Miracle Fashion Maker. Itu adalah game imut berdasarkan franchise Sanrio Hello Ki...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sebuah siklus tanpa akhir yang bukan: kisah serangga Cawan Suci</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488240/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekali waktu ada permainan untuk GBA disebut Hello Kitty Collection: Miracle Fashion Maker. Itu adalah game imut berdasarkan franchise Sanrio Hello Kitty yang terkenal dan dikembangkan oleh Imagineer. Tapi dengan kedok nama yang tampaknya tidak bersalah adalah masalah berbahaya. Untuk beberapa alasan, gim sederhana ini tidak berjalan pada emulator GBA apa pun. Tetapi ini saja tidak akan cukup untuk menyebut masalah itu sebagai bug dari Cawan Suci. Seperti semua bug dari Holy Grail, bug ini sendiri sangat membingungkan. Penjelasannya sederhana: pada suatu titik dalam urutan memulai permainan, itu jatuh ke dalam siklus dari mana ia tidak pernah </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keluar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , menunggu nilai tertentu untuk dibaca dari memori yang </font><em><font style="vertical-align: inherit;">tidak ada</font></em><font style="vertical-align: inherit;"> . Meskipun ada bug serupa di banyak game, misalnya, di intro populer</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Legend of Zelda: The Minish Cap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mereka mengandalkan perilaku khusus yang disebabkan oleh membaca alamat memori yang tidak valid. </font><font style="vertical-align: inherit;">Namun siklus ini sepertinya melanggar perilaku semacam itu. </font><font style="vertical-align: inherit;">Meskipun demikian, game ini bekerja dengan peralatan nyata. </font><font style="vertical-align: inherit;">Selain itu, bug yang sama persis terjadi ketika memuat save ke Sonic Pinball Party setelah reboot dingin. </font><font style="vertical-align: inherit;">Mungkinkah harapan alamat memori yang tidak valid ini menjadi salah? </font><font style="vertical-align: inherit;">Tetapi jika demikian, bagaimana?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/c85/547/1b0c8554787a8e54e1ac5c21c78d639c.png"></div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi ini ilegal, kan?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tunggu sebentar - jika Anda mencoba mengakses memori yang tidak valid, maka gim tersebut hanya perlu macet, bukan? Operasi yang tidak terselesaikan, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segfault,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau beberapa kesalahan lain </font><font style="vertical-align: inherit;">harus terjadi </font><font style="vertical-align: inherit;">. Baik? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yah itu lebih seperti Ya. Tapi tidak juga. Setidaknya tidak pada GBA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam arsitektur prosesor ARM yang digunakan dalam GBA, keadaan salah ini disebut pembatalan data dan terjadi hanya ketika Anda mencoba mengakses memori yang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manajer memori</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> belum menetapkan izin baca </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ketika data dibatalkan, prosesor menyelesaikan apa yang dilakukan dan pergi ke </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vektor pengecualian</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditugaskan untuk pengecualian batalkan data. Kemudian sistem operasi dapat memilih salah satu solusi: matikan proses saat ini, tetapkan memori </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kesalahan halaman</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , biarkan proses mengatasi situasi, karena beberapa emulator JIT melakukannya dengan "fastmem", atau melakukan beberapa tindakan lain. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana GBA menangani pembatalan data? Entri vektor pengecualian untuk pembatalan data terletak di ROM boot dari konsol GBA (atau, demikian juga disebut, di BIOS). Jika GBA menemukan data batal, maka ia mencoba untuk pergi ke penangan DACS </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jika ada, jika tidak terjadi pemblokiran. </font><font style="vertical-align: inherit;">Tidak ada game komersial yang memiliki penangan DACS. </font><font style="vertical-align: inherit;">Jadi mengapa game ini tidak kedinginan? </font><font style="vertical-align: inherit;">Semuanya sangat sederhana - GBA tidak pernah menghasilkan pembatalan data. </font><font style="vertical-align: inherit;">Itu tidak memiliki manajer memori (MMU) (atau bahkan unit perlindungan memori, seperti di DS), jadi itu hanya terus bekerja dan membaca memori yang tidak valid.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bus memori memasuki lokasi.</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f75/dd9/55f/f75dd955f33d3a974b417f401fe054a6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apakah memori yang tidak valid secara umum? Bagaimana penampilannya? Ini adalah halangan utama. Ini adalah situasi yang sulit: apa yang dibaca kode sangat bergantung pada apa yang baru-baru ini dilakukan CPU, atau, lebih tepatnya, apa yang dilakukan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bus memori</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baru-baru ini </font><font style="vertical-align: inherit;">. Singkatnya, ketika mengakses memori yang tidak valid, CPU membaca apa yang terakhir di bus memori. Untuk memahami apa yang mengikuti dari ini, Anda perlu belajar sedikit tentang bus memori dan cara kerjanya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bus memori adalah bagian dari sirkuit elektronik yang menghubungkan CPU ke semua komponen memori platform. Pada GBA, beberapa perangkat terhubung ke bus memori: RAM yang berfungsi, memori video, dan bus kartrid. Ketika CPU mencoba mengakses memori, ia memberi tahu bus memori ke alamat mana ia perlu akses, dan kemudian komponen yang sesuai dengan alamat itu diaktifkan. Kemudian komponen menempatkan nilai di alamat ini di bus, yang mungkin memakan waktu beberapa </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> siklus </font><font style="vertical-align: inherit;">, dan kemudian CPU akhirnya bisa membaca nilai dari bus. Dalam hal GBA, jika tidak ada peralatan yang dikaitkan dengan alamat, maka tidak ada nilai yang ditulis ke bus, dan CPU membaca nilai apa pun yang ditempatkan </font><em><font style="vertical-align: inherit;">terakhir</font></em><font style="vertical-align: inherit;"> di bus</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Situasi dapat bervariasi dalam berbagai cara, misalnya, jika pembacaannya 16-bit, dan CPU mencoba melakukan pembacaan 32-bit, tetapi secara umum itu akan selalu menjadi nilai dari bus. </font><font style="vertical-align: inherit;">Pengembang menyebut fitur ini "bus terbuka". </font><font style="vertical-align: inherit;">Sebelumnya, saya menulis bagaimana ini memengaruhi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">game lain</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya, sepertinya semuanya tidak terlihat buruk ... Benar?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi Anda bisa men-cache akses memori terakhir? Dan kemudian membawanya kembali? Dalam kasus umum, pendekatan ini akan berhasil, tetapi ada kesulitan tertentu. Pertama, Anda harus memastikan bahwa semua operasi akses memori dalam urutan yang benar. Ini lebih rumit daripada kedengarannya, karena CPU mengakses memori dengan setiap instruksi untuk mendapatkan instruksi berikutnya dalam pipa. Dan pada kenyataannya, dalam kasus umum *, memori yang tertahan di dalam bus adalah instruksi terakhir yang diterima. Ini menyederhanakan proses, karena Anda hanya perlu mendapatkan nilai terakhir yang sudah dipilih sebelumnya ini. Tetapi karena nilai yang dipilih sebelumnya tergantung hanya pada tempat kita mengeksekusi dari memori, itu harus selalu sama. Bahkan jika alamat yang diterima berubah saat tidak valid,Anda akan selalu mendapatkan memori yang sama.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uh ... Berhenti. </font><font style="vertical-align: inherit;">Tapi siklus ini ada, dan tidak bisa keluar jika nilai ini dipilih sebelumnya. </font><font style="vertical-align: inherit;">Jadi apa yang terjadi? </font><font style="vertical-align: inherit;">Jika dia terus-menerus menerima instruksi berikut, lalu apa yang terjadi antara operasi-operasi ini? </font><font style="vertical-align: inherit;">Saya mencoba menjalankan loop tanpa akhir seperti itu pada test ROM untuk memeriksa apakah, misalnya, nilainya bisa memburuk. </font><font style="vertical-align: inherit;">Ini pasti dapat terjadi jika nilai belum diperbarui baru-baru ini, tetapi nilai diperbarui dalam setiap instruksi, sehingga tidak punya waktu untuk rusak. </font><font style="vertical-align: inherit;">Tes saya tidak pernah meninggalkan loop. </font><font style="vertical-align: inherit;">Saya melakukan sesuatu yang berbeda dari pada game-game ini, meskipun saya membuat ulang siklusnya dengan tepat. </font><font style="vertical-align: inherit;">Apa kesalahan yang telah aku perbuat?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pokémon Emerald dan ACE, hanya terjadi pada besi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maju cepat dalam waktu, pada Januari 2020. Laporan bug di Sonic Pinball Party pada waktu itu berusia sekitar tiga setengah tahun. Di emulator lain, ia dikenal selama bertahun-tahun. Saya sudah kehabisan teori kerja. Pada akhir bulan ini, seorang pengguna dengan julukan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merrp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bergabung dengan komunitas Discord dari emulator mGBA dan mengatakan bahwa Pokémon Emerald memiliki kesalahan eksekusi kode arbitrer (ACE) baru yang hanya berfungsi pada perangkat keras. Selain itu, kesalahan ini kemungkinan besar akan digunakan oleh speedrunners, yang mungkin ingin berlatih emulator. Jelas, bug ini telah menjadi target yang menarik untuk memperbaiki kesalahan, meskipun akan lebih baik jika saya mengetahuinya sebelum versi 0.8.0. Saya mulai meneliti kesalahan dan mengkonfirmasi pengamatan merrp bahwa itu hanya bekerja pada perangkat keras. Di semua emulator yang saya coba, permainan digantung dengan layar hitam. Tetapi merrp memberi tahu saya bahwa itu tergantung pada pembacaan dari memori yang tidak valid dalam satu lingkaran, dan saya menyadari bahwa kemungkinan besar saya tidak dapat memperbaiki kesalahan dalam waktu dekat. Lagi </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lagi ini adalah </font><font style="vertical-align: inherit;">bug yang </font><strong><font style="vertical-align: inherit;">sama</font></strong><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kali ini, belajar tentang fungsi perulangan memberi saya keunggulan. Berkat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proyek</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dekompilasi </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">pokeemerald,</font></a><font style="vertical-align: inherit;"> saya dapat dengan mudah melakukan perubahan yang ditargetkan pada fungsi untuk mencoba mencari tahu bagaimana dia berhasil keluar dari loop. Versi sederhana dari loop ini terlihat seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint16_t</span> type = <span class="hljs-comment">/* ... */</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int32_t</span> i = <span class="hljs-number">0</span>; table[type][i] != <span class="hljs-number">0xFFFF</span>; ++i) {
	<span class="hljs-keyword">uint16_t</span> value = table[type][i] &amp; <span class="hljs-number">0xFE00</span>;
	<span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">0x7E00</span>) {
		<span class="hljs-keyword">break</span>;<font></font>
	}<font></font>
	<span class="hljs-comment">/* ... */</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Loop melakukan tugas yang cukup sederhana. Ada tabel nilai dua dimensi. Pada setiap baris tabel kolom ini, </font></font><code>type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loop pertama kali mencoba menentukan apakah nilainya adalah nilai sentinel tertentu. Jika demikian, loop berakhir. Kalau tidak, itu berlaku masker untuk nilai dan memeriksa apakah itu lebih besar dari nilai yang diperiksa. Kalau tidak, itu akan turun siklus. Dalam kasus kesalahan tertentu, nilainya </font></font><code>type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melampaui batas-batas tabel, yang mengarah ke tampilan pointer yang tidak valid. Ini berarti ketika Anda mencoba mengakses</font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk elemen kolom yang tidak ada ini, kami akan selalu mengakses memori yang tidak valid. Meskipun offset meja meningkat dengan setiap iterasi loop sebelum kembali ke memori aktual, mungkin membutuhkan ratusan juta pengulangan. Karena itu, jelas bahwa dia tidak. Jadi bagaimana sebuah program keluar dari loop?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menyelidiki ini, saya mengubah siklus dan melihat apa yang akan terjadi jika saya baru saja keluar dari siklus. </font><font style="vertical-align: inherit;">Semuanya ternyata sangat sederhana: saat ini ACE bekerja pada perangkat keras dan emulator, dan tidak ada yang menggantung. </font><font style="vertical-align: inherit;">Jadi sebagai gantinya, saya mencoba untuk mengatur warna layar ke nilai yang dibaca program ketika keluar dari loop dan membeku sehingga warnanya tidak berubah. </font><font style="vertical-align: inherit;">Saya mengkompilasi ulang kode dan menjalankannya pada GBA nyata. </font><font style="vertical-align: inherit;">Setelah beberapa detik membeku di layar hitam, itu menjadi rona biru yang cantik.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/eq/e_/md/eqe_md60cly8igmztq2_kd2yigc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SANGAT BIRU</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Tetapi emulator masih menggantung di layar hitam. </font><font style="vertical-align: inherit;">Nilai apa yang akan dia baca jika dia membaca nilai yang diterima sebelumnya? </font><font style="vertical-align: inherit;">Sebaliknya, itu menjadi pirus hitam.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/sh/hf/6j/shhf6jyqkem0ulhbpzjuhc9hmi4.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fu.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Artinya, program, sebelum berhasil keluar dari siklus, pasti melewati setidaknya sekali. </font><font style="vertical-align: inherit;">Ternyata waktu yang dibutuhkan untuk keluar dari siklus besi bervariasi. </font><font style="vertical-align: inherit;">Ini biasanya memakan waktu 2 hingga 30 detik. </font><font style="vertical-align: inherit;">Apa yang sedang terjadi?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teori kerja baru</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lalu saya perhatikan perbedaan antara test ROM saya dan Pokémon Emerald saat digantung. Pokemon memainkan musik. Sonic Pinball Party juga memainkan musik. Hello Kitty tidak memainkan musik, tetapi itu memberi saya ide. Apa yang terjadi jika interupsi terjadi antara pengambilan awal dan pemuatan data? Apakah program mulai mengambil vektor interupsi sebelum mengakses memori yang tidak valid? Saya dengan cepat membuat tata letak untuk situasi ini di mGBA, menyalakan interupsi di ROM tes, dan tentu saja itu keluar dari loop. Lalu saya mencoba test ROM yang sama pada perangkat keras dan ... tidak keluar dari loop. Maka teori pun muncul. Pada akhirnya, saya menyadari sesuatu. Saya yakin Anda melihat tanda bintang di atas, jadi ya, ada satu peristiwa antara pengambilan awal dan mengakses memori,tetapi hanya jika, antara prefetch dan akses ke memori yang tidak valid, bus memori mengirimkan permintaan tidak ke CPU, tetapi ke sesuatu yang lain.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mengatakan bahwa bus memori dikendalikan oleh CPU. Untuk sebagian besar, ini benar, tetapi ada peralatan penting lainnya yang juga memiliki akses ke bus memori melewati prosesor. Proses ini disebut </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akses memori langsung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Saya berbicara tentang DMA di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel sebelumnya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , jadi sekarang saya tidak akan membahas prinsip kerjanya. Jika Anda membaca kembali artikel tersebut, Anda mungkin memperhatikan bahwa saya mengatakan bahwa CPU utama berhenti sementara DMA sedang berjalan. Ini berarti bahwa ketika DMA berjalan, nilai pada bus sekarang akan menjadi akses terakhir ke memori DMA. Ini terutama penting jika DMA melampaui memori aktual ke wilayah yang tidak valid; Namun, itu menggandakan nilai bagus terakhir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sudah lama diketahui bahwa jika Anda memuat memori yang tidak valid ke DMA, Anda akan mendapatkan nilai DMA terakhir, tapi saya menerapkannya dalam mGBA untuk waktu yang lama dan sudah lupa tentang itu. Ketika saya melihat ini di kode akses untuk memori tidak valid ketika mempelajari bug, sesuatu diklik di kepala saya. Bagaimana jika nilai DMA bertahan di bus untuk satu instruksi? Jika instruksi pertama setelah DMA selesai memuat memori yang tidak valid sebelum mendapatkan nilai berikutnya, maka secara teori ini harus mengarah untuk memuat ulang nilai DMA. Selain itu, memutar musik di GBA biasanya menggunakan DMA untuk mengirimkan output audio. Untuk implementasi yang benar dari ini, diperlukan emulator taktik-akurat, yang dapat memblokir CPU di tengah-tengah pelaksanaan instruksi, antara awal instruksi dan akses memori, dan emulasi konsol GBA di emulator mGBA tidak akurat taktik.Dan ini sesuatu bagiku.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kenang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Untungnya, saya berhasil mengatasi masalah ini. </font><font style="vertical-align: inherit;">Solusinya tidak sempurna, tetapi sekarang saya dapat membandingkan alamat CPU yang diharapkan untuk instruksi setelah DMA dengan alamat CPU saat ini pada beban yang tidak valid dan menggunakan satu alamat alih-alih nilai yang dipilih sebelumnya untuk nilai DMA ini.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keputusan yang ditunggu-tunggu</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menyalakan operasi DMA untuk H-blank dalam ROM tes dan menyinkronkannya dengan V-blank sehingga timingnya stabil, menjalankannya pada perangkat keras, dan ... kali ini berhasil! ROM tes terus-menerus keluar dari loop setelah jumlah iterasi yang sama ketika nilai DMA dibaca dari bus. Saya benar! Untuk implementasi yang benar dalam mGBA ini, beberapa upaya diperlukan, tetapi sekarang program keluar dari siklus dengan hasil yang sama seperti pada perangkat keras. Saya akhirnya mendapat warna biru pada mGBA. Hello Kitty telah di-boot. Menyimpan di Sonic Pinball Party telah menghasilkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya melakukannya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini mungkin waktu terlama yang saya habiskan untuk satu bug. Selama tiga tahun, saya menginvestasikan begitu banyak waktu dalam debugging sehingga saya kehilangan hitungan, dan saya yakin bahwa pengembang lain juga menghadapi situasi serupa di emulator mereka. Tanpa wawasan ini, mungkin diperlukan saya satu tahun lagi, atau bahkan lebih, tetapi layar hitam, yang tidak ada yang terjadi selain bermain musik, menjadi ubin domino yang menyebabkan runtuhnya seluruh masalah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang solusinya ditemukan, itu dapat diimplementasikan dalam emulator GBA lainnya, mengakhiri bug ini. Bug ini akan diperbaiki di mGBA 0.9.0, yang, saya harap, akan dirilis tahun ini, dan telah diperbaiki dalam uji coba build. Anda akhirnya dapat memainkan Hello Kitty Collection: Miracle Fashion Maker. Kecuali, tentu saja, Anda berharap, bukan bagi saya untuk menghakimi Anda.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34c/74c/fce/34c74cfce5ebbb092c5a55c9293ec0cb.png" alt="gambar"></div><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda mencoba mengeksekusi memori yang tidak memiliki izin eksekusi, ini disebut prefetch abort.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DACS (kependekan dari Debugging dan Sistem Komunikasi) adalah bagian dari kit pengembangan GBA.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siklus-siklus idle saat membaca dari bus ini kadang-kadang disebut status tunggu.</font></font></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id488224/index.html">Mantan pemimpin redaksi TJ tentang surat-surat dari FSB: akan ada kisah "Durov 2.0", tetapi Habr akan menjadi headliner</a></li>
<li><a href="../id488228/index.html">10 tempat dan ide TOP untuk kencan geek pada 14 Februari</a></li>
<li><a href="../id488230/index.html">Pengantar SSD. Bagian 3. Form factor</a></li>
<li><a href="../id488232/index.html">sekitar teknologi: QATOK # 2</a></li>
<li><a href="../id488234/index.html">Menggunakan QubesOS untuk Windows 7</a></li>
<li><a href="../id488242/index.html">VueJS + TS Integrasi Proyek dengan SonarQube</a></li>
<li><a href="../id488244/index.html">Cara mengurangi overhead saat menangani pengecualian di C ++</a></li>
<li><a href="../id488246/index.html">VoiceOver di iOS: setiap kontrol berperilaku berbeda</a></li>
<li><a href="../id488250/index.html">Untuk pertanyaan tentang Linux (L)</a></li>
<li><a href="../id488252/index.html">Cara mengurangi biaya pengembangan produk baru menggunakan SLS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>