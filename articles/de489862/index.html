<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💈 🔫 🤱 Planen in Go: Teil II - Der Go-Planer 💆🏿 ✋🏿 🐻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Dies ist der zweite Beitrag in einer dreiteiligen Reihe, die einen Eindruck von der Mechanik und Semantik der Arbeit des Schedulers in Go ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Planen in Go: Teil II - Der Go-Planer</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489862/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font><font style="vertical-align: inherit;">Dies ist der zweite Beitrag in einer dreiteiligen Reihe, die einen Eindruck von der Mechanik und Semantik der Arbeit des Schedulers in Go vermittelt. </font><font style="vertical-align: inherit;">In diesem Beitrag geht es um den Go-Planer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ersten Teil</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dieser Serie habe ich Aspekte des Betriebssystem-Schedulers erläutert, die meiner Meinung nach wichtig sind, um die Semantik des Go-Schedulers zu verstehen und zu bewerten. </font><font style="vertical-align: inherit;">In diesem Beitrag werde ich auf semantischer Ebene erklären, wie der Go-Scheduler funktioniert. </font><font style="vertical-align: inherit;">Der Go Scheduler ist ein komplexes System und kleine mechanische Details sind nicht wichtig. </font><font style="vertical-align: inherit;">Es ist wichtig, ein gutes Modell dafür zu haben, wie alles funktioniert und sich verhält. </font><font style="vertical-align: inherit;">Auf diese Weise können Sie die besten technischen Entscheidungen treffen.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ihr Programm startet</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihr Go-Programm gestartet wird, wird ihm für jeden auf dem Hostcomputer definierten virtuellen Kern ein logischer Prozessor (P) zugewiesen. Wenn Sie einen Prozessor mit mehreren Hardwarethreads pro physischem Kern haben (Hyper-Threading), wird jeder Hardwarethread Ihrem Programm als virtueller Kern angezeigt. Schauen Sie sich zum besseren Verständnis den Systembericht für mein MacBook Pro an. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b6e/2de/4a8/b6e2de4a805c6a87c95aa0afcef436ac.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können sehen, dass ich einen Prozessor mit 4 physischen Kernen habe. In diesem Bericht wird die Anzahl der Hardwarethreads pro physischem Kern nicht angegeben. Der Intel Core i7-Prozessor verfügt über Hyper-Threading-Technologie, was bedeutet, dass der physische Core über 2 Hardware-Threads verfügt. Dies teilt Go mit, dass 8 virtuelle Kerne verfügbar sind, um Betriebssystem-Threads parallel auszuführen. Betrachten Sie das folgende Programm, um dies zu überprüfen:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"runtime"</span><font></font>
)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
<font></font>
    <span class="hljs-comment">// NumCPU returns the number of logical</span>
    <span class="hljs-comment">// CPUs usable by the current process.</span><font></font>
    fmt.Println(runtime.NumCPU())<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ich dieses Programm auf meinem Computer ausführe, ist das Ergebnis des Aufrufs der Funktion NumCPU () 8. Jedes Go-Programm, das ich auf meinem Computer ausführe, erhält 8 (P). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein Betriebssystemstrom ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) zugeordnet. Dieser Thread wird weiterhin vom Betriebssystem verwaltet, und das Betriebssystem ist weiterhin dafür verantwortlich, den Thread zur Ausführung im Kernel zu platzieren. Das heißt, wenn ich Go auf meinem Computer ausführe, stehen mir 8 Threads zur Verfügung, die jeweils einzeln mit P verknüpft sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes Go-Programm erhält außerdem eine erste Goroutine ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Goroutine ist im Wesentlichen Coroutine, aber es ist Go, also ersetzen wir den Buchstaben C durch G und erhalten das Wort Goroutine. Sie können sich Goroutines als Threads auf Anwendungsebene vorstellen, die OS-Threads sehr ähnlich sind. So wie Betriebssystem-Threads vom Kernel ein- und ausgeschaltet werden, werden Kontextprogramme vom Kontext ein- und ausgeschaltet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das letzte Rätsel sind die Ausführungswarteschlangen. </font><font style="vertical-align: inherit;">Der Go-Scheduler enthält zwei verschiedene Ausführungswarteschlangen: die globale Ausführungswarteschlange (GRQ) und die lokale Ausführungswarteschlange (LRQ). </font><font style="vertical-align: inherit;">Jedem P wird ein LRQ zugewiesen, der die Goroutins steuert, die im Kontext von P ausgeführt werden sollen. Diese Goroutinen werden in dem diesem P zugewiesenen Kontext M ein- und ausgeschaltet. GRQ ist für Goroutinen vorgesehen, die nicht P zugewiesen wurden. Es gibt einen Prozess zum Verschieben der Goroutinen von GRQ zu LRQ, die wir später diskutieren werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Bild zeigt alle diese Komponenten zusammen.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/114/13e/494/11413e494428c2540e349637f34bbec3.png" alt="Bild"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Genossenschaftsplaner</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits im ersten Beitrag erwähnt, ist der OS-Scheduler ein präventiver Scheduler. Dies bedeutet im Wesentlichen, dass Sie nicht vorhersagen können, was der Planer zu einem bestimmten Zeitpunkt tun wird. Der Kernel trifft Entscheidungen und alles ist nicht deterministisch. Anwendungen, die auf dem Betriebssystem ausgeführt werden, steuern nicht, was im Kernel mit der Zeitplanung geschieht, es sei denn, sie verwenden Synchronisationsprimitive wie atomare Anweisungen und Mutex-Aufrufe.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Go Scheduler ist Teil der Go Runtime, und die Go Runtime ist in Ihre Anwendung integriert. Dies bedeutet, dass der Go-Scheduler im Benutzerbereich des Kernels arbeitet. Die aktuelle Go-Scheduler-Implementierung ist kein präventiver, sondern ein interaktiver Scheduler. Ein kooperativer Planer zu sein bedeutet, dass der Planer klar definierte Ereignisse im Benutzerbereich benötigt, die an sicheren Stellen im Code auftreten, um Planungsentscheidungen zu treffen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Gute an Go's kollaborativem Planer ist, dass er proaktiv aussieht und sich proaktiv anfühlt. </font><font style="vertical-align: inherit;">Sie können nicht vorhersagen, was der Go-Scheduler tun wird. </font><font style="vertical-align: inherit;">Dies liegt an der Tatsache, dass die Entscheidungsfindung für diesen Scheduler nicht von den Entwicklern abhängt, sondern von der Ausführungszeit von Go. </font><font style="vertical-align: inherit;">Es ist wichtig, sich den Go-Scheduler als proaktiven Scheduler vorzustellen, und da der Scheduler nicht deterministisch ist, ist er nicht allzu schwierig.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gorutin Staaten</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goroutinen haben genau wie Bäche die gleichen drei Zustände auf hoher Ebene. Sie bestimmen die Rolle, die der Go-Planer bei jeder Goroutine spielt. Goroutin kann sich in einem von drei Zuständen befinden: Warten, Bereit oder Erfüllen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dies bedeutet, dass die Goroutine gestoppt wird und darauf wartet, dass etwas fortgesetzt wird. Dies kann beispielsweise aus Gründen des Wartens auf das Betriebssystem (Systemaufrufe) oder der Synchronisierung von Aufrufen (Atom- und Mutex-Operationen) geschehen. Diese Arten von Verzögerungen sind die Hauptursache für schlechte Leistung. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bereitschaft</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Dies bedeutet, dass Goroutine Zeit möchte, um den zugewiesenen Anweisungen zu folgen. </font><font style="vertical-align: inherit;">Wenn Sie viele Goroutinen haben, die Zeit brauchen, müssen Goroutinen länger warten, um Zeit zu bekommen. </font><font style="vertical-align: inherit;">Darüber hinaus wird die individuelle Zeit, die eine Goroutine erhält, reduziert, wenn mehr Goroutinen um die Zeit konkurrieren. </font><font style="vertical-align: inherit;">Diese Art der Planungsverzögerung kann auch zu einer schlechten Leistung führen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erfüllung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dies bedeutet, dass Goroutine in M ​​platziert wurde und seinen Anweisungen folgt. </font><font style="vertical-align: inherit;">Die mit dem Antrag verbundenen Arbeiten wurden abgeschlossen. </font><font style="vertical-align: inherit;">Das will jeder.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kontextwechsel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Go Scheduler erfordert genau definierte User-Space-Ereignisse, die an sicheren Punkten im Code auftreten, um den Kontext zu wechseln. </font><font style="vertical-align: inherit;">Diese Ereignisse und sicheren Punkte werden in Funktionsaufrufen angezeigt. </font><font style="vertical-align: inherit;">Funktionsaufrufe sind für die Leistung des Go Schedulers von entscheidender Bedeutung. </font><font style="vertical-align: inherit;">Wenn Sie enge Schleifen ausführen, die keine Funktionsaufrufe ausführen, kommt es zu Verzögerungen im Scheduler und in der Garbage Collection. </font><font style="vertical-align: inherit;">Funktionsaufrufe müssen unbedingt innerhalb eines angemessenen Zeitraums erfolgen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Ihren Go-Programmen treten vier Ereignisklassen auf, mit denen der Planer Planungsentscheidungen treffen kann. </font><font style="vertical-align: inherit;">Dies bedeutet nicht, dass dies bei einem dieser Ereignisse immer der Fall sein wird. </font><font style="vertical-align: inherit;">Dies bedeutet, dass der Scheduler die Möglichkeit erhält.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie das Schlüsselwort go</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Müllsammler</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Systemaufrufe</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronisation</font></font></li>
</ul><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden des</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Schlüsselworts </font><i><font style="vertical-align: inherit;">go Mit dem</font></i><font style="vertical-align: inherit;"> Schlüsselwort </font><i><font style="vertical-align: inherit;">go</font></i><font style="vertical-align: inherit;"> erstellen Sie eine Goroutine. </font><font style="vertical-align: inherit;">Sobald eine neue Goroutine erstellt wird, hat der Planer die Möglichkeit, eine Planungsentscheidung zu treffen. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garbage Collector (GC)</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Da der GC mit einem eigenen Satz von Goroutinen arbeitet, benötigen diese Gorutine Zeit auf M, um ausgeführt zu werden. </font><font style="vertical-align: inherit;">Dies zwingt den GC zu viel Chaos bei der Planung. </font><font style="vertical-align: inherit;">Der Planer ist jedoch sehr klug in dem, was Goroutine tut, und er wird es verwenden, um Entscheidungen zu treffen. </font><font style="vertical-align: inherit;">Eine vernünftige Lösung besteht darin, den Kontext auf Goroutine umzustellen, die auf die Systemressource zugreifen möchte, und niemand anderes als sie während der Speicherbereinigung. </font><font style="vertical-align: inherit;">Wenn der GC funktioniert, werden viele Planungsentscheidungen getroffen. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Systemaufrufe</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Goroutine einen Systemaufruf ausführt, der M blockiert, kann der Scheduler den Kontext auf eine andere Goroutine umschalten, auf dieselbe M. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronisation</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn ein Aufruf einer atomaren Operation, eines Mutex oder eines Kanals dazu führt, dass Goroutine blockiert wird, kann der Scheduler den Kontext wechseln, um eine neue Goroutine zu starten. </font><font style="vertical-align: inherit;">Sobald Goroutine wieder funktionieren kann, kann es in die Warteschlange gestellt werden und schließlich wieder zu M wechseln.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchrone Systemaufrufe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Betriebssystem, an dem Sie arbeiten, einen Systemaufruf asynchron verarbeiten kann, kann ein sogenannter Netzwerk-Poller verwendet werden, um den Systemaufruf effizienter zu verarbeiten. </font><font style="vertical-align: inherit;">Dies wird mit kqueue (MacOS), epoll (Linux) oder iocp (Windows) in diesen jeweiligen Betriebssystemen erreicht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Netzwerksystemaufrufe können von vielen der heute verwendeten Betriebssysteme asynchron verarbeitet werden. Hier zeigt sich der Netzwerk-Poller, da sein Hauptzweck darin besteht, Netzwerkoperationen zu verarbeiten. Mit dem Netzwerk-Poller für Netzwerksystemaufrufe kann der Scheduler verhindern, dass Goroutinen M während dieser Systemaufrufe blockieren. Dies hilft, M verfügbar zu halten, um andere Goroutinen in LRQ P auszuführen, ohne dass neues M erstellt werden muss. Dies hilft, den Planungsaufwand im Betriebssystem zu verringern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der beste Weg, um zu sehen, wie dies funktioniert, ist ein Beispiel. Die Abbildung zeigt unser grundlegendes Planungsschema. Gorutin-1 wird auf M ausgeführt, und 3 weitere Gorutins warten in LRQ darauf, ihre Zeit auf M zu bekommen. Der Netzwerk-Poller ist untätig und hat nichts zu tun.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d76/7cd/b0f/d767cdb0fd640db3a84e3c87d14f38e3.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der folgenden Abbildung möchte Gorutin-1 (G1) einen Netzwerksystemaufruf ausführen, daher wechselt G1 zum Netzwerk-Poller und wird als asynchroner Netzwerksystemaufruf behandelt. </font><font style="vertical-align: inherit;">Sobald G1 in den Netzwerk-Poller verschoben wurde, steht M nun zur Verfügung, um eine weitere Goroutine von LRQ auszuführen. </font><font style="vertical-align: inherit;">In diesem Fall wechselt Gorutin-2 zu M. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/764/93f/af0/76493faf0f599eefae69938878e4ceb1.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der folgenden Abbildung endet der Systemnetzwerkaufruf mit einem asynchronen Netzwerkaufruf, und G1 kehrt für P zu LRQ zurück. Nachdem G1 zu M zurückgeschaltet werden kann, wird der mit Go verknüpfte Code verwendet Die Antworten können erneut ausgeführt werden. </font><font style="vertical-align: inherit;">Der große Gewinn ist, dass keine zusätzliche Frau erforderlich ist, um Netzwerksystemanrufe zu tätigen. </font><font style="vertical-align: inherit;">Der Netzwerk-Poller verfügt über einen Betriebssystem-Thread und wird über eine Ereignisschleife verarbeitet.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchrone Systemaufrufe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert, wenn Goroutine einen Systemaufruf ausführen möchte, der nicht asynchron ausgeführt werden kann? </font><font style="vertical-align: inherit;">In diesem Fall kann der Netzwerk-Poller nicht verwendet werden, und die Goroutine, die den Systemaufruf ausführt, blockiert M. Dies ist schlecht, aber es gibt keine Möglichkeit, dies zu verhindern. </font><font style="vertical-align: inherit;">Ein Beispiel für einen Systemaufruf, der nicht asynchron ausgeführt werden kann, sind dateibasierte Systemaufrufe. </font><font style="vertical-align: inherit;">Wenn Sie CGO verwenden, kann es andere Situationen geben, in denen das Aufrufen von C-Funktionen auch M blockiert.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Windows-Betriebssystem kann dateibasierte asynchrone Systemaufrufe ausführen. </font><font style="vertical-align: inherit;">Technisch gesehen können Sie unter Windows den Netzwerk-Poller verwenden.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mal sehen, was mit einem synchronen Systemaufruf (z. B. Datei-E / A) passiert, der M blockiert. Die Abbildung zeigt unser grundlegendes Planungsdiagramm, aber dieses Mal wird G1 einen synchronen Systemaufruf ausführen, der M1 blockiert. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/747/549/a28/747549a28a7a627a3cbd98fffe728fad.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der folgenden Abbildung kann der Scheduler feststellen, dass G1 eine M-Sperre verursacht hat. Zu diesem Zeitpunkt trennt der Scheduler M1 von P, wobei ein blockierendes G1 noch angeschlossen ist. Der Scheduler führt dann einen neuen M2 ein, um P zu bedienen. Zu diesem Zeitpunkt kann G2 aus LRQ ausgewählt und in den M2-Kontext aufgenommen werden. Wenn M aufgrund eines vorherigen Austauschs bereits vorhanden ist, ist dieser Übergang schneller als die Notwendigkeit, ein neues M zu erstellen.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/966/30c/3dd/96630c3dd34a06fbc5ed5f8b4c8bdfbc.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der nächste Schritt schließt den Aufruf des Sperrsystems von G1 ab. </font><font style="vertical-align: inherit;">Zu diesem Zeitpunkt kann G1 zu LRQ zurückkehren und erneut von P. M1 bedient werden. M1 wird dann für die zukünftige Verwendung beiseite gelegt, falls dieses Szenario wiederholt werden sollte.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/553/0ed/f8c/5530edf8c481aee13a40ff0b55e8e1ed.png" alt="Bild"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbeit stehlen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer Aspekt des Schedulers ist, dass es sich um einen Goroutine-Diebstahlplaner handelt. Dies hilft in mehreren Bereichen, eine effektive Planung zu unterstützen. Erstens müssen Sie als letztes M in den Standby-Zustand versetzen, da das Betriebssystem M in diesem Fall mithilfe des Kontexts vom Kernel wechselt. Dies bedeutet, dass P keine Arbeit leisten kann, selbst wenn sich eine Goroutine in einem gesunden Zustand befindet, bis M zurück zum Kernel wechselt. Gorutin-Diebstahl hilft auch dabei, Zeitintervalle zwischen allen Ps auszugleichen, damit die Arbeit besser verteilt und effizienter ausgeführt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Abbildung haben wir ein Multithread-Go-Programm mit zwei Ps, die jeweils vier Gs und ein G in GRQ bedienen. Was passiert, wenn einer von P schnell sein gesamtes G bedient?</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e1a/745/eaa/e1a745eaaeab4e91bf35e80d8f16ae34.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Außerdem muss P1 keine Goroutinen mehr ausführen. Es gibt jedoch Goroutinen im Arbeitszustand, sowohl in LRQ für P2 als auch in GRQ. Dies ist der Moment, in dem P1 Goroutine stehlen muss. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6f6/190/ccc/6f6190cccec8213c27cadfbb03b67767.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Regeln für den Diebstahl von Goroutinen lauten wie folgt. Der gesamte Code kann in den Laufzeitquellen angezeigt werden.</font></font><br>
<br>
<pre><code class="go hljs">runtime.schedule() {
    <span class="hljs-comment">// only 1/61 of the time, check the global runnable queue for a G.</span>
    <span class="hljs-comment">// if not found, check the local queue.</span>
    <span class="hljs-comment">// if not found,</span>
    <span class="hljs-comment">//     try to steal from other Ps.</span>
    <span class="hljs-comment">//     if not, check the global runnable queue.</span>
    <span class="hljs-comment">//     if not found, poll network.</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf diesen Regeln sollte P1 P2 auf das Vorhandensein von Goroutinen in seinem LRQ prüfen und die Hälfte von dem nehmen, was es findet. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/af2/b9b/ec2/af2b9bec21571656e051799fb3213020.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert, wenn P2 alle seine Programme beendet und P1 nichts mehr in LRQ hat? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2 hat alle seine Arbeiten abgeschlossen und muss nun die Goroutinen stehlen. </font><font style="vertical-align: inherit;">Zuerst wird er sich den LRQ P1 ansehen, aber keine Goroutinen finden. </font><font style="vertical-align: inherit;">Als nächstes wird er sich GRQ ansehen. </font><font style="vertical-align: inherit;">Dort findet er die G9. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4f8/2db/b86/4f82dbb86b9005e458097587792dd462.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2 stiehlt G9 von GRQ und beginnt mit der Arbeit. </font><font style="vertical-align: inherit;">Das Gute an all diesem Diebstahl ist, dass M damit beschäftigt bleiben und nicht inaktiv sein kann.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e12/221/a4a/e12221a4ad60695c5c5c97837e30cfbb.png" alt="Bild"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Praktisches Beispiel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Mechanik und Semantik möchte ich Ihnen zeigen, wie dies alles zusammenkommt, damit der Go-Scheduler im Laufe der Zeit mehr Arbeit leisten kann. Stellen Sie sich eine in C geschriebene Multithread-Anwendung vor, in der das Programm zwei Betriebssystem-Threads verwaltet, die Nachrichten aneinander senden. Das Bild enthält zwei Threads, die die Nachricht hin und her senden. Thread 1 empfängt den kontextvermittelten Kern 1 und wird jetzt ausgeführt, wodurch Thread 1 seine Nachricht an Thread 2 senden kann.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bb3/6fb/00d/bb36fb00db345441ca295dd01d153b2b.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Thread 1 das Senden der Nachricht beendet hat, muss er auf eine Antwort warten. Dies führt dazu, dass Thread 1 vom Kontext von Kernel 1 getrennt und in einen Wartezustand versetzt wird. Sobald Thread 2 eine Nachrichtenbenachrichtigung erhält, wird er in einen fehlerfreien Zustand versetzt. Jetzt kann das Betriebssystem einen Kontextwechsel durchführen und Thread 2 auf dem Kernel ausführen, der sich als Kernel 2 herausstellt. Dann verarbeitet Thread 2 die Nachricht und sendet eine neue Nachricht zurück an Thread 1.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4af/66e/0fe/4af66e0fe8440f757063603b6bc161a2.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes wechselt der Stream zurück zum Kontext, wenn die Nachricht von Stream 2 von Stream 1 empfangen wird. Nun wechselt Stream 2 vom Ausführungsstatus in den Standby-Status, und Stream 1 wechselt vom Standby-Status in den Bereitschaftsstatus und kehrt schließlich in den Ausführungsstatus zurück, wodurch er verarbeitet werden kann und senden Sie eine neue Nachricht zurück. Alle diese Kontextwechsel und Statusänderungen benötigen Zeit, um abgeschlossen zu werden, was die Geschwindigkeit der Arbeit begrenzt. Da jeder Kontextwechsel eine Verzögerung von ~ 1000 Nanosekunden mit sich bringt und wir hoffen, dass die Hardware 12 Befehle pro Nanosekunde ausführt, sehen Sie sich 12.000 Befehle an, die während dieser Kontextwechsel mehr oder weniger nicht ausgeführt werden. Da sich diese Strömungen auch zwischen verschiedenen Kernen schneiden,Die Wahrscheinlichkeit einer zusätzlichen Verzögerung bei Cache-Zeilenfehlern ist ebenfalls hoch.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a45/b47/127/a45b47127d054f2b56b6c2534c9150bf.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Abbildung sind zwei Gorutine zu sehen, die in Harmonie miteinander sind und die Botschaft hin und her weitergeben. G1 erhält den Kontextschalter M1, der auf Core 1 ausgeführt wird und es G1 ermöglicht, seine Arbeit zu erledigen. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/977/b59/78c/977b5978ca8daa9bfc186c77c901565a.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn G1 das Senden der Nachricht beendet hat, muss er auf eine Antwort warten. Dies führt dazu, dass G1 vom M1-Kontext getrennt und in den Ruhezustand versetzt wird. Sobald G2 über die Nachricht informiert wird, geht sie in einen fehlerfreien Zustand über. Jetzt kann der Go-Scheduler eine Kontextumschaltung durchführen und G2 auf M1 ausführen, das noch auf Core 1 ausgeführt wird. Dann verarbeitet G2 die Nachricht und sendet eine neue Nachricht zurück an G1.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3e8/86c/003/3e886c003a64536731234abde2746ca2.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im nächsten Schritt schaltet alles wieder um, wenn die von G2 gesendete Nachricht von G1 empfangen wird. Nun wechselt der Kontext G2 vom Ausführungsstatus in den Wartezustand, und der Kontext G1 wechselt vom Wartezustand in den Ausführungsstatus und schließlich zurück in den Ausführungsstatus, wodurch er eine neue Nachricht verarbeiten und zurücksenden kann. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4db/97b/a31/4db97ba314fa8b14bf6497dcaf15135a.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Dinge an der Oberfläche scheinen nicht anders zu sein. Unabhängig davon, ob Sie Streams oder Goroutinen verwenden, treten dieselben Kontext- und Statusänderungen auf. Es gibt jedoch einen großen Unterschied zwischen der Verwendung von Streams und Gorutin, der auf den ersten Blick nicht offensichtlich ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Goroutine verwendet wird, werden für die gesamte Verarbeitung dieselben Betriebssystem-Threads und derselbe Kernel verwendet. Dies bedeutet, dass OS Flow aus Betriebssystemsicht niemals in einen Wartezustand wechselt. nicht einmal. Infolgedessen gehen alle Anweisungen, die wir beim Wechseln von Kontexten bei der Verwendung von Streams verloren haben, bei der Verwendung von Goroutin nicht verloren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Wesentlichen verwandelte Go IO / Blocking-Arbeit in einen prozessorgebundenen Job auf Betriebssystemebene. Da alle Kontextwechsel auf Anwendungsebene stattfinden, verlieren wir beim Kontextwechsel nicht die gleichen ~ 12.000 Anweisungen (im Durchschnitt), die wir bei der Verwendung von Streams verloren haben. In Go kosten dieselben Kontextwechsel ~ 200 Nanosekunden oder ~ 2,4 Tausend Befehle. Der Scheduler hilft auch dabei, die Leistung von Caching-Strings und </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">NUMA</font></a><font style="vertical-align: inherit;"> zu verbessern</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Deshalb benötigen wir nicht mehr Threads als virtuelle Kerne. </font><font style="vertical-align: inherit;">Go kann im Laufe der Zeit mehr Arbeit leisten, da der Go-Scheduler versucht, weniger Threads zu verwenden und mehr für jeden Thread zu tun, wodurch die Belastung des Betriebssystems und der Hardware verringert wird.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Go Scheduler ist wirklich erstaunlich, wie er die Feinheiten des Betriebssystems und der Hardware berücksichtigt. Durch die Möglichkeit, E / A / Lock-Vorgänge auf Betriebssystemebene in prozessorgebundene Vorgänge umzuwandeln, können wir mit der Zeit mehr Prozessorleistung erzielen. Aus diesem Grund benötigen Sie nicht mehr Betriebssystem-Threads als virtuelle Kernel. Sie können davon ausgehen, dass Ihre gesamte Arbeit (mit CPU-Bindung und E / A / Sperren) mit einem Betriebssystem-Thread pro virtuellem Kernel ausgeführt wird. Dies ist für Netzwerkanwendungen und andere Anwendungen möglich, die keine Systemaufrufe benötigen, die Betriebssystem-Threads blockieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Entwickler sollten Sie immer noch verstehen, was Ihre Anwendung in Bezug auf die Art der Arbeit tut. </font><font style="vertical-align: inherit;">Sie können nicht eine unbegrenzte Anzahl von Goroutinen erstellen und eine erstaunliche Leistung erwarten. </font><font style="vertical-align: inherit;">Weniger ist immer mehr, aber mit einem Verständnis dieser Semantik des Go-Schedulers können Sie bessere technische Entscheidungen treffen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de489852/index.html">Transparente Authentifizierung in ASP.Net Core unter Linux</a></li>
<li><a href="../de489854/index.html">Redux vs MobX ohne Verwirrung</a></li>
<li><a href="../de489856/index.html">Banach-Tarski-Umkehrparadoxon oder wie man das gespeicherte Datenvolumen um das Fünffache reduziert</a></li>
<li><a href="../de489858/index.html">Internationalisierung: Das Web für alle zugänglich machen</a></li>
<li><a href="../de489860/index.html">Die Geschichte von Telefunken: der Phönix der deutschen Elektronik von Wilhelm II. Und Goebbels bis zu den Beatles und heute</a></li>
<li><a href="../de489868/index.html">Einfrieren von Mozilla WebThings</a></li>
<li><a href="../de489870/index.html">Kostenlos offline intensiv von Node.js in Nischni Nowgorod</a></li>
<li><a href="../de489872/index.html">Wie das DLP-System und das OCR-Modul Mitarbeiter daran hinderten, Pass-Scans zu fälschen</a></li>
<li><a href="../de489874/index.html">Cross-Kompilieren von ausführbaren Rust for Windows-Dateien unter Linux</a></li>
<li><a href="../de489876/index.html">Wie wir das Problem der drei Monolithen gelöst haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>