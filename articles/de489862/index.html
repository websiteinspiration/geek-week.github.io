<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíà üî´ ü§± Planen in Go: Teil II - Der Go-Planer üíÜüèø ‚úãüèø üêª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Dies ist der zweite Beitrag in einer dreiteiligen Reihe, die einen Eindruck von der Mechanik und Semantik der Arbeit des Schedulers in Go ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Planen in Go: Teil II - Der Go-Planer</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489862/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font><font style="vertical-align: inherit;">Dies ist der zweite Beitrag in einer dreiteiligen Reihe, die einen Eindruck von der Mechanik und Semantik der Arbeit des Schedulers in Go vermittelt. </font><font style="vertical-align: inherit;">In diesem Beitrag geht es um den Go-Planer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ersten Teil</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dieser Serie habe ich Aspekte des Betriebssystem-Schedulers erl√§utert, die meiner Meinung nach wichtig sind, um die Semantik des Go-Schedulers zu verstehen und zu bewerten. </font><font style="vertical-align: inherit;">In diesem Beitrag werde ich auf semantischer Ebene erkl√§ren, wie der Go-Scheduler funktioniert. </font><font style="vertical-align: inherit;">Der Go Scheduler ist ein komplexes System und kleine mechanische Details sind nicht wichtig. </font><font style="vertical-align: inherit;">Es ist wichtig, ein gutes Modell daf√ºr zu haben, wie alles funktioniert und sich verh√§lt. </font><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen Sie die besten technischen Entscheidungen treffen.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ihr Programm startet</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihr Go-Programm gestartet wird, wird ihm f√ºr jeden auf dem Hostcomputer definierten virtuellen Kern ein logischer Prozessor (P) zugewiesen. Wenn Sie einen Prozessor mit mehreren Hardwarethreads pro physischem Kern haben (Hyper-Threading), wird jeder Hardwarethread Ihrem Programm als virtueller Kern angezeigt. Schauen Sie sich zum besseren Verst√§ndnis den Systembericht f√ºr mein MacBook Pro an. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b6e/2de/4a8/b6e2de4a805c6a87c95aa0afcef436ac.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen sehen, dass ich einen Prozessor mit 4 physischen Kernen habe. In diesem Bericht wird die Anzahl der Hardwarethreads pro physischem Kern nicht angegeben. Der Intel Core i7-Prozessor verf√ºgt √ºber Hyper-Threading-Technologie, was bedeutet, dass der physische Core √ºber 2 Hardware-Threads verf√ºgt. Dies teilt Go mit, dass 8 virtuelle Kerne verf√ºgbar sind, um Betriebssystem-Threads parallel auszuf√ºhren. Betrachten Sie das folgende Programm, um dies zu √ºberpr√ºfen:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"runtime"</span><font></font>
)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
<font></font>
    <span class="hljs-comment">// NumCPU returns the number of logical</span>
    <span class="hljs-comment">// CPUs usable by the current process.</span><font></font>
    fmt.Println(runtime.NumCPU())<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ich dieses Programm auf meinem Computer ausf√ºhre, ist das Ergebnis des Aufrufs der Funktion NumCPU () 8. Jedes Go-Programm, das ich auf meinem Computer ausf√ºhre, erh√§lt 8 (P). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein Betriebssystemstrom ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) zugeordnet. Dieser Thread wird weiterhin vom Betriebssystem verwaltet, und das Betriebssystem ist weiterhin daf√ºr verantwortlich, den Thread zur Ausf√ºhrung im Kernel zu platzieren. Das hei√üt, wenn ich Go auf meinem Computer ausf√ºhre, stehen mir 8 Threads zur Verf√ºgung, die jeweils einzeln mit P verkn√ºpft sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes Go-Programm erh√§lt au√üerdem eine erste Goroutine ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Goroutine ist im Wesentlichen Coroutine, aber es ist Go, also ersetzen wir den Buchstaben C durch G und erhalten das Wort Goroutine. Sie k√∂nnen sich Goroutines als Threads auf Anwendungsebene vorstellen, die OS-Threads sehr √§hnlich sind. So wie Betriebssystem-Threads vom Kernel ein- und ausgeschaltet werden, werden Kontextprogramme vom Kontext ein- und ausgeschaltet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das letzte R√§tsel sind die Ausf√ºhrungswarteschlangen. </font><font style="vertical-align: inherit;">Der Go-Scheduler enth√§lt zwei verschiedene Ausf√ºhrungswarteschlangen: die globale Ausf√ºhrungswarteschlange (GRQ) und die lokale Ausf√ºhrungswarteschlange (LRQ). </font><font style="vertical-align: inherit;">Jedem P wird ein LRQ zugewiesen, der die Goroutins steuert, die im Kontext von P ausgef√ºhrt werden sollen. Diese Goroutinen werden in dem diesem P zugewiesenen Kontext M ein- und ausgeschaltet. GRQ ist f√ºr Goroutinen vorgesehen, die nicht P zugewiesen wurden. Es gibt einen Prozess zum Verschieben der Goroutinen von GRQ zu LRQ, die wir sp√§ter diskutieren werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Bild zeigt alle diese Komponenten zusammen.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/114/13e/494/11413e494428c2540e349637f34bbec3.png" alt="Bild"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Genossenschaftsplaner</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits im ersten Beitrag erw√§hnt, ist der OS-Scheduler ein pr√§ventiver Scheduler. Dies bedeutet im Wesentlichen, dass Sie nicht vorhersagen k√∂nnen, was der Planer zu einem bestimmten Zeitpunkt tun wird. Der Kernel trifft Entscheidungen und alles ist nicht deterministisch. Anwendungen, die auf dem Betriebssystem ausgef√ºhrt werden, steuern nicht, was im Kernel mit der Zeitplanung geschieht, es sei denn, sie verwenden Synchronisationsprimitive wie atomare Anweisungen und Mutex-Aufrufe.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Go Scheduler ist Teil der Go Runtime, und die Go Runtime ist in Ihre Anwendung integriert. Dies bedeutet, dass der Go-Scheduler im Benutzerbereich des Kernels arbeitet. Die aktuelle Go-Scheduler-Implementierung ist kein pr√§ventiver, sondern ein interaktiver Scheduler. Ein kooperativer Planer zu sein bedeutet, dass der Planer klar definierte Ereignisse im Benutzerbereich ben√∂tigt, die an sicheren Stellen im Code auftreten, um Planungsentscheidungen zu treffen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Gute an Go's kollaborativem Planer ist, dass er proaktiv aussieht und sich proaktiv anf√ºhlt. </font><font style="vertical-align: inherit;">Sie k√∂nnen nicht vorhersagen, was der Go-Scheduler tun wird. </font><font style="vertical-align: inherit;">Dies liegt an der Tatsache, dass die Entscheidungsfindung f√ºr diesen Scheduler nicht von den Entwicklern abh√§ngt, sondern von der Ausf√ºhrungszeit von Go. </font><font style="vertical-align: inherit;">Es ist wichtig, sich den Go-Scheduler als proaktiven Scheduler vorzustellen, und da der Scheduler nicht deterministisch ist, ist er nicht allzu schwierig.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gorutin Staaten</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goroutinen haben genau wie B√§che die gleichen drei Zust√§nde auf hoher Ebene. Sie bestimmen die Rolle, die der Go-Planer bei jeder Goroutine spielt. Goroutin kann sich in einem von drei Zust√§nden befinden: Warten, Bereit oder Erf√ºllen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dies bedeutet, dass die Goroutine gestoppt wird und darauf wartet, dass etwas fortgesetzt wird. Dies kann beispielsweise aus Gr√ºnden des Wartens auf das Betriebssystem (Systemaufrufe) oder der Synchronisierung von Aufrufen (Atom- und Mutex-Operationen) geschehen. Diese Arten von Verz√∂gerungen sind die Hauptursache f√ºr schlechte Leistung. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bereitschaft</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Dies bedeutet, dass Goroutine Zeit m√∂chte, um den zugewiesenen Anweisungen zu folgen. </font><font style="vertical-align: inherit;">Wenn Sie viele Goroutinen haben, die Zeit brauchen, m√ºssen Goroutinen l√§nger warten, um Zeit zu bekommen. </font><font style="vertical-align: inherit;">Dar√ºber hinaus wird die individuelle Zeit, die eine Goroutine erh√§lt, reduziert, wenn mehr Goroutinen um die Zeit konkurrieren. </font><font style="vertical-align: inherit;">Diese Art der Planungsverz√∂gerung kann auch zu einer schlechten Leistung f√ºhren. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erf√ºllung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dies bedeutet, dass Goroutine in M ‚Äã‚Äãplatziert wurde und seinen Anweisungen folgt. </font><font style="vertical-align: inherit;">Die mit dem Antrag verbundenen Arbeiten wurden abgeschlossen. </font><font style="vertical-align: inherit;">Das will jeder.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kontextwechsel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Go Scheduler erfordert genau definierte User-Space-Ereignisse, die an sicheren Punkten im Code auftreten, um den Kontext zu wechseln. </font><font style="vertical-align: inherit;">Diese Ereignisse und sicheren Punkte werden in Funktionsaufrufen angezeigt. </font><font style="vertical-align: inherit;">Funktionsaufrufe sind f√ºr die Leistung des Go Schedulers von entscheidender Bedeutung. </font><font style="vertical-align: inherit;">Wenn Sie enge Schleifen ausf√ºhren, die keine Funktionsaufrufe ausf√ºhren, kommt es zu Verz√∂gerungen im Scheduler und in der Garbage Collection. </font><font style="vertical-align: inherit;">Funktionsaufrufe m√ºssen unbedingt innerhalb eines angemessenen Zeitraums erfolgen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Ihren Go-Programmen treten vier Ereignisklassen auf, mit denen der Planer Planungsentscheidungen treffen kann. </font><font style="vertical-align: inherit;">Dies bedeutet nicht, dass dies bei einem dieser Ereignisse immer der Fall sein wird. </font><font style="vertical-align: inherit;">Dies bedeutet, dass der Scheduler die M√∂glichkeit erh√§lt.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie das Schl√ºsselwort go</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√ºllsammler</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Systemaufrufe</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronisation</font></font></li>
</ul><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden des</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Schl√ºsselworts </font><i><font style="vertical-align: inherit;">go Mit dem</font></i><font style="vertical-align: inherit;"> Schl√ºsselwort </font><i><font style="vertical-align: inherit;">go</font></i><font style="vertical-align: inherit;"> erstellen Sie eine Goroutine. </font><font style="vertical-align: inherit;">Sobald eine neue Goroutine erstellt wird, hat der Planer die M√∂glichkeit, eine Planungsentscheidung zu treffen. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garbage Collector (GC)</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Da der GC mit einem eigenen Satz von Goroutinen arbeitet, ben√∂tigen diese Gorutine Zeit auf M, um ausgef√ºhrt zu werden. </font><font style="vertical-align: inherit;">Dies zwingt den GC zu viel Chaos bei der Planung. </font><font style="vertical-align: inherit;">Der Planer ist jedoch sehr klug in dem, was Goroutine tut, und er wird es verwenden, um Entscheidungen zu treffen. </font><font style="vertical-align: inherit;">Eine vern√ºnftige L√∂sung besteht darin, den Kontext auf Goroutine umzustellen, die auf die Systemressource zugreifen m√∂chte, und niemand anderes als sie w√§hrend der Speicherbereinigung. </font><font style="vertical-align: inherit;">Wenn der GC funktioniert, werden viele Planungsentscheidungen getroffen. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Systemaufrufe</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Goroutine einen Systemaufruf ausf√ºhrt, der M blockiert, kann der Scheduler den Kontext auf eine andere Goroutine umschalten, auf dieselbe M. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronisation</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn ein Aufruf einer atomaren Operation, eines Mutex oder eines Kanals dazu f√ºhrt, dass Goroutine blockiert wird, kann der Scheduler den Kontext wechseln, um eine neue Goroutine zu starten. </font><font style="vertical-align: inherit;">Sobald Goroutine wieder funktionieren kann, kann es in die Warteschlange gestellt werden und schlie√ülich wieder zu M wechseln.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchrone Systemaufrufe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Betriebssystem, an dem Sie arbeiten, einen Systemaufruf asynchron verarbeiten kann, kann ein sogenannter Netzwerk-Poller verwendet werden, um den Systemaufruf effizienter zu verarbeiten. </font><font style="vertical-align: inherit;">Dies wird mit kqueue (MacOS), epoll (Linux) oder iocp (Windows) in diesen jeweiligen Betriebssystemen erreicht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Netzwerksystemaufrufe k√∂nnen von vielen der heute verwendeten Betriebssysteme asynchron verarbeitet werden. Hier zeigt sich der Netzwerk-Poller, da sein Hauptzweck darin besteht, Netzwerkoperationen zu verarbeiten. Mit dem Netzwerk-Poller f√ºr Netzwerksystemaufrufe kann der Scheduler verhindern, dass Goroutinen M w√§hrend dieser Systemaufrufe blockieren. Dies hilft, M verf√ºgbar zu halten, um andere Goroutinen in LRQ P auszuf√ºhren, ohne dass neues M erstellt werden muss. Dies hilft, den Planungsaufwand im Betriebssystem zu verringern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der beste Weg, um zu sehen, wie dies funktioniert, ist ein Beispiel. Die Abbildung zeigt unser grundlegendes Planungsschema. Gorutin-1 wird auf M ausgef√ºhrt, und 3 weitere Gorutins warten in LRQ darauf, ihre Zeit auf M zu bekommen. Der Netzwerk-Poller ist unt√§tig und hat nichts zu tun.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d76/7cd/b0f/d767cdb0fd640db3a84e3c87d14f38e3.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der folgenden Abbildung m√∂chte Gorutin-1 (G1) einen Netzwerksystemaufruf ausf√ºhren, daher wechselt G1 zum Netzwerk-Poller und wird als asynchroner Netzwerksystemaufruf behandelt. </font><font style="vertical-align: inherit;">Sobald G1 in den Netzwerk-Poller verschoben wurde, steht M nun zur Verf√ºgung, um eine weitere Goroutine von LRQ auszuf√ºhren. </font><font style="vertical-align: inherit;">In diesem Fall wechselt Gorutin-2 zu M. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/764/93f/af0/76493faf0f599eefae69938878e4ceb1.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der folgenden Abbildung endet der Systemnetzwerkaufruf mit einem asynchronen Netzwerkaufruf, und G1 kehrt f√ºr P zu LRQ zur√ºck. Nachdem G1 zu M zur√ºckgeschaltet werden kann, wird der mit Go verkn√ºpfte Code verwendet Die Antworten k√∂nnen erneut ausgef√ºhrt werden. </font><font style="vertical-align: inherit;">Der gro√üe Gewinn ist, dass keine zus√§tzliche Frau erforderlich ist, um Netzwerksystemanrufe zu t√§tigen. </font><font style="vertical-align: inherit;">Der Netzwerk-Poller verf√ºgt √ºber einen Betriebssystem-Thread und wird √ºber eine Ereignisschleife verarbeitet.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchrone Systemaufrufe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert, wenn Goroutine einen Systemaufruf ausf√ºhren m√∂chte, der nicht asynchron ausgef√ºhrt werden kann? </font><font style="vertical-align: inherit;">In diesem Fall kann der Netzwerk-Poller nicht verwendet werden, und die Goroutine, die den Systemaufruf ausf√ºhrt, blockiert M. Dies ist schlecht, aber es gibt keine M√∂glichkeit, dies zu verhindern. </font><font style="vertical-align: inherit;">Ein Beispiel f√ºr einen Systemaufruf, der nicht asynchron ausgef√ºhrt werden kann, sind dateibasierte Systemaufrufe. </font><font style="vertical-align: inherit;">Wenn Sie CGO verwenden, kann es andere Situationen geben, in denen das Aufrufen von C-Funktionen auch M blockiert.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Windows-Betriebssystem kann dateibasierte asynchrone Systemaufrufe ausf√ºhren. </font><font style="vertical-align: inherit;">Technisch gesehen k√∂nnen Sie unter Windows den Netzwerk-Poller verwenden.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mal sehen, was mit einem synchronen Systemaufruf (z. B. Datei-E / A) passiert, der M blockiert. Die Abbildung zeigt unser grundlegendes Planungsdiagramm, aber dieses Mal wird G1 einen synchronen Systemaufruf ausf√ºhren, der M1 blockiert. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/747/549/a28/747549a28a7a627a3cbd98fffe728fad.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der folgenden Abbildung kann der Scheduler feststellen, dass G1 eine M-Sperre verursacht hat. Zu diesem Zeitpunkt trennt der Scheduler M1 von P, wobei ein blockierendes G1 noch angeschlossen ist. Der Scheduler f√ºhrt dann einen neuen M2 ein, um P zu bedienen. Zu diesem Zeitpunkt kann G2 aus LRQ ausgew√§hlt und in den M2-Kontext aufgenommen werden. Wenn M aufgrund eines vorherigen Austauschs bereits vorhanden ist, ist dieser √úbergang schneller als die Notwendigkeit, ein neues M zu erstellen.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/966/30c/3dd/96630c3dd34a06fbc5ed5f8b4c8bdfbc.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der n√§chste Schritt schlie√üt den Aufruf des Sperrsystems von G1 ab. </font><font style="vertical-align: inherit;">Zu diesem Zeitpunkt kann G1 zu LRQ zur√ºckkehren und erneut von P. M1 bedient werden. M1 wird dann f√ºr die zuk√ºnftige Verwendung beiseite gelegt, falls dieses Szenario wiederholt werden sollte.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/553/0ed/f8c/5530edf8c481aee13a40ff0b55e8e1ed.png" alt="Bild"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbeit stehlen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer Aspekt des Schedulers ist, dass es sich um einen Goroutine-Diebstahlplaner handelt. Dies hilft in mehreren Bereichen, eine effektive Planung zu unterst√ºtzen. Erstens m√ºssen Sie als letztes M in den Standby-Zustand versetzen, da das Betriebssystem M in diesem Fall mithilfe des Kontexts vom Kernel wechselt. Dies bedeutet, dass P keine Arbeit leisten kann, selbst wenn sich eine Goroutine in einem gesunden Zustand befindet, bis M zur√ºck zum Kernel wechselt. Gorutin-Diebstahl hilft auch dabei, Zeitintervalle zwischen allen Ps auszugleichen, damit die Arbeit besser verteilt und effizienter ausgef√ºhrt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Abbildung haben wir ein Multithread-Go-Programm mit zwei Ps, die jeweils vier Gs und ein G in GRQ bedienen. Was passiert, wenn einer von P schnell sein gesamtes G bedient?</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e1a/745/eaa/e1a745eaaeab4e91bf35e80d8f16ae34.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au√üerdem muss P1 keine Goroutinen mehr ausf√ºhren. Es gibt jedoch Goroutinen im Arbeitszustand, sowohl in LRQ f√ºr P2 als auch in GRQ. Dies ist der Moment, in dem P1 Goroutine stehlen muss. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6f6/190/ccc/6f6190cccec8213c27cadfbb03b67767.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Regeln f√ºr den Diebstahl von Goroutinen lauten wie folgt. Der gesamte Code kann in den Laufzeitquellen angezeigt werden.</font></font><br>
<br>
<pre><code class="go hljs">runtime.schedule() {
    <span class="hljs-comment">// only 1/61 of the time, check the global runnable queue for a G.</span>
    <span class="hljs-comment">// if not found, check the local queue.</span>
    <span class="hljs-comment">// if not found,</span>
    <span class="hljs-comment">//     try to steal from other Ps.</span>
    <span class="hljs-comment">//     if not, check the global runnable queue.</span>
    <span class="hljs-comment">//     if not found, poll network.</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf diesen Regeln sollte P1 P2 auf das Vorhandensein von Goroutinen in seinem LRQ pr√ºfen und die H√§lfte von dem nehmen, was es findet. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/af2/b9b/ec2/af2b9bec21571656e051799fb3213020.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert, wenn P2 alle seine Programme beendet und P1 nichts mehr in LRQ hat? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2 hat alle seine Arbeiten abgeschlossen und muss nun die Goroutinen stehlen. </font><font style="vertical-align: inherit;">Zuerst wird er sich den LRQ P1 ansehen, aber keine Goroutinen finden. </font><font style="vertical-align: inherit;">Als n√§chstes wird er sich GRQ ansehen. </font><font style="vertical-align: inherit;">Dort findet er die G9. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4f8/2db/b86/4f82dbb86b9005e458097587792dd462.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2 stiehlt G9 von GRQ und beginnt mit der Arbeit. </font><font style="vertical-align: inherit;">Das Gute an all diesem Diebstahl ist, dass M damit besch√§ftigt bleiben und nicht inaktiv sein kann.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e12/221/a4a/e12221a4ad60695c5c5c97837e30cfbb.png" alt="Bild"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Praktisches Beispiel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Mechanik und Semantik m√∂chte ich Ihnen zeigen, wie dies alles zusammenkommt, damit der Go-Scheduler im Laufe der Zeit mehr Arbeit leisten kann. Stellen Sie sich eine in C geschriebene Multithread-Anwendung vor, in der das Programm zwei Betriebssystem-Threads verwaltet, die Nachrichten aneinander senden. Das Bild enth√§lt zwei Threads, die die Nachricht hin und her senden. Thread 1 empf√§ngt den kontextvermittelten Kern 1 und wird jetzt ausgef√ºhrt, wodurch Thread 1 seine Nachricht an Thread 2 senden kann.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bb3/6fb/00d/bb36fb00db345441ca295dd01d153b2b.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Thread 1 das Senden der Nachricht beendet hat, muss er auf eine Antwort warten. Dies f√ºhrt dazu, dass Thread 1 vom Kontext von Kernel 1 getrennt und in einen Wartezustand versetzt wird. Sobald Thread 2 eine Nachrichtenbenachrichtigung erh√§lt, wird er in einen fehlerfreien Zustand versetzt. Jetzt kann das Betriebssystem einen Kontextwechsel durchf√ºhren und Thread 2 auf dem Kernel ausf√ºhren, der sich als Kernel 2 herausstellt. Dann verarbeitet Thread 2 die Nachricht und sendet eine neue Nachricht zur√ºck an Thread 1.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4af/66e/0fe/4af66e0fe8440f757063603b6bc161a2.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als n√§chstes wechselt der Stream zur√ºck zum Kontext, wenn die Nachricht von Stream 2 von Stream 1 empfangen wird. Nun wechselt Stream 2 vom Ausf√ºhrungsstatus in den Standby-Status, und Stream 1 wechselt vom Standby-Status in den Bereitschaftsstatus und kehrt schlie√ülich in den Ausf√ºhrungsstatus zur√ºck, wodurch er verarbeitet werden kann und senden Sie eine neue Nachricht zur√ºck. Alle diese Kontextwechsel und Status√§nderungen ben√∂tigen Zeit, um abgeschlossen zu werden, was die Geschwindigkeit der Arbeit begrenzt. Da jeder Kontextwechsel eine Verz√∂gerung von ~ 1000 Nanosekunden mit sich bringt und wir hoffen, dass die Hardware 12 Befehle pro Nanosekunde ausf√ºhrt, sehen Sie sich 12.000 Befehle an, die w√§hrend dieser Kontextwechsel mehr oder weniger nicht ausgef√ºhrt werden. Da sich diese Str√∂mungen auch zwischen verschiedenen Kernen schneiden,Die Wahrscheinlichkeit einer zus√§tzlichen Verz√∂gerung bei Cache-Zeilenfehlern ist ebenfalls hoch.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a45/b47/127/a45b47127d054f2b56b6c2534c9150bf.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Abbildung sind zwei Gorutine zu sehen, die in Harmonie miteinander sind und die Botschaft hin und her weitergeben. G1 erh√§lt den Kontextschalter M1, der auf Core 1 ausgef√ºhrt wird und es G1 erm√∂glicht, seine Arbeit zu erledigen. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/977/b59/78c/977b5978ca8daa9bfc186c77c901565a.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn G1 das Senden der Nachricht beendet hat, muss er auf eine Antwort warten. Dies f√ºhrt dazu, dass G1 vom M1-Kontext getrennt und in den Ruhezustand versetzt wird. Sobald G2 √ºber die Nachricht informiert wird, geht sie in einen fehlerfreien Zustand √ºber. Jetzt kann der Go-Scheduler eine Kontextumschaltung durchf√ºhren und G2 auf M1 ausf√ºhren, das noch auf Core 1 ausgef√ºhrt wird. Dann verarbeitet G2 die Nachricht und sendet eine neue Nachricht zur√ºck an G1.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3e8/86c/003/3e886c003a64536731234abde2746ca2.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im n√§chsten Schritt schaltet alles wieder um, wenn die von G2 gesendete Nachricht von G1 empfangen wird. Nun wechselt der Kontext G2 vom Ausf√ºhrungsstatus in den Wartezustand, und der Kontext G1 wechselt vom Wartezustand in den Ausf√ºhrungsstatus und schlie√ülich zur√ºck in den Ausf√ºhrungsstatus, wodurch er eine neue Nachricht verarbeiten und zur√ºcksenden kann. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4db/97b/a31/4db97ba314fa8b14bf6497dcaf15135a.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Dinge an der Oberfl√§che scheinen nicht anders zu sein. Unabh√§ngig davon, ob Sie Streams oder Goroutinen verwenden, treten dieselben Kontext- und Status√§nderungen auf. Es gibt jedoch einen gro√üen Unterschied zwischen der Verwendung von Streams und Gorutin, der auf den ersten Blick nicht offensichtlich ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Goroutine verwendet wird, werden f√ºr die gesamte Verarbeitung dieselben Betriebssystem-Threads und derselbe Kernel verwendet. Dies bedeutet, dass OS Flow aus Betriebssystemsicht niemals in einen Wartezustand wechselt. nicht einmal. Infolgedessen gehen alle Anweisungen, die wir beim Wechseln von Kontexten bei der Verwendung von Streams verloren haben, bei der Verwendung von Goroutin nicht verloren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Wesentlichen verwandelte Go IO / Blocking-Arbeit in einen prozessorgebundenen Job auf Betriebssystemebene. Da alle Kontextwechsel auf Anwendungsebene stattfinden, verlieren wir beim Kontextwechsel nicht die gleichen ~ 12.000 Anweisungen (im Durchschnitt), die wir bei der Verwendung von Streams verloren haben. In Go kosten dieselben Kontextwechsel ~ 200 Nanosekunden oder ~ 2,4 Tausend Befehle. Der Scheduler hilft auch dabei, die Leistung von Caching-Strings und </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">NUMA</font></a><font style="vertical-align: inherit;"> zu verbessern</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Deshalb ben√∂tigen wir nicht mehr Threads als virtuelle Kerne. </font><font style="vertical-align: inherit;">Go kann im Laufe der Zeit mehr Arbeit leisten, da der Go-Scheduler versucht, weniger Threads zu verwenden und mehr f√ºr jeden Thread zu tun, wodurch die Belastung des Betriebssystems und der Hardware verringert wird.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Go Scheduler ist wirklich erstaunlich, wie er die Feinheiten des Betriebssystems und der Hardware ber√ºcksichtigt. Durch die M√∂glichkeit, E / A / Lock-Vorg√§nge auf Betriebssystemebene in prozessorgebundene Vorg√§nge umzuwandeln, k√∂nnen wir mit der Zeit mehr Prozessorleistung erzielen. Aus diesem Grund ben√∂tigen Sie nicht mehr Betriebssystem-Threads als virtuelle Kernel. Sie k√∂nnen davon ausgehen, dass Ihre gesamte Arbeit (mit CPU-Bindung und E / A / Sperren) mit einem Betriebssystem-Thread pro virtuellem Kernel ausgef√ºhrt wird. Dies ist f√ºr Netzwerkanwendungen und andere Anwendungen m√∂glich, die keine Systemaufrufe ben√∂tigen, die Betriebssystem-Threads blockieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Entwickler sollten Sie immer noch verstehen, was Ihre Anwendung in Bezug auf die Art der Arbeit tut. </font><font style="vertical-align: inherit;">Sie k√∂nnen nicht eine unbegrenzte Anzahl von Goroutinen erstellen und eine erstaunliche Leistung erwarten. </font><font style="vertical-align: inherit;">Weniger ist immer mehr, aber mit einem Verst√§ndnis dieser Semantik des Go-Schedulers k√∂nnen Sie bessere technische Entscheidungen treffen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de489852/index.html">Transparente Authentifizierung in ASP.Net Core unter Linux</a></li>
<li><a href="../de489854/index.html">Redux vs MobX ohne Verwirrung</a></li>
<li><a href="../de489856/index.html">Banach-Tarski-Umkehrparadoxon oder wie man das gespeicherte Datenvolumen um das F√ºnffache reduziert</a></li>
<li><a href="../de489858/index.html">Internationalisierung: Das Web f√ºr alle zug√§nglich machen</a></li>
<li><a href="../de489860/index.html">Die Geschichte von Telefunken: der Ph√∂nix der deutschen Elektronik von Wilhelm II. Und Goebbels bis zu den Beatles und heute</a></li>
<li><a href="../de489868/index.html">Einfrieren von Mozilla WebThings</a></li>
<li><a href="../de489870/index.html">Kostenlos offline intensiv von Node.js in Nischni Nowgorod</a></li>
<li><a href="../de489872/index.html">Wie das DLP-System und das OCR-Modul Mitarbeiter daran hinderten, Pass-Scans zu f√§lschen</a></li>
<li><a href="../de489874/index.html">Cross-Kompilieren von ausf√ºhrbaren Rust for Windows-Dateien unter Linux</a></li>
<li><a href="../de489876/index.html">Wie wir das Problem der drei Monolithen gel√∂st haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>