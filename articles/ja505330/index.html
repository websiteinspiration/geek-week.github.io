<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍✈️ 🧕🏼 🌉 3年間でゼロから暗号通貨を作成しない方法 🧗 🏑 👩🏽‍🤝‍👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事では、私が暗号通貨を最初から単独でどのように記述したか、そこから学んだ興味深いテクノロジー、私が残した経験とその後に何が起こったかについて説明します。これはチュートリアルではなく、単にイベントの説明ですが、必要に応じて、何がどのような理由でいくつかの記事を書くことができますが、誰かがこれを必...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>3年間でゼロから暗号通貨を作成しない方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505330/"><img src="https://habrastorage.org/webt/p5/vm/p3/p5vmp3vpw1waurtqnk8ccsaqmgc.jpeg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、私が暗号通貨を最初から単独でどのように記述したか、そこから学んだ興味深いテクノロジー、私が残した経験とその後に何が起こったかについて説明します。</font><font style="vertical-align: inherit;">これはチュートリアルではなく、単にイベントの説明ですが、必要に応じて、何がどのような理由でいくつかの記事を書くことができますが、誰かがこれを必要としているかどうかはわかりません。</font><font style="vertical-align: inherit;">記事の最後に、3年間の作成の後に私が思いついた結論があります。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
みなさん、こんにちは。私は長い間ここに何も書いていない。</font><font style="vertical-align: inherit;">プロローグボットに関する私の最後の投稿は多かれ少なかれ成功しており、聴衆はそれを気に入っていました。</font><font style="vertical-align: inherit;">私はあらゆる種類の奇妙な事業に従事するのが好きなので、何かしたかったのです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ちょっとした歴史</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、2017年の夏に、ブロックチェーンと暗号通貨について読み始めました。そのため、私から学ぶ方法は実際に最もよく得られます-私は自分の暗号通貨を書くことにしました。</font><font style="vertical-align: inherit;">実際、目標は単に研究することではなく、1つの単純な考えから始まりました-ブロックチェーン-レジストリ、そしてデータベースです。</font><font style="vertical-align: inherit;">では、なぜ財務データのみがブロックチェーンに保存されるのか-任意のデータを保存しないのはなぜですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの考えを念頭に置いて、私はビットコインブロックチェーンの研究を開始し、4か月で計算（そしてもちろん自転車）を使ってそれをnodejsで完全に繰り返しました。 2017年10月までに、非常に曲がったコードを含むワーキングドラフトがありました。これは保守が困難でした。文字どおり11月に、別のSPVクライアントを作成し、ライトクライアントサポートをネットワークに追加しました。さらに、マイニングプール（最初から実行しなかった唯一の部分）をやり直しました。しかし、完成したものを取り、それを完成させただけです）、rpcメソッドを介してローカルノードと通信するブロックエクスプローラーを作成および設計しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
III ...私の制御の及ばない出来事があり、その後の開発（そして場合によってはローンチ）を無期限に延期しました（19年目まで、後で判明しました）。 17番目の暗号通貨の秋と冬のどこかで突然、その価格の上限に行くことを決めたことを思い出させてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定のアイデアとインフラストラクチャを備えた仮想通貨が機能していて、誰もが絶対にすべての仮想通貨が最大値を示し、仮想通貨を起動できる（レンガで提供されたトークンも含む）瞬間を逃したという事実-鉱山に少しがっかりした明るい計画が、私は絶望していませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その時点では開発を続けることができませんでしたが、上位10の暗号通貨を検討する時間がありました。そのため、電文チャネルを作成し、当時トップ10にあった主要な暗号通貨を技術面から分析しました。ちなみに、乱暴にしたい場合-ここにこれらの記事を「移植」できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が開発に戻ったときのこの将来の分析-モデルを改善し、将来の暗号通貨のアーキテクチャについてより詳細に考えることができました。</font><font style="vertical-align: inherit;">2019年、私は開発に戻り、ゼロから始めました。</font><font style="vertical-align: inherit;">将来のアーキテクチャをより詳細に検討し、コード内の相互参照を取り除き、冗長モジュールを削除し、一部のモジュールを個別のnpmパッケージに転送し、最近、暗号通貨を収集しました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">細部</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはプロジェクトではなく、単なる役に立たないコードのセットであるとすぐに言っておかなければならないので、githubへのリンクと名前の表示が禁止されないことを願っています。 </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暗号通貨</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の比較的成功した実験の後、私はより大胆になり、次のプロジェクトは最初のプロトタイプよりもコードの点でより美しくあるべきだと決めました。</font><font style="vertical-align: inherit;">さらに、必要に応じてモジュールを接続および切断できるように、システムをフレームワークの形でモジュール化することにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、技術用語で暗号通貨を書くことは、要するにそれほど難しい作業ではありません：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロックとインデックスのためのデータベースを構築する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノード間でメッセージを交換するためのプロトコルを編成する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データのシリアル化形式とトランザクション署名アルゴリズムを定義する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンセンサスを定義し、追加と検証のためのルールを設定する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプションのrpcサーバー</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、コンソールクライアントを構成し、ジェネシスブロックを生成してバリデーターをセットアップすることで実行を試みます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たくさんの修正されたエラーと不正確さの後-あなたは暗号通貨を動かしています、おめでとうございます</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、基にならない機能を追加する段階があります。</font><font style="vertical-align: inherit;">たとえば、私はこのデータスクリプト、プロジェクトの基礎を持っています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データスクリプト</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が4か月間書いたプロジェクトは、orwellと呼ばれ、ビットコインのフォークですが、各トランザクションには、財務情報に加えて、HEX形式の追加データが含まれていることも前提としています（トランザクションが有効でブロックに該当する場合）。このデータを復号化して通常のデータベースに変換するVM。</font><font style="vertical-align: inherit;">このVMにorwelldbという名前を付けました。形式はdatascript、復号化の例です</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。</font></font><br>
<br>
<code>ef01fd4f01190b6578616d706c6564617461fd3f0154fd3b011f000f0fa1067e45f40003f1096f776e65725f6b65798230343233633635653064373364626161386537393435633965663135626338366533643864396638636364323636626366323362623032646336333432386636623239343766336164643731636536333962653739646561333933313237613061336661623136613339306630326537363966633135373561333535333130323461f30a70726976696c6567657301f1008230346231363165656566623739363163366637306137643338666434373764616633333437643231346561663365313639643964316434336232346437323338383665343063643962633563633232393638333635656531663962653635333932303539383630643735656432356136303836653830666462653138336565613364f20b7772697465536372697074fdb815</code> <br>
<br>
<pre><code class="json hljs">[<font></font>
{<font></font>
   <span class="hljs-attr">"dataset"</span>: <span class="hljs-string">"exampledata"</span>,
   <span class="hljs-attr">"operator"</span>: <span class="hljs-string">"create"</span>,
   <span class="hljs-attr">"content"</span>: {
    <span class="hljs-attr">"owner_key"</span>: <span class="hljs-string">"0423c65e0d73dbaa8e7945c9ef15bc86e3d8d9f8ccd266bcf23bb02dc63428f6b2947f3add71ce639be79dea393127a0a3fab16a390f02e769fc1575a35531024a"</span>,
    <span class="hljs-attr">"privileges"</span>: [
<span class="hljs-string">"04b161eeefb7961c6f70a7d38fd477daf3347d214eaf3e169d9d1d43b24d723886e40cd9bc5cc22968365ee1f9be65392059860d75ed25a6086e80fdbe183eea3d"</span><font></font>
    ],<font></font>
    <span class="hljs-attr">"writeScript"</span>: <span class="hljs-number">5560</span><font></font>
   },<font></font>
   <span class="hljs-attr">"canRead"</span>: <span class="hljs-literal">true</span>,
   <span class="hljs-attr">"success"</span>: <span class="hljs-literal">true</span><font></font>
  }<font></font>
]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内容について少しお話します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データスクリプトには、特定のデータベースとそのデータセットへの呼び出しの配列が含まれます。この場合、トランザクションは新しいデータセット（つまり、リレーショナルデータベースの場合はテーブル）の作成を記述します。これは、「演算子」フィールドの内容から続きます。作成に加えて、「書き込み」と「設定」も可能です。それぞれデータの追加（または変更）とデータセットパラメータの更新です。 「コンテンツ」は、データセットに書き込まれる単なるデータです。この場合、テーブルを作成するため、内容はoperator = settings-table settingsで記述されたものと同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで書かれていることを正確に説明するには、データスクリプトの概念に目を向ける必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの目的のために作成された2017年の図を示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/jd/_7/njjd_72nro0czhi3e_4bbhkbrv4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データスクリプトには、ビットコインとそのロックおよびロック解除スクリプトと同様に、readおよびwriteScriptが含まれています。最初のスクリプトは誰がメッセージを読み取ることができるかを決定し、2番目は特定のデータセットに書き込むことができるユーザーを決定します。</font><font style="vertical-align: inherit;">スクリプトはスタック指向の言語です。</font><font style="vertical-align: inherit;">Readscriptはメッセージ自体に書き込まれ、メッセージを読むことができる人を示します。</font><font style="vertical-align: inherit;">これは暗号化を使用して実装されます。</font><font style="vertical-align: inherit;">暗号化を指定する場合、キーストアに必要なキーを持っている人だけが読み取ることができます。それ以外の場合は、必要な人が読み取ることができます。</font><font style="vertical-align: inherit;">create / settingsステートメントを含むメッセージは暗号化しないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開いているreadScriptの例（誰でも読むことができます）：</font></font><br>
<br>
<pre><code class="plaintext hljs">DATA_HEXJSON + jsonhexbytes <font></font>
 DATA_HEXJSON  = 0x54</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暗号化：</font></font><br>
<br>
<pre><code class="plaintext hljs">DATA_HEXJSONENCRYPTED + var_str(encrypted data) + PUSHDATA_DBREADPRIVATEKEY + uint8(encryption) + OP_DECRYPT + OP_HASH256 + DATA_HASH + char[32](hash) + OP_EQUAL</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生の形で： </font></font><br>
<br>
<pre><code class="plaintext hljs">0x53 + var_str + 0x56 + (0x1 or 0x2) + 0x57 + 0x59 + 0x58 + char[32] + 0x87</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
復号化されたデータのハッシュ検証を伴うデータ復号化テスト。 </font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">誰か興味があれば、プロトコルのドキュメントですべてを詳しく説明しました：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github：datascript docs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、コードで指定されたjsonhexは、jsonをバイナリ形式に変換するための私の実装です。</font><font style="vertical-align: inherit;">通常のjsonをそのままにしておくことができるようですが、統一性を求めていたため、別のプロトコルを開発しました。</font><font style="vertical-align: inherit;">彼について読みたい場合は、ドキュメント：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github：bitowlを参照してください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Writescriptはデータセット設定に登録されており、この例では0x5560です。</font><font style="vertical-align: inherit;">この場合、それは言う：</font></font><br>
<br>
<pre><code class="plaintext hljs">PUSHDATA_DBWRITEPUBLICKEY  OP_CHECKDBPRIVILEGES</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それら。</font><font style="vertical-align: inherit;">メッセージの送信者の公開鍵をスタックに送信し、このデータセットの権限のリストを確認します。</font><font style="vertical-align: inherit;">このキーが特権のリストにある場合（作成メッセージの送信者またはowner_keyのいずれか）、彼は書き込むことができます。</font><font style="vertical-align: inherit;">また、writescriptが空の場合は、ALLを意味します。</font><font style="vertical-align: inherit;">誰でもこのデータセットに書き込むことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
operator =設定の場合、すべてが同じに見え、コンテンツ内の設定のみが変更されます。</font><font style="vertical-align: inherit;">書き込みの場合-コンテンツには実際のデータが含まれます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロックチェーンについて少し</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、データベースについてはどうでしょうか。私の場合、ハッキングを行いました-トランザクションにデータスクリプトのコンテンツが含まれている場合-このトランザクションの最初の出力は常にゼロであり、このデータスクリプトはそれに送信されます。ネットワーク上のすべてのアドレスはデータベースです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このモデルでは、データをブロックチェーン自体の内部に格納できます。これにより、ある程度の柔軟性が得られますが、同時にビットコインブロックチェーンはすでに約500ギガバイトに成長しており、これは財務データのみであるため、ストレージの問題が追加されます。ここに任意のものも追加すると、冗長になります。したがって、ストレージは、認証のためにあらゆる種類のキーと接続に制限されていました。ちなみに、すべてのルールは作成時にVMレベルで検証されますが、ブロックチェーンと同期する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、システムデータベースにドメイン、マスターノード、トークン、dappのシステムデータセットをいくつか作成しました。これにより、アドレス/データベースごとにドメインを作成し、あいまいな文字のセットではなく、便利なニックネーム（たとえば）に加えて、ドメイン、設計上、dappsで使用できます（これについては後で説明します）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データセットトークンとマスターノードについては、最初のトークンには各参加者が作成できるユーザートークンが格納され、マスターノードにはネットワークバリデーターである参加者の公開鍵のリストが格納されます。</font><font style="vertical-align: inherit;">ここで少し余談が必要です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンセンサス </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロックチェーンの基本はコンセンサスです。ノード間での合意、ネットワーク上で動作する特定の一連のルール、およびそれらすべてがネットワークが動作可能であるために準拠します。たとえば、ビットコインのコンセンサスは、Proof of Work、つまりマイニングであり、私はきっとここで何度も書かれてきました。コンセンサスの本質は、ネットワーク参加者によって公開された新しいブロックをチェックすることです。ビットコインでは、ネットワーク参加者がランダムにブロックを公開します-最初のものを見つけた人は誰でも報酬を受け取ります。彼は最初、自分のネットワークで同じことをしましたが、後に1つのビットコインマイナーで私のネットワークを妨害し、51％の攻撃を加えるので十分であると合理的に判断しました。しばらくしてからコンセンサスモジュール</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">consensusjs</font></a><font style="vertical-align: inherit;">を実装しました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、いくつかの異なるコンセンサスを説明しました：集中型、PoW、PoS（PoW + PoS）、静的dpow、静的dos、動的dpos。とうとう立ち止まりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
動的デリゲートpos（ddpos）は、最初に、レーティングと使用中のコインの数でリストがソートされた特定の数のデリゲート（バリデーター）がある場合、リストの各バリデーターが厳密な順序でブロックを公開するラウンドが作成されると想定しています。ラウンドが終了すると、新しいラウンドが計算され、ネットワークの各メンバーは、ネットワークからのオープンデータに基づいて現在のラウンドと次のラウンドを個別に計算する機会があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、これにはmasternodeテーブルが必要です。その中には、バリデーターへの願望を表明したすべての人とその現在の評価が格納されています。</font><font style="vertical-align: inherit;">各ラウンドの最初に、このテーブルをソートして、結果としてN個のバリデーターでラウンドを作成します。</font><font style="vertical-align: inherit;">バリデーターの数がN未満の場合は、構成ファイルに記述されている標準のネットワークバリデーター（公開鍵）を使用してラウンドを作成します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">民主主義</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワーク内での投票の概念は、暗号通貨の古いバージョンで開発および実装されたものであり、投票したすべてのノードからネットワークから平均化されたデータを受け取ることができます。</font><font style="vertical-align: inherit;">新しいバージョンでは、別のモジュールを実装しましたが、統合できませんでした。</font><font style="vertical-align: inherit;">民主主義の助けを借りて、公平な投票によってネットワークパラメーターを変更し、ブロックのジェネシスをシフトすることで保存されたブロックチェーンのサイズを削減することができます（ジェネシスブロックは古いUTXOとその中にデータを配置することにより大きくなります）が、100万のブロックを同期することはできませんですが、たとえば最後の1000のみです。</font><font style="vertical-align: inherit;">さらに、投票はネットワークの分岐と変更を管理し、ネットワークに関連する組織の問題を解決することができます。</font><font style="vertical-align: inherit;">確かに、上で書いたように、このモジュールを実装することはできませんでしたが、アイデアは残っていました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapps</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dappsのコンセプトは、18世紀初頭のビットコインのピークの少し後で発明されました。次に、アプリケーション（公開キー）をブロックチェーンに登録し、ワーカー（公開キー）をシステムテーブルに登録し、ワーカーとアプリケーションとの通信を行うことでそれを実現するというアイデアがあり、ワーカーはすでに独自の独立したブロックチェーンで作業していました。この概念にはまだ視聴者がいます。クライアントと通信するためのインターフェースを備えたアプリケーションの一部であり、ブラウザと個別のアプリケーションの両方がビューアとして機能できます。後で実装するのに長い時間がかかって少し簡単になったので、後でこのアイデアを拒否しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロックチェーンにdAppを登録してドメインに関連付けることもでき、アプリケーションの公開鍵に関連付けられているドメインを知っている参加者は、このアプリケーションと対話できます。</font><font style="vertical-align: inherit;">ドメインにアクセスすると、ネットワーククライアントの透過DNSサーバーがユーザーのリクエストを読み取り、ecdh暗号化を使用して暗号化します。これにより、アプリケーションの公開鍵を持つ参加者だけがコンテンツを読み取ってネットワークに送信できます。</font><font style="vertical-align: inherit;">アプリケーションはこの要求を受信し、このアプリケーションの構成で指定されたエンドポイントに送信し、暗号化された結果をネットワークに返します。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ちなみに、面白い事実：ノードはecdh暗号化を使用して相互に通信し、dAppは暗号化されたデータを送受信するため、ノード間の転送時に、メッセージの一部が2回暗号化されます。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法を使用すると、暗号化されたネットワークが取得され、各参加者は（だけでなく）サイトを作成できます。各参加者は自分の「サイトを参照」する独自の公開鍵を含み、IPアドレスは要求と回答から切り取られるため、トラフィックの制御が容易になります。ネットワークを匿名にします。</font><font style="vertical-align: inherit;">したがって、最初は認証があり、ユーザーの残高、トークンの残高（サイトに関連付けられているなど）を確認して、サイトとネットワークを離れることなく支払いプロセスを完了することもできます。</font><font style="vertical-align: inherit;">テスト時の唯一の欠点はパフォーマンスでした。この形式では、サイトは分散ネットワーク経由で送信されるため、サイトの読み込みが10倍遅くなります。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記のメカニズムは単なる概念ですが、すでに半分は実装されています。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スポイラーの下で、これを実装するコード（github）へのリンクをプッシュしました。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生のdappコード</font></font></b>
                        <div class="spoiler_text"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">https://github.com/gettocat/friday/blob/master/node/modules/dapps/index.js</a><br>
</div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今どこから始めますか</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 最後に、現在の知識で最初からやり直す必要がある場合に適用できるいくつかのトリックを書きたいと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モジュール式のアーキテクチャ-確実に、各モジュールが他のすべてのモジュールに最小限接続され、たとえばコンセンサスが変更された場合に交換できることを確認するためだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モジュールの分離は、本質的に前の段落の続きであり、すでに論理モジュールではなく、特に機能モジュールに関するものです。</font><font style="vertical-align: inherit;">たとえば、私のコードでは、コンセンサスは別のconsensusjsモジュールによって実装されます。これにより、ワーキングドラフトに実装する前に上下にテストできます。これは、いわゆるプリミティブ（トランザクション形式、ブロックとそのシリアル化/逆シリアル化）にも当てはまり、特定のモジュールの機能を最大でテストできます。メインコードに埋め込みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テスト-各モジュールをテストでカバーすることは、起動プロセス中の幸福と夜の通常の睡眠（自分でテスト）の基礎です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのバージョン-暗号通貨はクローズドシステムであるため、次に何が起こるか、どのようにサポートするかを事前に考える必要があります。</font><font style="vertical-align: inherit;">反対に、メインネットワークの意図しない分岐が発生する可能性があるため、まだ更新していないユーザーに影響を及ぼさないように、すべての参加者のバージョン間で機能を更新するモデルを検討する必要があります。</font><font style="vertical-align: inherit;">私のconsensusjsモジュールでは、フォークとブロックの有効なバージョンを決定する機能が実装されていますが、メインコードにはまだ追加していません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が約束したように、記事の最後に結果のいくつかを要約します。この投稿は、自家製の暗号通貨の歴史のポイントと考えることができます。一方で、これは本番環境用ではないことを理解しました。より機密性の高いコード制御、テストカバレッジなど、本番プロジェクトのほか、複数のプログラマが必要です。そして、ファイナンス、ファイナンス、ファイナンス。それなしではどこにもありません。私はこれをすべて持っていないし、持っていなかったので、試してみてテクノロジーを研究し、それが価値があるかどうかを確認することに興味があった。それは価値があった。作業が終わった後、プログラミングやテクノロジーの多くの側面を理解し始め（たとえば、バイトシーケンスの処理に本当に進んでいます）、それに基づいてブロックチェーンとテクノロジーを確実に研究しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、Ethereumがトランザクションデータとこのデータを処理する仮想マシンで同様のコンセプトを使用していることは確かですが、Ethereumだけが関数としてデータを使用し（簡単な方法の場合）、それらにアクセスします（契約の作成を除く）。ビットコインの内部スクリプト（スタック言語）はかなり強力であることは確かですが、Satoshiは、「スマートコントラクト」の概念が登場するずっと前から、それらに基づいたスマートコントラクトの作成を示唆していましたが、これらのスクリプトの使用はビットコインでは削減されています。以前に知られていない可能性のあるバグ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3年間の研究の後に私が気に入ったテクノロジーについて話すと、これは間違いなくコンセンサスです。ネットワーク参加者間の合意とメッセージ検証の一般的なルール。ブルームフィルターはかなり興味深いものです。これにより、フィルターを別の参加者に送信して、詳細を明らかにせずに送信されているデータをフィルターすることができます。これにより、必要なデータの種類を明らかにせずにデータを取得できます。データストレージ構造としてのマークルツリー、ビットコインのライトノードの基礎、および状態ツリー（3つあります）イーサリアム。 PoWは非常に単純ですが、同時に、「誰もが、通常の比率で計算された、最後のNブロックの合計平均複雑度よりも少ない数を探している」という非常に洗練されたアイデアです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短所に関しては、それらもたくさんあります。これらの最初は人件費です。時間が経つにつれ、私はこのアイデアに燃え尽きましたが、それが約3年間私を魅了しました。たとえば、今、暗号通貨は起動されているように見え、それを起動するためにすでに何も保持していないように見えますが、5,000ブロック後に、なんらかの理由でブロックのカウントがゼロから開始するという事実で奇妙なバグが発生しました（インデックスはなんとかクラッシュしているようです） 、時間も欲望もないものを探すこと。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多分いつか私はこの考えに戻るか、それに似ています（またはそれに基づいて）。</font><font style="vertical-align: inherit;">必要に応じて、コードを調べたり、私のgithubで金曜日のプロジェクトをフォークしたりできます。すべてのコードはMITライセンスの下にあります。</font><font style="vertical-align: inherit;">間違いなく私はこの方向で作業を停止しません。分散化されたテクノロジーは非常に面倒ですが、非常に興味深いからです。</font><font style="vertical-align: inherit;">質問/提案または説明がある場合は、PMで待機しています。</font><font style="vertical-align: inherit;">あなたが突然必要になった場合、私はそれを理解するのに役立ちます。</font><font style="vertical-align: inherit;">以下で調査を整理します-ここでこのトピックについて書くことは他に価値がありますが、評価自体ですべてが整います。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja505302/index.html">回路設計の10のヒント</a></li>
<li><a href="../ja505306/index.html">ゲームからeコマースプロジェクトまで。テクノパークの2年間のプログラムを変える</a></li>
<li><a href="../ja505310/index.html">技術的に進歩した企業を区別するものと、テクライドがチームの成長にどのように役立つか</a></li>
<li><a href="../ja505314/index.html">Linuxの時刻同期：NTP、Chrony、およびsystemd-timesyncd</a></li>
<li><a href="../ja505322/index.html">未来のディスパッチャー：サービス会社における彼の役割はどのように変化しますか？</a></li>
<li><a href="../ja505336/index.html">方法：マネまたはモネ？ニューラルネットワークが応答する</a></li>
<li><a href="../ja505340/index.html">ウォルマートの従業員は、盗難防止AIが機能しないことを証明しようとします</a></li>
<li><a href="../ja505342/index.html">依存関係の注入と依存関係の逆転の原則は同一ではありません</a></li>
<li><a href="../ja505362/index.html">Vite-Vueにバンドルなしで開発をリード</a></li>
<li><a href="../ja505378/index.html">このすべてのマーケティング：IT企業の窓口と連携する方法？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>