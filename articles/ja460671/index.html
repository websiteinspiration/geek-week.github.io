<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽 👩🏻‍🌾 🏇🏿 Dでの所有権と借用 🏹 🐶 🦅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ほとんどすべての重要なプログラムが動的メモリを割り当てて使用します。プログラムがより複雑になり、エラーがさらに高価になるため、正しく実行することがますます重要になっています。
 
 一般的な問題は次のとおりです。
 
 

1. メモリリーク（使用済みメモリを解放しない） 
2. ダブルリリース（メ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Dでの所有権と借用</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460671/"><img src="https://habrastorage.org/webt/gp/qe/oo/gpqeookkvehf2hdsowdegomcqai.png" align="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどすべての重要なプログラムが動的メモリを割り当てて使用します。</font><font style="vertical-align: inherit;">プログラムがより複雑になり、エラーがさらに高価になるため、正しく実行することがますます重要になっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的な問題は次のとおりです。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリリーク（使用済みメモリを解放しない） </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダブルリリース（メモリリリースを複数回） </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リリース後の使用（以前に解放されたメモリへのポインタの使用） </font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
課題は、メモリの解放に関与するポインタ（つまり、メモリを所有するポインタ）を追跡し、メモリの一部を単に指すポインタを区別し、それらがどこにあり、どれがアクティブ（スコープ内）であるかを制御することです。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的な解決策は次のとおりです。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガベージコレクション（GC）-GCはメモリブロックを所有し、これらのブロックへのポインターを定期的にスキャンします。</font><font style="vertical-align: inherit;">ポインタが見つからない場合は、メモリが解放されます。</font><font style="vertical-align: inherit;">このスキームは信頼性が高く、GoやJavaなどの言語で使用されています。</font><font style="vertical-align: inherit;">しかし、GCは必要以上に多くのメモリを使用する傾向があり、再パッケージ（元の挿入された書き込みゲート）のために一時停止があり、コードが遅くなります。</font></font></li>
<li>  (Reference Counting, RC) – RC         .      ,  .          C++  ObjectiveC. RC   ,      .   RC      ,       ,  ,       .   ,   ,    RC    ,     .</li>
<li>  –      malloc  free.       ,        ,       .   malloc  free  35 ,          .     ,      ,      «»,   «».</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソリューション2と3は、プログラマがすべてを正しく実行するという信念に依存しています。信仰に基づくシステムは適切にスケーリングされず、メモリ管理エラーは再チェックが非常に困難であることが証明されています（コーディング基準によっては動的メモリの使用が禁止されているほど悪い）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、4つ目の方法もあります-所有権と借用、OB。メモリー効率がよく、手動操作と同じくらい高速で、自動再検査の対象となります。この方法は、Rustプログラミング言語によって最近普及しました。また、特にアルゴリズムとデータ構造の計画を再考する必要があるという欠点もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネガティブな側面にも対処できます。この記事の残りの部分は、OBシステムのしくみと、それをD言語で記述することを提案する方法の概略図です。私は最初はこれを不可能だと考えていましたが、かなりの時間をかけて考えて、方法を見つけました。</font><font style="vertical-align: inherit;">これは、関数型プログラミングで行ったものに似ています-推移的不変性と「純粋な」関数です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所持</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリ内のオブジェクトを誰が所有するかの決定は、途方もなく単純です。オブジェクトへの単一のポインタがあり、それが所有者です。</font><font style="vertical-align: inherit;">彼は記憶の解放も担当し、その後それは無効になります。</font><font style="vertical-align: inherit;">メモリ内のオブジェクトへのポインタが所有者であるという事実により、このデータ構造内には他のポインタはないため、データ構造はツリーを形成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の結果は、ポインターがコピーではなく移動のセマンティクスを使用することです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">T* <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T*)</span></span>;<font></font>
T* p = f();<font></font>
T* q = p; <span class="hljs-comment">//  p   q,   </span>
g(p);     <span class="hljs-comment">// , p  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ構造内からポインタを削除することは禁止されています：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> {</span> T* p; }
<span class="hljs-function">S* <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<font></font>
S* s = f();<font></font>
T* q = s.p; <span class="hljs-comment">// ,      s.p</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜspを無効としてマークしないのですか？</font><font style="vertical-align: inherit;">問題は、実行時にラベルを設定する必要があることですが、単にコンパイルエラーと見なされるため、コンパイル段階で解決する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スコープ外の自身のポインタの終了もエラーです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span>{<font></font>
  T* p = f();<font></font>
} <span class="hljs-comment">// ,   p?</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポインタ値を別の方法で移動する必要があります。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T*)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span>{<font></font>
  T* p = f();<font></font>
  g(p);  <span class="hljs-comment">//   g(),    g()</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、メモリリークと解放後の使用の問題が解決されます（ヒント：明確にするために、f（）をmalloc（）に、g（）をfree（）に置き換えてください）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはすべて</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、データフロー分析</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手法を使用してコンパイル時にチェックできます</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">（データフロー分析（DFA）</font></a><font style="vertical-align: inherit;">は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的な部分式</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">削除するために</font></a><font style="vertical-align: inherit;">使用されるものとほぼ同じです</font><font style="vertical-align: inherit;">。DFAは、発生する可能性のあるプログラム遷移からラットのもつれをほどくことができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">借用</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の在職期間制度は信頼できますが、制限が厳しすぎます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検討してください：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> {</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">car</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span>; }
<span class="hljs-function">struct S* <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<font></font>
S* s = f();<font></font>
s.car();  <span class="hljs-comment">// s   car()</span>
s.bar();  <span class="hljs-comment">// , s </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを機能させるには、s.car（）に、終了時にポインターを戻す方法が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが借り方です。 s.car（）は、s.car（）の間、sのコピーを取ります。 sは実行時には無効であり、s.car（）が終了すると再び有効になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dでは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造体</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メンバー関数</font><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインター</font><font style="vertical-align: inherit;">を参照によって</font><font style="vertical-align: inherit;">取得</font><font style="vertical-align: inherit;">するため、借用を小さな拡張で適合させることができます。参照によって引数を取得すると、それを受け取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dはポインターのスコープもサポートしているため、借用は自然です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">(scope T*)</span></span>;
<span class="hljs-function">T* <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<font></font>
T* p = f();<font></font>
g(p);      <span class="hljs-comment">// g()  p</span>
g(p);      <span class="hljs-comment">//    p     g()</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（関数が参照によって引数を受け取るか、スコープ付きのポインターが使用されている場合、関数またはスコープの境界を超えて拡張することは禁止されています。これは借用のセマンティクスに対応します。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法で借用すると、メモリ内のオブジェクトへのポインターの一意性が常に保証されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトが複数の定数ポインター（ただし、変更可能なポインターは1つだけ）によってさらに示されている場合でも、所有権システムも信頼できることを理解すれば、借用をさらに拡張できます。</font><font style="vertical-align: inherit;">定数ポインタはメモリを変更したり解放したりすることはできません。</font><font style="vertical-align: inherit;">これは、いくつかの定数ポインターを変更可能な所有者から借用できることを意味しますが、これらの定数ポインターが生きている間、彼には使用する権利がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例えば：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">T* <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T*)</span></span>;<font></font>
T* p = f();  <span class="hljs-comment">// p  </span><font></font>
{<font></font>
  scope <span class="hljs-keyword">const</span> T* q = p; <span class="hljs-comment">//   </span>
  scope <span class="hljs-keyword">const</span> T* r = p; <span class="hljs-comment">//   </span>
  g(p); <span class="hljs-comment">// , p   q  r   </span><font></font>
}<font></font>
g(p); <span class="hljs-comment">// ok</span></code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原則</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記は、メモリ内のオブジェクトが2つの状態の1つであるかのように動作するという次の理解に還元できます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それにただ1つの変更可能なポインタがあります</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つ以上の追加の定数ポインター</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意深い読者は、私が書いたものに「まるで」のような奇妙なことに気付くでしょう。</font><font style="vertical-align: inherit;">何をヒントにしたかったの？</font><font style="vertical-align: inherit;">何が起こっている？</font><font style="vertical-align: inherit;">はい、あります。</font><font style="vertical-align: inherit;">コンピュータープログラミング言語は、内部では「まるで」のようにいっぱいで、銀行口座のお金のようなものは実際にはそこにありません（これは誰かに大きなショックであったとすれば申し訳ありません）。これはそれと同じです。</font><font style="vertical-align: inherit;">読む！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、最初に、このトピックについてもう少し詳しく説明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有権の統合/ Dでのテクニックの借用</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのテクニックは、人々が通常Dで書く方法と互換性がなく、ほとんどすべての既存のDプログラムが壊れるでしょうか？そして、修正はそれほど簡単ではありませんが、すべてのアルゴリズムをゼロから再設計する必要があるほどです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、そうです。 Dが（ほとんど）秘密の武器を除いて：関数の属性。所有権/借用（OB）のセマンティクスは、通常のセマンティック分析の後で、各機能に個別に実装できることがわかります。注意深い読者は、新しい構文が追加されておらず、既存のコードに制限が課されているだけであることに気付くでしょう。 Dには、関数属性を使用してセマンティクスを変更する履歴があります。たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">純粋な</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性</font><font style="vertical-align: inherit;">を使用して「純粋な」関数を作成します。 OBセマンティクスを有効にするために、@ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">live</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性が追加されてい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、必要に応じてOBをDのコードに徐々に追加し、リソースを解放できることを意味します。</font><font style="vertical-align: inherit;">これにより、OBを追加することが可能になります。これは重要であり、完全に機能し、テストされ、リリースの準備ができた状態でプロジェクトを常にサポートします。</font><font style="vertical-align: inherit;">また、プロジェクトの何パーセントがすでにOBに転送されたかを監視するプロセスを自動化することもできます。</font><font style="vertical-align: inherit;">この手法は、メモリでの作業の信頼性（スタック上の一時変数へのポインタの非分散の制御など）に関する他のD言語保証のリストに追加されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">かのように</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
参照カウントオブジェクトなど、いくつかの必要なものは、OBに厳密に準拠して実装することはできません。結局のところ、RCオブジェクトはそれらへの多くのポインタを持つように設計されています。メモリを操作する場合（正しく実装されている場合）、RCオブジェクトは安全であるため、信頼性に悪影響を与えることなく、OBと一緒に使用できます。 OBテクニックを使用して作成することはできません。解決策は、Dに他の関数属性、たとえば@systemがあること</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 @ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システム</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、多くの信頼性チェックが無効になっている機能です。当然のことながら、OBもの@付きコードに無効になります</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システム</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、RCテクノロジの実装がOBコントロールから隠されている場所です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、OB、RCを含むコードでは、オブジェクトはすべてのルールに従っているかのように見えるため、問題ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OBを正常に使用するには、このようなライブラリタイプがいくつか必要になります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、OBテクノロジーの基本的な概要です。</font><font style="vertical-align: inherit;">より詳細な仕様に取り組んでいます。</font><font style="vertical-align: inherit;">何か、どこかで喫水線の下の穴を逃した可能性がありますが、これまでのところすべてがよさそうです。</font><font style="vertical-align: inherit;">これはDにとって非常にエキサイティングな開発であり、実装を楽しみにしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Walterからのさらなる議論とコメントについては、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ r / programming subreddit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacker News</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に関するトピックを参照してください</font><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja460659/index.html">パイプを使用したピボット</a></li>
<li><a href="../ja460661/index.html">Node.jsについて知っておくべきこと</a></li>
<li><a href="../ja460665/index.html">ドラフトFAQ：C ++標準が3年ごとに出てくるのはなぜですか？</a></li>
<li><a href="../ja460667/index.html">iOSでの有料サービスのテストの自動化</a></li>
<li><a href="../ja460669/index.html">開発の安全を確保し、時間と神経を節約する方法</a></li>
<li><a href="../ja460673/index.html">DiffUtilの魔法を明らかにする</a></li>
<li><a href="../ja460675/index.html">機械学習データの抽出</a></li>
<li><a href="../ja460683/index.html">Laravelイベントプロジェクターとイベント生成の概念</a></li>
<li><a href="../ja460685/index.html">nginxを使用してGoogleドライブからファイルを配布します</a></li>
<li><a href="../ja460687/index.html">缶が内側からどのように見えるか</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>