<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖱️ 🎥 🍁 STM32F103の3Dグラフィック 🦗 🧀 🚵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="このための速度もメモリもないコントローラーを使用して、編集不可でリアルタイムの3次元グラフィックスを表示する方法についての短編小説。
 
 2017年に（ファイルの変更日で判断して）、AVRコントローラーからより強力なSTM32に切り替えることにしました。当然、最初のコントローラーは広く知られている...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>STM32F103の3Dグラフィック</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496046/"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/cf8/e1c/7e5cf8e1c0fbc2ee47c87c71d72e865f.jpg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このための速度もメモリもないコントローラーを使用して、編集不可でリアルタイムの3次元グラフィックスを表示する方法についての短編小説。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2017年に（ファイルの変更日で判断して）、AVRコントローラーからより強力なSTM32に切り替えることにしました。当然、最初のコントローラーは広く知られているF103でした。既成のデバッグボードの使用が拒否され、要件に応じてゼロから製造することは当然のことです。奇妙なことに、側枠はほとんどありませんでした（ただし、UART1を通常のコネクタに接続する必要があり、配線を押しつぶさないでください）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVRと比較して、石の特性はかなりまともです：72 MHzクロック（実際には、100 MHz以上にオーバークロックできますが、自分の危険とリスクがある場合のみ！）、20 kBのRAM、64 kBのフラッシュ。さらに、大量のペリフェラルを使用する場合、この問題を恐れずに使用し、10個すべてのレジスタをシャベルで開始する必要がないことに気づいた場合、正しいレジスタに3ビットを設定するだけで十分です。少なくとも何か奇妙なものが欲しくなるまで。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような力の所有からの最初の陶酔が過ぎたとき、その限界を調査したいという欲求が生じました。効果的な例として、これらすべてのマトリックス、照明、ポリゴンモデル、およびili9341コントローラー上の320x240ディスプレイを備えたZバッファーを使用して、3次元グラフィックスの計算を選択しました。解決すべき最も明白な2つの問題は、速度とボリュームです。画面サイズ320x240、色あたり16ビットで、フレームあたり150 kBになります。しかし、RAMの合計はわずか20 kBです...そしてこれらの150 kBは、少なくとも毎秒10回ディスプレイに転送する必要があります。つまり、交換レートは少なくとも1.5 MB /秒または12 MB /秒である必要があり、すでにコアに大きな負荷がかかっているようです。幸いなことに、このコントローラーにはRAPモジュール（ダイレクトメモリアクセス、ダイレクトメモリアクセス、DMA）があり、輸血操作でカーネルを空から空にロードできないようになっています。つまり、バッファを準備し、モジュールに「ここにデータバッファがあります、動かせます！」と伝え、この時点で次の転送のためにデータを準備します。ストリームでデータを受信するディスプレイの機能を考慮すると、次のアルゴリズムが出現します：フロントバッファーが強調表示され、そこからDMAがディスプレイにデータを転送し、レンダリングが実行されるリアバッファー、および深さを減らすために使用されるZバッファー。バッファは、表示の単一行（または列）です。そして、150 kBの代わりに、必要なのは1920バイト（ラインあたり320ピクセル* 3バッファー*ポイントあたり2バイト）だけであり、これはメモリに完全に適合します。 2番目のハックは、変換行列と頂点座標の計算が行ごとに実行できないという事実に基づいています。そうしないと、画像が最も奇妙な方法で歪んでしまい、速度が低下します。代わりに、「外部」計算、つまり、変換行列の乗算と頂点への適用が各フレームで再計算され、中間表現に変換されます。これは、320x1の画像へのレンダリングに最適化されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フーリガンの理由から、ライブラリは外側からOpenGLに似ています。元のOpenGLの場合と同様に、レンダリングは変換マトリックスの形成から始まります。glLoadIdentity（）をクリアすると現在のマトリックスユニットが作成され、次に一連の変換glRotateXY（...）、glTranslate（...）がそれぞれ現在のマトリックスで乗算されます。これらの計算はフレームごとに1回だけ実行されるため、速度に関する特別な要件はありません。固定小数点数を使用した倒錯なしに、単純なフロートで実行できます。行列自体はfloatの配列[4] [4]であり、floatの1次元配列[16]にマップされます。実際、このメソッドは通常、動的配列に使用されますが、静的配列からも少しメリットがあります。別の標準的なハック：回転行列に多く含まれる正弦と余弦を常に計算する代わりに、事前に数えて、タブレットに書きます。これを行うには、円全体を256の部分に分割し、それぞれの正弦値を計算して、それをsin_table []配列にダンプします。まあ、学校の誰もがサインからコサインを得ることができます。 [0 ... 255]の範囲に縮小した後、回転関数がラジアン単位ではなく、1回転の分数単位で角度をとることは注目に値します。ただし、フードの下で角度からローブへの変換を実行する「正直な」機能が実装されています。フードから角度からローブへの変換を実行します。フードから角度からローブへの変換を実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マトリックスの準備ができたら、プリミティブの描画を開始できます。一般に、3次元グラフィックスには、3種類のプリミティブ（点、線、三角形）があります。ただし、ポリゴンモデルに関心がある場合は、三角形のみに注意を払う必要があります。その「レンダリング」は、関数glDrawTriangle（）またはglDrawTriangleV（）で発生します。この段階ではレンダリングが行われないため、「レンダリング」という単語は引用符で囲まれています。プリミティブのすべてのポイントに変換行列を乗算してから、エッジの分析式y = ky * x + byを抽出します。これにより、三角形の3つすべてのエッジと現在の出力ラインとの交点を見つけることができます。頂点間の間隔ではなく、その継続にあるため、そのうちの1つを破棄します。つまり、フレームを描画するには、すべての線を通過し、それぞれの交差点の間の領域をペイントする必要があります。ただし、このアルゴリズムを「正面から」適用すると、各プリミティブは以前に描画されたものと重なります。三角形が美しく交差するように、Z座標（深さ）を考慮する必要があります。単純にポイントごとに出力する代わりに、そのZ座標を考慮し、深度バッファーに格納されているZ座標と比較して、出力（Zバッファーの更新）または無視します。そして、対象となるラインの各ポイントのZ座標を計算するために、同じ直線式z = kz * y + bzを使用して、エッジを持つ同じ2つの交点で計算します。その結果、「半完成」の三角形の構造体glTriangleのオブジェクトは、頂点の3つのX座標で構成されます（Y座標とZ座標を格納する意味はありません。これらは計算されます）。b係数の色をヒープに直接割り当てます。ここでは、変換行列の計算とは対照的に、速度が重要であるため、固定小数点数を既に使用しています。さらに、項bの場合、座標（2バイト）と同じ精度で十分であれば、係数kの精度が高いほど良いので、4バイトを使用します。ただし、浮動小数点数ではありません。整数を処理するほうが、同じサイズでも高速です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、一連のglDrawTriangle（）を呼び出すことにより、半完成三角形の配列を準備しました。私の実装では、三角形は明示的な関数呼び出しによって一度に1つずつ推定されます。実際、頂点のアドレスを持つ三角形の配列を持つことは論理的ですが、ここでは複雑にしないことにしました。とにかく、レンダリング関数はロボットによって記述されており、定数配列を埋めるか、300の同じ呼び出しを書き込むかは関係ありません。三角形の半完成品を画面上の美しい絵に変換する時が来ました。これを行うには、glSwapBuffers（）関数が呼び出されます。上記のように、ディスプレイのラインを通過し、すべての三角形との各交点を検索し、深度によるフィルタリングに従ってセグメントを描画します。各ラインをレンダリングした後、このラインをディスプレイに送信する必要があります。これを行うには、文字列のアドレスとそのサイズを示すDMAを起動します。その間、DMAは機能し、別のバッファに切り替えて次の行をレンダリングできます。主なことは、突然レンダリングを早く終了した場合に転送の終了を待つことを忘れないことです。速度の比率を視覚化するために、レンダリングの終了後に赤色のLEDを含め、DMA待機の完了後にオフにした。待ち時間に応じて明るさを調整するPWMのようなものがわかります。理論的には、「ばかげた」待機の代わりにDMA割り込みを使用することもできますが、その場合は割り込みを使用できず、アルゴリズムがはるかに複雑になっていました。デモプログラムの場合、これは冗長です。速度の比率を視覚化するために、レンダリングの終了後に赤色のLEDを含め、DMA待機の完了後にオフにした。待ち時間に応じて明るさを調整するPWMのようなものがわかります。理論的には、「ばかげた」待機の代わりにDMA割り込みを使用できますが、その場合は割り込みを使用できず、アルゴリズムがはるかに複雑になっていました。デモプログラムの場合、これは冗長です。速度の比率を視覚化するために、レンダリングの終了後に赤色のLEDを含め、DMA待機の完了後にオフにした。待ち時間に応じて明るさを調整するPWMのようなものがわかります。理論的には、「ばかげた」待機の代わりにDMA割り込みを使用することもできますが、その場合は割り込みを使用できず、アルゴリズムがはるかに複雑になっていました。デモプログラムの場合、これは冗長です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の手順の結果は、異なる色の3つの交差する平面の回転画像であり、かなりまともな速度でした。赤いLEDの輝度はかなり高く、カーネルのパフォーマンスに大きなマージンがあることを示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、コアがアイドル状態の場合は、ロードする必要があります。そして、より良いモデルをロードします。ただし、メモリがまだ非常に制限されているため、コントローラーがあまり多くのポリゴンを物理的にプルしないことを忘れないでください。最も単純な計算では、ラインバッファーなどのメモリを差し引いた後、378個の三角形の場所があることがわかりました。練習が示しているように、古くて興味深いゴシックゲームのモデルはこのサイズに最適です。実際、蛇と血のハエのモデルがそこから引き出され（そしてこの記事を書いている時点で、KDPVを誇示している）、その後、コントローラーがフラッシュメモリを使い果たしました。ただし、ゲームモデルはマイクロコントローラーでの使用を想定していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アニメーションやテクスチャなどが含まれているとしましょう。これは私たちにとっては役に立ちませんし、メモリに収まりません。幸運なことに、blenderはそれらを* .objに保存するだけでなく、解析しやすいだけでなく、必要に応じてポリゴンの数を減らすこともできます。さらに、単純な自己作成プログラムobj2arr * .objを使用して、ファイルを座標にソートし、そこから* .hファイルを作成して、ファームウェアに直接含めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、今のところ、モデルは単純な巻き毛のしみのように見えます。テストモデルでは、すべての面が独自の色でペイントされていたため、問題はありませんでしたが、モデルの各ポリゴンに同じ色を指定していません。いいえ、もちろん、ハエをランダムな色でペイントすることはできますが、それは青からかなり見えます、と私はチェックしました。特に、各フレームで色が変化する場合...代わりに、ベクトルマジックをもう1滴適用してライティングを追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プリミティブバージョンでのライティングの計算は、法線と光源への方向のスカラー積を計算し、その後に顔の「ネイティブ」カラーを掛けることで構成されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで3つのモデルができました。2つはゲームから、もう1つはテストを開始しました。それらを切り替えるには、ボードにはんだ付けされた2つのボタンの1つを使用します。同時に、プロセッサに対する制御を追加できます。すでに1つのコントロールがあります。DMAレイテンシに関連する赤いLEDです。 2番目の緑のLEDは、フレームが更新されるたびに点滅します。これにより、フレームレートを推定できます。肉眼では約15fpsでした。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/afyTgpuA6sc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、私は結果に満足しています。根本的に解決することが基本的に不可能である何かを実装することは素晴らしいことです。</font><font style="vertical-align: inherit;">もちろん、最適化と改善の余地はまだたくさんありますが、これにはほとんど意味がありません。</font><font style="vertical-align: inherit;">客観的に言えば、3次元グラフィックスのコントローラーは弱く、速度の問題ではなくRAMの問題です。</font><font style="vertical-align: inherit;">ただし、他のデモシーンサンプルと同様に、このプロジェクトは結果ではなくプロセスによって価値があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰かが突然興味を持った場合、ソースコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここから</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入手でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja496036/index.html">オープンソース：Android向けCI / CDおよびAvitoテストインフラストラクチャ</a></li>
<li><a href="../ja496038/index.html">ビリルビン-黄疸の原因となる分子</a></li>
<li><a href="../ja496040/index.html">10 Zenライフハック</a></li>
<li><a href="../ja496042/index.html">Habr、私はあなたのサイトのエラーを通知しません</a></li>
<li><a href="../ja496044/index.html">宇宙船の打ち上げと地域の天気</a></li>
<li><a href="../ja496050/index.html">タイガースとライオンズがニューヨークでコロナウイルスに感染</a></li>
<li><a href="../ja496052/index.html">サービス会社はどのようにして顧客からの罰金を回避できますか？プロセス自動化の明らかでないいくつかの利点</a></li>
<li><a href="../ja496056/index.html">デジタル：数字と用語がどのように私たちを欺くか</a></li>
<li><a href="../ja496058/index.html">Почему нужно роботизировать сельхозкомбайны, в чём сложности, и как мы это сделали за два года</a></li>
<li><a href="../ja496060/index.html">Intel 0x7E4サマートレーニング-すべてのウイルスに対応</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>