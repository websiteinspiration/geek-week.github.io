<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüè≠ üé© üë∞üèΩ Widgets en Android. Una caracter√≠stica rara para descubrir ü§æüèΩ üë©üèº‚Äçüíº ‚úçüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Mi nombre es Alexander Khakimov, soy desarrollador de Android en FINCH. 
 
 ¬øSucedi√≥ que su dise√±o era para iOS y tiene que adaptarlo para ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Widgets en Android. Una caracter√≠stica rara para descubrir</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492166/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hola Habr! </font><font style="vertical-align: inherit;">Mi nombre es Alexander Khakimov, soy desarrollador de Android en FINCH. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øSucedi√≥ que su dise√±o era para iOS y tiene que adaptarlo para Android? </font><font style="vertical-align: inherit;">Si es as√≠, ¬øsus dise√±adores a menudo usan widgets? </font><font style="vertical-align: inherit;">Desafortunadamente, un widget es un caso raro para muchos desarrolladores, porque rara vez alguien trabaja con √©l. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este art√≠culo te contar√© en detalle c√≥mo crear un widget, al cual vale la pena prestarle atenci√≥n y compartir√© mi caso.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creaci√≥n de widgets</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para crear un widget necesitas saber:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caracter√≠sticas de los componentes del widget.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caracter√≠sticas de mostrar el widget en la cuadr√≠cula de la pantalla.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Presenta actualizaciones de widgets.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Analizaremos cada art√≠culo por separado.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caracter√≠sticas de los componentes del widget</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cualquier desarrollador que haya trabajado con RemoteViews al menos una vez est√° familiarizado con este elemento. </font><font style="vertical-align: inherit;">Si eres uno de estos, no dudes en pasar al siguiente punto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RemoteViews est√° dise√±ado para describir y administrar las jerarqu√≠as de Vistas que pertenecen a un proceso en otra aplicaci√≥n. </font><font style="vertical-align: inherit;">Mediante la administraci√≥n de jerarqu√≠a, puede cambiar las propiedades o los m√©todos de llamada que pertenecen a la Vista, que forma parte de otra aplicaci√≥n. </font><font style="vertical-align: inherit;">RemoteViews incluye un conjunto limitado de componentes de la biblioteca de componentes est√°ndar android.widget. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ver dentro de los widgets funciona en un proceso separado (por lo general, esta es la pantalla de inicio), por lo tanto, para cambiar la interfaz de usuario del widget, use la extensi√≥n BroadcastReceiver: AppWidgetProvider, que funciona en nuestra aplicaci√≥n.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caracter√≠sticas de mostrar el widget en la "cuadr√≠cula" de la pantalla</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, este punto no es tan complicado si nos fijamos en las </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pautas oficiales</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
 <blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada widget debe definir un minWidth y minHeight, que indica la cantidad m√≠nima de espacio que debe consumir de manera predeterminada. </font><font style="vertical-align: inherit;">Cuando los usuarios agregan un widget a su pantalla de inicio, generalmente ocupar√° m√°s que el ancho y la altura m√≠nimos que especifique. </font><font style="vertical-align: inherit;">Las pantallas de inicio de Android ofrecen a los usuarios una cuadr√≠cula de espacios disponibles en los que pueden colocar widgets e √≠conos. </font><font style="vertical-align: inherit;">Esta cuadr√≠cula puede variar seg√∫n el dispositivo; </font><font style="vertical-align: inherit;">por ejemplo, muchos tel√©fonos ofrecen una cuadr√≠cula de 4x4, y las tabletas pueden ofrecer una cuadr√≠cula m√°s grande de 8x7.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Traducci√≥n al ruso: cada widget debe establecer su propio ancho y alto m√≠nimos para indicar el espacio m√≠nimo que ocupar√° de forma predeterminada. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6r/p-/ux/6rp-uxyfekjzwlpantqmxkdfaio.png" alt="imagen"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo de configuraci√≥n de widgets al crear en Android Studio Un</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
widget que se agreg√≥ a la pantalla de inicio generalmente ocupar√° m√°s espacio que el ancho y la altura m√≠nimos de la pantalla que configur√≥. Las pantallas de inicio de Android proporcionan a los usuarios una cuadr√≠cula de espacios disponibles en los que se pueden ubicar widgets e √≠conos. Esta cuadr√≠cula puede variar seg√∫n el dispositivo; Por ejemplo, muchos tel√©fonos ofrecen cuadr√≠culas de 4x4, y las tabletas pueden ofrecer cuadr√≠culas de 8x4 grandes.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A partir de esto, queda claro que la cuadr√≠cula del dispositivo puede ser cualquier cosa, y el tama√±o de la celda puede variar, dependiendo del tama√±o de la cuadr√≠cula. </font><font style="vertical-align: inherit;">En consecuencia, el contenido del widget debe dise√±arse teniendo en cuenta estas caracter√≠sticas. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El ancho y la altura m√≠nimos del widget para un n√∫mero determinado de columnas y filas se pueden calcular mediante la f√≥rmula: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
minSideSizeDp = 70 √ó n - 30, donde n es el n√∫mero de filas o columnas. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este momento, la cuadr√≠cula m√≠nima m√°xima que puede establecer es 4x4. </font><font style="vertical-align: inherit;">Esto asegura que su widget se mostrar√° en todos los dispositivos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Presenta actualizaciones de widgets</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que AppWidgetProvider es esencialmente una extensi√≥n de BroadcastReceiver, puede hacer lo mismo con un BroadcastReceiver normal. AppWidgetProvider simplemente analiza los campos correspondientes de la intenci√≥n recibida en onReceive y llama a los m√©todos de intercepci√≥n con los extras recibidos. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La dificultad surgi√≥ con la frecuencia de actualizaci√≥n del contenido: el punto central es la diferencia en el funcionamiento interno de los widgets en iOS y Android. El hecho es que los datos en los widgets de iOS se actualizan cuando el widget se vuelve visible para el usuario. En Android, tal evento no existe. No podemos saber cu√°ndo el usuario ve el widget.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para los widgets en Android, el m√©todo de actualizaci√≥n recomendado es una actualizaci√≥n del temporizador. </font><font style="vertical-align: inherit;">La configuraci√≥n del temporizador se establece mediante el par√°metro de actualizaci√≥n updatePeriodMillis. </font><font style="vertical-align: inherit;">Desafortunadamente, esta configuraci√≥n no permite actualizar el widget m√°s de una vez cada 30 minutos. </font><font style="vertical-align: inherit;">A continuaci√≥n hablar√© sobre esto con m√°s detalle.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caso de widget</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, hablaremos sobre el caso que tuvimos en FINCH en una gran aplicaci√≥n de loter√≠a con la aplicaci√≥n Stoloto para participar en loter√≠as estatales. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tarea de la aplicaci√≥n es simplificar y hacer transparente para el usuario la elecci√≥n de una loter√≠a y la compra de un boleto. </font><font style="vertical-align: inherit;">Por lo tanto, la funcionalidad requerida del widget es bastante simple: muestre los juegos recomendados por el usuario para la compra y toque para ir al correspondiente. </font><font style="vertical-align: inherit;">La lista de juegos se determina en el servidor y se actualiza regularmente. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestro caso, el dise√±o del widget inclu√≠a dos estados:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para usuarios autorizados</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para un usuario no autorizado.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un usuario autorizado debe mostrar sus datos de perfil: el estado de la billetera interna, la cantidad de boletos que esperan el sorteo y la cantidad de victorias perdidas. </font><font style="vertical-align: inherit;">Para cada uno de estos elementos, se proporciona una transici√≥n a la pantalla dentro de la aplicaci√≥n, diferente de los dem√°s. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rp/d2/6i/rpd26ixtdxfjopibvmgaaczfkco.png" alt="imagen"><br>
<br>
<img src="https://habrastorage.org/webt/dk/yy/qx/dkyyqxqcnopxezwhknrmqbuedgu.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como habr√°s notado, otra caracter√≠stica para un usuario autorizado es el bot√≥n "actualizar", pero m√°s sobre eso m√°s adelante. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para implementar la visualizaci√≥n de dos estados, teniendo en cuenta el dise√±o, utilic√© RemoteAdapter como una implementaci√≥n de RemoteViewsService para generar tarjetas de contenido. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y ahora un peque√±o c√≥digo y c√≥mo funciona todo dentro. </font><font style="vertical-align: inherit;">Si ya ten√≠a experiencia con el widget, sabe que cualquier actualizaci√≥n de los datos del widget comienza con el m√©todo onUpdate:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onUpdate</span><span class="hljs-params">(
        context: <span class="hljs-type">Context</span>,
        appWidgetManager: <span class="hljs-type">AppWidgetManager</span>,
        appWidgetIds: <span class="hljs-type">IntArray</span>
    )</span></span> {<font></font>
        injector.openScope(<span class="hljs-keyword">this</span>, *arrayOf(<span class="hljs-keyword">this</span>))
        <span class="hljs-comment">// update each of the widgets with the remote adapter</span><font></font>
        appWidgetIds<font></font>
            .forEach {<font></font>
                updateWidget(context, appWidgetManager, it)<font></font>
          }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estamos escribiendo una actualizaci√≥n para cada instancia de nuestro widget.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateWidget</span><span class="hljs-params">(
        context: <span class="hljs-type">Context</span>,
        appWidgetManager: <span class="hljs-type">AppWidgetManager</span>,
        appWidgetId: <span class="hljs-type">Int</span>
    )</span></span> {
<span class="hljs-comment">// remoteViews   widgetId</span>
        <span class="hljs-keyword">val</span> remoteViews = RemoteViews(<font></font>
            context.packageName,<font></font>
            R.layout.app_widget_layout<font></font>
...<font></font>
<span class="hljs-comment">//        </span><font></font>
...<font></font>
<span class="hljs-comment">//    remoteViews</span><font></font>
updateRemoteAdapter(context, remoteViews, appWidgetId)<font></font>
 <font></font>
<span class="hljs-comment">//   remoteViews </span><font></font>
appWidgetManager.updateAppWidget(appWidgetId, remoteViews)<font></font>
<span class="hljs-comment">// collection view  </span><font></font>
appWidgetManager.notifyAppWidgetViewDataChanged(<font></font>
            appWidgetId,<font></font>
            R.id.lvWidgetItems<font></font>
        )<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Actualizando el adaptador.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateRemoteAdapter</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, remoteViews: <span class="hljs-type">RemoteViews</span>, appWidgetId: <span class="hljs-type">Int</span>)</span></span> {
<span class="hljs-comment">//   RemoteViewsService   RemoteAdapter   </span>
        <span class="hljs-keyword">val</span> adapterIntent = Intent(context, StolotoAppWidgetRemoteViewsService::<span class="hljs-keyword">class</span>.java).apply {<font></font>
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)<font></font>
        }<font></font>
        remoteViews.setRemoteAdapter(R.id.lvWidgetItems, adapterIntent)<font></font>
// actionIntent  pendingIntent      <font></font>
        <span class="hljs-keyword">val</span> actionIntent = Intent(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java).apply {<font></font>
            action = WIDGET_CLICK_ACTION<font></font>
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)<font></font>
        }<font></font>
        <span class="hljs-keyword">val</span> pendingIntent = PendingIntent.getBroadcast(<font></font>
            context, <span class="hljs-number">0</span>, actionIntent,<font></font>
            PendingIntent.FLAG_UPDATE_CURRENT<font></font>
        )<font></font>
<span class="hljs-comment">// pendingIntent      </span><font></font>
        remoteViews.setPendingIntentTemplate(R.id.lvWidgetItems, pendingIntent)<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estamos escribiendo la implementaci√≥n de nuestro servicio. </font><font style="vertical-align: inherit;">En √©l, es importante que indiquemos qu√© implementaci√≥n de la interfaz RemoteViewsService.RemoteViewsFactory usar para generar contenido.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StolotoAppWidgetRemoteViewsService</span> : <span class="hljs-type">RemoteViewsService</span></span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onGetViewFactory</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>)</span></span>: RemoteViewsFactory =<font></font>
        StolotoAppWidgetRemoteViewsFactory(<font></font>
            <span class="hljs-keyword">this</span>.applicationContext,<font></font>
            intent<font></font>
        )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto es en realidad una envoltura delgada sobre el adaptador. </font><font style="vertical-align: inherit;">Gracias a √©l, podemos asociar nuestros datos con la vista de recopilaci√≥n remota. </font><font style="vertical-align: inherit;">RemoteViewsFactory proporciona m√©todos para generar RemoteViews para cada elemento del conjunto de datos. </font><font style="vertical-align: inherit;">El constructor no tiene requisitos: todo lo que hago es pasarle el contexto. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n, algunas palabras sobre los m√©todos principales:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onCreate: creaci√≥n de un adaptador.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getLoadingView: el m√©todo sugiere devolver la Vista, que el sistema mostrar√° en lugar de los elementos de la lista mientras se crean. </font><font style="vertical-align: inherit;">Si no crea nada aqu√≠, el sistema usa alguna Vista predeterminada.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getViewAt: el m√©todo sugiere crear elementos de lista. </font><font style="vertical-align: inherit;">Aqu√≠ viene el uso est√°ndar de RemoteViews.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se llama a onDataSetChanged cuando se recibe una solicitud para actualizar los datos de la lista. </font><font style="vertical-align: inherit;">Aquellos. </font><font style="vertical-align: inherit;">En este m√©todo, preparamos los datos para la lista. </font><font style="vertical-align: inherit;">El m√©todo se agudiza mediante la ejecuci√≥n de un c√≥digo largo y pesado.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se llama a onDestroy cuando se elimina la √∫ltima lista que utiliz√≥ el adaptador (varias listas pueden usar un adaptador).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RemoteViewsFactory vive mientras todas las instancias de la lista est√°n activas, por lo que podemos almacenar datos actuales en ella, por ejemplo, una lista de elementos actuales.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Defina una lista de datos que mostraremos:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> widgetItems = ArrayList&lt;WidgetItem&gt;()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al crear el adaptador, comenzamos a cargar los datos. </font><font style="vertical-align: inherit;">Aqu√≠ puede realizar con seguridad cualquier tarea dif√≠cil, como caminar silenciosamente hacia la red bloqueando el flujo.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
        updateDataSync()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando llamamos al comando para actualizar datos, tambi√©n llamamos a updateDataSync ()</font></font><br>
<br>
<pre><code class="kotlin hljs">   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDataSetChanged</span><span class="hljs-params">()</span></span> {<font></font>
        updateDataSync()<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dentro de updateDataSync, todo es simple tambi√©n. </font><font style="vertical-align: inherit;">Borramos la lista actual de art√≠culos. </font><font style="vertical-align: inherit;">Descargar perfil y datos del juego.</font></font><br>
<br>
<pre><code class="kotlin hljs"> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateDataSync</span><span class="hljs-params">()</span></span> {<font></font>
        widgetItems.clear()<font></font>
        updateProfileSync()<font></font>
        updateGamesSync()<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es m√°s interesante aqu√≠.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateProfileSync</span><span class="hljs-params">()</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que es importante para nosotros mostrar el perfil solo a un usuario autorizado, necesitamos descargar la informaci√≥n del perfil solo en este caso:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> isUserFullAuth = isUserFullAuthInteractor<font></font>
            .execute()<font></font>
            .blockingGet()<font></font>
        <span class="hljs-keyword">if</span> (isUserFullAuth) {
            <span class="hljs-keyword">val</span> profile = getWidgetProfileInteractor<font></font>
                .execute()<font></font>
                .onErrorReturn {<font></font>
                    WidgetProfile()<font></font>
<span class="hljs-comment">//           </span><font></font>
                }<font></font>
                .blockingGet()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El modelo WidgetProfile se ensambla a partir de diferentes fuentes, por lo que la l√≥gica de su recibo y sus valores predeterminados se organizan de tal manera que un valor negativo de la billetera indica datos incorrectos o problemas con su recibo. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para la l√≥gica empresarial, la falta de datos de billetera es cr√≠tica, por lo tanto, en el caso de una billetera incorrecta, no se crear√° un modelo de perfil ni se agregar√° a la lista de elementos.</font></font><br>
<br>
<pre><code class="kotlin hljs">  <span class="hljs-keyword">if</span> (profile.walletAmount &gt;= <span class="hljs-number">0L</span>) {<font></font>
                widgetItems.add(<font></font>
                    WidgetItem.Profile(<font></font>
                        wallet = profile.walletAmount.toMoneyFormat(),<font></font>
                        waitingTickets = <span class="hljs-keyword">if</span> (profile.waitingTicketsCount &gt;= <span class="hljs-number">0</span>) profile.waitingTicketsCount.toString() <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>,<font></font>
                        unpaidPrizeAmount = <span class="hljs-keyword">if</span> (profile.unpaidPrizeAmount &gt;= <span class="hljs-number">0</span>) profile.unpaidPrizeAmoount.toMoneyFormat() <span class="hljs-keyword">else</span> <span class="hljs-string">""</span><font></font>
                    )<font></font>
                )<font></font>
            }<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El m√©todo updateGamesSync () usa getWidgetGamesInteractor y agrega un conjunto de juegos relevantes para el widget a la lista widgetItems. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de proceder a la generaci√≥n de tarjetas, considere el modelo WidgetItem con m√°s detalle. </font><font style="vertical-align: inherit;">Se implementa a trav√©s de la clase sellada kotlin, lo que hace que el modelo sea m√°s flexible, y trabajar con √©l es m√°s conveniente.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetItem</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Profile</span></span>(
        <span class="hljs-keyword">val</span> wallet: String,
        <span class="hljs-keyword">val</span> waitingTickets: String,
        <span class="hljs-keyword">val</span> unpaidPrizeAmount: String<font></font>
    ) : WidgetItem()<font></font>
 <font></font>
    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span></span>(
        <span class="hljs-keyword">val</span> id: String,
        <span class="hljs-keyword">val</span> iconId: <span class="hljs-built_in">Int</span>,
        <span class="hljs-keyword">val</span> prizeValue: String,
        <span class="hljs-keyword">val</span> date: String<font></font>
    ) : WidgetItem()<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cree RemoteViews y determine su respuesta a trav√©s de FillInIntent</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getViewAt</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span>: RemoteViews {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> item = widgetItems[position]) {
            <span class="hljs-keyword">is</span> WidgetItem.Profile -&gt; {<font></font>
              RemoteViews(<font></font>
                        context.packageName,<font></font>
                        R.layout.item_widget_user_profile<font></font>
                    ).apply {<font></font>
                        setTextViewText(R.id.tvWidgetWalletMoney, item.wallet)<font></font>
                        setTextViewText(R.id.tvWidgetUnpaidCount, item.unpaidPrizeAmount)<font></font>
                        setTextViewText(R.id.tvWidgetWaitingCount, item.waitingTickets)<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileWallet, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_USER_WALLET<font></font>
                            )<font></font>
                        )<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileUnpaid, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_UNPAID_PRIZE<font></font>
                            )<font></font>
                        )<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileWaiting, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_WAITING_TICKETS<font></font>
                            )<font></font>
                        )<font></font>
                    }<font></font>
 <font></font>
            <span class="hljs-keyword">is</span> WidgetItem.Game -&gt; {<font></font>
                RemoteViews(<font></font>
                    context.packageName,<font></font>
                    R.layout.item_widget_game<font></font>
                ).apply {<font></font>
                    setImageViewResource(R.id.ivWidgetGame, item.iconId)<font></font>
                    setTextViewText(R.id.tvWidgetGamePrize, item.prizeValue)<font></font>
                    setTextViewText(R.id.tvWidgetGameDate, item.date)<font></font>
                    setOnClickFillInIntent(<font></font>
                        R.id.llWidgetGame, Intent().putExtra(<font></font>
                            StolotoAppWidgetProvider.KEY_GAME_CLICK, item.id<font></font>
                        )<font></font>
                    )<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El m√©todo setOnClickFillInIntent asigna la intenci√≥n viewId especificada, que se combinar√° con el PendingIntent principal para determinar el comportamiento al hacer clic en la vista con este viewId. </font><font style="vertical-align: inherit;">De esta manera podemos responder a los clics de los usuarios en nuestro WidgetProvider.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actualizaci√≥n manual de widgets</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se estableci√≥ un tiempo de actualizaci√≥n de media hora para nuestro widget. Puede actualizarlo m√°s a menudo, por ejemplo, bailando con WorkManager, pero ¬øpor qu√© cargar su red y bater√≠a? Tal comportamiento en las primeras etapas de desarrollo parec√≠a adecuado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo cambi√≥ cuando el "negocio" not√≥ que cuando el usuario mira el widget, los datos irrelevantes se muestran en √©l: "Aqu√≠ en mi iPhone, abro el widget y hay los datos M√ÅS actualizados de mi perfil". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La situaci√≥n es com√∫n: iOS genera nuevas tarjetas para CADA pantalla de widget, porque para esto tienen una pantalla especial, y Android no tiene tales eventos para el widget en principio. Ten√≠a que tener en cuenta que algunas loter√≠as se llevan a cabo una vez cada 15 minutos, por lo que el widget debe proporcionar informaci√≥n actualizada: desea participar en alg√∫n tipo de sorteo, pero ya ha pasado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para salir de esta situaci√≥n desagradable y de alguna manera resolver el problema con la actualizaci√≥n de datos, propuse e implement√© una soluci√≥n probada con el tiempo: el bot√≥n "actualizar". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregue este bot√≥n al dise√±o con la lista e inicialice su comportamiento cuando se llama a updateWidget.</font></font><br>
<br>
<pre><code class="kotlin hljs">...
<span class="hljs-comment">// Intent   AppWidgetManager.ACTION_APPWIDGET_UPDATE</span>
<span class="hljs-keyword">val</span> intentUpdate = Intent(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java)<font></font>
intentUpdate.action = AppWidgetManager.ACTION_APPWIDGET_UPDATE<font></font>
<font></font>
//    <font></font>
<span class="hljs-keyword">val</span> ids = AppWidgetManager.getInstance(context)<font></font>
   .getAppWidgetIds(ComponentName(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java))<font></font>
intentUpdate.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, ids)<font></font>
<font></font>
//  intent  PendingIntent,  PendingIntent.getBroadcast()<font></font>
<span class="hljs-keyword">val</span> pendingUpdate = PendingIntent.getBroadcast(<font></font>
   context,<font></font>
   appWidgetId,<font></font>
   intentUpdate,<font></font>
   PendingIntent.FLAG_UPDATE_CURRENT<font></font>
)<font></font>
//  pendingIntent      ‚Äò‚Äô<font></font>
remoteViews.setOnClickPendingIntent(R.id.ivWidgetRefresh, pendingUpdate)<font></font>
‚Ä¶</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los primeros desarrollos mostraron una imagen triste: desde presionar el bot√≥n "actualizar" hasta la actualizaci√≥n real, podr√≠an pasar varios segundos. </font><font style="vertical-align: inherit;">Aunque el widget es generado por nuestra aplicaci√≥n, en realidad est√° bajo el control del sistema y se comunica con nuestra aplicaci√≥n a trav√©s de transmisiones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquellos. </font><font style="vertical-align: inherit;">Cuando hace clic en el bot√≥n "actualizar" de nuestro widget, la cadena comienza:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenga la intenci√≥n en la 'acci√≥n' del proveedor onReceive.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppWidgetManager.ACTION_APPWIDGET_UPDATE. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llame a onUpdate para todos los widgetsIds especificados en intent-e.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con√©ctese en l√≠nea para obtener nuevos datos.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actualice los datos locales y muestre nuevas tarjetas de lista.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, la actualizaci√≥n del widget no se ve√≠a muy bien, porque al hacer clic en el bot√≥n miramos el mismo widget durante un par de segundos. </font><font style="vertical-align: inherit;">No estaba claro si los datos se actualizaron. </font><font style="vertical-align: inherit;">¬øC√≥mo resolver el problema de la respuesta visual? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, agregu√© el indicador isWidgetLoading con acceso global a trav√©s del interactor. </font><font style="vertical-align: inherit;">La funci√≥n de este par√°metro es bastante simple: no muestre el bot√≥n Actualizar mientras se cargan los datos del widget. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En segundo lugar, divid√≠ el proceso de carga de datos en la f√°brica en tres etapas:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadingStep</span> </span>{<font></font>
   START,<font></font>
   MIDDLE,<font></font>
   END<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
INICIO: inicio de la descarga. </font><font style="vertical-align: inherit;">En esta etapa, el estado de todas las vistas del adaptador y el indicador de descarga global cambia a "cargando". </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MEDIO - la etapa de la carga de datos principal. </font><font style="vertical-align: inherit;">Despu√©s de que se descargan, el indicador de descarga global se coloca en el estado "cargado" y los datos descargados se muestran en el adaptador. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FIN: fin de la descarga. </font><font style="vertical-align: inherit;">El adaptador no necesita cambiar los datos del adaptador en este paso. </font><font style="vertical-align: inherit;">Este paso es necesario para procesar correctamente la etapa de actualizaci√≥n de las vistas en WidgetProvider. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos con m√°s detalle c√≥mo se ve la actualizaci√≥n del bot√≥n en el proveedor:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">if</span> (isFullAuthorized &amp;&amp; !widgetLoadingStateInteractor.isWidgetLoading) {<font></font>
   remoteViews.setViewVisibility(R.id.ivWidgetRefresh, View.VISIBLE)<font></font>
...<font></font>
<span class="hljs-comment">//     ,    </span><font></font>
...   <font></font>
} <span class="hljs-keyword">else</span> {<font></font>
   remoteViews.setViewVisibility(<font></font>
       R.id.ivWidgetRefresh,<font></font>
       <span class="hljs-keyword">if</span> (isFullAuthorized) View.INVISIBLE <span class="hljs-keyword">else</span> View.GONE <span class="hljs-comment">//       .</span><font></font>
   )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora veamos qu√© sucede en el adaptador:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateDataSync</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">when</span> (loadingStep) {<font></font>
       START -&gt; {<font></font>
           widgetItems.forEach { it.isLoading = <span class="hljs-literal">true</span> }<font></font>
           widgetLoadingStateInteractor.isWidgetLoading = <span class="hljs-literal">true</span><font></font>
           loadingStep = MIDDLE<font></font>
           widgetManager.updateWidgets()<font></font>
       }<font></font>
       MIDDLE -&gt; {<font></font>
           widgetItems.clear()<font></font>
           updateProfileSync()<font></font>
           updateGamesSync()<font></font>
           widgetLoadingStateInteractor.isWidgetLoading = <span class="hljs-literal">false</span><font></font>
           loadingStep = END<font></font>
           widgetManager.updateWidgets()<font></font>
       }<font></font>
       END -&gt; {<font></font>
           loadingStep = START<font></font>
       }<font></font>
   }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/bq/ah/hg/bqahhgnwugy10345-bcegnupxo8.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L√≥gica de trabajo: </font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al final de los pasos START y MIDDLE, llamo al m√©todo updateWidgets para actualizar el estado de vista administrado por el proveedor.</font></font></li>
<li>   START     ¬´¬ª   ,    MIDDLE.</li>
<li>         MIDDLE,    ¬´¬ª.</li>
<li>   MIDDLE,          END. </li>
<li>      ,   END,    ¬´¬ª.        ,    END   loadingStep  START.</li>
</ol><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con la ayuda de dicha implementaci√≥n, logr√© un compromiso entre el requisito del "negocio" de ver los datos relevantes en el widget y la necesidad de "extraer" la actualizaci√≥n con demasiada frecuencia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que el art√≠culo te haya sido √∫til. </font><font style="vertical-align: inherit;">Si tienes experiencia creando widgets para Android, cu√©ntanoslo en los comentarios. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Buena suerte</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es492150/index.html">Implem√©ntalo completamente. Di-in-js</a></li>
<li><a href="../es492154/index.html">Lanzamiento de ExoMars retrasado a la pr√≥xima ventana de lanzamiento en 2022</a></li>
<li><a href="../es492156/index.html">Restado Querer. Hacer</a></li>
<li><a href="../es492162/index.html">Interfaces oculares. Informar en Yandex</a></li>
<li><a href="../es492164/index.html">Puerta de entrada al cielo, o la ciudad del futuro.</a></li>
<li><a href="../es492168/index.html">Trabajo frontal en el desarrollo de back-end de los portales m√°s grandes en software de c√≥digo abierto: compartir experiencias</a></li>
<li><a href="../es492172/index.html">Copia de seguridad delgada de sistemas de archivos Linux. C√≥mo crear copias de trabajo de un DBMS MySQL de tres terabytes en 20 segundos</a></li>
<li><a href="../es492174/index.html">Monitor inal√°mbrico de humedad del suelo de bricolaje</a></li>
<li><a href="../es492178/index.html">Una ruta de siete mil p√≠xeles: evoluci√≥n de las resoluciones de monitor y nuestros requisitos</a></li>
<li><a href="../es492182/index.html">Fundamentos de seguridad de la informaci√≥n en los equipos de Microsoft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>