<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🚒 🤰 👨🏾‍🤝‍👨🏻 Classificar por n-pirâmide 🥗 ✍🏻 👩🏾‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Classificar em uma pilha (também é uma classificação piramidal) em Habré já foi lembrado com uma boa palavra mais de uma ou duas vezes, mas essa sempr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Classificar por n-pirâmide</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/495420/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><div style="text-align:center;"><img width="750" height="322" src="https://habrastorage.org/webt/jf/fj/_q/jffj_qzdbowiyg-ae0vt73ddewc.jpeg"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Classificar em uma pilha (também é uma classificação piramidal) em Habré já foi lembrado com uma boa palavra mais de uma ou duas vezes, mas essa sempre foi uma informação bastante conhecida. Todo mundo conhece a pilha binária usual, mas a teoria dos algoritmos também possui: uma </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pilha n; um monte de montes com base nos números de Leonardo; Deramide (um híbrido de heap e árvore de pesquisa binária); mini pilha de torneios; pilha espelho (reversa); pilha fraca; Pilha de Jung; pilha binomial; e Deus sabe que outros montões ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E os representantes mais inteligentes da ciência da computação em anos diferentes propuseram seus algoritmos de classificação usando essas estruturas piramidais. Quem se importa com o que eles fizeram - para aqueles que estamos iniciando uma pequena série de artigos dedicados à classificação usando essas estruturas. O mundo dos montões é diverso - espero que você esteja interessado.</font></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="EDISON Software - desenvolvimento web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - desenvolvimento web"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este artigo foi escrito com o apoio da EDISON. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estamos envolvidos no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desenvolvimento de aplicativos móveis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e fornecemos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serviços de teste de software</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adoramos a teoria dos algoritmos! </font><font style="vertical-align: inherit;">;-)</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existe essa classe de algoritmos - ordenando por escolha. </font><font style="vertical-align: inherit;">A idéia geral é que a parte não ordenada da matriz seja reduzida devido ao fato de procurar os elementos máximos que são reorganizados em uma área classificada crescente.</font></font><br>
<br>
<div style="text-align:center;"><img width="646" height="69" src="https://habrastorage.org/webt/ew/-y/d5/ew-yd57sbecvuebvverib0a80am.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Classificar a escolha usual é força bruta. </font><font style="vertical-align: inherit;">Se, em busca de máximos, é simples passar linearmente pela matriz, a complexidade de tempo de um algoritmo desse tipo não pode exceder O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></b><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um monte</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A maneira mais eficiente de trabalhar com os altos da matriz é organizar os dados em uma estrutura de árvore especial, conhecida como </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heap</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Essa é uma árvore na qual todos os nós pai não são menos que nós descendentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outros nomes da pilha - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a pirâmide</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a árvore de classificação</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejamos como pode ser fácil e quase gratuito apresentar uma matriz na forma de uma árvore.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pegue o primeiro elemento da matriz e considere que essa é a raiz da árvore - um nó do 1º nível. </font><font style="vertical-align: inherit;">Os próximos 2 elementos são nós do 2º nível, os descendentes direito e esquerdo do elemento raiz. </font><font style="vertical-align: inherit;">Os próximos 4 elementos são nós do terceiro nível, os descendentes direito / esquerdo do segundo / terceiro elemento da matriz. </font><font style="vertical-align: inherit;">Os próximos 8 elementos são nós do 4º nível, descendentes de elementos do 3º nível. </font><font style="vertical-align: inherit;">Etc. </font><font style="vertical-align: inherit;">Nesta imagem, os nós da árvore binária estão claramente localizados estritamente abaixo dos elementos correspondentes na matriz:</font></font><br>
<br>
<div style="text-align:center;"><img width="627" height="340" src="https://habrastorage.org/webt/ut/e6/in/ute6inpfajr64j1tlpggpl5w8fo.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Embora as árvores nos diagramas sejam mais frequentemente representadas em uma varredura: </font></font><br>
<br>
<div style="text-align:center;"><img width="571" height="244" src="https://habrastorage.org/webt/3l/pz/yi/3lpzyizc7eephsbmsc9viexmr2u.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você observar esse ângulo, ficará claro por que a classificação por um grupo é chamada de classificação piramidal. Embora isso seja quase o mesmo que se você chamar um elefante de xadrez de oficial, uma torre de tura e uma rainha de rainha. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os índices para os descendentes do </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ésimo elemento são determinados por elementar (se o índice do primeiro elemento da matriz for considerado igual a 0, como é habitual na maioria das linguagens de programação): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Descendente esquerdo de 2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
o filho certo: 2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(eu estou nos gráficos e nas animações, tradicionalmente, os índices de matrizes começam com 1, onde as fórmulas são ligeiramente diferentes: filho esquerdo: </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ie</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> filho direito: </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas essas já são pequenas nuances aritméticas). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se a prole resultante dessas fórmulas, os índices ultrapassarem a matriz, significa que o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ésimo item não possui filhos. </font><font style="vertical-align: inherit;">Também pode acontecer que o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ésimo elemento seja um descendente à esquerda (cai no último elemento da matriz em que um número ímpar de elementos), mas não há um direito. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, qualquer matriz pode ser facilmente representada na forma de uma árvore, no entanto, isso ainda não é um monte, porque, na matriz, alguns elementos descendentes podem ser maiores que os elementos pai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que nossa árvore, criada com base na matriz, se torne um monte, ela precisa ser peneirada corretamente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peneirar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A alma de escolher um grupo é peneirada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A peneiração de um elemento é que, se for menor do que os descendentes combinados em uma cadeia inextricável, esse elemento deverá ser movido o mais baixo possível, e os descendentes maiores deverão ser aumentados 1 nível acima. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A imagem mostra o caminho de peneiração do item. A cor azul indica o elemento para o qual a peneiração é realizada. Verde - descendentes maiores no galho. Eles serão aumentados um nível acima, porque são maiores em tamanho do que o nó azul para o qual a tela é feita. O próprio elemento do nó azul superior será movido para o local do descendente mais baixo da cadeia verde.</font></font><br>
<br>
<div style="text-align:center;"><img width="571" height="249" src="https://habrastorage.org/webt/rh/i5/p_/rhi5p_yzvebng8-pywu-zuli7h0.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É necessário um peneiramento para fazer uma árvore de classificação fora de uma árvore comum e para apoiar ainda mais a árvore nesse estado (de classificação). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesta imagem, os elementos da matriz são redistribuídos para que já estejam dispostos em um heap. </font><font style="vertical-align: inherit;">Embora a matriz seja decomposta em uma árvore de classificação, ela ainda não foi classificada (crescente ou decrescente), embora todos os descendentes na árvore sejam menores que seus nós principais. </font><font style="vertical-align: inherit;">Mas o elemento mais máximo na árvore de classificação está sempre na raiz principal, o que é muito importante.</font></font><br>
<br>
<div style="text-align:center;"><img width="571" height="244" src="https://habrastorage.org/webt/iz/yg/lk/izyglkygfz4sh7izbjkhhsbdsvk.png"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sort :: Heapsort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O algoritmo é realmente simples:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 1. Formamos uma árvore de classificação de toda a matriz. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para fazer isso, passamos da direita para a esquerda os elementos (do último para o primeiro) e, se o elemento tem descendentes, fazemos uma seleção.</font></font></li>
<li><b> 2.       .</b>             ,        .   (  )        .        , ..   .       ,      —             .         ,             .</li>
</ul><br>
<br>
<div style="text-align:center;"><img width="646" height="303" src="https://habrastorage.org/webt/cr/ik/_t/crik_twwuqdjsiclj7t-mcdjx78.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Código Python para uma implementação clássica de classificação piramidal:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#    </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HeapSort</span>(<span class="hljs-params">data</span>):</span><font></font>
<font></font>
    <span class="hljs-comment">#    </span>
    <span class="hljs-comment">#   -   </span>
    <span class="hljs-comment"># (   )       </span>
    <span class="hljs-keyword">for</span> start <span class="hljs-keyword">in</span> range((len(data) - <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):<font></font>
        HeapSift(data, start, len(data) - <span class="hljs-number">1</span>) <font></font>
<font></font>
    <span class="hljs-comment">#        </span>
    <span class="hljs-comment">#        .</span>
    <span class="hljs-keyword">for</span> end <span class="hljs-keyword">in</span> range(len(data) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>): 
        <span class="hljs-comment">#       </span>
        <span class="hljs-comment">#    </span>
        data[end], data[<span class="hljs-number">0</span>] = data[<span class="hljs-number">0</span>], data[end]
        <span class="hljs-comment">#        </span>
        <span class="hljs-comment">#   </span>
        <span class="hljs-comment">#     </span>
        HeapSift(data, <span class="hljs-number">0</span>, end - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> data<font></font>
<font></font>
<span class="hljs-comment">#   ,      </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HeapSift</span>(<span class="hljs-params">data, start, end</span>):</span><font></font>
<font></font>
    <span class="hljs-comment">#   - ,     </span><font></font>
    root = start <font></font>
    <font></font>
    <span class="hljs-comment">#      ,</span>
    <span class="hljs-comment">#   ,    </span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
<font></font>
        child = root * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> <span class="hljs-comment">#  </span>
        <span class="hljs-comment">#      -  </span>
        <span class="hljs-keyword">if</span> child &gt; end: <span class="hljs-keyword">break</span> <font></font>
<font></font>
        <span class="hljs-comment">#       ,</span>
        <span class="hljs-comment">#      </span>
        <span class="hljs-keyword">if</span> child + <span class="hljs-number">1</span> &lt;= end <span class="hljs-keyword">and</span> data[child] &lt; data[child + <span class="hljs-number">1</span>]:<font></font>
            child += <span class="hljs-number">1</span><font></font>
<font></font>
        <span class="hljs-comment">#     ,   </span>
        <span class="hljs-comment">#       , </span>
        <span class="hljs-comment">#       </span>
        <span class="hljs-keyword">if</span> data[root] &lt; data[child]:<font></font>
            data[root], data[child] = data[child], data[root]<font></font>
            root = child<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span></code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complexidade do algoritmo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que um heap simples é bom - ele não precisa ser armazenado separadamente, ao contrário de outros tipos de árvores (por exemplo, uma árvore de pesquisa binária baseada em uma matriz deve ser criada antes do uso). Qualquer matriz já é uma árvore na qual, em movimento, você pode identificar imediatamente os pais e descendentes. A complexidade da memória adicional é O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), tudo acontece imediatamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quanto à complexidade do tempo, depende da peneiração. Uma única peneiração é ignorada em </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Primeiro, </font><font style="vertical-align: inherit;">analisamos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elementos para construir o heap inicial a partir da matriz - esta etapa leva </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Na segunda etapa, quando tiramos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">os máximos atuais da pilha, fazemos uma única peneiração para a parte restante não classificada, ou seja, </font><font style="vertical-align: inherit;">esse estágio também nos custa </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Complexidade do tempo total: O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) + O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, a classificação piramidal não apresenta casos degenerados nem melhores. </font><font style="vertical-align: inherit;">Qualquer matriz será processada a uma velocidade decente, mas não haverá degradação ou registros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A classificação de heap, em média, é um pouco mais lenta que a classificação rápida. </font><font style="vertical-align: inherit;">Mas para o quicksort, você pode escolher uma matriz matadora na qual o computador trava, mas para o heapsort - não.</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th rowspan="2"></th>
<th colspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complexidade do tempo</font></font></th>
</tr>
<tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pior</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Média</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao melhor</font></font></th>
</tr>
<tr>
<th> </th>
<td colspan="3" align="center">O(<b>n</b> log <b>n</b>)</td>
</tr>
<tr>
<th> </th>
<td align="center">O(<b>n</b><sup>2</sup>)</td>
<td align="center">O(<b>n</b> log <b>n</b>)</td>
<td align="center">O(<b>n</b>)</td>
</tr>
</tbody></table></div><br>
<br>
<h2>   :: Ternary heapsort</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos olhar para a pilha ternária. Você não acreditará no binário, ele difere apenas no fato de os nós pais terem um máximo de não dois, mas três descendentes. Na pilha ternária para o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ésimo elemento codifica três filhos calculados de maneira semelhante (se o primeiro índice do elemento = 0): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O descendente esquerdo 3 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Descendente médio 3 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
descendente direito 3 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 3 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Se os índices começam com 1, como nas animações deste artigo, e nessas fórmulas você só precisa subtrair uma). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Processo de classificação:</font></font><br>
<br>
<div style="text-align:center;"><img width="646" height="251" src="https://habrastorage.org/webt/-g/8n/rn/-g8nrn8fbhvbv4wvceklzcw2rio.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por um lado, o número de níveis na árvore diminui acentuadamente em comparação com a pilha binária, o que significa que, em média, haverá menos trocas durante a peneiração. </font><font style="vertical-align: inherit;">Por outro lado, para encontrar o descendente mínimo, serão necessárias mais comparações - porque os descendentes agora não são dois, mas três cada. </font><font style="vertical-align: inherit;">Em geral, em termos de complexidade de tempo - em algum lugar que encontramos, em algum lugar que perdemos, mas em geral a mesma coisa. </font><font style="vertical-align: inherit;">Os dados no heap ternário são classificados um pouco mais rápido que no binário, mas essa aceleração é muito pequena. </font><font style="vertical-align: inherit;">Em todas as variações da classificação piramidal, os desenvolvedores dos algoritmos preferem usar a opção binária, porque o ternário é supostamente mais difícil de implementar (embora seja "mais difícil" adicionar algumas ou três linhas extras ao algoritmo), e o ganho de velocidade é mínimo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificar por pilha n-heap :: N-narny heapsort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, você não pode parar por aí e adaptar a classificação por vários grupos para qualquer número de descendentes. Talvez se você continuar aumentando o número de descendentes, poderá aumentar significativamente a velocidade do processo? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ésimo elemento dos índices da matriz (se a contagem de zero), seus </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> descendentes computaram de maneira muito simples: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1º descendente: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2º descendente: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3º descendente: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nésimo descendente: </font><font style="vertical-align: inherit;">
código </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + N </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python para classificação por um N-heap:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#      N </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NHeapSort</span>(<span class="hljs-params">data</span>):</span><font></font>
<font></font>
    n = <span class="hljs-number">3</span> <span class="hljs-comment">#    </span><font></font>
<font></font>
    <span class="hljs-comment">#    </span>
    <span class="hljs-comment">#   -   </span>
    <span class="hljs-comment"># (   )       </span>
    <span class="hljs-keyword">for</span> start <span class="hljs-keyword">in</span> range(len(data), <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):<font></font>
        NHeapSift(data, n, start, len(data) - <span class="hljs-number">1</span>) <font></font>
<font></font>
    <span class="hljs-comment">#        </span>
    <span class="hljs-comment">#        .</span>
    <span class="hljs-keyword">for</span> end <span class="hljs-keyword">in</span> range(len(data) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>): 
        <span class="hljs-comment">#       </span>
        <span class="hljs-comment">#    </span>
        data[end], data[<span class="hljs-number">0</span>] = data[<span class="hljs-number">0</span>], data[end]
        <span class="hljs-comment">#        </span>
        <span class="hljs-comment">#   </span>
        <span class="hljs-comment">#     </span>
        NHeapSift(data, n, <span class="hljs-number">0</span>, end - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> data<font></font>
    <font></font>
<span class="hljs-comment">#  -     N </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NHeapSift</span>(<span class="hljs-params">data, n, start, end</span>):</span><font></font>
    <font></font>
    <span class="hljs-comment">#   - ,     </span><font></font>
    root = start <font></font>
<font></font>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
        <font></font>
        <span class="hljs-comment">#   (    )</span>
        <span class="hljs-comment">#   </span>
        child = root * n + <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> child &gt; end: 
            <span class="hljs-keyword">break</span> <font></font>
<font></font>
        max = child<font></font>
        <font></font>
        <span class="hljs-comment">#    </span>
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<font></font>
            current = root * n + k<font></font>
            <span class="hljs-keyword">if</span> current &gt; end:
                <span class="hljs-keyword">break</span><font></font>
                <font></font>
            <span class="hljs-keyword">if</span> data[current] &gt; data[max]:<font></font>
                max = current<font></font>
        <font></font>
        <span class="hljs-comment">#     </span>
        <span class="hljs-comment">#        </span>
        <span class="hljs-comment">#  </span>
        <span class="hljs-keyword">if</span> data[root] &lt; data[max]:<font></font>
            data[root], data[max] = data[max], data[root]<font></font>
            root = max<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, mais não significa melhor. </font><font style="vertical-align: inherit;">Se você levar a situação ao limite e levar N descendentes para uma matriz de N elementos, a classificação por vários degrada para de acordo com a escolha usual. </font><font style="vertical-align: inherit;">Além disso, também será uma versão piorada da classificação por seleção, porque serão executados gestos sem sentido: a peneiração primeiro colocará o máximo em primeiro lugar na matriz e, em seguida, enviará o máximo até o fim (na classificação de seleção, o máximo será enviado imediatamente ao final). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se a pilha ternária ultrapassar minimamente o binário, o quádruplo já estará perdendo. </font><font style="vertical-align: inherit;">Encontrar o máximo de descendentes entre vários torna-se muito caro.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trailer da próxima série</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, a principal desvantagem do binário / ternário / n-heap é que a incapacidade de saltar em sua complexidade é maior que </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">A saída do impasse é usar variedades de heap mais sofisticadas na classificação. </font><font style="vertical-align: inherit;">Em uma semana, vamos nos familiarizar com o que Edsger Dijkstra pensa sobre isso.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><div style="text-align:center;"><img width="627" height="475" src="https://habrastorage.org/webt/qi/dn/w-/qidnw-xsewiihfsqbr8ajkj4jhi.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clique na animação para ir ao artigo com a seguinte classificação por vários</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referências</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilha</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pirâmide</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artigos da série:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplicativo Excel AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificações de Câmbio</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificações de inserção</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificar por seleção</font></font></a><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipos de pilhas: N-pirâmides</font></font></b></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificações da pilha: números de Leonardo</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificação de heap: heap fraco</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipos de Cacho: Árvore Cartesiana</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outras classificações de pilha: pilha de espelhos, mini-pilha, peneiração de baixo para cima</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipos de Heap: Jung Heap</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesclar classificações</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificar por distribuição</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classificação híbrida</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O aplicativo AlgoLab adicionou a classificação por n-heap. </font><font style="vertical-align: inherit;">Para selecionar o número de descendentes, no comentário na célula desse tipo, você precisa especificar um número para n. </font><font style="vertical-align: inherit;">O intervalo de valores possíveis é de 2 a 5 (não faz mais sentido, porque para n&gt; = 6, a animação com três níveis de aninhamento em uma escala normal não é garantida para caber na tela).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt495408/index.html"># 02 - E um byte inteiro não é suficiente ... | A cruz das mudanças</a></li>
<li><a href="../pt495412/index.html">Norbert Wiener. Uma pessoa interessante. Colegas, inimigos, luta pela independência</a></li>
<li><a href="../pt495414/index.html">Consequências do medo</a></li>
<li><a href="../pt495416/index.html">pipeplot - visualização interativa do fluxo de dados do pipe no console</a></li>
<li><a href="../pt495418/index.html">Loja online Blazor Client Side: Parte 4 - Adicionar itens ao carrinho</a></li>
<li><a href="../pt495422/index.html">Profissão: Desenvolvedor Mobile</a></li>
<li><a href="../pt495432/index.html">Singleton com armadilhas</a></li>
<li><a href="../pt495434/index.html">O que aconteceu com o transporte nas últimas duas semanas</a></li>
<li><a href="../pt495436/index.html">Abrimos o acesso ao curso prático sobre como trabalhar com o sistema DLP</a></li>
<li><a href="../pt495438/index.html">Linguagem R para usuários do Excel (curso em vídeo gratuito)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>