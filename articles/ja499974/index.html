<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏻 🎷 💌 Instagram JavaScriptの3Dゲーム、またはソーセージの飛行経路 🥀 🎦 💅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instagramのマスクでのゲームプログラミングに関する最初の記事の後で、ある顧客から、ピザ屋用にInstagramでゲームを作成するように依頼されました。このゲームは、ビジネスの宣伝目的で使用するように計画されました。もちろん、最初の記事の閲覧数から判断すると、InstagramのテーマはHab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Instagram JavaScriptの3Dゲーム、またはソーセージの飛行経路</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499974/"><img src="https://habrastorage.org/webt/gl/zq/2a/glzq2aogs8xde9o1cauyy8qc838.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Instagramのマスクでのゲームプログラミングに関する最初の記事の後で、ある顧客から、ピザ屋用にInstagramでゲームを作成するように依頼されました。このゲームは、ビジネスの宣伝目的で使用するように計画されました。もちろん、最初の記事の閲覧数から判断すると、InstagramのテーマはHabrコミュニティにとって特に興味深いものではないことは理解しています。どうやら、このサービスはまだブロンドのための軽薄な娯楽の一種と考えられており、それに関する記事はイブニングカクテルの金曜日の読書としてのみ適しています。しかし、今日は金曜日だけです。カクテルをどうぞ。そしてブロンドを招待することを忘れないでください。ただし、将来的には、GTA-5でInstagramでプレイを開始するほどの高さになる可能性があります。または10。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、同時に2つのゲームについて説明します。</font><font style="vertical-align: inherit;">私は注文するために1つを作り、次に自分用に2つ目を作りました。</font><font style="vertical-align: inherit;">新しいゲームのたびに、私は新しいタスクに直面しました。解決策を探すことで、開発の新しいニュアンスに慣れることができました。</font><font style="vertical-align: inherit;">おそらく、このストーリーは拡張現実の要素の他の開発者にとって役立つでしょう。</font><font style="vertical-align: inherit;">ゲームは、追加のライブラリを使用せずに純粋なJavascriptで記述されています。</font><font style="vertical-align: inherit;">3Dグラフィックスを表示するには、組み込みのInstagramツールを使用します。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム1.ピザ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だから、最初のゲームの本質は何ですか。回転するピザ。コンポーネントはその表面から飛び散ります-ソーセージ、トマトなどの破片。 2人のプレーヤーは自分の口をキャッチする必要があります。勝者は、ご想像のとおり、より多くをキャッチする人です。時間の経過とともに、回転速度は増加します。私にとってこのゲームで最もおもしろいのは、これらの食用要素の飛行経路をプログラミングすることでした。ソーセージフライトのプログラミングを想像してみてください。いいえ、間違いなく、これほど楽しいプログラミングをしたことがありません。今でも笑ってこの記事を書いています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
お客様がプロトタイプが機能しているのを見たとき、「:)）」と送ってくれました。最終結果のテスト中に問題が発生しました。それは、被験者がゲームをプレイすることができなかったという事実にありました：彼らは単に笑いに溢れていました-それはとても楽しかったです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
思い出していただきたいのですが、マスクとゲームの開発はSpark AR Studioで行われます。そして、そこからあなたの作品をInstagramにアップロードして、誰でも見ることができます。開発者にとって、Webテクノロジーがオペレーティングシステム間の境界をぼかしていることは注目に値します。 1つのコードを記述します。このコードは、変更や変更を加えることなく、iOSとAndroidの両方のInstagramアプリケーションで機能します。もちろん、これに対する支払いはスクリプトの速度が根本的に低くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームのスケジュールはお客様から提供されました。 3Dモデルにはいくつかの問題がありました。特に、組み込みのアニメーションエンジンSpark AR Studioを使用する場合、移動するオブジェクトがスケーリングされると、その座標がゲーム内で誤って決定されることがわかりました。ただし、オブジェクト全体を完全にスケーリングせず、各メッシュを個別にスケーリングしない場合、この厄介な効果は見られません。私はピザのスケールを1：1のままにし、それを構成する各要素に特定の係数を指定する必要がありました。 Instagramゲームのモデルをエクスポートする必要があるFBX形式にも問題がありました。グラフィックデザイナーは、組み込みのテクスチャを持つモデルを送信しました。さらに、テクスチャは相対パスに沿って配置されました。 3Dエディターはそれらを見ましたが、Spark ARは見ませんでした。テクスチャファイルがモデルとは別に、1つのパスに沿って配置されるように、モデルを再パックする必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、私が遭遇したもう1つの小さな問題は、画面にテキストを表示することを担当するAPI Saprk ARオブジェクトが、値を値として受け入れることを拒否したことです-たとえば、ゲームのスコア。</font><font style="vertical-align: inherit;">何も表示されない理由が長い間わかりませんでした。</font><font style="vertical-align: inherit;">何が悪いのですか？</font><font style="vertical-align: inherit;">まず、数値を文字列（.toString（））に変換する必要があることがわかりました。</font><font style="vertical-align: inherit;">これは他の言語については言うまでもありませんが、常にこれ自体を行ってきたjavascriptについてはむしろ非定型です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シンプルなアニメーション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このゲームで私にとって新しいことの1つは、3Dオブジェクトのアニメーションをプログラミングすることでした。 （以前のInstagramゲーム「Tic-Tac-Toe」では、アニメーションはまったくありませんでした。）Spark AR Studioのアニメーションエンジンは非常に特殊です。これは、いくつかの入力パラメーターを受け取り、変数を何かを変更したいオブジェクトに反応的に接続します。たとえば、これは、時間tの経過とともに、いくつかの3Dオブジェクトのy座標（startValue、endValue-その初期値と最終値）を変更します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> driverParameters = {
    <span class="hljs-attr">durationMilliseconds</span>: t,
    <span class="hljs-attr">loopCount</span>: <span class="hljs-literal">Infinity</span>,
    <span class="hljs-attr">mirror</span>: <span class="hljs-literal">false</span><font></font>
};<font></font>
<span class="hljs-keyword">var</span> driver = Animation.timeDriver(driverParameters);
<span class="hljs-keyword">var</span> sampler = Animation.samplers.linear(startValue, endValue);<font></font>
sceneObject.transform.y = Animation.animate(driver, sampler);<font></font>
driver.start();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
飛んでくるピザの材料を動かすために、座標ごとに3つのアニメーションを並行して実行することにしました。初期座標（startValue）とピザの回転角度（endValue）から計算された最終座標を示すのに十分なため、プレイヤーが口でこの「シェル」を捕まえなかった場合に、それは遠く離れた場所にありました。引っ掛かった場合-動きが停止します。前回の記事で説明した開口イベント。ここでのみ2人用のゲームがあり、したがって、すでに2つの顔と2つの口があります。</font></font><br>
<br>
<pre><code class="javascript hljs">FaceTracking.face(<span class="hljs-number">0</span>).mouth.openness.monitor().subscribe(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-keyword">if</span> (event.newValue &gt; <span class="hljs-number">0.2</span>) {<font></font>
        ...<font></font>
    };<font></font>
});<font></font>
<font></font>
FaceTracking.face(<span class="hljs-number">1</span>).mouth.openness.monitor().subscribe(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-keyword">if</span> (event.newValue &gt; <span class="hljs-number">0.2</span>) {<font></font>
        ...<font></font>
    };<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このゲームの重要なポイントは、飛んでいる材料を口で捕まえることです。つまり、人の口の中心付近の特定の小さな領域で飛んでいる物体を見つけることです。</font><font style="vertical-align: inherit;">最初は、この計算は正しく行われることを望んでいませんでしたが、口の座標に関連付けられた非表示オブジェクトの導入後に問題の解決策が見つかり、それが機能しました。</font><font style="vertical-align: inherit;">どういうわけか、口の直接の座標は戻りませんでした。</font><font style="vertical-align: inherit;">ここで、cameraTransform.applyToは、顔の点の座標を3Dワールドの座標に換算したものです（メソッドはドキュメントから取得されます）。</font></font><br>
<br>
<pre><code class="javascript hljs">move: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//   (   )</span><font></font>
<font></font>
    <span class="hljs-comment">//    </span>
    <span class="hljs-keyword">var</span> object = Scene.root.find(<span class="hljs-string">'pizzafly'</span>);
    <span class="hljs-keyword">var</span> olast = {
        <span class="hljs-attr">x</span>: object.transform.x.pinLastValue(),
        <span class="hljs-attr">y</span>: object.transform.y.pinLastValue(),
        <span class="hljs-attr">z</span>: object.transform.z.pinLastValue()<font></font>
    };<font></font>
<font></font>
    <span class="hljs-comment">//   ,       </span>
    <span class="hljs-keyword">var</span> objectHidden = Scene.root.find(<span class="hljs-string">'nullObject'</span>);<font></font>
    objectHidden.transform.x = FaceTracking.face(face).cameraTransform.applyTo(FaceTracking.face(face).mouth.center).x;<font></font>
    objectHidden.transform.y = FaceTracking.face(face).cameraTransform.applyTo(FaceTracking.face(face).mouth.center).y;<font></font>
    objectHidden.transform.z = FaceTracking.face(face).cameraTransform.applyTo(FaceTracking.face(face).mouth.center).z;<font></font>
<font></font>
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">var</span> mouth = {
        <span class="hljs-attr">x</span>: objectHidden.transform.x.pinLastValue(),
        <span class="hljs-attr">y</span>: objectHidden.transform.y.pinLastValue(),
        <span class="hljs-attr">z</span>: objectHidden.transform.z.pinLastValue()<font></font>
    };<font></font>
<font></font>
    <span class="hljs-comment">//    </span>
    <span class="hljs-keyword">var</span> d = {
        <span class="hljs-attr">x</span>: <span class="hljs-built_in">Math</span>.abs(olast.x - mouth.x),
        <span class="hljs-attr">y</span>: <span class="hljs-built_in">Math</span>.abs(olast.y - mouth.y),
        <span class="hljs-attr">z</span>: <span class="hljs-built_in">Math</span>.abs(olast.z - mouth.z)<font></font>
    };<font></font>
<font></font>
    <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">if</span> ((d.x &gt; <span class="hljs-number">0.03</span>) || (d.y &gt; <span class="hljs-number">0.03</span>) || (d.z &gt; <span class="hljs-number">0.03</span>)) {
        <span class="hljs-comment">// </span><font></font>
        ...<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// </span><font></font>
        ...<font></font>
    };<font></font>
<font></font>
},<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、この特定のゲームでは視覚的に深度を推定することが難しいため、深度チェック（z座標）を削除する必要があることに気付きました。</font><font style="vertical-align: inherit;">つまり、飛行中いつでも口を開けて食材を捕まえることができるようになりました。</font><font style="vertical-align: inherit;">主なものは、xとyの組み合わせです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nw/v9/dw/nwv9dwt-p5wip4yhnnhtirudgoe.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、このゲームの作成中に遭遇した最後の問題は、最終ビルドのサイズを4 MBに制限することでした。また、Facebookの推奨によると、できるだけ多くの携帯端末でゲームを表示するためには、2MBでも収まることが望ましい。また、3Dモデラーはクリエイティブな人々であり、密集したグリッドと巨大なテクスチャーを備えた重いモデルを作りたいと思っています。私たち、プログラマー、またはゲームの最終的なパフォーマンスをまったく気にしません。また、テクスチャを縮小してjpg（pngではなく）で圧縮しましたが、ピザモデル自体を修正（トポロジー）のために送信する必要がありました。その結果、それにもかかわらず、すべてのモデル、テクスチャ、およびスクリプトで2MBのボリュームに収めることができました。そしてゲームは節度を増しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてしばらくして、彼女は「効果には静的テキストが多すぎる」という文言を返しました。</font><font style="vertical-align: inherit;">私はカウントダウン番号を削除する必要があり、代わりにアニメーションをストップウォッチの矢印に設定しました。ストップウォッチは現在ではなく、時間をカウントし始めました。</font><font style="vertical-align: inherit;">その後、ゲームは承認されました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲーム2.蝶について（ButterFlap）</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/dt/63/wddt63fejsxelpizwyffhzw5zig.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、2番目のゲームの作成について説明します。私はゲームを作るのを手伝うことができません、これは私の趣味です。 3月8日の数日前に、この休暇用にInstagramゲームを作成することにしました。花、蝶、お菓子について。でも、ゲームの本質が何なのか考えられませんでした。その考えは私の頭の中で回転しました。たぶん、蝶はキャンディーを集めてバスケットに入れますか？または、蝶がお菓子を空中に拾って投げ、プレーヤーが口でそれらを捕まえる必要があるでしょうか？一般的に、私は数日間混乱しましたが、解決策が見つからなかったため、3月8日までにゲームがモデレートする時間がないことに気付きました。後者は3〜4日かかるためです。突然、アイデアが突然生まれたとき、私はすでにこのベンチャーを離れたいと思っていました。私はもはやゲームを女性の日と結び付けていませんでした、今それはただのゲームでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スクローラー。</font><font style="vertical-align: inherit;">左から右へ、風景や様々な障害物が移動します。</font><font style="vertical-align: inherit;">プレイヤーは、画面内を自由に移動できる蝶を操り、宙に舞うダイヤモンドを集めなければなりません。</font><font style="vertical-align: inherit;">また、右から左に向かって、写真の残りの部分より少し速く、雲が移動しており、そこから雨が降っています。</font><font style="vertical-align: inherit;">花の下で雨から身を隠す必要があります。</font><font style="vertical-align: inherit;">蝶が水に落ちると、羽が濡れて落ち、これでゲームは終了です。</font><font style="vertical-align: inherit;">私は単にゲームを呼び出しました：ButterFlap。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、これはすべていいですね。</font><font style="vertical-align: inherit;">私は直接、自分で遊びたかった。</font><font style="vertical-align: inherit;">でも、自分はアーティストではないことを思い出しました。</font><font style="vertical-align: inherit;">しかし、私は3Dモデルを作成することができ、これは描画より簡単です。</font><font style="vertical-align: inherit;">そこで、3Dスクローラーを作ってみることにしました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グラフィックアート</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は改良しなければならなかったオンラインのロイヤリティフリーモデルを見つけました。彼は以前にテクスチャアトラスにテクスチャを配置していた、テクスチャのないものにテクスチャをプルしました。「ラダー」の形式のアーティファクトは非テクスチャモデルに表示され、ゲーム内のテクスチャにスムージングを設定できます。これにより、オブジェクトの外観がより見やすく、それほど平坦ではなくなります。テクスチャを含むこれらのモデルにも、修正が必要な欠陥がありました。まず、テクスチャのサイズが2の倍数ではありませんでした。つまり、たとえば、1200x1200になる可能性があります。 1024x1024に圧縮する必要がありました。ビデオプロセッサは、1024x1024、512x512、256x256などではない、空のスペースで不適切なテクスチャをスケーリングまたは埋めることができます。いずれにしても、そのようなアクションはゲームの作業中の余分な負荷であり、意味のないメモリ消費です。したがって、最初に手動で正しい画像を準備することをお勧めします。この状況は、すべてのテクスチャをテクスチャアトラスで配布したことによっても救われたので、たとえば、元のテクスチャのサイズが400x200ピクセルの場合、アトラス1024x1024に、他の同様のテクスチャの横にそのまま配置できます。この後、当然ながらUVスキャンもスケーリングする必要がありますが、これは数秒で完了します。それでも、何らかの理由でテクスチャが「C：\ Work \ Vasya \ Map.jpg」などの絶対パスに沿って結び付けられているモデルのバリアントに遭遇しました。私のコンピューターにはそのようなフォルダーはありません！テクスチャへのパスを手動で指定する必要がありましたが、すべてのプロジェクトを「C：」ドライブに保持する必要があるという考えが浮かんだのはなぜですか。ああ、これらのモデラー、無料のアーティスト...ちなみに、このように、ランダムに左のパスにあるフォルダーの名前によって、モデラーのアイデンティティについて誤って学ぶことができます。たとえば、彼の名前。はじめまして！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も難しいのは、アニメーション付きの適切なバタフライモデルを見つけることでした。 Spark ARは、任意の3DエディターからFBX形式にエクスポートできるアニメーションを使用します。私がダウンロードした2組の蝶モデルの翼は、どういうわけか奇妙にミラーリングされました-1つの翼がモデル化され、2つ目の翼は私が理解できない何らかの方法で反映されたため、2つが判明しました。このモデリングへのアプローチでは、最終的に、ゲームでは、翼の1つ（コピーされた）が光源からの光を受け取りたくないため、常に薄暗いままでした。アニメーションが飛んでいたので、モデルを大幅に変更するリスクはありませんでした。アニメーションでは、3Dモデリングよりもさらに大きな初心者です。おそらく問題は別の問題でした。たとえば、法線を拡張しようとしましたが、それは役に立ちませんでした。つまり、無料の3Dモデルは面倒です。その結果、一晩中洗ったので、試行錯誤の結果、適切なモデルが見つかりました。ファイルを微調整したところ、問題のないように見えました。気に入らない点はありましたが、それはささいなことでした。テクスチャをやり直し、場所によってジオメトリを変更し、マテリアルパラメータを調整しました。最後に、蝶が離陸しました。やったーしかし、今私は疲れきっています。だから私は就寝して翌日続けることにしました。はい、ゲームの作成に7〜8日を費やしました。しかし、夕方には、ドキュメントや記事を読んだり、質問への回答を見つけたりするなど、かなりゆったりとした作業でした。それで私は就寝して翌日続けることにしました。はい、ゲームの作成に7〜8日を費やしました。しかし、夕方には、ドキュメントや記事を読んだり、質問への回答を見つけたりするなど、かなりゆったりとした作業でした。それで私は就寝して翌日続けることにしました。はい、ゲームの作成に7〜8日を費やしました。しかし、夕方には、ドキュメントや記事を読んだり、質問への回答を見つけたりするなど、かなりゆったりとした作業でした。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rr/zb/iy/rrzbiyezloccrjo_egas613ltry.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
翌日の夜はずっとグラフィックの作業をしていました。すでに述べたように、Instagramのゲームマスクの特徴は、ゲーム全体で2 MBのボリューム（最大4 MB）を超えないようにすることをお勧めします。スクリプトについては心配していませんでした。そのサイズは50 KBを超えることはほとんどありません。しかし、植物の3Dモデル以上はかなり手品でなければなりませんでした。たとえば、ヒマワリの種が配置されている部分は、ジオメトリによって作成されました。何百ものポリゴン...数十の三角形の球のフラグメントに置き換え、実際にダウンロードされたこの部分のテクスチャを引き伸ばします。葉の数も減らすことができます。シーンの最下部に草を作成し、2つの三角形の平面に、アルファチャネルのあるテクスチャを重ねます。影でボリュームに到達し、テクスチャ自体の中に画像の断片をコピーします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、テクスチャの数とサイズ（バイト単位）を最小限に抑えることが望まれます。</font><font style="vertical-align: inherit;">ゲームの大部分を作成するのはテクスチャです。</font><font style="vertical-align: inherit;">透明度が必要なテクスチャ、1つのテクスチャアトラス（png 32ビット）に配置されたテクスチャ、アルファチャネルを使用しないテクスチャ、別のアトラスにパックしてjpgに保存することに慣れています。</font><font style="vertical-align: inherit;">Jpgはpngよりも強力に縮小できます。</font><font style="vertical-align: inherit;">透明度を必要とする草とUI要素はpngアトラスに、その他はすべてjpgに移動しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
総量。</font><font style="vertical-align: inherit;">計4種類の植物、岩、プレイヤーが操作する蝶、そして雲を手に入れました。</font><font style="vertical-align: inherit;">圧縮形式のこれらすべてのモデルのテクスチャは、2つのアトラス1024x1024 jpgとpngを使用し、総容量は500 Kbでした。</font><font style="vertical-align: inherit;">モデル自体は約200 Kbかかりました。</font><font style="vertical-align: inherit;">プラススクリプト。</font><font style="vertical-align: inherit;">サウンド-31 Kb。</font><font style="vertical-align: inherit;">合計：約1 Mb。</font><font style="vertical-align: inherit;">緑色で、ビルドのサイズが表示されます（これは2 MBに収まるはずです）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ak/7r/c1/ak7rc1e09ycyaee13ypwnokgeqm.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
突然、私は完全に予期しない問題に遭遇しました。</font><font style="vertical-align: inherit;">未使用のモデルをいくつか削除しましたが、Spark AR Studioではなく、ファイルシステムから削除しました。</font><font style="vertical-align: inherit;">その後、ビルドをアセンブルすると、Spark AR Studioシーンから消えてしまいましたが、まだアセンブリに入っていました。</font><font style="vertical-align: inherit;">そして、未使用のリソースからプロジェクトをクリアすることは不可能です。</font><font style="vertical-align: inherit;">「アセットサマリー」からのリンクはどこにもつながりません。</font><font style="vertical-align: inherit;">どうやら、これはSpark AR Studioの欠陥です。</font><font style="vertical-align: inherit;">最初からプロジェクトを再作成し、必要なリソースをすべて追加する必要がありました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は長い間、画面上のすべてのオブジェクトのスクロールを実装する方法について考えてきました。</font><font style="vertical-align: inherit;">このためのツールのうち、Spark AR StudioにはJavaScriptと最も単純な組み込みのアニメーションエンジンしかありません。これは、オブジェクトの座標を特定の時間内に初期値から最終値に変更するだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、まだこの前にジレンマが発生しました：ゲームのシーン全体をスクロールするため、または各3Dのコピーを1つだけロードするために、繰り返しの植物を必要な回数複製して正しい位置に配置することにより、ゲームのレベル全体、3Dエディターでシーンを作成するかどうかオブジェクトの代わりに、画面のすぐ外側のプレーヤーの方向に置き換えます。答えは明白でした。私たちの選択は2番目のオプションです。それ以外の場合は、2 MBに収めることは絶対に不可能です。おそらく、最初のオプションによるシーンは重くなります。ただし、オブジェクトのレイアウトが必要です。そして私はためらうことなく、3Dエディターをレベルエディターとして使用することにしました。ええ、私は両方をしたことがわかりました。ゲーム用の植物は、それぞれを1つのコピーに保存しました。エディターからは座標のみが必要でした。仕事が終わったらすべてのオブジェクトの座標を書き出し、ゲームのデータで配列を作成しました。</font></font><br>
<br>
<pre><code class="javascript hljs">lv:[<font></font>
    {<span class="hljs-attr">n</span>:<span class="hljs-string">'flower1'</span>, <span class="hljs-attr">x</span>:<span class="hljs-number">8.0</span>, <span class="hljs-attr">y</span>:<span class="hljs-number">-6.5</span>},<font></font>
    {<span class="hljs-attr">n</span>:<span class="hljs-string">'cloud'</span>, <span class="hljs-attr">x</span>:<span class="hljs-number">10.0</span>, <span class="hljs-attr">y</span>:<span class="hljs-number">0.1</span>},<font></font>
    {<span class="hljs-attr">n</span>:<span class="hljs-string">'rain'</span>, <span class="hljs-attr">x</span>:<span class="hljs-number">10.0</span>, <span class="hljs-attr">y</span>:<span class="hljs-number">6.6</span>},<font></font>
    {<span class="hljs-attr">n</span>:<span class="hljs-string">'flower1'</span>, <span class="hljs-attr">x</span>:<span class="hljs-number">14</span>, <span class="hljs-attr">y</span>:<span class="hljs-number">-2.5</span>},<font></font>
    {<span class="hljs-attr">n</span>:<span class="hljs-string">'diamond_red'</span>, <span class="hljs-attr">x</span>:<span class="hljs-number">20</span>, <span class="hljs-attr">y</span>:<span class="hljs-number">2.0</span>},<font></font>
	...<font></font>
],</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、オブジェクトのタイプに応じた個別の連想配列。コライダーのサイズと3Dオブジェクトの中心を基準にしたそれらの変位、およびオブジェクトが障害物であるかどうかを決定するフラグ（col）が格納されます（それ以外の場合は、プレイヤーがオブジェクトを通過します）。</font><font style="vertical-align: inherit;">一部のタイプのオブジェクトでは、（破棄）フラグが設定されています。これは、相互作用後にオブジェクトを非表示にするかどうかを決定します。（v）パラメーターは、ある程度の相互作用を決定します。たとえば、プレーヤーが獲得または失うポイントの数などです。</font></font><br>
<br>
<pre><code class="javascript hljs">colld:{
    <span class="hljs-string">'flower1'</span>: {<span class="hljs-attr">dx</span>:<span class="hljs-number">0</span>, <span class="hljs-attr">dy</span>:<span class="hljs-number">5</span>, <span class="hljs-attr">w</span>:<span class="hljs-number">2.3</span>, <span class="hljs-attr">h</span>:<span class="hljs-number">1.4</span>, <span class="hljs-attr">col</span>:<span class="hljs-literal">true</span>},
    <span class="hljs-string">'diamond_green'</span>: {<span class="hljs-attr">dx</span>:<span class="hljs-number">0</span>, <span class="hljs-attr">dy</span>:<span class="hljs-number">0</span>, <span class="hljs-attr">w</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">h</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">col</span>:<span class="hljs-literal">false</span>, <span class="hljs-attr">v</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">destroy</span>:<span class="hljs-literal">true</span>},
    <span class="hljs-string">'diamond_red'</span>:{<span class="hljs-attr">dx</span>:<span class="hljs-number">0</span>, <span class="hljs-attr">dy</span>:<span class="hljs-number">0</span>, <span class="hljs-attr">w</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">h</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">col</span>:<span class="hljs-literal">false</span>, <span class="hljs-attr">v</span>:<span class="hljs-number">-2</span>},<font></font>
<font></font>
    ...<font></font>
},</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少しニュアンス。</font><font style="vertical-align: inherit;">シーンの下部にある草は、連続的にスクロールする必要があります。</font><font style="vertical-align: inherit;">したがって、このオブジェクトの2つのコピーを使用し、移動するときに次々にそれらを置き換える必要があります。</font><font style="vertical-align: inherit;">花は、1つの画面にそれぞれ1つのコピーで表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のゲームの開発時に発生したスケールの問題を念頭に置いて、3Dエディターですべてのモデルのスケールをリセットしました。したがって、Saprk ARモデルでは、通常のサイズですぐに読み込まれます。確かに、スクリプトではとにかく、「マジックナンバー」、グローバル係数、宇宙のエッセンスを含むユニバーサルコードなしでは実現できませんでした。もちろん仮想宇宙。そして、私はあなたにこの数を明らかにする準備ができています。それを使ってください、人々！私は気にしません！この数は0.023423です。つまり、すべてのスケールがリセットされたにもかかわらず、3Dエディターの1メートルは、Spark AR Studioのこの数値と同じであることがわかりました。ほとんどの場合、私はそれにもかかわらず、3Dグラフィックスでの作業の複雑さ、つまり係数を完全には理解していません。エディタからエクスポートされたすべてのオブジェクトの座標（サイズではありません）に乗算されます。Spark ARでシーンのスケールを調整する場所が見つかりませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に遭遇した問題は、3Dエディターからエクスポートするときにオブジェクトのソート順が失われることでした。</font><font style="vertical-align: inherit;">複数のメッシュで構成される複雑なオブジェクトは、ゲーム内のシーンに予期せず表示される可能性があります。たとえば、別のメッシュの背後にあるメッシュが突然前方にジャンプしたような場合です。</font><font style="vertical-align: inherit;">また、Spark AR Studioにエクスポートした後でオブジェクトの順序を見ると、実際には、このメッシュはリストではいくらか上位にありますが、エディターでは低いことがわかります。</font><font style="vertical-align: inherit;">この問題を解決するには、シーンをレイヤーに分割して別のファイルに保存します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複雑なアニメーション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに3晩は、プログラミングをいじっていました。標準のSpark AR Studioエンジンを使用して蝶の羽をアニメーション化した場合、背景を移動する作業はそれほど簡単ではありませんでした。私はまだ、モーションサイクルの反復に1つの変数パラメーターだけでなく、本格的なコールバック関数をアタッチする方法を理解していませんでした。いずれにせよ、私はそれを行うことができませんでした。現在のアニメーションパラメータはそこに転送されたくありませんでした。そして、このような機能が必要なのは、最初のゲーム（ピザあり）で、サブスクライブして口を開くイベントによる衝突をチェックした場合、ここではそのようなイベントはなかったためです。そして、現在の座標に従って、キャラクターが動くときに環境オブジェクトとの衝突をチェックするだけで済みました。このため、座標は各反復で比較する必要があります。そして私は思いました。結局、私はすでにjavascriptでゲームを書いています。そして、それらのゲームのために先に書いたアニメーションエンジンを使用してみませんか？その動作原理はほぼ同じです。特定の時間内に、パラメータ（1つまたは複数）は特定の初期値と最終値の間で変化します。そして、現在の値はパラメーターとして渡されます-信じられないでしょう-たとえば、これらの現在の値に等しい座標でシーンの3Dオブジェクトを設定したり、それらの衝突をチェックしたりすることができるコールバック関数です。ありがとう、キャップ。私は自分のエンジンをローカルの「エコシステム」に少し適応させる必要がありました。そこからwindowオブジェクトへの参照を削除します。これはここにないためです。そして、現在の値はパラメーターとして渡されます-信じられないでしょう-たとえば、シーンの3Dオブジェクトをこれらの現在の値と等しい座標に設定したり、それらの衝突をチェックしたりすることができます。ありがとう、キャップ。エンジンをローカルの「エコシステム」に少し適合させる必要がありました。ここにはウィンドウオブジェクトがないため、そこからウィンドウオブジェクトへの参照を削除します。そして、現在の値はパラメーターとして渡されます-信じられないでしょう-たとえば、シーンの3Dオブジェクトをこれらの現在の値と等しい座標に設定したり、それらの衝突をチェックしたりすることができます。ありがとう、キャップ。エンジンをローカルの「エコシステム」に少し適合させる必要がありました。ここにはウィンドウオブジェクトがないため、そこからウィンドウオブジェクトへの参照を削除します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、まだ-環境の風景とオブジェクトのスクロールについて。全世界を1つのNullObject、つまり空の3Dオブジェクトであるコンテナーに配置し、アニメーションの1つのパラメーター（x座標）だけを使用して移動することにしました。コンテナの内部では、すべてのモデルが外部にあるかのように同じ座標を持ちます。ここでのみ、参照システムはこの空のオブジェクトに関連付けられます。岩と花は繰り返されます（さらに、レベルダイアグラムに従って、地面からの異なる高さで）。これらのオブジェクトを移動しながら再利用して、「コンテナ」内の目的の水平および垂直位置に設定できます。フレームに入るオブジェクトの検索システムを（現在のコンテナーオフセットで）作成しました。これにより、フレームから離れるオブジェクトを新しい位置に設定する必要があります。あなたは見ることができます、3つのオブジェクトの例でどのように機能するか。 （ゲームにはそれらの数が増えるため、環境オブジェクトの「再配置」のそのような効果はもう見られません。）</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/f3i72svxLHM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトの座標を更新する関数は次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs">oCoordSet: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
    <span class="hljs-comment">//  :    </span>
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">var</span> camx = -ap.oWorld.transform.x.pinLastValue();
    <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">var</span> x1 = camx - ap.game.scro.w2;
    <span class="hljs-keyword">var</span> x2 = camx + ap.game.scro.w2;
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ap.d.lv.length; i++) {
        <span class="hljs-comment">//    </span>
        <span class="hljs-keyword">if</span> ((ap.d.lv[i].x &gt;= x1) &amp; (ap.d.lv[i].x &lt;= x2)) {
            <span class="hljs-comment">//   </span><font></font>
            ap.d.lv[i].o = Scene.root.find(ap.d.lv[i].n);<font></font>
            <span class="hljs-comment">//  -  </span><font></font>
            ap.d.lv[i].o.transform.y = ap.d.lv[i].y;<font></font>
            <span class="hljs-keyword">if</span> ((ap.d.lv[i].n == <span class="hljs-string">'cloud'</span>) || (ap.d.lv[i].n == <span class="hljs-string">'rain'</span>)) {
                <span class="hljs-comment">//    ,</span>
                <span class="hljs-comment">//  </span>
                <span class="hljs-comment">//   2.3,</span>
                <span class="hljs-comment">//     </span>
                ap.d.lv[i].o.transform.x = ap.d.lv[i].x - (x2 - ap.d.lv[i].x) * <span class="hljs-number">2.3</span> + <span class="hljs-number">0.2</span>;<font></font>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">//    ,</span>
                <span class="hljs-comment">//      </span><font></font>
                ap.d.lv[i].o.transform.x = ap.d.lv[i].x;<font></font>
            };<font></font>
        };<font></font>
    };<font></font>
    <span class="hljs-comment">//        </span>
    <span class="hljs-comment">//     </span>
    <span class="hljs-keyword">if</span> (camx &gt; ap.game.grassPosLast) {<font></font>
        ap.game.grassPosLast += ap.game.grassd;<font></font>
        ap.game.grassi = <span class="hljs-number">1</span> - ap.game.grassi;<font></font>
        ap[ap.game.grassNm[ap.game.grassi]].transform.x = ap.game.grassPosLast;<font></font>
    };<font></font>
},</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主人公</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームの主人公は沈むことができない蝶であり、大胆に前へ飛び、障害を乗り越えます。</font><font style="vertical-align: inherit;">頭を回したり傾けたりしてマーカーやカーソル（光点）を設定して管理することにしました。</font><font style="vertical-align: inherit;">そして、このポイントの方向では、蝶はゆっくり飛んでいきます（実際、それは戦闘機ではなく、テレポートすることもできません）。</font><font style="vertical-align: inherit;">たとえば、ヘッドチルトイベントをサブスクライブする場合、次のように垂直方向のコントロールを実装できます。</font></font><br>
<br>
<pre><code class="javascript hljs">FaceTracking.face(<span class="hljs-number">0</span>).cameraTransform.rotationX.monitor().subscribe(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-keyword">var</span> v = event.newValue;
    <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">var</span> scrH2 = ap.game.scr.h2;
    <span class="hljs-comment">//</span>
    <span class="hljs-keyword">var</span> p = -v * <span class="hljs-number">0.5</span>;
    <span class="hljs-keyword">if</span> (p &lt; -scrH2) {<font></font>
        p = -scrH2;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p &gt; scrH2) {<font></font>
        p = scrH2;<font></font>
    };<font></font>
    <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">var</span> d = <span class="hljs-number">0.006</span>;
    <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">var</span> cur = ap.oPers.transform.y.pinLastValue();
    <span class="hljs-keyword">if</span> (p &lt; cur) {<font></font>
        cur -= d;<font></font>
        <span class="hljs-keyword">if</span> (cur &lt; p) {cur = p;};<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        cur += d;<font></font>
        <span class="hljs-keyword">if</span> (cur &gt; p) {cur = p;};<font></font>
    };<font></font>
    <span class="hljs-comment">//    ()</span><font></font>
    ap.oPointer1.transform.y = p;<font></font>
    <span class="hljs-comment">//   ,</span>
    <span class="hljs-comment">// ,    </span><font></font>
    ap.game.pers.dy + = cur - ap.game.pers.y;<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
横についても同様です。</font><font style="vertical-align: inherit;">イベントをサブスクライブする必要があるのは、チルトではなく、頭を回す（rotationY）だけであり、画面の高さではなく、その幅を考慮してください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コライダー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべてが素晴らしい、世界は動いており、ゲームキャラクターは画面内を自由に移動できます。しかし、今は衝突ハンドラが必要です。そうしないと、ゲームは機能しません。ゲームには3つのイベントがあり、キャラクターの位置を変更できます。これは、頭の回転と傾斜、および世界の動きであり、プレーヤーの水平座標（x）が自動的に増加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Spark ARでフェイスハンドラーの反復がどのように機能するかわからない-特定の周波数で呼び出されるか、可能な最大クロック周波数で設定されるか、アニメーションエンジンでこのパラメーターを制御できるため、関数で衝突を定義することにしました私が設定した周波数（60フレーム/秒）で呼び出される世界の動き。顔処理イベントでは、動きを「蓄積」するだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則はそのようになります。頭の傾きと頭の回転イベントでは、x軸とy軸に沿ったオフセットが累積されます。また、世界をスクロールする機能では、「貯金箱」に水平方向の変位も加わります。そして、それがチェックされ、累積された変位が元の座標に追加された場合、ワールド内のオブジェクトとの衝突が発生します。そうでない場合、プレーヤーの元の座標とオフセットは現在の座標によって作成されます。次に、ソースを現在のものに更新し（リセット）、オフセットをリセットします。その場合は、座標を元に戻します。さらに、どちらの座標もロールバックできないため、衝突が発生する軸を決定する必要があります。それ以外の場合、プレイヤーは空間内の1点に「くっつく」だけで、どこにも移動できなくなります。衝突が発生しない軸に沿って自由に移動できるようにする必要があります。したがって、障害物を飛び回る機会を彼に与えることができます。</font></font><br>
<br>
<pre><code class="javascript hljs">setPersPos: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">camx, camdx</span>) </span>{
    <span class="hljs-comment">//   </span>
    <span class="hljs-comment">//       (camx,camdx)</span><font></font>
<font></font>
    <span class="hljs-comment">//     </span>
    <span class="hljs-keyword">var</span> persx = ap.game.pers.x;
    <span class="hljs-keyword">var</span> persy = ap.game.pers.y;
    <span class="hljs-keyword">var</span> dx = ap.game.pers.dx;
    <span class="hljs-keyword">var</span> dy = ap.game.pers.dy;<font></font>
<font></font>
    <span class="hljs-comment">// ,     </span>
    <span class="hljs-keyword">var</span> col = ap.collisionDetect(<font></font>
        {<span class="hljs-attr">x</span>: persx, <span class="hljs-attr">y</span>: persy, <span class="hljs-attr">dx</span>: dx, <span class="hljs-attr">dy</span>: dy},<font></font>
        {<span class="hljs-attr">x</span>: camx, <span class="hljs-attr">dx</span>: camdx, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>}<font></font>
    );<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (col.f == <span class="hljs-literal">true</span>) {
        <span class="hljs-comment">// </span><font></font>
<font></font>
        <span class="hljs-keyword">if</span> (col.colx == <span class="hljs-literal">true</span>) {
            <span class="hljs-comment">//   </span>
            <span class="hljs-comment">//    ,</span>
            <span class="hljs-comment">//   </span>
            <span class="hljs-comment">//(    ,    )</span><font></font>
            ap.game.pers.x = col.x;<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">//    ,</span>
            <span class="hljs-comment">//   </span><font></font>
            ap.game.pers.x = persx + dx;<font></font>
        };<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (col.coly == <span class="hljs-literal">true</span>) {
            <span class="hljs-comment">// -  </span><font></font>
            ap.game.pers.y = col.y;<font></font>
        } <span class="hljs-keyword">else</span> {<font></font>
            ap.game.pers.y = persy + dy;<font></font>
        };<font></font>
<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//  ,   </span><font></font>
        ap.game.pers.x = persx + dx;<font></font>
        ap.game.pers.y = persy + dy;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-comment">// </span>
    ap.game.pers.dx = <span class="hljs-number">0</span>;<font></font>
    ap.game.pers.dy = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-comment">//     </span><font></font>
    ap.oPers.transform.x = ap.game.pers.x;<font></font>
    ap.oPers.transform.y = ap.game.pers.y;<font></font>
},</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
衝突検出機能自体：</font></font><br>
<br>
<pre><code class="javascript hljs">collisionDetect: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">opers, ow</span>) </span>{
    <span class="hljs-comment">// , opers -   , ow -  </span><font></font>
<font></font>
    <span class="hljs-keyword">var</span> res = {<span class="hljs-attr">f</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">colx</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">coly</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>};<font></font>
<font></font>
    <span class="hljs-keyword">var</span> ocoll, x, y, w, h, persx, persy, persx0, persy0, od, colx1, coly1, colx2, coly2;
    <span class="hljs-keyword">var</span> collw = <span class="hljs-literal">false</span>, collh = <span class="hljs-literal">false</span>;<font></font>
<font></font>
    <span class="hljs-comment">//  </span>
    <span class="hljs-comment">//(  ,  "" )</span><font></font>
    persx0 = opers.x + ow.x - ow.dx;<font></font>
    persy0 = opers.y + ow.y;<font></font>
<font></font>
    <span class="hljs-comment">//       </span><font></font>
    persx = persx0 + opers.dx;<font></font>
    persy = persy0 + opers.dy;<font></font>
<font></font>
    <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ap.d.lv.length; i++) {<font></font>
        od = ap.d.lv[i]; <span class="hljs-comment">//obj data</span><font></font>
<font></font>
        <span class="hljs-comment">//    (   ),</span>
        <span class="hljs-comment">//     </span>
        <span class="hljs-comment">//        </span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ap.d.colld[od.n] !== <span class="hljs-string">"undefined"</span>) {<font></font>
<font></font>
            <span class="hljs-comment">//       </span><font></font>
            ocoll = ap.d.colld[od.n];<font></font>
            colx1 = od.x + ocoll.x1;<font></font>
            colx2 = od.x + ocoll.x2;<font></font>
            coly1 = od.y + ocoll.y1;<font></font>
            coly2 = od.y + ocoll.y2;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> ((persx &lt; colx1) || (persx &gt; colx2) || (persy &lt; coly1) || (persy &gt; coly2)) {} <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">//   </span>
                res.f = <span class="hljs-literal">true</span>;<font></font>
<font></font>
                <span class="hljs-comment">//        ,</span>
                <span class="hljs-comment">//,    </span>
                <span class="hljs-keyword">if</span> ((persx0 &lt; colx1) || (persx0 &gt; colx2)) {<font></font>
                    collw = <span class="hljs-literal">true</span>;<font></font>
                };<font></font>
                <span class="hljs-comment">//        ,</span>
                <span class="hljs-comment">//,    </span>
                <span class="hljs-keyword">if</span> ((persy0 &lt; coly1) || (persy0 &gt; coly2)) {<font></font>
                    collh = <span class="hljs-literal">true</span>;<font></font>
                };<font></font>
<font></font>
            };<font></font>
        };<font></font>
<font></font>
    };<font></font>
<font></font>
    <span class="hljs-comment">//   </span><font></font>
<font></font>
    <span class="hljs-comment">//  ,     ,</span>
    <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">if</span> (collw == <span class="hljs-literal">true</span>) {<font></font>
        res.colx = <span class="hljs-literal">true</span>;<font></font>
        res.x = persx0 - ow.x;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        res.x = opers.x;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-comment">// -  </span>
    <span class="hljs-keyword">if</span> (collh == <span class="hljs-literal">true</span>) {<font></font>
        res.coly = <span class="hljs-literal">true</span>;<font></font>
        res.y = persy0 + ow.y;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        res.y = opers.y;<font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">return</span> res;<font></font>
},</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">雨</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準のパーティクルエンジンSpark AR Studioを使用して、雨をアニメートしました。</font><font style="vertical-align: inherit;">ここで特別なことは何もありません。</font><font style="vertical-align: inherit;">Emtterオブジェクトをシーンに追加し、Emitter-&gt; Space-&gt; Local（Worldの代わりに）と尋ねることを忘れないでください。</font><font style="vertical-align: inherit;">これは、滴が移動中に動的に雲に遅れずに、常に直接落ちるようにするためです。</font><font style="vertical-align: inherit;">この方法は、蝶が雨の中に落ちる瞬間を簡単に判断するのに便利です。高さを調整する必要はありません。</font><font style="vertical-align: inherit;">しずく自体に適した質感を用意しました。</font><font style="vertical-align: inherit;">まあ、もちろん、雨オブジェクトは雲オブジェクトと一緒に移動します。</font><font style="vertical-align: inherit;">次に、衝突処理コードにクラウドヒット条件を追加しました。</font><font style="vertical-align: inherit;">そして、この時点でプレイヤーの上に障害物がない場合は、蝶が落ちてゲームが終了します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">節度</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデレートを成功させるには、ゲームの必須ビデオに、オブジェクトに関連付けられていない静的テキストを含めないでください。</font><font style="vertical-align: inherit;">それ以外の場合、ロボットはすぐにモデレートを停止します。</font><font style="vertical-align: inherit;">しかし、その後、数日間ゲームをチェックします。</font><font style="vertical-align: inherit;">そして、彼は試合前だけでなく、試合終了時の豊富なテキストも好きではありませんでした。</font><font style="vertical-align: inherit;">テキストの量を減らす必要がありました。</font><font style="vertical-align: inherit;">その後、ゲームは承認されました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のゲームが特にエキサイティングだったわけではありません。</font><font style="vertical-align: inherit;">彼女はおそらくダイナミクスと追加のメカニズムが不足しています。</font><font style="vertical-align: inherit;">アップデートをリリースします。</font><font style="vertical-align: inherit;">しかし、インスタグラムでゲームを作るのは面白いことに気づきました。</font><font style="vertical-align: inherit;">これは一種の挑戦です。</font><font style="vertical-align: inherit;">ツールと割り当てられたメモリの量に関して、ミニマリズムの下であらゆる種類のタスクのプログラミングと解決のプロセスを本当に楽しんだ。</font><font style="vertical-align: inherit;">640 Kbで十分だと誰かが言ったのを覚えています。</font><font style="vertical-align: inherit;">次に、2 MBの3Dゲームに合わせてみます。</font><font style="vertical-align: inherit;">私は、おそらく、それらがすべての人にとって十分であると主張しません...しかし、それを試してください！</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/7f/g7/kr/7fg7kra8uhidburs19pognju5vc.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論として、私が遭遇したすべての明らかでない瞬間を1つのリストにまとめたいと思います。</font><font style="vertical-align: inherit;">これは、Instagram向けのゲームを作成する際のチートシートとして役立つかもしれません。</font></font><br>
<br>
<i><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">規模。</font><font style="vertical-align: inherit;">3Dエディターですべての3Dモデルのスケールを調整して、彼がゲームのステージですぐに1：1になるようにします。</font></font></li>
<li>       .              .   ,            .</li>
<li>.          FBX,     .        -.           ,    .</li>
<li>  .  JPG   ,     ,   ,       -,    JPG,    PNG.</li>
<li>   . , ,        .   Spark AR  ,         . , , ,   3D-.</li>
<li>   3D ,    :     ,    .       .             .</li>
<li>,    ,      .   javascript   .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spark ARのコンテキストでは、ウィンドウオブジェクトはなく、webkitRequestAnimationFrame、mozRequestAnimationFrameなどのブラウザー固有のあらゆる種類のオブジェクトがあります。</font><font style="vertical-align: inherit;">これは、JavaScriptアニメーションでプログラミングする場合の運命です。</font></font></li>
</ul></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja499964/index.html">NASAは、月面着陸用の船を作成するプログラムに参加する3つの企業を選択しました</a></li>
<li><a href="../ja499966/index.html">UVA UVBの測定</a></li>
<li><a href="../ja499968/index.html">5月にさえ行われる最も永続的なオンラインmitapのリスト</a></li>
<li><a href="../ja499970/index.html">Mediastreamer2 VoIPエンジンを研究します。パート12</a></li>
<li><a href="../ja499972/index.html">5月のオンラインイベントダイジェスト</a></li>
<li><a href="../ja499978/index.html">Andrew Unの本、機械学習への情熱、36章と37章の翻訳</a></li>
<li><a href="../ja499982/index.html">初心者テスター計画：「ITに入る」から「エンジニアです！」</a></li>
<li><a href="../ja499986/index.html">そして再び組み込みについて：Emboxプロジェクトのバグを探す</a></li>
<li><a href="../ja499988/index.html">砂糖とCOVID-19</a></li>
<li><a href="../ja499990/index.html">ジオコーディング 10分間で25万のアドレスを座標にバインドする方法は？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>