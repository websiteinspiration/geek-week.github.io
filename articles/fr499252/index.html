<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏰 👨🏾‍🎨 🎊 Création d'un jeu de course pseudo-tridimensionnel 🔚 🎀 🙏🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Enfant, je suis rarement allé dans des salles d'arcade parce que je n'en avais pas vraiment besoin, parce que j'avais des jeux géniaux pour C64 à la m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Création d'un jeu de course pseudo-tridimensionnel</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499252/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d16/6e3/cff/d166e3cff9c2a3cefeb68f5c1ddc02d1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfant, je suis rarement allé dans des salles d'arcade parce que je n'en avais pas vraiment besoin, parce que j'avais des jeux géniaux pour C64 à la maison ... mais il y a trois jeux d'arcade pour lesquels j'ai toujours eu de l'argent - Donkey Kong, Dragons Lair et Outrun ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... et j'ai vraiment adoré Outrun - vitesse, collines, palmiers et musique, même sur la version faible du C64.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48e/aee/56f/48eaee56f43d8a25e840c6ae13268db4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai donc décidé d'essayer d'écrire un jeu de course pseudo-tridimensionnel à l'ancienne dans le style d'Outrun, Pitstop ou Pole position. </font><font style="vertical-align: inherit;">Je n'ai pas l'intention de monter un jeu complet et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">complet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais il me semble qu'il sera intéressant de réexaminer les mécanismes avec lesquels ces jeux ont réalisé leurs tours. </font><font style="vertical-align: inherit;">Courbes, collines, sprites et sens de la vitesse ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors, voici mon «projet de week-end», qui a finalement pris cinq ou six semaines le week-end</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/27b/d28/7ec27bd28630dbbaf7b81c87233c28ac.png"></div><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jouer à un jeu</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afficher </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le code source</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La version jouable ressemble plus à une démo technique qu'à un vrai jeu. </font><font style="vertical-align: inherit;">En fait, si vous voulez créer une véritable course pseudo-tridimensionnelle, ce sera la base la plus minimale dont vous aurez besoin pour devenir progressivement un jeu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'est pas poli, un peu moche, mais entièrement fonctionnel. </font><font style="vertical-align: inherit;">Je vais vous montrer comment l'implémenter par vous-même en quatre étapes simples. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez également jouer</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">démonstration directe de la route</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">démo avec des courbes</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">démo avec les collines</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">version finale</font></font></a></li>
</ul><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À propos des performances</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les performances de ce jeu </font><font style="vertical-align: inherit;">dépendent </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fortement</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la machine / du navigateur. </font><font style="vertical-align: inherit;">Dans les navigateurs modernes, cela fonctionne bien, en particulier dans ceux qui ont une accélération du GPU Canvas, mais un mauvais pilote graphique peut le geler. </font><font style="vertical-align: inherit;">Dans le jeu, vous pouvez modifier la résolution de rendu et la distance de rendu.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À propos de la structure du code</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il se trouve que le projet a été implémenté en Javascript (en raison de la simplicité du prototypage), mais il n'est pas destiné à démontrer les techniques ou les techniques recommandées de Javascript. </font><font style="vertical-align: inherit;">En fait, pour faciliter la compréhension, le Javascript de chaque exemple est intégré directement dans la page HTML (horreur!); </font><font style="vertical-align: inherit;">pire, il utilise des variables et des fonctions globales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si je créais un vrai jeu, le code serait beaucoup plus structuré et rationalisé, mais comme il s'agit d'une démonstration technique d'un jeu de course, j'ai décidé de m'en tenir à </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KISS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 1. Routes droites.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors, comment pouvons-nous commencer à créer un jeu de course pseudo-tridimensionnel? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, nous avons besoin</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Répéter la trigonométrie</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rappelez les bases de la projection 3D</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créer une boucle de jeu</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Télécharger des images de sprite</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Construire la géométrie de la route</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fond de rendu</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendre la route</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendre la voiture</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implémenter la prise en charge du clavier pour le contrôle de la machine</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais avant de </font><font style="vertical-align: inherit;">commencer, Lisons </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pseudo 3d page de Lou</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traduction</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Habré] - la seule source d'information (que je pouvais trouver) sur la </font><font style="vertical-align: inherit;">façon de créer jeu de course psevdotrohmernuyu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous avez fini de lire l'article de Lou? </font><font style="vertical-align: inherit;">Bien! </font><font style="vertical-align: inherit;">Nous allons créer une variation de sa technique Realistic Hills Using 3D-Projected Segments. </font><font style="vertical-align: inherit;">Nous le ferons progressivement au cours des quatre prochaines parties. </font><font style="vertical-align: inherit;">Mais nous allons commencer maintenant, avec la version v1, et créer une géométrie de route droite très simple en la projetant sur un élément de toile HTML5.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La démo peut être vue </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un peu de trigonométrie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant d'entrer dans l'implémentation, utilisons les bases de la trigonométrie pour nous rappeler comment projeter un point du monde 3D sur un écran 2D. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cas le plus simple, si vous ne touchez pas aux vecteurs et aux matrices, la loi des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">triangles similaires est</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilisée pour la projection 3D </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous utilisons la notation suivante:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = hauteur de la caméra</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = distance de la caméra à l'écran</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = distance de la caméra à la voiture</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = coordonnées </font><strong><font style="vertical-align: inherit;">y de l'</font></strong><font style="vertical-align: inherit;"> écran</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous pouvons utiliser la loi des triangles similaires pour calculer </font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y = h * d / z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
comme le montre le schéma:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/949/0ab/47b/9490ab47bb570b61218e46e5913c18bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez également dessiner un diagramme similaire dans une vue de dessus au lieu d'une vue latérale et dériver une équation similaire pour calculer la coordonnée </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de l' </font><font style="vertical-align: inherit;">écran:</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x = w * d / z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Où </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = la moitié de la largeur de la route (de la caméra au bord de la route). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, pour </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous évoluons d'un facteur</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d / z</font></font></strong></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Systèmes de coordonnées</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sous la forme d'un diagramme, il a l'air beau et simple, mais lorsque vous commencez à coder, vous pouvez être un peu confus, car nous avons choisi des noms arbitraires, et on ne sait pas ce que nous avons indiqué les coordonnées du monde 3D et quelles sont les coordonnées de l'écran 2D. </font><font style="vertical-align: inherit;">Nous supposons également que la caméra est au centre de l'origine du monde, bien qu'en réalité elle suivra la machine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous vous approchez de manière plus formelle, nous devons effectuer:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conversion</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des coordonnées du monde en coordonnées d'écran</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projection</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des coordonnées de la caméra sur un plan de projection normalisé</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mettre à l'échelle les</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordonnées projetées aux coordonnées de l'écran physique (dans notre cas, c'est du canevas)</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/5d2/30f/b595d230f4f45b9b0c9409266d5804d8.png"></div><br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque: dans le système 3D actuel </font><font style="vertical-align: inherit;">, l' </font><font style="vertical-align: inherit;">étape de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rotation</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est effectuée entre les étapes 1 et 2 </font><font style="vertical-align: inherit;">, mais comme nous simulerons les courbes, nous n'avons pas besoin d'une rotation.</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projection</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les équations de projection formelles peuvent être représentées comme suit:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/246/e18/edb246e187e7fe0eb027b53c58790c34.png"></div><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le point d'équations de conversion ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">translate</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) est calculé par rapport à la chambre</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les équations de projection ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projet</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sont des variations de la «loi des triangles similaires» illustrée ci-dessus.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les équations de mise à l' </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">échelle</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><strong><font style="vertical-align: inherit;">échelle</font></strong><font style="vertical-align: inherit;"> ) tiennent compte de la différence entre:</font></font><br>
<ul>
<li><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mathématiques</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , où 0,0 est au centre et l'axe y est en haut, et</font></font></li>
<li><em></em>,  0,0     ,   y  :</li>
</ul></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11f/050/aad/11f050aadea0d1c537baefcb06f7c2f0.png"></div><br>
<blockquote><em>:   3d-         <code>Vector</code>  <code>Matrix</code>     3d-,      ,      WebGL (  )…       .           Outrun.</em></blockquote><br>
<h2>  </h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b7/27b/1bd/3b727b1bdb285d874bd659c29db13522.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La dernière pièce du puzzle sera un moyen de calculer </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - la distance entre la caméra et le plan de projection. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lieu d'écrire simplement une valeur fixe de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , il serait plus utile de la calculer à partir du champ de vision vertical souhaité. </font><font style="vertical-align: inherit;">Grâce à cela, nous pourrons "zoomer" la caméra si nécessaire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous supposons que nous projetons sur un plan de projection normalisé, dont les coordonnées sont comprises entre -1 et +1, alors </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peut être calculé comme suit:</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 / bronzage (fov / 2)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">définissant fov</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme une (parmi plusieurs) variables, nous pouvons ajuster la portée pour affiner l'algorithme de rendu.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Structure du code Javascript</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au début de l'article, j'ai déjà dit que le code n'était pas tout à fait conforme aux directives pour écrire Javascript - c'est une démo «rapide et sale» avec des variables et fonctions globales simples. </font><font style="vertical-align: inherit;">Cependant, puisque je vais créer quatre versions distinctes (droite, courbes, collines et sprites), je vais stocker des méthodes réutilisables à l'intérieur </font></font><code>common.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans les modules suivants:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dom</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est quelques fonctions d'assistance DOM mineures.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Util</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - utilitaires généraux, principalement des fonctions mathématiques auxiliaires.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Fonctions générales d'assistance au jeu, telles que le téléchargement d'images et la boucle de jeu.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - fonctions de rendu d'aide sur le canevas.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'expliquerai en détail les méthodes de </font></font><code>common.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seulement si elles se rapportent au jeu lui-même, et ne sont pas seulement des fonctions mathématiques ou DOM auxiliaires. </font><font style="vertical-align: inherit;">Espérons que d'après le nom et le contexte, il sera clair ce que les méthodes devraient faire.</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme d'habitude, le code source est dans la documentation finale.</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boucle de jeu simple</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de rendre quelque chose, nous avons besoin d'une boucle de jeu. </font><font style="vertical-align: inherit;">Si vous avez lu l'un de mes articles précédents sur les jeux ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pong</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">breakout</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tetris</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">snakes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boulderdash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), vous avez déjà vu des exemples de mon cycle de jeu préféré avec un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas de temps fixe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'entrerai pas dans les détails, et je réutiliserai simplement une partie du code des jeux précédents pour créer une boucle de jeu avec un pas de temps fixe en utilisant </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requestAnimationFrame</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le principe est que chacun de mes quatre exemples peut appeler </font></font><code>Game.run(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et utiliser ses propres versions</font></font><br>
<br>
<ul>
<li><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Mise à jour du monde du jeu avec un pas de temps fixe.</font></font></li>
<li><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Mise à jour du monde du jeu lorsque le navigateur le permet.</font></font></li>
</ul><br>
<pre><code class="javascript hljs">run: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{<font></font>
<font></font>
  Game.loadImages(options.images, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">images</span>) </span>{<font></font>
<font></font>
    <span class="hljs-keyword">var</span> update = options.update,    <span class="hljs-comment">// method to update game logic is provided by caller</span>
        render = options.render,    <span class="hljs-comment">// method to render the game is provided by caller</span>
        step   = options.step,      <span class="hljs-comment">// fixed frame step (1/fps) is specified by caller</span>
        now    = <span class="hljs-literal">null</span>,<font></font>
        last   = Util.timestamp(),<font></font>
        dt     = <span class="hljs-number">0</span>,<font></font>
        gdt    = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">frame</span>(<span class="hljs-params"></span>) </span>{<font></font>
      now = Util.timestamp();<font></font>
      dt  = <span class="hljs-built_in">Math</span>.min(<span class="hljs-number">1</span>, (now - last) / <span class="hljs-number">1000</span>); <span class="hljs-comment">// using requestAnimationFrame have to be able to handle large delta's caused when it 'hibernates' in a background or non-visible tab</span><font></font>
      gdt = gdt + dt;<font></font>
      <span class="hljs-keyword">while</span> (gdt &gt; step) {<font></font>
        gdt = gdt - step;<font></font>
        update(step);<font></font>
      }<font></font>
      render();<font></font>
      last = now;<font></font>
      requestAnimationFrame(frame);<font></font>
    }<font></font>
    frame(); <span class="hljs-comment">// lets get this party started</span><font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encore une fois, il s'agit d'un remake des idées de mes précédents jeux de toile, donc si vous ne comprenez pas comment fonctionne la boucle de jeu, revenez à l'un des articles précédents.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Images et sprites</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant le début du cycle de jeu, nous chargeons deux feuilles de sprites séparées (feuilles de sprites):</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fond</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - trois couches de parallaxe pour le ciel, les collines et les arbres</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sprites</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><strong><font style="vertical-align: inherit;">sprites</font></strong><font style="vertical-align: inherit;"> machine (plus des arbres et des panneaux d'affichage à ajouter à la version finale)</font></font></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6f/111/acc/f6f111accbba448459e25c6fe761ff05.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La feuille de sprite a été générée à l'aide d'une petite </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usine de sprites</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rake and </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Ruby Gem</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette tâche génère les feuilles de sprites combinées, ainsi que les coordonnées x, y, w, h, qui seront stockées dans les constantes </font></font><code>BACKGROUND</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>SPRITES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque: J'ai créé les arrière-plans à l'aide d'Inkscape, et la plupart des sprites sont des graphiques </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tirés</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de l'ancienne version Outrun pour Genesis et utilisés comme exemples de formation.</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variables de jeu</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus des images d'arrière-plans et de sprites, nous aurons besoin de plusieurs variables de jeu, à savoir:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> fps           = <span class="hljs-number">60</span>;                      <span class="hljs-comment">// how many 'update' frames per second</span>
<span class="hljs-keyword">var</span> step          = <span class="hljs-number">1</span>/fps;                   <span class="hljs-comment">// how long is each frame (in seconds)</span>
<span class="hljs-keyword">var</span> width         = <span class="hljs-number">1024</span>;                    <span class="hljs-comment">// logical canvas width</span>
<span class="hljs-keyword">var</span> height        = <span class="hljs-number">768</span>;                     <span class="hljs-comment">// logical canvas height</span>
<span class="hljs-keyword">var</span> segments      = [];                      <span class="hljs-comment">// array of road segments</span>
<span class="hljs-keyword">var</span> canvas        = Dom.get(<span class="hljs-string">'canvas'</span>);       <span class="hljs-comment">// our canvas...</span>
<span class="hljs-keyword">var</span> ctx           = canvas.getContext(<span class="hljs-string">'2d'</span>); <span class="hljs-comment">// ...and its drawing context</span>
<span class="hljs-keyword">var</span> background    = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// our background image (loaded below)</span>
<span class="hljs-keyword">var</span> sprites       = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// our spritesheet (loaded below)</span>
<span class="hljs-keyword">var</span> resolution    = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// scaling factor to provide resolution independence (computed)</span>
<span class="hljs-keyword">var</span> roadWidth     = <span class="hljs-number">2000</span>;                    <span class="hljs-comment">// actually half the roads width, easier math if the road spans from -roadWidth to +roadWidth</span>
<span class="hljs-keyword">var</span> segmentLength = <span class="hljs-number">200</span>;                     <span class="hljs-comment">// length of a single segment</span>
<span class="hljs-keyword">var</span> rumbleLength  = <span class="hljs-number">3</span>;                       <span class="hljs-comment">// number of segments per red/white rumble strip</span>
<span class="hljs-keyword">var</span> trackLength   = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// z length of entire track (computed)</span>
<span class="hljs-keyword">var</span> lanes         = <span class="hljs-number">3</span>;                       <span class="hljs-comment">// number of lanes</span>
<span class="hljs-keyword">var</span> fieldOfView   = <span class="hljs-number">100</span>;                     <span class="hljs-comment">// angle (degrees) for field of view</span>
<span class="hljs-keyword">var</span> cameraHeight  = <span class="hljs-number">1000</span>;                    <span class="hljs-comment">// z height of camera</span>
<span class="hljs-keyword">var</span> cameraDepth   = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// z distance camera is from screen (computed)</span>
<span class="hljs-keyword">var</span> drawDistance  = <span class="hljs-number">300</span>;                     <span class="hljs-comment">// number of segments to draw</span>
<span class="hljs-keyword">var</span> playerX       = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// player x offset from center of road (-1 to 1 to stay independent of roadWidth)</span>
<span class="hljs-keyword">var</span> playerZ       = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// player relative z distance from camera (computed)</span>
<span class="hljs-keyword">var</span> fogDensity    = <span class="hljs-number">5</span>;                       <span class="hljs-comment">// exponential fog density</span>
<span class="hljs-keyword">var</span> position      = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// current camera Z position (add playerZ to get player's absolute Z position)</span>
<span class="hljs-keyword">var</span> speed         = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// current speed</span>
<span class="hljs-keyword">var</span> maxSpeed      = segmentLength/step;      <span class="hljs-comment">// top speed (ensure we can't move more than 1 segment in a single frame to make collision detection easier)</span>
<span class="hljs-keyword">var</span> accel         =  maxSpeed/<span class="hljs-number">5</span>;             <span class="hljs-comment">// acceleration rate - tuned until it 'felt' right</span>
<span class="hljs-keyword">var</span> breaking      = -maxSpeed;               <span class="hljs-comment">// deceleration rate when braking</span>
<span class="hljs-keyword">var</span> decel         = -maxSpeed/<span class="hljs-number">5</span>;             <span class="hljs-comment">// 'natural' deceleration rate when neither accelerating, nor braking</span>
<span class="hljs-keyword">var</span> offRoadDecel  = -maxSpeed/<span class="hljs-number">2</span>;             <span class="hljs-comment">// off road deceleration is somewhere in between</span>
<span class="hljs-keyword">var</span> offRoadLimit  =  maxSpeed/<span class="hljs-number">4</span>;             <span class="hljs-comment">// limit when off road deceleration no longer applies (e.g. you can always go at least this speed even when off road)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certains d'entre eux peuvent être personnalisés à l'aide de contrôles d'interface utilisateur pour modifier les valeurs critiques lors de l'exécution du programme afin que vous puissiez voir comment elles affectent le rendu de la route. </font><font style="vertical-align: inherit;">D'autres sont recalculés à partir des valeurs d'interface utilisateur personnalisées dans la méthode </font></font><code>reset()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous gérons Ferrari</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous effectuons des raccourcis clavier pour </font></font><code>Game.run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui fournit une entrée de clavier simple qui définit ou réinitialise les variables qui signalent les actions actuelles du joueur:</font></font><br>
<br>
<pre><code class="javascript hljs">Game.run({<font></font>
  ...<font></font>
  keys: [<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.LEFT,  KEY.A], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyLeft   = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.RIGHT, KEY.D], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyRight  = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.UP,    KEY.W], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyFaster = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.DOWN,  KEY.S], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keySlower = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.LEFT,  KEY.A], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyLeft   = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.RIGHT, KEY.D], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyRight  = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.UP,    KEY.W], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyFaster = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.DOWN,  KEY.S], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keySlower = <span class="hljs-literal">false</span>; } }<font></font>
  ],<font></font>
  ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'état du joueur est contrôlé par les variables suivantes:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speed</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><strong><font style="vertical-align: inherit;">vitesse</font></strong><font style="vertical-align: inherit;"> actuelle.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">position</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - la position Z actuelle sur la piste. </font><font style="vertical-align: inherit;">Notez qu'il s'agit d'une position de caméra, pas d'une Ferrari.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">playerX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - position actuelle du joueur sur X sur la route. </font><font style="vertical-align: inherit;">Normalisé dans la plage de -1 à +1, afin de ne pas dépendre de la valeur réelle </font></font><code>roadWidth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces variables sont définies à l'intérieur de la méthode </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui effectue les actions suivantes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mises à jour </font></font><code>position</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basées sur le courant </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se met </font></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à </font><font style="vertical-align: inherit;">jour </font><font style="vertical-align: inherit;">lorsque vous appuyez sur la touche gauche ou droite.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">augmente </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si la touche haut est enfoncée.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diminue </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si la touche bas est enfoncée.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">réduit </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si les touches haut et bas ne sont pas enfoncées.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">réduit </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s'il est </font></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">situé en bordure de route et sur l'herbe.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cas des routes directes, la méthode est </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assez claire et simple:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">dt</span>) </span>{<font></font>
<font></font>
  position = Util.increase(position, dt * speed, trackLength);<font></font>
<font></font>
  <span class="hljs-keyword">var</span> dx = dt * <span class="hljs-number">2</span> * (speed/maxSpeed); <span class="hljs-comment">// at top speed, should be able to cross from left to right (-1 to 1) in 1 second</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span> (keyLeft)<font></font>
    playerX = playerX - dx;<font></font>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (keyRight)<font></font>
    playerX = playerX + dx;<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (keyFaster)<font></font>
    speed = Util.accelerate(speed, accel, dt);<font></font>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (keySlower)<font></font>
    speed = Util.accelerate(speed, breaking, dt);<font></font>
  <span class="hljs-keyword">else</span><font></font>
    speed = Util.accelerate(speed, decel, dt);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (((playerX &lt; <span class="hljs-number">-1</span>) || (playerX &gt; <span class="hljs-number">1</span>)) &amp;&amp; (speed &gt; offRoadLimit))<font></font>
    speed = Util.accelerate(speed, offRoadDecel, dt);<font></font>
<font></font>
  playerX = Util.limit(playerX, <span class="hljs-number">-2</span>, <span class="hljs-number">2</span>);     <span class="hljs-comment">// dont ever let player go too far out of bounds</span>
  speed   = Util.limit(speed, <span class="hljs-number">0</span>, maxSpeed); <span class="hljs-comment">// or exceed maxSpeed</span><font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ne vous inquiétez pas, cela deviendra beaucoup plus difficile lorsque dans la version finale, nous ajouterons des sprites et la reconnaissance des collisions.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Géométrie routière</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de pouvoir rendre le monde du jeu, nous devons créer un tableau de </font></font><code>segments</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in dans la méthode </font></font><code>resetRoad()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chacun de ces segments de la route sera finalement projeté à partir de ses coordonnées mondiales afin qu'il se transforme en un polygone 2D en coordonnées d'écran. </font><font style="vertical-align: inherit;">Pour chaque segment, nous stockons deux points, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le centre du bord le plus proche de la caméra et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le centre du bord le plus éloigné de la caméra.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53a/fa4/076/53afa40768a00b49833703b1457a6941.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À proprement parler, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2 de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chaque segment est identique à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1 du</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segment précédent, mais il me semble qu'il est plus facile de les stocker en tant que points séparés et de convertir chaque segment séparément. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous restons séparés </font></font><code>rumbleLength</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">car nous pouvons avoir de belles courbes et collines détaillées, mais en même temps des rayures horizontales. Si chaque segment suivant a une couleur différente, cela créera un mauvais effet stroboscopique. Par conséquent, nous voulons avoir de nombreux petits segments, mais les regrouper pour former des bandes horizontales distinctes.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetRoad</span>(<span class="hljs-params"></span>) </span>{<font></font>
  segments = [];<font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span> ; n &lt; <span class="hljs-number">500</span> ; n++) { <span class="hljs-comment">// arbitrary road length</span><font></font>
    segments.push({<font></font>
       <span class="hljs-attr">index</span>: n,
       <span class="hljs-attr">p1</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>:  n   *segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
       <span class="hljs-attr">p2</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>: (n+<span class="hljs-number">1</span>)*segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
       <span class="hljs-attr">color</span>: <span class="hljs-built_in">Math</span>.floor(n/rumbleLength)%<span class="hljs-number">2</span> ? COLORS.DARK : COLORS.LIGHT<font></font>
    });<font></font>
  }<font></font>
<font></font>
  trackLength = segments.length * segmentLength;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous initialisons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uniquement avec les coordonnées du monde </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , car nous n'avons besoin que de routes droites. Les coordonnées </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seront toujours 0 et les coordonnées </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dépendront toujours de la valeur mise à l'échelle </font></font><code>+/- roadWidth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Plus tard, lorsque nous ajouterons des courbes et des collines, cette partie changera. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons également définir des objets vides pour stocker des représentations de ces points dans la caméra et sur l'écran afin de ne pas créer un tas d'objets temporaires dans chacun </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pour minimiser la récupération de place, nous devons éviter d'allouer des objets dans la boucle de jeu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque la voiture atteint la fin de la route, nous revenons simplement au début du cycle. </font><font style="vertical-align: inherit;">Pour simplifier cela, nous allons créer une méthode pour trouver un segment pour n'importe quelle valeur de Z, même s'il dépasse la longueur de la route:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findSegment</span>(<span class="hljs-params">z</span>) </span>{
  <span class="hljs-keyword">return</span> segments[<span class="hljs-built_in">Math</span>.floor(z/segmentLength) % segments.length];<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu en arrière-plan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La méthode </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commence par le rendu de l'image d'arrière-plan. </font><font style="vertical-align: inherit;">Dans les parties suivantes, où nous ajouterons des courbes et des collines, nous aurons besoin de l'arrière-plan pour effectuer le défilement de parallaxe, nous allons donc commencer à nous déplacer dans cette direction, rendant l'arrière-plan en trois couches distinctes:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params"></span>) </span>{<font></font>
<font></font>
  ctx.clearRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<font></font>
<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.SKY);<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.HILLS);<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.TREES);<font></font>
<font></font>
  ...</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu routier</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, la fonction de rendu itère sur tous les segments et projette </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2 de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chaque segment des coordonnées universelles aux coordonnées d'écran, en coupant le segment si nécessaire et en le rendant autrement:</font></font><br>
<br>
<pre><code class="javascript hljs">  <span class="hljs-keyword">var</span> baseSegment = findSegment(position);
  <span class="hljs-keyword">var</span> maxy        = height;
  <span class="hljs-keyword">var</span> n, segment;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; drawDistance ; n++) {<font></font>
<font></font>
    segment = segments[(baseSegment.index + n) % segments.length];<font></font>
<font></font>
    Util.project(segment.p1, (playerX * roadWidth), cameraHeight, position, cameraDepth, width, height, roadWidth);<font></font>
    Util.project(segment.p2, (playerX * roadWidth), cameraHeight, position, cameraDepth, width, height, roadWidth);<font></font>
<font></font>
    <span class="hljs-keyword">if</span> ((segment.p1.camera.z &lt;= cameraDepth) || <span class="hljs-comment">// behind us</span>
        (segment.p2.screen.y &gt;= maxy))          <span class="hljs-comment">// clip by (already rendered) segment</span>
      <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
    Render.segment(ctx, width, lanes,<font></font>
                   segment.p1.screen.x,<font></font>
                   segment.p1.screen.y,<font></font>
                   segment.p1.screen.w,<font></font>
                   segment.p2.screen.x,<font></font>
                   segment.p2.screen.y,<font></font>
                   segment.p2.screen.w,<font></font>
                   segment.color);<font></font>
<font></font>
    maxy = segment.p2.screen.y;<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ci-dessus, nous avons déjà vu les calculs nécessaires à la projection d'un point; La version javascript combine la transformation, la projection et la mise à l'échelle en une seule méthode:</font></font><br>
<br>
<pre><code class="javascript hljs">project: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth</span>) </span>{<font></font>
  p.camera.x     = (p.world.x || <span class="hljs-number">0</span>) - cameraX;<font></font>
  p.camera.y     = (p.world.y || <span class="hljs-number">0</span>) - cameraY;<font></font>
  p.camera.z     = (p.world.z || <span class="hljs-number">0</span>) - cameraZ;<font></font>
  p.screen.scale = cameraDepth/p.camera.z;<font></font>
  p.screen.x     = <span class="hljs-built_in">Math</span>.round((width/<span class="hljs-number">2</span>)  + (p.screen.scale * p.camera.x  * width/<span class="hljs-number">2</span>));<font></font>
  p.screen.y     = <span class="hljs-built_in">Math</span>.round((height/<span class="hljs-number">2</span>) - (p.screen.scale * p.camera.y  * height/<span class="hljs-number">2</span>));<font></font>
  p.screen.w     = <span class="hljs-built_in">Math</span>.round(             (p.screen.scale * roadWidth   * width/<span class="hljs-number">2</span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus de calculer l'écran </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour chaque point </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous utilisons les mêmes calculs de projection pour calculer la largeur projetée ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) du segment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ayant les coordonnées d'écran </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des </font><font style="vertical-align: inherit;">points </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ainsi que la largeur projetée de la route </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous pouvons assez facilement calculer à l'aide d'une fonction auxiliaire </font></font><code>Render.segment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tous les polygones nécessaires pour rendre l'herbe, la route, les bandes horizontales et les lignes de division, en utilisant la fonction auxiliaire générale </font></font><code>Render.polygon</code> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(voir . </font></font><code>common.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu de voiture</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, la dernière chose dont la méthode a besoin </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est un rendu Ferrari:</font></font><br>
<br>
<pre><code class="javascript hljs">  Render.player(ctx, width, height, resolution, roadWidth, sprites, speed/maxSpeed,<font></font>
                cameraDepth/playerZ,<font></font>
                width/<span class="hljs-number">2</span>,<font></font>
                height);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette méthode est appelée </font></font><code>player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et non </font></font><code>car</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car dans la version finale du jeu, il y aura d'autres voitures sur la route, et nous voulons séparer la Ferrari du joueur des autres voitures. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction d'assistance </font></font><code>Render.player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilise la méthode canvas appelée </font></font><code>drawImage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour rendre le sprite, après l'avoir précédemment mis à l'échelle en utilisant la même mise à l'échelle de projection que celle utilisée auparavant:</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Où </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans ce cas est la distance relative de la machine à la caméra, stockée dans la variable </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">playerZ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, la fonction «secoue» un peu la voiture à grande vitesse, ajoutant un peu de caractère aléatoire à l'équation de mise à l'échelle, en fonction de la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vitesse / vitesse maximale</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et voici ce que nous avons obtenu:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/845/dfd/3e8/845dfd3e88ef0a22b2c9fd021140ff3b.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons fait un travail assez important juste pour créer un système avec des routes droites. </font><font style="vertical-align: inherit;">Nous avons ajouté</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">module d'assistance générique </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dom</font></font></strong></li>
<li><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">Utiliser</font></strong><font style="vertical-align: inherit;"> le module mathématique général</font></font><strong><font style="vertical-align: inherit;"></font></strong></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Module d'aide au </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rendu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> général du canevas </font><font style="vertical-align: inherit;">...</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... y compris </font></font><code>Render.segment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Render.polygon</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et</font></font><code>Render.sprite</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cycle de jeu à pas fixe</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">téléchargeur d'images</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gestionnaire de clavier</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fond de parallaxe</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">feuille de sprite avec des voitures, des arbres et des panneaux d'affichage</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">géométrie rudimentaire de la route</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthode </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour contrôler la machine</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthode </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de rendu de l'arrière-plan, de la route et de la voiture du joueur</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Balise HTML5 </font></font><code>&lt;audio&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec musique de course (bonus caché!)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... ce qui nous a donné une bonne base pour un développement ultérieur.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 2. Courbes.</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98f/c3d/6d1/98fc3d6d13cc16f12847d253e112fcb2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cette partie, nous expliquerons plus en détail le fonctionnement des courbes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la partie précédente, nous avons compilé la géométrie de la route sous la forme d'un tableau de segments, dont chacun a des coordonnées mondiales, transformés par rapport à la caméra, puis projetés sur l'écran. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous n'avions besoin que de la coordonnée mondiale </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour chaque point, car sur les routes droites, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> étaient égaux à zéro.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c78/551/359/c78551359ef7c11e4af48b4285d61842.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous devions créer un système 3D entièrement fonctionnel, nous pourrions implémenter les courbes en calculant les </font><font style="vertical-align: inherit;">bandes </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des polygones illustrés ci-dessus. Cependant, ce type de géométrie sera assez difficile à calculer, et pour cela il faudra ajouter l'étape de rotation 3d aux équations de projection ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... si nous allions dans ce sens, il serait préférable d'utiliser WebGL ou ses analogues, mais ce projet n'a pas d'autres tâches pour notre projet. Nous voulons simplement utiliser des astuces pseudo-tridimensionnelles à l'ancienne pour simuler des courbes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, vous serez probablement surpris d'apprendre que nous ne calculerons pas du tout les coordonnées </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des segments de route ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lieu de cela, nous utiliserons </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les conseils de Lu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Pour courber la route, changez simplement la position de la ligne centrale de la forme de la courbe ... à partir du bas de l'écran, la quantité de décalage du centre de la route vers la gauche ou la droite augmente progressivement</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><em><font style="vertical-align: inherit;">"</font></em></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre cas, la ligne médiane est la valeur </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passée aux calculs de projection. </font><font style="vertical-align: inherit;">Cela signifie que lorsque nous effectuons </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaque segment de la route, vous pouvez simuler les courbes en décalant la valeur </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'une valeur progressivement croissante.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8a/569/19e/c8a56919e67d6f19cc737074ce92fffb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour savoir combien changer, nous devons stocker une valeur dans chaque segment </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cette valeur indique dans quelle mesure le segment doit être décalé de la ligne centrale de la caméra. </font><font style="vertical-align: inherit;">Elle sera:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">négatif pour les virages à gauche</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">positif pour les courbes tournant à droite</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moins pour les courbes lisses</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plus pour les courbes nettes</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les valeurs elles-mêmes sont choisies assez arbitrairement; </font><font style="vertical-align: inherit;">par essais et erreurs, nous pouvons trouver de bonnes valeurs auxquelles les courbes semblent être «correctes»:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> ROAD = {
  <span class="hljs-attr">LENGTH</span>: { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">SHORT</span>:  <span class="hljs-number">25</span>, <span class="hljs-attr">MEDIUM</span>:  <span class="hljs-number">50</span>, <span class="hljs-attr">LONG</span>:  <span class="hljs-number">100</span> }, <span class="hljs-comment">// num segments</span>
  <span class="hljs-attr">CURVE</span>:  { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">EASY</span>:    <span class="hljs-number">2</span>, <span class="hljs-attr">MEDIUM</span>:   <span class="hljs-number">4</span>, <span class="hljs-attr">HARD</span>:    <span class="hljs-number">6</span> }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus de choisir de bonnes valeurs pour les courbes, nous devons éviter tout écart dans les transitions lorsque la ligne se transforme en courbe (ou vice versa). </font><font style="vertical-align: inherit;">Ceci peut être réalisé en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adoucissant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lors de l'entrée et de la sortie des courbes. </font><font style="vertical-align: inherit;">Pour ce faire, nous augmenterons (ou diminuerons) progressivement la valeur </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de chaque segment à l'aide des fonctions de lissage traditionnelles jusqu'à ce qu'il atteigne la valeur souhaitée:</font></font><br>
<br>
<pre><code class="javascript hljs">easeIn:    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*<span class="hljs-built_in">Math</span>.pow(percent,<span class="hljs-number">2</span>);                           },
<span class="hljs-attr">easeOut</span>:   <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*(<span class="hljs-number">1</span>-<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">1</span>-percent,<span class="hljs-number">2</span>));                     },
<span class="hljs-attr">easeInOut</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*((-<span class="hljs-built_in">Math</span>.cos(percent*<span class="hljs-built_in">Math</span>.PI)/<span class="hljs-number">2</span>) + <span class="hljs-number">0.5</span>);        },</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est, maintenant, en tenant compte de la fonction d'ajouter un segment à la géométrie ...</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params">curve</span>) </span>{
  <span class="hljs-keyword">var</span> n = segments.length;<font></font>
  segments.push({<font></font>
     <span class="hljs-attr">index</span>: n,
        <span class="hljs-attr">p1</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>:  n   *segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
        <span class="hljs-attr">p2</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>: (n+<span class="hljs-number">1</span>)*segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
     <span class="hljs-attr">curve</span>: curve,
     <span class="hljs-attr">color</span>: <span class="hljs-built_in">Math</span>.floor(n/rumbleLength)%<span class="hljs-number">2</span> ? COLORS.DARK : COLORS.LIGHT<font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nous pouvons créer une méthode pour une entrée, une recherche et une sortie en douceur d'une route incurvée:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRoad</span>(<span class="hljs-params">enter, hold, leave, curve</span>) </span>{
  <span class="hljs-keyword">var</span> n;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; enter ; n++)<font></font>
    addSegment(Util.easeIn(<span class="hljs-number">0</span>, curve, n/enter));
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; hold  ; n++)<font></font>
    addSegment(curve);<font></font>
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; leave ; n++)<font></font>
    addSegment(Util.easeInOut(curve, <span class="hljs-number">0</span>, n/leave));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... et en plus, vous pouvez imposer une géométrie supplémentaire, par exemple des courbes en S:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSCurves</span>(<span class="hljs-params"></span>) </span>{<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,   ROAD.CURVE.MEDIUM);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,   ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.MEDIUM);<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifications de la méthode update ()</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les seuls changements à apporter à la méthode </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont l'application d'une sorte de force centrifuge lorsque la machine se déplace le long d'une courbe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous définissons un facteur arbitraire qui peut être ajusté selon nos préférences.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> centrifugal = <span class="hljs-number">0.3</span>;   <span class="hljs-comment">// centrifugal force multiplier when going around curves</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et puis nous allons simplement mettre à jour la position en </font></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonction de sa vitesse actuelle, de la valeur de la courbe et du multiplicateur de force centrifuge:</font></font><br>
<br>
<pre><code class="javascript hljs">playerX = playerX - (dx * speedPercent * playerSegment.curve * centrifugal);</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu de courbe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons dit ci-dessus que vous pouvez rendre des courbes simulées en décalant la valeur </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisée dans les calculs de projection lors de l'exécution de </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaque segment de route.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8a/569/19e/c8a56919e67d6f19cc737074ce92fffb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ce faire, nous allons stocker la variable d'entraînement </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en augmentant pour chaque segment d'une valeur </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ainsi que la variable </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui sera utilisée comme décalage de la valeur </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisée dans les calculs de projection. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour implémenter les courbes, nous avons besoin des éléments suivants:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">décaler la projection </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1 de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chaque segment de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">décaler la projection </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2 de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chaque segment de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">augmenter </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour le segment suivant de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, afin d'éviter les transitions déchirées lors du franchissement des frontières des segments, il faut faire </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> initialisé avec la valeur interpolée de la courbe des segments de base courants. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modifiez la méthode </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme suit:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> baseSegment = findSegment(position);
<span class="hljs-keyword">var</span> basePercent = Util.percentRemaining(position, segmentLength);
<span class="hljs-keyword">var</span> dx = - (baseSegment.curve * basePercent);
<span class="hljs-keyword">var</span> x  = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; drawDistance ; n++) {<font></font>
<font></font>
  ...<font></font>
<font></font>
  Util.project(segment.p1, (playerX * roadWidth) - x,      cameraHeight, position - (segment.looped ? trackLength : <span class="hljs-number">0</span>), cameraDepth, width, height, roadWidth);<font></font>
  Util.project(segment.p2, (playerX * roadWidth) - x - dx, cameraHeight, position - (segment.looped ? trackLength : <span class="hljs-number">0</span>), cameraDepth, width, height, roadWidth);<font></font>
<font></font>
  x  = x + dx;<font></font>
  dx = dx + segment.curve;<font></font>
<font></font>
  ...<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fond de défilement de parallaxe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, nous devons faire défiler les couches d'arrière-plan de parallaxe, en stockant le décalage pour chaque couche ...</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> skySpeed    = <span class="hljs-number">0.001</span>; <span class="hljs-comment">// background sky layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> hillSpeed   = <span class="hljs-number">0.002</span>; <span class="hljs-comment">// background hill layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> treeSpeed   = <span class="hljs-number">0.003</span>; <span class="hljs-comment">// background tree layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> skyOffset   = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current sky scroll offset</span>
<span class="hljs-keyword">var</span> hillOffset  = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current hill scroll offset</span>
<span class="hljs-keyword">var</span> treeOffset  = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current tree scroll offset</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... et l'augmenter dans le temps en </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonction de la valeur de la courbe du segment de joueur actuel et de sa vitesse ...</font></font><br>
<br>
<pre><code class="javascript hljs">skyOffset  = Util.increase(skyOffset,  skySpeed  * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);<font></font>
hillOffset = Util.increase(hillOffset, hillSpeed * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);<font></font>
treeOffset = Util.increase(treeOffset, treeSpeed * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... puis utilisez pour utiliser ce décalage lors de la création de </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calques d'arrière-plan.</font></font><br>
<br>
<pre><code class="javascript hljs">Render.background(ctx, background, width, height, BACKGROUND.SKY,   skyOffset);<font></font>
Render.background(ctx, background, width, height, BACKGROUND.HILLS, hillOffset);<font></font>
Render.background(ctx, background, width, height, BACKGROUND.TREES, treeOffset);</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, ici, nous obtenons les fausses courbes pseudo-tridimensionnelles:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98f/c3d/6d1/98fc3d6d13cc16f12847d253e112fcb2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La partie principale du code que nous avons ajouté est de construire la géométrie de la route avec la valeur correspondante </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En le réalisant, ajouter de la force centrifuge pendant le temps est </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beaucoup plus facile. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le rendu de courbe est effectué en quelques lignes de code, mais il peut être difficile de comprendre (et décrire) ce qui se passe exactement ici. Il existe de nombreuses façons de simuler des courbes et il est très facile de se promener lorsqu'elles sont implémentées dans une impasse. Il est encore plus facile de se laisser emporter par une tâche extérieure et d'essayer de tout faire «correctement»; avant de vous en rendre compte, vous commencerez à créer un système 3D entièrement fonctionnel avec des matrices, des rotations et une vraie géométrie 3D ... ce qui, comme je l'ai dit, n'est pas notre tâche.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque j'ai écrit cet article, j'étais sûr qu'il y avait définitivement des problèmes dans ma mise en œuvre des courbes. </font><font style="vertical-align: inherit;">En essayant de visualiser l'algorithme, je ne comprenais pas pourquoi j'avais besoin de deux valeurs des lecteurs </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au lieu d'une ... et si je ne peux pas expliquer complètement quelque chose, alors quelque chose s'est mal passé quelque part ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... mais le temps du projet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" le week-end »a</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> presque expiré et, franchement, les courbes me semblent assez belles, et au final, c'est le plus important.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr499240/index.html">À travers les épines jusqu'aux étoiles ou l'analyse des données dans les affaires du ciel</a></li>
<li><a href="../fr499242/index.html">Les chercheurs ont transmis des données à partir d'un ordinateur de bureau via des vibrations sur une table</a></li>
<li><a href="../fr499244/index.html">Organisations synergiques. Partie II</a></li>
<li><a href="../fr499246/index.html">Enquête sur la fonction logistique en tant que loi de développement de l'industrie</a></li>
<li><a href="../fr499248/index.html">Comment nous reconnaissons les équipements de protection individuelle</a></li>
<li><a href="../fr499254/index.html">Un membre du comité du programme PyConRu 2020 répond aux questions sur Python: un look à jour et un peu de fourchelang</a></li>
<li><a href="../fr499262/index.html">Dernier hackathon en ligne pour les indépendants SMZhack: des projets qui toucheront les gens</a></li>
<li><a href="../fr499268/index.html">Conscience spatiale: que peuvent faire les lunettes Hololens?</a></li>
<li><a href="../fr499272/index.html">Composants de soudure 0201. Nerveux, veuillez vous éloigner des écrans</a></li>
<li><a href="../fr499274/index.html">Nous avons démonté la nouvelle capsule. Nous savons combien de microphones et comment cela fonctionne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>