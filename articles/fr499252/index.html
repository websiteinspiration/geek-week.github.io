<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè∞ üë®üèæ‚Äçüé® üéä Cr√©ation d'un jeu de course pseudo-tridimensionnel üîö üéÄ üôèüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Enfant, je suis rarement all√© dans des salles d'arcade parce que je n'en avais pas vraiment besoin, parce que j'avais des jeux g√©niaux pour C64 √† la m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Cr√©ation d'un jeu de course pseudo-tridimensionnel</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499252/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d16/6e3/cff/d166e3cff9c2a3cefeb68f5c1ddc02d1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfant, je suis rarement all√© dans des salles d'arcade parce que je n'en avais pas vraiment besoin, parce que j'avais des jeux g√©niaux pour C64 √† la maison ... mais il y a trois jeux d'arcade pour lesquels j'ai toujours eu de l'argent - Donkey Kong, Dragons Lair et Outrun ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... et j'ai vraiment ador√© Outrun - vitesse, collines, palmiers et musique, m√™me sur la version faible du C64.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48e/aee/56f/48eaee56f43d8a25e840c6ae13268db4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai donc d√©cid√© d'essayer d'√©crire un jeu de course pseudo-tridimensionnel √† l'ancienne dans le style d'Outrun, Pitstop ou Pole position. </font><font style="vertical-align: inherit;">Je n'ai pas l'intention de monter un jeu complet et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">complet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais il me semble qu'il sera int√©ressant de r√©examiner les m√©canismes avec lesquels ces jeux ont r√©alis√© leurs tours. </font><font style="vertical-align: inherit;">Courbes, collines, sprites et sens de la vitesse ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors, voici mon ¬´projet de week-end¬ª, qui a finalement pris cinq ou six semaines le week-end</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/27b/d28/7ec27bd28630dbbaf7b81c87233c28ac.png"></div><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jouer √† un jeu</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afficher </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le code source</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La version jouable ressemble plus √† une d√©mo technique qu'√† un vrai jeu. </font><font style="vertical-align: inherit;">En fait, si vous voulez cr√©er une v√©ritable course pseudo-tridimensionnelle, ce sera la base la plus minimale dont vous aurez besoin pour devenir progressivement un jeu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'est pas poli, un peu moche, mais enti√®rement fonctionnel. </font><font style="vertical-align: inherit;">Je vais vous montrer comment l'impl√©menter par vous-m√™me en quatre √©tapes simples. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez √©galement jouer</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©monstration directe de la route</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©mo avec des courbes</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©mo avec les collines</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">version finale</font></font></a></li>
</ul><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä propos des performances</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les performances de ce jeu </font><font style="vertical-align: inherit;">d√©pendent </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fortement</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la machine / du navigateur. </font><font style="vertical-align: inherit;">Dans les navigateurs modernes, cela fonctionne bien, en particulier dans ceux qui ont une acc√©l√©ration du GPU Canvas, mais un mauvais pilote graphique peut le geler. </font><font style="vertical-align: inherit;">Dans le jeu, vous pouvez modifier la r√©solution de rendu et la distance de rendu.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä propos de la structure du code</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il se trouve que le projet a √©t√© impl√©ment√© en Javascript (en raison de la simplicit√© du prototypage), mais il n'est pas destin√© √† d√©montrer les techniques ou les techniques recommand√©es de Javascript. </font><font style="vertical-align: inherit;">En fait, pour faciliter la compr√©hension, le Javascript de chaque exemple est int√©gr√© directement dans la page HTML (horreur!); </font><font style="vertical-align: inherit;">pire, il utilise des variables et des fonctions globales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si je cr√©ais un vrai jeu, le code serait beaucoup plus structur√© et rationalis√©, mais comme il s'agit d'une d√©monstration technique d'un jeu de course, j'ai d√©cid√© de m'en tenir √† </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KISS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 1. Routes droites.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors, comment pouvons-nous commencer √† cr√©er un jeu de course pseudo-tridimensionnel? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, nous avons besoin</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©p√©ter la trigonom√©trie</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rappelez les bases de la projection 3D</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©er une boucle de jeu</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T√©l√©charger des images de sprite</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Construire la g√©om√©trie de la route</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fond de rendu</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendre la route</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendre la voiture</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Impl√©menter la prise en charge du clavier pour le contr√¥le de la machine</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais avant de </font><font style="vertical-align: inherit;">commencer, Lisons </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pseudo 3d page de Lou</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traduction</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Habr√©] - la seule source d'information (que je pouvais trouver) sur la </font><font style="vertical-align: inherit;">fa√ßon de cr√©er jeu de course psevdotrohmernuyu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous avez fini de lire l'article de Lou? </font><font style="vertical-align: inherit;">Bien! </font><font style="vertical-align: inherit;">Nous allons cr√©er une variation de sa technique Realistic Hills Using 3D-Projected Segments. </font><font style="vertical-align: inherit;">Nous le ferons progressivement au cours des quatre prochaines parties. </font><font style="vertical-align: inherit;">Mais nous allons commencer maintenant, avec la version v1, et cr√©er une g√©om√©trie de route droite tr√®s simple en la projetant sur un √©l√©ment de toile HTML5.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La d√©mo peut √™tre vue </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un peu de trigonom√©trie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant d'entrer dans l'impl√©mentation, utilisons les bases de la trigonom√©trie pour nous rappeler comment projeter un point du monde 3D sur un √©cran 2D. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cas le plus simple, si vous ne touchez pas aux vecteurs et aux matrices, la loi des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">triangles similaires est</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilis√©e pour la projection 3D </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous utilisons la notation suivante:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = hauteur de la cam√©ra</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = distance de la cam√©ra √† l'√©cran</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = distance de la cam√©ra √† la voiture</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = coordonn√©es </font><strong><font style="vertical-align: inherit;">y de l'</font></strong><font style="vertical-align: inherit;"> √©cran</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous pouvons utiliser la loi des triangles similaires pour calculer </font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y = h * d / z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
comme le montre le sch√©ma:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/949/0ab/47b/9490ab47bb570b61218e46e5913c18bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez √©galement dessiner un diagramme similaire dans une vue de dessus au lieu d'une vue lat√©rale et d√©river une √©quation similaire pour calculer la coordonn√©e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de l' </font><font style="vertical-align: inherit;">√©cran:</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x = w * d / z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O√π </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = la moiti√© de la largeur de la route (de la cam√©ra au bord de la route). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, pour </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous √©voluons d'un facteur</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d / z</font></font></strong></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syst√®mes de coordonn√©es</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sous la forme d'un diagramme, il a l'air beau et simple, mais lorsque vous commencez √† coder, vous pouvez √™tre un peu confus, car nous avons choisi des noms arbitraires, et on ne sait pas ce que nous avons indiqu√© les coordonn√©es du monde 3D et quelles sont les coordonn√©es de l'√©cran 2D. </font><font style="vertical-align: inherit;">Nous supposons √©galement que la cam√©ra est au centre de l'origine du monde, bien qu'en r√©alit√© elle suivra la machine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous vous approchez de mani√®re plus formelle, nous devons effectuer:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conversion</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des coordonn√©es du monde en coordonn√©es d'√©cran</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projection</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des coordonn√©es de la cam√©ra sur un plan de projection normalis√©</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mettre √† l'√©chelle les</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordonn√©es projet√©es aux coordonn√©es de l'√©cran physique (dans notre cas, c'est du canevas)</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/5d2/30f/b595d230f4f45b9b0c9409266d5804d8.png"></div><br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque: dans le syst√®me 3D actuel </font><font style="vertical-align: inherit;">, l' </font><font style="vertical-align: inherit;">√©tape de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rotation</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est effectu√©e entre les √©tapes 1 et 2 </font><font style="vertical-align: inherit;">, mais comme nous simulerons les courbes, nous n'avons pas besoin d'une rotation.</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projection</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les √©quations de projection formelles peuvent √™tre repr√©sent√©es comme suit:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/246/e18/edb246e187e7fe0eb027b53c58790c34.png"></div><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le point d'√©quations de conversion ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">translate</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) est calcul√© par rapport √† la chambre</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les √©quations de projection ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projet</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sont des variations de la ¬´loi des triangles similaires¬ª illustr√©e ci-dessus.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les √©quations de mise √† l' </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©chelle</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><strong><font style="vertical-align: inherit;">√©chelle</font></strong><font style="vertical-align: inherit;"> ) tiennent compte de la diff√©rence entre:</font></font><br>
<ul>
<li><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">math√©matiques</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o√π 0,0 est au centre et l'axe y est en haut, et</font></font></li>
<li><em></em>,  0,0     ,   y  :</li>
</ul></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11f/050/aad/11f050aadea0d1c537baefcb06f7c2f0.png"></div><br>
<blockquote><em>:   3d-         <code>Vector</code>  <code>Matrix</code>     3d-,      ,      WebGL (  )‚Ä¶       .           Outrun.</em></blockquote><br>
<h2>  </h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b7/27b/1bd/3b727b1bdb285d874bd659c29db13522.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La derni√®re pi√®ce du puzzle sera un moyen de calculer </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - la distance entre la cam√©ra et le plan de projection. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lieu d'√©crire simplement une valeur fixe de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , il serait plus utile de la calculer √† partir du champ de vision vertical souhait√©. </font><font style="vertical-align: inherit;">Gr√¢ce √† cela, nous pourrons "zoomer" la cam√©ra si n√©cessaire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous supposons que nous projetons sur un plan de projection normalis√©, dont les coordonn√©es sont comprises entre -1 et +1, alors </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peut √™tre calcul√© comme suit:</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 / bronzage (fov / 2)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©finissant fov</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme une (parmi plusieurs) variables, nous pouvons ajuster la port√©e pour affiner l'algorithme de rendu.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Structure du code Javascript</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au d√©but de l'article, j'ai d√©j√† dit que le code n'√©tait pas tout √† fait conforme aux directives pour √©crire Javascript - c'est une d√©mo ¬´rapide et sale¬ª avec des variables et fonctions globales simples. </font><font style="vertical-align: inherit;">Cependant, puisque je vais cr√©er quatre versions distinctes (droite, courbes, collines et sprites), je vais stocker des m√©thodes r√©utilisables √† l'int√©rieur </font></font><code>common.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans les modules suivants:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dom</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est quelques fonctions d'assistance DOM mineures.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Util</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - utilitaires g√©n√©raux, principalement des fonctions math√©matiques auxiliaires.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Fonctions g√©n√©rales d'assistance au jeu, telles que le t√©l√©chargement d'images et la boucle de jeu.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - fonctions de rendu d'aide sur le canevas.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'expliquerai en d√©tail les m√©thodes de </font></font><code>common.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seulement si elles se rapportent au jeu lui-m√™me, et ne sont pas seulement des fonctions math√©matiques ou DOM auxiliaires. </font><font style="vertical-align: inherit;">Esp√©rons que d'apr√®s le nom et le contexte, il sera clair ce que les m√©thodes devraient faire.</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme d'habitude, le code source est dans la documentation finale.</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boucle de jeu simple</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de rendre quelque chose, nous avons besoin d'une boucle de jeu. </font><font style="vertical-align: inherit;">Si vous avez lu l'un de mes articles pr√©c√©dents sur les jeux ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pong</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">breakout</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tetris</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">snakes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boulderdash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), vous avez d√©j√† vu des exemples de mon cycle de jeu pr√©f√©r√© avec un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas de temps fixe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'entrerai pas dans les d√©tails, et je r√©utiliserai simplement une partie du code des jeux pr√©c√©dents pour cr√©er une boucle de jeu avec un pas de temps fixe en utilisant </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requestAnimationFrame</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le principe est que chacun de mes quatre exemples peut appeler </font></font><code>Game.run(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et utiliser ses propres versions</font></font><br>
<br>
<ul>
<li><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Mise √† jour du monde du jeu avec un pas de temps fixe.</font></font></li>
<li><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Mise √† jour du monde du jeu lorsque le navigateur le permet.</font></font></li>
</ul><br>
<pre><code class="javascript hljs">run: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{<font></font>
<font></font>
  Game.loadImages(options.images, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">images</span>) </span>{<font></font>
<font></font>
    <span class="hljs-keyword">var</span> update = options.update,    <span class="hljs-comment">// method to update game logic is provided by caller</span>
        render = options.render,    <span class="hljs-comment">// method to render the game is provided by caller</span>
        step   = options.step,      <span class="hljs-comment">// fixed frame step (1/fps) is specified by caller</span>
        now    = <span class="hljs-literal">null</span>,<font></font>
        last   = Util.timestamp(),<font></font>
        dt     = <span class="hljs-number">0</span>,<font></font>
        gdt    = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">frame</span>(<span class="hljs-params"></span>) </span>{<font></font>
      now = Util.timestamp();<font></font>
      dt  = <span class="hljs-built_in">Math</span>.min(<span class="hljs-number">1</span>, (now - last) / <span class="hljs-number">1000</span>); <span class="hljs-comment">// using requestAnimationFrame have to be able to handle large delta's caused when it 'hibernates' in a background or non-visible tab</span><font></font>
      gdt = gdt + dt;<font></font>
      <span class="hljs-keyword">while</span> (gdt &gt; step) {<font></font>
        gdt = gdt - step;<font></font>
        update(step);<font></font>
      }<font></font>
      render();<font></font>
      last = now;<font></font>
      requestAnimationFrame(frame);<font></font>
    }<font></font>
    frame(); <span class="hljs-comment">// lets get this party started</span><font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encore une fois, il s'agit d'un remake des id√©es de mes pr√©c√©dents jeux de toile, donc si vous ne comprenez pas comment fonctionne la boucle de jeu, revenez √† l'un des articles pr√©c√©dents.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Images et sprites</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant le d√©but du cycle de jeu, nous chargeons deux feuilles de sprites s√©par√©es (feuilles de sprites):</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fond</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - trois couches de parallaxe pour le ciel, les collines et les arbres</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sprites</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><strong><font style="vertical-align: inherit;">sprites</font></strong><font style="vertical-align: inherit;"> machine (plus des arbres et des panneaux d'affichage √† ajouter √† la version finale)</font></font></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6f/111/acc/f6f111accbba448459e25c6fe761ff05.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La feuille de sprite a √©t√© g√©n√©r√©e √† l'aide d'une petite </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usine de sprites</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rake and </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Ruby Gem</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette t√¢che g√©n√®re les feuilles de sprites combin√©es, ainsi que les coordonn√©es x, y, w, h, qui seront stock√©es dans les constantes </font></font><code>BACKGROUND</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>SPRITES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque: J'ai cr√©√© les arri√®re-plans √† l'aide d'Inkscape, et la plupart des sprites sont des graphiques </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tir√©s</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de l'ancienne version Outrun pour Genesis et utilis√©s comme exemples de formation.</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variables de jeu</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus des images d'arri√®re-plans et de sprites, nous aurons besoin de plusieurs variables de jeu, √† savoir:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> fps           = <span class="hljs-number">60</span>;                      <span class="hljs-comment">// how many 'update' frames per second</span>
<span class="hljs-keyword">var</span> step          = <span class="hljs-number">1</span>/fps;                   <span class="hljs-comment">// how long is each frame (in seconds)</span>
<span class="hljs-keyword">var</span> width         = <span class="hljs-number">1024</span>;                    <span class="hljs-comment">// logical canvas width</span>
<span class="hljs-keyword">var</span> height        = <span class="hljs-number">768</span>;                     <span class="hljs-comment">// logical canvas height</span>
<span class="hljs-keyword">var</span> segments      = [];                      <span class="hljs-comment">// array of road segments</span>
<span class="hljs-keyword">var</span> canvas        = Dom.get(<span class="hljs-string">'canvas'</span>);       <span class="hljs-comment">// our canvas...</span>
<span class="hljs-keyword">var</span> ctx           = canvas.getContext(<span class="hljs-string">'2d'</span>); <span class="hljs-comment">// ...and its drawing context</span>
<span class="hljs-keyword">var</span> background    = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// our background image (loaded below)</span>
<span class="hljs-keyword">var</span> sprites       = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// our spritesheet (loaded below)</span>
<span class="hljs-keyword">var</span> resolution    = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// scaling factor to provide resolution independence (computed)</span>
<span class="hljs-keyword">var</span> roadWidth     = <span class="hljs-number">2000</span>;                    <span class="hljs-comment">// actually half the roads width, easier math if the road spans from -roadWidth to +roadWidth</span>
<span class="hljs-keyword">var</span> segmentLength = <span class="hljs-number">200</span>;                     <span class="hljs-comment">// length of a single segment</span>
<span class="hljs-keyword">var</span> rumbleLength  = <span class="hljs-number">3</span>;                       <span class="hljs-comment">// number of segments per red/white rumble strip</span>
<span class="hljs-keyword">var</span> trackLength   = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// z length of entire track (computed)</span>
<span class="hljs-keyword">var</span> lanes         = <span class="hljs-number">3</span>;                       <span class="hljs-comment">// number of lanes</span>
<span class="hljs-keyword">var</span> fieldOfView   = <span class="hljs-number">100</span>;                     <span class="hljs-comment">// angle (degrees) for field of view</span>
<span class="hljs-keyword">var</span> cameraHeight  = <span class="hljs-number">1000</span>;                    <span class="hljs-comment">// z height of camera</span>
<span class="hljs-keyword">var</span> cameraDepth   = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// z distance camera is from screen (computed)</span>
<span class="hljs-keyword">var</span> drawDistance  = <span class="hljs-number">300</span>;                     <span class="hljs-comment">// number of segments to draw</span>
<span class="hljs-keyword">var</span> playerX       = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// player x offset from center of road (-1 to 1 to stay independent of roadWidth)</span>
<span class="hljs-keyword">var</span> playerZ       = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// player relative z distance from camera (computed)</span>
<span class="hljs-keyword">var</span> fogDensity    = <span class="hljs-number">5</span>;                       <span class="hljs-comment">// exponential fog density</span>
<span class="hljs-keyword">var</span> position      = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// current camera Z position (add playerZ to get player's absolute Z position)</span>
<span class="hljs-keyword">var</span> speed         = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// current speed</span>
<span class="hljs-keyword">var</span> maxSpeed      = segmentLength/step;      <span class="hljs-comment">// top speed (ensure we can't move more than 1 segment in a single frame to make collision detection easier)</span>
<span class="hljs-keyword">var</span> accel         =  maxSpeed/<span class="hljs-number">5</span>;             <span class="hljs-comment">// acceleration rate - tuned until it 'felt' right</span>
<span class="hljs-keyword">var</span> breaking      = -maxSpeed;               <span class="hljs-comment">// deceleration rate when braking</span>
<span class="hljs-keyword">var</span> decel         = -maxSpeed/<span class="hljs-number">5</span>;             <span class="hljs-comment">// 'natural' deceleration rate when neither accelerating, nor braking</span>
<span class="hljs-keyword">var</span> offRoadDecel  = -maxSpeed/<span class="hljs-number">2</span>;             <span class="hljs-comment">// off road deceleration is somewhere in between</span>
<span class="hljs-keyword">var</span> offRoadLimit  =  maxSpeed/<span class="hljs-number">4</span>;             <span class="hljs-comment">// limit when off road deceleration no longer applies (e.g. you can always go at least this speed even when off road)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certains d'entre eux peuvent √™tre personnalis√©s √† l'aide de contr√¥les d'interface utilisateur pour modifier les valeurs critiques lors de l'ex√©cution du programme afin que vous puissiez voir comment elles affectent le rendu de la route. </font><font style="vertical-align: inherit;">D'autres sont recalcul√©s √† partir des valeurs d'interface utilisateur personnalis√©es dans la m√©thode </font></font><code>reset()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous g√©rons Ferrari</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous effectuons des raccourcis clavier pour </font></font><code>Game.run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui fournit une entr√©e de clavier simple qui d√©finit ou r√©initialise les variables qui signalent les actions actuelles du joueur:</font></font><br>
<br>
<pre><code class="javascript hljs">Game.run({<font></font>
  ...<font></font>
  keys: [<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.LEFT,  KEY.A], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyLeft   = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.RIGHT, KEY.D], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyRight  = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.UP,    KEY.W], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyFaster = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.DOWN,  KEY.S], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keySlower = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.LEFT,  KEY.A], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyLeft   = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.RIGHT, KEY.D], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyRight  = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.UP,    KEY.W], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyFaster = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.DOWN,  KEY.S], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keySlower = <span class="hljs-literal">false</span>; } }<font></font>
  ],<font></font>
  ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'√©tat du joueur est contr√¥l√© par les variables suivantes:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speed</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><strong><font style="vertical-align: inherit;">vitesse</font></strong><font style="vertical-align: inherit;"> actuelle.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">position</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - la position Z actuelle sur la piste. </font><font style="vertical-align: inherit;">Notez qu'il s'agit d'une position de cam√©ra, pas d'une Ferrari.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">playerX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - position actuelle du joueur sur X sur la route. </font><font style="vertical-align: inherit;">Normalis√© dans la plage de -1 √† +1, afin de ne pas d√©pendre de la valeur r√©elle </font></font><code>roadWidth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces variables sont d√©finies √† l'int√©rieur de la m√©thode </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui effectue les actions suivantes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mises √† jour </font></font><code>position</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bas√©es sur le courant </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se met </font></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† </font><font style="vertical-align: inherit;">jour </font><font style="vertical-align: inherit;">lorsque vous appuyez sur la touche gauche ou droite.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">augmente </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si la touche haut est enfonc√©e.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diminue </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si la touche bas est enfonc√©e.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©duit </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si les touches haut et bas ne sont pas enfonc√©es.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©duit </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s'il est </font></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">situ√© en bordure de route et sur l'herbe.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cas des routes directes, la m√©thode est </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assez claire et simple:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">dt</span>) </span>{<font></font>
<font></font>
  position = Util.increase(position, dt * speed, trackLength);<font></font>
<font></font>
  <span class="hljs-keyword">var</span> dx = dt * <span class="hljs-number">2</span> * (speed/maxSpeed); <span class="hljs-comment">// at top speed, should be able to cross from left to right (-1 to 1) in 1 second</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span> (keyLeft)<font></font>
    playerX = playerX - dx;<font></font>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (keyRight)<font></font>
    playerX = playerX + dx;<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (keyFaster)<font></font>
    speed = Util.accelerate(speed, accel, dt);<font></font>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (keySlower)<font></font>
    speed = Util.accelerate(speed, breaking, dt);<font></font>
  <span class="hljs-keyword">else</span><font></font>
    speed = Util.accelerate(speed, decel, dt);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (((playerX &lt; <span class="hljs-number">-1</span>) || (playerX &gt; <span class="hljs-number">1</span>)) &amp;&amp; (speed &gt; offRoadLimit))<font></font>
    speed = Util.accelerate(speed, offRoadDecel, dt);<font></font>
<font></font>
  playerX = Util.limit(playerX, <span class="hljs-number">-2</span>, <span class="hljs-number">2</span>);     <span class="hljs-comment">// dont ever let player go too far out of bounds</span>
  speed   = Util.limit(speed, <span class="hljs-number">0</span>, maxSpeed); <span class="hljs-comment">// or exceed maxSpeed</span><font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ne vous inqui√©tez pas, cela deviendra beaucoup plus difficile lorsque dans la version finale, nous ajouterons des sprites et la reconnaissance des collisions.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G√©om√©trie routi√®re</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de pouvoir rendre le monde du jeu, nous devons cr√©er un tableau de </font></font><code>segments</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in dans la m√©thode </font></font><code>resetRoad()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chacun de ces segments de la route sera finalement projet√© √† partir de ses coordonn√©es mondiales afin qu'il se transforme en un polygone 2D en coordonn√©es d'√©cran. </font><font style="vertical-align: inherit;">Pour chaque segment, nous stockons deux points, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le centre du bord le plus proche de la cam√©ra et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le centre du bord le plus √©loign√© de la cam√©ra.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53a/fa4/076/53afa40768a00b49833703b1457a6941.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä proprement parler, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2 de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chaque segment est identique √† </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1 du</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segment pr√©c√©dent, mais il me semble qu'il est plus facile de les stocker en tant que points s√©par√©s et de convertir chaque segment s√©par√©ment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous restons s√©par√©s </font></font><code>rumbleLength</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">car nous pouvons avoir de belles courbes et collines d√©taill√©es, mais en m√™me temps des rayures horizontales. Si chaque segment suivant a une couleur diff√©rente, cela cr√©era un mauvais effet stroboscopique. Par cons√©quent, nous voulons avoir de nombreux petits segments, mais les regrouper pour former des bandes horizontales distinctes.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetRoad</span>(<span class="hljs-params"></span>) </span>{<font></font>
  segments = [];<font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span> ; n &lt; <span class="hljs-number">500</span> ; n++) { <span class="hljs-comment">// arbitrary road length</span><font></font>
    segments.push({<font></font>
       <span class="hljs-attr">index</span>: n,
       <span class="hljs-attr">p1</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>:  n   *segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
       <span class="hljs-attr">p2</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>: (n+<span class="hljs-number">1</span>)*segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
       <span class="hljs-attr">color</span>: <span class="hljs-built_in">Math</span>.floor(n/rumbleLength)%<span class="hljs-number">2</span> ? COLORS.DARK : COLORS.LIGHT<font></font>
    });<font></font>
  }<font></font>
<font></font>
  trackLength = segments.length * segmentLength;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous initialisons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uniquement avec les coordonn√©es du monde </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , car nous n'avons besoin que de routes droites. Les coordonn√©es </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seront toujours 0 et les coordonn√©es </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©pendront toujours de la valeur mise √† l'√©chelle </font></font><code>+/- roadWidth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Plus tard, lorsque nous ajouterons des courbes et des collines, cette partie changera. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons √©galement d√©finir des objets vides pour stocker des repr√©sentations de ces points dans la cam√©ra et sur l'√©cran afin de ne pas cr√©er un tas d'objets temporaires dans chacun </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pour minimiser la r√©cup√©ration de place, nous devons √©viter d'allouer des objets dans la boucle de jeu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque la voiture atteint la fin de la route, nous revenons simplement au d√©but du cycle. </font><font style="vertical-align: inherit;">Pour simplifier cela, nous allons cr√©er une m√©thode pour trouver un segment pour n'importe quelle valeur de Z, m√™me s'il d√©passe la longueur de la route:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findSegment</span>(<span class="hljs-params">z</span>) </span>{
  <span class="hljs-keyword">return</span> segments[<span class="hljs-built_in">Math</span>.floor(z/segmentLength) % segments.length];<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu en arri√®re-plan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La m√©thode </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commence par le rendu de l'image d'arri√®re-plan. </font><font style="vertical-align: inherit;">Dans les parties suivantes, o√π nous ajouterons des courbes et des collines, nous aurons besoin de l'arri√®re-plan pour effectuer le d√©filement de parallaxe, nous allons donc commencer √† nous d√©placer dans cette direction, rendant l'arri√®re-plan en trois couches distinctes:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params"></span>) </span>{<font></font>
<font></font>
  ctx.clearRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<font></font>
<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.SKY);<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.HILLS);<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.TREES);<font></font>
<font></font>
  ...</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu routier</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, la fonction de rendu it√®re sur tous les segments et projette </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2 de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chaque segment des coordonn√©es universelles aux coordonn√©es d'√©cran, en coupant le segment si n√©cessaire et en le rendant autrement:</font></font><br>
<br>
<pre><code class="javascript hljs">  <span class="hljs-keyword">var</span> baseSegment = findSegment(position);
  <span class="hljs-keyword">var</span> maxy        = height;
  <span class="hljs-keyword">var</span> n, segment;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; drawDistance ; n++) {<font></font>
<font></font>
    segment = segments[(baseSegment.index + n) % segments.length];<font></font>
<font></font>
    Util.project(segment.p1, (playerX * roadWidth), cameraHeight, position, cameraDepth, width, height, roadWidth);<font></font>
    Util.project(segment.p2, (playerX * roadWidth), cameraHeight, position, cameraDepth, width, height, roadWidth);<font></font>
<font></font>
    <span class="hljs-keyword">if</span> ((segment.p1.camera.z &lt;= cameraDepth) || <span class="hljs-comment">// behind us</span>
        (segment.p2.screen.y &gt;= maxy))          <span class="hljs-comment">// clip by (already rendered) segment</span>
      <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
    Render.segment(ctx, width, lanes,<font></font>
                   segment.p1.screen.x,<font></font>
                   segment.p1.screen.y,<font></font>
                   segment.p1.screen.w,<font></font>
                   segment.p2.screen.x,<font></font>
                   segment.p2.screen.y,<font></font>
                   segment.p2.screen.w,<font></font>
                   segment.color);<font></font>
<font></font>
    maxy = segment.p2.screen.y;<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ci-dessus, nous avons d√©j√† vu les calculs n√©cessaires √† la projection d'un point; La version javascript combine la transformation, la projection et la mise √† l'√©chelle en une seule m√©thode:</font></font><br>
<br>
<pre><code class="javascript hljs">project: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth</span>) </span>{<font></font>
  p.camera.x     = (p.world.x || <span class="hljs-number">0</span>) - cameraX;<font></font>
  p.camera.y     = (p.world.y || <span class="hljs-number">0</span>) - cameraY;<font></font>
  p.camera.z     = (p.world.z || <span class="hljs-number">0</span>) - cameraZ;<font></font>
  p.screen.scale = cameraDepth/p.camera.z;<font></font>
  p.screen.x     = <span class="hljs-built_in">Math</span>.round((width/<span class="hljs-number">2</span>)  + (p.screen.scale * p.camera.x  * width/<span class="hljs-number">2</span>));<font></font>
  p.screen.y     = <span class="hljs-built_in">Math</span>.round((height/<span class="hljs-number">2</span>) - (p.screen.scale * p.camera.y  * height/<span class="hljs-number">2</span>));<font></font>
  p.screen.w     = <span class="hljs-built_in">Math</span>.round(             (p.screen.scale * roadWidth   * width/<span class="hljs-number">2</span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus de calculer l'√©cran </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour chaque point </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous utilisons les m√™mes calculs de projection pour calculer la largeur projet√©e ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) du segment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ayant les coordonn√©es d'√©cran </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des </font><font style="vertical-align: inherit;">points </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ainsi que la largeur projet√©e de la route </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous pouvons assez facilement calculer √† l'aide d'une fonction auxiliaire </font></font><code>Render.segment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tous les polygones n√©cessaires pour rendre l'herbe, la route, les bandes horizontales et les lignes de division, en utilisant la fonction auxiliaire g√©n√©rale </font></font><code>Render.polygon</code> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(voir . </font></font><code>common.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu de voiture</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, la derni√®re chose dont la m√©thode a besoin </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est un rendu Ferrari:</font></font><br>
<br>
<pre><code class="javascript hljs">  Render.player(ctx, width, height, resolution, roadWidth, sprites, speed/maxSpeed,<font></font>
                cameraDepth/playerZ,<font></font>
                width/<span class="hljs-number">2</span>,<font></font>
                height);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette m√©thode est appel√©e </font></font><code>player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et non </font></font><code>car</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car dans la version finale du jeu, il y aura d'autres voitures sur la route, et nous voulons s√©parer la Ferrari du joueur des autres voitures. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction d'assistance </font></font><code>Render.player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilise la m√©thode canvas appel√©e </font></font><code>drawImage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour rendre le sprite, apr√®s l'avoir pr√©c√©demment mis √† l'√©chelle en utilisant la m√™me mise √† l'√©chelle de projection que celle utilis√©e auparavant:</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O√π </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans ce cas est la distance relative de la machine √† la cam√©ra, stock√©e dans la variable </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">playerZ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, la fonction ¬´secoue¬ª un peu la voiture √† grande vitesse, ajoutant un peu de caract√®re al√©atoire √† l'√©quation de mise √† l'√©chelle, en fonction de la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vitesse / vitesse maximale</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et voici ce que nous avons obtenu:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/845/dfd/3e8/845dfd3e88ef0a22b2c9fd021140ff3b.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons fait un travail assez important juste pour cr√©er un syst√®me avec des routes droites. </font><font style="vertical-align: inherit;">Nous avons ajout√©</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">module d'assistance g√©n√©rique </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dom</font></font></strong></li>
<li><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">Utiliser</font></strong><font style="vertical-align: inherit;"> le module math√©matique g√©n√©ral</font></font><strong><font style="vertical-align: inherit;"></font></strong></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Module d'aide au </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rendu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> g√©n√©ral du canevas </font><font style="vertical-align: inherit;">...</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... y compris </font></font><code>Render.segment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Render.polygon</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et</font></font><code>Render.sprite</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cycle de jeu √† pas fixe</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t√©l√©chargeur d'images</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gestionnaire de clavier</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fond de parallaxe</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">feuille de sprite avec des voitures, des arbres et des panneaux d'affichage</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g√©om√©trie rudimentaire de la route</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour contr√¥ler la machine</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de rendu de l'arri√®re-plan, de la route et de la voiture du joueur</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Balise HTML5 </font></font><code>&lt;audio&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec musique de course (bonus cach√©!)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... ce qui nous a donn√© une bonne base pour un d√©veloppement ult√©rieur.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 2. Courbes.</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98f/c3d/6d1/98fc3d6d13cc16f12847d253e112fcb2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cette partie, nous expliquerons plus en d√©tail le fonctionnement des courbes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la partie pr√©c√©dente, nous avons compil√© la g√©om√©trie de la route sous la forme d'un tableau de segments, dont chacun a des coordonn√©es mondiales, transform√©s par rapport √† la cam√©ra, puis projet√©s sur l'√©cran. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous n'avions besoin que de la coordonn√©e mondiale </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour chaque point, car sur les routes droites, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √©taient √©gaux √† z√©ro.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c78/551/359/c78551359ef7c11e4af48b4285d61842.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous devions cr√©er un syst√®me 3D enti√®rement fonctionnel, nous pourrions impl√©menter les courbes en calculant les </font><font style="vertical-align: inherit;">bandes </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des polygones illustr√©s ci-dessus. Cependant, ce type de g√©om√©trie sera assez difficile √† calculer, et pour cela il faudra ajouter l'√©tape de rotation 3d aux √©quations de projection ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... si nous allions dans ce sens, il serait pr√©f√©rable d'utiliser WebGL ou ses analogues, mais ce projet n'a pas d'autres t√¢ches pour notre projet. Nous voulons simplement utiliser des astuces pseudo-tridimensionnelles √† l'ancienne pour simuler des courbes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par cons√©quent, vous serez probablement surpris d'apprendre que nous ne calculerons pas du tout les coordonn√©es </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des segments de route ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lieu de cela, nous utiliserons </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les conseils de Lu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Pour courber la route, changez simplement la position de la ligne centrale de la forme de la courbe ... √† partir du bas de l'√©cran, la quantit√© de d√©calage du centre de la route vers la gauche ou la droite augmente progressivement</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><em><font style="vertical-align: inherit;">"</font></em></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre cas, la ligne m√©diane est la valeur </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pass√©e aux calculs de projection. </font><font style="vertical-align: inherit;">Cela signifie que lorsque nous effectuons </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaque segment de la route, vous pouvez simuler les courbes en d√©calant la valeur </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'une valeur progressivement croissante.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8a/569/19e/c8a56919e67d6f19cc737074ce92fffb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour savoir combien changer, nous devons stocker une valeur dans chaque segment </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cette valeur indique dans quelle mesure le segment doit √™tre d√©cal√© de la ligne centrale de la cam√©ra. </font><font style="vertical-align: inherit;">Elle sera:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√©gatif pour les virages √† gauche</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">positif pour les courbes tournant √† droite</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moins pour les courbes lisses</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plus pour les courbes nettes</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les valeurs elles-m√™mes sont choisies assez arbitrairement; </font><font style="vertical-align: inherit;">par essais et erreurs, nous pouvons trouver de bonnes valeurs auxquelles les courbes semblent √™tre ¬´correctes¬ª:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> ROAD = {
  <span class="hljs-attr">LENGTH</span>: { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">SHORT</span>:  <span class="hljs-number">25</span>, <span class="hljs-attr">MEDIUM</span>:  <span class="hljs-number">50</span>, <span class="hljs-attr">LONG</span>:  <span class="hljs-number">100</span> }, <span class="hljs-comment">// num segments</span>
  <span class="hljs-attr">CURVE</span>:  { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">EASY</span>:    <span class="hljs-number">2</span>, <span class="hljs-attr">MEDIUM</span>:   <span class="hljs-number">4</span>, <span class="hljs-attr">HARD</span>:    <span class="hljs-number">6</span> }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus de choisir de bonnes valeurs pour les courbes, nous devons √©viter tout √©cart dans les transitions lorsque la ligne se transforme en courbe (ou vice versa). </font><font style="vertical-align: inherit;">Ceci peut √™tre r√©alis√© en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adoucissant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lors de l'entr√©e et de la sortie des courbes. </font><font style="vertical-align: inherit;">Pour ce faire, nous augmenterons (ou diminuerons) progressivement la valeur </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de chaque segment √† l'aide des fonctions de lissage traditionnelles jusqu'√† ce qu'il atteigne la valeur souhait√©e:</font></font><br>
<br>
<pre><code class="javascript hljs">easeIn:    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*<span class="hljs-built_in">Math</span>.pow(percent,<span class="hljs-number">2</span>);                           },
<span class="hljs-attr">easeOut</span>:   <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*(<span class="hljs-number">1</span>-<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">1</span>-percent,<span class="hljs-number">2</span>));                     },
<span class="hljs-attr">easeInOut</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*((-<span class="hljs-built_in">Math</span>.cos(percent*<span class="hljs-built_in">Math</span>.PI)/<span class="hljs-number">2</span>) + <span class="hljs-number">0.5</span>);        },</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est, maintenant, en tenant compte de la fonction d'ajouter un segment √† la g√©om√©trie ...</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params">curve</span>) </span>{
  <span class="hljs-keyword">var</span> n = segments.length;<font></font>
  segments.push({<font></font>
     <span class="hljs-attr">index</span>: n,
        <span class="hljs-attr">p1</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>:  n   *segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
        <span class="hljs-attr">p2</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>: (n+<span class="hljs-number">1</span>)*segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
     <span class="hljs-attr">curve</span>: curve,
     <span class="hljs-attr">color</span>: <span class="hljs-built_in">Math</span>.floor(n/rumbleLength)%<span class="hljs-number">2</span> ? COLORS.DARK : COLORS.LIGHT<font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nous pouvons cr√©er une m√©thode pour une entr√©e, une recherche et une sortie en douceur d'une route incurv√©e:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRoad</span>(<span class="hljs-params">enter, hold, leave, curve</span>) </span>{
  <span class="hljs-keyword">var</span> n;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; enter ; n++)<font></font>
    addSegment(Util.easeIn(<span class="hljs-number">0</span>, curve, n/enter));
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; hold  ; n++)<font></font>
    addSegment(curve);<font></font>
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; leave ; n++)<font></font>
    addSegment(Util.easeInOut(curve, <span class="hljs-number">0</span>, n/leave));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... et en plus, vous pouvez imposer une g√©om√©trie suppl√©mentaire, par exemple des courbes en S:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSCurves</span>(<span class="hljs-params"></span>) </span>{<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,   ROAD.CURVE.MEDIUM);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,   ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.MEDIUM);<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifications de la m√©thode update ()</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les seuls changements √† apporter √† la m√©thode </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont l'application d'une sorte de force centrifuge lorsque la machine se d√©place le long d'une courbe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous d√©finissons un facteur arbitraire qui peut √™tre ajust√© selon nos pr√©f√©rences.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> centrifugal = <span class="hljs-number">0.3</span>;   <span class="hljs-comment">// centrifugal force multiplier when going around curves</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et puis nous allons simplement mettre √† jour la position en </font></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonction de sa vitesse actuelle, de la valeur de la courbe et du multiplicateur de force centrifuge:</font></font><br>
<br>
<pre><code class="javascript hljs">playerX = playerX - (dx * speedPercent * playerSegment.curve * centrifugal);</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu de courbe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons dit ci-dessus que vous pouvez rendre des courbes simul√©es en d√©calant la valeur </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilis√©e dans les calculs de projection lors de l'ex√©cution de </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaque segment de route.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8a/569/19e/c8a56919e67d6f19cc737074ce92fffb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ce faire, nous allons stocker la variable d'entra√Ænement </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en augmentant pour chaque segment d'une valeur </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ainsi que la variable </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui sera utilis√©e comme d√©calage de la valeur </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilis√©e dans les calculs de projection. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour impl√©menter les courbes, nous avons besoin des √©l√©ments suivants:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©caler la projection </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1 de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chaque segment de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©caler la projection </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2 de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chaque segment de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">augmenter </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour le segment suivant de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, afin d'√©viter les transitions d√©chir√©es lors du franchissement des fronti√®res des segments, il faut faire </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> initialis√© avec la valeur interpol√©e de la courbe des segments de base courants. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modifiez la m√©thode </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme suit:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> baseSegment = findSegment(position);
<span class="hljs-keyword">var</span> basePercent = Util.percentRemaining(position, segmentLength);
<span class="hljs-keyword">var</span> dx = - (baseSegment.curve * basePercent);
<span class="hljs-keyword">var</span> x  = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; drawDistance ; n++) {<font></font>
<font></font>
  ...<font></font>
<font></font>
  Util.project(segment.p1, (playerX * roadWidth) - x,      cameraHeight, position - (segment.looped ? trackLength : <span class="hljs-number">0</span>), cameraDepth, width, height, roadWidth);<font></font>
  Util.project(segment.p2, (playerX * roadWidth) - x - dx, cameraHeight, position - (segment.looped ? trackLength : <span class="hljs-number">0</span>), cameraDepth, width, height, roadWidth);<font></font>
<font></font>
  x  = x + dx;<font></font>
  dx = dx + segment.curve;<font></font>
<font></font>
  ...<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fond de d√©filement de parallaxe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, nous devons faire d√©filer les couches d'arri√®re-plan de parallaxe, en stockant le d√©calage pour chaque couche ...</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> skySpeed    = <span class="hljs-number">0.001</span>; <span class="hljs-comment">// background sky layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> hillSpeed   = <span class="hljs-number">0.002</span>; <span class="hljs-comment">// background hill layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> treeSpeed   = <span class="hljs-number">0.003</span>; <span class="hljs-comment">// background tree layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> skyOffset   = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current sky scroll offset</span>
<span class="hljs-keyword">var</span> hillOffset  = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current hill scroll offset</span>
<span class="hljs-keyword">var</span> treeOffset  = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current tree scroll offset</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... et l'augmenter dans le temps en </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonction de la valeur de la courbe du segment de joueur actuel et de sa vitesse ...</font></font><br>
<br>
<pre><code class="javascript hljs">skyOffset  = Util.increase(skyOffset,  skySpeed  * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);<font></font>
hillOffset = Util.increase(hillOffset, hillSpeed * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);<font></font>
treeOffset = Util.increase(treeOffset, treeSpeed * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... puis utilisez pour utiliser ce d√©calage lors de la cr√©ation de </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calques d'arri√®re-plan.</font></font><br>
<br>
<pre><code class="javascript hljs">Render.background(ctx, background, width, height, BACKGROUND.SKY,   skyOffset);<font></font>
Render.background(ctx, background, width, height, BACKGROUND.HILLS, hillOffset);<font></font>
Render.background(ctx, background, width, height, BACKGROUND.TREES, treeOffset);</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, ici, nous obtenons les fausses courbes pseudo-tridimensionnelles:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98f/c3d/6d1/98fc3d6d13cc16f12847d253e112fcb2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La partie principale du code que nous avons ajout√© est de construire la g√©om√©trie de la route avec la valeur correspondante </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En le r√©alisant, ajouter de la force centrifuge pendant le temps est </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beaucoup plus facile. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le rendu de courbe est effectu√© en quelques lignes de code, mais il peut √™tre difficile de comprendre (et d√©crire) ce qui se passe exactement ici. Il existe de nombreuses fa√ßons de simuler des courbes et il est tr√®s facile de se promener lorsqu'elles sont impl√©ment√©es dans une impasse. Il est encore plus facile de se laisser emporter par une t√¢che ext√©rieure et d'essayer de tout faire ¬´correctement¬ª; avant de vous en rendre compte, vous commencerez √† cr√©er un syst√®me 3D enti√®rement fonctionnel avec des matrices, des rotations et une vraie g√©om√©trie 3D ... ce qui, comme je l'ai dit, n'est pas notre t√¢che.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque j'ai √©crit cet article, j'√©tais s√ªr qu'il y avait d√©finitivement des probl√®mes dans ma mise en ≈ìuvre des courbes. </font><font style="vertical-align: inherit;">En essayant de visualiser l'algorithme, je ne comprenais pas pourquoi j'avais besoin de deux valeurs des lecteurs </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au lieu d'une ... et si je ne peux pas expliquer compl√®tement quelque chose, alors quelque chose s'est mal pass√© quelque part ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... mais le temps du projet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" le week-end ¬ªa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> presque expir√© et, franchement, les courbes me semblent assez belles, et au final, c'est le plus important.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr499240/index.html">√Ä travers les √©pines jusqu'aux √©toiles ou l'analyse des donn√©es dans les affaires du ciel</a></li>
<li><a href="../fr499242/index.html">Les chercheurs ont transmis des donn√©es √† partir d'un ordinateur de bureau via des vibrations sur une table</a></li>
<li><a href="../fr499244/index.html">Organisations synergiques. Partie II</a></li>
<li><a href="../fr499246/index.html">Enqu√™te sur la fonction logistique en tant que loi de d√©veloppement de l'industrie</a></li>
<li><a href="../fr499248/index.html">Comment nous reconnaissons les √©quipements de protection individuelle</a></li>
<li><a href="../fr499254/index.html">Un membre du comit√© du programme PyConRu 2020 r√©pond aux questions sur Python: un look √† jour et un peu de fourchelang</a></li>
<li><a href="../fr499262/index.html">Dernier hackathon en ligne pour les ind√©pendants SMZhack: des projets qui toucheront les gens</a></li>
<li><a href="../fr499268/index.html">Conscience spatiale: que peuvent faire les lunettes Hololens?</a></li>
<li><a href="../fr499272/index.html">Composants de soudure 0201. Nerveux, veuillez vous √©loigner des √©crans</a></li>
<li><a href="../fr499274/index.html">Nous avons d√©mont√© la nouvelle capsule. Nous savons combien de microphones et comment cela fonctionne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>