<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🎨 😈 🤸🏼 バランスのとれた二分探索木：Juliaでの実装 💹 🐘 🎁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="G.M.の作品からのイラスト Adelson-WelskyおよびE.M. ランディス1962
 

検索ツリーは、整然とした保管とアイテムの単純な検索のためのデータ構造です。バイナリ検索ツリーは広く使用されており、各ノードには2つの子しかありません。この記事では、二分探索木を編成するための2つの方法...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>バランスのとれた二分探索木：Juliaでの実装</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455172/"><p><img src="https://habrastorage.org/webt/5q/ek/4n/5qek4nssuu4dsjepoaa2g9tgmw0.png"><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G.M.の作品からのイラスト </font><font style="vertical-align: inherit;">Adelson-WelskyおよびE.M. </font><font style="vertical-align: inherit;">ランディス1962</font></font></em></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検索ツリーは、整然とした保管とアイテムの単純な検索のためのデータ構造です。</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイナリ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検索ツリー</font><font style="vertical-align: inherit;">は広く使用されて</font><font style="vertical-align: inherit;">おり、各ノードには2つの子しかありません。</font><font style="vertical-align: inherit;">この記事では、二分探索木を編成するための2つの方法、Adelson-WelskyおよびLandisアルゴリズム（AVLツリー）と弱められたAVLツリー（WAVLツリー）について検討します。</font></font></p><a name="habracut"></a><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定義から始めましょう。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイナリツリー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノード</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">構成され</font><font style="vertical-align: inherit;">、各ノード</font><font style="vertical-align: inherit;">は</font><em><font style="vertical-align: inherit;">キーと値の</font></em><font style="vertical-align: inherit;">ペア</font><font style="vertical-align: inherit;">（または単純な場合は値のみ）</font><font style="vertical-align: inherit;">の形式で</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レコード</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">格納し、</font><em><font style="vertical-align: inherit;">子</font></em><font style="vertical-align: inherit;">は2つだけです</font><font style="vertical-align: inherit;">。子孫ノードは</font><em><font style="vertical-align: inherit;">right</font></em><font style="vertical-align: inherit;">と</font><em><font style="vertical-align: inherit;">left</font></em><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">区別され</font><font style="vertical-align: inherit;">、キーの順序の条件が満たされます。つまり、左側の子孫のキーはそれ以上ではなく、右側の子孫は親ノードのキー以上です。さらに、サービス情報はノードに保存できます（通常は保存されます）。たとえば、親ノードへのリンクや他のデータなどです。特別なケースは、</font><font style="vertical-align: inherit;">ツリーが入る</font><em><font style="vertical-align: inherit;">ルートノード</font></em><font style="vertical-align: inherit;">と</font><em><font style="vertical-align: inherit;">空のノードです。</font></em></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情報を保存しません。</font><font style="vertical-align: inherit;">両方の子孫が空のノードは、</font><font style="vertical-align: inherit;">ツリー</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リーフ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">すべての子孫を持つノードは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブツリーを</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形成し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">したがって、各ノードはサブツリーのルートまたはリーフのいずれかです。</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この定義により、ノードとツリー自体を格納するための単純な構造を構築できます。</font><font style="vertical-align: inherit;">空のノードには特別な</font></font><code>nothing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型の</font><font style="vertical-align: inherit;">値があると仮定します</font></font><code>Nothing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次に、ノードに、右および左の子孫と親への参照を格納するだけで十分です。</font><font style="vertical-align: inherit;">ツリーを格納するための構造には、ルートノードへのリンクのみが含まれます。</font></font></p><br>
<pre><code class="julia hljs"><span class="hljs-comment"># K -  </span>
<span class="hljs-comment"># V -   </span>
<span class="hljs-keyword">mutable struct</span> BSTNode{K, V}<font></font>
    key::K<font></font>
    value::V<font></font>
    left::<span class="hljs-built_in">Union</span>{Nothing, BSTNode{K,V}}<font></font>
    right::<span class="hljs-built_in">Union</span>{Nothing, BSTNode{K,V}}<font></font>
    parent::BSTNode{K,V}<font></font>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">mutable struct</span> BST{K, V}<font></font>
    root::BSTNode{K,V}<font></font>
<span class="hljs-keyword">end</span></code></pre><br>
<p>    ,     .       ":   "          ,   ,     .          BSTNode :</p><br>
<pre><code class="julia hljs"><span class="hljs-keyword">mutable struct</span> BSTNode{K, V}<font></font>
    key::K<font></font>
    value::V<font></font>
    left::<span class="hljs-built_in">Union</span>{Nothing, BSTNode{K,V}}<font></font>
    right::<span class="hljs-built_in">Union</span>{Nothing, BSTNode{K,V}}<font></font>
    parent::BSTNode{K,V}<font></font>
    <span class="hljs-comment">#  </span>
    <span class="hljs-keyword">function</span> BSTNode{K,V}() <span class="hljs-keyword">where</span> {K,V}<font></font>
        node = new{K,V}()<font></font>
        node.parent = node<font></font>
        node.left = node.right = <span class="hljs-literal">nothing</span>
        <span class="hljs-keyword">return</span> node
    <span class="hljs-keyword">end</span>
    <span class="hljs-comment">#    -</span>
    <span class="hljs-keyword">function</span> BSTNode{K,V}(key, value) <span class="hljs-keyword">where</span> {K, V}<font></font>
        node = new{K,V}()<font></font>
        node.parent = node<font></font>
        node.left = node.right = <span class="hljs-literal">nothing</span><font></font>
        node.key, node.value = key, value<font></font>
        <span class="hljs-keyword">return</span> node
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span><font></font>
<font></font>
BSTNode() = BSTNode{<span class="hljs-built_in">Any</span>, <span class="hljs-built_in">Any</span>}()<font></font>
<font></font>
<span class="hljs-comment">#     !</span>
<span class="hljs-keyword">struct</span> BST{K, V}<font></font>
    entry::BSTNode{K,V}<font></font>
    BST{K,V}() <span class="hljs-keyword">where</span> {K,V} = new{K,V}(BSTNode{K,V}())
<span class="hljs-keyword">end</span><font></font>
<font></font>
BST() = BST{<span class="hljs-built_in">Any</span>, <span class="hljs-built_in">Any</span>}()<font></font>
<font></font>
Base.isempty(bst::BST) = bst.entry.left == <span class="hljs-literal">nothing</span></code></pre><br>
<p>    <code>BST</code>   , ..        .   ,        ,     .</p><br>
<p> ,      — , ,  .      ,   —    ,      :    ,       ;    —  ,         ,     .        —    ,  .</p><br>
<pre><code class="julia hljs"><span class="hljs-comment">#   Base.getindex()    </span>
<span class="hljs-comment">#      tree[key]</span>
<span class="hljs-keyword">function</span> Base.getindex(bst::BST{K,V}, key) <span class="hljs-keyword">where</span> {K,V}<font></font>
    key = convert(K, key)<font></font>
    node = bst.entry.left<font></font>
    <span class="hljs-keyword">while</span> node != <span class="hljs-literal">nothing</span>
        key == node.key &amp;&amp; <span class="hljs-keyword">return</span> node.value<font></font>
        node = (key &lt; node.key ? node.left : node.right)<font></font>
    <span class="hljs-keyword">end</span>
    throw(<span class="hljs-built_in">KeyError</span>(key))
<span class="hljs-keyword">end</span></code></pre><br>
<p>   , ,   <em>O</em>(<em>h</em>),  <em>h</em> —  , ..      .   ,    <em>h</em>     2<sup>h+1</sup>-1 ,   <em> </em>, ..  , ,  ,   ,   .    ,            .                <em>O</em>(log<sub>2</sub><em>N</em>),  <em>N</em> —  .</p><br>
<p>,          ,      .       :</p><br>
<pre><code class="julia hljs"><span class="hljs-comment">#   Base.setindex!()    </span>
<span class="hljs-comment">#       tree[key] = value</span>
<span class="hljs-keyword">function</span> Base.setindex!(bst::BST{K,V}, val::SV, key::SK) <span class="hljs-keyword">where</span> {K, V}<font></font>
    key, value = convert(K, key), convert(V, val)<font></font>
    parent = bst.entry.left<font></font>
    <span class="hljs-comment">#   -    </span>
    <span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nothing</span><font></font>
        newnode.parent = bst.entry<font></font>
        bst.entry.left = bst.entry.right = newnode<font></font>
        <span class="hljs-keyword">return</span> val
    <span class="hljs-keyword">end</span><font></font>
<font></font>
    key_found = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">while</span> !key_found
        <span class="hljs-keyword">if</span> key &lt; parent.key
            <span class="hljs-keyword">if</span> parent.left == <span class="hljs-literal">nothing</span><font></font>
                parent.left = BSTNode{K,V}(key, value)<font></font>
                parent.left.parent = parent<font></font>
                key_found = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">else</span><font></font>
                parent = parent.left<font></font>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">elseif</span> key &gt; parent.key
            <span class="hljs-keyword">if</span> parent.right == <span class="hljs-literal">nothing</span><font></font>
                parent.right = BSTNode{K,V}(key, value)<font></font>
                newnode.parent = parent<font></font>
                key_found = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">else</span><font></font>
                parent = parent.right<font></font>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">else</span>
            key_found = <span class="hljs-literal">true</span><font></font>
            parent.value = value<font></font>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> val
<span class="hljs-keyword">end</span></code></pre><br>
<p> ,           ,        .   ,      (  ,   ),            , ,  ,  .   ,   ,          <em>O</em>(<em>N</em>),           .</p><br>
<p>:      <em></em>, ..         .     .  —       ,      .           "" , -       <em>O</em>(<em>N</em>)   ,       /     .    —       ,     ,      <em></em>   <em>O</em>(log<sub>2</sub><em>N</em>).</p><br>
<p>   ,   ,     "",           ,          ,  <em></em>  <em></em>  / .             <em>O</em>(log<sub>2</sub><em>N</em>)  ,   — ,    <em>O</em>(<em>N</em>).</p><br>
<h3 id="algoritm-adelson-velskogo-i-landisa-avl"> -   ()</h3><br>
<p>         1962  -  .           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">-</a>.    :</p><br>
<ol>
<li>:         ,      — ,     (     ).</li>
<li> :          .       .</li>
<li>-:              1.</li>
</ol><br>
<p>   ,      <em>O</em>(log<sub>2</sub><em>N</em>),  <em>N</em> —     ,  ,      .   -    ,     <em></em>.            .  ,      .</p><br>
<pre><code class="julia hljs"><span class="hljs-keyword">mutable struct</span> AVLNode{K,V}
    <span class="hljs-comment"># ,       255</span>
    <span class="hljs-comment"># (  10^38 )</span>
    height::<span class="hljs-built_in">UInt8</span> <font></font>
    key::K<font></font>
    value::V<font></font>
    left::<span class="hljs-built_in">Union</span>{Nothing, AVLNode{K,V}}<font></font>
    right::<span class="hljs-built_in">Union</span>{Nothing, AVLNode{K,V}}<font></font>
    parent::AVLNode{K,V}<font></font>
    <span class="hljs-comment">#  </span>
    <span class="hljs-keyword">function</span> AVLNode{K,V}() <span class="hljs-keyword">where</span> {K,V}<font></font>
        node = new{K,V}()<font></font>
        node.height = <span class="hljs-number">1</span><font></font>
        node.parent = node<font></font>
        node.left = node.right = <span class="hljs-literal">nothing</span>
        <span class="hljs-keyword">return</span> node
    <span class="hljs-keyword">end</span>
    <span class="hljs-comment">#    -</span>
    <span class="hljs-keyword">function</span> AVLNode{K,V}(key::SK, value::SV) <span class="hljs-keyword">where</span> {K, V, SK&lt;:K, SV&lt;:V}<font></font>
        node = new{K,V}()<font></font>
        node.height = <span class="hljs-number">1</span><font></font>
        node.parent = node<font></font>
        node.left = node.right = <span class="hljs-literal">nothing</span><font></font>
        node.key, node.value = key, value<font></font>
        <span class="hljs-keyword">return</span> node
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span><font></font>
<font></font>
avlheight(node::<span class="hljs-built_in">Union</span>{Nothing,AVLNode}) = node == <span class="hljs-literal">nothing</span> ? <span class="hljs-number">0</span> : <span class="hljs-built_in">Int</span>(node.height)</code></pre><br>
<h4 id="vstavka-zapisi"> </h4><br>
<p>      —    , ,       .            -1  1    :</p><br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> child(root::AVLNode, side::<span class="hljs-built_in">Signed</span>)
    <span class="hljs-keyword">if</span> side == -<span class="hljs-number">1</span><font></font>
        root.left<font></font>
    <span class="hljs-keyword">elseif</span> side == <span class="hljs-number">1</span><font></font>
        root.right<font></font>
    <span class="hljs-keyword">else</span>
        throw(<span class="hljs-built_in">ArgumentError</span>(<span class="hljs-string">"Expecting side=-1 to get the left child or side=1 to get the right child"</span>))
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> insert_child!(root::AVLNode{K,V},<font></font>
                       newnode::<span class="hljs-built_in">Union</span>{Nothing,AVLNode{K,V}},<font></font>
                       side::<span class="hljs-built_in">Signed</span>) <span class="hljs-keyword">where</span> {K,V}<font></font>
    newnode == <span class="hljs-literal">nothing</span> || (newnode.parent = root)
    <span class="hljs-keyword">if</span> side == -<span class="hljs-number">1</span><font></font>
        root.left = newnode<font></font>
    <span class="hljs-keyword">elseif</span> side == <span class="hljs-number">1</span><font></font>
        root.right = newnode<font></font>
    <span class="hljs-keyword">else</span>
        throw(<span class="hljs-built_in">ArgumentError</span>(<span class="hljs-string">"Expecting side=-1 for inserting node to the left or side=1 for inserting to the right"</span>))
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre><br>
<p>,         2  3.   ,    (    ,  ,   —  ).</p><br>
<p><strong> 0</strong><br>
      ,   ,   1  ()   .</p><br>
<p><img src="https://habrastorage.org/webt/uf/9_/iq/uf9_iqcs1ydiwszzfl8ub8dbxj8.png"></p><br>
<p>  ,     .      , ..    .</p><br>
<p><strong> 1</strong><br>
        .    ,       .</p><br>
<p><img src="https://habrastorage.org/webt/s4/nv/t4/s4nvt4y-m1znfln4g4ajf2346d0.png"></p><br>
<p>    ""  ,     1.        ,           2   .</p><br>
<p><img src="https://habrastorage.org/webt/v-/j9/0s/v-j90s0nar7w4mgas4oujggl3h8.png"></p><br>
<div class="spoiler"><b class="spoiler_title"></b><div class="spoiler_text"><pre><code class="julia hljs">fucntion promote!(nd::AVLNode, by::<span class="hljs-built_in">Integer</span>=<span class="hljs-number">1</span>)<font></font>
    nd.height += by<font></font>
<span class="hljs-keyword">end</span><font></font>
<font></font>
fucntion demote!(nd::AVLNode, by::<span class="hljs-built_in">Integer</span>=<span class="hljs-number">1</span>)<font></font>
    nd.height -= by<font></font>
<span class="hljs-keyword">end</span></code></pre></div></div><br>
<p><strong> 2</strong></p><br>
<p>        2,  ""   :</p><br>
<p><img src="https://habrastorage.org/webt/la/bl/aj/lablajxlzp2lgvbhm4nlh5j-3ks.png"></p><br>
<p>  ,  " ",    :</p><br>
<p><img src="https://habrastorage.org/webt/8j/zc/yt/8jzcytyqgke3xpcikei8zrbvbrq.png"></p><br>
<p>    6  .</p><br>
<p> ,         <em>n</em>, <em>p</em>   <em>T</em><sub>1</sub> — <em>T</em><sub>3</sub>         .  —   .  ,          .</p><br>
<div class="spoiler"><b class="spoiler_title"></b><div class="spoiler_text"><pre><code class="julia hljs"><span class="hljs-comment"># pivot      </span>
<span class="hljs-keyword">function</span> rotate!(pivot::AVLNode, dir::<span class="hljs-built_in">Signed</span>)<font></font>
    dir <span class="hljs-keyword">in</span> (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) || throw(<span class="hljs-built_in">ArgumentError</span>(<span class="hljs-string">"Unknown rotation direction"</span>))<font></font>
    p = pivot.parent<font></font>
    g = p.parent<font></font>
    p.height = avlheight(child(pivot, dir)) + <span class="hljs-number">1</span>
    pivot.height = p.height + <span class="hljs-number">1</span>
    <span class="hljs-comment"># "" pivot  g</span><font></font>
    pivot.parent = g<font></font>
    g.left === p &amp;&amp; (g.left = pivot)<font></font>
    g.right === p &amp;&amp; (g.right = pivot)<font></font>
    c = child(pivot, dir)<font></font>
    <span class="hljs-comment">#  c  p</span><font></font>
    insert_child!(p, c, -dir)<font></font>
    <span class="hljs-comment">#  p  pivot</span><font></font>
    insert_child!(pivot, p, dir)<font></font>
    pivot<font></font>
<span class="hljs-keyword">end</span></code></pre></div></div><br>
<p><strong> 3</strong><br>
        2,  ""   :</p><br>
<p><img src="https://habrastorage.org/webt/cs/el/1u/csel1u39enlepfhdrc4bdw_legq.png"></p><br>
<p>        ,         ,      2,      .</p><br>
<p>   ""        ,  ,   .   12      10.        :</p><br>
<p><img src="https://habrastorage.org/webt/ub/ds/7i/ubds7iawqzg9uqgned3mxiqs_8m.png"></p><br>
<p> ,           .</p><br>
<div class="spoiler"><b class="spoiler_title"></b><div class="spoiler_text"><pre><code class="julia hljs"><span class="hljs-comment"># pivot      </span>
funtion double_rotate!(pivot::AVLNode, dir::<span class="hljs-built_in">Signed</span>)<font></font>
    dir <span class="hljs-keyword">in</span> (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) || throw(<span class="hljs-built_in">ArgumentError</span>(<span class="hljs-string">"Unknown rotation direction"</span>))<font></font>
    n = pivot.parent<font></font>
    p = n.parent<font></font>
    g = p.parent<font></font>
    pivot.height = n.height<font></font>
    n.height = p.height = pivot.height - <span class="hljs-number">1</span>
    <span class="hljs-comment"># "" pivot  g</span><font></font>
    pivot.parent = g<font></font>
    g.left === p &amp;&amp; (g.left = pivot)<font></font>
    g.right === p &amp;&amp; (g.right = pivot)<font></font>
    t2, t3 = child(pivot, -dir), child(pivot, dir)<font></font>
    <span class="hljs-comment">#  n  pivot  t2  n</span><font></font>
    insert_child!(n, t2, dir)<font></font>
    insert_child!(pivot, n, -dir)<font></font>
    <span class="hljs-comment">#  p  pivot  t3  p</span><font></font>
    insert_child!(p, t3, -dir)<font></font>
    insert_child!(pivot, p, dir)<font></font>
    pivot<font></font>
<span class="hljs-keyword">end</span></code></pre></div></div><br>
<p>,     -  <em>O</em>(log<sub>2</sub><em>N</em>)           .      .        ,        <code>fix_insertion!()</code>,         ,      .</p><br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> Base.setindex!(avlt::AVLTree{K,V}, val, key) <span class="hljs-keyword">where</span> {K,V}<font></font>
    key, value = convert(K, key), convert(V, val)<font></font>
    parent = avlt.entry.left<font></font>
    <span class="hljs-comment">#   -    </span>
    <span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nothing</span><font></font>
        newnode = AVLNode{K,V}(key, value)<font></font>
        newnode.parent = avlt.entry<font></font>
        avlt.entry.left = avlt.entry.right = newnode<font></font>
        <span class="hljs-keyword">return</span> val
    <span class="hljs-keyword">end</span><font></font>
<font></font>
    key_found = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">while</span> !key_found<font></font>
        key_found = key == parent.key<font></font>
        <span class="hljs-keyword">if</span> key_found<font></font>
            parent.value = value<font></font>
        <span class="hljs-keyword">else</span>
            side = (key &gt; parent.key) * <span class="hljs-number">2</span> - <span class="hljs-number">1</span> <span class="hljs-comment"># true == 1, false == 0</span><font></font>
            next = child(parent, side)<font></font>
            <span class="hljs-keyword">if</span> next == <span class="hljs-literal">nothing</span><font></font>
                newnode = AVLNode{K,V}(key, value)<font></font>
                insert_child!(parent, newnode, side)<font></font>
                fix_insertion!(newnode)<font></font>
                key_found = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">else</span><font></font>
                parent = next<font></font>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> val
<span class="hljs-keyword">end</span></code></pre><br>
<p> <code>fix_insertion!()</code>      ,      .    1 —     1,       .    —  .    2 —   2  3,    ,      . </p><br>
<pre><code class="julia hljs"><span class="hljs-comment">#     -  ,</span>
<span class="hljs-comment">#   - </span><font></font>
imbalance(node::AVLNode) = avlheight(node.right) - avlheight(node.left)<font></font>
<font></font>
<span class="hljs-keyword">function</span> fix_insertion!(start::AVLNode)<font></font>
    node = start.parent<font></font>
    skew = imbalance(node)<font></font>
   <span class="hljs-comment">#      0 - ..       </span>
    <span class="hljs-keyword">while</span> abs(skew) == <span class="hljs-number">1</span>
        node.height += <span class="hljs-number">1</span><font></font>
        node = node.parent<font></font>
        skew = imbalance(node)<font></font>
    <span class="hljs-keyword">end</span>
    <span class="hljs-meta">@assert</span> abs(skew) == <span class="hljs-number">2</span> || skew == <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> skew != <span class="hljs-number">0</span>
        <span class="hljs-comment">#       ,</span>
        <span class="hljs-comment"># ..  </span>
        dir = -skew ÷ <span class="hljs-number">2</span><font></font>
        n = child(node, -dir)<font></font>
        prev_skew = imbalance(n)<font></font>
        <span class="hljs-meta">@assert</span> abs(prev_skew) == <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> prev_skew == dir<font></font>
            double_rotate!(child(n, dir), dir)<font></font>
        <span class="hljs-keyword">else</span><font></font>
            rotate!(n, dir)<font></font>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre><br>
<h4 id="udalenie-zapisi"> </h4><br>
<p>   .</p><br>
<p>         . </p><br>
<ol>
<li>     —    ,   .</li>
<li>    ,      —             .</li>
<li>   —        ,    ,    (            ,    — ,      )      .</li>
</ol><br>
<p>      ,        ,  . ,              1.       (  ,  ,   —   ):</p><br>
<p><strong> 1</strong><br>
 . ,     1  ,      2  .</p><br>
<p><img src="https://habrastorage.org/webt/mo/cm/a_/mocma_jzetjrizjwiesbdtx1rtu.png"></p><br>
<p>     1    .</p><br>
<p><img src="https://habrastorage.org/webt/j8/6y/yi/j86yyi7cxkzasggld6pzo9fldwu.png"></p><br>
<p><strong> 2</strong><br>
 1  .</p><br>
<p><img src="https://habrastorage.org/webt/hn/8v/cx/hn8vcxpvolbjnafm9h3u08kpnoo.png"></p><br>
<p>- ,  .</p><br>
<p><strong> 3</strong><br>
 2  ,       .</p><br>
<p><img src="https://habrastorage.org/webt/vr/_f/jc/vr_fjcvwl3zxc6ocy622l2sszrw.png"></p><br>
<p>   ( T<sub>1</sub> ,  T<sub>2</sub>)   (  ) ,    .     , ..      .</p><br>
<p><img src="https://habrastorage.org/webt/h9/5f/qx/h95fqxdbbqukr_eyjbhbjyyoju4.png"></p><br>
<p><strong> 4</strong><br>
 2  ,     .</p><br>
<p><img src="https://habrastorage.org/webt/o6/rl/mq/o6rlmq62rxnxxyh6knsz3xne4te.png"></p><br>
<p>    ,       —   .</p><br>
<p><img src="https://habrastorage.org/webt/sw/c-/d5/swc-d56rswsunltv7_3g60tvufq.png"></p><br>
<div class="spoiler"><b class="spoiler_title">   </b><div class="spoiler_text"><pre><code class="julia hljs"><span class="hljs-keyword">function</span> next_node(node::AVLNode)<font></font>
    next = node.right<font></font>
    <span class="hljs-keyword">if</span> next == <span class="hljs-literal">nothing</span><font></font>
        p = node.parent<font></font>
        next = p.parent<font></font>
        <span class="hljs-keyword">while</span> (next !== p) &amp;&amp; (next.key &lt; p.key)<font></font>
            p, next = next, next.parent<font></font>
        <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">return</span> (next === p ? <span class="hljs-literal">nothing</span> : next)
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">while</span> next.left != <span class="hljs-literal">nothing</span><font></font>
            next = next.left<font></font>
        <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">return</span> next
    <span class="hljs-keyword">end</span> 
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> Base.delete!(avlt::AVLTree{K,V}, key) <span class="hljs-keyword">where</span> {K,V}<font></font>
    key = convert(K, key)<font></font>
    candidate = avlt.entry.left<font></font>
    dir = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> candidate.key != key<font></font>
        dir = <span class="hljs-number">2</span> * (key &gt; candidate.key) - <span class="hljs-number">1</span><font></font>
        candidate = child(candidate, dir)<font></font>
        candidate == <span class="hljs-literal">nothing</span> &amp;&amp; <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">end</span><font></font>
    val = candidate.value<font></font>
    <span class="hljs-keyword">for</span> side <span class="hljs-keyword">in</span> (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
        <span class="hljs-keyword">if</span> child(candidate, side) == <span class="hljs-literal">nothing</span><font></font>
            p, s = candidate.parent, child(candidate, -side)<font></font>
            <span class="hljs-keyword">if</span> p === p.parent<font></font>
                insert_child!(p, s, <span class="hljs-number">1</span>)<font></font>
                insert_child!(p, s, -<span class="hljs-number">1</span>)
            <span class="hljs-keyword">else</span><font></font>
                insert_child!(p, s, dir)<font></font>
                fix_deletion!(p)<font></font>
            <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span><font></font>
    swap = next_node(candidate)<font></font>
    cp, sp, sr = candidate.parent, swap.parent, swap.right<font></font>
    swap.height = candidate.height<font></font>
    insert_child!(swap, candidate.left, -<span class="hljs-number">1</span>)
    <span class="hljs-keyword">for</span> side <span class="hljs-keyword">in</span> (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<font></font>
        child(cp, side) === candidate &amp;&amp; insert_child!(cp, swap, side)<font></font>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">if</span> sp === candidate<font></font>
        fix_deletion!(swap)<font></font>
    <span class="hljs-keyword">else</span>
        insert_child!(swap, candidate.right, <span class="hljs-number">1</span>)<font></font>
        insert_child!(sp, sr, -<span class="hljs-number">1</span>)<font></font>
        fix_deletion!(sp)<font></font>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> fix_deletion!(start::AVLNode)<font></font>
    node = start<font></font>
    skew = imbalance(node)<font></font>
    <span class="hljs-keyword">while</span> (node !== node.parent) &amp;&amp; (abs(skew) != <span class="hljs-number">1</span>)
        <span class="hljs-keyword">if</span> skew != <span class="hljs-number">0</span>
            <span class="hljs-meta">@assert</span> abs(skew) == <span class="hljs-number">2</span>
            dir = -skew ÷ <span class="hljs-number">2</span><font></font>
            n = child(node, -dir)<font></font>
            prev_skew = imbalance(n)<font></font>
            <span class="hljs-meta">@assert</span> abs(prev_skew) &lt; <span class="hljs-number">2</span>
            <span class="hljs-keyword">if</span> prev_skew == dir<font></font>
                node = double_rotate!(child(n, dir), dir)<font></font>
            <span class="hljs-keyword">else</span><font></font>
                node = rotate!(n, dir)<font></font>
                prev_skew != <span class="hljs-number">0</span> || <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">else</span>
            node.height -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">end</span><font></font>
        node = node.parent<font></font>
        skew = imbalance(node)<font></font>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre></div></div><br>
<h3 id="vzlyot-i-padenie-avl-derevev">   -</h3><br>
<p>     -     : ..   ""     ,       <em>O</em>(log<sub>2</sub><em>N</em>)   —        <code>fix_deletion!()</code>.</p><br>
<p>-      -     1970- - ,       —                   . -   -      2log<sub>2</sub><em>N</em>  1,44log<sub>2</sub><em>N</em>  -,         .  ,             ,    ,     .</p><br>
<h3 id="avl-nanosyat-otvetnyy-udar">   </h3><br>
<p>,  ""          (   -)       ,     .    ,   2015    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>,   ,    ,   - .      ,    ,      .  ,  " -" (W(eak)AVL-)   :</p><br>
<ol>
<li>:         ,      — ,     (     ).</li>
<li> .    .      ,   — 1.       .</li>
<li> -:            2.</li>
</ol><br>
<p>,          -,  - .  ,   ,  <em></em>           2,     ,        .</p><br>
<p> -  ,    -           !      h &lt; min(1,44log<sub>2</sub><em>M</em>, 2log<sub>2</sub><em>N</em>),  <em>N</em> —    , <em>M</em> —  ,    h &lt; 2log<sub>2</sub><em>N</em>  - .  ,  -   ,       ,      .</p><br>
<p> -             ,          .  -        .</p><br>
<h4 id="struktura-hraneniya"> .</h4><br>
<p>    -,  ""    "".  ,   :</p><br>
<pre><code class="julia hljs"><span class="hljs-keyword">mutable struct</span> WAVLNode<font></font>
    rank::<span class="hljs-built_in">UInt8</span> <font></font>
    key::K<font></font>
    value::V<font></font>
    left::<span class="hljs-built_in">Union</span>{Nothing, WAVLNode{K,V}}<font></font>
    right::<span class="hljs-built_in">Union</span>{Nothing, WAVLNode{K,V}}<font></font>
    parent::WAVLNode{K,V}<font></font>
    <span class="hljs-comment">#  </span>
    <span class="hljs-keyword">function</span> WAVLNode{K,V}() <span class="hljs-keyword">where</span> {K,V}<font></font>
        node = new{K,V}()<font></font>
        node.rank = <span class="hljs-number">1</span><font></font>
        node.parent = node<font></font>
        node.left = node.right = <span class="hljs-literal">nothing</span>
        <span class="hljs-keyword">return</span> node
    <span class="hljs-keyword">end</span>
    <span class="hljs-comment">#    -</span>
    <span class="hljs-keyword">function</span> WAVLNode{K,V}(key, value) <span class="hljs-keyword">where</span> {K,V}<font></font>
        key, value = convert(K, key), convert(V, value)<font></font>
        node = new{K,V}()<font></font>
        node.rank = <span class="hljs-number">1</span><font></font>
        node.parent = node<font></font>
        node.left = node.right = <span class="hljs-literal">nothing</span><font></font>
        node.key, node.value = key, value<font></font>
        <span class="hljs-keyword">return</span> node
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">struct</span> WAVLTree{K, V}<font></font>
    entry::WAVLNode{K,V}<font></font>
    WAVLTree{K,V}() <span class="hljs-keyword">where</span> {K,V} = new{K,V}(WAVLNode{K,V}())
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> child(root::WAVLNode, side::<span class="hljs-built_in">Signed</span>)
    <span class="hljs-keyword">if</span> side == -<span class="hljs-number">1</span><font></font>
        root.left<font></font>
    <span class="hljs-keyword">elseif</span> side == <span class="hljs-number">1</span><font></font>
        root.right<font></font>
    <span class="hljs-keyword">else</span>
        throw(<span class="hljs-built_in">ArgumentError</span>(<span class="hljs-string">"Expecting side=-1 to get the left child or side=1 to get the right child"</span>))
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> Base.getindex(avlt::WAVLTree{K,V}, key) <span class="hljs-keyword">where</span> {K,V}<font></font>
    key = convert(K, key)<font></font>
    node = avlt.entry.left<font></font>
    <span class="hljs-keyword">while</span> node != <span class="hljs-literal">nothing</span>
        key == node.key &amp;&amp; <span class="hljs-keyword">return</span> node.value<font></font>
        node = (key &lt; node.key ? node.left : node.right)<font></font>
    <span class="hljs-keyword">end</span>
    throw(<span class="hljs-built_in">KeyError</span>(key))
<span class="hljs-keyword">end</span></code></pre><br>
<h4 id="vstavka-zapisi-1"> </h4><br>
<p>   ,     -.  :      1    ,      —      ,          0 (  )  1 (    ).      <code>imbalance()</code>,     ,  .</p><br>
<pre><code class="julia hljs">wavlrank(node::<span class="hljs-built_in">Union</span>{Nothing,WAVLNode}) = node == <span class="hljs-literal">nothing</span> ? <span class="hljs-number">0</span> : <span class="hljs-built_in">Int</span>(node.rank)<font></font>
<font></font>
<span class="hljs-keyword">function</span> imbalance(node::WAVLNode)<font></font>
    rr, lr = wavlrank(node.right), wavlrank(node.left)<font></font>
    skew = rr - lr<font></font>
    diff = node.rank - max(rr, lr)<font></font>
    skew, diff<font></font>
<span class="hljs-keyword">end</span></code></pre><br>
<p>   ,           .  ,  ,    ,    ,    -,   - .</p><br>
<div class="spoiler"><b class="spoiler_title">   </b><div class="spoiler_text"><pre><code class="julia hljs"><span class="hljs-comment"># pivot      </span>
<span class="hljs-keyword">function</span> rotate!(pivot::AVLNode, dir::<span class="hljs-built_in">Signed</span>)<font></font>
    dir <span class="hljs-keyword">in</span> (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) || throw(<span class="hljs-built_in">ArgumentError</span>(<span class="hljs-string">"Unknown rotation direction"</span>))<font></font>
    p = pivot.parent<font></font>
    g = p.parent<font></font>
    p.height = avlheight(child(pivot, dir)) + <span class="hljs-number">1</span>
    pivot.height = p.height + <span class="hljs-number">1</span>
    <span class="hljs-comment"># "" pivot  g</span><font></font>
    pivot.parent = g<font></font>
    g.left === p &amp;&amp; (g.left = pivot)<font></font>
    g.right === p &amp;&amp; (g.right = pivot)<font></font>
    c = child(pivot, dir)<font></font>
    <span class="hljs-comment">#  c  p</span><font></font>
    insert_child!(p, c, -dir)<font></font>
    <span class="hljs-comment">#  p  pivot</span><font></font>
    insert_child!(pivot, p, dir)<font></font>
    pivot<font></font>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-comment"># pivot      </span>
<span class="hljs-keyword">function</span> double_rotate!(pivot::AVLNode, dir::<span class="hljs-built_in">Signed</span>)<font></font>
    dir <span class="hljs-keyword">in</span> (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) || throw(<span class="hljs-built_in">ArgumentError</span>(<span class="hljs-string">"Unknown rotation direction"</span>))<font></font>
    n = pivot.parent<font></font>
    p = n.parent<font></font>
    g = p.parent<font></font>
    pivot.height = n.height<font></font>
    n.height = p.height = pivot.height - <span class="hljs-number">1</span>
    <span class="hljs-comment"># "" pivot  g</span><font></font>
    pivot.parent = g<font></font>
    g.left === p &amp;&amp; (g.left = pivot)<font></font>
    g.right === p &amp;&amp; (g.right = pivot)<font></font>
    t2, t3 = child(pivot, -dir), child(pivot, dir)<font></font>
    <span class="hljs-comment">#  n  pivot  t2  n</span><font></font>
    insert_child!(n, t2, dir)<font></font>
    insert_child!(pivot, n, -dir)<font></font>
    <span class="hljs-comment">#  p  pivot  t3  p</span><font></font>
    insert_child!(p, t3, -dir)<font></font>
    insert_child!(pivot, p, dir)<font></font>
    pivot<font></font>
<span class="hljs-keyword">end</span><font></font>
<font></font>
imbalance(node::AVLNode) = avlheight(node.right) - avlheight(node.left)<font></font>
<font></font>
<span class="hljs-keyword">function</span> fix_insertion!(start::AVLNode)<font></font>
    node = start.parent<font></font>
    skew = imbalance(node)<font></font>
    <span class="hljs-keyword">while</span> abs(skew) == <span class="hljs-number">1</span>
        node.height += <span class="hljs-number">1</span><font></font>
        node = node.parent<font></font>
        skew = imbalance(node)<font></font>
    <span class="hljs-keyword">end</span>
    <span class="hljs-meta">@assert</span> abs(skew) == <span class="hljs-number">2</span> || skew == <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> skew != <span class="hljs-number">0</span>
        dir = -skew ÷ <span class="hljs-number">2</span><font></font>
        n = child(node, -dir)<font></font>
        prev_skew = imbalance(n)<font></font>
        <span class="hljs-meta">@assert</span> abs(prev_skew) == <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> prev_skew == dir<font></font>
            double_rotate!(child(n, dir), dir)<font></font>
        <span class="hljs-keyword">else</span><font></font>
            rotate!(n, dir)<font></font>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> Base.setindex!(avlt::AVLTree{K,V}, val, key) <span class="hljs-keyword">where</span> {K,V}<font></font>
    key, value = convert(K, key), convert(V, val)<font></font>
    parent = avlt.entry.left<font></font>
    <span class="hljs-comment">#   -    </span>
    <span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nothing</span><font></font>
        newnode = AVLNode{K,V}(key, value)<font></font>
        newnode.parent = avlt.entry<font></font>
        avlt.entry.left = avlt.entry.right = newnode<font></font>
        <span class="hljs-keyword">return</span> val
    <span class="hljs-keyword">end</span><font></font>
<font></font>
    key_found = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">while</span> !key_found<font></font>
        key_found = key == parent.key<font></font>
        <span class="hljs-keyword">if</span> key_found<font></font>
            parent.value = value<font></font>
        <span class="hljs-keyword">else</span>
            side = (key &gt; parent.key) * <span class="hljs-number">2</span> - <span class="hljs-number">1</span><font></font>
            next = child(parent, side)<font></font>
            <span class="hljs-keyword">if</span> next == <span class="hljs-literal">nothing</span><font></font>
                newnode = AVLNode{K,V}(key, value)<font></font>
                insert_child!(parent, newnode, side)<font></font>
                fix_insertion!(newnode)<font></font>
                key_found = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">else</span><font></font>
                parent = next<font></font>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> val
<span class="hljs-keyword">end</span></code></pre></div></div><br>
<h4 id="udalenie-zapisi-1"> </h4><br>
<p>   ,     —    -.        .</p><br>
<p><strong> 0</strong><br>
      , ..:</p><br>
<ol>
<li> 1,     1  </li>
<li> 0,    2  ,     .<br>
   .</li>
</ol><br>
<p><strong> 1</strong><br>
    2 ( 0,   2   ).<br>
   1   .</p><br>
<p><strong> 2</strong><br>
 1,     2.</p><br>
<p><img src="https://habrastorage.org/webt/q0/gq/3h/q0gq3hi6g7k8modechdmavys-to.png"></p><br>
<p>     1,  .</p><br>
<p><img src="https://habrastorage.org/webt/28/ss/oc/28ssoc1ki3flzroiinnigcsguhg.png"></p><br>
<p><strong> 3</strong><br>
 2 (     1, ..          ),         2  .</p><br>
<p><img src="https://habrastorage.org/webt/oi/tl/qd/oitlqdhhc83lttdsw6s0az_kr5y.png"></p><br>
<p>      ,    .  .</p><br>
<p><img src="https://habrastorage.org/webt/st/pn/se/stpnsenr-ygtamabscwra_yd2dy.png"></p><br>
<p><strong> 4</strong><br>
<img src="https://habrastorage.org/webt/fp/l-/h1/fpl-h1yg-9gl3wrucoiq-lhefwq.png"></p><br>
<p>  .</p><br>
<p><img src="https://habrastorage.org/webt/s3/qy/0u/s3qy0uwfz87t5uroqynp4rvchwi.png"></p><br>
<p> ,          ,      , ..      .</p><br>
<p>  —   T<sub>1</sub>  T<sub>2</sub>  ,  <em>p</em>     2,    <em>p</em>     1.</p><br>
<p><strong> 5</strong><br>
<img src="https://habrastorage.org/webt/5m/pn/sb/5mpnsb8edlrtcazgox852h6rrsm.png"></p><br>
<p>  .</p><br>
<p><img src="https://habrastorage.org/webt/im/vt/7c/imvt7cnylf5_dja5jc6xx9km-xo.png"></p><br>
<p>,    ,      .</p><br>
<div class="spoiler"><b class="spoiler_title">   </b><div class="spoiler_text"><pre><code class="julia hljs"><span class="hljs-keyword">function</span> next_node(node::WAVLNode)<font></font>
    next = node.right<font></font>
    <span class="hljs-keyword">if</span> next == <span class="hljs-literal">nothing</span><font></font>
        p = node.parent<font></font>
        next = p.parent<font></font>
        <span class="hljs-keyword">while</span> (next !== p) &amp;&amp; (next.key &lt; p.key)<font></font>
            p, next = next, next.parent<font></font>
        <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">return</span> (next === p ? <span class="hljs-literal">nothing</span> : next)
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">while</span> next.left != <span class="hljs-literal">nothing</span><font></font>
            next = next.left<font></font>
        <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">return</span> next
    <span class="hljs-keyword">end</span> 
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> Base.delete!(avlt::WAVLTree{K,V}, key) <span class="hljs-keyword">where</span> {K,V}<font></font>
    key = convert(K, key)<font></font>
    candidate = avlt.entry.left<font></font>
    dir = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> candidate.key != key<font></font>
        dir = <span class="hljs-number">2</span> * (key &gt; candidate.key) - <span class="hljs-number">1</span><font></font>
        candidate = child(candidate, dir)<font></font>
        candidate == <span class="hljs-literal">nothing</span> &amp;&amp; <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">end</span><font></font>
    val = candidate.value<font></font>
    <span class="hljs-keyword">for</span> side <span class="hljs-keyword">in</span> (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
        <span class="hljs-keyword">if</span> child(candidate, side) == <span class="hljs-literal">nothing</span><font></font>
            p, s = candidate.parent, child(candidate, -side)<font></font>
            <span class="hljs-keyword">if</span> p === p.parent<font></font>
                insert_child!(p, s, <span class="hljs-number">1</span>)<font></font>
                insert_child!(p, s, -<span class="hljs-number">1</span>)
            <span class="hljs-keyword">else</span><font></font>
                insert_child!(p, s, dir)<font></font>
                fix_deletion!(p)<font></font>
            <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span><font></font>
    swap = next_node(candidate)<font></font>
    cp, sp, sr = candidate.parent, swap.parent, swap.right<font></font>
    swap.height = candidate.height<font></font>
    insert_child!(swap, candidate.left, -<span class="hljs-number">1</span>)
    <span class="hljs-keyword">for</span> side <span class="hljs-keyword">in</span> (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<font></font>
        child(cp, side) === candidate &amp;&amp; insert_child!(cp, swap, side)<font></font>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">if</span> sp === candidate<font></font>
        fix_deletion!(swap)<font></font>
    <span class="hljs-keyword">else</span>
        insert_child!(swap, candidate.right, <span class="hljs-number">1</span>)<font></font>
        insert_child!(sp, sr, -<span class="hljs-number">1</span>)<font></font>
        fix_deletion!(sp)<font></font>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span>
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> fix_deletion!(start::WAVLNode)<font></font>
    node = start<font></font>
    skew, diff = imbalance(node)<font></font>
    <span class="hljs-keyword">while</span> (node !== node.parent)
        <span class="hljs-keyword">if</span> skew == <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> node.right == <span class="hljs-literal">nothing</span>
                node.rank = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">elseif</span> abs(skew) == <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> diff == <span class="hljs-number">1</span>
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">else</span>
                node.rank -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">else</span>
            dir = -skew ÷ <span class="hljs-number">2</span><font></font>
            n = child(node, -dir)<font></font>
            prev_skew, prev_diff = imbalance(n)<font></font>
            <span class="hljs-keyword">if</span> prev_diff == <span class="hljs-number">2</span>
                <span class="hljs-meta">@assert</span> prev_skew == <span class="hljs-number">0</span>
                n.rank -= <span class="hljs-number">1</span>
                node.rank -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">elseif</span> prev_skew == dir<font></font>
                double_rotate!(child(n, dir), dir)<font></font>
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">else</span><font></font>
                rotate!(n, dir)<font></font>
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span><font></font>
        node = node.parent<font></font>
        skew, diff = imbalance(node)<font></font>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre></div></div><br>
<p>     -.</p><br>
<pre><code class="julia hljs">julia&gt; <span class="hljs-keyword">const</span> wavl = WAVLTree{<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>}()<font></font>
julia&gt; <span class="hljs-keyword">const</span> avl = AVLTree{<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>}()<font></font>
julia&gt; <span class="hljs-keyword">const</span> dd = <span class="hljs-built_in">Dict</span>{<span class="hljs-built_in">Int</span>,<span class="hljs-built_in">Int</span>}()<font></font>
julia&gt; x = trues(<span class="hljs-number">1_000_000</span>)
<span class="hljs-comment">#       ~ </span>
julia&gt; <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>:<span class="hljs-number">1_000_000</span>; dd[i] = avl[i] = wavl[i] = i * i; <span class="hljs-keyword">end</span>
julia&gt; <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>:<span class="hljs-number">500_000</span>
       k = rand(<span class="hljs-number">1</span>:<span class="hljs-number">1_000_000</span>)<font></font>
       x[k] = <span class="hljs-literal">false</span><font></font>
       delete!(avl, k)<font></font>
       delete!(wavl, k)<font></font>
       delete!(dd, k)<font></font>
       <span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-comment"># ,    </span>
julia&gt; <span class="hljs-keyword">const</span> y = <span class="hljs-built_in">Int</span>[]<font></font>
julia&gt; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> eachindex(x); <span class="hljs-keyword">if</span> x[i] push!(y, i); <span class="hljs-keyword">end</span>; <span class="hljs-keyword">end</span><font></font>
<font></font>
julia&gt; <span class="hljs-meta">@btime</span> <span class="hljs-keyword">let</span> s = <span class="hljs-number">0.0</span>; <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> y; s += dd[idx]; <span class="hljs-keyword">end</span>; s; <span class="hljs-keyword">end</span>
  <span class="hljs-number">57.626</span> ms (<span class="hljs-number">0</span> allocations: <span class="hljs-number">0</span> bytes)
<span class="hljs-number">2.0238199367708794e17</span>
julia&gt; <span class="hljs-meta">@btime</span> <span class="hljs-keyword">let</span> s = <span class="hljs-number">0.0</span>; <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> y; s += wavl[idx]; <span class="hljs-keyword">end</span>; s; <span class="hljs-keyword">end</span>
  <span class="hljs-number">57.796</span> ms (<span class="hljs-number">0</span> allocations: <span class="hljs-number">0</span> bytes)
<span class="hljs-number">2.0238199367708794e17</span>
julia&gt; <span class="hljs-meta">@btime</span> <span class="hljs-keyword">let</span> s = <span class="hljs-number">0.0</span>; <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> y; s += avl[idx]; <span class="hljs-keyword">end</span>; s; <span class="hljs-keyword">end</span>
  <span class="hljs-number">53.884</span> ms (<span class="hljs-number">0</span> allocations: <span class="hljs-number">0</span> bytes)
<span class="hljs-number">2.0238199367708794e17</span></code></pre><br>
<p>,        ,    . , ,   -    ,   -,    .</p><br>
<h3 id="primenenie-derevev-poiska">  </h3><br>
<p>   —   ?<br>
  —   ,   . ,   ,  .</p><br>
<p>          .</p><br>
<h4 id="uporyadochennoe-mnozhestvo"> </h4><br>
<p>   —   ,           .      <em>n</em>-   . ,     , ..  ,       .</p><br>
<div class="scrollable-table"><table>
<thead>
<tr>
<th></th>
<th> </th>
<th> </th>
</tr>
</thead>
<tbody>
<tr>
<td>  </td>
<td><em>O</em>(<em>N</em>)</td>
<td><em>O</em>(<em>N</em>)</td>
</tr>
<tr>
<td></td>
<td><em>O</em>(log<em>N</em>)</td>
<td><em>O</em>(<em>N</em>)</td>
</tr>
<tr>
<td></td>
<td><em>O</em>(log<em>N</em>)</td>
<td><em>O</em>(<em>N</em>)</td>
</tr>
<tr>
<td><em>n</em>- </td>
<td><em>O</em>(log<em>N</em>)*</td>
<td><em>O</em>(1)</td>
</tr>
</tbody>
</table></div><br>
<p>*        </p><br>
<h4 id="associativnyy-massiv"> </h4><br>
<p>  —   ,      "   ", "    ", "  -", " ".    ,      ,        -.      .   ,          .</p><br>
<div class="scrollable-table"><table>
<thead>
<tr>
<th></th>
<th> </th>
<th>-</th>
<th></th>
<th> </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><em>O</em>(log<em>N</em>)</td>
<td><em>O</em>(1)*</td>
<td><em>O</em>(<em>N</em>)</td>
<td><em>O</em>(log<em>N</em>)</td>
</tr>
<tr>
<td></td>
<td><em>O</em>(log<em>N</em>)</td>
<td><em>O</em>(1)*</td>
<td><em>O</em>(1)</td>
<td><em>O</em>(<em>N</em>)</td>
</tr>
<tr>
<td></td>
<td><em>O</em>(log<em>N</em>)</td>
<td><em>O</em>(1)*</td>
<td><em>O</em>(<em>N</em>)**</td>
<td><em>O</em>(<em>N</em>)</td>
</tr>
<tr>
<td>  </td>
<td><em>O</em>(log<em>N</em>)</td>
<td><em>O</em>(<em>N</em>)</td>
<td><em>O</em>(<em>N</em>)</td>
<td><em>O</em>(log<em>N</em>)</td>
</tr>
</tbody>
</table></div><br>
<p>*   <br>
**     <em>O</em>(1),     ...</p><br>
<h4 id="ochered-s-prioritetami">  </h4><br>
<p>   ,       " — ".      ,    .   —     ( ) ,       ,  ,   .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>.</p><br>
<div class="scrollable-table"><table>
<thead>
<tr>
<th></th>
<th> </th>
<th> </th>
<th></th>
<th> /</th>
</tr>
</thead>
<tbody>
<tr>
<td> </td>
<td><em>O</em>(1)*</td>
<td><em>O</em>(1)</td>
<td><em>O</em>(<em>N</em>)</td>
<td><em>O</em>(1)</td>
</tr>
<tr>
<td> </td>
<td><em>O</em>(log<em>N</em>)</td>
<td><em>O</em>(log<em>N</em>)</td>
<td><em>O</em>(<em>N</em>)</td>
<td><em>O</em>(1)**</td>
</tr>
<tr>
<td> </td>
<td><em>O</em>(log<em>N</em>)</td>
<td><em>O</em>(log<em>N</em>)</td>
<td><em>O</em>(1)</td>
<td><em>O</em>(<em>N</em>)</td>
</tr>
<tr>
<td> </td>
<td><em>O</em>(log<em>N</em>)</td>
<td><em>O</em>(log<em>N</em>)</td>
<td><em>O</em>(<em>N</em>)</td>
<td><em>O</em>(<em>N</em>)</td>
</tr>
</tbody>
</table></div><br>
<p>*       <br>
**  ,      </p><br>
<h3 id="vyvod"></h3><br>
<p>()    —       ,   , ,   , ,    .      —     , ..  ,         ,   .</p><br>
<h2 id="ssylki"></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">"-"</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link">nickme</a> </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bernhard Haeupler、Siddhartha Sen、Robert E. Tarjanによるランクバランスツリー//アルゴリズムでのACMトランザクション| </font><font style="vertical-align: inherit;">2015年6月、Vol 11（4）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pdf</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Goodrich MT、Tamassia R.アルゴリズムの設計とアプリケーション</font></font></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja455160/index.html">LINQによる全文検索を備えたEntity Framework 6</a></li>
<li><a href="../ja455164/index.html">Elena Balashova：「私たちのGISポータルのデータはOpenStreetMapに開かれているべきだという疑問を提起しました」</a></li>
<li><a href="../ja455166/index.html">ロックをバイパスするBeelineルーター上のVPN</a></li>
<li><a href="../ja455168/index.html">ATtiny5の492バイトのデモ</a></li>
<li><a href="../ja455170/index.html">SSDへのバイトアクセスの新しいアーキテクチャ-仕組み</a></li>
<li><a href="../ja455176/index.html">Reduxがなくても可能ですか？</a></li>
<li><a href="../ja455178/index.html">できればキャッチ・ミー。ディレクターバージョン</a></li>
<li><a href="../ja455184/index.html">250ドルの部屋サイズの3Dプリンター</a></li>
<li><a href="../ja455186/index.html">MIT 3Dプリンター：モデルあたり最大10個の材料</a></li>
<li><a href="../ja455190/index.html">心筋細胞の3Dプリント</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>