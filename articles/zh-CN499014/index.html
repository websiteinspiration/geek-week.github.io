<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛤️ 📹 🏾 JavaScript面试的23个难题 👩‍🎓 👨🏻 👇🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="是否想为JavaScript面试做好准备并正在寻找练习的问题？如果是这样-请考虑您的搜索已经结束。该材料的作者（我们今天将发表其翻译）说，他已经收集了关于JavaScript的二十多个问题，这些问题的对象是希望从初级变成高级的人，以及那些希望成功通过前端开发领域的采访并从中获得有趣邀请的人。雇主。
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>JavaScript面试的23个难题</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/499014/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是否想为JavaScript面试做好准备并正在寻找练习的问题？</font><font style="vertical-align: inherit;">如果是这样-请考虑您的搜索已经结束。</font><font style="vertical-align: inherit;">该材料的作者（我们今天将发表其翻译）说，他已经收集了关于JavaScript的二十多个问题，这些问题的对象是希望从初级变成高级的人，以及那些希望成功通过前端开发领域的采访并从中获得有趣邀请的人。雇主。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/qi/tz/vo/qitzvoimkys1bwbzrblcb_-d6a0.jpeg"></a><br>
<a name="habracut"></a><img src="https://habrastorage.org/webt/e-/we/pj/e-wepj0aq22hixysckglfp766g4.png" alt="图片"><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.解释JavaScript平等验证功能</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：*</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript有两个用于检查值是否相等的运算符。</font><font style="vertical-align: inherit;">第一个是所谓的严格相等运算符。</font><font style="vertical-align: inherit;">第二个是非严格相等运算符，可用于转换检查数量的类型。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">严格相等运算符（</font></font><code>===</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）在不执行类型转换的情况下检查值是否相等。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非严格相等运算符（</font></font><code>==</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）检查值是否相等，将其转换为通用类型。</font></font></li>
</ul><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> a = <span class="hljs-string">"42"</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-number">42</span>;<font></font>
<font></font>
a == b; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// true</span>
a === b;&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是在JavaScript中使用各种相等性检查器的一些准则：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果任何比较值可以是一个值，</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或者</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-避免使用运算符</font></font><code>==</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用运算符</font></font><code>===</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"></font><code>===</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果要使用以下值</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">请使用运算符</font><font style="vertical-align: inherit;">：</font></font><code>«»</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><code>[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（空数组）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在所有其他情况下，您可以安全地使用运算符</font></font><code>==</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">而且，这不仅安全，而且还有助于简化代码并提高其可读性。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.举例说明强制转换为与该类型无关的逻辑类型的值</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：***</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个问题的实质是找出在将它们转换为逻辑类型的情况下哪些值变成了</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以及哪个值变成了</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是可以称为``虚假''的值列表。</font><font style="vertical-align: inherit;">它们在转换为逻辑类型时会转换为值</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><code>«»</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> （空行）。</font></font></li>
<li><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>-0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>NaN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（非数字）。</font></font></li>
<li><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“假”是一种逻辑含义</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
转换为逻辑类型时，此列表中未包含的任何值都会变成</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（这样的值称为``真''-真）。</font><font style="vertical-align: inherit;">例如：</font></font><br>
<br>
<ul>
<li><code>«hello»</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><code>42</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><code>[ ]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>[ 1, «2», 3 ]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（数组）。</font></font></li>
<li><code>{ }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>{ a: 42 }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（对象）。</font></font></li>
<li><code>function foo() { .. }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> （功能）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“正确”也是逻辑含义</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.什么是IIFE？</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：***</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IIFE（立即调用函数表达式）是立即调用的函数表达式。</font><font style="vertical-align: inherit;">创建后立即执行该表达式。</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IIFE</span>(<span class="hljs-params"></span>)</span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Hello!"</span> );<font></font>
})();<font></font>
<span class="hljs-comment">// "Hello!"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该模式通常用于防止污染全局名称空间。</font><font style="vertical-align: inherit;">事实是，在IIFE中声明的变量（与在任何其他普通函数中一样）在该函数之外是不可见的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.我什么时候应该使用ES6中出现的箭头功能？</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：***</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一些简单的规则，用于使用各种方式声明为支持ES6和更高标准的环境开发代码时遵循的功能：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"></font><code>function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在全局范围和属性中</font><font style="vertical-align: inherit;">使用关键字</font></font><code>Object.prototype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将关键字</font></font><code>function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于对象构造函数。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在其他情况下，请使用箭头功能。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，建议在几乎所有地方都使用箭头功能。</font><font style="vertical-align: inherit;">这种情况有多种原因：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结合上下文进行便捷的工作。</font><font style="vertical-align: inherit;">箭头函数使用</font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">周围上下文</font><font style="vertical-align: inherit;">的值</font><font style="vertical-align: inherit;">而没有它们自己的</font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果顺序使用这些功能，而不在复杂结构中使用普通功能，则可以确保在上下文中安全工作。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">紧凑。</font><font style="vertical-align: inherit;">箭头功能代码更易于输入和阅读。</font><font style="vertical-align: inherit;">在您看来，箭头功能相对于普通功能的这种优势将引起争议，并且取决于每个特定开发人员的观点。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码清晰。</font><font style="vertical-align: inherit;">如果几乎所有代码都由箭头函数表示，则通过创建其自身的上下文来区分此类代码中的任何普通函数。</font><font style="vertical-align: inherit;">程序员使用箭头功能创建了更容易理解的代码，与没有箭头功能的代码相比，使用起来更容易</font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. ES6类和函数构造函数有什么区别？</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：***</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们先来看一些例子。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
构造函数：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>{
&nbsp;&nbsp;<span class="hljs-keyword">this</span>.name = name;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ES6课程：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(name) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.name = name;<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在创建简单对象时，用于此目的的构造函数和类看起来非常相似。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用继承时，构造函数和类之间的主要区别出现。</font><font style="vertical-align: inherit;">如果我们需要创建一个作为该类</font></font><code>Student</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的子类的类</font></font><code>Person</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并向该新类添加字段</font></font><code>studentId</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则这就是使用构造函数的代码和使用这些类的代码的样子。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
构造函数：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name, studentId</span>) </span>{
&nbsp;&nbsp;<span class="hljs-comment">//      ,   .</span>
&nbsp;&nbsp;Person.call(<span class="hljs-keyword">this</span>, name);<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-comment">//    .</span>
&nbsp;&nbsp;<span class="hljs-keyword">this</span>.studentId = studentId;<font></font>
}<font></font>
<font></font>
Student.prototype = <span class="hljs-built_in">Object</span>.create(Person.prototype);<font></font>
Student.prototype.constructor = Student;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ES6课程：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>{
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(name, studentId) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">super</span>(name);
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.studentId = studentId;<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.向我们介绍Function.prototype.bind（）方法。</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：***</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
引用MDN：“该方法</font></font><code>bind()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建一个新函数，该函数在调用时会将</font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供的值设置</font><font style="vertical-align: inherit;">为执行上下文</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">参数集也将传递给方法，该方法将在调用参数时将其设置为传递给绑定函数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我相信这种方法。</font></font><code>bind()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于</font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在需要传递给其他函数的类方法中</font><font style="vertical-align: inherit;">绑定值特别有用</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该技术通常在React组件中使用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a>&nbsp;<br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.匿名函数通常用于什么？</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：***</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
匿名函数用于创建IIFE构造，在其中声明的变量不会污染全局范围。</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
&nbsp;&nbsp;<span class="hljs-comment">// - .</span><font></font>
})();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
匿名函数用作回调函数，仅在程序的一个位置使用。</font><font style="vertical-align: inherit;">如果在使用它的地方立即声明了回调，则代码将看起来更加自给自足且可读性强。</font><font style="vertical-align: inherit;">这消除了在搜索功能主体时查看代码的需要。</font></font><br>
<br>
<pre><code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello world!'</span>);<font></font>
}, <span class="hljs-number">1000</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
匿名函数可方便地用于特定于函数式编程风格的构造中，或在使用Lodash之类的库时使用（此用例类似于其用作回调的用法）。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> double = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el</span>) </span>{
&nbsp;&nbsp;<span class="hljs-keyword">return</span> el * <span class="hljs-number">2</span>;<font></font>
});<font></font>
<span class="hljs-built_in">console</span>.log(double); <span class="hljs-comment">// [2, 4, 6]</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Object.freeze（）方法和const关键字有什么区别？</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：***</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关键字</font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和方法</font></font><code>Object.freeze()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是完全不同的东西。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关键字</font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">适用于绑定（适用于“变量”）。</font><font style="vertical-align: inherit;">它创建了一个不可变的绑定，也就是说，</font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不可能将新内容绑定</font><font style="vertical-align: inherit;">到使用keyword声明的变量（常量）</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">无法为常数分配新值。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> person = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">"Leonardo"</span><font></font>
};<font></font>
<span class="hljs-keyword">let</span> animal = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">species</span>: <span class="hljs-string">"snake"</span><font></font>
};<font></font>
person = animal; <span class="hljs-comment">// Uncaught TypeError: Assignment to constant variable.</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该方法</font></font><code>Object.freeze()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">适用于值。</font><font style="vertical-align: inherit;">或更确切地说，具有对象值。</font><font style="vertical-align: inherit;">它使对象不可变，从而防止该对象的属性值发生变化。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> person = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">"Leonardo"</span><font></font>
};<font></font>
<span class="hljs-built_in">Object</span>.freeze(person);<font></font>
person.name = <span class="hljs-string">"Lima"</span>; <span class="hljs-comment">// Uncaught TypeError: Cannot assign to read only property 'name' of object</span>
<span class="hljs-built_in">console</span>.log(person);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，错误消息以严格模式显示。</font><font style="vertical-align: inherit;">在普通模式下，更改“冻结”对象的属性的操作根本不起作用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9.什么是“发电机”？</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：***</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生成器是一些函数，您可以从中“退出”这些函数，并且可以根据需要“进入”这些函数。</font><font style="vertical-align: inherit;">它们的上下文（变量绑定）在“进入”会话之间保持。</font><font style="vertical-align: inherit;">生成器使用关键字声明</font></font><code>function*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">初次调用此函数时，它不会执行代码，而是返回一个特殊的对象，即生成器，使您可以控制其执行。</font><font style="vertical-align: inherit;">要获取生成器发出的下一个值，您需要调用其method </font></font><code>next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，功能代码将执行到遇到</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回值</font><font style="vertical-align: inherit;">的关键字为止</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生成器函数可以根据需要多次调用。</font><font style="vertical-align: inherit;">每次有新的发电机返回。</font><font style="vertical-align: inherit;">但是每个发电机只能旁路一次。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">makeRangeIterator</span>(<span class="hljs-params">start = <span class="hljs-number">0</span>, end = Infinity, step = <span class="hljs-number">1</span></span>) </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span> iterationCount = <span class="hljs-number">0</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; end; i += step) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterationCount++;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">yield</span> i;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> iterationCount;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.什么时候应该使用发电机？</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：***</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
简而言之，如果描述发生器的主要有用功能，那么它们将具有以下特征：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用生成器的代码确定接收下一个值的时间。</font><font style="vertical-align: inherit;">生成器仅负责返回值，它是从外部控制的。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有异步发电机。</font><font style="vertical-align: inherit;">它们使您可以处理异步数据流。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生成器中的主要内容是，只有在使用生成器的代码中需要生成器返回的下一个值时，才可以获取它。</font><font style="vertical-align: inherit;">生成器不会一次返回所有内容。</font><font style="vertical-align: inherit;">在某些情况下，此功能可能非常方便。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11.什么是“增加变量”？</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：****</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“提高变量”概念的实质是广告“上升”到当前范围的顶部。</font><font style="vertical-align: inherit;">因此，可以在声明变量之前使用该变量。</font><font style="vertical-align: inherit;">仅引发变量声明，而不引发其初始化代码。</font><font style="vertical-align: inherit;">请注意，使用关键字声明的变量的行为</font></font><code>var</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不同于使用</font></font><code>let</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">声明的变量和常量的行为</font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12.以下代码将输出什么？</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：****</font></font></h3><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> output = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
&nbsp;&nbsp;<span class="hljs-keyword">delete</span> x;
&nbsp;&nbsp;<span class="hljs-keyword">return</span> x;<font></font>
})(<span class="hljs-number">0</span>);<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(output);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此代码将输出</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该运算符</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于删除对象的属性。</font><font style="vertical-align: inherit;">而且</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这不是对象属性-它是局部变量。</font><font style="vertical-align: inherit;">运算符</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不影响局部变量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13.以下代码将输出什么？</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：****</font></font></h3><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> Employee = {
&nbsp;&nbsp;<span class="hljs-attr">company</span>: <span class="hljs-string">'xyz'</span><font></font>
}<font></font>
<span class="hljs-keyword">var</span> emp1 = <span class="hljs-built_in">Object</span>.create(Employee);
<span class="hljs-keyword">delete</span> emp1.company
<span class="hljs-built_in">console</span>.log(emp1.company);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此代码将输出</font></font><code>xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">属性</font></font><code>company</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是对象</font></font><code>emp1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的属性，而是其原型的属性。</font><font style="vertical-align: inherit;">操作员</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会删除对象的原型属性。</font><font style="vertical-align: inherit;">对象</font></font><code>emp1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有自己的属性</font></font><code>company</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您可以通过以下方式对此进行验证：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">console</span>.log(emp1.hasOwnProperty(<span class="hljs-string">'company'</span>)); <span class="hljs-comment">// false</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们仍然需要删除此属性，则可以通过直接联系对象</font></font><code>Employee</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>delete Employee.company</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）或</font></font><code>emp1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">的属性</font></font><code>__proto__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>delete emp1.__proto__.company</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">联系对象的原型来实现</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14.告诉我们有关原型设计模式的信息。</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：****</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原型是一种通用的设计模式。</font><font style="vertical-align: inherit;">它用于创建对象。</font><font style="vertical-align: inherit;">使用它创建的对象包含从其原型（从示例对象）复制的值。</font><font style="vertical-align: inherit;">该模板也称为属性模板。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用``原型''模式的一个示例是使用数据库中存储的标准值初始化某些对象。</font><font style="vertical-align: inherit;">原型中记录的此类值将被复制到新对象而无需访问数据库。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
应当指出，这种模式在古典语言中很少使用。</font><font style="vertical-align: inherit;">JavaScript使用原型继承模型。</font><font style="vertical-align: inherit;">此模式用于设计新对象及其原型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.什么是ES6中的“临时死区”？</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：****</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该ES6进行的变量提升和常量使用关键字声明</font></font><code>let</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（这样做是和实体的崛起，通过使用关键字声明</font></font><code>var</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>class</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">但是，代码具有从输入范围到声明变量或常量的区域。</font><font style="vertical-align: inherit;">在该区域中访问变量或常量时，将生成错误。</font><font style="vertical-align: inherit;">这就是“临时死区”（TDZ）。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//console.log(aLet)&nbsp; //  ReferenceError</span><font></font>
<font></font>
<span class="hljs-keyword">let</span> aLet;
<span class="hljs-built_in">console</span>.log(aLet); <span class="hljs-comment">// undefined</span>
aLet = <span class="hljs-number">10</span>;
<span class="hljs-built_in">console</span>.log(aLet); <span class="hljs-comment">// 10</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此示例中，TDZ在声明之后结束</font></font><code>aLet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但在赋值之后结束</font></font><code>aLet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16.您能否描述forEach（）和map（）数组方法之间的主要区别？</font><font style="vertical-align: inherit;">在哪种情况下，您更喜欢这些方法中的一种？</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：****</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了了解这些方法之间的区别，让我们谈谈它们各自的功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
运作方式</font></font><code>.forEach()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如下：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它遍历数组的元素。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它为数组的每个元素执行传递给它的回调函数。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它不返回任何东西。</font></font></li>
</ul><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> doubled = a.forEach(<span class="hljs-function">(<span class="hljs-params">num, index</span>) =&gt;</span> {
&nbsp;&nbsp;<span class="hljs-comment">//  -  num /  index.</span><font></font>
});<font></font>
<font></font>
<span class="hljs-comment">// doubled = undefined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是该方法的简要说明</font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它遍历数组的元素。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它将原始数组的每个元素转换为新数组的元素，并为原始数组的每个元素调用传递给它的函数。</font></font></li>
</ul><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> doubled = a.map(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> {
&nbsp;&nbsp;<span class="hljs-keyword">return</span> num * <span class="hljs-number">2</span>;<font></font>
});<font></font>
<font></font>
<span class="hljs-comment">// doubled = [2, 4, 6]</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，发现</font></font><code>.forEach()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">之间的主要区别在于</font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它</font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回了一个新数组。</font><font style="vertical-align: inherit;">如果需要在不更改此数组的情况下转换原始数组的元素的结果，则应选择</font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果只需要遍历数组的元素，则可以使用它</font></font><code>.forEach()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17.未声明的变量，包含空值的变量和未定义的变量有什么区别？</font><font style="vertical-align: inherit;">如何检查变量未声明的事实，以及null和undefined？</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：****</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当值被分配给以前未使用声明的标识符，创建未声明的变量</font></font><code>var</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>let</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。未声明的变量在当前范围之外的全局范围内声明。在严格模式下，尝试为未声明的变量赋值时会引发异常</font></font><code>ReferenceError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。不建议使用未声明的变量-就像不建议使用全局变量一样。一定要避免它们。为了保护自己免受使用未声明变量的影响，请使用block </font></font><code>try/catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{<font></font>
&nbsp;&nbsp;x = <span class="hljs-number">1</span>; <span class="hljs-comment">//     ReferenceError</span><font></font>
}<font></font>
<font></font>
foo();<font></font>
<span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// 1</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
包含</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的变量是未分配值的声明变量。值</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形成自己的数据类型。如果该函数不返回任何内容，并且其调用结果被写入变量，则它将落入该变量中</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。为了组织检查</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，可以使用严格相等运算符（</font></font><code>===</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）或</font></font><code>typeof</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回字符串</font><font style="vertical-align: inherit;">的运算符</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。请注意，在进行检查时，</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您不应使用非严格相等运算符（</font></font><code>==</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），因为它会将</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">值视为相等</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> foo;
<span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(foo === <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> foo === <span class="hljs-string">'undefined'</span>); <span class="hljs-comment">// true</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(foo == <span class="hljs-literal">null</span>); <span class="hljs-comment">// true.        undefined!</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{}
<span class="hljs-keyword">var</span> baz = bar();
<span class="hljs-built_in">console</span>.log(baz); <span class="hljs-comment">// undefined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
包含值的变量</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须明确设置为此值。它象征着意义的缺失，它与</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-variable的</font><font style="vertical-align: inherit;">不同之处在于</font><font style="vertical-align: inherit;">，其中的值已明确分配给它。为了检查on的值</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，使用严格的相等运算符就足够了。要进行检查</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，就像在进行检查的情况一样</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，不应使用非严格相等运算符，该运算符会考虑of </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">equal的值</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> foo = <span class="hljs-literal">null</span>;
<span class="hljs-built_in">console</span>.log(foo === <span class="hljs-literal">null</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> foo === <span class="hljs-string">'object'</span>); <span class="hljs-comment">// true</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(foo == <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true        null!</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我尽量不要让变量处于未声明状态或声明状态，但不会为它们明确分配任何值。</font><font style="vertical-align: inherit;">如果我不打算在变量声明后立即将值写入变量，则将其写入</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果使用lint，通常会报告使用未声明变量的情况。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18.向我们介绍设计模块“打开模块”</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：*****</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“显示模块”模板是“模块”模板的变体。</font><font style="vertical-align: inherit;">使用此模式的目的是支持封装并发现对象文字中返回的一些属性和方法。</font><font style="vertical-align: inherit;">以下是此模板的直接实现：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> Exposer = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
&nbsp;&nbsp;<span class="hljs-keyword">var</span> privateVariable = <span class="hljs-number">10</span>;<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">var</span> privateMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Inside a private method!'</span>);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;privateVariable++;<font></font>
&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">var</span> methodToExpose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'This is a method I want to expose!'</span>);<font></font>
&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">var</span> otherMethodIWantToExpose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;privateMethod();<font></font>
&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">return</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">first</span>: methodToExpose,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">second</span>: otherMethodIWantToExpose<font></font>
&nbsp;&nbsp;};<font></font>
})();<font></font>
<font></font>
Exposer.first();&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// : This is a method I want to expose!</span>
Exposer.second(); &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// : Inside a private method!</span>
Exposer.methodToExpose; <span class="hljs-comment">// undefined</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此模板的明显缺点是使用模板时不能使用私有方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19. Map和WeakMap对象之间有什么区别？</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：*****</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果包含对对象的引用（是键/值对之一）的变量的变量不可用，则这些对象的行为会有所不同。</font><font style="vertical-align: inherit;">这是一个例子：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
<span class="hljs-keyword">var</span> weakmap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();<font></font>
<font></font>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">var</span> a = {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">x</span>: <span class="hljs-number">12</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;};<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">var</span> b = {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">y</span>: <span class="hljs-number">12</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;map.set(a, <span class="hljs-number">1</span>);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;weakmap.set(b, <span class="hljs-number">2</span>);<font></font>
})()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IIFE的执行完成后，我们将无法再访问对象</font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，垃圾收集器</font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从中</font><font style="vertical-align: inherit;">删除密钥</font></font><code>weakmap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并清除内存。</font><font style="vertical-align: inherit;">但是内容</font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保持不变。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，事实证明对象</font></font><code>WeakMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许垃圾收集器摆脱那些在外部变量中未引用的记录。</font><font style="vertical-align: inherit;">对象</font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储键/值对，而不管是否存在外部键引用。</font><font style="vertical-align: inherit;">可以说</font></font><code>Map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用普通数组</font><font style="vertical-align: inherit;">实现数据结构也是如此</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用</font></font><code>WeakMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“弱”键引用。</font><font style="vertical-align: inherit;">如果没有其他用作键的对象的引用，它们不会干扰垃圾收集器的操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20.如何将参数传递给JavaScript函数：按引用还是按值？</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：*****</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
参数始终按值传递，但对对象的引用将写入表示对象的变量。</font><font style="vertical-align: inherit;">因此，当将对象转移到函数并更改该对象的属性时，即使函数退出，此更改也会保存在对象中。</font><font style="vertical-align: inherit;">结果，感觉到函数中的参数是通过引用传递的。</font><font style="vertical-align: inherit;">但是，如果更改表示对象的变量的值，则此更改将不会影响该函数外部的对象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个例子：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeStuff</span>(<span class="hljs-params">a, b, c</span>)
</span>{<font></font>
&nbsp;&nbsp;a = a * <span class="hljs-number">10</span>;<font></font>
&nbsp;&nbsp;b.item = <span class="hljs-string">"changed"</span>;<font></font>
&nbsp;&nbsp;c = {<span class="hljs-attr">item</span>: <span class="hljs-string">"changed"</span>};<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;
<span class="hljs-keyword">var</span> obj1 = {<span class="hljs-attr">item</span>: <span class="hljs-string">"unchanged"</span>};
<span class="hljs-keyword">var</span> obj2 = {<span class="hljs-attr">item</span>: <span class="hljs-string">"unchanged"</span>};<font></font>
<font></font>
changeStuff(num, obj1, obj2);<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(num);
<span class="hljs-built_in">console</span>.log(obj1.item);
<span class="hljs-built_in">console</span>.log(obj2.item);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是此代码将输出的内容：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-number">10</span><font></font>
changed<font></font>
unchanged<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21.如何组织对象的“深度冻结”？</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：*****</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了使用来“深度冻结”对象</font></font><code>Object.freeze()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，您需要创建一个递归函数来“冻结”对象的属性，这些属性也是对象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个普通的对象“冻结”的示例：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> person = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">"Leonardo"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">profession</span>: {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">"developer"</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
};<font></font>
<span class="hljs-built_in">Object</span>.freeze(person); <span class="hljs-comment">//   </span>
person.profession.name = <span class="hljs-string">"doctor"</span>;
<span class="hljs-built_in">console</span>.log(person); <span class="hljs-comment">// { name: 'Leonardo', profession: { name: 'doctor' } }</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是“深度冻结”：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepFreeze</span>(<span class="hljs-params">object</span>) </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span> propNames = <span class="hljs-built_in">Object</span>.getOwnPropertyNames(object);
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> name <span class="hljs-keyword">of</span> propNames) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span> value = object[name];<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object[name] = value &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"object"</span> ?<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deepFreeze(value) : value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.freeze(object);<font></font>
}<font></font>
<span class="hljs-keyword">let</span> person = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">"Leonardo"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">profession</span>: {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">"developer"</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
};<font></font>
deepFreeze(person);<font></font>
person.profession.name = <span class="hljs-string">"doctor"</span>; <span class="hljs-comment">// TypeError: Cannot assign to read only property 'name' of object</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仅在严格模式下显示错误消息。</font><font style="vertical-align: inherit;">在正常模式下，该值不会更改而不会出现错误消息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22.为什么JavaScript程序员在使用this关键字时会遇到麻烦？</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：*****</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要了解的最重要的事情</font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是函数没有固定的值</font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该值取决于函数的调用方式。</font><font style="vertical-align: inherit;">如果我们说用某个特定值调用函数</font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则意味着此值不是在函数声明期间确定的，而是在函数调用期间确定的。</font><font style="vertical-align: inherit;">以下是一些功能</font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果以通常的形式调用该函数（即使用view结构</font></font><code>someFunc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），则</font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它将引用全局对象（在浏览器中为this </font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">如果代码以严格模式执行，</font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">则将值写入</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果将该函数作为对象的方法调用，则关键字</font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将由该方法所属的对象表示。</font></font></li>
<li>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">call</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">apply</a>, <code>this</code>   ,       <code>call</code>  <code>apply</code>.</li>
<li>      ,   <code>this</code>    .</li>
<li>     ,     <code>new</code>,   <code>this</code>   ,       <code>prototype</code> -.</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果函数是使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bind</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法创建的</font><font style="vertical-align: inherit;">，那么</font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">function </font><font style="vertical-align: inherit;">关键字</font><font style="vertical-align: inherit;">将严格绑定到</font></font><code>bind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为第一个参数</font><font style="vertical-align: inherit;">传递的值</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是函数没有硬编码值的规则的唯一例外</font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用创建的函数</font></font><code>bind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是不可变的</font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源</font></font></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">23.比较使用异步/等待构造和生成器来实现相同的功能</font></font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">难度：*****</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用方法迭代生成器时，</font></font><code>.next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对此方法的每次调用都会使用关键字返回单个值</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用async / await构造时，将按顺序执行await表达式。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步/等待设计简化了特定生成器用例的实现。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成器返回的值始终具有形式</font></font><code>{value: X, done: Boolean}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且异步函数返回使用值解析的承诺</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，否则将失败。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以使用promise将异步函数转换为生成器。</font><font style="vertical-align: inherit;">以下是这种转换的示例。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是异步函数：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  </span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>) </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> res1 = <span class="hljs-keyword">await</span> doTask1();
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(res1);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> res2 = <span class="hljs-keyword">await</span> doTask2(res1);
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(res2);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> res3 = <span class="hljs-keyword">await</span> doTask3(res2);
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(res3);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> res3;<font></font>
}<font></font>
<font></font>
init();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个类似的发电机。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//    </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runner</span>(<span class="hljs-params">genFn</span>) </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> itr = genFn();<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params">arg</span>) </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span> result = itr.next(arg);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span> (result.done) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> result.value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <span class="hljs-keyword">else</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(result.value).then(run);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> run;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//   runner    </span>
runner(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> res1 = <span class="hljs-keyword">await</span> doTask1();
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(res1);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> res2 = <span class="hljs-keyword">await</span> doTask2(res1);
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(res2);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> res3 = <span class="hljs-keyword">await</span> doTask3(res2);
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(res3);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> res3;<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资料来源</font></font></a><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尊敬的读者！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您在面试中提出了哪些JavaScript问题？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/iq/fi/b4/iqfib45pgphfrxv--zfemt0qnmw.jpeg"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN498996/index.html">Web套接字和Socket.IO之间的区别</a></li>
<li><a href="../zh-CN498998/index.html">Rust 1.43.0发行版：改进了编译器和基元，宏项中的类型推断</a></li>
<li><a href="../zh-CN499004/index.html">如何在孤立的环境中玩耍或使用声卡传输数据</a></li>
<li><a href="../zh-CN499008/index.html">为什么开发人员这么慢：常见问题及其解决方案</a></li>
<li><a href="../zh-CN499010/index.html">我们研究了Mediastreamer2 VoIP引擎。第11部分</a></li>
<li><a href="../zh-CN499016/index.html">与ESIA for .Net集成：比听起来容易</a></li>
<li><a href="../zh-CN499018/index.html">6个家庭运动应用</a></li>
<li><a href="../zh-CN499020/index.html">一项模糊行为的研究</a></li>
<li><a href="../zh-CN499030/index.html">在20分钟内在isic上监视Grafana的MySQL性能</a></li>
<li><a href="../zh-CN499032/index.html">如何使用Prometheus检测GitLab中的异常</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>