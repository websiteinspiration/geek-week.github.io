<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏜️ 📕 👩‍👩‍👧‍👦 Gesetze der Programmierung 👩🏾‍💼 😧 🤴🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gesetze, Theorien, Prinzipien und Muster, die für Entwickler nützlich sind
 Einführung
 Repository-Übersetzung github.com/dwmkerr/hacker-laws
 
 In Di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Gesetze der Programmierung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491946/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesetze, Theorien, Prinzipien und Muster, die für Entwickler nützlich sind</font></font></h3><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung</font></font></h2><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository-Übersetzung </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/dwmkerr/hacker-laws</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In Diskussionen im Zusammenhang mit der Softwareentwicklung wird häufig über unterschiedliche Gesetze gesprochen. </font><font style="vertical-align: inherit;">In diesem Repository werden Links und Beschreibungen einiger der bekanntesten von ihnen gespeichert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es enthält Erklärungen einiger Gesetze, Prinzipien und Gesetze, aber es gibt keine Aufregung zu ihren Gunsten. </font><font style="vertical-align: inherit;">Sie zu benutzen oder nicht, ist immer ein strittiger Punkt, und alles hängt davon ab, woran Sie arbeiten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Gesetze</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Amdahls Gesetz</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Amdahls Gesetz ist eine Formel, die das Potenzial zur Beschleunigung einer Rechenaufgabe demonstriert, die mit einer Erhöhung der Menge an Systemressourcen erreicht werden kann. </font><font style="vertical-align: inherit;">Es wird normalerweise beim parallelen Rechnen verwendet und kann die tatsächlichen Vorteile einer Erhöhung der Anzahl der Prozessoren unter Berücksichtigung der Parallelitätsbeschränkungen des Programms vorhersagen.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir geben ein Beispiel. Wenn das Programm aus zwei Teilen besteht - Teil A, der auf einem Prozessor ausgeführt werden muss, und Teil B, der parallelisiert werden kann, ist klar, dass die Vorteile des Hinzufügens mehrerer Prozessoren zu dem System, das das Programm ausführt, begrenzt sind. Möglicherweise kann dies Teil B stark beschleunigen - die Geschwindigkeit von Teil A ändert sich jedoch nicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das folgende Diagramm zeigt Beispiele für mögliche Geschwindigkeitsgewinne: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ut/xp/-d/utxp-dkhljmsqsjmdgauv6_qtsg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen, sind die Vorteile des Hinzufügens von mehr als 10 separaten Prozessoren vernachlässigbar, selbst wenn 50% des Programms parallelisiert werden können. Wenn das Programm zu 95% parallelisiert werden kann, werden die Verbesserungen auch nach dem Hinzufügen von Tausenden von Prozessoren spürbar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der Verlangsamung des Moore'schen Gesetzes und der Beschleunigung des Prozessors wird die Parallelisierung zum Schlüssel zur Verbesserung der Effizienz. </font><font style="vertical-align: inherit;">Die Grafikprogrammierung ist ein gutes Beispiel: Mit der modernen Programmierung auf Basis von Shadern können Sie Fragmente des Bildes parallel zeichnen, sodass Sie in modernen Grafikkarten Tausende von Prozessorkernen (GPUs oder Shader-Module) finden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Theorie der zerbrochenen Fenster</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Theorie der zerbrochenen Fenster besagt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dass sichtbare Anzeichen von Kriminalität (oder mangelnde Sorge um die Umwelt) eine Zunahme der Anzahl und Schwere der Kriminalität (und eine weitere Verschlechterung der Umwelt) zur Folge haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Theorie wurde auf die Softwareentwicklung angewendet, was darauf hindeutet, dass eine schlechte Codequalität (oder die sogenannte " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">technische Verschuldung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ") das Gefühl hervorrufen kann, dass alle Versuche, die Qualität zu verbessern, ignoriert oder unterschätzt werden, was zum Auftreten von neuem fehlerhaftem Code führt. </font><font style="vertical-align: inherit;">Dieser Effekt entwickelt sich in einer Kaskade, weshalb sich die Qualität mit der Zeit verschlechtert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brooks Law</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hinzufügen zusätzlicher Humanressourcen zu einem verspäteten Projekt verzögerte seine Leistung noch mehr.</font></font></blockquote><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Brooks-Gesetz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besagt, dass in vielen Fällen Versuche, die Veröffentlichung eines bereits verspäteten Projekts zu beschleunigen, indem zusätzliche Personen hinzugefügt werden, dazu führen, dass das Projekt noch später veröffentlicht wird, als es könnte. Brooks betont jedoch, dass dies eine übermäßige Vereinfachung des Problems darstellt. Er argumentierte wie folgt: Angesichts der Kosten für die Zeit, die für die Beauftragung neuer Ressourcen und die Kommunikation der Menschen untereinander erforderlich ist, sinkt kurzfristig die Entwicklungsrate des Projekts. Außerdem können viele Aufgaben möglicherweise nicht getrennt werden, dh sie können nicht einfach auf Ressourcen verteilt werden, deren Menge erhöht wurde, sodass die potenzielle Geschwindigkeitssteigerung nicht so signifikant ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das allgemeine Sprichwort "Neun Frauen können in einem Monat kein Baby zur Welt bringen" bezieht sich auf das Brooks-Gesetz, insbesondere weil einige Arten von Arbeit nicht geteilt oder parallelisiert werden können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist das Hauptthema des Buches Mythical Man-Month.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conway Gesetz</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Gesetz von Conway</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besagt, dass die technischen Einschränkungen des entworfenen Systems die Struktur der Organisation widerspiegeln. </font><font style="vertical-align: inherit;">Er wird oft erinnert, wenn er versucht, die Organisation zu verbessern. </font><font style="vertical-align: inherit;">Das Gesetz besagt, dass wenn eine Organisation in viele kleine, nicht verwandte Module strukturiert ist, das von ihr erstellte Programm dasselbe ist. </font><font style="vertical-align: inherit;">Wenn die Organisation basierend auf bestimmten Funktionen oder Diensten auf Branchen aufgebaut ist, spiegelt die Software diese Tatsache wider.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cunningham Law</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der beste Weg, um im Internet die richtige Antwort zu finden, besteht nicht darin, eine Frage zu stellen, sondern eine absichtlich falsche Antwort zu veröffentlichen.</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stephen McGeady sagt, dass </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ward Cunningham</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ihm </font><font style="vertical-align: inherit;">in den frühen 1980er Jahren </font><font style="vertical-align: inherit;">Ratschläge gab: "Der beste Weg, die richtige Antwort im Internet zu finden, besteht nicht darin, eine Frage zu stellen, sondern eine absichtlich falsche Antwort zu veröffentlichen." </font><font style="vertical-align: inherit;">McGeady nannte es "Cunninghams Gesetz", obwohl Cunningham es selbst leugnet und sagt, er sei "falsch zitiert". </font><font style="vertical-align: inherit;">Obwohl sich der Ausdruck ursprünglich auf die Kommunikation im Usenet bezog, wurde das Gesetz seitdem verwendet, um Arbeit und andere Gemeinschaften (Wikipedia, Reddit, Twitter, Facebook) zu beschreiben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dunbar Nummer</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anzahl der Dunbar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine Grenze für die Anzahl der dauerhaften sozialen Bindungen, die eine Person aufrechterhalten kann. Dies bezieht sich auf Beziehungen, die das Wissen über die Besonderheiten eines bestimmten Individuums beinhalten, dessen Verbindung aufrechterhalten werden muss, seinen Charakter sowie seinen sozialen Status und seine Verbindungen zu anderen Menschen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die genaue Anzahl solcher Beziehungen ist unbekannt. Dunbar selbst schlug vor, dass eine Person nicht mehr als 150 solcher Verbindungen bequem unterstützen kann. Er beschrieb es in einem sozialeren Kontext: "Die Anzahl der Personen, denen Sie ohne Einladung zum gemeinsamen Trinken ohne zu zögern beitreten, wenn Sie ihnen versehentlich an der Bar begegnen." Schätzungen dieser Zahl variieren normalerweise zwischen 100 und 250.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bei stabilen Beziehungen zwischen Personen erfordert die Aufrechterhaltung der Beziehung eines Programmierers zum Code viel Aufwand. </font><font style="vertical-align: inherit;">Wenn wir mit großen und komplexen Projekten oder mit dem Besitz vieler kleiner Projekte konfrontiert werden, verlassen wir uns auf bestimmte Vereinbarungen, Richtlinien und Verfahren. </font><font style="vertical-align: inherit;">Es ist wichtig, die Dunbar-Nummer nicht nur bei der Erhöhung der Mitarbeiterzahl zu berücksichtigen, sondern auch bei der Bestimmung des Teamumfangs oder des Zeitpunkts, zu dem das System zusätzliche Tools zur Modellierung und Automatisierung der Logistik erwerben sollte. </font><font style="vertical-align: inherit;">Im technischen Kontext ist dies die Anzahl der Projekte (oder die normalisierte Komplexität eines Projekts), für die Sie sicher in die Code-Support-Gruppe aufgenommen würden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Goll Gesetz</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein funktionierendes komplexes System kam notwendigerweise von einem funktionierenden einfachen System. </font><font style="vertical-align: inherit;">Ein komplexes System, das von Grund auf neu entwickelt wurde, funktioniert nie und es ist unmöglich, es so zu reparieren, dass es funktioniert. </font><font style="vertical-align: inherit;">Sie müssen mit einem einfachen Arbeitssystem neu beginnen.</font></font></blockquote><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Golls Gesetz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> legt nahe, dass Versuche, ein sehr komplexes System zu entwickeln, höchstwahrscheinlich scheitern werden. </font><font style="vertical-align: inherit;">Systeme mit hoher Komplexität werden selten in einer Sitzung erstellt - sie entstehen aus einfacheren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein klassisches Beispiel ist ein weltweites Netzwerk. </font><font style="vertical-align: inherit;">Im gegenwärtigen Zustand ist es ein System von hoher Komplexität. </font><font style="vertical-align: inherit;">Es wurde jedoch ursprünglich als eine einfache Möglichkeit zum Austausch von Inhalten zwischen Institutionen identifiziert. </font><font style="vertical-align: inherit;">Sie hat diese Ziele sehr erfolgreich gemeistert und sich im Laufe der Zeit zu einem komplexeren entwickelt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Goodhart-Gesetz</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes beobachtete statistische Muster neigt dazu, zusammenzubrechen, sobald Druck auf es ausgeübt wird, um es zu kontrollieren.</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird auch oft formuliert als:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn eine Maßnahme zum Ziel wird, ist sie keine gute Maßnahme mehr. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Marilyn Strain</font></font></blockquote><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Gesetz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sieht vor, dass eine Optimierung aufgrund bestimmter Maßnahmen zur Abschreibung dieser Maßnahmen führen kann. </font><font style="vertical-align: inherit;">Übermäßig selektive Messungen (KPIs), die blind auf einen Prozess angewendet werden, führen zu Verzerrungen. </font><font style="vertical-align: inherit;">Menschen bemühen sich, den Prozess lokal zu optimieren und das System zu „täuschen“, um eine bestimmte Metrik zu erfüllen, anstatt auf das globale Ergebnis ihrer Handlungen zu achten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiele:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tests ohne Ansprüche erfüllen die Erwartungen an die Codeabdeckung, obwohl eine solche Metrik erstellt wurde, damit das Programm gut getestet wurde.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Beurteilung der Effektivität des Entwicklers anhand der Anzahl der zum Projekt beigetragenen Zeilen führt zu einer ungerechtfertigten Aufblähung des Codes.</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hanlon Rasiermesser</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Führen Sie niemals Bosheit auf das zurück, was vollständig durch Dummheit erklärt wird.</font></font></blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Prinzip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besagt, dass Handlungen, die zu einem negativen Ergebnis führen, nicht mit schlechten Absichten durchgeführt werden dürfen. </font><font style="vertical-align: inherit;">Das negative Ergebnis ist eher darauf zurückzuführen, dass diese Maßnahmen und ihre Folgen nicht gut verstanden wurden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hofstaders Gesetz</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ausführung einer Aufgabe dauert immer länger als erwartet, auch wenn Sie das Gesetz von Hofstader berücksichtigt haben.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Möglicherweise stoßen Sie </font><font style="vertical-align: inherit;">auf </font><font style="vertical-align: inherit;">Verweise auf dieses </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesetz,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wenn Sie Schätzungen der für ein Projekt aufgewendeten Zeit vornehmen. </font><font style="vertical-align: inherit;">Auf dem Gebiet der Softwareentwicklung scheint es eine Binsenweisheit zu sein, dass wir die für die Fertigstellung des Projekts benötigte Zeit nicht sehr gut abschätzen können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zitat aus dem Buch " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gödel, Escher, Bach: Diese endlose Girlande</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ".</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hutber-Gesetz</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbesserung ist gleichbedeutend mit Zerstörung.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesetz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besagt, dass die Verbesserung eines Teils des Systems zur Zerstörung anderer Teile führt oder andere Arten der Zerstörung verbirgt, was im Allgemeinen zu einer Verschlechterung des Systems im Vergleich zu seinem aktuellen Zustand führt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispielsweise kann das Verringern der Antwortzeit in einem bestimmten Teil des Systems zu einer Erhöhung seines Durchsatzes und infolgedessen zu Problemen mit der Kapazität irgendwo im Pfad des Anforderungsflusses führen, die sich auf ein anderes Subsystem auswirken können.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Kreislauf von Hype und Amars Gesetz</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir neigen dazu, die Auswirkungen der Technologie kurzfristig zu überschätzen und langfristig zu unterschätzen.</font></font></blockquote><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Hype-Zyklus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine Visualisierung der Begeisterung und Entwicklung der Technologie im Laufe der Zeit, die ursprünglich von Gartner entwickelt wurde. Die Grafik zeigt dies am besten: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/oq/li/9p/oqli9pjl8nd51lwajsklecrdjm8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Aufkommen der Technologie erreicht ihre Popularität den Höhepunkt aufgeblähter Erwartungen, taucht dann in die Höhle der Enttäuschung ein, steigt entlang des Abhangs der Erleuchtung und erreicht das Plateau der Produktivität</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz gesagt, der Zyklus argumentiert, dass in der Regel eine Quelle der Begeisterung für neue Technologien und ihre möglichen Folgen entsteht. </font><font style="vertical-align: inherit;">Teams sind oft schnell von diesen Technologien abhängig und von den Ergebnissen oft enttäuscht. </font><font style="vertical-align: inherit;">Vielleicht liegt dies daran, dass die Technologie noch nicht ausreichend entwickelt ist oder die Methoden für ihre Anwendung noch nicht durchdacht sind. </font><font style="vertical-align: inherit;">Nach einer gewissen Zeit nehmen die Fähigkeiten der Technologie zu und die Anzahl der praktischen Anwendungen wächst, wonach die Teams endlich produktiv werden können.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hirams Gesetz</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie eine ausreichende Anzahl von API-Benutzern erreichen, spielt es keine Rolle, welche Funktionen Sie allen versprochen haben: Für alle möglichen Funktionen des Verhaltens Ihres Systems gibt es einen Benutzer, der davon abhängt.</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hirams Gesetz postuliert, dass, wenn Ihre API genügend Benutzer hat, es einen Benutzer geben wird, der von einem der möglichen Verhaltensweisen Ihres Systems abhängig ist (nicht einmal im öffentlichen Auftrag beschrieben). </font><font style="vertical-align: inherit;">Ein triviales Beispiel wären nicht funktionierende API-Funktionen wie die Antwortzeit. </font><font style="vertical-align: inherit;">Ein subtileres Beispiel sind Verbraucher, die sich darauf verlassen, die Art des Fehlers zu bestimmen, indem sie die Regex-Funktion auf ihre Beschreibung anwenden. </font><font style="vertical-align: inherit;">Selbst wenn der öffentliche Vertrag nichts über den Inhalt der Nachricht aussagt und impliziert, dass Benutzer den Fehlercode verwenden müssen, entscheiden sich einige von ihnen möglicherweise für die Verwendung der Nachricht, und durch Ändern der Nachricht wird die API für diese Benutzer beschädigt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kernigan Law</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Debuggen von Code ist zweimal schwieriger als das Schreiben. </font><font style="vertical-align: inherit;">Wenn Sie also Code bis an die Grenzen Ihrer geistigen Fähigkeiten schreiben, verfügen Sie per Definition nicht über genügend Intelligenz, um ihn zu debuggen.</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kernigans Gesetz ist nach Brian Kernigan benannt und stammt aus einem Buch, das er und Plauger geschrieben haben: "Elemente eines Programmierstils". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder weiß, dass das Debuggen von Code zweimal schwieriger ist als das Schreiben. </font><font style="vertical-align: inherit;">Wenn Sie also beim Schreiben von Code alle Ihre mentalen Anstrengungen unternehmen, wie werden Sie ihn dann debuggen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl das Gesetz eine Übertreibung ist, behauptet es, dass es besser ist, einfachen Code als komplexen zu verwenden, da das Debuggen von Problemen, die in komplexem Code auftreten, zu teuer oder sogar unmöglich sein kann.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metcalfs Gesetz</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Netzwerktheorie wächst der Nutzen eines Netzwerks ungefähr als Quadrat der Anzahl seiner Benutzer.</font></font></blockquote><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Gesetz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> basiert auf der Anzahl möglicher paarweiser Verbindungen innerhalb des Systems und ist eng mit dem Reedschen Gesetz verbunden. </font><font style="vertical-align: inherit;">Odlyzhko und andere argumentierten, dass die Gesetze von Reed und Metcalf den Wert des Systems übertrieben hätten, ohne die Einschränkungen der menschlichen Fähigkeit zu berücksichtigen, das Netzwerk zu verstehen. </font><font style="vertical-align: inherit;">siehe Dunbar Nummer.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moores Gesetz</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anzahl der auf einem integrierten Schaltkreischip platzierten Transistoren verdoppelt sich ungefähr alle 24 Monate.</font></font></blockquote><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moores Vorhersage</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die oft verwendet wurde, um die enorme Geschwindigkeit der Verbesserung der Halbleiter- und Chipherstellungstechnologien zu demonstrieren, war überraschend genau und funktionierte von den 1970er bis Ende der 2000er Jahre. </font><font style="vertical-align: inherit;">In den letzten Jahren hat sich der Trend insbesondere aufgrund der physikalischen Einschränkungen der Miniaturisierung von Bauteilen leicht verändert. </font><font style="vertical-align: inherit;">Parallelisierungsfortschritte und möglicherweise revolutionäre Veränderungen in der Halbleitertechnologie und in Quantencomputern können jedoch dazu führen, dass das Mooresche Gesetz für die nächsten Jahrzehnte gültig bleibt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Murphys Gesetz</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles, was schief gehen kann, wird schief gehen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Murphys Gesetz, verfasst von Edward A. Murphy, postuliert, dass alles, was schief gehen kann, notwendigerweise schief gehen wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Sprichwort wird oft von Entwicklern verwendet. </font><font style="vertical-align: inherit;">Manchmal passieren unerwartete Dinge während der Entwicklung, des Testens oder sogar in der Produktion. </font><font style="vertical-align: inherit;">Es kann mit dem Gesetz der Gemeinheit in Verbindung gebracht werden, das in Großbritannien häufiger angewendet wird [tatsächlich ist es auch in Russland bekannt / ca. </font><font style="vertical-align: inherit;">übersetzt.]:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn etwas schief gehen kann, wird es passieren und im schlimmsten Moment.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Normalerweise werden diese "Gesetze" in einem humorvollen Sinne verwendet. </font><font style="vertical-align: inherit;">Phänomene wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bestätigungsverzerrungen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">systematische Auswahlfehler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> können jedoch dazu führen, dass die Menschen übermäßig an diesen Gesetzen interessiert sind (in den meisten Fällen bemerkt dies niemand, wenn alles so funktioniert, wie es sollte, aber Fehler sind auffälliger und ziehen mehr Diskussionen an).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ockhams Rasiermesser</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie sollten die Dinge nicht unnötig multiplizieren.</font></font></blockquote><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Occams Rasiermesser</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> behauptet, dass von den wenigen möglichen Lösungen die Lösung, die die geringste Menge an Konzepten und Annahmen enthält, am wahrscheinlichsten ist. </font><font style="vertical-align: inherit;">Diese Lösung ist die einfachste und löst nur das gegebene Problem, ohne zufällige Schwierigkeiten und mögliche negative Folgen mit sich zu bringen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parkinson-Gesetz</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Arbeit füllt die ihr zugewiesene Zeit aus.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im ursprünglichen Kontext </font><font style="vertical-align: inherit;">basierte </font><font style="vertical-align: inherit;">das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesetz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf der Untersuchung der Bürokratie. </font><font style="vertical-align: inherit;">Pessimistisch kann es auf die Softwareentwicklung angewendet werden, vorausgesetzt, das Team arbeitet ineffizient, bis sich die Projektfrist nähert, und es wird dann eilig sein, es pünktlich zu liefern, was das spezifische Enddatum eher willkürlich macht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie es mit dem Gesetz von Hofstader kombinieren, erhalten Sie eine noch pessimistischere Sichtweise: Die Arbeit wird erweitert, bis sie die gesamte für ihre Fertigstellung erforderliche Zeit ausfüllt und dennoch mehr als erwartet dauert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Effekt einer vorzeitigen Optimierung</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorzeitige Optimierung ist die Wurzel allen Übels.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Donald Knuths Arbeit „Strukturierte Programmierung mit GoTo“ schrieb er: „Programmierer verbringen viel Zeit damit, über die Geschwindigkeit der Ausführung unkritischer Teile von Programmen nachzudenken und sich Sorgen zu machen, und der Versuch, sie effektiver zu machen, wirkt sich stark negativ aus, wenn Sie über das Debuggen und Unterstützen nachdenken. </font><font style="vertical-align: inherit;">Wir müssen die unwichtige Effizienz von 97% der Zeit vergessen: Vorzeitige Optimierung ist die Wurzel aller Übel. </font><font style="vertical-align: inherit;">In kritisch kritischen 3% der Fälle sollten wir jedoch unsere Chance nicht verpassen. “ </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vorzeitige Optimierung kann jedoch auch als Versuch beschrieben werden, etwas zu optimieren, bevor wir verstehen, was wir tun müssen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patt Law</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Technologiesektor wird von zwei Arten von Menschen dominiert: denen, die verstehen, dass sie nicht kontrollieren, und denen, die kontrollieren, was sie nicht verstehen.</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesetz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sollte Patta </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Patta</font></a><font style="vertical-align: inherit;"> oft schließen:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In jeder technischen Hierarchie entwickelt sich im Laufe der Zeit eine Umkehrung der Kompetenz.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Aussagen deuten darauf hin, dass es aufgrund unterschiedlicher Auswahlkriterien und Gruppenorganisationstrends immer eine bestimmte Anzahl erfahrener Personen auf den Arbeitsebenen der technischen Organisation geben wird, und es wird immer Personen auf der Führungsebene geben, die keine Ahnung von der Komplexität und den Problemen der von ihnen verwalteten Arbeit haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist jedoch hervorzuheben, dass solche Gesetze eine sehr grobe Verallgemeinerung darstellen und möglicherweise für einige Arten von Organisationen gelten und für andere nicht.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reeds Gesetz</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Nutzen großer Netzwerke, insbesondere sozialer Netzwerke, wächst exponentiell mit dem Wachstum der Netzwerkgröße.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesetz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> basiert auf der Graphentheorie, bei der der Nutzen als Anzahl möglicher Untergruppen skaliert und schneller wächst als die Anzahl der Teilnehmer oder mögliche paarweise Verbindungen. </font><font style="vertical-align: inherit;">Odlyzhko und andere argumentierten, dass die Gesetze von Reed und Metcalf den Wert des Systems übertrieben hätten, ohne die Einschränkungen der menschlichen Fähigkeit zu berücksichtigen, das Netzwerk zu verstehen. </font><font style="vertical-align: inherit;">siehe Dunbar Nummer.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Gesetz der Erhaltung der Komplexität (Tesler-Gesetz)</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Gesetz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besagt, dass das System eine gewisse Komplexität aufweist, die nicht reduziert werden kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Teil der Komplexität des Systems kann unbeabsichtigt auftreten. </font><font style="vertical-align: inherit;">Dies ist das Ergebnis einer schlechten Struktur, von Fehlern oder einer erfolglosen Modellierung des zu lösenden Problems. </font><font style="vertical-align: inherit;">Unbeabsichtigte Komplexität kann reduziert oder beseitigt werden. </font><font style="vertical-align: inherit;">Einige Arten von Komplexität sind jedoch eine wesentliche Folge der Komplexität der Aufgabe selbst. </font><font style="vertical-align: inherit;">Diese Komplexität kann verschoben, aber nicht beseitigt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eines der interessanten Elemente dieses Gesetzes ist die Annahme, dass selbst mit der Vereinfachung des gesamten Systems seine interne Komplexität nicht abnimmt, sondern an den Benutzer geht, der es schwerer hat, sich zu verhalten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Gesetz der fließenden Abstraktionen</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle nicht trivialen Abstraktionen unterliegen einem gewissen Fluss.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Gesetz besagt, dass Abstraktionen, die normalerweise in der IT verwendet werden, um die Arbeit mit komplexen Systemen zu vereinfachen, in bestimmten Situationen auslaufen und die Elemente der ihnen zugrunde liegenden Systeme nach oben fließen lassen, weshalb sich die Abstraktion unvorhersehbar verhält.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Beispiel ist das Herunterladen einer Datei und das Lesen ihres Inhalts. Die Dateisystem-API ist eine Abstraktion von Kernelsystemen niedrigerer Ebene, die selbst eine Abstraktion der physischen Prozesse sind, die mit dem Ändern von Daten auf einer Magnetplatte (oder in einem SSD-Flash-Speicher) verbunden sind. In den meisten Fällen funktioniert eine Abstraktion, die eine Datei als Strom von Binärdaten darstellt. Das sequentielle Lesen von Daten von einer Magnetplatte erfolgt jedoch schneller als der zufällige Zugriff darauf, SSDs haben jedoch keine derartigen Probleme. Sie müssen die Details verstehen, die in der Tiefe liegen, um diese Fälle zu behandeln (z. B. sind Indexdatenbankdateien so strukturiert, dass die Zeit für den wahlfreien Zugriff verkürzt wird), wenn die Abstraktion ein Leck an Implementierungsdetails enthält, über die der Entwickler Bescheid wissen muss.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das obige Beispiel kann beim Hinzufügen neuer Abstraktionen komplizierter werden. Unter Linux können Sie über das Netzwerk auf Dateien zugreifen, diese werden jedoch lokal als "normal" angezeigt. Diese Abstraktion tritt bei Netzwerkproblemen aus. Wenn der Entwickler sie als „normal“ behandelt und nicht berücksichtigt, dass sie anfällig für Probleme mit Verzögerungen und Netzwerkfehlern sind, ist seine Lösung suboptimal und fehlerhaft. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dem Artikel, der das Gesetz beschreibt, wird angenommen, dass eine übermäßige Abhängigkeit von Abstraktionen in Verbindung mit einem schlechten Verständnis der zugrunde liegenden Prozesse in einigen Fällen sogar den Prozess der Problemlösung erschwert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiele: Langsamer Start von Photoshop. Ich bin </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">auf</font></a><font style="vertical-align: inherit;"> dieses Problem gestoßen</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Vergangenheit. </font><font style="vertical-align: inherit;">Photoshop wurde sehr langsam gestartet, manchmal dauerte es einige Minuten. </font><font style="vertical-align: inherit;">Anscheinend bestand das Problem darin, dass beim Start standardmäßig Informationen über den aktuellen Drucker gelesen werden. </font><font style="vertical-align: inherit;">Wenn dieser Drucker jedoch ein Netzwerkdrucker ist, kann dies extrem lange dauern. </font><font style="vertical-align: inherit;">Die Abstraktion, nach der der Netzwerkdrucker dem lokalen ähnlich ist, verursachte dem Benutzer Probleme bei schlechter Kommunikation.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesetz der Trivialität</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Gesetz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besagt, dass Gruppen viel mehr Zeit und Aufmerksamkeit für die Erörterung kosmetischer oder trivialer Fragen aufwenden als für ernsthafte und umfassende. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Beispiel ist in der Regel die Arbeit eines Ausschusses, der Pläne für ein Kernkraftwerk genehmigt, in dem die Struktur des Fahrradabstellplatzes meistens erörtert wird, als die wichtigeren Fragen bei der Gestaltung der Station selbst. Es kann schwierig sein, einen wertvollen Beitrag zur Diskussion sehr großer und komplexer Themen zu leisten, ohne über umfassende Kenntnisse zu diesem Thema zu verfügen. Die Leute möchten jedoch für wertvolle Kommentare zur Kenntnis genommen werden. Ab hier entsteht die Tendenz, sich auf kleine Details zu konzentrieren, über die leicht zu sprechen ist, die aber für das gesamte Projekt nicht unbedingt wichtig sind.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus dem oben angegebenen fiktiven Beispiel entstand der Begriff „Fahrradschuppen-Effekt“, der den Zeitverlust bei der Erörterung trivialer Details beschreibt. </font><font style="vertical-align: inherit;">Es gibt einen ähnlichen Begriff, "Yak-Haarschnitt", der eine scheinbar nicht verwandte Aktivität beschreibt, die Teil einer langen Kette notwendiger Vorbereitungsschritte ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unix-Philosophie </font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Unix-Philosophie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lautet, dass Softwarekomponenten klein sein und sich darauf konzentrieren sollten, eine bestimmte Aufgabe gut zu erledigen. </font><font style="vertical-align: inherit;">Dies erleichtert den Prozess des Aufbaus von Systemen, indem aus kleinen, einfachen und genau definierten Modulen rekrutiert wird, anstatt große, komplexe, multifunktionale Programme zu verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Moderne Praktiken wie die „Microservice-Architektur“ können als Anwendung dieser Philosophie angesehen werden. Die Services sind klein und konzentrieren sich auf eine bestimmte Aufgabe, sodass Sie aus einfachen Bausteinen ein komplexes Verhalten erstellen können.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spotify-Modell </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Ansatz zur Teamstruktur und -organisation, den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spotify</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fördert </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In diesem Modell sind Teams nach Programmfunktionen organisiert, nicht nach Technologie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Modell fördert auch die Konzepte von Stämmen, Gilden, Zweigen - andere Komponenten der Organisationsstruktur.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wadlers Gesetz</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Entwerfen einer Sprache ist die Gesamtzeit, die für die Erörterung eines Features aus dieser Liste aufgewendet wird, proportional zur Potenz der Positionsnummer dieses Features in der Liste. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0. Semantik. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Die Syntax. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Lexikalische Syntax. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. Die lexikalische Syntax von Kommentaren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, für jede Stunde, die für die Semantik aufgewendet wird, werden 8 Stunden für die Syntax von Kommentaren aufgewendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie das Gesetz der Trivialität </font><font style="vertical-align: inherit;">postuliert </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wadlers Gesetz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dass beim Entwerfen einer Sprache der Zeitaufwand für Sprachstrukturen im Vergleich zur Bedeutung dieser Strukturen unverhältnismäßig hoch ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wheatons Gesetz</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sei keine Ziege.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses präzise, ​​einfache und umfassende Gesetz, das von Will Wheatan formuliert wurde, zielt darauf ab, die Harmonie und den Respekt innerhalb einer professionellen Organisation zu erhöhen. </font><font style="vertical-align: inherit;">Es kann in Gesprächen mit Kollegen, bei der Durchführung einer Expertenbewertung des Kodex, bei der Suche nach Einwänden gegen andere Gesichtspunkte, bei der Kritik und allgemein bei der professionellen Kommunikation zwischen Personen verwendet werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prinzipien</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grundsätze werden am häufigsten mit Ratschlägen zur Gestaltung von Programmen in Verbindung gebracht.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dilbert-Prinzip</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Unternehmen besteht die Tendenz, inkompetente Mitarbeiter zu Managern zu machen, um sie aus dem Arbeitsprozess auszuschließen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Managementkonzept, entwickelt von Scott Adams (Schöpfer der Dilbert-Comics), inspiriert von Peters Prinzip. </font><font style="vertical-align: inherit;">Nach </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Dilbert-Prinzip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden Mitarbeiter, die nicht als kompetent angesehen werden konnten, zu Managern befördert, um den möglichen Schaden für das Unternehmen zu begrenzen. </font><font style="vertical-align: inherit;">Adams erklärte dieses Prinzip erstmals 1995 in einem Artikel für das Wall Street Journal und beschrieb es dann ausführlich in seinem 1996 erschienenen Buch The Dilbert Principle.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pareto-Prinzip (80/20-Regel)</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum größten Teil ist alles im Leben ungleich verteilt.</font></font></blockquote><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Pareto-Prinzip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besagt, dass in einigen Fällen ein kleinerer Teil der Investition für die meisten Ergebnisse verantwortlich ist:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">80% des Programms können in 20% der Zeit geschrieben werden (und die schwierigsten 20% nehmen die restlichen 80% der Zeit in Anspruch).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20% des Aufwands ergeben 80% des Ergebnisses.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20% der Arbeit machen 80% des Gewinns aus.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20% der Fehler führen zu 80% der Programmabstürze.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20% der Funktionen werden in 80% der Fälle verwendet.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den 1940er Jahren begann Joseph Juran, ein amerikanischer Ingenieur rumänischer Herkunft, der oft als Vater des Qualitätsmanagements bezeichnet wird, das Pareto-Prinzip auf Qualitätsprobleme anzuwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auch dieses Prinzip ist in der Regel 80/20 das Gesetz des wichtigsten Kleinen, das Prinzip des Mangels an Faktoren, bekannt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiele: Im Jahr 2002 berichtete Microsoft, dass nach der Behebung von 20% der häufigsten Fehler 80% der damit verbundenen Probleme und Abstürze von Windows und Office behoben werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peter-Prinzip</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im hierarchischen System hat jeder Einzelne die Tendenz, auf das Niveau seiner Inkompetenz aufzusteigen.</font></font></blockquote><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von Lawrence Johnston Peter entwickelte </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Managementkonzept</font></a><font style="vertical-align: inherit;"> stellt fest, dass Menschen, die gute Arbeit leisten, befördert werden, bis sie ein Niveau erreichen, mit dem sie nicht mehr fertig werden („Inkompetenzniveau“). Da sie hoch genug geklettert sind, ist es bereits weniger wahrscheinlich, dass sie entlassen werden (es sei denn, sie erzeugen einen vollständigen Unsinn), sodass sie in dieser Position bleiben, für die ihnen die erforderlichen Fähigkeiten fehlen, da ihre Verhaltensfähigkeiten in der Organisation nicht unbedingt übereinstimmen mit den Fähigkeiten, die für eine erfolgreiche Arbeit in dieser Position erforderlich sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Prinzip ist besonders interessant für Ingenieure, die mit rein technischen Rollen arbeiten, aber häufig eine Karriere aufbauen, die zum Management anderer Ingenieure führt - was völlig andere Fähigkeiten erfordert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Prinzip der Zuverlässigkeit (Postelsches Gesetz)</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seien Sie konservativ in Bezug auf Ihre Aktivitäten und liberal in Bezug auf die Beiträge anderer.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Prinzip wird häufig bei der Entwicklung von Serveranwendungen angewendet. </font><font style="vertical-align: inherit;">Ihm zufolge sollten die Daten, die Sie an andere senden, so klein wie möglich und so gut wie möglich sein, um dem Standard zu entsprechen. Sie müssen jedoch selbst nicht vollständig standardisierte Daten als Eingabe akzeptieren, wenn Sie damit umgehen können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Zweck des Prinzips besteht darin, zuverlässige Systeme zu erstellen, die schlecht formatierte Daten verarbeiten können, deren Bedeutung noch verstanden werden kann. </font><font style="vertical-align: inherit;">Der Empfang nicht standardmäßiger Eingabedaten kann jedoch Konsequenzen im Zusammenhang mit einer Sicherheitsverletzung haben, insbesondere wenn der Empfang solcher Daten nicht gut getestet wurde.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Laufe der Zeit kann die Praxis, nicht standardisierte Daten zu empfangen, dazu führen, dass sich die Protokolle nicht mehr entwickeln, da diejenigen, die den Datenaustausch implementieren, sich auf die Liberalität der Programme verlassen und neue Funktionen schaffen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOLIDE</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Akronym für die folgenden 5 Prinzipien: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S: Das Prinzip der Einzelverantwortung </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 O: Das offene / geschlossene Prinzip </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 L: Das Liskov-Substitutionsprinzip </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 I: Das Prinzip der Schnittstellentrennung [ Prinzip der Schnittstellentrennung] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 D: Das </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prinzip der </font><font style="vertical-align: inherit;">Abhängigkeitsinversion </font><font style="vertical-align: inherit;">Dies sind die Schlüsselprinzipien der objektorientierten Programmierung. </font><font style="vertical-align: inherit;">Solche Entwurfsprinzipien sollen Entwicklern helfen, Systeme zu erstellen, die einfacher zu warten sind.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundsatz der alleinigen Verantwortung</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes Objekt muss eine Verantwortung haben, und diese Verantwortung muss vollständig in der Klasse enthalten sein.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste der Prinzipien von SOLID. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Prinzip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besagt, dass jedes Modul oder jede Klasse nur eines tun sollte. In der Praxis bedeutet dies, dass eine kleine, einzelne Änderung der Funktion eines Programms nur eine Änderung einer Komponente erfordern sollte. Um beispielsweise das Verfahren zum Überprüfen des Kennworts auf Komplexität zu ändern, muss das Programm nur an einer Stelle repariert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Theoretisch gibt dies dem Code Zuverlässigkeit und vereinfacht seine Änderung. Die Tatsache, dass die zu ändernde Komponente die alleinige Verantwortung trägt, sollte bedeuten, dass es einfacher ist, diese Änderung zu testen. Das Ändern der Komponente zur Überprüfung der Kennwortkomplexität gegenüber dem vorherigen Beispiel sollte sich nur auf Funktionen auswirken, die sich auf die Kennwortkomplexität beziehen. Es ist viel schwieriger, darüber zu sprechen, was von einem Komponentenwechsel mit vielen Verantwortlichkeiten betroffen sein wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Prinzip der Offenheit / Nähe</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entitäten müssen für Erweiterungen geöffnet, für Änderungen jedoch geschlossen sein.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite der Prinzipien von SOLID. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Prinzip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besagt, dass Entitäten (Klassen, Module, Funktionen usw.) die Erweiterung ihres Verhaltens ermöglichen sollten, ihr aktuelles Verhalten jedoch nicht geändert werden sollte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein hypothetisches Beispiel: Stellen Sie sich ein Modul vor, das ein Markdown-Markup-Dokument in ein HTML-Markup-Dokument verwandeln kann. </font><font style="vertical-align: inherit;">Wenn das Modul so erweitert werden kann, dass es lernt, mit den neuen Funktionen des Markdown-Formats umzugehen, ohne seine internen Funktionen zu ändern, kann das Modul erweitert werden. </font><font style="vertical-align: inherit;">Wenn das Modul die Verarbeitung der aktuellen Markdown-Funktionen nicht ändern kann, wird das Modul zur Änderung geschlossen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Prinzip ist besonders eng mit der objektorientierten Programmierung verbunden, bei der Sie Objekte entwerfen können, die leicht zu erweitern sind. Sie sollten jedoch keine Objekte entwerfen, deren Innenräume sich unerwartet ändern.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barbara Liskov Substitutionsprinzip</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sollte möglich sein, den Typ durch einen Untertyp zu ersetzen, ohne das System zu beschädigen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das dritte der Prinzipien von SOLID. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Prinzip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besagt, dass, wenn eine Komponente von einem Typ abhängt, es möglich sein sollte, Untertypen dieses Typs zu verwenden, damit das System die Arbeit nicht verweigert oder keine Details dieses Untertyps benötigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel haben wir eine Methode, die ein XML-Dokument aus einer Struktur liest, die eine Datei bezeichnet. </font><font style="vertical-align: inherit;">Wenn die Methode die Basistypdatei verwendet, sollte die Funktion in der Lage sein, alles zu verwenden, was aus der Datei stammt. </font><font style="vertical-align: inherit;">Wenn die Datei die umgekehrte Suche unterstützt und der XML-Parser diese Funktion verwendet, der abgeleitete Typ "Netzwerkdatei" jedoch nicht mit der umgekehrten Suche arbeitet, verstößt die "Netzwerkdatei" gegen dieses Prinzip.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Prinzip ist besonders eng mit der objektorientierten Programmierung verbunden, bei der Typhierarchien sehr sorgfältig modelliert werden müssen, um Verwirrung für den Systembenutzer zu vermeiden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prinzip der Schnittstellentrennung</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Software-Entitäten sollten nicht von Methoden abhängen, die sie nicht verwenden.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das vierte der Prinzipien von SOLID. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Prinzip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besagt, dass Verbraucher einer Komponente nicht von den Funktionen einer Komponente abhängen sollten, die sie nicht verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel haben wir eine Methode, die ein XML-Dokument aus einer Struktur liest, die eine Datei bezeichnet. </font><font style="vertical-align: inherit;">Es muss nur Bytes lesen und sich vorwärts oder rückwärts durch die Datei bewegen. </font><font style="vertical-align: inherit;">Wenn diese Methode aufgrund von Änderungen in einer Dateistruktur, die nicht damit zusammenhängt, aktualisiert werden muss (z. B. aufgrund einer Aktualisierung des Zugriffssteuerungsmodells, das die Dateisicherheit darstellt), wird dieses Prinzip verletzt. </font><font style="vertical-align: inherit;">Es ist besser, wenn die Datei die Schnittstelle "Suchbarer Stream" und die XML-Methode implementiert, um sie zu verwenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Prinzip ist besonders eng mit der objektorientierten Programmierung verbunden, bei der Schnittstellen, Hierarchien und abstrakte Typen verwendet werden, um Verbindungen zwischen Komponenten zu minimieren. </font><font style="vertical-align: inherit;">Dieses Prinzip erzwingt die Verwendung der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ententypisierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , einer Methode, die explizite Schnittstellen eliminiert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prinzip der Abhängigkeitsinversion</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Module der oberen Ebene sollten nicht von Modulen der unteren Ebene abhängen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fünftel der Prinzipien von SOLID. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Prinzip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besagt, dass Steuerungskomponenten höherer Ebenen die Details der Implementierung ihrer Abhängigkeiten nicht kennen sollten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel haben wir ein Programm, das Metadaten von einer Website liest. Vermutlich sollte die Hauptkomponente eine Komponente kennen, die den Inhalt einer Webseite herunterlädt, und eine Komponente, die Metadaten liest. Wenn wir das Prinzip der Abhängigkeitsinversion berücksichtigen, hängt die Hauptkomponente nur von der abstrakten Komponente ab, die Bytedaten empfängt, und wiederum von der abstrakten Komponente, die Metadaten aus dem Bytestrom lesen kann. Die Hauptkomponente weiß nichts über TCP / IP, HTTP, HTML usw.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Prinzip ist ziemlich kompliziert, da es die erwartete Abhängigkeit im System umkehrt. </font><font style="vertical-align: inherit;">In der Praxis bedeutet dies auch, dass eine separate Steuerungskomponente die korrekte Implementierung abstrakter Typen gewährleisten muss (im vorherigen Beispiel muss der Metadatenleser der Komponente zum Herunterladen der Datei über HTTP und zum Lesen von Daten aus dem Meta-HTML-Tag bereitgestellt werden).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederholen Sie sich nicht Prinzip</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes Wissen sollte eine eindeutige, konsistente und maßgebliche Darstellung innerhalb des Systems haben.</font></font></blockquote><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederholen Sie sich nicht</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder DRY hilft Entwicklern dabei, die Wiederholbarkeit von Code zu verringern und Informationen an einem Ort zu speichern. </font><font style="vertical-align: inherit;">Es wurde 1999 von Andy Hunt und Dave Thomas in ihrem Buch Pragmatic Programmer erwähnt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Gegenteil des DRY-Prinzips </font><font style="vertical-align: inherit;">trocken] sollte das Prinzip von WET sein </font><font style="vertical-align: inherit;">nass] - "Schreibe alles zweimal" oder "Wir tippen gerne" [Wir tippen gerne]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn in der Praxis dieselben Informationen an zwei oder mehr Stellen in Ihnen dupliziert werden, verwenden Sie das DRY-Prinzip, indem Sie sie an einer Stelle zusammenführen und bei Bedarf wiederverwenden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KISS-Prinzip</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halte es einfach, dumm [Nicht komplizieren, Dummkopf]</font></font></blockquote><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das KISS-Prinzip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besagt, dass die meisten Systeme besser funktionieren, wenn sie nicht kompliziert sind. </font><font style="vertical-align: inherit;">Daher sollte Einfachheit ein zentrales Ziel bei der Entwicklung sein und unnötige Komplexität sollte vermieden werden. </font><font style="vertical-align: inherit;">Es entstand 1960 in der US-Marine und wird dem Flugzeugdesigner Clarence Johnson zugeschrieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist am besten, sich dies anhand eines Beispiels vorzustellen, als Johnson einem Team von Konstrukteuren einen kleinen Satz Werkzeuge gab und sie anwies, ein Flugzeug so zu entwerfen, dass ein durchschnittlicher Mechaniker es nur mit diesem Satz auf einem Schlachtfeld reparieren konnte. </font><font style="vertical-align: inherit;">Dumm bezeichnet hier eher die Beziehung zwischen dem Zusammenbruch der Dinge und der Komplexität der Werkzeuge, die zur Reparatur zur Verfügung stehen, als die mentalen Fähigkeiten der Ingenieure.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YAGNI</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akronym für "Du wirst es nicht brauchen" [du wirst es nicht brauchen].</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementieren Sie Funktionen immer nur dann, wenn Sie sie wirklich benötigen, und nicht, wenn Sie glauben, dass Sie sie in Zukunft benötigen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Autor von Extreme Programming (XP) und das Buch „Installed Extreme Programming“, Ron Jeffries </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schlagen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">vor,</font></a><font style="vertical-align: inherit;"> dass Entwickler nur die Funktionen implementieren sollten, die gerade benötigt werden, und nicht versuchen sollten, die Zukunft vorherzusagen, sondern die Funktionen implementieren sollten, die später möglicherweise benötigt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Befolgen dieses Prinzips sollte die Menge an nicht verwendetem Code in der Datenbank sowie die Zeit- und Energieverschwendung für Funktionen reduzieren, die keine Vorteile bringen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Missverständnisse des verteilten Rechnens</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auch als Irrtum des Netzwerk-Computing bekannt. </font><font style="vertical-align: inherit;">Dies ist eine Liste von Annahmen in Bezug auf verteiltes Rechnen, die zu Softwarefehlern führen können. </font><font style="vertical-align: inherit;">Dies sind die folgenden Annahmen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Netzwerk ist zuverlässig.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verzögerung ist Null.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bandbreite ist endlos.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Netzwerk ist sicher.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Topologie ändert sich nicht.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt nur einen Administrator.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Versandkosten sind Null.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Netzwerk ist homogen.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten vier wurden 1991 von Bill Joy und Tom Lyon aufgelistet, und James Gosling klassifizierte sie zuerst als "Network Computing Misconceptions". </font><font style="vertical-align: inherit;">Peter Deutsch fügte die 5., 6. und 7. Täuschung hinzu. </font><font style="vertical-align: inherit;">In den späten 90ern fügte Gosling den 8. hinzu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Gruppe von Ingenieuren ließ sich von den damaligen Prozessen bei Sun Microsystems inspirieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Fehler sollten bei der Entwicklung zuverlässigen Codes sorgfältig berücksichtigt werden. </font><font style="vertical-align: inherit;">Jeder der Fehler kann zu einer falschen Logik führen, die die Realität und Komplexität verteilter Systeme nicht bewältigen kann.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de491934/index.html">Psychologische Profile von Aktieninvestoren: wie es funktioniert</a></li>
<li><a href="../de491936/index.html">Wie sich Bakterien von Eisen ernähren und hochwertige Pigmente aus künstlichen Deponien entfernen</a></li>
<li><a href="../de491938/index.html">5 Game Designer Tools, die Ihrem Spiel helfen</a></li>
<li><a href="../de491942/index.html">Wie wir item2vec verwenden, um ähnliche Produkte zu empfehlen</a></li>
<li><a href="../de491944/index.html">So kombinieren Sie zwei Plattformen zu einer und beleidigen Benutzer nicht. Yandex.Kew Entwicklererfahrung</a></li>
<li><a href="../de491948/index.html">Design-Token können mehr: Sie können eine einzige Informationsquelle über UI-Komponenten erstellen</a></li>
<li><a href="../de491956/index.html">Rust 1.42.0 Release: Slice-Vorlagen und bequemere Panikmeldungen</a></li>
<li><a href="../de491958/index.html">Handbuch zur Komprimierung von Skelettanimationen</a></li>
<li><a href="../de491960/index.html">Ära, in der es schwer ist, sich zu verlaufen</a></li>
<li><a href="../de491962/index.html">VPN-Killer. Richtiger Fernzugriff auf Kampfserver</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>