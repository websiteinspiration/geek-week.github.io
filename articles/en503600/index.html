<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîû üêÑ ‚ôøÔ∏è STM32MP1: U-Boot, Buildroot, Arch Linux and a little Debian üï∏Ô∏è üåò üíÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! 
 
 Some time ago, STMicroelectronics released interesting STM32MP1 series processors. When I finally got my hands on the debug board bas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>STM32MP1: U-Boot, Buildroot, Arch Linux and a little Debian</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503600/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Some time ago, STMicroelectronics released interesting STM32MP1 series processors. </font><font style="vertical-align: inherit;">When I finally got my hands on the debug board based on this processor, I was surprised to find that it lacks any builds based on popular distributions (Debian, Arch Linux, etc.). </font><font style="vertical-align: inherit;">All that remained was to try to adapt some distribution kit for this board yourself. </font><font style="vertical-align: inherit;">Based on the results of this, this article appeared.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ws/zo/9c/wszo9cao_bq-m_5z9q9fk8moxls.jpeg"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What are the characteristics?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This article would not be complete without at least a brief overview of the characteristics of the STM32MP1 series processors. </font><font style="vertical-align: inherit;">There are three families of processors in the STM32MP1 series: STM32MP151, STM32MP153, and STM32MP157. </font><font style="vertical-align: inherit;">Their main characteristics are given in the table. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rf/ez/9u/rfez9ud26bcli38_4juxyx-byya.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see from the table, the difference between the families is that STM32MP151 has one Cortex-A7 core, while STM32MP153 and STM32MP157 have two such cores, and STM32MP157 also has 3D GPU support. </font><font style="vertical-align: inherit;">But in general, the characteristics of these processors in 2020 do not make any impression, they are rather modest. </font><font style="vertical-align: inherit;">Why did I still pay attention to them?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why STM32MP1?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Indeed, a completely logical question may arise: is there a Raspberry Pi, there is a Banana Pi, there is an Orange Pi, and finally - why do we need some other STM32MP1? </font><font style="vertical-align: inherit;">Moreover, all these boards usually have significantly higher performance than the object of our study. </font><font style="vertical-align: inherit;">The answer is simple - while you are doing any crafts for home use, it is, you need to take the raspberry and it will be right. </font><font style="vertical-align: inherit;">But if we are talking about mass-produced products for industrial applications - here other things begin to play a decisive role, thanks to which the STM32MP1 is the winner:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operating temperature range. </font><font style="vertical-align: inherit;">For STM32MP1, it starts at minus 40 degrees, while for many processors of other single-board computers it is good if it is minus 20.</font></font></li>
<li>  .  STMicroelectronics      ,            .</li>
<li>      .   DigiKey  Mouser       STM32MP1,           .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, ST32MP1 is not the only processor on the market for industrial applications. </font><font style="vertical-align: inherit;">There are both NXP and TI. </font><font style="vertical-align: inherit;">As for TI, I had a project of a rather complex module based on it, and there was a sediment from a noticeable number of hardware features that were not covered in the documentation, but if not respected, the processor could completely fail, and not immediately, but over time and at the most inopportune moment. </font><font style="vertical-align: inherit;">In addition, it was a single-core processor, and with an increase in the number of tasks assigned to it, performance problems more and more often arose. </font><font style="vertical-align: inherit;">At the same time, I was dealing with STMicroelectronics microcontrollers, and they proved to be quite good, so I decided to try to pick this new little one.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug board</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For experiments, I purchased a STM32MP157A-DK1 debug board. </font><font style="vertical-align: inherit;">This board is rather modest in terms of equipment: it does not have an LCD display like the STM32MP157C-DK2 or such a rich peripheral as the STM32MP157A-EV1. </font><font style="vertical-align: inherit;">However, there is a microSD card slot, a USB-UART console, several USB ports and Ethernet. </font><font style="vertical-align: inherit;">For the first start, more than enough. </font><font style="vertical-align: inherit;">And to dilute the dry story with a picture, I am attaching a photo of this debug board.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jq/o9/ta/jqo9tap0mu2icbhbofhdjoocquk.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is from ready-made software?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At STMicroelectronics, everything is usually quite good in terms of hardware, but terrible in terms of software. All these modifications of Atollic True Studio, CubeMX, CubeIDE, which are buggy more and more with each new release, evoke some anguish. The situation is slightly better with STM32MP1 support. STMicroelectronics offers only a certain assembly of OpenSTLinux. This assembly is a distribution built using the Yocto Project. Of course, all this can exist in this form, but for me the main drawback was the lack of access to repositories of well-known distributions. This means that you will not be able to put on your board any utility from the repositories of popular distributions simply by running a command like apt-get install. Often this is not required for embedded solutions, but situations are possible,when such an opportunity will definitely not be superfluous.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What do we do?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, the task is clear - we need to run some popular distribution on our debug board. </font><font style="vertical-align: inherit;">My choice fell on Arch Linux. </font><font style="vertical-align: inherit;">This is not the easiest distribution, but it is well adapted for ARM devices: there are ready-made assemblies and an official </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dedicated to this. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first thing I tried to solve the problem with a snap - I just slipped the bootloader ready core from the distribution of Arch Linux, assembled under armv7. </font><font style="vertical-align: inherit;">This sometimes worked on other boards, but there was a fiasco waiting for me: despite the fact that the kernel was assembled for the correct architecture, it did not start. </font><font style="vertical-align: inherit;">Well, then you need to assemble your kernel and at the same time your loader. </font><font style="vertical-align: inherit;">My action plan was this:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Build the U-Boot bootloader.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Build the Linux kernel. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We mark the microSD card.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We write the bootloader, the kernel and the root file system to the microSD card.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Profit</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembly preparation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To implement this plan, we need a computer with Linux and a card reader for recording on a microSD-card. </font><font style="vertical-align: inherit;">I used a laptop with Debian 10, but in general this is not important, the names of the utilities may only slightly differ. </font><font style="vertical-align: inherit;">So, we put the required utilities. </font><font style="vertical-align: inherit;">I note right away that now and further all the commands must be executed as root or through sudo.</font></font><br>
<br>
<pre><code class="cpp hljs">apt-get install git<font></font>
apt-get install make<font></font>
apt-get install gcc<font></font>
apt-get install gcc-arm-linux-gnueabihf<font></font>
apt-get install bison<font></font>
apt-get install flex<font></font>
apt-get install g++<font></font>
apt-get install rsync<font></font>
apt-get install libncurses-dev</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In preparation for the assembly, we create three directories in the working directory: u-boot (for the bootloader), buildroot (for the system build) and archlinux (for the distribution):</font></font><br>
<br>
<pre><code class="cpp hljs">mkdir u-boot<font></font>
mkdir buildroot<font></font>
mkdir archlinux</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will need these directories further. </font><font style="vertical-align: inherit;">I will refer to these names later in the text of the article.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U-boot assembly</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A lot of articles have already been written about U-Boot, and as part of this, I will not go deep with explanations of what it is, what it is for, and how it works. I can only say that this is a bootloader that provides Linux startup on ARM devices. The source code for the U-Boot bootloader is available on GitHub. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to build U-Boot, first of all we clone the U-Boot repository into the u-boot directory that we created earlier:</font></font><br>
<br>
<pre><code class="cpp hljs">git clone https:<span class="hljs-comment">//github.com/u-boot/u-boot</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To successfully build U-Boot, we need a device tree file and a U-Boot configuration file. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The device tree file is a device dependent file. This file describes the configuration of the processor for a specific board. If you make your hardware based on any ARM processor and plan to run Linux on it, then you will need to develop your device tree file for it (or adapt some ready-made one). However, many debug boards already have ready-made files: caring U-Boot developers include them in their repository. So, look at the u-boot / arch / arm / dts directory. It should contain the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp157a-dk1.dtb file</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - this is the device tree file for our debug board.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the U-Boot configuration file, the basic bootloader settings are written. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Configuring U-Boot from scratch is a rather long and laborious process, because there are so many settings. </font><font style="vertical-align: inherit;">For these purposes, there are both console and graphical configurators. </font><font style="vertical-align: inherit;">However, here we were lucky: in the u-boot / configs directory there is a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp15_basic_defconfig</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is the U-Boot basic configuration file for the STM32MP15 debug boards. </font><font style="vertical-align: inherit;">We open this file and see that for us to quickly start it is enough to change only one line: instead</font></font><br>
<br>
<pre><code class="cpp hljs">CONFIG_DEFAULT_DEVICE_TREE=‚Äùstm32mp157c-ev1‚Äù</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
write</font></font><br>
<br>
<pre><code class="cpp hljs">CONFIG_DEFAULT_DEVICE_TREE=‚Äùstm32mp157a-dk1‚Äù</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With this line, we tell the bootloader that we need to use the device tree file for our board. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now you are ready to build U-Boot. </font><font style="vertical-align: inherit;">We use our config:</font></font><br>
<br>
<pre><code class="cpp hljs">make CROSS_COMPILE=arm-linux-gnueabihf- stm32mp15_basic_defconfig</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And run the assembly:</font></font><br>
<br>
<pre><code class="cpp hljs">make CROSS_COMPILE=arm-linux-gnueabihf-</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If everything went smoothly, then in the u-boot directory we should have a bunch of files. </font><font style="vertical-align: inherit;">Of these, two are of interest to us: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot-spl.stm32</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot.img</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first file is the so-called First Stage Boot Loader (FSBL). </font><font style="vertical-align: inherit;">It is located in front of the U-Boot, starts first and initializes the DDR3 memory, which is necessary to start U-Boot. </font><font style="vertical-align: inherit;">In other boards, FSBL is often combined with U-Boot into one image, but here you have to write each image to a USB flash drive separately. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's all with U-Boot for now, save the designated files and proceed directly to the Linux kernel assembly.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux kernel assembly</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will use Buildroot to build the Linux kernel. Of course, for these purposes, you can use the equally popular Yocto, or even try to build the kernel from source from kernel.org. However, I had some experience working with Buildroot, so I decided on it. In addition, Buildroot also builds the root file system (rootfs) and even the U-Boot loader. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, by any available means, download the archive from Buildroot from the official </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">website</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , unpack it into the buildroot directory and go to it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As in the case of U-Boot, the first thing you need to take care of is the configuration file for our hardware. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We go to the buildroot / configs directory and see that the developers have already added a configuration file for our board: there is a file</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp157a_dk1_defconfig</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (true for Buildroot-2020.05 build, in earlier versions of this file there wasn‚Äôt yet). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I tried to build the 5.4.26 kernel using this configuration file, and it generally successfully started on my board. However, for some reason, the Linux device tree file in this assembly turned out to be truncated: by default there was not even support for USB ports. Let's hope that over time this bug will be fixed, but what to do now?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I went google this problem and came across STMicroelectronics repositories, where I found Linux 4.19 sources with patches for their products. </font><font style="vertical-align: inherit;">Including, the correct DTB files were also there. </font><font style="vertical-align: inherit;">It remains only to tell Buildroot to use this repository when building the kernel. </font><font style="vertical-align: inherit;">To do this, copy the stm32mp157a_dk1_defconfig file and rename it to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp157a_dk1_new_defconfig</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Open it and make the following changes: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Instead</font></font><br>
<br>
<pre><code class="cpp hljs">BR2_PACKAGE_HOST_LINUX_HEADERS_CUSTOM_5_4=y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We write </font></font><br>
<br>
<pre><code class="cpp hljs">BR2_PACKAGE_HOST_LINUX_HEADERS_CUSTOM_4_19=y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Instead </font></font><br>
<br>
<pre><code class="cpp hljs">BR2_LINUX_KERNEL_CUSTOM_VERSION=y<font></font>
BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE=<span class="hljs-string">"5.4.26"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We write</font></font><br>
<br>
<pre><code class="cpp hljs">BR2_LINUX_KERNEL_CUSTOM_TARBALL=y<font></font>
BR2_LINUX_KERNEL_CUSTOM_TARBALL_LOCATION=<span class="hljs-string">"$(call github,STMicroelectronics,linux,v4.19-stm32mp-r1.2)/linux-v4.19-stm32mp-r1.2.tar.gz"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Save and close the file. </font><font style="vertical-align: inherit;">The configuration file is ready, let's apply it (you need to execute it from the buildroot directory):</font></font><br>
<br>
<pre><code class="cpp hljs">make CROSS_COMPILE=arm-linux-gnueabihf- stm32mp157a_dk1_new_defconfig</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This command will transfer information from our configuration file stm32mp157a_dk1_defconfig to the .config file, which is located in the buildroot directory. In the future, the assembly will be built on the basis of the .config file. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, now everything is almost ready to start the build process, but before that you need to configure our kernel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here it is worth saying that by default minimal functionality will be included in the kernel. If we want to expand it, then the kernel will need to be configured for ourselves. At a minimum, you will need to add support for the Control Group to the kernel: without this, our Arch Linux will not start. Additionally, as an example, I will demonstrate how to add support for USB-flash drives to the kernel: as a result, our debug board will be able to work with flash drives.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To start the kernel configurator from the buildroot directory, execute the command</font></font><br>
<br>
<pre><code class="cpp hljs">make linux-menuconfig</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
and go to drink tea. </font><font style="vertical-align: inherit;">This process is not fast and depending on the power of your computer can take from fifteen minutes to several hours. </font><font style="vertical-align: inherit;">Important: during the work of buildroot you need a stable connection to the Internet, many different packages will be downloaded. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If in the process an error pops up</font></font><br>
<br>
<pre><code class="cpp hljs">configure: error: <span class="hljs-function">you should <span class="hljs-keyword">not</span> run configure as <span class="hljs-title">root</span> <span class="hljs-params">(<span class="hljs-built_in">set</span> FORCE_UNSAFE_CONFIGURE=<span class="hljs-number">1</span> in environment to bypass <span class="hljs-keyword">this</span> check)</span>
See `config.<span class="hljs-built_in">log</span>' <span class="hljs-keyword">for</span> more details</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
will need to execute the command</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">export</span> FORCE_UNSAFE_CONFIGURE=<span class="hljs-number">1</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
and restart the kernel configurator. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, the configurator window should appear: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xs/ah/h7/xsahh7p0h-ee5ly4sz54vvg1gcc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Add Control Group support: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">General setup -&gt; Control Group support</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and set the asterisk with a space:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/x-/hu/lm/x-hulmm3zia2p1azslxcwuszfto.jpeg"><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And how to add flash drive support?</font></font></b>
                        <div class="spoiler_text">  SCSI .     80- ,  , ,     USB FLASH .   <b>Device Drivers -&gt; SCSI support</b>       :<br>
<br>
<img src="https://habrastorage.org/webt/kh/59/mq/kh59mqwq_7lppvsozcmqzq4pp94.jpeg"><br>
<br>
     USB FLASH .   <b>Device Drivers -&gt; USB support</b>    <b>USB Mass Storage support</b>:<br>
<br>
<img src="https://habrastorage.org/webt/ar/uu/qy/aruuqyuuanaakzw8mm1givi6yua.jpeg"><br>
<br>
,     FLASH     : <b>File systems -&gt; Native language support -&gt; Codepage 437</b>  <b>File systems -&gt; Native language support -&gt; NLS ISO 8859-1:</b><br>
<br>
<img src="https://habrastorage.org/webt/n2/mt/_x/n2mt_x_utdbu9zdr1dxcugqmaoy.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/0o/sy/f8/0osyf81e1zk8m8fyic9rhhh4yw0.jpeg"><br>
<br>
   ,  USB FLASH      . <br>
</div>
                    </div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After all the settings in the kernel configurator are made, save them with the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Save</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> button </font><font style="vertical-align: inherit;">and exit the configurator with the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> button </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now it remains only to start the build process with the command:</font></font><br>
<br>
<pre><code class="cpp hljs">make CROSS_COMPILE=arm-linux-gnueabihf-</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
and you can go to drink tea a second time, this process also takes a lot of time. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If everything went smoothly, then the following set of files should appear in the buildroot / output / images directory:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rootfs.ext2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a compiled root file system with ext2. </font><font style="vertical-align: inherit;">It is not of interest to us;</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rootfs.ext4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a compiled root file system with ext4. </font><font style="vertical-align: inherit;">It will be useful to us a little later;</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdcard.img</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - An image of a microSD card, including FSBL + U-Boot + zImage + rootfs. </font><font style="vertical-align: inherit;">A file for the lazy, it allows you not to bother marking up a microSD card and immediately upload the entire system to it. </font><font style="vertical-align: inherit;">Of course, this is not our way :).</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp157a-dk1.dtb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - device tree file. </font><font style="vertical-align: inherit;">Be sure to come in handy for starting the system;</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot.img</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot-spl.stm32</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - file FSBL and U-Boot. </font><font style="vertical-align: inherit;">Since we collected them at the last step, we do not need them;</font></font><br>
 <div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why did we collect them separately?</font></font></b>
                        <div class="spoiler_text"> , Buildroot             U-Boot.    ,       .                 U-Boot,        ‚Äì     Linux.<br>
 </div>
                    </div></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zImage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the heart of the entire system - a compressed Linux kernel file.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, the assembly process is completed, now we proceed to marking the microSD-memory card and creating partitions on it.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partitioning and sections of a microSD-card</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Marking a microSD-card and creating partitions is a very important stage, strongly tied to a specific hardware platform. Unfortunately, information on this issue on a specific processor is not always easy to find, and even if you collect fully functional U-Boot and the Linux kernel, none of this will work with the slightest error in the layout of the microSD card. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Immediately, I note that the microSD card with which the system is launched on the STM32MP1 must have GPT markup. The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gdisk</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utility will help us with this </font><font style="vertical-align: inherit;">, but more on that later. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The microSD card sections should look like this:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xs/-l/rr/xs-lrrpr3mi-vrdqemol2sy8szg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see from the figure, the card must contain at least 5 partitions: fsbl1, fsbl2, ssbl, kernel, rootfs. </font><font style="vertical-align: inherit;">Additionally, you can also create one or more data sections to store any information on them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fsbl1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fsbl2 sections</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are completely identical and the primary bootloader is written to them (as you remember, this is the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot-spl.stm32 file</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that we received during the U-Boot assembly process). </font><font style="vertical-align: inherit;">Despite the fact that everything should work and with only one such section, the documentation on STM2MP1 recommends doing two of them. </font><font style="vertical-align: inherit;">Other requirements apply to these sections:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each partition must be 256 KB in size.</font></font></li>
<li>    ,      <b>fsbl</b> (fsbl1  fsbl2).   :          ,     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ssbl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> section </font><b><font style="vertical-align: inherit;">is</font></b><font style="vertical-align: inherit;"> intended for writing the U-Boot bootloader (the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot.img file</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that we received during the U-Boot assembly process). The recommended ssbl partition size is 2 MB. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kernel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> section is </font><font style="vertical-align: inherit;">intended for writing to it the Linux kernel ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zImage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file </font><font style="vertical-align: inherit;">), the device tree ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp157a-dk1.dtb file</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), as well as the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">script</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for U-Boot, with which the system will be launched. The recommended kernel partition size is 64 MB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rootfs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> section </font><font style="vertical-align: inherit;">is for writing the root file system. We will try to write to it the root file system compiled by Buildroot, as well as the root file system of Arch Linux. The recommended rootfs partition size is 1 GB or more.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The data section is intended for storing user data. </font><font style="vertical-align: inherit;">You can make one such section or several. </font><font style="vertical-align: inherit;">And you can do without it at all. </font><font style="vertical-align: inherit;">In this article, I will not create this section. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we begin to markup. </font><font style="vertical-align: inherit;">We insert the microSD-card into the card reader of our computer with Linux on board and using any available means (for example, using dmesg) determine the name of the device that appears. </font><font style="vertical-align: inherit;">In my case, this is / dev / sdb. </font><font style="vertical-align: inherit;">In your case, it may be a different name. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Run the gdisk utility and completely delete the markup on the microSD card:</font></font><br>
<br>
<pre><code class="cpp hljs">root@debian:/home/myuser<span class="hljs-meta"># gdisk /dev/sdb</span>
<span class="hljs-function">GPT <span class="hljs-title">fdisk</span> <span class="hljs-params">(gdisk)</span> version 1.0.3
Partition table scan:
  MBR: protective
  BSD: <span class="hljs-keyword">not</span> present
  APM: <span class="hljs-keyword">not</span> present
  GPT: present
Found valid GPT with protective MBR</span>; <span class="hljs-keyword">using</span> GPT.<font></font>
Command (? <span class="hljs-keyword">for</span> help): <span class="hljs-function">x
Expert <span class="hljs-title">command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: z
About to wipe out GPT on /dev/sdb. Proceed? <span class="hljs-params">(Y/N)</span>: y
GPT data structures destroyed! You may now partition the disk <span class="hljs-keyword">using</span> fdisk <span class="hljs-keyword">or</span>
other utilities.
Blank out MBR? <span class="hljs-params">(Y/N)</span>: y</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Just in case, we hammer the beginning of the microSD card with zeros. </font></font><br>
<br>
<pre><code class="cpp hljs">dd <span class="hljs-keyword">if</span>=/dev/zero of=/dev/sdb bs=<span class="hljs-number">1</span>M count=<span class="hljs-number">64</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now run gdisk again, add the markup and create 5 partitions on the microSD card according to the table that I gave above:</font></font><br>
<br>
<pre><code class="cpp hljs">root@debian:/home/myuser<span class="hljs-meta"># gdisk /dev/sdb</span>
<span class="hljs-function">GPT <span class="hljs-title">fdisk</span> <span class="hljs-params">(gdisk)</span> version 1.0.3

Partition table scan:
  MBR: <span class="hljs-keyword">not</span> present
  BSD: <span class="hljs-keyword">not</span> present
  APM: <span class="hljs-keyword">not</span> present
  GPT: <span class="hljs-keyword">not</span> present

Creating <span class="hljs-keyword">new</span> GPT entries.

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: o
This option deletes all partitions <span class="hljs-keyword">and</span> creates a <span class="hljs-keyword">new</span> protective MBR.
Proceed? <span class="hljs-params">(Y/N)</span>: y

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>)</span>: 1
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">2048</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">2048</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: +<span class="hljs-number">256</span>K<font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">2</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">2</span>)</span>: 2
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">4096</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">4096</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: +<span class="hljs-number">256</span>K<font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">3</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">3</span>)</span>: 3
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">6144</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">6144</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: +<span class="hljs-number">2</span>M<font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">4</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">4</span>)</span>: 4
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">10240</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">10240</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: +<span class="hljs-number">64</span>M<font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">5</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">5</span>)</span>: 5
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">141312</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">141312</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: <font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? <span class="hljs-params">(Y/N)</span>: y
OK</span>; <span class="hljs-function">writing <span class="hljs-keyword">new</span> GUID partition <span class="hljs-title">table</span> <span class="hljs-params">(GPT)</span> to /dev/sdb.
The operation has completed successfully.</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, add the names to the sections on the microSD-card. </font><font style="vertical-align: inherit;">As you remember, this is especially critical for the first sections where FSBL will be written: if you do not assign the required names to them, the system will not start:</font></font><br>
<br>
<pre><code class="cpp hljs">root@debian:/home/myuser<span class="hljs-meta"># gdisk /dev/sdb</span>
<span class="hljs-function">GPT <span class="hljs-title">fdisk</span> <span class="hljs-params">(gdisk)</span> version 1.0.3

Partition table scan:
  MBR: protective
  BSD: <span class="hljs-keyword">not</span> present
  APM: <span class="hljs-keyword">not</span> present
  GPT: present

Found valid GPT with protective MBR</span>; <span class="hljs-keyword">using</span> GPT.<font></font>
<font></font>
Command (? <span class="hljs-keyword">for</span> help): <span class="hljs-function">c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 1
Enter name: fsbl1

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 2
Enter name: fsbl2

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 3
Enter name: ssbl

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 4
Enter name: kernel

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 5
Enter name: roootfs

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? <span class="hljs-params">(Y/N)</span>: y
OK</span>; <span class="hljs-function">writing <span class="hljs-keyword">new</span> GUID partition <span class="hljs-title">table</span> <span class="hljs-params">(GPT)</span> to /dev/sdb.
The operation has completed successfully.</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the end of work with the microSD-card, we need to add the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">legacy BIOS bootable attribute</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to the section on which we will write the Linux kernel. </font><font style="vertical-align: inherit;">Without this attribute, the kernel refused to start:</font></font><br>
<br>
<pre><code class="cpp hljs">root@debian:/home/myuser<span class="hljs-meta"># gdisk /dev/sdb</span>
<span class="hljs-function">GPT <span class="hljs-title">fdisk</span> <span class="hljs-params">(gdisk)</span> version 1.0.3

Partition table scan:
  MBR: protective
  BSD: <span class="hljs-keyword">not</span> present
  APM: <span class="hljs-keyword">not</span> present
  GPT: present

Found valid GPT with protective MBR</span>; <span class="hljs-keyword">using</span> GPT.<font></font>
<font></font>
Command (? <span class="hljs-keyword">for</span> help): <span class="hljs-function">x

Expert <span class="hljs-title">command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: a
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 4
Known attributes are:
0: system partition
1: hide from EFI
2: legacy BIOS bootable
60: read-only
62: hidden
63: <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> automount

Attribute value is 0000000000000000. Set fields are:
  No fields <span class="hljs-built_in">set</span>

Toggle which attribute <span class="hljs-title">field</span> <span class="hljs-params">(<span class="hljs-number">0</span><span class="hljs-number">-63</span>, <span class="hljs-number">64</span> <span class="hljs-keyword">or</span> &lt;Enter&gt; to <span class="hljs-built_in">exit</span>)</span>: 2
Have enabled the 'legacy BIOS bootable' attribute.
Attribute value is 0000000000000004. Set fields are:
2 <span class="hljs-params">(legacy BIOS bootable)</span>

Toggle which attribute <span class="hljs-title">field</span> <span class="hljs-params">(<span class="hljs-number">0</span><span class="hljs-number">-63</span>, <span class="hljs-number">64</span> <span class="hljs-keyword">or</span> &lt;Enter&gt; to <span class="hljs-built_in">exit</span>)</span>: 

Expert <span class="hljs-title">command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? <span class="hljs-params">(Y/N)</span>: y
OK</span>; <span class="hljs-function">writing <span class="hljs-keyword">new</span> GUID partition <span class="hljs-title">table</span> <span class="hljs-params">(GPT)</span> to /dev/sdb.
The operation has completed successfully.</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's all, the layout of the memory card is ready. </font><font style="vertical-align: inherit;">Just in case, check that everything is recorded as it should. </font><font style="vertical-align: inherit;">To do this, run </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gdisk</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> again </font><font style="vertical-align: inherit;">and run the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The result should advise the picture: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q9/ko/ff/q9koffmcelcxpna_qtwtfkdlzz8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now create the ext4 file system on / dev / sdb4 and / dev / sdb5:</font></font><br>
<br>
<pre><code class="cpp hljs">mkfs.ext4 /dev/sdb4<font></font>
mkfs.ext4 /dev/sdb5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And we prescribe volume labels so that later it is easier to access them:</font></font><br>
<br>
<pre><code class="cpp hljs">e2label /dev/sdb4 kernel<font></font>
e2label /dev/sdb5 rootfs</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This completes the creation of sections of the memory card, you can proceed to write files to it.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroSD card recording</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, at the current stage, everything is ready for recording on a microSD card. </font><font style="vertical-align: inherit;">We insert it into the card reader of the Linux computer and write the primary bootloader (FSBL) in the first and second sections of the mocroSD card:</font></font><br>
<br>
<pre><code class="cpp hljs">dd <span class="hljs-keyword">if</span>=u-boot/u-boot-spl.stm32 of=/dev/sdb1<font></font>
dd <span class="hljs-keyword">if</span>=u-boot/u-boot-spl.stm32 of=/dev/sdb2</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now write U-Boot to the third section of the microSD card:</font></font><br>
<br>
<pre><code class="cpp hljs">dd <span class="hljs-keyword">if</span>=u-boot/u-boot.img of=/dev/sdb3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, you need to copy the kernel, the device tree file and the boot script to the fourth section on the microSD-card. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before you start copying files, you need a little explanation about the download script. In this script, in fact, various information for U-Boot is indicated, with the help of which it can boot the system and transfer control to the kernel. There are different ways to write these scripts, but the simplest (in my opinion) is described in the documentation for STM32MP1: you need to create the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ extlinux</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> directory in the root of the kernel section </font><font style="vertical-align: inherit;">and create a text file with the name </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extlinux.conf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with the following contents:</font></font><br>
<br>
<pre><code class="cpp hljs">LABEL stm32mp157a-dk1<font></font>
KERNEL /zImage<font></font>
FDT /stm32mp157a-dk1.dtb<font></font>
APPEND root=/dev/mmcblk0p5 rootwait rw console=ttySTM0,<span class="hljs-number">115200</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything is quite simple here: we tell the loader where to get the kernel, the device tree, the root file system and say that we will have the ttySTM0 port as the working console. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now copy the kernel:</font></font><br>
<br>
<pre><code class="cpp hljs">cp -a buildroot/output/images/zImage /media/myuser/kernel/</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note: in the / media / myuser / directory, I mount a microSD card when installed in the card reader. </font><font style="vertical-align: inherit;">In your case, it may be a different directory. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Copy the device tree file:</font></font><br>
<br>
<pre><code class="cpp hljs">cp -a buildroot/output/images/stm32mp157a-dk1.dtb /media/myuser/kernel/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Create a directory:</font></font><br>
<br>
<pre><code class="cpp hljs">mkdir /media/myuser/kernel/extlinux</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Create a file:</font></font><br>
<br>
<pre><code class="cpp hljs">nano /media/myuser/kernel/extlinux/extlinux.conf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
and fill it with the contents:</font></font><br>
<br>
<pre><code class="cpp hljs">LABEL stm32mp157a-dk1<font></font>
KERNEL /zImage<font></font>
FDT /stm32mp157a-dk1.dtb<font></font>
APPEND root=/dev/mmcblk0p5 rootwait rw console=ttySTM0,<span class="hljs-number">115200</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Save the file and close the editor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On this, the fourth section of the microSD card is ready: the linux kernel and all the auxiliary files for it are already written. </font><font style="vertical-align: inherit;">Already at this stage, if you insert a microSD-card into the debug board, the Linux kernel should be loaded, however, in the end it will crash into kernel panic due to the fact that the root file system cannot be mounted. </font><font style="vertical-align: inherit;">This is not surprising, because we have recorded it so far. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is the final stage, at which we will write the root file system to the microSD-card. </font><font style="vertical-align: inherit;">And here various options are possible:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Write the root file system generated by Buildroot</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rewrite the Arch Linux root file system</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, write down the root file system that Buildroot generated for us and try to start with it. This was not the purpose of this article, but it seemed to me that in general it might be useful for any applications, especially since this action does not take much time. The root file system is written to the fifth section of our microSD card with just one command:</font></font><br>
<br>
<pre><code class="cpp hljs">dd <span class="hljs-keyword">if</span>=buildroot/output/images/rootfs.ext4 of=/dev/sdb5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now insert the memory card into the debug board and start the system. We will observe the output of debugging information via the USB-UART console: access to it is provided through a microUSB port on the STM32MP157A-DK1 board. Displaying the displayed information is possible in any terminal program, for example Putty or Minicom. For the purposes of this article, I used the latter by opening another terminal window in Debian. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we insert the microSD-card into the debug board, supply power to the board and look at the terminal. If everything was done correctly, then the FSBL, U-Boot, kernel logs should be poured in there and ultimately - an invitation to enter the login will appear. We enter root and - voila - we get to the console of the system we just collected:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1q/hh/sz/1qhhszribllpziacncz6titn6bw.jpeg"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yes, it doesn‚Äôt even have a package manager, and in general the functionality is very poor, but with the help of Buildroot you can build it very cool and create a really working complex system. </font><font style="vertical-align: inherit;">In the meantime, its size is only 7 megabytes! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rq/e7/iv/rqe7iv12mmdleosrwxo8jb-rmj8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After making sure that the homemade root file system starts up successfully, it's time to start Arch Linux. </font><font style="vertical-align: inherit;">Again, insert the microSD-card into the card reader of our computer and format again the fifth section of the memory card:</font></font><br>
<br>
<pre><code class="cpp hljs">mkfs.ext4 /dev/sdb5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Download the archive with Arch Linux, assembled under armv7, from the official site. </font><font style="vertical-align: inherit;">Unpack the archive into the archlinux directory and using the command:</font></font><br>
<br>
<pre><code class="cpp hljs">cp -a archlinux<span class="hljs-comment">/* /media/myuser/rootfs </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Copy it to the rootfs section of the microSD card. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We clean the directory / media / myuser / rootfs / boot: we don‚Äôt need the contents, because the kernel and the device tree are in a separate section of the microSD card:</font></font><br>
<br>
<pre><code class="cpp hljs">rm ‚Äìrf /media/myuser/rootfs/boot<span class="hljs-comment">/*</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Later, you can mount the / dev / sdb4 partition in the boot directory, where we have the kernel image. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After that, insert the microSD card into the debug board, power on and enjoy working ArchLinux: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bj/n8/6i/bjn86iex090rkcggj7v5sz7yayg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After Arch Linux successfully started, I decided to try running Debian on the debug board as well. </font><font style="vertical-align: inherit;">Using absolutely similar manipulations with the root file system, it successfully worked:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8h/kg/1c/8hkg1c82dcu2ruov5fm7rdu-j-i.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the course of this article, we played enough with the STM32MP157A-DK1 debug board: we built U-Boot, the Linux kernel, our own root file system for it, and also launched Arch Linux and Debian. </font><font style="vertical-align: inherit;">I hope this material will be useful to someone both when working with processors of the STM32MP1 family, or with any other single-board on ARM.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">useful links</font></font></b>
                        <div class="spoiler_text"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow">www.st.com/en/microcontrollers-microprocessors/stm32mp1-series.html</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow">wiki.st.com/stm32mpu/wiki/Category</a>:STM32_MPU_microprocessor_devices</div>
                    </div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en503578/index.html">Good programmers copy, great programmers steal</a></li>
<li><a href="../en503580/index.html">What is Big Data?</a></li>
<li><a href="../en503588/index.html">Bill Gates: What You Need to Know About COVID-19 Vaccine</a></li>
<li><a href="../en503594/index.html">Remote observer</a></li>
<li><a href="../en503598/index.html">FOSS News No. 17 - review of free and open source news for May 18-24, 2020</a></li>
<li><a href="../en503604/index.html">Sergey and ‚Äúprogramming is better than sex‚Äù</a></li>
<li><a href="../en503606/index.html">Swift 5.3: What's New?</a></li>
<li><a href="../en503608/index.html">How we searched for virus filters</a></li>
<li><a href="../en503610/index.html">Why not make your own Lisp for the web?</a></li>
<li><a href="../en503612/index.html">Kubernetes best practices. Mapping external services</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>