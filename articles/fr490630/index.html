<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖🏻 👨🏼‍⚖️ 🧑🏾‍🤝‍🧑🏻 Chargement de tableaux NumPy à partir du disque: comparaison de memmap () et Zarr / HDF5 🏙️ 🆙 ♨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si votre tableau NumPy est trop grand pour tenir dans la RAM, vous pouvez le traiter en le divisant en fragments . Vous pouvez le faire en mode transp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Chargement de tableaux NumPy à partir du disque: comparaison de memmap () et Zarr / HDF5</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/490630/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si votre tableau NumPy est trop grand pour tenir dans la RAM, vous pouvez le traiter en le divisant en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fragments</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vous pouvez le faire en mode transparent ou explicitement en chargeant ces fragments à partir du disque un par un. </font><font style="vertical-align: inherit;">
Dans cette situation, vous pouvez recourir à deux classes d'outils:</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/2n/8r/ck/2n8rckf95tnhx1yrkvvlfy2cf_4.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La méthode NumPy </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, un mécanisme transparent qui vous permet de percevoir un fichier situé sur un disque comme s'il était entièrement en mémoire.&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formats de stockage de données Zarr et HDF5 similaires les uns aux autres, qui permettent, si nécessaire, de charger à partir du disque et d'enregistrer des fragments compressés de la matrice sur disque.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chacune de ces méthodes a ses propres forces et faiblesses.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le matériel, dont nous publions la traduction aujourd'hui, est consacré à l'analyse des caractéristiques de ces méthodes de travail avec les données, et à l'histoire des situations dans lesquelles elles peuvent être utiles. </font><font style="vertical-align: inherit;">En particulier, une attention particulière sera accordée aux formats de données qui sont optimisés pour effectuer des calculs et qui ne sont pas nécessairement conçus pour transférer ces données à d'autres programmeurs.</font></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que se passe-t-il lors de la lecture de données à partir d'un disque ou de l'écriture de données sur un disque?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsqu'un fichier est lu sur le disque pour la première fois, le système d'exploitation ne copie pas simplement les données dans la mémoire de processus. </font><font style="vertical-align: inherit;">Tout d'abord, il copie ces données dans sa mémoire, en en stockant une copie dans le soi-disant «cache tampon». </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelle est l'utilité ici? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fait est que le système d'exploitation stocke les données dans le cache au cas où vous auriez besoin de relire les mêmes données à partir du même fichier.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c5/896/e36/8c5896e36f5312d8e00b92103b7d037f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si les données sont relues, elles entrent dans la mémoire du programme non pas à partir du disque, mais à partir de la RAM, ce qui est plus rapide de plusieurs ordres de grandeur.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf3/382/7a3/cf33827a346960cbcc33f54835b9bce3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si la mémoire occupée par le cache est nécessaire pour autre chose, le cache sera automatiquement vidé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque les données sont écrites sur le disque, elles se déplacent dans la direction opposée. </font><font style="vertical-align: inherit;">Au début, ils sont écrits uniquement dans le cache tampon. </font><font style="vertical-align: inherit;">Cela signifie que les opérations d'écriture sont généralement très rapides, car le programme n'a pas besoin de se concentrer sur un disque lent. </font><font style="vertical-align: inherit;">Elle, pendant l'enregistrement, n'a besoin de travailler qu'avec de la RAM.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed3/6be/592/ed36be592685ca4f42954971e000eb89.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, les données sont vidées sur le disque à partir du cache.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffc/0bb/0fc/ffc0bb0fc60c346671dfba89e8c78c1c.png"></div><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation d'un tableau à l'aide de memmap ()</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre cas, </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cela nous permet de percevoir un fichier sur disque comme s'il s'agissait d'un tableau stocké en mémoire. </font><font style="vertical-align: inherit;">Le système d'exploitation, transparent pour le programme, effectue des opérations de lecture / écriture, accédant soit au cache tampon soit au disque dur, selon que les données demandées sont mises en cache ou non en mémoire. </font><font style="vertical-align: inherit;">Un algorithme comme celui-ci est exécuté ici:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les données sont-elles dans le cache? </font><font style="vertical-align: inherit;">Si c'est le cas - génial - vous pouvez les contacter directement.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les données sont-elles sur le disque? </font><font style="vertical-align: inherit;">Leur accès sera plus lent, mais vous n'aurez pas à vous en soucier, ils seront chargés en mode transparent.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme avantage supplémentaire, </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on peut noter que dans la plupart des cas, le cache de tampon pour le fichier sera intégré dans la mémoire du programme. </font><font style="vertical-align: inherit;">Cela signifie que le système n'a pas à conserver une copie supplémentaire des données dans la mémoire du programme en dehors de la mémoire tampon.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47e/922/86e/47e92286e0761142e8f411c84d188e76.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La méthode </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est intégrée à NumPy:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<font></font>
array = np.memmap(<span class="hljs-string">"mydata/myarray.arr"</span>, mode=<span class="hljs-string">"r"</span>,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtype=np.int16, shape=(<span class="hljs-number">1024</span>, <span class="hljs-number">1024</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exécutez ce code et vous aurez à votre disposition un tableau dont le travail sera complètement transparent pour le programme, que le travail soit effectué avec le cache de tampon ou avec le disque dur.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limitations de Memmap ()</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien que dans certaines situations, elle </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puisse se montrer assez bien, cette méthode a également des limites:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les données doivent être stockées dans le système de fichiers. </font><font style="vertical-align: inherit;">Les données ne peuvent pas être téléchargées à partir du stockage binaire comme AWS S3.</font></font></li>
<li>        ,      .   ,       . ,           ,  ,      .</li>
<li>   N-        ,      ,        ,        .         .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Expliquons le dernier point. </font><font style="vertical-align: inherit;">Imaginez que nous ayons un tableau à deux dimensions contenant des entiers 32 bits (4 octets). </font><font style="vertical-align: inherit;">4096 octets sont lus par disque. </font><font style="vertical-align: inherit;">Si vous lisez des données situées dans un fichier de manière séquentielle à partir d'un disque (par exemple, ces données sont dans les lignes d'un tableau), après chaque opération de lecture, nous aurons 1024 entiers. </font><font style="vertical-align: inherit;">Mais si vous lisez des données dont l'emplacement dans le fichier ne correspond pas à leur emplacement dans le tableau (par exemple, les données situées dans les colonnes), chaque opération de lecture vous permettra d'obtenir seulement 1 numéro requis. </font><font style="vertical-align: inherit;">En conséquence, il s'avère que pour obtenir la même quantité de données, vous devez effectuer mille fois plus d'opérations de lecture.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr et HDF5</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin de surmonter les limitations ci-dessus, vous pouvez utiliser des formats de stockage de données </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou HDF5, qui sont très similaires:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez travailler avec des fichiers HDF5 en Python en utilisant </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pytables</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h5py</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ce format est plus ancien que Zarr et a plus de restrictions, mais son avantage est qu'il peut être utilisé dans des programmes écrits dans différentes langues.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr est un format implémenté à l'aide du package Python du même nom. </font><font style="vertical-align: inherit;">Il est beaucoup plus moderne et flexible que HDF5, mais vous ne pouvez l'utiliser (au moins pour l'instant) que dans l'environnement Python. </font><font style="vertical-align: inherit;">Selon mes sentiments, dans la plupart des situations, s'il n'y a pas besoin de support multilingue pour HDF5, cela vaut la peine de choisir Zarr. </font><font style="vertical-align: inherit;">Zarr, par exemple, a un meilleur support multithreading.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, nous ne discuterons que de Zarr, mais si vous êtes intéressé par le format HDF5 et sa comparaison plus approfondie avec Zarr, vous pouvez regarder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vidéo.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation de Zarr</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zarr vous permet de stocker des éléments de données et de les charger en mémoire sous forme de tableaux, et également - d'écrire ces éléments de données sous forme de tableaux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici comment charger un tableau à l'aide de Zarr:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> zarr, numpy <span class="hljs-keyword">as</span> np
<span class="hljs-meta">&gt;&gt;&gt; </span>z = zarr.open(<span class="hljs-string">'example.zarr'</span>, mode=<span class="hljs-string">'a'</span>,
<span class="hljs-meta">... </span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shape=(<span class="hljs-number">1024</span>, <span class="hljs-number">1024</span>),
<span class="hljs-meta">... </span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunks=(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>), dtype=np.int16)
<span class="hljs-meta">&gt;&gt;&gt; </span>type(z)<font></font>
&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">zarr</span>.<span class="hljs-title">core</span>.<span class="hljs-title">Array</span>'&gt;
&gt;&gt;&gt; <span class="hljs-title">type</span>(<span class="hljs-params">z[<span class="hljs-number">100</span>:<span class="hljs-number">200</span>]</span>)
&lt;<span class="hljs-title">class</span> '<span class="hljs-title">numpy</span>.<span class="hljs-title">ndarray</span>'&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez noter que jusqu'à réception d'une tranche de l'objet, nous ne serons pas à notre disposition </font></font><code>numpy.ndarray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Une entité </font></font><code>zarr.core.array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'est que des métadonnées. </font><font style="vertical-align: inherit;">Seules les données incluses dans la tranche sont chargées à partir du disque.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi ai-je choisi Zarr?</font></font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr contourne les limitations </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">discutées ci-dessus:</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les fragments de données peuvent être stockés sur disque, dans le stockage AWS S3 ou dans un système de stockage qui offre la possibilité de travailler avec des enregistrements de format clé / valeur.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La taille et la structure du fragment de données sont déterminées par le programmeur. </font><font style="vertical-align: inherit;">Par exemple, les données peuvent être organisées de manière à pouvoir lire efficacement des informations situées sur différents axes d'un réseau multidimensionnel. </font><font style="vertical-align: inherit;">Cela est vrai pour HDF5.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les fragments peuvent être compressés. </font><font style="vertical-align: inherit;">La même chose peut être dite de HDF5.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arrêtons-nous plus en détail sur les deux derniers points.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dimensions des fragments</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que nous travaillons avec un tableau de 30 000 x 3 000 éléments. </font><font style="vertical-align: inherit;">Si vous devez lire ce tableau et vous déplacer le long de son axe </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et se déplacer le long de son axe </font></font><code>Y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous pouvez enregistrer des fragments contenant les données de ce tableau, comme indiqué ci-dessous (en pratique, vous aurez probablement besoin de plus de 9 fragments):</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c3/ef4/df7/8c3ef4df7f8f782bbc28e998913f8e34.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Désormais, les données situées à la fois sur l'axe </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et sur l'axe </font></font><code>Y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peuvent être chargées efficacement. </font><font style="vertical-align: inherit;">Selon le type de données nécessaires dans le programme, vous pouvez télécharger, par exemple, des fragments (1, 0), (1, 1), (1, 2) ou des fragments (0, 1), (1, 1), (2, 1).</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compression des données</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque fragment peut être compressé. </font><font style="vertical-align: inherit;">Cela signifie que les données peuvent entrer dans le programme plus rapidement que le disque ne vous permet de lire les informations non compressées. </font><font style="vertical-align: inherit;">Si les données sont compressées 3 fois, cela signifie qu'elles peuvent être téléchargées du disque 3 fois plus rapidement que les données non compressées, moins le temps nécessaire au processeur pour les décompresser.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/677/f42/f3f/677f42f3fc5539051f4adeb8f391684a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois les fragments téléchargés, ils peuvent être supprimés de la mémoire du programme.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résumé: memmap () ou Zarr?</font></font></font></h2><br><font style="vertical-align: inherit;"></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quel est le </font><font style="vertical-align: inherit;">
meilleur à utiliser - </font><font style="vertical-align: inherit;">ou Zarr? </font></font><br>
<br>
<code>Memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela semble intéressant dans de tels cas:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe de nombreux processus qui lisent des parties du même fichier. </font><font style="vertical-align: inherit;">Ces processus, grâce à l'application </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pourront partager le même cache tampon. </font><font style="vertical-align: inherit;">Cela signifie qu'une seule copie des données doit être conservée en mémoire, quel que soit le nombre de processus en cours d'exécution.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le développeur n'a aucune envie de gérer manuellement la mémoire. </font><font style="vertical-align: inherit;">Il prévoit de simplement s'appuyer sur les capacités du système d'exploitation, ce qui résoudra tous les problèmes de gestion de la mémoire automatiquement et de manière invisible pour le développeur.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zarr est particulièrement utile dans les situations suivantes (dans certains d'entre eux, comme cela sera noté, le format HDF5 est également applicable):</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les données sont téléchargées à partir de sources distantes et non à partir du système de fichiers local.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est très probable que le goulot d'étranglement du système lira à partir du disque. </font><font style="vertical-align: inherit;">La compression des données permettra une utilisation plus efficace des capacités matérielles. </font><font style="vertical-align: inherit;">Cela vaut également pour HDF5.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous avez besoin d'obtenir des tranches de tableaux multidimensionnels le long de différents axes, Zarr aide à optimiser ces opérations en sélectionnant la taille et la structure appropriées des fragments. </font><font style="vertical-align: inherit;">Cela est vrai pour HDF5.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je choisirais entre </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr et, tout d'abord, j'essaierais d'utiliser Zarr - en raison de la flexibilité que ce package offre et du format de stockage de données qu'il implémente. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chers lecteurs! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment résolvez-vous le problème de travailler avec de grands tableaux NumPy?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr490620/index.html">Quand j'entends les mots "restauré le réseau neuronal", je grimpe pour vérifier les sauvegardes</a></li>
<li><a href="../fr490622/index.html">Lutte contre les fuites de mémoire dans les applications Web</a></li>
<li><a href="../fr490624/index.html">En-tête HTTP et contrôle du navigateur Web</a></li>
<li><a href="../fr490626/index.html">Un guide complet des attributs data- * HTML</a></li>
<li><a href="../fr490628/index.html">Que faire lorsque CSS bloque l'analyse des pages?</a></li>
<li><a href="../fr490634/index.html">Événements numériques à Moscou du 2 au 8 mars</a></li>
<li><a href="../fr490636/index.html">Événements numériques à Saint-Pétersbourg du 2 au 8 mars</a></li>
<li><a href="../fr490640/index.html">Surcharge en C ++. Partie III. Surcharge des instructions new / delete</a></li>
<li><a href="../fr490642/index.html">Plugin pour la surveillance des applications K8s DevOpsProdigy KubeGraf v1.3.0: nouvelle version et nouvelles fonctionnalités</a></li>
<li><a href="../fr490644/index.html">Référentiel rpm simple utilisant Inotify et webdav</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>