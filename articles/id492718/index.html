<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌 🙅🏿 👧🏼 Keamanan melalui pembatasan pengguna atau cara membuat kerentanan 🎐 🌠 👍🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada tahun 2019, kerentanan CPDoS Cache Poisoned Denial of Service) ditemukan di jaringan CDN, yang memungkinkan keracunan cache HTTP dari penyedia CD...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Keamanan melalui pembatasan pengguna atau cara membuat kerentanan</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492718/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahun 2019, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kerentanan CPDoS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cache Poisoned Denial of Service) </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ditemukan</font></a><font style="vertical-align: inherit;"> di jaringan CDN, yang memungkinkan keracunan cache HTTP dari penyedia CDN dan menyebabkan penolakan layanan. </font><font style="vertical-align: inherit;">Kerentanan belum mengumpulkan banyak hype, karena belum terlihat dalam serangan nyata. </font><font style="vertical-align: inherit;">Tapi saya ingin berbicara tentang salah satu metode keracunan cache secara terpisah. </font><font style="vertical-align: inherit;">Metode HTTP Override.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rb/7j/wy/rb7jwy3an79ykaffwer39l297eu.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika varian lain dari mengeksploitasi kerentanan dalam satu atau lain cara bergantung pada bug atau fitur modifikasi permintaan oleh perantara, maka varian Metode Override didasarkan pada taktik dengan nama yang sama, yang bukan bagian dari standar HTTP, disertai dengan masalah tambahan, dan yang muncul dan menyebar karena ceroboh. hubungan dengan keamanan. </font><font style="vertical-align: inherit;">Di sini kita akan mempertimbangkannya.</font></font><br>
<a name="habracut"></a><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Singkat tentang CPDoS jika Anda melewatkannya</font></font></b><div class="spoiler_text"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"> </a> ,         URI  method   .<br>
<br>
      ,       ,       ,         ,      -   .       —            -  -   -,      ,    -     ,      .           ,         .<br>
<br>
            ,    . ,  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">   -</a>.      -   ,       ,      .<br>
<br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Batasi klien, lebih sedikit bisa - lebih sedikit akan rusak</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sangat perlu untuk menimpa metode dalam permintaan muncul karena fakta bahwa beberapa Aplikasi Web Firewall dan implementasi klien HTTP sangat terbatas dan tidak memungkinkan pelaksanaan metode selain GET dan POST. Masalahnya bukan bahwa itu adalah pembatasan implementasi, tetapi bahwa itu adalah pembatasan yang disengaja dari klien HTTP oleh kebijakan keamanan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jelas bahwa semuanya dilakukan dengan niat baik untuk memotong lalu lintas yang sempit, non-standar untuk klien HTTP biasa. Tetapi dalam mengejar keamanan, semua metode kecuali GET dan POST terputus. Mungkin karena ini adalah satu-satunya metode yang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak opsional dan diperlukan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk server tujuan umum.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa itu diperlukan untuk memperkenalkan pembatasan ketat seperti itu tidak jelas. Ya, serangan dengan pengenalan berbagai karakter untuk membingungkan parser hanyalah hobi protokol teks. Tetapi Anda dapat mengizinkan sedikit lebih banyak metode, misalnya, mengambil setidaknya yang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dijelaskan dalam standar itu sendiri</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://www.iana.org/assignments/http-methods/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terdaftar di IANA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Itu tidak layak untuk sepenuhnya menghapus pemeriksaan metode, tetapi Anda bisa memanggil sejumlah metode yang paling populer dan mengecualikan mereka yang mengubah protokol interaksi dan memutus pekerjaan dengan koneksi pada server proxy (CONNECT). Tapi tidak, ternyata kebijakan keamanan yang </font><font style="vertical-align: inherit;">memberlakukan pembatasan dan larangan yang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak perlu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bagi pelanggan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan pelanggan terbatas pada yang salah. </font><font style="vertical-align: inherit;">Mereka ingin membatasi variabilitas pesan dari klien HTTP, dan membatasi klien yang dilindungi oleh WAF ini, server aplikasi akhir dan pengembangnya. </font><font style="vertical-align: inherit;">Sekarang, pengembang hanya memiliki dua metode yang tidak selalu cukup untuk menggambarkan logika klien HTTP.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kendala diciptakan untuk mengatasinya.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diharapkan bahwa pembatasan yang berlebihan ini cepat atau lambat akan mulai mengganggu pengembang web. Ironinya adalah sangat mudah untuk tidak menyingkirkan WAF seperti itu. Terutama ketika mereka bersama pelanggan atau penyedia. Menantang kebijakan keamanan orang lain adalah masalah yang menghancurkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena fleksibilitas HTTP, tidak sulit untuk menghindari batasan ini, cukup tambahkan sesuatu ke permintaan di mana Anda dapat mengganti metode. WAF yang ketat hanya akan memeriksa metode di Baris Permintaan (baris pertama permintaan) dan akan senang melihat GET atau POST yang disetujui di sana. Dan backend akan dapat menguraikan elemen yang ditambahkan dan mengekstrak metode nyata darinya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://fandry.blogspot.com/2012/03/x-" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">google </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">banyak </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://docs.inpaas.com/docs/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel, </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benar-benar </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://www.infoworld.com/article/3249687/how-to-implement-a-delegatinghandler-for-x-" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">banyak</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tentang bagaimana proxy yang buruk merusak aplikasi REST, dan bagaimana penulis harus melewati metode nyata di header yang terpisah. </font><font style="vertical-align: inherit;">Dalam semuanya, mereka menyarankan agar Anda memasukkan kira-kira tajuk yang sama (X-HTTP-Method, X-HTTP-Method-Override atau X-Method-Override - ejaannya agak bervariasi) untuk menunjukkan metode yang diganti. </font><font style="vertical-align: inherit;">Sangat, sangat jarang orang dapat menemukan referensi yang dapat digunakan untuk tujuan-komponen URI tujuan yang sama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang hilang dari artikel ini adalah bagian Pertimbangan Keamanan. </font><font style="vertical-align: inherit;">Dan memang begitu.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah metode utama aman?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terkadang pengembang aplikasi web lupa bahwa antara klien dan server mungkin ada peserta menengah yang berinteraksi melalui protokol HTTP: proksi, cache web penyedia, CDN dan WAF. Proliferasi TLS sangat mengurangi kemungkinan peserta perantara antara klien dan server. Kemungkinan besar satu-satunya proxy antara klien dan backend adalah servernya sendiri dengan Nginx. Dan konfigurasi seperti itu cukup mudah untuk menguji skenario tipikal sebelum rilis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi kami memasuki era CDN, dan semakin banyak aplikasi akan bersembunyi di balik CDN yang membaca dan memanipulasi traffic pengguna. </font><font style="vertical-align: inherit;">Backends secara langsung hampir tidak pernah melayani pengguna, dan bersembunyi di balik proxy terbalik untuk meningkatkan daya tanggap dan kinerja. </font><font style="vertical-align: inherit;">Oleh karena itu, Anda harus ingat bagaimana mengganti metode dapat memengaruhi pemrosesan permintaan pada server mediasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Serangan yang ingin saya bicarakan terutama berlaku untuk HTTP / 1.1. </font><font style="vertical-align: inherit;">HTTP / 2 dalam beberapa hal mewarisi perilaku standar lama, dalam beberapa hal berjalan dengan caranya sendiri, sehingga penerapan setiap serangan ke standar baru akan dipertimbangkan secara terpisah.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serangan cache</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Paling sering, server perantara tidak memperhitungkan penggantian metode akun, jangan memeriksa header keluarga X-HTTP-Method-Override, dan bekerja dengan permintaan menggunakan metode utamanya dari Baris Permintaan. Dan karena metode yang diganti tidak termasuk dalam kunci untuk mencari permintaan dalam cache (metode + URI), server tersebut tidak dapat membedakan POST dari POST + X-HTTP-Method-Override: DELETE. Ini berarti bahwa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda tidak dapat mengizinkan caching</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permintaan apa pun ke URI tertentu jika backend dapat memantau dan menjalankan metode yang diganti.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dokumen CPDoS memiliki contoh bagus tentang apa yang terjadi jika Anda menyimpan permintaan seperti itu. Ketika seorang penyerang menyamarkan permintaan POST sebagai permintaan GET, proksi tidak mengenali substitusi dan memperlakukan permintaan tersebut sebagai permintaan GET yang sah. Backend, bagaimanapun, mengenali metode yang ditimpa dan mengeksekusi kata kerja yang dijelaskan dalam X-HTTP-Method-Override - POST header. Karena metode POST tidak ditentukan untuk URI tujuan, server menghasilkan kesalahan. Selanjutnya, respons backend disimpan dalam cache sebagai respons terhadap metode asli - GET. Sekarang setiap permintaan GET berikutnya untuk URI yang sama akan mengembalikan kesalahan dalam cache.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/0r/bv/_q/0rbv_qeocdxi9b4ctw2rschthgw.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan, serangannya sedikit lebih lebar dari yang disajikan dalam dokumen. Para penulis fokus pada menyimpan kesalahan dalam cache, yang tidak di mana-mana (sudah) dapat direproduksi. Tetapi jika metode yang diminta untuk URI yang dipilih ditentukan dan akan berhasil dijalankan, proksi akan menerima respons dengan status 200 dan menyimpannya. Kemudian permintaan selanjutnya dari URI yang sama untuk menerima tanggapan terhadap metode yang sepenuhnya salah. Dalam skenario ini, tidak ada lagi persyaratan dengan kesalahan cache tanggapan 4XX, seperti dalam deskripsi CPDoS asli. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah sebaliknya dapat terjadi. Jika klien HTTP yang terhormat mengirim GET + X-HTTP-Method-Override: permintaan PATCH (ini buruk, tetapi lebih lanjut tentang itu nanti), dan cache sudah memiliki respons GET, maka klien akan menerima respons cache ini. Dalam kasus ini, backend tidak akan pernah menerima permintaan PATCH, yang dapat melanggar logika aplikasi pada klien dan server.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat mengurangi efek pada cache dengan membangun kebijakan cache yang benar dan membagi sumber daya menjadi dua grup: yang metode yang menimpa operasi tidak dapat diterima atau tidak diperlukan, respons terhadapnya bisa di-cache, dan yang metode diperlukan untuk menimpanya, caching jawaban semacam itu tidak dapat diterima . Tetapi semakin sedikit sumber daya yang di-cache, semakin tidak berguna adalah CDN dan semakin banyak lalu lintas mencapai backend, semakin banyak aplikasi terkena banjir HTTP. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, lebih baik menggunakan cache HTTP sebanyak mungkin, untuk ini perlu bahwa server cache dapat membedakan antara permintaan dengan metode menimpa yang berbeda. Cara pertama adalah mentransfer metode override komponen kueri ke URI:</font></font><br>
<br>
<pre><code class="plaintext hljs">POST /some-uri HTTP/1.1<font></font>
X-HTTP-Method-Override: DELETE<font></font>
   ↓  ↓   ↓<font></font>
POST /some-uri?method=DELETE HTTP/1.1<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang permintaan dengan metode berbeda terlihat berbeda untuk cache, karena mereka mendapatkan kunci yang berbeda. Beberapa proksi memilih untuk tidak menembaki respons ke permintaan yang berisi komponen kueri di URI. Tetapi ini hanya akan mempengaruhi efisiensi caching. Metode ini selalu memecahkan masalah dengan caching yang salah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cara lain adalah meninggalkan metode override di header yang terpisah, tetapi masukkan kunci sekunder untuk menemukan jawabannya di cache. Ini dimungkinkan dengan header Vary. Saat melayani permintaan, server akan mengulangi tajuk dengan metode override dan mencerminkan nama tajuk ini di tajuk Vary. Kemudian, pada permintaan berikut, server cache akan menggunakan nilai metode yang diganti sebagai kunci sekunder saat mencari permintaan di cache.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/oh/1n/rd/oh1nrdf3x18yktd6moekwlr01-w.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode ini berfungsi jika server perantara dapat bekerja dengan kunci sekunder. </font><font style="vertical-align: inherit;">Ini biasanya terjadi, tetapi tingkat kepercayaan proxy, yang memotong semua metode kecuali GET dan POST, biasanya lebih rendah dan lebih baik untuk memeriksa ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengganti metode melalui entitas apa pun di dalam tubuh permintaan memiliki kelemahan yang sama persis dengan mengesampingkan melalui header tambahan - itu berada di luar visibilitas cache.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serangan Antrian Pesan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan jika serangan cache ditutup, itu tidak semua. </font><font style="vertical-align: inherit;">Seorang penyerang dengan mengganti metode mungkin mencoba mengubah pembingkaian respons dan dengan demikian melanggar korespondensi dari pasangan permintaan-respons untuk klien lain. </font><font style="vertical-align: inherit;">Atau paksakan sisi server aplikasi untuk memproses permintaan yang sama beberapa kali.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal terpenting yang diperlukan untuk ini adalah server perantara yang beroperasi dalam mode reverse-proxy. Artinya, semua caching atau server CDN. Proxy semacam itu mendukung sejumlah kecil koneksi ke backend, dan melipatgandakan permintaan dari banyak klien di masing-masing. Hal ini diperlukan baik untuk mengambil beban mendukung sejumlah besar koneksi klien dari backend ke server proxy, dan untuk menyeimbangkan beban antara backend. Pengakhiran koneksi TLS juga terjadi pada proksi, koneksi klien tidak pernah terhubung langsung ke backend. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena sekarang permintaan dari klien yang berbeda akan berada dalam koneksi yang sama antara backend dan proksi, perlu untuk menjaga korespondensi yang jelas antara pasangan permintaan-respons. Sebagian besar proxy </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak menggunakan saluran pipa</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(pipa) permintaan ke backend dan bekerja dengannya dalam mode permintaan-respons. Mode permintaan-respons lebih sederhana dan tunduk pada satu ancaman - pemblokiran koneksi. Jika Anda membuat koneksi menggantung pada pasangan permintaan-respons tunggal, Anda dapat menyebabkan penundaan atau bahkan penolakan untuk memproses permintaan berikut (misalnya, jika Anda berhasil meluap antrian permintaan proxy).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Permintaan pipa proksi yang lebih produktif ke backend - ini memungkinkan Anda untuk mengirim paket permintaan ke server segera dan menunggu eksekusi. Kinerja lebih tinggi, tetapi ada lebih banyak ancaman. Pertama, masalah pemblokiran head-of-line tidak hilang di mana pun - bahkan jika backend dapat menyapu pipa permintaan dan menjalankannya secara paralel, mereka tidak dapat dikirim jika yang pertama hang. Kedua, jika Anda mematahkan framing respons, Anda dapat membingungkan proksi dan memutus korespondensi dari pasangan permintaan-respons, maka beberapa klien dapat memperoleh jawaban orang lain, atau setidaknya mencapai penutupan koneksi instan dengan backend.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/td/wn/rj/tdwnrjiw4ekrsl7l1aqda-hhyzi.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redefinisi paling sederhana dan paling menyenangkan dari suatu metode adalah mengganti GET dengan kata kerja HEAD. Jika jawaban yang pertama memiliki tubuh, maka jawaban kedua tidak. Selain itu, semua tajuk lainnya adalah sama, termasuk yang menyediakan framing permintaan. Ketika proxy mengarahkan kembali HEAD yang ditimpa ke server, itu akan diharapkan dari server tidak hanya header respons, tetapi juga badan respons, yang tidak akan dikirim oleh backend. Jika proksi dan server berinteraksi dalam mode permintaan-respons, maka koneksi akan “hang” hingga terputus oleh batas waktu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika server mengirim jawaban berikut (mode pipelined), maka mereka dapat diurai bukan sebagai jawaban independen, tetapi sebagai bagian dari respons sebelumnya, tidak lengkap untuk GET. Proxy akan menempatkan mereka (atau sebagian dari mereka) di badan respons "GET" dan mengirimkannya ke penyerang untuk membacanya. Anda dapat membuat pseudo-GET tersebut untuk menerima file besar dan membuang beberapa lalu lintas antara proksi dan backend. Keberhasilan tergantung pada bagaimana backend menempatkan Content-Length dan Transfer-Encoding: header chunked untuk membingkai pesan. Yang pertama hampir selalu memungkinkan Anda untuk mendapatkan dump, yang kedua akan sering menghasilkan kesalahan parsing dan menyebabkan pemutusan dari backend. Jika Anda sama sekali tidak beruntung, pseudo-GET dapat mencakup beberapa jawaban secara keseluruhan dan berakhir tepat sebelum jawaban berikutnya.Proxy tidak akan dapat mengenali masalah ini sama sekali dan untuk jawaban lebih lanjut dalam hubungan ini korespondensi permintaan-respons akan dilanggar.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ee/ds/h9/eedsh90uounshmxglkz5aconiim.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan jika semua yang dicapai dengan mengganti metode adalah menutup koneksi antara proxy dan backend, maka ini mungkin cukup untuk serangan. </font><font style="vertical-align: inherit;">Anda dapat mengajukan permintaan layanan dengan permintaan seperti itu - koneksi dengan backend akan terus putus. </font><font style="vertical-align: inherit;">Jumlahnya tidak terlalu banyak, dan pembukaan kembali membutuhkan waktu, sebagai hasilnya, Anda dapat mencapai penurunan yang signifikan dalam kinerja koneksi backend proxy dan dengan demikian mengurangi bandwidth layanan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Putar ulang spam otomatis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya katakan di atas bahwa permintaan formulir GET + X-HTTP-Method-Override: PATCH dari klien terhormat adalah buruk. Dan ini buruk karena metode memiliki dua properti: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keamanan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idempotensi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Keamanan berarti bahwa metode ini tidak mengubah status server (hanya baca), dan tidak menarik bagi kami dalam konteks artikel ini. Idempotensi metode memastikan bahwa permintaan yang diulang memiliki efek yang sama dengan satu permintaan. Anda dapat menggambar analogi: </font></font><code>(a = 5)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- permintaan idempoten, dan </font></font><code>(a += 2) </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- non-idempoten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Properti ini yang menarik minat kami. Jika koneksi antara klien dan server tiba-tiba terputus, klien, mengetahui bahwa metode ini idempoten, dapat secara otomatis mengirim ulang permintaan. Proxy berperilaku dengan cara yang sama. Permintaan non-idempoten tidak secara otomatis diulang karena tidak diketahui bagaimana mereka mempengaruhi server dan apa yang akan diterima klien pada akhirnya. Saya pikir semua orang tahu pop-up di browser: "Apakah Anda yakin ingin mengulangi permintaan?" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda menutupi metode non-idempoten sebagai idempoten, maka jika terjadi kesalahan tidak akan dibuang, tetapi akan dialihkan ke server lagi. Bahkan jika klien akan mempertimbangkan metode permintaan sebenarnya sebelum mengirimkan kembali permintaan, ini tidak akan banyak membantu, karena server proxy tidak mengetahui metode menimpa dan akan mengulangi permintaan tersebut.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika penyerang dapat memaksa pemutusan antara backend dan klien, ia akan dapat menyebabkan server untuk berulang kali mengeksekusi permintaan non-idempoten dan mengurangi keandalan dan prediktabilitas aplikasi. </font><font style="vertical-align: inherit;">Di bagian sebelumnya, kami baru saja menemukan cara bagaimana Anda dapat menyebabkan koneksi terputus dengan metode override yang sama. </font><font style="vertical-align: inherit;">Meskipun harus diingat bahwa Internet adalah jaringan yang tidak dapat diandalkan, menurut definisi, dan aplikasi itu sendiri dalam bahaya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk melindungi dari serangan ini, Anda harus menggunakan hanya metode yang tidak menambahkan properti baru ke permintaan sebagai transportasi. </font><font style="vertical-align: inherit;">POST adalah kandidat yang baik, karena secara default tidak aman atau idempoten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 1.1 kuno itu, seperti HTTP / 2?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTP / 2 telah mengubah cara permintaan diangkut antar node, tetapi tidak mengubah makna leksikalnya. Oleh karena itu, dalam serangan yang terkait dengan nilai permintaan, HTTP / 2 berperilaku sama. Tetapi serangan “transportasi” tidak direproduksi, karena sudah diperhitungkan dalam standar. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serangan pada cache</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> direproduksi dengan cara yang mirip dengan HTTP / 1, dan perlindungannya serupa. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesan Serangan antrian</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak berlaku untuk HTTP / 2. Pesan HTTP di dalamnya dibagi menjadi beberapa frame terpisah, dengan header frame terpisah yang secara eksplisit menentukan panjang dan akhir pesan. Seolah-olah penyerang tidak akan mengubah metode dan memodifikasi header HTTP, ini tidak akan mempengaruhi bingkai pesan. Mencuri jawabannya akan gagal. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serangan pada pengulangan pesan non-idempoten</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berlaku bahkan dengan mempertimbangkan fakta bahwa dalam HTTP / 2 ada</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mekanisme pemberitahuan permintaan terakhir yang diproses</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dalam HTTP / 2, banyak permintaan dikalikan dalam TCP yang sama dan dengan demikian menciptakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aliran</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Setiap utas memiliki nomornya sendiri. </font><font style="vertical-align: inherit;">Jika server HTTP / 2 terputus, ini dapat menunjukkan jumlah permintaan yang diproses terakhir di GOAWAY. </font><font style="vertical-align: inherit;">Permintaan dengan nomor yang lebih tinggi selalu aman untuk dialihkan, permintaan dengan nomor yang lebih rendah hanya dialihkan jika mereka idempoten. </font><font style="vertical-align: inherit;">Jika permintaan dengan metode yang diganti terlihat idempoten untuk server proxy, maka proxy akan meneruskannya ke server.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara mengganti metode dengan aman</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jawaban singkatnya tidak mungkin. Lebih baik tidak menggunakan metode menimpa sama sekali. Dan sepenuhnya menonaktifkan dukungan di backend, jika ada. Blokir metode penggantian klien HTTP. Menolak proxy / WAF, yang memotong metode "ekstra". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda harus entah bagaimana hidup dengan redefinisi metode, maka untuk mencegah pengeditan cukup ke backend. Pertama, disarankan untuk mengganti metode hanya melalui komponen kueri URI.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kedua, harus ada daftar putih dari transformasi metode: yang dapat diterima sebagai "transportasi" dan yang merupakan hasil. </font><font style="vertical-align: inherit;">Seharusnya tidak ada fungsi transformasi umum ketika metode apa pun dapat diganti oleh apa pun. </font><font style="vertical-align: inherit;">Metode "transportasi" tidak boleh memiliki sifat keamanan dan idempotensi jika yang dihasilkan tidak. </font><font style="vertical-align: inherit;">Transformasi berbahaya harus dilarang, GET pengganti yang sama -&gt; KEPALA.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah saya perlu menambal proxy masalah / WAF?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika proxy hanya mengimplementasikan metode GET dan POST, dan memblokir yang lain karena satu dan lain alasan, pasti ya. </font><font style="vertical-align: inherit;">Anda dapat mengoptimalkannya terutama untuk GET dan POST, tetapi memblokir metode lain adalah ide yang buruk. </font><font style="vertical-align: inherit;">Yang masih menciptakan jurang ketidakpercayaan pada produk: jika hal-hal dasar diblokir, apa yang diharapkan dari implementasi masalah yang lebih kompleks?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda khawatir tentang keamanan aplikasi web yang dilindungi, maka mungkin ada baiknya untuk mengamankan aplikasi dari metode yang tidak aman dan mengabaikan kebijakan. </font><font style="vertical-align: inherit;">Tentu saja, dalam kasus umum, tanpa mengetahui detail penerapan aplikasi web, tidak mungkin untuk sepenuhnya melindungi aplikasi dari penggantian yang salah, tetapi Anda dapat sebagian melindungi pengguna yang tidak tahu tentang masalahnya. </font><font style="vertical-align: inherit;">Diperlukan tidak hanya untuk melindungi dari meracuni cache Anda sendiri, tetapi juga untuk memungkinkan untuk mengaktifkan atau menonaktifkan penggantian untuk setiap aplikasi yang dilindungi. </font><font style="vertical-align: inherit;">Untuk melakukan ini, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perhatikan </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tajuk yang biasa digunakan.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X-HTTP-Method, X-HTTP-Method-Override dan X-Method-Override. </font><font style="vertical-align: inherit;">Melacak redefinisi dalam komponen kueri URI tidak masuk akal: cache tidak meracuni permintaan seperti itu, dan kueri bisa sangat panjang dan memiliki format yang sepenuhnya arbitrer.</font></font><br>
<br>
<h2>      ?</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengembang keamanan, jangan membatasi pengembang aplikasi untuk kebijakan keamanan. </font><font style="vertical-align: inherit;">Mereka masih akan menemukan cara menyiasatinya, dan semakin fleksibel protokolnya, semakin mudah melakukannya. </font><font style="vertical-align: inherit;">Sangat mungkin bahwa mereka tidak akan menendang Anda dan menunggu sampai Anda membuat batasan lebih masuk akal, tetapi hanya memotongnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda menemukan cara mengimplementasikan sesuatu dalam protokol, tetapi menimpa atau bertentangan dengan salah satu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konsep kunci</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> standar, maka masalah kompatibilitas dan keamanan pasti akan muncul. </font><font style="vertical-align: inherit;">Dan mereka perlu dibahas pada saat yang sama dengan keputusan. </font><font style="vertical-align: inherit;">Setiap saat. </font><font style="vertical-align: inherit;">Jika Anda bertemu saran tersebut dan tidak melihat peringatan keamanan, maka jangan menduplikasi saran di seluruh Internet. </font><font style="vertical-align: inherit;">Selalu kritis terhadap keputusan dan mencari tahu apa yang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">salah</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih kata penutup</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa masalah server proxy yang Anda temui? </font><font style="vertical-align: inherit;">Apa yang harus dielakkan dan bagaimana?</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id492706/index.html">Arsip memori: bagaimana otak menyandikan dan mereproduksi memori</a></li>
<li><a href="../id492708/index.html">Internet satelit global - apakah ada berita dari ladang?</a></li>
<li><a href="../id492710/index.html">Jalur kandidat yang berduri melalui berbagai sistem HRM</a></li>
<li><a href="../id492712/index.html">Menguasai pengembangan melalui pengujian di Android menggunakan tes UI</a></li>
<li><a href="../id492714/index.html">Kerja efektif dari rumah: umum dan pribadi</a></li>
<li><a href="../id492720/index.html">diskussion: layanan file proyek</a></li>
<li><a href="../id492724/index.html">Björn Straustrup Jawaban Top 5 C ++ Pertanyaan dengan Stack Overflow</a></li>
<li><a href="../id492726/index.html">OS Sivelkiriya: proses pengembangan perangkat lunak</a></li>
<li><a href="../id492728/index.html">Asterisk dan pengiriman tidak terjawab di Telegram / Slack / E-mail</a></li>
<li><a href="../id492730/index.html">Departemen Pertahanan AS: Etika untuk AI dan Kendaraan Tanpa Awak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>