<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✌🏽 ◀️ 👩🏾‍💻 Stas Afanasyev. Juno. Pipelines basés sur io.Reader / io.Writer. Partie 1 🗝️ ✌🏾 🏷️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans le rapport, nous parlerons du concept de io.Reader / io.Writer, pourquoi ils sont nécessaires, comment les implémenter correctement et quels pièg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Stas Afanasyev. Juno. Pipelines basés sur io.Reader / io.Writer. Partie 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/491484/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le rapport, nous parlerons du concept de io.Reader / io.Writer, pourquoi ils sont nécessaires, comment les implémenter correctement et quels pièges existent à cet égard, ainsi que de la construction de pipelines basés sur des implémentations standard et personnalisées de io.Reader / io.Writer .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rd/nv/uj/rdnvujcjwsukejxq_6a9syayawu.jpeg"><a name="habracut"></a><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stanislav Afanasyev (ci-après - SA):</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Bonjour! Je m'appelle Stas. Je venais de Minsk, de la société Juno. Merci d'être venu ce jour de pluie, d'avoir trouvé la force de quitter la maison. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aujourd'hui, je veux vous parler d'un sujet tel que la construction de pipelines Go basés sur les interfaces io.Reader / io.Writer. Ce dont je vais parler aujourd'hui est, en général, le concept des interfaces io.Reader / io.Writer, pourquoi elles sont nécessaires, comment les utiliser correctement et, surtout, comment les implémenter correctement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous parlerons également de la construction de pipelines basés sur diverses implémentations de ces interfaces. Nous parlerons des méthodes existantes, discuterons de leurs avantages et inconvénients. Je mentionnerai divers pièges (ce sera en abondance).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de commencer, nous devons répondre à la question: pourquoi ces interfaces sont-elles nécessaires? </font><font style="vertical-align: inherit;">Levez la main, qui travaille étroitement avec Go (tous les jours, tous les deux jours) ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d2/pd/f4/d2pdf4kdwdjk_vxkqz6fwckqrgk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Génial! </font><font style="vertical-align: inherit;">Nous avons toujours une communauté Go. </font><font style="vertical-align: inherit;">Je pense que beaucoup d'entre vous ont travaillé avec ces interfaces, en ont entendu parler, au moins. </font><font style="vertical-align: inherit;">Vous ne les connaissez peut-être même pas, mais vous auriez certainement dû en entendre parler. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, ces interfaces sont une abstraction de l'opération entrée-sortie dans toutes ses manifestations. </font><font style="vertical-align: inherit;">Deuxièmement, c'est une API très pratique qui vous permet de construire des pipelines, comme un constructeur à partir de cubes, sans vraiment penser aux détails internes de l'implémentation. </font><font style="vertical-align: inherit;">Au moins, c'était initialement prévu.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit d'une interface très simple. Il se compose d'une seule méthode - la méthode Read. Conceptuellement, l'implémentation de l'interface io.Reader peut être une connexion réseau - par exemple, où il n'y a pas encore de données, mais elles peuvent y apparaître: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/n-/4n/dc/n-4ndcbxpoxkul6h227ue7hruli.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
il peut s'agir d'un tampon en mémoire où les données existent déjà et peuvent être lues entièrement. Il peut également s'agir d'un descripteur de fichier - nous pouvons lire ce fichier en morceaux s'il est très volumineux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'implémentation conceptuelle de l'interface io.Reader est l'accès à certaines données. Tous les cas que j'ai écrits sont pris en charge par la méthode Read. Il n'a qu'un seul argument - c'est l'octet de tranche.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un point à souligner ici. Ceux qui sont venus récemment sur Go ou sont venus d'une autre technologie, où il n'y avait pas d'API similaire (je suis de ceux-là), cette signature est un peu déroutante. La méthode Read semble lire en quelque sorte cette tranche. En fait, l'inverse est vrai: l'implémentation de l'interface Reader lit les données à l'intérieur et remplit cette tranche avec les données que cette implémentation possède.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La quantité maximale de données pouvant être lues sur demande par la méthode Read est égale à la longueur de cette tranche. </font><font style="vertical-align: inherit;">Une implémentation régulière renvoie autant de données qu'elle peut en renvoyer au moment de la demande, ou la quantité maximale qui correspond à cette tranche. </font><font style="vertical-align: inherit;">Cela suggère que Reader peut être lu en morceaux: au moins par octet, au moins dix - comme vous le souhaitez. </font><font style="vertical-align: inherit;">Et le client qui appelle Reader, selon les valeurs de retour de la méthode Read, pense comment vivre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La méthode Read renvoie deux valeurs:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nombre d'octets soustraits;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une erreur si elle s'est produite.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces valeurs influencent le comportement futur du client. </font><font style="vertical-align: inherit;">Il y a un gif sur la diapositive qui montre, affiche ce processus, que je viens de décrire:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/ww/sf/siwwsf6u8mb1nkztg0ltnumkckw.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/p1/hk/mb/p1hkmbpfp8-twtnznjj2ihireaa.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Io.Reader - Comment faire?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe exactement deux façons pour que vos données satisfassent l'interface du Reader. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/l0/fm/e7/l0fme7quz_tqzilkfiuiddpgjk4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier est le plus simple. Si vous avez une sorte d'octet de tranche et que vous voulez qu'il satisfasse l'interface Reader, vous pouvez prendre l'implémentation d'une bibliothèque standard qui satisfait déjà cette interface. Par exemple, Reader à partir du package d'octets. Sur la diapositive ci-dessus, vous pouvez voir la signature de la façon dont ce Reader est créé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe un moyen plus compliqué - d'implémenter l'interface Reader vous-même. Il y a environ 30 lignes dans la documentation avec des règles compliquées, des restrictions qui doivent être suivies. Avant de parler de chacun d'eux, il m'est devenu intéressant: «Et dans quels cas les implémentations standard (bibliothèque standard) ne sont-elles pas suffisantes? Quel est le moment où nous devons implémenter l'interface Reader nous-mêmes? »</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin de répondre à cette question, j'ai pris les milliers de référentiels les plus populaires sur Github (par le nombre d'étoiles), les ai ajoutés et y ai trouvé toutes les implémentations de l'interface Reader. </font><font style="vertical-align: inherit;">Sur la diapositive, j'ai quelques statistiques (catégorisées) sur le moment où les gens implémentent cette interface.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La catégorie la plus populaire est celle des connexions. </font><font style="vertical-align: inherit;">Il s'agit d'une implémentation de protocoles propriétaires et d'encapsuleurs pour les types existants. </font><font style="vertical-align: inherit;">Ainsi, Brad Fitzpatrick a un projet Camlistore - il y a un exemple sous la forme de statTrackingConn, qui, en général, est un wrapper ordinaire sur le type con du package net (ajoute des métriques à ce type).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La deuxième catégorie la plus populaire est celle des tampons personnalisés. </font><font style="vertical-align: inherit;">Ici, j'ai aimé le seul et unique exemple: dataBuffer du package x / net. </font><font style="vertical-align: inherit;">Sa particularité est qu'il stocke les données découpées en morceaux, et lors de la soustraction, il passe à travers ces morceaux. </font><font style="vertical-align: inherit;">Si les données du bloc sont terminées, elles passent au bloc suivant. </font><font style="vertical-align: inherit;">Dans le même temps, il prend en compte la longueur, la place qu'il peut remplir dans la tranche transmise.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre catégorie comprend toutes sortes de barres de progression, comptant le nombre d'octets soustraits lors de l'envoi de métriques ...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur la base de ces données, nous pouvons dire que la nécessité de mettre en œuvre l'interface io.Reader se produit assez souvent. </font><font style="vertical-align: inherit;">Commençons ensuite par parler des règles qui se trouvent dans la documentation.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Règles de documentation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme je l'ai dit, la liste des règles, et en général la documentation est assez grande, massive. 30 lignes suffisent pour une interface composée de seulement trois lignes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première règle, la plus importante, concerne le nombre d'octets renvoyés. Elle doit être strictement supérieure ou égale à zéro et inférieure ou égale à la longueur de la tranche envoyée. Pourquoi c'est important? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1k/kp/xh/1kkpxhahoiicme8z8vbdbq5ajbm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme il s'agit d'un contrat assez strict, le client peut faire confiance au montant provenant de la mise en œuvre. Il existe des wrappers dans la bibliothèque standard (par exemple, bytes.Buffer et bufio). Il y a un tel moment dans la bibliothèque standard: certaines implémentations font confiance aux lecteurs enveloppés, d'autres ne font pas confiance (nous en reparlerons plus tard).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bufio ne fait confiance à rien - il vérifie absolument tout. </font><font style="vertical-align: inherit;">Bytes.Buffer fait entièrement confiance à tout ce qui lui arrive. </font><font style="vertical-align: inherit;">Je vais maintenant montrer ce qui se passe à ce sujet ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons maintenant considérer trois cas possibles - ce sont trois lecteurs implémentés. </font><font style="vertical-align: inherit;">Ils sont assez synthétiques, utiles à la compréhension. </font><font style="vertical-align: inherit;">Nous lirons tous ces lecteurs à l'aide de l'assistant ReadAll. </font><font style="vertical-align: inherit;">Sa signature est présentée en haut de la diapositive:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ib/c1/7b/ibc17bdqyrimk3xce2khqwera4w.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader # 1. </font><font style="vertical-align: inherit;">Exemple 1</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ReadAll est un assistant qui accepte une sorte d'implémentation de l'interface Reader, lit tout et retourne les données qu'il a lues, ainsi qu'une erreur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre premier exemple est Reader, qui renverra toujours -1 et nil comme une erreur, c'est-à-dire un tel NegativeReader. Lançons-le et voyons ce qui se passe: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7n/3h/l-/7n3hl-2vdvmgvmw80eljlorapiw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous le savez, la panique sans raison est un signe de folie. Mais qui dans ce cas est idiot - moi ou octet.Buffer - dépend du point de vue. Ceux qui écrivent ce paquet et qui le suivent ont des points de vue différents. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que s'est-il passé ici? Bytes.Buffer a accepté un nombre négatif d'octets, n'a pas vérifié qu'il était négatif et a essayé de couper le tampon interne le long de la limite supérieure, qu'il a reçu - et nous sommes sortis des limites de tranche.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a deux problèmes dans cet exemple. La première est que la signature n'est pas interdite de renvoyer des nombres négatifs, et la documentation est interdite. Si la signature avait Uint, nous obtiendrions un débordement classique (lorsqu'un numéro signé est interprété comme non signé). Et c'est un bug très délicat, qui se produira certainement vendredi soir, lorsque vous serez déjà assemblé à la maison. Par conséquent, la panique dans ce cas est l'option préférée.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxième «point» est que la trace de la pile ne comprend pas du tout ce qui s'est passé. Il est clair que nous avons dépassé les limites de la tranche - alors quoi? Lorsque vous disposez d'un tel tuyau multicouche et qu'une telle erreur se produit, il n'est pas immédiatement clair ce qui s'est passé. Le bufio de la bibliothèque standard «panique» également dans cette situation, mais il le fait plus magnifiquement. Il écrit immédiatement: «J'ai soustrait un nombre négatif d'octets. Je ne ferai rien d'autre - je ne sais pas quoi en faire. "</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et octets. Buffer panique du mieux qu'il peut. </font><font style="vertical-align: inherit;">J'ai posté un problème à Golang me demandant d'ajouter une erreur humaine. </font><font style="vertical-align: inherit;">Le troisième jour, nous avons discuté des perspectives de cette décision. </font><font style="vertical-align: inherit;">La raison en est la suivante: historiquement, il arrivait que différentes personnes à différents moments prenaient différentes décisions non coordonnées. </font><font style="vertical-align: inherit;">Et maintenant, nous avons ce qui suit: dans un cas, nous ne faisons pas du tout confiance à la mise en œuvre (nous vérifions tout), et dans l'autre, nous faisons entièrement confiance, nous n'obtenons pas ce qui en découle. </font><font style="vertical-align: inherit;">Il s'agit d'un problème non résolu, et nous en parlerons davantage.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader # 1. </font><font style="vertical-align: inherit;">Exemple 2</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La situation suivante: notre Reader retournera toujours 0 et nil comme résultat. </font><font style="vertical-align: inherit;">Du point de vue des contrats, tout est légal ici - il n'y a pas de problèmes. </font><font style="vertical-align: inherit;">Seul bémol: la documentation indique que les implémentations ne sont pas recommandées pour renvoyer les valeurs 0 et nil, en plus du cas, lorsque la longueur de la tranche envoyée est nulle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la vraie vie, un tel lecteur peut causer beaucoup de problèmes. </font><font style="vertical-align: inherit;">Donc, revenons à la question, faut-il faire confiance à Reader? </font><font style="vertical-align: inherit;">Par exemple, une vérification est intégrée à bufio: elle lit séquentiellement Reader exactement 100 fois - si une telle paire de valeurs est retournée 100 fois, elle renvoie simplement NoProgress. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'y a rien de tel dans bytes.Buffer. </font><font style="vertical-align: inherit;">Si nous exécutons cet exemple, nous obtenons juste une boucle sans fin (ReadAll utilise bytes.Buffer sous le capot, pas Reader lui-même):</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xh/br/zu/xhbrzuvnof4dxubt2d26i6q4l_q.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader # 1. </font><font style="vertical-align: inherit;">Exemple 2</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre exemple. </font><font style="vertical-align: inherit;">Il est également assez synthétique, mais utile à la compréhension: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ga/pe/xp/gapexpzfyhd6za09ss_uuwbrmlk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ici, nous renvoyons toujours 1 et nil. </font><font style="vertical-align: inherit;">Il semblerait qu'il n'y ait pas de problème ici non plus - tout est légal du point de vue du contrat. </font><font style="vertical-align: inherit;">Il y a une nuance: si j'exécute cet exemple sur mon ordinateur, il se fige après 30 secondes ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela est dû au fait que le client qui lit ce Reader (c'est-à-dire octets.Buffer) ne reçoit jamais un signe de la fin des données - il lit, soustrait ... De plus, il obtient un octet soustrait à chaque fois. </font><font style="vertical-align: inherit;">Pour lui, cela signifie qu'à un moment donné, le tampon repositionné se termine, il s'exécute toujours - la situation se répète et il s'exécute à l'infini jusqu'à ce qu'il éclate.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Lecteur # 2. </font><font style="vertical-align: inherit;">Retour d'erreur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous arrivons à la deuxième règle importante pour la mise en œuvre de l'interface Reader - il s'agit d'un retour d'erreur. </font><font style="vertical-align: inherit;">La documentation indique trois erreurs que l'implémentation doit renvoyer. </font><font style="vertical-align: inherit;">Le plus important d'entre eux est l'EOF. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EOF est le signe même de la fin des données, que l'implémentation doit retourner chaque fois qu'il manque de données. </font><font style="vertical-align: inherit;">Sur le plan conceptuel, il ne s'agit pas, en général, d'une erreur, mais d'une erreur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a une autre erreur appelée UnexpectedEOF. </font><font style="vertical-align: inherit;">Si soudainement, pendant la lecture, Reader ne peut plus lire les données, on pensait que cela retournerait UneattenduEOF. </font><font style="vertical-align: inherit;">Mais en fait, cette erreur n'est utilisée qu'à un seul endroit de la bibliothèque standard - dans la fonction ReadAtLeast.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-c/og/la/-coglawtrylyakbq0kxlc0ob9rs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre erreur est NoProgress, dont nous avons déjà parlé. </font><font style="vertical-align: inherit;">La documentation le dit: c'est un signe que l'interface est implémentée, c'est nul.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lecteur n ° 3</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La documentation stipule un ensemble de cas sur la façon de renvoyer correctement l'erreur. </font><font style="vertical-align: inherit;">Ci-dessous, vous pouvez voir trois cas possibles: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m1/ef/si/m1efsipabh8oypgch-7_ni2syc8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons renvoyer une erreur à la fois avec le nombre d'octets soustraits et séparément. </font><font style="vertical-align: inherit;">Mais si tout d'un coup vos données s'épuisent dans votre Reader et que vous ne pouvez pas retourner le EOF [signe de fin] pour le moment (de nombreuses implémentations de la bibliothèque standard fonctionnent exactement comme ça), alors on suppose que vous retournerez EOF au prochain appel consécutif (c'est-à-dire, vous devez laisser aller client). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour le client, cela signifie qu'il n'y a plus de données - ne me revenez plus. </font><font style="vertical-align: inherit;">Si vous retournez zéro et que le client a besoin de données, il devrait revenir vers vous.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader. </font><font style="vertical-align: inherit;">Erreurs</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, selon Reader, ce sont les principales règles importantes. </font><font style="vertical-align: inherit;">Il existe encore un ensemble de petits, mais ils ne sont pas si importants et ne conduisent pas à une telle situation: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xv/iu/az/xviuazv5segzzd5ganrbinp8xli.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de passer en revue tout ce qui concerne Reader, nous devons répondre à la question: est-ce important, des erreurs se produisent-elles souvent dans les implémentations personnalisées? </font><font style="vertical-align: inherit;">Pour répondre à cette question, je me suis tourné vers mon spool pour 1000 référentiels (et là, nous avons obtenu environ 550 implémentations personnalisées). </font><font style="vertical-align: inherit;">J'ai regardé à travers les cent premiers avec mes yeux. </font><font style="vertical-align: inherit;">Bien sûr, ce n'est pas une super-analyse, mais ce que c'est ... J'ai </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
identifié les deux erreurs les plus courantes:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne renvoie jamais EOF;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trop de confiance dans le Reader encapsulé.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encore une fois, c'est un problème de mon point de vue. </font><font style="vertical-align: inherit;">Et pour ceux qui regardent le package io, ce n'est pas un problème. </font><font style="vertical-align: inherit;">Nous en reparlerons. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je voudrais revenir sur une nuance. </font><font style="vertical-align: inherit;">Voir: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/te/3h/9q/te3h9q46okeg22rijrfyxrmi4da.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le client ne doit jamais interpréter la paire 0 et nil comme EOF. </font><font style="vertical-align: inherit;">C'est une erreur! </font><font style="vertical-align: inherit;">Pour Reader, cette valeur n'est qu'une opportunité de laisser aller le client. </font><font style="vertical-align: inherit;">Donc, les deux erreurs que j'ai mentionnées semblent insignifiantes, mais il suffit d'imaginer que vous avez un pipeline multicouche dans la prod et un petit "bagul" sournois glissé au milieu, alors le "coup souterrain" ne prendra pas longtemps - c'est garanti! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selon Reader, pratiquement tout. </font><font style="vertical-align: inherit;">Telles étaient les règles de mise en œuvre de base.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Writer</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À l'autre bout des pipelines, nous avons io.Writer, qui est l'endroit où nous écrivons habituellement les données. </font><font style="vertical-align: inherit;">Une interface très similaire: elle se compose également d'une méthode (Write), leur signature est similaire. </font><font style="vertical-align: inherit;">Du point de vue de la sémantique, l'interface Writer est plus compréhensible: je dirais que telle qu'elle est entendue, elle est écrite. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fq/ya/ls/fqyalshoz2lwp48cs5u8oa9ymdk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La méthode Write prend un octet de tranche et l'écrit dans son intégralité. </font><font style="vertical-align: inherit;">Il a également un ensemble de règles qui doivent être suivies.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le premier concerne le nombre d'octets renvoyés écrits. </font><font style="vertical-align: inherit;">Je dirais que ce n'est pas si strict, parce que je n'ai pas trouvé un seul exemple où cela conduirait à des conséquences critiques - par exemple, à la panique. </font><font style="vertical-align: inherit;">Ce n'est pas très strict car il y a la règle suivante ...</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'implémentation Writer est requise pour renvoyer une erreur lorsque la quantité de données écrites est inférieure à ce qui a été envoyé. </font><font style="vertical-align: inherit;">Autrement dit, l'enregistrement partiel n'est pas pris en charge. </font><font style="vertical-align: inherit;">Cela signifie qu'il n'est pas très important de savoir combien d'octets ont été écrits.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une règle de plus: Writer ne doit en aucun cas modifier la tranche envoyée, car le client continuera de travailler avec cette tranche.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Writer ne doit pas contenir cette tranche (Reader a la même règle). </font><font style="vertical-align: inherit;">Si vous avez besoin de données dans votre implémentation pour certaines opérations, il vous suffit de copier cette diapositive, et c'est tout.</font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/iy/tx/qe/iytxqemg1nabcwxyfzxtgszmjxy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par Reader et Writer, c'est tout.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dendrogramme</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Surtout pour ce rapport, j'ai généré un graphe d'implémentation et l'ai conçu sous forme de dendrogramme. </font><font style="vertical-align: inherit;">Ceux qui veulent en ce moment peuvent suivre ce code QR: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/r2/zp/pq/r2zppqu-0snqu80oqyxxpxakkpc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce dendrogramme a toutes les implémentations de toutes les interfaces du paquet io. </font><font style="vertical-align: inherit;">Ce dendrogramme est nécessaire pour comprendre simplement: quoi et avec quoi vous pouvez rester ensemble dans les pipelines, où et ce que vous pouvez lire, où vous pouvez écrire. </font><font style="vertical-align: inherit;">Je vais toujours y faire référence au cours de mon rapport, veuillez donc vous référer au code QR.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipelines</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons parlé de ce qu'est Reader, io.Writer. Parlons maintenant de l'API qui existe dans la bibliothèque standard pour la construction de pipelines. Commençons par les bases. Peut-être que cela ne sera même intéressant pour personne. Cependant, c'est très important. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous lirons les données du flux d'entrée standard (de Stdin): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zq/tq/4m/zqtq4mfocqntafmpk5m_scirhcm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stdin est représenté dans Go par une variable globale de type file du package os. Si vous regardez le dendrogramme, vous remarquerez que le type de fichier implémente également les interfaces Reader et Writer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En ce moment, nous sommes intéressés par Reader. Nous lirons Stdin en utilisant le même assistant ReadAll que nous avons déjà utilisé.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une nuance concernant cet assistant mérite d'être notée: ReadAll lit Reader jusqu'à la fin, mais il détermine la fin par EOF, selon le signe de la fin dont nous avons parlé. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons maintenant limiter la quantité de données que nous lisons depuis Stdin. Pour ce faire, il existe une implémentation de LimitedReader dans la bibliothèque standard: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qq/dm/hn/qqdmhnj73dfyxpdlrpoffwzimgq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
je voudrais que vous fassiez attention à la façon dont LimitedReader limite le nombre d'octets à lire. On pourrait penser que cette implémentation, ce Wrapper, soustrait tout ce qui se trouve dans le Reader, qu'il enveloppe, puis donne autant que nous voulons. Mais tout fonctionne un peu différemment ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LimitedReader coupe la tranche qui lui est donnée comme argument le long de la limite supérieure. </font><font style="vertical-align: inherit;">Et il passe cette tranche recadrée à Reader, qui l'enveloppe. </font><font style="vertical-align: inherit;">Il s'agit d'une démonstration claire de la façon dont la longueur des données lues est régulée dans les implémentations de l'interface io.Reader.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erreur de retour de fin de fichier</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autre point intéressant: notez comment cette implémentation renvoie une erreur EOF! </font><font style="vertical-align: inherit;">Les valeurs nommées renvoyées sont utilisées ici, et elles sont affectées par les valeurs que nous obtenons du Reader encapsulé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et s'il arrive qu'il y ait plus de données dans le lecteur encapsulé que nous n'en avons besoin, nous attribuons les valeurs du lecteur encapsulé - disons, 10 octets et zéro - car il y a encore des données dans le lecteur encapsulé. </font><font style="vertical-align: inherit;">Mais la variable n, qui diminue (dans l'avant-dernière ligne), dit que nous avons atteint le «bas» - la fin de ce dont nous avons besoin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la prochaine itération, le client devrait revenir - à la première condition, il recevra EOF. </font><font style="vertical-align: inherit;">C'est le cas que j'ai mentionné. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A suivre très prochainement ...</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/kuyjuGk1USY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un peu de publicité :)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Merci de rester avec nous. Aimez-vous nos articles? Vous voulez voir des matériaux plus intéressants? Soutenez-nous en passant une commande ou en recommandant à vos amis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des VPS basés sur le cloud pour les développeurs à partir de 4,99 $</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analogue unique de serveurs d'entrée de gamme que nous avons inventés pour vous: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toute la vérité sur les VPS (KVM) E5-2697 v3 (6 cœurs) 10 Go DDR4 480 Go SSD 1 Gbit / s à partir de 19 $ ou comment diviser le serveur?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (les options sont disponibles avec RAID1 et RAID10, jusqu'à 24 cœurs et jusqu'à 40 Go de DDR4). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2 fois moins cher au centre de données Equinix Tier IV à Amsterdam?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous avons seulement </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV à partir de 199 $</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aux Pays-Bas!</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - à partir de 99 $! </font></font></b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En savoir plus sur la</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> création d'un bâtiment d'infrastructure. </font><font style="vertical-align: inherit;">classe c utilisant des serveurs Dell R730xd E5-2650 v4 coûtant 9 000 euros pour un sou?</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr491462/index.html">Week-end lu: 12 podcasts, stations de radio FM de l'ère du coucher du soleil et applications de méditation</a></li>
<li><a href="../fr491476/index.html">Accéléromètres, magnétomètres et angles d'orientation MEMS</a></li>
<li><a href="../fr491478/index.html">Un nouvel implant pour les aveugles se connecte directement au cerveau</a></li>
<li><a href="../fr491480/index.html">Projet CoVirus MVP - une carte en ligne de l'infection à coronavirus ou un «bouton rouge» dans votre main</a></li>
<li><a href="../fr491482/index.html">Présentation de PowerShell 7.0</a></li>
<li><a href="../fr491486/index.html">Script personnalisé lors de la fermeture du couvercle de l'ordinateur portable et du verrouillage de l'écran sans sommeil</a></li>
<li><a href="../fr491488/index.html">Que signifie être agile?</a></li>
<li><a href="../fr491490/index.html">Comment Gitlab-CI hérite-t-il des variables d'environnement?</a></li>
<li><a href="../fr491494/index.html">L'arnaque grandiose de la science soviétique: pourquoi un vaisseau orbital réutilisable s'est avéré être une fois</a></li>
<li><a href="../fr491496/index.html">Conseils et astuces IntelliJ IDEA: 1. Comparaison de fichiers et de dossiers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>