<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍⚕️ 🤾🏾 🧕🏼 SHISHUA: generator nomor acak semu tercepat di dunia 🦋 📟 🖱️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Enam bulan lalu, saya ingin membuat generator nomor pseudorandom terbaik (PRNG) dengan arsitektur yang tidak biasa. Saya pikir awalnya akan mudah, dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SHISHUA: generator nomor acak semu tercepat di dunia</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/498352/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/ex/bl/5pexblhd_seedlgm8iidkfktef4.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enam bulan lalu, saya ingin membuat generator nomor pseudorandom terbaik (PRNG) dengan arsitektur yang tidak biasa. Saya pikir awalnya akan mudah, dan saat Anda bekerja, tugasnya perlahan akan menjadi lebih kompleks. Dan saya pikir jika saya bisa mempelajari semuanya dengan cukup cepat untuk mengatasi yang paling sulit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang mengejutkan saya, kompleksitas tidak meningkat secara linear. Pengujian byte-kuadrat terbukti sangat sulit! Kemudian sama sulitnya untuk lulus tes diehard. Saya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menerbitkan hasil saat ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk memahami kesulitan apa yang menunggu saya. Namun </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tes PractRand gagal pada saat itu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maka sangat sulit untuk </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lulus ujian BigCrush</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maka sangat sulit untuk mentransfer data 32 terabyte ketika melewati PractRand. </font><font style="vertical-align: inherit;">Kecepatan telah menjadi masalah. </font><font style="vertical-align: inherit;">Itu tidak cukup untuk membuat desain yang menghasilkan sepuluh megabyte per detik, karena melewati PractRand akan memakan waktu satu bulan. </font><font style="vertical-align: inherit;">Tetapi saya harus mengakui bahwa </font><font style="vertical-align: inherit;">sangat sulit untuk </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lulus tes ini dengan kecepatan gigabytes per detik</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika Anda naik ke ketinggian seperti itu ... Anda ingin tahu apakah Anda bisa sampai ke perbatasan Pareto. </font><font style="vertical-align: inherit;">Anda ingin membuat PRNG tercepat di dunia, yang akan lulus tes statistik paling kompleks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya telah berhasil </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel sebelumnya,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saya berbicara tentang apa yang saya pelajari untuk mencapai tujuan saya. </font><font style="vertical-align: inherit;">Dan di sini saya akan memberi tahu Anda bagaimana arsitektur final bekerja.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tujuan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita mulai dengan yang jelas: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kecepatan tergantung pada platform</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Saya fokus pada pengoptimalan untuk arsitektur x86-64 modern (prosesor Intel dan AMD). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk membandingkan kinerja, metrik </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> klasik digunakan </font><font style="vertical-align: inherit;">: ini adalah jumlah siklus prosesor yang dihabiskan untuk menghasilkan satu byte. </font><font style="vertical-align: inherit;">Metrik ini </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dihitung dan dibandingkan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di semua karya kriptografi. </font><font style="vertical-align: inherit;">Cpb yang sedikit lebih rendah di dunia perangkat lunak atau perangkat keras dapat memastikan kemenangan dalam persaingan atau digunakan di situs web di seluruh dunia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk meningkatkan cpb, Anda dapat:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasilkan lebih banyak byte dengan jumlah pekerjaan yang sama,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atau bekerja lebih sedikit untuk menghasilkan jumlah byte yang sama,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atau memparalelkan pekerjaan.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan melakukan semua hal di atas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menurut poin pertama, kita perlu menghasilkan lebih banyak bit pada setiap iterasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya takut mereka akan memberi tahu saya: "Jika tidak memberikan angka 32-bit, maka ini bukan PRSP", atau hal yang sama dengan angka 64-bit. Atau: "PRNG seharusnya hanya untuk arsitektur x86-64," seolah-olah instruksi seperti POPCNT atau register seperti% xmm7 dilarang.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, PRNG adalah rekayasa: generator telah berusaha selama beberapa dekade untuk memeras segala kemungkinan dari prosesor! Ketika ROL muncul, mereka mulai mengandalkannya. Dengan munculnya prosesor 64-bit, mereka mulai mengandalkan% rax. Tentu saja, pada ARM, algoritma tersebut dapat bekerja lebih lambat (meskipun ini masih harus dilihat), namun, PRN 64-bit aktif digunakan bahkan sebelum Android mulai membutuhkan dukungan untuk 64-bit pada 2019! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artinya, area ini berkembang seiring dengan perangkat kerasnya. Dan hari ini, prosesor Intel dan AMD karena </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sudah mendukung operasi 256-bit. RC4 menghasilkan 1 byte, drand48 dapat menghasilkan 4 byte pada satu waktu, pcg64 - 8 byte, dan sekarang kita dapat langsung menghasilkan 32 byte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8 byte bisa berupa angka 64-bit, dan sebagian besar bahasa pemrograman memiliki tipe bawaan untuk ini. </font><font style="vertical-align: inherit;">Tetapi beberapa bahasa menyediakan tipe untuk 16 byte (pengecualian penting adalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__uint128_t</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam C). </font><font style="vertical-align: inherit;">Bahkan lebih sedikit bahasa yang mengetikkan 32 byte (kecuali internal). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi kita bisa mengucapkan selamat tinggal pada prototipe fungsi PRNG yang biasa (contoh dari benchmark </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HWD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vigny </font><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="plaintext hljs">static uint64_t next(void);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai gantinya, Anda dapat membuat generator yang mengisi buffer (contoh dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tolok ukur saya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="plaintext hljs">void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa kerugian dari solusi ini? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika generator Anda menghasilkan 32 byte pada suatu waktu, maka Anda perlu konsumen untuk menyediakan array yang merupakan kelipatan 32 (idealnya selaras dengan 32 byte). </font><font style="vertical-align: inherit;">Meskipun Anda dapat melakukannya tanpa itu, kami hanya akan mengisi buffer. </font><font style="vertical-align: inherit;">Kami akan menghapus data yang tidak terpakai darinya dan mengisinya lagi seperlunya. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penundaan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menjadi tidak dapat diprediksi: beberapa panggilan hanya akan membaca buffer. </font><font style="vertical-align: inherit;">Tapi rata-rata semuanya akan sama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita menghasilkan lebih banyak byte, melakukan jumlah pekerjaan yang sama. </font><font style="vertical-align: inherit;">Bagaimana kita memparalelkannya?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paralelisme</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prosesor menawarkan seperangkat alat paralelisasi yang luar biasa di semua tingkatan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, ini adalah instruksi SIMD (Instruksi Tunggal, Banyak Data). Misalnya, AVX2 secara bersamaan melakukan empat penambahan 64-bit, atau delapan tambahan 32-bit, dll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini telah digunakan dalam kriptografi selama sekitar lima belas tahun. Concurrency menyediakan kinerja luar biasa dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaCha20</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini digunakan oleh kebanyakan primitif penting yang tidak menggunakan AESNI. Sebagai contoh, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NORX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gimli</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dirancang dengan mempertimbangkan paralelisme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baru-baru ini, minat terhadap topik ini juga meningkat dalam komunitas PRNG non-kriptografi. Secara khusus, primitif yang ada yang tidak dirancang untuk SIMD dapat menjadi dasar untuk menciptakan PRN yang sangat cepat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika Sebastiano Vigna mempromosikan arsitektur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 ++-nya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di perpustakaan standar Julia, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ia menemukan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bahwa hasil dari delapan instance PRNG yang kompetitif dan diinisialisasi berbeda dapat digabungkan dengan sangat cepat jika setiap operasi dilakukan secara bersamaan di semua PRNR. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMD hanyalah salah satu level paralelisasi dalam prosesor. Saya sarankan membaca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel sebelumnya tentang topik ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk memiliki ide yang lebih baik, tetapi saya akan memberikan beberapa penjelasan. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalur pipa prosesor</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memungkinkan beberapa instruksi untuk diproses pada tahapan yang berbeda. Jika Anda mengatur urutan pelaksanaannya dengan baik untuk mengurangi ketergantungan antar tahap, Anda dapat mempercepat pemrosesan instruksi.</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eksekusi Superscalar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memungkinkan Anda untuk secara bersamaan memproses bagian-bagian komputasi dari instruksi. </font><font style="vertical-align: inherit;">Tetapi untuk ini mereka seharusnya tidak memiliki ketergantungan baca-tulis. </font><font style="vertical-align: inherit;">Anda dapat mengadaptasi arsitektur untuk mengurangi risiko downtime dengan merekam jauh sebelum membaca. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eksekusi luar biasa</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memungkinkan prosesor untuk menjalankan instruksi tidak dalam urutan, tetapi karena mereka siap, bahkan jika instruksi sebelumnya belum siap. </font><font style="vertical-align: inherit;">Tetapi untuk ini seharusnya tidak ada ketergantungan baca-tulis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan sekarang kita lolos implementasi!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arsitektur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan skema yang disebut semi-SHISHUA. </font><font style="vertical-align: inherit;">Dari mana nama seperti itu berasal akan menjadi semakin jelas saat Anda membaca. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skemanya terlihat seperti ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd8/df1/b8f/bd8df1b8fcfae4897eb4b74f2c6e856f.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan baris demi baris.</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct prng_state {<font></font>
  __m256i state[2];<font></font>
  __m256i output;<font></font>
  __m256i counter;<font></font>
} prng_state;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Negara dibagi menjadi dua bagian, yang ditempatkan di register AVX2 (256 bit). Untuk meningkatkan kecepatan, kami menjaga hasilnya dekat dengan negara itu sendiri, tetapi itu bukan bagian dari negara. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami juga memiliki penghitung 64-bit. Untuk menyederhanakan perhitungan, ini juga merupakan register AVX2. Faktanya adalah bahwa AVX2 memiliki fitur kecil: register biasa (% rax dan sejenisnya) tidak dapat ditransfer langsung ke SIMD melalui MOV, mereka harus melewati RAM (paling sering melalui tumpukan), yang meningkatkan penundaan dan biaya dua instruksi prosesor (MOV pada stack, VMOV dari stack). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita lihat generasi. Mari kita mulai dengan memuat, lalu pergi melalui buffer dan mengisinya dengan 32 byte di setiap iterasi.</font></font><br>
<br>
<pre><code class="plaintext hljs">inline void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size) {<font></font>
  __m256i s0 = s-&gt;state[0], counter = s-&gt;counter,<font></font>
          s1 = s-&gt;state[1],       o = s-&gt;output;<font></font>
  for (__uint64_t i = 0; i &lt; size; i += 4) {<font></font>
    _mm256_storeu_si256((__m256i*)&amp;buf[i], o);<font></font>
    // …<font></font>
  }<font></font>
  s-&gt;state[0] = s0; s-&gt;counter = counter;<font></font>
  s-&gt;state[1] = s1; s-&gt;output  = o;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena fungsinya inline, segera mengisi buffer saat startup memungkinkan prosesor untuk segera menjalankan instruksi tergantung pada ini melalui mekanisme eksekusi yang luar biasa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di dalam loop, kami dengan cepat melakukan tiga operasi negara:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ft</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> main-main</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dd</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maka dari itu nama SHISHUA!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Giliran pertama</font></font></h3><br>
<pre><code class="plaintext hljs">u0 = _mm256_srli_epi64(s0, 1);              u1 = _mm256_srli_epi64(s1, 3);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sayangnya, AVX2 tidak mendukung revs. </font><font style="vertical-align: inherit;">Tapi saya ingin mencampur bit dari satu posisi dalam angka 64-bit dengan bit dari posisi lain! </font><font style="vertical-align: inherit;">Dan shift adalah cara terbaik untuk mewujudkan ini. </font><font style="vertical-align: inherit;">Kami akan bergeser dengan angka ganjil, sehingga setiap bit akan mengunjungi semua posisi 64-bit, dan tidak setengah dari mereka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selama shift, bit hilang, yang mengarah pada penghapusan informasi dari negara kita. </font><font style="vertical-align: inherit;">Ini buruk, Anda harus meminimalkan kerugian. </font><font style="vertical-align: inherit;">Angka ganjil terkecil adalah 1 dan 3, kami akan menggunakan nilai shift yang berbeda untuk meningkatkan perbedaan antara dua bagian. </font><font style="vertical-align: inherit;">Ini akan membantu mengurangi kesamaan korelasi-diri mereka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan bergeser ke kanan, karena bit paling kanan memiliki difusi terendah selama penambahan: misalnya, bit paling tidak signifikan dalam A + B hanyalah XOR dari bit paling tidak signifikan A dan B.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aduk</font></font></h3><br>
<pre><code class="plaintext hljs">t0 = _mm256_permutevar8x32_epi32(s0, shu0); t1 = _mm256_permutevar8x32_epi32(s1, shu1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan menggunakan pencampuran 32-bit, karena memberikan granularitas yang berbeda dibandingkan dengan operasi 64-bit yang kami gunakan di mana-mana (penyelarasan 64-bit dilanggar). Ini juga bisa menjadi operasi lintas-jalur: pengocokan lainnya dapat memindahkan bit dalam 128 bit kiri jika mereka mulai dari kiri, atau dalam 128 bit kanan jika mereka mulai dari kanan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pencampuran Konstanta:</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i shu0 = _mm256_set_epi32(4, 3, 2, 1, 0, 7, 6, 5),<font></font>
        shu1 = _mm256_set_epi32(2, 1, 0, 7, 6, 5, 4, 3);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agar pencampuran benar-benar meningkatkan hasilnya, kami akan memindahkan bagian 32-bit yang lemah (dispersi rendah) dari penambahan 64-bit ke posisi yang kuat, sehingga penambahan selanjutnya akan memperkaya mereka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagian 32-bit low-end dari 64-bit chunk tidak pernah berpindah ke chunk 64-bit yang sama dengan bagian high-order. </font><font style="vertical-align: inherit;">Dengan demikian, kedua bagian tidak tetap berada dalam potongan yang sama, yang meningkatkan pencampuran. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada akhirnya, setiap bagian 32-bit melewati semua posisi dalam lingkaran: dari A ke B, dari B ke C, ... dari H ke A. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda mungkin telah memperhatikan bahwa pencampuran paling sederhana yang memperhitungkan semua persyaratan ini adalah dua 256-bit turnover (putaran masing-masing 96 bit dan 160 bit ke kanan).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita tambahkan potongan 64-bit dari dua variabel sementara - shift dan mixing.</font></font><br>
<br>
<pre><code class="plaintext hljs">s0 = _mm256_add_epi64(t0, u0);              s1 = _mm256_add_epi64(t1, u1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penambahan adalah sumber utama dispersi: dalam operasi ini, bit digabungkan menjadi kombinasi tak tereduksi dari XOR dan ekspresi AND yang didistribusikan melalui posisi 64-bit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menyimpan hasil penambahan dalam keadaan secara permanen menjaga dispersi ini.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi output</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari mana kita mendapatkan output? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sederhana: struktur yang kami buat memungkinkan kami untuk menghasilkan dua bagian keadaan bebas s0 dan s1, yang tidak saling memengaruhi dengan cara apa pun. </font><font style="vertical-align: inherit;">Terapkan XOR pada mereka dan dapatkan hasil yang sepenuhnya acak. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memperkuat independensi antara data yang kami terapkan XOR, kami mengambil hasil parsial: bagian bergeser dari satu negara dan bagian campuran dari yang lain.</font></font><br>
<br>
<pre><code class="plaintext hljs">o = _mm256_xor_si256(u0, t1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini mirip dengan mengurangi ketergantungan baca-tulis antara instruksi dalam prosesor superscalar, seolah-olah u0 dan t1 siap untuk membaca ke s0 dan s1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang diskusikan konternya. Kami memprosesnya di awal siklus. Pertama, ubah status, dan kemudian tambahkan nilai penghitung:</font></font><br>
<br>
<pre><code class="plaintext hljs">s1 = _mm256_add_epi64(s1, counter);<font></font>
counter = _mm256_add_epi64(counter, increment);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa kita pertama-tama mengubah status, dan kemudian memperbarui penghitung? s1 menjadi tersedia lebih awal, ini mengurangi kemungkinan bahwa instruksi selanjutnya yang membacanya akan berhenti di pipa prosesor. Selain itu, urutan ini membantu menghindari ketergantungan langsung dari penghitung baca-tulis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menerapkan penghitung ke s1, dan bukan ke s0, karena mereka berdua mempengaruhi output, bagaimanapun, s1 kehilangan lebih banyak bit karena pergeseran, sehingga membantu untuk "bangkit" setelah pergeseran. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penghitung mungkin tidak mencatat tes PractRand. Tujuan utamanya adalah untuk menetapkan batas bawah 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">byte = 512 exbibytes untuk periode PRNG: kita mulai mengulangi siklus hanya setelah satu milenium bekerja dengan kecepatan 10 gibytes per detik. Tampaknya tidak mungkin terlalu lambat untuk penggunaan praktis pada abad-abad mendatang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kenaikan:</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i increment = _mm256_set_epi64x(1, 3, 5, 7);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angka ganjil dipilih sebagai kenaikan, karena hanya angka coprime dasar yang mencakup seluruh siklus bidang hingga GF (2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), dan semua angka ganjil adalah coprime untuk 2. Dengan kata lain, jika Anda menambah bilangan bulat genap dalam rentang dari 0 hingga 4, kembali ke 0 setelah 4, ternyata urutan 0-2-0-2- ..., yang tidak akan mengarah ke 1 atau 3. Dan kenaikan aneh melewati semua bilangan bulat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk semua angka 64-bit dalam keadaan, kami akan menggunakan angka ganjil yang berbeda, yang selanjutnya akan memisahkan mereka dan sedikit meningkatkan pencampuran. </font><font style="vertical-align: inherit;">Saya memilih angka ganjil terkecil sehingga tidak terlihat ajaib. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inilah cara transisi fungsi dan fungsi keluaran bekerja. </font><font style="vertical-align: inherit;">Bagaimana cara menginisialisasi mereka?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inisialisasi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menginisialisasi keadaan menggunakan digit heksadesimal Φ, bilangan irasional yang paling tidak diperkirakan oleh fraksi.</font></font><br>
<br>
<pre><code class="plaintext hljs">static __uint64_t phi[8] = {<font></font>
  0x9E3779B97F4A7C15, 0xF39CC0605CEDC834, 0x1082276BF3A27251, 0xF86C6A11D0C18E95,<font></font>
  0x2767F0B153D27B7F, 0x0347045B5BF1827F, 0x01886F0928403002, 0xC1D64BA40F335E36,<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ambil biji 256-bit. </font><font style="vertical-align: inherit;">Ini sering dilakukan dalam kriptografi dan tidak membahayakan pekerjaan PRNG non-kriptografi:</font></font><br>
<br>
<pre><code class="plaintext hljs">prng_state prng_init(SEEDTYPE seed[4]) {<font></font>
  prng_state s;<font></font>
  // …<font></font>
  return s;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami tidak ingin mendefinisikan ulang seluruh bagian negara (s0 atau s1) dengan angka awal ini, kami hanya perlu mempengaruhi setengahnya. </font><font style="vertical-align: inherit;">Dengan cara ini kita akan menghindari penggunaan pelemahan angka awal, yang secara tidak sengaja atau sengaja menimbulkan kondisi awal yang diketahui lemah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena kami tidak mengubah setengah dari masing-masing negara, kami mempertahankan kontrol atas 128 bit status. </font><font style="vertical-align: inherit;">Entropi semacam itu sudah cukup untuk memulai dan mempertahankan posisi yang kuat.</font></font><br>
<br>
<pre><code class="plaintext hljs">s.state[0] = _mm256_set_epi64x(phi[3], phi[2] ^ seed[1], phi[1], phi[0] ^ seed[0]);<font></font>
s.state[1] = _mm256_set_epi64x(phi[7], phi[6] ^ seed[3], phi[5], phi[4] ^ seed[2]);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian kami ulangi ( </font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">beberapa kali </font><font style="vertical-align: inherit;">urutan berikut:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalankan langkah-langkah ( </font></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) dari iterasi SHISHUA.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menetapkan satu bagian dari negara bagian ke negara bagian lain, dan bagian yang lain untuk output.</font></font></li>
</ol><br>
<pre><code class="plaintext hljs">for (char i = 0; i &lt; ROUNDS; i++) {<font></font>
  prng_gen(&amp;s, buf, 4 * STEPS);<font></font>
  s.state[0] = s.state[1];<font></font>
  s.state[1] = s.output;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menetapkan hasil keluaran meningkatkan dispersi negara. </font><font style="vertical-align: inherit;">Selama inisialisasi, kerja tambahan dan korelasi keadaan tidak menjadi masalah, karena rangkaian operasi ini dilakukan sekali. </font><font style="vertical-align: inherit;">Kami hanya tertarik pada dispersi selama inisialisasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah mengevaluasi efek pada korelasi nilai awal, saya memilih </font></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font><font style="vertical-align: inherit;">untuk </font><font style="vertical-align: inherit;">nilai dan </font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font><font style="vertical-align: inherit;">untuk </font><font style="vertical-align: inherit;">10. Saya menghitung korelasi dengan menghitung anomali "tidak biasa" dan "mencurigakan" yang timbul dari alat kontrol kualitas PRNG di PractRand.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performa</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sulit untuk mengukur kecepatan karena beberapa alasan:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengukuran jam</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mungkin tidak cukup akurat.</font></font></li>
<li>    <strong></strong>,      , -  ,  -,       .</li>
<li>,        .        <strong></strong>   .</li>
<li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>  </strong></a>:        ,       .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menggunakan instruksi prosesor RDTSC, yang menghitung jumlah siklus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agar siapa pun dapat mereproduksi hasil saya, saya menggunakan mesin virtual berbasis cloud. Ini tidak mengubah tingkat hasil benchmark dibandingkan dengan pengujian lokal. Selain itu, Anda tidak perlu membeli komputer yang sama seperti komputer saya. Akhirnya, ada banyak situasi di mana PRNG diluncurkan di awan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya memilih Google Cloud Platform N2 (prosesor Intel) dan N2D (prosesor AMD). Keuntungan dari GCP adalah bahwa mereka menawarkan server dengan prosesor dari kedua produsen. Pada artikel ini, kami akan fokus pada Intel, tetapi untuk AMD hasilnya akan berada dalam urutan yang sama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mempelajari lebih dalam topik ini, mari kita singkirkan generator kriptografi RC4 lama. Tidak dapat memparalelkan pekerjaan, saya mengerti</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7,5 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (siklus per byte yang dihasilkan). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita jalankan MCG yang sangat populer dan cepat: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lehmer128 PRNG</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">paling sederhana</font></a><font style="vertical-align: inherit;"> , yang lulus tes BigCrush, menunjukkan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wow LUAR BIASA! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian kita akan menjalankan pengembangan terbaru, yang digunakan untuk tabel hash cepat - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wyrand</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,41 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sedikit lebih baik! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beberapa PRSP tidak lulus tes PractRand 32-terabyte, tetapi mereka bekerja dengan sangat cepat. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xoshiro256 +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hanya mencapai 512 mebibytes, tetapi menunjukkan kecepatan yang sangat tinggi: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,34 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perkembangan baru </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RomuTrio lainnya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dia mengklaim sebagai PRNG tercepat di dunia - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,31 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oke, itu sudah cukup. </font><font style="vertical-align: inherit;">Apa yang ditunjukkan semi-SHISHUA? </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,14 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dua kali lebih cepat dari RomuTrio.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c84/f7a/c9f/c84f7ac9fcbc4d4a7b2400ae552522a4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keren. </font><font style="vertical-align: inherit;">Sekarang coba generator cryptographic ChaCha8. </font><font style="vertical-align: inherit;">Dia mencapai ... </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,12 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMD adalah sihir nyata! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk komunitas kriptografi, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini bukan kejutan khusus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">ChaCha8 sangat mudah diparalelkan. </font><font style="vertical-align: inherit;">Ini hanya counter hash dalam kondisi difus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan ingat bagaimana tim bahasa Julia mencoba menggabungkan beberapa contoh arsitektur Vigny untuk membuat PRNG berbasis SIMD yang cepat? </font><font style="vertical-align: inherit;">Mari kita lihat hasilnya menggunakan teknik ini ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 buah Xoshiro256 +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,09 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara teknis, laptop saya bisa mempengaruhi hasilnya. Saya tidak yakin mengapa pengembangan tim Julia lebih cepat dari ChaCha8 di GCP, tetapi lebih lambat saat diuji secara lokal. Di mesin saya, semi-SHISHUA berjalan lebih cepat dari pengembangan tim Julia, tetapi lebih lambat dari ChaCha8. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlu untuk mengalahkan semua pesaing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda mungkin sudah bertanya mengapa kami menyebut generator semi-SHISHUA versi sebelumnya? Karena ternyata mudah untuk menggandakan kecepatan jika Anda menjalankan dua salinan semi-SHISHUA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mirip dengan gagasan perintah Julia, kami secara terpisah menginisialisasi dua PRNG (empat blok negara 256-bit), secara bergantian memasok output dari pekerjaan mereka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi jika kita membuat lebih banyak status, maka kita dapat menghasilkan lebih banyak data, menggabungkan empat status berpasangan:</font></font><br>
<br>
<pre><code class="plaintext hljs">o0 = _mm256_xor_si256(u0, t1);<font></font>
o1 = _mm256_xor_si256(u2, t3);<font></font>
o2 = _mm256_xor_si256(s0, s3);<font></font>
o3 = _mm256_xor_si256(s2, s1);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi kami mendapat SHISHUA, yang menunjukkan kecepatan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,06 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini dua kali lebih cepat dari pesaing tercepat sebelumnya di dunia yang lulus tes PractRand 32-terabyte. </font><font style="vertical-align: inherit;">Hasilnya ada di grafik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya percaya bahwa perkembangannya ternyata kompetitif. </font><font style="vertical-align: inherit;">Ini bekerja lebih cepat di laptop saya - 0,03 cpb, tapi saya akan mematuhi prinsip saya tentang tolok ukur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semoga untuk beberapa minggu lagi generator saya akan tetap di podium tercepat di dunia (silakan lakukan).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kualitas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Generator dengan jujur ​​melewati tes BigCrush dan 32-terabyte PractRand. Dan semuanya berkat empat aliran keluaran. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kerugian dari arsitektur termasuk </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">irreversibilitasnya</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini dapat dilihat dengan mengurangi ke kondisi 4-bit dengan </font></font><code>s0 = [a, b]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>s1 = [c, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dengan bergeser, kita mendapatkan </font></font><code>[0, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>[0, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan dengan mengaduk, </font></font><code>[b, c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>[d, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Baru </font></font><code>s0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sama dengan </font></font><code>[b, c] + [0, a] = [b⊕(a∧c), a⊕c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tapi </font></font><code>s1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sama </font></font><code>[d, a] + [0, c] = [d⊕(a∧c), a⊕c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jika </font></font><code>a = ¬c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lalu, </font></font><code>a⊕c = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>a∧c = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">karena itu, </font></font><code>s0 = [b, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>s1 = [d, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Yaitu, kita mendapatkan dua kombinasi </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang memberi kita keadaan akhir yang sama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus kami, ini bukan masalah, karena penghitung 64-bit juga merupakan bagian dari keadaan. Ternyata siklus minimum 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">71</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">byte (128 byte per transisi negara), yang pada kecepatan 10 gibytes / detik. </font><font style="vertical-align: inherit;">akan bertahan tujuh ribu tahun. </font><font style="vertical-align: inherit;">Ini menyeimbangkan keadaan yang hilang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, meskipun tidak dapat dibalikkan, periode transisi rata-rata antar negara adalah 2 ^ ((256 + 1) ÷ 2). </font><font style="vertical-align: inherit;">Ini memberikan siklus rata-rata </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.135</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> byte (pada kecepatan 10 gibytes / detik. Ini akan bertahan lebih dari satu triliun kali lebih lama daripada alam semesta ada). </font><font style="vertical-align: inherit;">Meskipun saya percaya bahwa siklus menengah terlalu tinggi, karena mereka tidak memberi tahu kami apa-apa tentang kualitas generator. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut adalah hasil benchmark:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generator</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performa</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kualitas</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Korelasi benih</font></font></strong></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHISHUA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,06</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 256 GiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 + x8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,09</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaCha8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB?</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB?</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RomuTrio</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,31</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 +</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,34</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">512 MiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wyrand</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,41</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lehmer128</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,44</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RC4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.48</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
</tbody></table></div><br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kinerja</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Jumlah siklus prosesor yang dihabiskan untuk satu byte yang dihasilkan. </font><font style="vertical-align: inherit;">Diterima di mesin cloud N2 GCP dan N2D (AMD), urutannya sama.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kualitas</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Level di mana generator gagal lulus tes PractRand. </font><font style="vertical-align: inherit;">Jika tidak gagal, ada tanda&gt;. </font><font style="vertical-align: inherit;">Jika hasilnya tidak terbukti, ada tanda tanya.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Korelasi nomor benih</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : PractRand traversal dengan byte bergantian dari delapan aliran dengan nomor benih 0, 1, 2, 4, 8, 16, 32, 64. Kami menggunakan PractRand dengan konvolusi ganda dan pengujian lanjutan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/3f6/f1d/ea73f6f1db25664622785ba127764dbc.png"></div><br>
</li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lebih lanjut</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meskipun dalam kasus kami tidak ada masalah dengan irreversibilitas, kami masih bisa meningkatkan SHISHUA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menurut pendapat saya, PRNG yang ideal memiliki sifat-sifat berikut:</font></font><br>
<br>
<ol>
<li><strong>      </strong>,     2<sup>1024</sup>.      10 /.    10<sup>282</sup>  ,   .    «» (  ).              ,       .  ,      128-  NEON   ARM?  ,      ,     .</li>
<li><strong>    </strong>.      ,   SHISHUA  XOR    .     ,     .</li>
<li><strong>  ,</strong>      2<sup>128</sup>    (     ).        SHISHUA,  ,  .  ,      ( )    (, , .  2).</li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inisialisasi negara memiliki dispersi sempurna</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : semua bit dari angka awal mempengaruhi semua bit negara dengan probabilitas yang sama. </font><font style="vertical-align: inherit;">Saya ingin mencari tahu sehubungan dengan SHISHUA.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu masalah yang menghambat pengembangan PRNG dan kriptografi secara keseluruhan adalah kurangnya alat tujuan umum yang lebih baik. </font><font style="vertical-align: inherit;">Saya membutuhkan alat yang dapat segera memberi saya hasil pengukuran yang tepat sehingga saya dapat membandingkan berbagai arsitektur dengan cepat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, PractRand sangat bagus dibandingkan dengan yang sebelumnya:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu tidak memungkinkan mengevaluasi generator berkualitas tinggi, sehingga tidak mungkin untuk membandingkan mereka satu sama lain. </font><font style="vertical-align: inherit;">Kita harus mengatakan: "baiklah, setelah 32 terabyte mereka tidak memiliki anomali ..."</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Butuh berminggu-minggu untuk menjalankannya ...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya harap situasinya akan segera membaik.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id498332/index.html">Implementasi Arsitektur Keamanan Tepercaya Nol: Edisi Kedua</a></li>
<li><a href="../id498334/index.html">Cara mengatur proses perencanaan di SAP Analytics Cloud</a></li>
<li><a href="../id498340/index.html">Tentang Beranda IDA baru (ulasan)</a></li>
<li><a href="../id498346/index.html">GoLand 2020.1 - Dukungan yang ditingkatkan untuk Modul Go, banyak penyelesaian otomatis, dan banyak lagi</a></li>
<li><a href="../id498350/index.html">Bahan terbaik untuk wawancara kerja dan pencarian kerja</a></li>
<li><a href="../id498354/index.html">Cara menerjemahkan "Wishlist" menjadi "perangkat keras", atau semi-mobile semi-ideal semi-mobile</a></li>
<li><a href="../id498358/index.html">Pelajari bahasa Prancis atau cara mendapatkan adaptor universal dari pemindai diagnostik PSA</a></li>
<li><a href="../id498360/index.html">Evaluasi Metrik Muat Server Terpadu</a></li>
<li><a href="../id498362/index.html">Kingston mempertahankan kepemimpinan dalam pengiriman SSD: bagaimana kita melakukannya?</a></li>
<li><a href="../id498366/index.html">Algoritma apa yang diterapkan pengembang Yandex setiap hari</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>