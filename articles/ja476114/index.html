<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍⚖️ ✍🏻 🕸️ Pythonがないとどうなりますか？機械学習向けのJuliaと一般 🏐 🔮 🤟🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私たちは常に迅速にコードを書きたいと思っていますが、その代償を払わなければなりません。通常の高水準の柔軟な言語では、プログラムは迅速に開発できますが、起動後の実行速度は遅くなります。たとえば、純粋なPythonで重いものを読むのは非常に遅くなります。 Cライクな言語ははるかに高速に動作しますが、間違...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Pythonがないとどうなりますか？機械学習向けのJuliaと一般</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/476114/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは常に迅速にコードを書きたいと思っていますが、その代償を払わなければなりません。通常の高水準の柔軟な言語では、プログラムは迅速に開発できますが、起動後の実行速度は遅くなります。たとえば、純粋なPythonで重いものを読むのは非常に遅くなります。 Cライクな言語ははるかに高速に動作しますが、間違いを犯しやすくなります。これを検索すると、速度の向上がすべて失われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、このジレンマは次のように解決されます。最初に、PythonやRなどの柔軟なものでプロトタイプを記述し、次にC / C ++またはFortranでそれを書き換えます。しかし、このサイクルは長すぎます。それなしで済ますことができますか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c0/hu/mw/c0humwwihszecprm5u7-j1ofego.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく解決策があります。</font><font style="vertical-align: inherit;">Juliaは、高水準で柔軟かつ高速なプログラミング言語です。</font><font style="vertical-align: inherit;">Juliaには、複数のディスパッチ、統合されたスマートコンパイラ、およびメタプログラミングツールがあります。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleb Ivashkevich</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がJuliaの内容について詳しく説明します</font><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">phtRaveller</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）datarythmicsの創設者であり、以前は物理学者であった業界や他の業界向けの機械学習システムを開発しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Glebは、なぜ新しい言語が必要なのか、なぜPythonがないのかを説明します。</font><font style="vertical-align: inherit;">彼はジュリアの何が面白いか、その長所と短所について教え、他の言語と比較し、その言語が機械学習とコンピューティングの一般的な見通しを持っていることを示します。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">免責事項 </font><font style="vertical-align: inherit;">構文解析は行われません。</font><font style="vertical-align: inherit;">Habrazhiteliは経験豊富な開発者なので、たとえばループの記述方法を示すことは意味がありません。</font></font></em><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/REVmhiJ1Zi8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つの言語の問題</font></font></h2><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを速く書くと、プログラムの実行速度が遅くなります。</font><font style="vertical-align: inherit;">プログラムが高速に動作する場合は、長時間プログラムを記述してください。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラシックPythonは最初のカテゴリに分類されます。 NumPyを削除する場合は、純粋なPythonでゆっくりと検討してください。一方、CやC ++のような言語があります。バランスを見つけるのは難しいため、たいていの場合、最初に柔軟なもののプロトタイプを作成し、アルゴリズムをデバッグした後、より速く言語に書き換えます。これは、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つの言語</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">での</font><strong><font style="vertical-align: inherit;">明確な問題の</font></strong><font style="vertical-align: inherit;">例です。たとえば、Pythonで記述し、CまたはCythonで書き直す必要がある長いサイクルです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機械学習とデータサイエンスの専門家は、NumPy、Sklearn、TensorFlowを持っています。彼らはCで1行も使用せずに長年にわたって問題を解決してきましたが、2つの言語の問題はそれらに関係していないようです。これはそうではありません、問題は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暗黙的です</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NumPyまたはTensorFlowのコードは実際には実際にはPythonではないためです。中身を起動するメタ言語として使用されます。内部は正確にC / Fortran（NumPyの場合）またはC ++（TensorFlowの場合）です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この「機能」は、たとえばPyTorchではあまり見えませんが、Numpyでははっきりと見えます。たとえば、古典的なPythonサイクルが計算</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">発生した場合</font><font style="vertical-align: inherit;">、何かがうまくいってい</font><font style="vertical-align: inherit;">ませ</font><font style="vertical-align: inherit;">ん。生産的なコードでは、ループは必要ありません。NumPyがベクトル化してすばやく計算できるように、すべてを書き直す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、NumPyは高速で、すべてがうまく機能しているようです。これを確認するために、NumPyの内部の内容を見てみましょう。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NumPyはPythonの型の柔軟性の問題を修正しようとしているため、かなり</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">厳密な型システムを</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">持っています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">配列に特定のタイプがある場合、それ以外に</font></font><code>Float64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は何もない可能性が</font><font style="vertical-align: inherit;">あります。そこにある場合、それ</font><font style="vertical-align: inherit;">に対して何も実行できません。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">派遣。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列のタイプと実行する必要のある操作に応じて、NumPy自体が、計算をできるだけ高速にするために呼び出す関数を決定します。</font><font style="vertical-align: inherit;">ライブラリは、古典的なPythonを計算ループから除外しようとします。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Numpyは見かけほど速くないことがわかりました。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cython</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numbaの</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ようなプロジェクトがあるのはそのため</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">1つ目はPythonとCの「ハイブリッド」からCコードを生成し、2つ目はPythonでコードをコンパイルします。通常、これはより高速です。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NumPyが実際に多くの人に思われるほど高速である場合、CythonとNumbaの存在は意味がありません。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大きくて複雑なものをすばやく見つけたい場合は、Cythonですべてを書き換えます。</font><font style="vertical-align: inherit;">Cythonのラッパーの品質基準の1つは、生成されたコードでの純粋なPython呼び出しの有無です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純な例：タイプを追加する（良い）または追加しない（悪い）と、2つの完全に異なるコードを取得します。ただし、タイプに加えて、初期オプションは同じです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/23/nj/e0/23nje0ddwbpf8c9debfufjvg0h8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cコードを生成すると、最初のケースでは次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs">__pyx_t_4 = __pyx_v_i;<font></font>
__pyx_v_result = (__pyx_v_result + (*((<span class="hljs-keyword">double</span> *) ( <span class="hljs-comment">/* dim=0 */</span> (__pyx_v_a.data + __pyx_t_4 * __pyx_v_a.strides[<span class="hljs-number">0</span>]) ))));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして二番目にそれ</font></font><code>result =0.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">これ</font><font style="vertical-align: inherit;">に変わります：</font></font><br>
<br>
<pre><code class="cpp hljs">__pyx_t_6 = PyFloat_FromDouble((*((<span class="hljs-keyword">double</span> *) ( <span class="hljs-comment">/* dim=0 */</span> (__pyx_v_a.data + __pyx_t_4 * __pyx_v_a.strides[<span class="hljs-number">0</span>]) )))); <span class="hljs-keyword">if</span> (unlikely(!__pyx_t_6)) __PYX_ERR(<span class="hljs-number">0</span>, <span class="hljs-number">9</span>, __pyx_L1_error)<font></font>
__Pyx_GOTREF(__pyx_t_6);<font></font>
__pyx_t_7 = PyNumber_InPlaceAdd(__pyx_v_result, __pyx_t_6); <span class="hljs-keyword">if</span> (unlikely(!__pyx_t_7)) __PYX_ERR(<span class="hljs-number">0</span>, <span class="hljs-number">9</span>, __pyx_L1_error)<font></font>
__Pyx_GOTREF(__pyx_t_7);<font></font>
__Pyx_DECREF(__pyx_t_6); __pyx_t_6 = <span class="hljs-number">0</span>;<font></font>
__Pyx_DECREF_SET(__pyx_v_result, __pyx_t_7);<font></font>
__pyx_t_7 = <span class="hljs-number">0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプを指定すると、Cコードは高速で実行されます。</font><font style="vertical-align: inherit;">タイプが指定されていない場合、通常のPythonが表示されますが、C側から見ます。標準のPython呼び出しでは、何らかの理由で</font></font><code>float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から</font><font style="vertical-align: inherit;">作成さ</font><font style="vertical-align: inherit;">れ</font></font><code>double</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、リンクがカウント</font><font style="vertical-align: inherit;">さ</font><font style="vertical-align: inherit;">れ</font><font style="vertical-align: inherit;">、他の多くのガベージコードが含まれます。</font><font style="vertical-align: inherit;">すべての操作でPythonを呼び出すため、このコードは低速です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての問題を一度に解決することは可能ですか</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
面白いことに、私たちは純粋なPythonを削除しようとしています。</font><font style="vertical-align: inherit;">これを行う方法には2つのオプションがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cython</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">やその他のツールを。</font><font style="vertical-align: inherit;">さまざまな方法でCythonコードを最適化して、Python呼び出しをほとんど行わないようにすることができます。</font><font style="vertical-align: inherit;">しかし、これは最も楽しいアクティビティではありません。Cythonですべてが明らかであるとは限りません。Cですべてを書き込む場合よりも少しだけ時間が費やされます。結果のモジュールはPythonで使用できますが、それでも長い間、エラーが発生し、コードは常に明白ではありません。それを最適化する方法が常に明確であるとは限りません。</font></font></li>
<li><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JITコンパイル</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を行うNumbaを使用し</font><font style="vertical-align: inherit;">ます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、もっと良い方法があるかもしれません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジュリア</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">だと思います</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジュリア</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作成者は、これは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高速</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高レベル</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">柔軟な</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">言語であり、コードの記述が容易な点でPythonに匹敵すると</font><font style="vertical-align: inherit;">主張して</font><font style="vertical-align: inherit;">います。私の意見では、ジュリアは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スクリプト言語の</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ような</font><font style="vertical-align: inherit;">ものです。データ構造を含め、すべてが非常に低レベルであるCでやらなければならないことはありません。同時に、Pythonや他の言語のように、通常のコンソールで作業できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジュリアは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジャストインタイムのコンパイルを</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用しています</font><font style="vertical-align: inherit;">-これはスピードを与える要素の1つです。しかし、言語はそれらのために開発されたので、計算に適しています。ジュリアは科学的なタスクに使用され、まともなパフォーマンスを得ます。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juliaは汎用言語のように見せかけようとしていますが、Juliaはコンピューティングには適していますが、Webサービスにはあまり適していません。</font><font style="vertical-align: inherit;">たとえば、Djangoの代わりにJuliaを使用することは最良の選択ではありません。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリミティブ関数の例として、言語の特徴を見てみましょう。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> f(x)<font></font>
    α = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>x
<span class="hljs-keyword">end</span><font></font>
<font></font>
julia&gt; methods(f)<font></font>
<span class="hljs-comment"># 1 method for generic function "f":</span>
[<span class="hljs-number">1</span>] f(x) <span class="hljs-keyword">in</span> Main at mpconf.jl:<span class="hljs-number">2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードでは4つの機能が顕著です。</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unicodeの使用に関する制限はほとんどありません</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ディープラーニングまたは数値モデリングに関する記事から式を取り、同じ文字で書き直すと、すべてが機能します。Unicodeはほとんどどこでも縫い付けられています。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乗算記号はありません。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ただし、それがなくても常に実行できるとは限りません。たとえば、2.x（浮動小数点数x倍）の場合、ジュリアは誓います。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いいえ</font></font><code>return</code></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">一般に、</font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何が起こっているかを確認</font><font style="vertical-align: inherit;">するために書くことをお勧めします</font><font style="vertical-align: inherit;">が、例ではが返され</font></font><code>α</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。これは、代入が式であるためです。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプはありません</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">速度があれば、ある時点でタイプが表示されるはずです。</font><font style="vertical-align: inherit;">はい、表示されますが、後で表示されます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juliaには、柔軟性とスピードを提供する3つの機能があります。それ</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、複数のディスパッチ、メタプログラミング、並列処理</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">最初の2つについては説明し、並列化は上級ユーザー向けの独立した研究のために残します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数のスケジューリング</font></font></h3><br><font style="vertical-align: inherit;"></font><code>methods(f)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記の例</font><font style="vertical-align: inherit;">
の呼び出し</font><font style="vertical-align: inherit;">は予想外に見えます-関数にはどのようなメソッドがありますか？</font><font style="vertical-align: inherit;">クラスオブジェクトがあり、クラスにはメソッドがあるということに慣れています。</font><font style="vertical-align: inherit;">しかし、ジュリアではすべてが裏返されています。言語には複数のディスパッチが使用されているため、関数にはメソッドがあります。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数のスケジューリングとは、実行される特定の関数のバリアントが、この関数のパラメータータイプのセット全体によって決定されることを意味します。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これが既におなじみの例でどのように機能するかを簡単に説明します。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> f(x)<font></font>
    α = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>x
<span class="hljs-keyword">end</span><font></font>
<font></font>
<span class="hljs-keyword">function</span> f(x::<span class="hljs-built_in">AbstractFloat</span>)<font></font>
    α = <span class="hljs-number">1</span> + sin(x)
<span class="hljs-keyword">end</span><font></font>
<font></font>
julia&gt; methods(f)<font></font>
<span class="hljs-comment"># 2 methods for generic function "f":</span>
[<span class="hljs-number">1</span>] f(x::<span class="hljs-built_in">AbstractFloat</span>) <span class="hljs-keyword">in</span> Main at mpconf.jl:<span class="hljs-number">6</span>
[<span class="hljs-number">2</span>] f(x) <span class="hljs-keyword">in</span> Main at mpconf.jl:<span class="hljs-number">2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプの異なるセットに対する同じ関数のバリアントはメソッドと呼ばれます。コードには2つあります。1つ目はすべての浮動小数点数、2つ目はその他すべてです。最初に関数を呼び出すときに、Juliaは使用するメソッドとそれをコンパイルするかどうかを決定します。すでに呼び出されてコンパイルされている場合は、それが使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juliaではすべてが慣れ親しんでいる方法ではないため、ここでユーザー型に関数を追加できますが、これらはOOPの意味での型メソッドにはなりません。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数は</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他のすべてのもの</font><strong><font style="vertical-align: inherit;">と同じ本格的なオブジェクト</font></strong><font style="vertical-align: inherit;">であるため、それは単に関数が記述されるフィールドになり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正確に何がトリガーされるかを見つけるために、特別なマクロがあります。彼らはで始まる</font></font><code>@</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。例のマクロでは</font></font><code>@which</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のケースで呼び出されたメソッドを見つけることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nu/ix/ih/nuixiha2x9r2b148gdqyo81fkri.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のケースでは、ジュリアは2は整数なのでそれ</font></font><code>AbstractFloat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は適合しないと判断し、最初のオプションを呼び出しました。</font><font style="vertical-align: inherit;">2番目のケースでは、結局のところ、彼女</font></font><code>Float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はすでに専用バージョンを呼び出していたと</font><font style="vertical-align: inherit;">判断しまし</font><font style="vertical-align: inherit;">た。</font><font style="vertical-align: inherit;">これは、特定のタイプに他のメソッドを追加した場合にほぼ機能します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVMとJIT</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JuliaはLLVMフレームワークを使用してコンパイルします。</font><font style="vertical-align: inherit;">JITコンパイルライブラリは言語パックで提供されます。</font><font style="vertical-align: inherit;">関数が最初に呼び出されると、Juliaは関数がこのタイプのセットで使用されているかどうかを確認し、必要に応じてコンパイルします。</font><font style="vertical-align: inherit;">最初の起動にはしばらく時間がかかりますが、その後はすべてが迅速に機能します。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数は、このパラメーターセットの最初の呼び出し時にコンパイルされます。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラの機能</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVMは優れた製品であるため、</font><strong><font style="vertical-align: inherit;">コンパイラーは合理的に妥当</font></strong><font style="vertical-align: inherit;">です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどの上級開発者は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コンパイルプロセス</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><strong><font style="vertical-align: inherit;">調べて、</font></strong><font style="vertical-align: inherit;">それが生成するものを確認</font><font style="vertical-align: inherit;">でき</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JuliaとNumbaの編集は似てい</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">NumbaではJITデコレーターも作成しますが、Numbaではそれほど多くのことはできず、何を最適化または変更するかを決定できません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーの動作を説明するために、簡単な関数の例を示します。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> f(x)<font></font>
    α = <span class="hljs-number">1</span> + <span class="hljs-number">3</span>x
<span class="hljs-keyword">end</span><font></font>
<font></font>
julia&gt; <span class="hljs-meta">@code_llvm</span> f(<span class="hljs-number">2</span>)<font></font>
<font></font>
define i64 <span class="hljs-meta">@julia_f_35897</span>(i64) {<font></font>
top:<font></font>
  %<span class="hljs-number">1</span> = mul i64 %<span class="hljs-number">0</span>, <span class="hljs-number">3</span>
  %<span class="hljs-number">2</span> = add i64 %<span class="hljs-number">1</span>, <span class="hljs-number">1</span>
  ret i64 %<span class="hljs-number">2</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マクロを</font></font><code>@code_llvm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用すると、生成の結果を確認できます。</font><font style="vertical-align: inherit;">この</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM IR</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、中間表現</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であり、一種のアセンブラーです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードでは、関数の引数に3を掛けています。結果に1が加算され、結果が返されます。</font><font style="vertical-align: inherit;">すべてが可能な限り簡単です。</font><font style="vertical-align: inherit;">たとえば、3を2に置き換えるなど、関数を少し異なる方法で定義すると、すべてが変更されます。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> f(x)<font></font>
    α = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>x
<span class="hljs-keyword">end</span><font></font>
<font></font>
julia&gt; <span class="hljs-meta">@code_llvm</span> f(<span class="hljs-number">2</span>)<font></font>
<font></font>
define i64 <span class="hljs-meta">@julia_f_35894</span>(i64) {<font></font>
top:<font></font>
  %<span class="hljs-number">1</span> = shl i64 %<span class="hljs-number">0</span>, <span class="hljs-number">1</span>
  %<span class="hljs-number">2</span> = or i64 %<span class="hljs-number">1</span>, <span class="hljs-number">1</span>
  ret i64 %<span class="hljs-number">2</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どうやら、違いは何ですか：2、3、10？</font><font style="vertical-align: inherit;">しかし、JuliaとLLVMは、整数の関数を呼び出すと、少し賢くできることを理解しています。</font><font style="vertical-align: inherit;">整数に2を掛けると、1ビット左シフトになります。これは、積よりも高速です。</font><font style="vertical-align: inherit;">しかし、もちろんこれは整数に対してのみ機能し、</font></font><code>Float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1ビット左</font><font style="vertical-align: inherit;">にシフト</font><font style="vertical-align: inherit;">して2を乗算した結果を取得する</font><font style="vertical-align: inherit;">ようには機能しません</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カスタムタイプ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juliaのカスタム型は組み込み型と同じくらい高速です。それらに対して複数のスケジューリングが実行され、組み込み型と同じくらい高速になります。この意味で、複数のディスパッチメカニズムは言語に深く埋め込まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数には型がなく、値だけに型があると期待するのは論理的です。型のない変数自体は単なるマーカーであり、ある種のコンテナーのラベルです。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型システムは階層的です。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具象型の子孫を作成することはできません;抽象型はそれらのみを持つことができます。ただし、抽象型はインスタンス化できません。このニュアンスは誰にとっても魅力的ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語の作者が説明したように、彼らがジュリアを開発したとき、彼らは結果を得たいと思っていました、そして、何かが難しい場合は、それを拒否しました。このような階層型システムは開発が容易でした。これは致命的な問題ではありませんが、最初に頭を裏返しにしないと不便です。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型はパラメータ化できます</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、C / C ++に少し似ています。たとえば、フィールドが存在する構造がある場合がありますが、これらのフィールドのタイプは指定されていません-これらはパラメーターです。インスタンス化時に特定のタイプを指定します。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどの場合、タイプはスキップできます</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。通常、これらは、型がコンパイラーが最適なコンパイル方法を推測するのに役立つときに必要です。この場合、タイプを指定することをお勧めします。パフォーマンスを向上させたい場合は、タイプも指定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何が可能で何がインスタンス化できないかを見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0r/xr/bl/0rxrbllszhjk9okl1-3irj1zdns.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のタイプ</font></font><code>AbstractPoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はインスタンス化できません。これは、たとえばメソッドで指定できる、すべての人の共通の親にすぎません。 2行目は、次のように述べてい</font></font><code>PlanarPoint{T}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。これは、この抽象的なポイントの子孫です。フィールドの下から始まります-ここでは、パラメーター化を確認できます。ここ</font></font><code>float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">置く</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か、別のタイプに</font><font style="vertical-align: inherit;">することができ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のタイプはインスタンス化できず、他のすべてのタイプでは子孫を作成できません。また、デフォルトでは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">影響を</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受けません</font><font style="vertical-align: inherit;">。フィールドを変更できるようにするには、これを明示的に指定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての準備ができたら、続行できます。たとえば、さまざまなタイプのポイントの距離を計算できます。この例では、平面上の最初の点は</font></font><code>PlanarPoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それから球と円柱の上に。</font><font style="vertical-align: inherit;">距離を計算する2つのポイントに応じて、異なる方法を使用する必要があります。</font><font style="vertical-align: inherit;">通常、関数は次のようになります。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> describe(p::AbstractPoint)<font></font>
    println(<span class="hljs-string">"Point instance: <span class="hljs-variable">$p</span>"</span>)
<span class="hljs-keyword">end</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それは次のようになります。</font></font><code>Float64</code><font style="vertical-align: inherit;"></font><code>Float32</code><font style="vertical-align: inherit;"></font><code>Float16</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> distance(pf::PlanarPoint{T}, ps::PlanarPoint{T}) <span class="hljs-keyword">where</span> T&lt;:<span class="hljs-built_in">AbstractFloat</span>
    sqrt((pf.x-ps.x)^<span class="hljs-number">2</span> + (pf.y-ps.y)^<span class="hljs-number">2</span>)
<span class="hljs-keyword">end</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
整数の場合、距離の計算方法は次のようになります。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> distance(pf::PlanarPoint{T}, ps::PlanarPoint{T}) <span class="hljs-keyword">where</span> T&lt;:<span class="hljs-built_in">Integer</span><font></font>
    abs(pf.x-ps.x) + abs(pf.y-ps.y)<font></font>
<span class="hljs-keyword">end</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各タイプのポイントについて、異なるメソッドが呼び出されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ya/8n/_d/ya8n_dvihkdqpsmqfkmdl5wm_ro.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不正行為をした場合、たとえば、を適用した場合</font></font><code>distance(f1, i2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ジュリアは次のように誓います。</font><font style="vertical-align: inherit;">あなたは私にそのような方法を尋ね、それらは両方とも同じタイプであると言いました。</font><font style="vertical-align: inherit;">あるパラメーター</font></font><code>float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と別の</font><font style="vertical-align: inherit;">パラメーターの数を数える方法を教えてくれませんでした</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。」</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速度</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「JITコンパイルがあります。書き込みは簡単で、すぐに動作します。</font><font style="vertical-align: inherit;">Pythonを捨てて、ジュリアで書き始めてください！」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、それほど単純ではありません。</font><font style="vertical-align: inherit;">Juliaのすべての機能が高速になるとは限りません。</font><font style="vertical-align: inherit;">それは2つの要因に依存します。</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発者から</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">関数が高速になる言語はありません。</font><font style="vertical-align: inherit;">経験の浅い開発者は、経験豊富な開発者のPythonコードよりもはるかに遅いCでコードを書くことさえできます。</font><font style="vertical-align: inherit;">どの言語にも、パフォーマンスが依存する独自のトリックとニュアンスがあります。</font><font style="vertical-align: inherit;">コンパイラーは、それが通常の静的であるかJITであるかに関係なく、考えられるすべてのオプションを提供し、すべてを最適化することはできません。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプ安定性から</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">高速バージョンでは、タイプごとに安定している関数がコンパイルされます。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型の安定性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
型の安定性とは何ですか？コンパイラーが型で何が起こるかを十分に確実に推測できない場合、入力に到達するすべてが機能するように、多くのラッパーコードを生成する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
型の安定性を理解するための簡単な例。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ye/83/jv/ye83jvzws3gkfjvobwf6xvtlpaq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機械学習の専門家は、これが通常のreluアクティベーションであると言います。x&gt; 0の場合はそのまま返し、それ以外の場合はゼロを返します。 1つの問題は、疑問符の整数の後のゼロです。つまり、浮動小数点数に対してこの関数を呼び出すと、一方の場合は浮動小数点数が返され、もう一方の場合は整数が返されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーは、関数の引数のタイプだけでは結果のタイプを推測できません。彼はまたその意味を知る必要があります。したがって、多くのコードが生成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、0から1までの100の乱数ごとに100の配列を作成し、正の数と負の数を均等に分散するように0.5だけシフトして、結果を測定します。ここに2つの興味深いポイントがあります。ポイントと機能です。後のドット</font></font><code>rand(100,100)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は「各要素に適用する」ことを意味します。ある種のコレクションとスカラー関数があれば、それに終止符を打つと、ジュリアが残りを行います。これは、通常のコンパイル言語の通常のループと同じくらい効果的であると想定できます。書く必要はありません</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-すべてがあなたのために行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その時点では</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題は</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ありません</font><font style="vertical-align: inherit;">。</font><strong><font style="vertical-align: inherit;">問題は関数自体の内部にあります</font></strong><font style="vertical-align: inherit;">。そのようなマトリックスのためのまともなコンピューターでのそのようなオプションの推定実行時間はマイクロ秒です。しかし、実際には-ミリ秒。これは、このような小さなマトリックスには多すぎます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1行だけを変更します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bt/3g/4t/bt3g4t3kgng3thzuyb75mi_bmzw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数</font></font><code>zero(x)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">executeは、引数と同じ型のゼロを生成します</font></font><code>(x)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">つまり、yの値が何であっても</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、結果のタイプは常にそれ自体のタイプによって認識されます</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引数のタイプのみを調べ、結果のタイプがすでにわかっている場合、これらの関数はタイプが安定しています。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引数の意味を調べる必要がある場合、これらは安定した関数ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーがコードを最適化できる場合、実行時間の差は2桁異なります。 2番目の例では、それは新しい配列に正確に割り当てられただけで、数十バイトだけあり、それ以上はありません。このオプションは、以前のオプションよりもはるかに効果的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Juliaでコードを作成するときに注意する必要がある主なことです。 Pythonのように書くと、Pythonのように動作します。これらの操作がNumPyで行われる場合、ポイントの有無にかかわらずゼロは役割を果たしません。しかし、ジュリアでは、これはパフォーマンスを大きく損なう可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸い、問題が存在するかどうかを確認する方法があります。これはマクロです。</font></font><code>@code_warntype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、これにより、コンパイラーがどの型がどこにあるかを推測し、すべてが正常である場合に最適化できるかどうかを確認できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/jp/xf/bgjpxfne2jxskxqaloz2omljbda.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のバージョン（左）では、コンパイラーはタイプを確認せず、赤で表示します。</font><font style="vertical-align: inherit;">2番目のケースでは、常に</font></font><code>Float64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そのような引数があるため、コードをはるかに短く生成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはまだLLVMではありませんが、ラベルが付けられたJuliaコードです。</font></font><code>return 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>return 0.0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、2桁のパフォーマンスの違いがあります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メタプログラミング</font></font></h3><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メタプログラミングとは、プログラムでプログラムを作成し、外出先で実行することです。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、さまざまな興味深いことを実行できる強力な方法です。典型的な例はDjango ORMで、メタクラスを使用してフィールドが作成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの人は、</font><font style="vertical-align: inherit;">Python of Zenの作者である</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tim Peters</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の免責事項を知ってい</font><font style="vertical-align: inherit;">ます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「メタクラスは、99％のユーザーが心配するべきではない、より深い魔法です。 Pythonでメタクラスが必要かどうか疑問に思っている場合、それらは必要ありません。それらが必要な場合は、その理由と使用方法を正確に理解しています。」</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
メタプログラミングでも状況は似ていますが、ジュリアではずっと深く縫われています。これは言語全体の重要な機能です。 Juliaのコードは他のコードと同じデータ構造であり、式を操作、結合、作成でき、これらすべてが機能します。</font></font><br>
<br>
<pre><code class="julia hljs">julia&gt; x = <span class="hljs-number">4</span>;<font></font>
<font></font>
julia&gt; typeof(:(x+<span class="hljs-number">1</span>))
<span class="hljs-built_in">Expr</span><font></font>
<font></font>
julia&gt; expr = :(x+<span class="hljs-number">1</span>)<font></font>
:(x + <span class="hljs-number">1</span>)<font></font>
<font></font>
julia&gt; expr.head<font></font>
:call<font></font>
<font></font>
julia&gt; expr.args<font></font>
<span class="hljs-number">3</span>-element <span class="hljs-built_in">Array</span>{<span class="hljs-built_in">Any</span>,<span class="hljs-number">1</span>}:<font></font>
  :+<font></font>
  :x<font></font>
 <span class="hljs-number">1</span></code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マクロはジュリアのメタプログラミングツールの1つです</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。私たちはそれらに何かを与え、見て、正しいものを追加し、不要なものを取り除き、結果を出します。</font><font style="vertical-align: inherit;">前のすべての例では、呼び出しを関数に渡し、内部のマクロが呼び出しを解析しました。</font><font style="vertical-align: inherit;">これはすべて、構文ツリーを操作するレベルで発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非常に単純な式を解析できます。たとえば、</font></font><code>(x+1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それが関数呼び出し</font></font><code>+</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（他の多くの言語のように演算子は演算子ではありませんが、関数です）と2つの引数です：1つは記号（コロンは記号であることを意味します）、2つ目は定数です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の簡単なマクロの例：</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">macro</span> named(name, expr)<font></font>
    println(<span class="hljs-string">"Starting <span class="hljs-variable">$name</span>"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">quote</span><font></font>
        $(esc(expr))<font></font>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span><font></font>
<font></font>
julia&gt; <span class="hljs-meta">@named</span> <span class="hljs-string">"some process"</span> x=<span class="hljs-number">5</span>;<font></font>
Starting some process<font></font>
julia&gt; x<font></font>
<span class="hljs-number">5</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、マクロを使用して、データフレームの進行状況インジケーターまたはフィルターが作成されます-これはJuliaの一般的なメカニズムです。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マクロは呼び出し時に実行されませんが、コードの解析時に実行されます。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはジュリアの主要なマクロ機能です。</font><font style="vertical-align: inherit;">関数内のどこかにマクロがある場合、コードを見ながら処理されます。</font><font style="vertical-align: inherit;">したがって、マクロが展開されるミサゴのコンテキストには、ニュアンスがあります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">言語について知っている合計</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジュリアは柔軟で高速な言語です。</font><font style="vertical-align: inherit;">しかし、これらはすべての特性ではありません。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジュリアは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的言語</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">外出先で変数のタイプを変更できます。</font></font></li>
<li><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの通訳のような</font><strong><font style="vertical-align: inherit;">高級言語</font></strong><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">例のような単純な関数でさえ、Cではよりロードされているように見えます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジュリアでは、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JITコンパイラは十分にスマート</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">それはスピードを提供しますが、もちろん、すべてがボタンをクリックする人に依存します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もう1つの速度の要因は、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型の安定性</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">カスタムタイプは複数のディスパッチで機能します。</font></font></li>
<li><strong>     </strong>    ( ).       ,         .    ,    ,    .</li>
<li>Julia  <strong></strong> —      .</li>
</ul><br>
<h2></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エコシステムはありますが、ジュリアは比較的若い言語であるため、少し混乱しています。</font><font style="vertical-align: inherit;">この言語には、機械学習、データサイエンス、数値モデリングに必要な機能がありますが、Pythonのようにパッケージ化されているわけではありません。</font><font style="vertical-align: inherit;">たとえば、Pythonにはパンダがあり、画像のレンダリングまで、データフレームに関連するすべてのものが完全にあります。Juliaでは、同様の機能がいくつかのパッケージに分散されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juliaエコシステムは急速に進化しており、Python 2008の開発段階にあります。</font><font style="vertical-align: inherit;">ちょうどその時、私はPythonで書き始めました、そして、私は現在のJuliaほど数値問題に慣れていませんでした。</font><font style="vertical-align: inherit;">しかし、これは正常な段階であり、若い言語の不便さに耐える必要があります。</font><font style="vertical-align: inherit;">気にしない場合は、すでにJuliaを使用できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PythonとJuliaの条件付き同等物（すべてではない）</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形代数</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Julia自体にあります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">行列の作成、反転、乗算などができます... </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データフレーム</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">いくつかのライブラリがあります。</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DataFrames.jl</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">強力な</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JuliaDB</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリ</font><font style="vertical-align: inherit;">は、クラスターのさまざまなノード上にある分散データフレームを処理できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データフレームのクエリ言語は、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Query.jl</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に個別に</font><strong><font style="vertical-align: inherit;">あり</font></strong><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これはパンダのマスクの類似物です-基準による要素の選択、集計など。</font></font></li>
</ul><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロット</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matplotlib</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">慣れている場合は</font><font style="vertical-align: inherit;">、Juliaのインターフェースを使用して操作できます。しかし</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">インターフェイスもあります</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。VegaLite.jl</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には、汎用の</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plots.jlがあり</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、レンダリング用にバックエンドを選択できます</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。Gadfly.jl</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があり</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディープラーニング</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TensorFlow</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">へのインターフェース</font><font style="vertical-align: inherit;">と、興味深くコンパクトなFlux.jlがあります。ただし、Fluxでは、データの読み込み用に、KerasやTensorFlowのような適応オプティマイザや便利なメカニズムなどの高度なツールはありません。しかし、それを自分で行うことは難しくありません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scikit-learn</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ライブラリの類似物があります。それは機能し、sklearnのモデルを使用できますが、パッケージは他の方法では構造化されており、少し混乱しています。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XGBoost</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用できますが、Juliaには優れたインターフェースがあります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このすべてと一緒に暮らすには？</font></font></h3><br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jupyterで</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
引き続き作業でき</font><font style="vertical-align: inherit;">ます。 IDEはJunoまたはVisual Studioのプラグインのいずれかですが、試していないため評価できません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">鉄</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 GPU / TPUを使用すると、すべてがうまくいきます。 CUDAnative.jlパッケージを使用すると、Julia自体でGPUのカーネルを作成できます。トリッキーなレイヤーをニューラルネットワークに追加する必要があり、すべてがGPUですぐにカウントされるようにする場合は、ほぼ純粋なジュリアコードを記述します。さらにそれは私たちの関心事ではありません、それがどのようにコンパイルされて起動されるか、すべてが私たちなしですでに機能し、そして悪くはありません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">言語互換性：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C、Fortran、Python、およびその他の言語を呼び出すことができます。</font><font style="vertical-align: inherit;">通常、</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォーマットの互換性</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は機能しますが、例外があります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージング</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：パッケージマネージャーはJuliaコンソールにあります。特別なモードでは、パッケージのインストール、削除、更新などを行うことができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">微分可能なプログラミング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、ニューラルネットワークのアーキテクチャは非常に複雑になり、静的グラフも動的グラフも十分でない場合があります。</font><font style="vertical-align: inherit;">外出先で変わるモデル、特に言語があります。</font><font style="vertical-align: inherit;">動的グラフの方が優れています。これは、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作成し</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た静的グラフしかなく、変更できないTensorFlowよりも、PyTorchが研究タスクにとってずっと便利である</font><font style="vertical-align: inherit;">理由の1 </font><strong><font style="vertical-align: inherit;">つでも</font></strong><font style="vertical-align: inherit;">あります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ループや条件付き遷移のあるコードなど、任意のコードから勾配をカウントできるものがあればよいでしょう。</font><font style="vertical-align: inherit;">ジュリアでは、たとえば、外出先でのコンパイルや複数のディスパッチなどの機能により、これらすべてを行うことができます。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動差別化</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を行うパッケージの1つは</font><strong><font style="vertical-align: inherit;">Zygote.jl</font></strong><font style="vertical-align: inherit;">と呼ばれ</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これはFlux.jlの実験的なパッケージです。</font></font><br>
<br>
<pre><code class="julia hljs">julia&gt; <span class="hljs-keyword">using</span> Zygote<font></font>
<font></font>
julia&gt; <span class="hljs-literal">φ</span>(x) = x*sin(x)<font></font>
julia&gt; Zygote.gradient(<span class="hljs-literal">φ</span>, <span class="hljs-literal">π</span>/<span class="hljs-number">2.</span>)<font></font>
(<span class="hljs-number">1.0</span>,)<font></font>
<font></font>
julia&gt; model = Chain(Dense(<span class="hljs-number">768</span>, <span class="hljs-number">128</span>, relu), Dense(<span class="hljs-number">128</span>, <span class="hljs-number">10</span>), softmax)<font></font>
julia&gt; loss(x, y) = crossentropy(model(x), y) + sum(norm, params(model))<font></font>
julia&gt; optimizer = ADAM(<span class="hljs-number">0.001</span>)<font></font>
julia&gt; Flux.train!(loss, params(model), data, optimizer)<font></font>
<font></font>
julia&gt; model = Chain(x -&gt; sqrt(x), x-&gt;x-<span class="hljs-number">1</span>)</code></pre><br><font style="vertical-align: inherit;"></font><code>φ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば条件など、</font><font style="vertical-align: inherit;">
関数</font><font style="vertical-align: inherit;">には何でも</font><font style="vertical-align: inherit;">書き込むことができ</font><font style="vertical-align: inherit;">、パッケージはほとんど常に勾配を計算できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、Zygoteは「ソースからソースへ」の勾配を生成します。関数の表現から、勾配の関数を生成します。これは、同じ方法でコンパイルされ、呼び出されます。</font><font style="vertical-align: inherit;">これは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">微分可能プログラミング</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><strong><font style="vertical-align: inherit;">ます—微分可能プログラミング</font></strong><font style="vertical-align: inherit;"> —どの関数でも、条件付きで逆伝播を行い、勾配降下をトレーニングする任意のアルゴリズムで使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juliaには、その機能により、この方向に利点があります。「ソースからソースへ」はコンパイラレベルで実装でき、言語に縫い込むことができるため、勾配を常に計算できます。</font><font style="vertical-align: inherit;">とにかく、クレイジーなアーキテクチャが可能になります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジュリアを使うかどうか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
既製のモデルを使用する場合は、分類を上に配置して本番環境に送信してください。</font><font style="vertical-align: inherit;">この使用例では、メリットはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、既製の事前トレーニング済みモデルがないアーキテクチャなど、もっと難しいことを行う場合は、それを試してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数値モデリングに携わっている場合は、ぜひ試してみてください。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Juliaの</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
使用を開始するには</font><font style="vertical-align: inherit;">、2つのニュアンスを考慮してください。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントにコードを提供する場合、誰がそれをサポートするかを考えてください。</font><font style="vertical-align: inherit;">ジュリアはまだかなり「ブティック」言語です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスを開発している場合は、APIによって提供され、内部でどのように配置されているかは問題ではありません。</font></font></li>
</ul><br>
<blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Moscow Python Conf++</a>    ,  27   ,          Python  Julia.   ,     ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">telegram-</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>  MoscowPython.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja476104/index.html">無料のMTProxyやその他の種類の無料のプロキシを使用しないでください...</a></li>
<li><a href="../ja476106/index.html">暗号システムプロトコル：Diffie — Hellman、El-Gamal、MTI / A（0）、STS</a></li>
<li><a href="../ja476108/index.html">可変脳</a></li>
<li><a href="../ja476110/index.html">ITにパーソナルブランドが必要な理由</a></li>
<li><a href="../ja476112/index.html">python asyncの開発目標としてのElixir</a></li>
<li><a href="../ja476118/index.html">ゲームのインターフェイスデザイン、Dark Souls 3からHavelリングを描く</a></li>
<li><a href="../ja476122/index.html">宇宙を「聞く」：暗黒物質から彗星チュリュモフまで-Gerasimenko</a></li>
<li><a href="../ja476126/index.html">サーバーのパフォーマンスをテストする方法：いくつかのオープンソースベンチマークの選択</a></li>
<li><a href="../ja476128/index.html">jug.msk.ruミーティングでのKotlinとIntelliJ IDEAのプラグインについてIvan OsipovとYuri Artamonov</a></li>
<li><a href="../ja476134/index.html">MONQ-ロシア出身の監視とAIOps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>