<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📕 😎 🤚 NSA，Ghidra和独角兽 🔏 🏦 👩🏾‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这次，PVS-Studio团队被Ghidra所吸引，Ghidra是一个用于逆向工程的庞大而邪恶的框架，您可以使用该框架分析各种二进制文件并使用它们进行各种可怕的事情。最有趣的不是它可以免费使用或很好地扩展插件，而是由NSA编写并发布在GitHub上的。一方面，NSA似乎有足够的资源来保持代码库的整洁...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>NSA，Ghidra和独角兽</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/504780/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/zb/b9/po/zbb9pocjsbhx8woze4xo8picks0.png" alt="NSA，Ghidra和独角兽"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这次，PVS-Studio团队被Ghidra所吸引，Ghidra是一个用于逆向工程的庞大而邪恶的框架，您可以使用该框架分析各种二进制文件并使用它们进行各种可怕的事情。</font><font style="vertical-align: inherit;">最有趣的不是它可以免费使用或很好地扩展插件，而是由NSA编写并发布在GitHub上的。</font><font style="vertical-align: inherit;">一方面，NSA似乎有足够的资源来保持代码库的整洁。</font><font style="vertical-align: inherit;">另一方面，对它不太熟悉的新贡献者最近可能会意外添加未发现的错误。</font><font style="vertical-align: inherit;">因此，在进行了静态分析之后，我们决定寻找此项目中的弱点。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序幕</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总的来说，PVS-Studio静态分析器在Ghidra项目的Java部分（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">版本9.1.2，提交687ce7f</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）中</font><font style="vertical-align: inherit;">发出651高，904中和909低警告</font><font style="vertical-align: inherit;">。其中，大约一半的高中响应是由</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">V6022</font></a><font style="vertical-align: inherit;">诊断程序触发的。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在“方法主体”中不使用参数，该参数通常在重构后出现，当不再需要某些参数或某些功能被注释暂时禁用时。快速查看一下这些警告（它们太多了，无法作为外部观察者来查看每个警告） ）在此项目中没有发现任何明显可疑的东西。可能允许该项目在分析器设置中暂时禁用此诊断以免被它分散注意力。实际上，一个人经常会在setter或构造函数参数的名称中遇到错别字，通常来说，它不应该我敢肯定，大多数读者至少会遇到一次类似的不愉快模式：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{
  <span class="hljs-keyword">private</span> String value;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">(String val)</span> </span>{ <span class="hljs-comment">// V6022</span>
    <span class="hljs-keyword">this</span>.value = value;<font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> value.hashCode(); <span class="hljs-comment">// NullPointerException</span><font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
低警告的一半以上是由</font><font style="vertical-align: inherit;">“变量的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V6008</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">潜在的空取消引用” </font><font style="vertical-align: inherit;">诊断产生的</font><font style="vertical-align: inherit;">-例如，通常使用值</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">File.getParentFile（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不检查</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果在没有绝对路径</font><font style="vertical-align: inherit;">的情况下</font><font style="vertical-align: inherit;">构造了调用此方法的文件对象，则将返回</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且缺少验证可能会丢弃该应用程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
按照传统，我们将仅分析高中级别的警告，因为其中包含了大量实际错误。使用分析器报告时，我们始终建议您按可靠性的降序对警告进行分析。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，我们考虑分析仪指示的一些片段，这些片段对我来说似乎可疑或有趣。</font><font style="vertical-align: inherit;">事实证明，该项目的代码库规模巨大，几乎不可能手动找到这些地方。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片段1：验证无效</font></font></h2><br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parseDataTypeTextEntry</span><span class="hljs-params">()</span>
<span class="hljs-keyword">throws</span> InvalidDataTypeException </span>{<font></font>
  ...<font></font>
  <span class="hljs-keyword">try</span> {<font></font>
    newDataType = parser.parse(selectionField.getText(),<font></font>
                               getDataTypeRootForCurrentText());<font></font>
  }<font></font>
  <span class="hljs-keyword">catch</span> (CancelledException e) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span> (newDataType != <span class="hljs-keyword">null</span>) {
    <span class="hljs-keyword">if</span> (maxSize &gt;= <span class="hljs-number">0</span>
        &amp;&amp; newDataType.getLength() &gt; newDataType.getLength()) { <span class="hljs-comment">// &lt;=</span>
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidDataTypeException(<span class="hljs-string">"data-type larger than "</span>
                                         + maxSize + <span class="hljs-string">" bytes"</span>);<font></font>
    }<font></font>
    selectionField.setSelectedValue(newDataType);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-Studio警告：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V6001</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在'&gt;'运算符的左侧和右侧有相同的子表达式'newDataType.getLength（）'。 DataTypeSelectionEditor.java data66 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此类提供用于选择支持自动完成的数据类型的图形组件。使用此组件的开发人员可以设置所选数据类型的最大允许大小（通过</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxSize</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段</font><font style="vertical-align: inherit;">），也可以通过设置负值使其不受限制。假定在验证输入的数据时，超出限制将引发异常，然后将异常捕获到调用堆栈中，并向用户显示一条消息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
似乎该组件的作者在编写此测试时就分心了，或者也许他在思考生命的意义，但是最后，根本就没有进行验证，因为该数字永远不能大于其本身，因此我们忽略了这种情况。这意味着该组件可以提供无效数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在另外两个类中发现了另一个类似的错误：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GuidUtil</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NewGuid</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuidUtil</span> </span>{<font></font>
  ...<font></font>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuidInfo <span class="hljs-title">parseLine</span><span class="hljs-params">(...)</span> </span>{<font></font>
    ...<font></font>
    <span class="hljs-keyword">long</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">4</span>];<font></font>
    ...<font></font>
    <span class="hljs-keyword">if</span> (isOK(data)) {
      <span class="hljs-keyword">if</span> (!hasVersion) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GuidInfo(guidString, name, guidType);<font></font>
      }<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> VersionedGuidInfo(guidString, version, name, guidType);<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
  }<font></font>
  ...<font></font>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOK</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] data)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; data.length; i++) {
      <span class="hljs-keyword">if</span> ((data[i] != <span class="hljs-number">0</span>) || (data[i] != <span class="hljs-number">0xFFFFFFFFL</span>)) { <span class="hljs-comment">// &lt;=</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<font></font>
  }<font></font>
  ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-Studio </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警告</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">V6007</font></a><font style="vertical-align: inherit;">表达式'data [i]！= 0xFFFFFFFFL'始终为true。 GuidUtil.java:200 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的循环</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISOK</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">检查该相同值不同时等于两个不同的数字。如果是这样，则GUID立即被识别为有效。也就是说，仅当</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组为</font><font style="vertical-align: inherit;">空时，</font><font style="vertical-align: inherit;">GUID才是无效的</font><font style="vertical-align: inherit;">，并且永远不会发生，因为在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parseLine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法的开始处，仅对一次分配了相应变量的值</font><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">IsOK</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
方法</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主体</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这两个类中它完全重合，这表明了另一种错误代码的复制粘贴的想法。</font><font style="vertical-align: inherit;">我不确定作者到底想检查什么，但是我可以假定应按以下方式修复此方法：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOK</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] data)</span> </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; data.length; i++) {
    <span class="hljs-keyword">if</span> ((data[i] == <span class="hljs-number">0</span>) || (data[i] == <span class="hljs-number">0xFFFFFFFFL</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片段2：隐藏异常</font></font></h2><br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putByte</span><span class="hljs-params">(<span class="hljs-keyword">long</span> offsetInMemBlock, <span class="hljs-keyword">byte</span> b)</span>
<span class="hljs-keyword">throws</span> MemoryAccessException, IOException </span>{
  <span class="hljs-keyword">long</span> offsetInSubBlock = offsetInMemBlock - subBlockOffset;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">if</span> (ioPending) {
      <span class="hljs-keyword">new</span> MemoryAccessException(<span class="hljs-string">"Cyclic Access"</span>); <span class="hljs-comment">// &lt;=</span><font></font>
    }<font></font>
    ioPending = <span class="hljs-keyword">true</span>;<font></font>
    doPutByte(mappedAddress.addNoWrap(offsetInSubBlock / <span class="hljs-number">8</span>),<font></font>
              (<span class="hljs-keyword">int</span>) (offsetInSubBlock % <span class="hljs-number">8</span>), b);<font></font>
  }<font></font>
  <span class="hljs-keyword">catch</span> (AddressOverflowException e) {
    <span class="hljs-keyword">new</span> MemoryAccessException(<span class="hljs-string">"No memory at address"</span>); <span class="hljs-comment">// &lt;=</span><font></font>
  }<font></font>
  <span class="hljs-keyword">finally</span> {<font></font>
    ioPending = <span class="hljs-keyword">false</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-Studio警告：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V6006</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已创建对象，</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">但未使用</font></a><font style="vertical-align: inherit;">该对象。可能没有'throw'关键字：'new MemoryAccessException（“ Cyclic Access”）'。 BitMappedSubMemoryBlock.java:99 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所知，异常对象本身不执行任何操作（或至少不应执行任何操作）。几乎总是，它们的新实例是通过</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw抛出的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在极少数情况下-转移到某个地方或放在集合中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
包含此方法的类是对存储块的包装，该存储块允许读取和写入数据。在这里，由于没有引发异常，因此</font><i><font style="vertical-align: inherit;">可能会违反</font></i><font style="vertical-align: inherit;">使用</font><i><font style="vertical-align: inherit;">ioPending</font></i><font style="vertical-align: inherit;">标志对当前内存块进行访问的限制</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，还将忽略</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AddressOverflowException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，数据可以被静默破坏，并且开发人员将收到必须由调试器进行分析的奇怪工件，而不是明确指示特定位置的错误。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些丢失的异常中有八种：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BitMappedSubMemoryBlock.java：第77、99、106、122行</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ByteMappedSubMemoryBlock.java：第52、73、92、114行</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特征是在同一文件中存在极其相似的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抛出</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最有可能的是，一种方法最初是与上述片段类似地编写的，之后被复制了几次，以某种方式发现了错误，并在他们可以记住的地方纠正了该错误。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片段3：雷区</font></font></h2><br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelection</span><span class="hljs-params">(OptionsTreeNode selectedNode)</span> </span>{
  <span class="hljs-keyword">if</span> (selectedNode == <span class="hljs-keyword">null</span>) {<font></font>
    setViewPanel(defaultPanel, selectedNode); <span class="hljs-comment">// &lt;=</span>
    <span class="hljs-keyword">return</span>;<font></font>
  }<font></font>
  ...<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setViewPanel</span><span class="hljs-params">(JComponent component, OptionsTreeNode selectedNode)</span> </span>{<font></font>
  ...<font></font>
  setHelpLocation(component, selectedNode);<font></font>
  ...<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHelpLocation</span><span class="hljs-params">(JComponent component, OptionsTreeNode node)</span> </span>{<font></font>
  Options options = node.getOptions();<font></font>
  ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-Studio </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警告</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">V6008</font></a><font style="vertical-align: inherit;">函数'setViewPanel'中'selectedNode'的空取消引用。 OptionsPanel.java:266 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分析器撒了谎-目前，调用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">processSelection</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><i><font style="vertical-align: inherit;">不会</font></i><font style="vertical-align: inherit;">导致</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullPointerException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为此方法仅被调用了两次，并且在调用之前，</font><font style="vertical-align: inherit;">显式检查</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selectedNode是否</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。不应这样做，因为另一个开发人员可以看到该方法显式处理了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selectedNode == null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的情况</font><font style="vertical-align: inherit;">，并确定这是一个有效值，这将导致应用程序崩溃。这样的惊喜在开放项目中尤其危险，因为不了解代码库的人会完全参与其中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，我必须说整个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">processSelection</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">看起来很奇怪。</font><font style="vertical-align: inherit;">这可能是一个复制粘贴错误，因为在相同的方法中，尽管条件不同，但具有相同主体的if块会再遇到两次。</font><font style="vertical-align: inherit;">但是，此时，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selectedNode</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不再为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setViewPanel-setHelpLocation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用链</font><font style="vertical-align: inherit;">不会导致</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullPointerException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片段4：自动完成以作恶用</font></font></h2><br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] UNSUPPORTED_OPCODES_LIST = { ... };
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;Integer&gt; UNSUPPORTED_OPCODES = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<font></font>
<font></font>
<span class="hljs-keyword">static</span> {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> opcode : UNSUPPORTED_OPCODES) {<font></font>
    UNSUPPORTED_OPCODES.add(opcode);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-Studio警告：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V6053</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正在进行迭代时，将修改集合。 ConcurrentModificationException可能会发生。 DWARFExpressionOpCodes.java:205 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，分析器再次撒了谎-不会引发异常，因为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNSUPPORTED_OPCODES</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集合</font><font style="vertical-align: inherit;">始终为空，并且循环根本不会执行。另外，碰巧集合是多种多样的，添加一个已经存在的元素不会改变它。作者很可能输入</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for-each</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过自动完成收集的名称，并且没有注意到提出了错误的字段。</font><font style="vertical-align: inherit;">不可能在迭代过程中修改集合，但是在良好的情况下（如在这种情况下），应用程序可能不会崩溃。</font><font style="vertical-align: inherit;">在这里，这种错字有间接的影响：解析DWARF文件的机器在发现不受支持的操作码时将依赖此集合来停止分析。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从Java 9开始，值得将标准库的工厂方法用于常量集合：例如，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Set.of（T ... elements）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不仅更加方便，而且可以立即使创建的集合不可变，从而提高了代码的可靠性。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片段5：应有尽有</font></font></h2><br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValueAt</span><span class="hljs-params">(Object aValue, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> column)</span> </span>{<font></font>
  ...<font></font>
  <span class="hljs-keyword">int</span> index = indexOf(newName);
  <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {                  <span class="hljs-comment">// &lt;=</span><font></font>
    Window window = tool.getActiveWindow();<font></font>
    Msg.showInfo(getClass(), window, <span class="hljs-string">"Duplicate Name"</span>,
                 <span class="hljs-string">"Name already exists: "</span> + newName);
    <span class="hljs-keyword">return</span>;<font></font>
  }<font></font>
<font></font>
  ExternalPath path = paths.get(row); <span class="hljs-comment">// &lt;=</span><font></font>
  ...<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String name)</span> </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; paths.size(); i++) {<font></font>
    ExternalPath path = paths.get(i);<font></font>
    <span class="hljs-keyword">if</span> (path.getName().equals(name)) {
      <span class="hljs-keyword">return</span> i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-Studio警告：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V6007</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式'index&gt; = 0'始终为true。</font><font style="vertical-align: inherit;">ExternalNamesTableModel.java:105</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6019</a> Unreachable code detected. It is possible that an error is present. ExternalNamesTableModel.java:109</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作者对此进行了考虑，并且在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indexOf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法中</font><i><font style="vertical-align: inherit;">，</font></i><font style="vertical-align: inherit;">对于未知值</font><i><font style="vertical-align: inherit;">，</font></i><font style="vertical-align: inherit;">不是“ index” -1而是返回0- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paths</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集合的第一个元素的索引</font><font style="vertical-align: inherit;">。即使集合为空。或者可能是生成了方法，但是忘记更改默认返回值。结果，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setValueAt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><i><font style="vertical-align: inherit;">将</font></i><font style="vertical-align: inherit;">丢弃传递给它的任何值，并向用户显示“名称已存在”错误，即使没有名称也是如此。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顺便说一句，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indexOf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会在其他任何地方使用，仅在确定您要查找的元素是否存在时才需要它的值。也许，而不是单独的方法，</font><font style="vertical-align: inherit;">直接在</font><i><font style="vertical-align: inherit;">setValueAt中</font></i><font style="vertical-align: inherit;">编写</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for-each</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并</font><i><font style="vertical-align: inherit;">返回</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在匹配项上，而不是带有索引的游戏上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意：我无法重现所谓的错误。</font><font style="vertical-align: inherit;">仅在某些情况下，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不再使用或调用</font><i><font style="vertical-align: inherit;">setValueAt</font></i><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片段6：保持沉默</font></font></h2><br>
<pre><code class="java hljs"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Map&lt;Character, String&gt; DELIMITER_NAME_MAP = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">20</span>);
<span class="hljs-comment">// Any non-alphanumeric char can be used as a delimiter.</span>
<span class="hljs-keyword">static</span> {<font></font>
  DELIMITER_NAME_MAP.put(<span class="hljs-string">' '</span>, <span class="hljs-string">"Space"</span>);<font></font>
  DELIMITER_NAME_MAP.put(<span class="hljs-string">'~'</span>, <span class="hljs-string">"Tilde"</span>);<font></font>
  DELIMITER_NAME_MAP.put(<span class="hljs-string">'`'</span>, <span class="hljs-string">"Back quote"</span>);<font></font>
  DELIMITER_NAME_MAP.put(<span class="hljs-string">'@'</span>, <span class="hljs-string">"Exclamation point"</span>);<font></font>
  DELIMITER_NAME_MAP.put(<span class="hljs-string">'@'</span>, <span class="hljs-string">"At sign"</span>);<font></font>
  DELIMITER_NAME_MAP.put(<span class="hljs-string">'#'</span>, <span class="hljs-string">"Pound sign"</span>);<font></font>
  DELIMITER_NAME_MAP.put(<span class="hljs-string">'$'</span>, <span class="hljs-string">"Dollar sign"</span>);<font></font>
  DELIMITER_NAME_MAP.put(<span class="hljs-string">'%'</span>, <span class="hljs-string">"Percent sign"</span>);<font></font>
  ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-Studio警告：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V6033</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已经添加了具有相同键“ @”的项目。 FilterOptions.java:45 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ghidra支持在各种上下文中过滤数据：例如，您可以按名称过滤项目文件列表。另外，同时实现了通过几个关键字的过滤：'.java，.c'处于'OR'模式时，显示名称包含'.java'或'.c'的所有文件。可以理解，任何特殊字符都可以用作单词分隔符（在过滤器设置中选择了特定的分隔符），但实际上没有感叹号。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此类初始化表中，密封起来非常容易，因为它们通常是使用复制粘贴编写的，并且当您查看此类代码时，您的眼睛很快就会模糊。</font><font style="vertical-align: inherit;">如果错别字不在两条相邻的线上，那么用手肯定几乎没人会看到。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片段7：除法余数始终为0</font></font></h2><br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setFactorys</span><span class="hljs-params">(FieldFactory[] fieldFactorys,
                 DataFormatModel dataModel, <span class="hljs-keyword">int</span> margin)</span> </span>{<font></font>
  factorys = <span class="hljs-keyword">new</span> FieldFactory[fieldFactorys.length];<font></font>
<font></font>
  <span class="hljs-keyword">int</span> x = margin;
  <span class="hljs-keyword">int</span> defaultGroupSizeSpace = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; factorys.length; i++) {<font></font>
    factorys[i] = fieldFactorys[i];<font></font>
    factorys[i].setStartX(x);<font></font>
    x += factorys[i].getWidth();<font></font>
    <span class="hljs-comment">// add in space between groups</span>
    <span class="hljs-keyword">if</span> (((i + <span class="hljs-number">1</span>) % defaultGroupSizeSpace) == <span class="hljs-number">0</span>) { <span class="hljs-comment">// &lt;=</span><font></font>
      x += margin * dataModel.getUnitDelimiterSize();<font></font>
    }<font></font>
  }<font></font>
  width = x - margin * dataModel.getUnitDelimiterSize() + margin;<font></font>
  layoutChanged();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-Studio警告：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V6007</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式'（（（i + 1）％defaultGroupSizeSpace）== 0'始终为true。</font><font style="vertical-align: inherit;">ByteViewerLayoutModel.java:66</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V6048</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此表达式可以简化。</font><font style="vertical-align: inherit;">该操作中的操作数“ defaultGroupSizeSpace”等于1。ByteViewerLayoutModel.java:66</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
十六进制字节查看器支持选择显示的组的大小：例如，您可以将输出配置为'ffff ffff'或'ff ff ff ff'格式。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setFactorys</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法负责这些组在用户界面中的位置</font><font style="vertical-align: inherit;">。尽管自定义和显示工作正常，但此方法中的循环看起来非常可疑：除以1的余数始终为零，这意味着</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">坐标</font><font style="vertical-align: inherit;">将在每次迭代时增加。怀疑</font><font style="vertical-align: inherit;">在设置</font><i><font style="vertical-align: inherit;">DataModel时</font></i><font style="vertical-align: inherit;">添加属性和可用性</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">groupSize</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
重构后还剩下垃圾吗？或者也许</font><i><font style="vertical-align: inherit;">defaultGroupSizeSpace</font></i><font style="vertical-align: inherit;">变量计算丢失了</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font><font style="vertical-align: inherit;">无论如何，尝试用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dataModel.getGroupSize（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">替换其值都会</font><font style="vertical-align: inherit;">破坏布局，也许只有这段代码的作者才能给出明确的答案。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片段8：无效的验证，第2部分</font></font></h2><br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">parseArrayDimensions</span><span class="hljs-params">(String datatype,
                                    List&lt;Integer&gt; arrayDimensions)</span> </span>{<font></font>
  String dataTypeName = datatype;<font></font>
  <span class="hljs-keyword">boolean</span> zeroLengthArray = <span class="hljs-keyword">false</span>;
  <span class="hljs-keyword">while</span> (dataTypeName.endsWith(<span class="hljs-string">"]"</span>)) {
    <span class="hljs-keyword">if</span> (zeroLengthArray) {                   <span class="hljs-comment">// &lt;=</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">// only last dimension may be 0</span><font></font>
    }<font></font>
    <span class="hljs-keyword">int</span> rBracketPos = dataTypeName.lastIndexOf(<span class="hljs-string">']'</span>);
    <span class="hljs-keyword">int</span> lBracketPos = dataTypeName.lastIndexOf(<span class="hljs-string">'['</span>);
    <span class="hljs-keyword">if</span> (lBracketPos &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">int</span> dimension;
    <span class="hljs-keyword">try</span> {<font></font>
      dimension = Integer.parseInt(dataTypeName.substring(lBracketPos + <span class="hljs-number">1</span>,<font></font>
                                                          rBracketPos));<font></font>
      <span class="hljs-keyword">if</span> (dimension &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">// invalid dimension</span><font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span> (NumberFormatException e) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
    }<font></font>
    dataTypeName = dataTypeName.substring(<span class="hljs-number">0</span>, lBracketPos).trim();<font></font>
    arrayDimensions.add(dimension);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> dataTypeName;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-Studio警告：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V6007</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式'zeroLengthArray'始终为false。 PdbDataTypeParser.java:278 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此方法解析多维数组的维，并返回解析后剩余的文本或</font><font style="vertical-align: inherit;">无效数据的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。一项验证检查旁边的注释指出，只有最后读取的大小可以为零。分析是从右到左进行的，因此可以理解，“ [0] [1] [2]”是有效的输入文本，而“ [2] [1] [0]”则不是。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，麻烦的是：没有人添加下一个大小为零的检查，并且解析器将吃掉无效数据而没有不必要的问题。您可能应该按以下方式修复try块：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">try</span> {<font></font>
  dimension = Integer.parseInt(dataTypeName.substring(lBracketPos + <span class="hljs-number">1</span>,<font></font>
                                                      rBracketPos));<font></font>
  <span class="hljs-keyword">if</span> (dimension &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">// invalid dimension</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dimension == <span class="hljs-number">0</span>) {<font></font>
    zeroLengthArray = <span class="hljs-keyword">true</span>;<font></font>
  }<font></font>
}<font></font>
<span class="hljs-keyword">catch</span> (NumberFormatException e) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自然地，有可能该效度标准随着时间的推移被证明是不必要的，或者作者的评论具有不同的含义，因此有必要检查阅读的第一维度。</font><font style="vertical-align: inherit;">无论如何，数据验证是任何应用程序的关键部分，必须全权负责。</font><font style="vertical-align: inherit;">其中的错误可能导致应用程序崩溃，并导致安全漏洞，数据泄漏，数据损坏或丢失（例如，如果在查询验证期间跳过SQL注入）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于其余的警告</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
读者可能会注意到发出了很多警告，但很少考虑。在项目中调整Cloc的方式不是很整齐，它计数了大约125万行Java代码（不是空的也没有注释）。事实是，几乎所有警告都极为相似：在这里，他们忘记了检查</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，没有删除那里未使用的旧代码。我并不是真的想通过列出相同的东西来让读者感到厌倦，并且我在文章的开头提到了这种情况的一部分。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一个示例是在</font><font style="vertical-align: inherit;">错误使用</font><i><font style="vertical-align: inherit;">子字符串</font></i><font style="vertical-align: inherit;">方法的情况下</font><font style="vertical-align: inherit;">的五十条警告“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V6009</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数接收到一个奇数参数”</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（CParserUtils.java:280、ComplexName.java:48等）来获取任何分隔符之后的其余字符串。</font><font style="vertical-align: inherit;">开发人员通常希望此分隔符出现在字符串中，而忘记了否则</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indexOf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将返回-1，这是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">substring</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的不正确值</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">自然，如果数据不是从外部验证或接收的，则应用程序崩溃的可能性将大大降低。</font><font style="vertical-align: inherit;">但是，总的来说，这些是我们希望摆脱的潜在危险场所。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，Ghidra对代码的质量感到满意-没有明显的噩梦。</font><font style="vertical-align: inherit;">该代码格式正确，样式非常一致：在大多数情况下，变量，方法以及其他所有内容都被赋予了明确的名称，可以找到解释性的注释，并且存在大量的测试。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自然地，没有问题，其中：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">死代码，很可能在大量重构后仍然存在；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">许多javadocs已经过时了，例如，指示不存在的参数。</font></font></li>
<li><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用IntelliJ IDEA时</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不可能方便开发</font><font style="vertical-align: inherit;">;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">围绕反射构建的模块化系统使导航项目和查找组件之间的依赖关系变得更加困难。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请不要忽视开发人员工具。</font><font style="vertical-align: inherit;">像安全带一样，静态分析不是灵丹妙药，但是它可以帮助防止释放前造成的一些灾难。</font><font style="vertical-align: inherit;">而且没有人喜欢使用登录的软件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的博客中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解其他经过验证的项目</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">而且我们也有一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">试用许可证</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和各种</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于选择</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用分析仪，无需为它付出。</font></font><br>
<br>
<p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a></p><div style="text-align:center;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/eb2/f9c/3bb/eb2f9c3bb5f32f39239298d36431961c.png"></a></div><p></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您想与讲英语的读者分享这篇文章，请使用翻译链接：Nikita Lazeba。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NSA，Ghidra和Unicorns</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN504768/index.html">Yandex中的分析师实习：测试任务分析</a></li>
<li><a href="../zh-CN504770/index.html">Linux游戏发行版</a></li>
<li><a href="../zh-CN504772/index.html">6月1日至7日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN504774/index.html">IT管​​理人员有关IT服务需求变化的调查</a></li>
<li><a href="../zh-CN504776/index.html">在第一年编写游戏引擎：轻松！（几乎）</a></li>
<li><a href="../zh-CN504784/index.html">Sectigo的AddTrust根证书于2020年5月30日到期，这在OpenSSL 1.0.x和GnuTLS客户端中引起了问题</a></li>
<li><a href="../zh-CN504786/index.html">您需要了解的有关缓存的所有信息</a></li>
<li><a href="../zh-CN504790/index.html">机器学习文章精选：2020年5月的案例，指南和研究</a></li>
<li><a href="../zh-CN504792/index.html">值班宿舍。NSPK如何从冠状病毒中拯救其值班室</a></li>
<li><a href="../zh-CN504796/index.html">Udalenka很酷。也许永远留下来？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>