<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏆 💃🏽 🤞🏻 PostgreSQL: Server-side programming in the human language (PL / Perl, PL / Python, PL / v8) 🐇 😋 👩🏼‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Postgres is known for its extensibility, which also applies to support for procedural languages ​​(PL). No one can boast a language with a list of lan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL: Server-side programming in the human language (PL / Perl, PL / Python, PL / v8)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/502254/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Postgres is known for its extensibility, which also applies to support for procedural languages ​​(PL). No one can boast a </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">language with a</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> list of languages ​​of this length, and potentially this list is not at all limited: in order to connect the language to the server, no extra effort is required. You can even come up with your own language and make it a server procedural language. Alterations in the DBMS will not require this. Like so much more, this extensibility has been built into the Postgres architecture from the very beginning. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is possible and sometimes necessary to write PL languages ​​for tasks. Better yet, if someone writes such a framework for writing languages ​​so that you can write not in C, but to choose a language that is more comfortable for a language developer. As with FDW, which </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be written in Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This article was written on the basis of a number of reports and master classes on this topic made by the author at the conferences </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PgConf.Russia 2019</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PgConf.Russia 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DevConf 2017</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is not about exoticism, but about the most common procedural languages ​​PL / Perl, PL / Python and PL / V8 (i.e. JavaScript) and comparing their capabilities with PL / pgSQL.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When are these languages ​​worth using? </font><font style="vertical-align: inherit;">When is SQL and PL / pgSQL missing?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then, when you need to work with complex structures, with algorithms: traversing trees, for example, or when HTML or XML parsing is required, especially when extracting them from archives;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you need to dynamically generate complex SQL (reports, ORM). </font><font style="vertical-align: inherit;">On PL / pgSQL, it’s not only inconvenient, but will also work slower in some cases;</font></font></li>
<li>         Perl  Python,        C/C++,      Perl  Python    .         . ,    Oracle.     ,    Postgres   .    Perl  Python  .</li>
<li>   —    .   , ,   untrusted- (  — . ),    Perlu  Python(3)u,    PL/V8.   Postgres  ,     ,   FDW,    ,         .       .  !</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And one more thing: if you are going to write something in C, then you can make a prototype in these languages ​​that are more adapted to rapid development.</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to embed a language in Postgres</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To implement the language you need: write in C from one to three functions:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HANDLER - a call handler that will execute a function in the language (this is a required part);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INLINE - anonymous block handler (if you want the language to support anonymous blocks);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VALIDATOR - code verification function when creating a function (if you want this verification to be done).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is described in detail in the documentation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“Languages ​​out of the box” and other languages</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are only four languages ​​that are supported “out of the box”: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Tcl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but the tickle is rather a tribute to history: few people use it now, we won’t talk about it anymore. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Perl, PL / Python and, of course, PL / pgSQL are supported by the Postgres community. Support for other non-box languages ​​falls on their </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maintainers</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - companies, communities, or specific developers interested in making the language work inside the DBMS. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> promotes Google. But from time to time </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there are reasons</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doubt the cloudless future of PL / V8. Google’s current PL / V8 project maintainer, Jerry Sievert, is considering postgres server-based JS support based on a different engine (such as QuickJS), as PL / V8 is difficult to build and requires 3-5 GB all sorts of stuff on Linux when building, and this often leads to problems on different OSs. But the PL / V8 is widely used and thoroughly tested. It is possible that PL / JS will appear as an alternative to another JS engine, or for now just as a name, which we will get used to during the transition period. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Java</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is rarely used. I personally did not have a need to write in PL / Java because in PL / Perl and in PL / V8 there is enough functionality for almost all tasks. Even Python does not particularly add features. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / R</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Useful for those who like statistics and love this language. We will not talk about him here either. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Popular languages ​​are not necessarily popular with writing storages: there is PL / PHP, but now it is practically not supported by anyone - there are few who want to write server procedures on it. For the PL / Ruby language, the picture is somehow the same, although the language seems to be more modern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A Go-based procedural language is being developed, see </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Go</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and also, it seems, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Lua</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It will be necessary to study them. For stubborn fans of the shell, there is even </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Sh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , it's hard to even imagine what it might be for. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is at least one domain-specific procedural language (DSL) that is narrowly specialized for its task - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Proxy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which used to be very popular for proxying and balancing server load. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this article, we will cover the main, most commonly used languages. This, of course, is PL / PgSQL, PL / Perl, PL / Python and PL / V8, we will call them </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> below </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Languages ​​“out of the box” are really almost literally installed out of the box - usually the installation is painless. But to install PL / V8, if you did not find a package with the necessary version in the repository of your OS, this is almost a feat, because for this you will have to actually build the entire V8, or, in other words, Chromium. At the same time, the entire development infrastructure will be downloaded from google.com along with V8 itself - count on a couple of gigabytes of traffic. For Postgres 11 under Ubuntu, the PL / V8 package has not yet appeared, only V8 for PG 10 is available in the repository so far. If you want, assemble it by hand. It is also important that the version that you will find in the repository is most likely quite old. At the time of publication of the article, the latest version is 2.3.14.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After the language itself is installed, you must also “create” the language - register it in the system directory. </font><font style="vertical-align: inherit;">This should be done by the team.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> plperl;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(instead of plperl, you can substitute the name of another language, there are certain nuances, see below). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We look at what happened:</font></font><br>
<br>
<pre><code class="plaintext hljs">test_langs=# \x<font></font>
test_langs=# \dL+<font></font>
List of languages<font></font>
-[ RECORD 1 ]-----+---------------------------------<font></font>
Name              | plperl<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plperl_call_handler()<font></font>
Validator         | plperl_validator(oid)<font></font>
Inline handler    | plperl_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       | PL/Perl procedural language<font></font>
-[ RECORD 2 ]-----+---------------------------------<font></font>
Name              | plpgsql<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plpgsql_call_handler()<font></font>
Validator         | plpgsql_validator(oid)<font></font>
Inline handler    | plpgsql_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       | PL/pgSQL procedural language<font></font>
[ RECORD 3 ]-----+---------------------------------<font></font>
Name              | plv8<font></font>
Owner             | postgres<font></font>
Trusted           | t<font></font>
Internal language | f<font></font>
Call handler      | plv8_call_handler()<font></font>
Validator         | plv8_call_validator(oid)<font></font>
Inline handler    | plv8_inline_handler(internal)<font></font>
Access privileges |<font></font>
Description       |</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / pgSQL does not need to be specially created; it is always already in the database. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attention! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL should not be confused with SQL. </font><font style="vertical-align: inherit;">This is a different language. </font><font style="vertical-align: inherit;">However, Postgres can also write functions in plain SQL.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standards</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the world of DBMS, they often talk about compliance with SQL standards. </font><font style="vertical-align: inherit;">Procedural languages ​​also have standards, although they are not talked about so often. </font><font style="vertical-align: inherit;">The </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL / PSM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> standard </font><font style="vertical-align: inherit;">is highly compliant with the DB2 procedural language. </font><font style="vertical-align: inherit;">Its implementation is far from PL / pgSQL, although conceptually they are close. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL / JRT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the standard for Java procedures, and PL / Java is a good match.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trusted and Untrusted Languages</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postgres procedural languages ​​are trusted (TRUSTED) and untrusted (UNTRUSTED). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In TRUSTED languages, there is no possibility of direct work with I / O, including the network, and indeed with system resources. Therefore, such functions can be created by any database user, spoil something and he will not be able to learn too much. Functions in UNTRUSTED languages ​​can only be created by a supervisor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the language interpreter supports such restrictions, then it can be used to create both TRUSTED and UNTRUSTED languages. So with Perl, so there are different languages </font></font><code>plperl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>plperlu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Letter </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the end it gives out the untrusted character of the language. </font><font style="vertical-align: inherit;">Python exists only in an untrusted version. </font><font style="vertical-align: inherit;">PL / v8 - on the contrary, only in trusted. </font><font style="vertical-align: inherit;">As a result, PL / v8 cannot load any modules or libraries from disk, only from the database. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A function in the UNTRUSTED language can do anything: send an email, ping a site, log into a foreign database, and execute an HTTP request. </font><font style="vertical-align: inherit;">TRUSTED languages ​​are limited to processing data from the database. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By TRUSTED include: </font></font><code>plpgsql, plperl, plv8, pljava</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By UNTRUSTED include: </font></font><code>plperlu, pljavau, plpython2u, plpython3u</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Please note: there is no PL / Python like TRUSTED (since you cannot set restrictions on access to resources there), and PLpgSQL and PL / V8 are the other way around: they are not UNTRUSTED. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But Perl and Java are available in both versions.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL vs PL / *</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / pgSQL code natively works with all the data types that Postgres has. Other languages ​​do not have many Postgres types, and the language interpreter takes care of converting the data into an internal representation of the language, replacing obscure types with text. However, he can be helped with the help of TRANSFORM, which I will talk about closer to the end of the article.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Function calls in PL / pgSQL are often more expensive. Functions in other languages ​​can access their libraries without looking at the system catalog. PL / pgSQL cannot work like that. Some queries in PL / pgSQL work for a long time because of the fact that a lot of types are supported: to add two integers, the interpreter needs to realize that he is dealing with integers and not some other exotic types, then decide how to fold them, and only after that actually fold them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since PL / pgSQL is TRUSTED, you cannot work with network and disks from it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When it comes to working with nested data structures, PL / pgSQL has only Postgres tools for working with JSON, which are very cumbersome and unproductive, in other languages, working with nested structures is much simpler and more economical.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / * has its own memory management, and you need to monitor the memory, or maybe limit it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You should carefully monitor the error handling, which is also different for everyone. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But in PL / * there is a global interpreter context, and it can be used, for example, for caching data, including query plans. </font><font style="vertical-align: inherit;">If the language is UNTRUSTED, then the network and drive (s) are available. </font><font style="vertical-align: inherit;">All these languages ​​work with the database, as a rule, through the SPI, but more on that later. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's take a closer look at the features of the PL / * languages.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Perl interpreter is a hefty piece of code in memory, but fortunately, it is not created when the connection is opened, but only when the first stored procedure / function PL / Perl is launched. </font><font style="vertical-align: inherit;">When it is initialized, the code specified in the Postgres configuration parameters is executed. </font><font style="vertical-align: inherit;">Usually, modules are loaded and precomputations are made. </font><font style="vertical-align: inherit;">
If you added to the configuration file while the database is running, make Postgres re-read the configuration. </font><font style="vertical-align: inherit;">In this article, the examples use a module </font><font style="vertical-align: inherit;">to visualize data structures. </font><font style="vertical-align: inherit;">
There are parameters for separate initialization of TRUSTED and UNTRUSTED Perl and, of course, a parameter </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Those who program in Perl know that without </font><font style="vertical-align: inherit;">it is not a language, but one misunderstanding.</font></font><br>
<br>
<code>plperl.on_init= 'use Data::Dumper;'<br>
plperl.on_plperl_init= ' ... '<br>
plperl.on_plperlu_init= ' ... '<br>
plperl.use_strict= on</code><br>
<br><font style="vertical-align: inherit;"></font><code>Data::Dumper</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>use_strict=on</code><font style="vertical-align: inherit;"></font><code>strict</code><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In it, the interpreter is created in the same way the first time it is accessed. And here it is important to immediately decide which python you want: second or third. As you know, Python exists in two popular versions (Python 2 and Python 3), but the problem is that their so-shki do not get along together in one process: there is a conflict by name. If you worked with v2 in one session and then called v3, then Postgres will crash, and for the server process (backend) this will be a fatal error. To access a different version, you need to open another session. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unlike Perl, python cannot be told what to do during initialization. Another inconvenience: single-liners are inconvenient to do. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In all Python functions, two dictionaries are defined - static </font></font><code>SD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and global </font></font><code>GD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Global </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allows</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exchange data with all functions within one backend - which is attractive and dangerous at the same time. </font><font style="vertical-align: inherit;">Each function has a static dictionary. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In PL / Python, you can make subtransactions, which we will discuss below.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is only TRUSTED. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conveniently, JSON data is automatically converted to a JS structure. In PL / V8, as in PL / Python, you can do subtransactions. There is an interface for simplified function calls. This is the only procedural language in question in which </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">window functions can be defined</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . They suggest that they </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be defined on PL / R</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but this language is outside the scope of this article. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And only in PL / V8 is there a execution timeout. True, it is not turned on by default, and if you build PL / V8 by hand, you need to say that it was turned on during assembly, and then you can set timeouts for function calls with the configuration parameter.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialization in PL / V8 looks interesting: since it is trusted, it cannot read the library from disk, it cannot load anything from anywhere. </font><font style="vertical-align: inherit;">He can take everything he needs only from the base. </font><font style="vertical-align: inherit;">Therefore, a stored initializer function is defined that is called when the language interpreter starts. </font><font style="vertical-align: inherit;">The function name is specified in a special configuration parameter:</font></font><br>
<br>
<pre><code class="pgsql hljs">plv8.start_proc=my_init # ( PL/V8-)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
During initialization, global variables and functions can be created by assigning their values ​​to the attributes of the this variable. </font><font style="vertical-align: inherit;">For example, like this:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> my_init()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span> <span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span> $$<span class="php">
     this.get_57 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">57</span>; }; <span class="hljs-comment">//   </span>
     this.pi_square = <span class="hljs-number">9.8696044</span>;  <span class="hljs-comment">//   </span>
$$</span>;
<span class="hljs-keyword">SET</span> plv8.start_proc = <span class="hljs-string">'my_init'</span>;
<span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, pi_square, get_57() );
$$</span>;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparison of PL / Perl vs PL / Python vs PL / V8 in practice</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello World!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's perform a simple exercise with the output of this phrase in all three languages, first in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">And let him do something else useful, for example, tells his version:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     elog(<span class="hljs-keyword">NOTICE</span>,"Hello World! $]");
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  Hello World!<font></font>
DO<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can also use the usual Perl functions </font></font><code>warn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . More precisely on PL / Python3u (untrusted) - for definiteness.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">import</span> sys
     plpy.<span class="hljs-keyword">notice</span>(<span class="hljs-string">'Hello World! '</span> , hint=" ", detail=sys.version_info)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
NOTICE:  Hello World! <font></font>
DETAIL:  sys.version_info(major=3, minor=6, micro=9, releaselevel='final', serial=0)<font></font>
HINT:   <font></font>
DO<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Can use </font></font><code>throw 'Errmsg'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">There are many things you can extract from Postgres messages: they contain Hint, Details, line number, and many other parameters. </font><font style="vertical-align: inherit;">In PL / Python, they can be passed, but not in the other languages ​​under consideration: their means can only be cursed with a plain text line. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In PL / Python, each postgres logging level has its own function: NOTICE, WARNING, DEBUG, LOG, INFO, FATAL. </font><font style="vertical-align: inherit;">If it is ERROR, then the transaction has fallen, if FATAL, the entire backend has fallen. </font><font style="vertical-align: inherit;">Fortunately, the matter did not reach PANIC. </font><font style="vertical-align: inherit;">You can </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">read here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In this language, Hello world is very similar to pearl. </font><font style="vertical-align: inherit;">You can quit </font></font><code>exception</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">using </font></font><code>throw</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and this will also be error handling, although the tools are not as advanced as in Python. </font><font style="vertical-align: inherit;">If you write</font></font><code>plv8.elog(ERROR)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the effect will be, by the way, the same.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, <span class="hljs-string">'Hello World!'</span>, plv8.<span class="hljs-keyword">version</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  Hello World! 2.3.14<font></font>
DO<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Work with the base</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's see how to work with a database from stored procedures. Postgres has an SPI (Server Programming Interface). This is a set of C functions that is available to all extension authors. Almost all PL languages ​​provide wrappers for SPI, but each language does it a bit differently. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A function written in C but using SPI is unlikely to give a significant gain compared to PL / PgSQL and other procedural languages. But a C function that bypasses SPI and works with data without intermediaries (for example </font></font><code>table_beginscan/heap_getnext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) will work an order of magnitude faster.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Java also uses SPI. But working with the database still happens in the style of JDBC and the JDBC standard. For the creator of code in PL / Java, everything happens as if you were working from a client application, but JNI (Java Native Interface) translates calls to the database into the same SPI functions. It is convenient, and there are no fundamental obstacles to translate this principle into PL / Perl and PL / Python, but for some reason this has not been done, and it is not yet visible in the plans. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, if you wish, you can go to foreign bases in the usual way - through DBI or </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Psycopg</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It is possible to local database, but why.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you don’t get into the holistic topic “process in the base vs process on the client”, and immediately proceed from the maximum processing closer to the data (at least in order not to drive giant samples over the network), then the solution to use the functions stored on the server looks naturally. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : keep in mind that SPI has some overhead, and SQL queries in functions may be slower than without functions. The 13th postgres included a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patch by Konstantin Knizhnik</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which reduces these costs. But, of course, the processing of query results in a stored function does not require the transfer of the result to the client, and therefore can be beneficial in terms of performance. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Safety</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: a set of debugged and tested functions isolates the database structure from the user, protects against SQL injections and other mischief. </font><font style="vertical-align: inherit;">Otherwise, it will remain a headache for every application developer. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reuse: if a large number of intricate applications work with the database, it is convenient to store useful functions on the server, rather than writing them again in each application.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How and in what form do we get data from the database</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , everything is simple and clear. </font><font style="vertical-align: inherit;">The call </font></font><code>spi_exec_query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns the number of rows processed, the status and the array of rows selected by the SQL query:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="ruby"> 
     warn Data::Dumper::Dumper(
          spi_exec_query(<span class="hljs-string">'SELECT 57 AS x'</span>)
     )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  $VAR1 = {<font></font>
          'rows' =&gt; [<font></font>
                    {<font></font>
                      'x' =&gt; '57'<font></font>
                    }<font></font>
                  ],<font></font>
          'processed' =&gt; 1,<font></font>
          'status' =&gt; 'SPI_OK_SELECT'<font></font>
        };<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python, the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> query and the result look something like this, but here the function does not return a data structure, but a special object that you can work with in different ways. </font><font style="vertical-align: inherit;">Usually it pretends to be an array and, accordingly, you can extract strings from it.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plpy.<span class="hljs-keyword">notice</span>(
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 AS x'</span>)
     )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  &lt;PLyResult status=5 nrows=1 rows=[{'x': 57}]&gt;<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And now we take the 1st line, get out of there X and get the value - the number.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plpy.<span class="hljs-keyword">notice</span>(
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 AS x'</span>)[<span class="hljs-number">0</span>][<span class="hljs-string">'x'</span>]
      )
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  57<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> 
     plv8.elog(<span class="hljs-keyword">NOTICE</span>, <span class="hljs-type">JSON</span>.stringify(
          plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT 57 as x'</span>))
     );
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  [{"x":57}]<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to see the structure, we used the library function JSON.stringify, which does not need to be loaded specifically, it is already ready for use as part of PL / v8 by default. </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shielding</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To avoid malicious SQL injections, some characters in queries must be escaped. To do this, firstly, there are SPI functions and corresponding functions (written in C) in languages ​​that work like SPI wrappers. For example, in PL / Perl: </font></font><br>
<br>
<code>quote_literal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- takes in apostrophes and doubles' and \. Designed for screening text data. </font></font><br>
<code>quote_nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- same, but </font></font><code>undef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">converted to NULL. </font></font><br>
<code>quote_ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- quotes the name of the table or field, if necessary. Useful in the case when you are constructing an SQL query and substituting the names of the database objects in it. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> <span class="hljs-string">"macy's"</span>;
     <span class="hljs-keyword">warn</span> quote_literal(<span class="hljs-string">"macy's"</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  macy's at line 2.<font></font>
WARNING:  'macy''s' at line 3.<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keep in mind: the table name must not be escaped like a text line. </font><font style="vertical-align: inherit;">That is why there is a function </font></font><code>quote_ident</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But in PL / Perl there are other functions for shielding data of individual post-gres types: </font><font style="vertical-align: inherit;">
A function </font><font style="vertical-align: inherit;">should accept any type and turn atypical doubtful characters into something obviously safe. </font><font style="vertical-align: inherit;">It works with a huge number of types, but, nevertheless, not with all. </font><font style="vertical-align: inherit;">She, for example, will not understand </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">range types</font></a><font style="vertical-align: inherit;"> and perceive them simply as text strings.</font></font><br>
<br>
<code>encode_bytea<br>
decode_bytea<br>
encode_array_literal<br>
encode_typed_literal<br>
encode_array_constructor</code><br>
<br><font style="vertical-align: inherit;"></font><code>quote_typed_literal</code><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> encode_typed_literal(
          [<span class="hljs-string">""</span>, <span class="hljs-string">" "</span>], <span class="hljs-string">"text[]"</span>
     );
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  {," "} at line 2.<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There </font><font style="vertical-align: inherit;">are three similar functions </font><font style="vertical-align: inherit;">in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and they work in much the same way:</font></font><br>
<br>
<code>plpy.quote_literal<br>
plpy.quote_nullable<br>
plpy.quote_ident</code><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql"> plpy.<span class="hljs-keyword">notice</span>(
     plpy.quote_literal("Macy's"));
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;</code></pre><pre><code class="plaintext hljs">NOTICE:  'Macy''s'<font></font>
DO</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Are the functions in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8 the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> same </font><font style="vertical-align: inherit;">? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course! </font><font style="vertical-align: inherit;">Everything is the same up to syntactic features.</font></font><br>
<br>
<code>plv8.quote_literal<br>
plv8.quote_nullable<br>
plv8.quote_ident</code><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
    plv8.elog(<span class="hljs-keyword">NOTICE</span>, plv8.quote_nullable("Macy's"));
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  'Macy''s'</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Which language is the fastest? Usually they answer: C. But the correct answer is C </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SQL. Why SQL? The fact is that a function in this language is not always performed explicitly. It can become embedded in the request (the scheduler will embed the function in the body of the main request), optimize well with the request, and the result will be faster. But under what conditions can code be embedded in a request? There are a few simple conditions that you can read about, say, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . For example, a function should not be executed with the rights of the owner (to be SECURITY DEFINER). Most simple functions will fit these conditions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this article we will measure "on the knee", not seriously. We need a rough comparison. First turn on the timing:</font></font><br>
<br>
<pre><code class="plaintext hljs">\timing</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's try </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (The execution times of the commands below are the rounded average values ​​that the author received on an unloaded six-year-old PC. They can be compared with each other, but they do not claim to be scientific):</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">FROM</span> pg_class;
<span class="hljs-number">0.5</span> ms
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It works very fast. </font><font style="vertical-align: inherit;">In other languages, time is wasted calling functions from the language. </font><font style="vertical-align: inherit;">Of course, the first time the request will run slower due to the initialization of the interpreter. </font><font style="vertical-align: inherit;">Then it stabilizes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's try </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">int</span>;
     <span class="hljs-keyword">BEGIN</span>
          <span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">INTO</span> a <span class="hljs-keyword">FROM</span> pg_class;
     <span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">0.7</span> ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $x = spi_exec_query(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">0.7</span> ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python:</font></font></b><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     x = plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpythonu;
<span class="hljs-number">0.8</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It was Python 2. Now </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (recall: Python2 and Python3 do not live peacefully within the same session, a conflict of names is possible):</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     x = plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">0.9</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And finally, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     var x = plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8 ;
<span class="hljs-number">0.9</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But it is somehow very fast. </font><font style="vertical-align: inherit;">Let's try to execute the query 1000 times or 1 million times, suddenly the difference will be more noticeable: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">int</span>; i <span class="hljs-type">int</span>;
     <span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">0.</span><span class="hljs-number">.999999</span> <span class="hljs-keyword">LOOP</span>
          <span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">INTO</span> a <span class="hljs-keyword">FROM</span> pg_class;
    <span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;
<span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">53</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="ruby">
     <span class="hljs-keyword">for</span> (<span class="hljs-number">0</span>..<span class="hljs-number">999999</span>) {
          spi_exec_query(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     }
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">102</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range (<span class="hljs-number">0</span>,<span class="hljs-number">1000000</span>) :
          plpy.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">98</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">for</span>(var i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)
          plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;
<span class="hljs-number">100</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note that with PL / V8, the experiment was done with a thousand, not a million iterations. With moderate resources, the PL / V8 in a cycle of 1 million operations will eat all the memory and completely hang the car. Already at a thousand iterations, the postgres process selects 3.5GB of memory and 100% write to disk. In fact, postgres launches the V8 environment, and of course it eats memory. After executing the request, this turbo monster is not going to give back memory. To free memory, you have to end the session. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We see that PL / pgSQL is already 2 times faster than PL / Perl and PL / Python. PL / V8 is still slightly behind them, but towards the end of the article he is partially rehabilitated.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, Perl with Python in these experiments show approximately the same results. </font><font style="vertical-align: inherit;">Perl used to be slightly inferior to Python; in modern versions, it is slightly faster. </font><font style="vertical-align: inherit;">The third python is slightly slower than the second. </font><font style="vertical-align: inherit;">The whole difference is within 15%.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance with PREPARE</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
People who know will understand: something is wrong. </font><font style="vertical-align: inherit;">PL / pgSQL can </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">automatically cache query plans</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and in PL / *, each time the query was scheduled again. </font><font style="vertical-align: inherit;">In a good way, you need to prepare requests, build a request plan, and then according to this plan they should be executed as many times as needed. </font><font style="vertical-align: inherit;">In PL / *, you can explicitly work with query plans, which we will try starting with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     <span class="hljs-keyword">for</span> (<span class="hljs-number">0</span>..<span class="hljs-number">999999</span>) {
          spi_exec_prepared($h);
     }
     spi_freeplan($h);
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">60</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     h = plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>)
     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range (<span class="hljs-number">0</span>,<span class="hljs-number">1000000</span>): plpy.<span class="hljs-keyword">execute</span>(h)
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">62</span>s</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     var h=plv8.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT count(*) FROM pg_class'</span>);
     <span class="hljs-keyword">for</span>(var i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++) h.<span class="hljs-keyword">execute</span>();
$$</span> <span class="hljs-keyword">LANGUAGE</span> plv8;
<span class="hljs-number">53</span>ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With </font></font><code>prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">our two languages, we almost caught up with PL / pgSQL, while the third one also wanted to, but did not reach the finish line due to the growing demand for memory. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But if you do not take into account memory, then it is clear that all languages ​​go almost head to head - and not by chance. </font><font style="vertical-align: inherit;">Their bottleneck is now common - working with the database through SPI.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computing performance</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We see that the language performance has rested in working with the database. </font><font style="vertical-align: inherit;">To compare languages ​​with each other, let's try to calculate something without resorting to the database, for example, the sum of the squares. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
     <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">bigint</span>; a <span class="hljs-type">bigint</span>;
     <span class="hljs-keyword">BEGIN</span> a=<span class="hljs-number">0</span>;
     <span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">0.</span><span class="hljs-number">.1000000</span> <span class="hljs-keyword">LOOP</span>
          a=a+i*i::<span class="hljs-type">bigint</span>;
     <span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;
<span class="hljs-keyword">END</span>;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;
<span class="hljs-number">280</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="perl">
     <span class="hljs-keyword">my</span> $a=<span class="hljs-number">0</span>;
     <span class="hljs-keyword">for</span> <span class="hljs-keyword">my</span> $i (<span class="hljs-number">0</span>..<span class="hljs-number">1000000</span>) { $a+=$i*$i; };
     <span class="hljs-keyword">warn</span> $a;
$$</span> <span class="hljs-keyword">LANGUAGE</span> plperl;
<span class="hljs-number">63</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> $$<span class="pgsql">
a=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">1000001</span>): a=a+i*i
$$</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u;
<span class="hljs-number">73</span>ms</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="plaintext hljs">DO $$<font></font>
     var a=0;<font></font>
     for(var i=0;i&lt;=1000000;i++) a+=i*i;<font></font>
     plv8.elog(NOTICE, a);<font></font>
$$ language plv8;<font></font>
7.5ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We see that PL / Perl and PL / Python overtook and overtook PL / pgSQL, they are 4 times faster. </font><font style="vertical-align: inherit;">And the eight is tearing everyone! </font><font style="vertical-align: inherit;">But is it really for nothing? </font><font style="vertical-align: inherit;">Or will we get it for the head? </font><font style="vertical-align: inherit;">Yes, we will. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The number in JavaScript is a float, and the result is fast, but not accurate: 333333833333127550 instead of 333333833333500000. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is the formula by which the exact result is </font><font style="vertical-align: inherit;">calculated </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">∑ = n*(n+1)*(2n+1)/6
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As an exercise, you can prove it using mathematical induction. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the order of laughter</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
plv8.elog(<span class="hljs-keyword">NOTICE</span>, parseInt(<span class="hljs-number">33333383333312755033</span>)) $$</span>;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:<font></font>
33333383333312754000</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Javascript, </font></font><code>parseInt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it still does a float, not an Int. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nevertheless, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BigInt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> appeared in V8 in 2018 </font><font style="vertical-align: inherit;">, and it can now be counted for sure, but with a detriment to speed, since it is not a 64-bit integer, but an integer of arbitrary bit depth. </font><font style="vertical-align: inherit;">However, in PL / V8 this innovation has not yet hit. </font><font style="vertical-align: inherit;">In other procedural languages, arbitrary bit numbers (analogues of SQL </font></font><code>numeric</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) are supported through special libraries. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Perl, there is a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Math :: BigFloat module</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for arithmetic with arbitrary precision, and in Python, the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bigfloat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> package </font><font style="vertical-align: inherit;">is a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cython</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wrapper </font><font style="vertical-align: inherit;">around the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNU MPFR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance functions for sorting</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is a practical example, which shows the difference in the performance of sorting by function, if this function is written in different languages. </font><font style="vertical-align: inherit;">Task: to sort the text fields containing the numbers of the issues of the journal, which may be as follows:</font></font><br>
<br>
<pre><code class="plaintext hljs">1<font></font>
2<font></font>
3<font></font>
4-5<font></font>
6<font></font>
6A<font></font>
6<font></font>
11<font></font>
12<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Those. </font><font style="vertical-align: inherit;">it's actually a string, but it starts with a number, and you need to sort by these numbers. </font><font style="vertical-align: inherit;">Therefore, in order to correctly sort as strings, we supplement the numerical part with zeros on the left to get:</font></font><br>
<br>
<pre><code class="plaintext hljs">0000000001<font></font>
0000000002<font></font>
0000000003<font></font>
0000000004-5<font></font>
0000000006<font></font>
0000000006A<font></font>
0000000006<font></font>
0000000011<font></font>
0000000012<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yes, I know that this is not the only solution to the problem (and not even quite right). </font><font style="vertical-align: inherit;">But for example, it will do. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To request a type, </font></font><code>SELECT ... ORDER BY nsort(n)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we write functions in PL / Perl, SQL, PL / Python, and PL / V8 that convert the journal numbers to this form:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> nsort(<span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> PLPERL <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="perl">
    <span class="hljs-keyword">my</span> $x = <span class="hljs-keyword">shift</span>;
    <span class="hljs-keyword">return</span> ($x =~ <span class="hljs-regexp">/^\s*(\d+)(.*)$/</span>)
        ? <span class="hljs-keyword">sprintf</span>(<span class="hljs-string">"%010d"</span>, $1).$2
        : $x;
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> _nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span>
     <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">SQL</span>  <span class="hljs-keyword">IMMUTABLE</span>  <span class="hljs-keyword">AS</span> $$<span class="pgsql">
 <span class="hljs-keyword">WITH</span> y <span class="hljs-keyword">AS</span> (
    <span class="hljs-keyword">SELECT</span> regexp_match(x,<span class="hljs-string">'^\s*(\d*)(.*)$'</span>) <span class="hljs-keyword">as</span> z
 )
 <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> z[<span class="hljs-number">1</span>] = <span class="hljs-string">''</span> <span class="hljs-keyword">THEN</span> x <span class="hljs-keyword">ELSE</span> lpad(z[<span class="hljs-number">1</span>],<span class="hljs-number">10</span>,<span class="hljs-string">'0'</span>) || z[<span class="hljs-number">2</span>] <span class="hljs-keyword">END</span> <span class="hljs-keyword">FROM</span> y;
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> py_nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> plpython2u <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="pgsql">
<span class="hljs-keyword">import</span> re
r = re.match(<span class="hljs-string">'^\s*(\d+)(.*)$'</span>, x)
<span class="hljs-keyword">return</span> x <span class="hljs-keyword">if</span> r == <span class="hljs-keyword">None</span> <span class="hljs-keyword">else</span> (<span class="hljs-string">'%010d'</span> % <span class="hljs-type">int</span>(r.<span class="hljs-keyword">group</span>(<span class="hljs-number">1</span>))) + r.<span class="hljs-keyword">group</span>(<span class="hljs-number">2</span>)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> js_nsort(x <span class="hljs-type">text</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">text</span> 
   <span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">IMMUTABLE</span> <span class="hljs-keyword">AS</span> $$<span class="ruby">
var m = x.match(<span class="hljs-regexp">/^\s*(\d+)(.*)$/</span>);
<span class="hljs-keyword">if</span>(m) { <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>].padStart(<span class="hljs-number">10</span>-m[<span class="hljs-number">1</span>].length,<span class="hljs-string">'0'</span>) + m[<span class="hljs-number">2</span>]; }
<span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> x; } 
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In my library of 15.5 thousand journal articles, a query using a function in PL / Perl takes about 64ms against 120ms in PL / Python and 200ms in PL / PgSQL. </font><font style="vertical-align: inherit;">But the fastest - PL / v8: 54ms. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> when experimenting with sorting, provide the necessary amount of working memory so that sorting goes in memory (EXPLAIN will then show </font></font><code>Sort Method: quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">The amount of memory is set by the parameter </font></font><code>work_mem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">set</span> work_mem = <span class="hljs-string">'20MB'</span>;
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perl does not like looped structures; he does not know how to clean them. </font><font style="vertical-align: inherit;">If you </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">have a pointer to </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and a </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pointer to </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then the reference counter will never be reset and memory will not be freed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Garbage collection languages ​​have other problems. </font><font style="vertical-align: inherit;">It is not known, for example, when memory will be freed, or whether it will be freed at all. </font><font style="vertical-align: inherit;">Or - if you don’t take care of this on purpose - collectors will go to collect garbage at the most inopportune moment. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But there are also memory management features directly related to Postgres. </font><font style="vertical-align: inherit;">There are structures that SPI allocates, and Perl does not always realize that they need to be freed. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
This is NOT how it goes:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">return</span> spi_exec_query(
           <span class="hljs-string">'SELECT count(*) FROM pg_class'</span>
     )-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And so it goes:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(
          <span class="hljs-string">'SELECT count(*) FROM pg_class'</span>
     );
     <span class="hljs-keyword">return</span> spi_exec_prepared($h)-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After execution, the handler </font></font><code>$h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will remain alive, despite the fact that not a single living link to him remains. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It's okay, you just need to remember the need to explicitly release resources with </font></font><code>spi_freeplan($h)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr()
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span> <span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
     <span class="hljs-keyword">my</span> $h = spi_prepare(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     <span class="hljs-keyword">my</span> $res = spi_exec_prepared($h)-&gt;{rows}-&gt;[<span class="hljs-number">0</span>]-&gt;{count};
     spi_freeplan($h);
     <span class="hljs-keyword">return</span> $res;
$$</span>;</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Python </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">never flows</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the plan is automatically released:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">function</span> cr3() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plpythonu <span class="hljs-keyword">as</span>
$$<span class="pgsql">
     <span class="hljs-keyword">return</span> plpy.<span class="hljs-keyword">execute</span>(
           <span class="hljs-string">'select count(*) from pg_class'</span>
     )[<span class="hljs-number">0</span>][<span class="hljs-string">'count'</span>]
$$</span>;</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Same story as Perl. </font><font style="vertical-align: inherit;">It does not flow like this:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     <span class="hljs-keyword">return</span> plv8.<span class="hljs-keyword">execute</span>(
          <span class="hljs-string">'select count(*) from pg_class‘
     )[0].count;
$$</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And so it goes:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     var h = plv8.<span class="hljs-keyword">prepare</span>(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     <span class="hljs-keyword">return</span> h.<span class="hljs-keyword">execute</span>()[<span class="hljs-number">0</span>].count;
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Again: don't forget about freeing up resources. </font><font style="vertical-align: inherit;">Here it does. </font></font><code>h.free();</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It doesn’t flow:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">int</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span>
$$<span class="pgsql">
     var h = plv8.<span class="hljs-keyword">prepare</span>(
          <span class="hljs-string">'select count(*) from pg_class'</span>
     );
     var r = h.<span class="hljs-keyword">execute</span>()[<span class="hljs-number">0</span>].count;
     h.free();
     <span class="hljs-keyword">return</span> r;
$$</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameters</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It's time to understand how arguments are passed to functions. </font><font style="vertical-align: inherit;">In the examples, we will pass 4 parameters with types to the function:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">whole;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an array;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bytea and</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsonb</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How </font><font style="vertical-align: inherit;">
do they get into </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ?</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq(a <span class="hljs-type">int</span>, b
<span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span> ) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plperl <span class="hljs-keyword">AS</span>
$$<span class="perl">
    <span class="hljs-keyword">warn</span> Dumper(@_);
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> crq(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  $VAR1 = '1';<font></font>
$VAR2 = '\\x61626364';<font></font>
$VAR3 = bless( {<font></font>
                 'array' =&gt; [<font></font>
                              '1',<font></font>
                              '2',<font></font>
                              '3'<font></font>
                            ],<font></font>
                 'typeoid' =&gt; 1007<font></font>
               }, 'PostgreSQL::InServer::ARRAY' );<font></font>
$VAR4 = '{"a": 2, "b": 3}';<font></font>
 crq <font></font>
-----<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Will it be JSON or JSONB - in this case, it makes no difference: they still get in the form of a string. This is a fee for versatility: Postgres has a lot of types, of varying degrees of “embeddedness”. To demand from the developer that with the new type he immediately provides and conversion functions for all PL / * would be too much. By default, many types are passed as strings. But this is not always convenient, you have to parse these terms. Of course, I would like Postgres data to immediately turn into the appropriate Perl structures. By default, this does not happen, but starting from 9.6, the TRANSFORM mechanism appeared - the ability to define type conversion functions: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CREATE TRANSFORM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To create TRANSFORM, you need to write two functions in C: one will convert data of a certain type to one side, the other back. </font><font style="vertical-align: inherit;">Please note, TRANSFORM works in four places:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When passing parameters to a function;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When returning a function value;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When passing parameters to an SPI call inside a function;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Upon receipt of the result of the SPI call inside the function.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TRANSFORM JSONB for Perl and Python, developed by Anton Bykov, appeared in the 11th version of Postgres. </font><font style="vertical-align: inherit;">Now you do not need to parse JSONB, it gets into Perl right away as the corresponding structure. </font><font style="vertical-align: inherit;">You must create the jsonb_plperl extension, and then you can use TRANSFORM:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> jsonb_plperl;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> crq2(d <span class="hljs-type">jsonb</span>)
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span> <span class="hljs-keyword">LANGUAGE</span> plperl
<span class="hljs-keyword">TRANSFORM</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">TYPE</span> <span class="hljs-type">jsonb</span> <span class="hljs-keyword">AS</span> $$<span class="perl">
     <span class="hljs-keyword">warn</span> Dumper(@_);
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can call this function to verify that JSONB has turned into a pearl hash:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> crq2( <span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  $VAR1 = {<font></font>
          'a' =&gt; '2',<font></font>
          'b' =&gt; '3'<font></font>
        };<font></font>
 crq2 <font></font>
------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A completely different matter! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The author of this article also had a hand in developing TRANSFORMs. It turned out that such a simple data type, as </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passed to PL / Perl in an inconvenient form, as text strings </font></font><code>'t'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>'f'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. But in Perl's understanding, the string 'f' is true. To eliminate the inconvenience, a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was invented </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">that defined the conversion for the Boolean type</font></a><font style="vertical-align: inherit;"> . This patch hit PostgreSQL 13 and will be available soon. Due to its simplicity, bool_plperl can serve as a minimal starting model for writing any other conversion. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I hope someone will develop TRANSFORM for other data types (bytea, arrays, dates, numeric). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's see how the parameters are passed in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> jsonb_plpython3u;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> pdump(a <span class="hljs-type">int</span>, b <span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span> ) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plpython3u
<span class="hljs-keyword">TRANSFORM</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">TYPE</span> <span class="hljs-type">jsonb</span> <span class="hljs-keyword">AS</span> $$<span class="pgsql">
      plpy.<span class="hljs-built_in">warning</span>(a,b,c,d)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> pdump(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  (1, b'abcd', [1, 2, 3], {'a': Decimal('2'), 'b': Decimal('3')})<font></font>
 pdump <font></font>
-------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An array is converted to an array - this is good (since version PG10 multidimensional arrays are also correctly transferred to python). </font><font style="vertical-align: inherit;">In Perl, an array was converted to an object of a special class. </font><font style="vertical-align: inherit;">Well, </font></font><code>jsonb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transformed. </font><font style="vertical-align: inherit;">Without TRANSFORM, jsonb will be passed as a string. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's see in what form the parameters get into </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> jsdump(a <span class="hljs-type">int</span>, b <span class="hljs-type">bytea</span>, c <span class="hljs-type">int</span>[], d <span class="hljs-type">jsonb</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">void</span>
<span class="hljs-keyword">LANGUAGE</span> plv8 <span class="hljs-keyword">AS</span> $$<span class="pgsql">
     plv8.elog(<span class="hljs-built_in">WARNING</span>,a,b,c,d)
$$</span>;</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> jsdump(<span class="hljs-number">1</span>,<span class="hljs-string">'abcd'</span>, <span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">'{"a":2,"b":3}'</span>);</code></pre><br>
<pre><code class="plaintext hljs"><font></font>
WARNING:  1 97,98,99,100 1,2,3 [object Object]<font></font>
jsdump <font></font>
-------<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSONB converted to a JavaScript object without any TRANSFORM! </font><font style="vertical-align: inherit;">Temporary Postgres types are also converted to the Date JS type. </font><font style="vertical-align: inherit;">Same thing with boolean. </font><font style="vertical-align: inherit;">All transformations are already built into PL / V8.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Work with infinity</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The INFINITY constant is not used very often, but sloppy work with it is dangerous. </font><font style="vertical-align: inherit;">In PostgreSQL, Infinity and -Infinity exist as special values ​​for some temporary and floating-point types. </font><font style="vertical-align: inherit;">But the transfer of Infinity to procedural languages ​​and vice versa needs to be discussed in detail, since working with them can depend not only on the language, but also on libraries, on the OS and even on the hardware. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python has a Numpy module that defines numerical infinity:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> nm<font></font>
a = nm.inf<font></font>
b = -nm.inf<font></font>
print(a, b)</code></pre><br>
<pre><code class="plaintext hljs">inf -inf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perl also has infinity, it uses a string </font></font><code>"infinity"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that can be shortened to </font></font><code>"inf"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For example, you could say:</font></font><br>
<br>
<pre><code class="perl hljs">perl -e <span class="hljs-string">'print 1 * "inf"'</span></code></pre><br>
<pre><code class="plaintext hljs">Inf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
or</font></font><br>
<br>
<pre><code class="perl hljs">perl -e <span class="hljs-string">'print 1/"inf"'</span></code></pre><br>
<pre><code class="plaintext hljs">0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In PL / Perl, PL / Python, PL / v8, numerical infinity from Postgres is passed correctly, but an infinite date is not quite right. </font><font style="vertical-align: inherit;">Rather, in PL / Perl and PL / Python there is no built-in data type for time, a string comes there. </font><font style="vertical-align: inherit;">In PL / V8, there is a built-in type Date, and the usual date from a postgres turns into it. </font><font style="vertical-align: inherit;">But the V8 does not know the endless date, and when transferred, it turns into </font></font><code>Invalid Date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passing parameters to prepared requests</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Back to </font></font><code>prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, consider how the parameters are passed there. </font><font style="vertical-align: inherit;">Different languages ​​have a lot in common, since they are all based on SPI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When you prepare a query in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , you need to determine the type of parameters that are passed, and when you run the query, you only specify the values ​​of these parameters (the parameters are passed to PL / pgSQL in the same way).</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plperl $$<span class="perl">
     <span class="hljs-keyword">my</span> $h= spi_prepare(<span class="hljs-string">'SELECT * FROM pg_class WHERE
          relname ~ $1'</span>, <span class="hljs-string">'text'</span> );                     <span class="hljs-comment">#   </span>
     <span class="hljs-keyword">warn</span> Dumper(spi_exec_prepared($h, <span class="hljs-string">'pg_language'</span>)); <span class="hljs-comment">#   </span>
     spi_freeplan($h);
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python, the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> essence is the same, but the syntax is slightly different:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plpython3u $$<span class="pgsql">
     h= plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT relname FROM pg_class WHERE relname ~ $1'</span>, [<span class="hljs-string">'text'</span>] )
     plpy.<span class="hljs-keyword">notice</span>(.<span class="hljs-keyword">execute</span> ([<span class="hljs-string">'pg_language'</span>]))
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8, the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> differences are minimal:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="pgsql">
    var h= plv8.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT relname FROM pg_class WHERE relname ~ $1'</span>, [<span class="hljs-string">'text'</span>] );
    plv8.elog(<span class="hljs-keyword">NOTICE</span>, h.<span class="hljs-keyword">execute</span> ([<span class="hljs-string">'pg_language'</span>]));
    h.free();
$$</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Java,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> everything is different. </font><font style="vertical-align: inherit;">There, SPI is clearly not used, but a pseudo-JDBC connection to the database is formed. </font><font style="vertical-align: inherit;">For a PL / Java programmer, everything happens as if he were creating a client application. </font><font style="vertical-align: inherit;">This is convenient, and one could also approach the design of PL / Perl and PL / Python, but for some reason this was not done (however, no one forbids creating a couple more implementations of PL / Perl and PL / Python).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Work with cursor</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All the SPI functions that we used when we went to the database — </font></font><code>spi_exec_query()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and others — have a parameter that limits the number of rows returned. </font><font style="vertical-align: inherit;">If you need a lot of returned rows, then you can’t do without a cursor to pull them up a little. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cursors work in all of these languages. </font><font style="vertical-align: inherit;">In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl,</font></font></b> <br>
<code>spi_exec_query</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> returns a cursor from which you can extract strings one at a time. </font><font style="vertical-align: inherit;">It is not necessary to close the cursor; it will close itself. </font><font style="vertical-align: inherit;">But if you want to rediscover it again, you can explicitly close it with a command </font></font><code>close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plperl $$<span class="perl">
    <span class="hljs-keyword">my</span> $cursor = spi_query(<span class="hljs-string">'SELECT * FROM pg_class'</span>);
    <span class="hljs-keyword">my</span> $row;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">defined</span>($row = spi_fetchrow($cursor))) {
         <span class="hljs-keyword">warn</span> $row-&gt;{relname};
    }
$$</span>;</code></pre><br>
<pre><code class="plaintext hljs">WARNING:  pg_statistic at line 5.<font></font>
WARNING:  pg_toast_2604 at line 5.<font></font>
WARNING:  pg_toast_2604_index at line 5.<font></font>
WARNING:  pg_toast_2606 at line 5.<font></font>
WARNING:  pg_toast_2606_index at line 5.<font></font>
WARNING:  pg_toast_2609 at line 5.<font></font>
WARNING:  pg_toast_2609_index at line 5.<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> everything is very similar, but the cursor is presented as an object that you can cycle through:</font></font><br>
<br>
<pre><code class="pgsql hljs">h = plpy.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT ...'</span>);
<span class="hljs-keyword">cursor</span> = plpy.<span class="hljs-keyword">cursor</span>(h);
<span class="hljs-keyword">for</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">cursor</span>:<font></font>
...<font></font>
<span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>() //  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / v8,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> everything is also very similar, but do not forget to free the prepared query plan:</font></font><br>
<br>
<pre><code class="pgsql hljs">var h = plv.<span class="hljs-keyword">prepare</span>(<span class="hljs-string">'SELECT ...'</span>);<font></font>
var <span class="hljs-keyword">cursor</span> = h.<span class="hljs-keyword">cursor</span>();<font></font>
var <span class="hljs-keyword">row</span>;
<span class="hljs-keyword">while</span>(<span class="hljs-keyword">row</span> = <span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">fetch</span>()) {<font></font>
...<font></font>
}<font></font>
<span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>();<font></font>
h.free();</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8: Quick access to features</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In PL / V8, you can call a function not from a regular SELECT, but find it by name and immediately launch it with </font></font><code>plv8.find_function(name);</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">But keep in mind that in JS a function cannot be polymorphic, as in PostgreSQL, in which functions with the same name but with different parameters can coexist. </font><font style="vertical-align: inherit;">In PL / v8, of course, we can create polymorphic functions, but there </font></font><code>find_function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be an error </font><font style="vertical-align: inherit;">when trying to use </font><font style="vertical-align: inherit;">it.</font></font><br>
<br>
<pre><code class="plaintext hljs">ERROR:  Error: more than one function named "jsdump"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If a function by name is unambiguous, then it can be called without SPI and type conversions, i.e. </font><font style="vertical-align: inherit;">much faster. </font><font style="vertical-align: inherit;">For example, like this:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DO</span> <span class="hljs-keyword">LANGUAGE</span> plv8 $$<span class="ruby">
plv8.find_function(<span class="hljs-string">'jsdump'</span>)(<span class="hljs-number">1</span>, <span class="hljs-string">'abc'</span>);
$$</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transactions</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postgres 11 has a lot of fun: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">real</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> procedures </font><font style="vertical-align: inherit;">have appeared </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Postgres used to have only features. </font><font style="vertical-align: inherit;">The joy is not only due to compatibility and compliance with the SQL standard, but why: within the procedures you can commit and roll back transactions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / Perl and PL / Python already have SPI functions for managing transactions, while PL / V8 does not yet. </font><font style="vertical-align: inherit;">In PL / Perl, these functions are called </font></font><code>spi_commit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>spi_rollback()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and a usage example is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In PL / Python, this is </font></font><code>plpy.commit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>plpy.rollback()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Subtransaction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Subtransactions are convenient for correct error handling in complex multi-level logic. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / pgSQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inside a transaction, each block with the EXCEPTION keyword is a subtransaction. You can read about some performance and reliability issues that may arise in this case, for example, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are </font><font style="vertical-align: inherit;">no explicit subtransactions </font><font style="vertical-align: inherit;">in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but they can be simulated through savaepoints. Apparently, if you wish, it is easy to write a pearl module that implements subtransactions in an explicit form. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Python,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sub-transactions appeared long ago: from 9.5 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explicit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , before that there were </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implicit ones</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . You can define a transaction, wrap it in</font></font><code>try-</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and execute. </font><font style="vertical-align: inherit;">If the subtransaction falls off, then we fall into the block </font></font><code>except</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, if not fall off, then into the block </font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and move on.</font></font><br>
<br>
<pre><code class="pgsql hljs">try:
     <span class="hljs-keyword">with</span> plpy.subtransaction():<font></font>
          plpy.<span class="hljs-keyword">execute</span>("...")<font></font>
          plpy.<span class="hljs-keyword">execute</span>("...")
<span class="hljs-keyword">except</span> plpy.SPIError, e:<font></font>
. . .<font></font>
<span class="hljs-keyword">else</span>:<font></font>
. . .</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A similar design exists in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / V8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , only in JS syntax.</font></font><br>
<br>
<pre><code class="pgsql hljs">try {<font></font>
plv8.subtransaction(<span class="hljs-keyword">function</span>() {<font></font>
plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'UPDATE...'</span>);<font></font>
plv8.<span class="hljs-keyword">execute</span>(<span class="hljs-string">'UPDATE...'</span>);<font></font>
});<font></font>
}<font></font>
catch(e) {<font></font>
...<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Try, but do not abuse :) Knowledge of PL / * can bring some benefits. </font><font style="vertical-align: inherit;">Like any tool, they love to be used for their intended purpose. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PL / v8 is very promising, but sometimes it behaves unexpectedly and has a number of problems. </font><font style="vertical-align: inherit;">Therefore, it is better to take languages ​​out of the box if they are suitable for your task. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I want to thank Igor Levshin (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Igor_Le</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), who helped me a lot with preparing the material for the article, and threw some useful ideas, as well as Evgeny Sergeev and Alexey Fadeev for the corrections they proposed.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en502236/index.html">Children's aircraft modeling - at a decent level</a></li>
<li><a href="../en502246/index.html">What do Alice's bold answers have in common with drones?</a></li>
<li><a href="../en502248/index.html">A new GOST for digital resources came into force: all platforms should be accessible for people with disabilities</a></li>
<li><a href="../en502250/index.html">Civil Aviation Today: Important Aspects and Challenges in Training</a></li>
<li><a href="../en502252/index.html">Remote control and drones</a></li>
<li><a href="../en502256/index.html">How to visualize a Spring Integration graph using Neo4j?</a></li>
<li><a href="../en502260/index.html">ESP-NOW is an alternative communication protocol for ESP8266 and ESP32. Basic concepts</a></li>
<li><a href="../en502262/index.html">Why AIOps and umbrella monitoring for the bank, or on what are customer relations built</a></li>
<li><a href="../en502264/index.html">Public Key Infrastructure. Issue of certificates in conditions of self-isolation</a></li>
<li><a href="../en502266/index.html">Aurora on Intel platform. Dawn of the Exaflops Era</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>