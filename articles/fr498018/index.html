<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍒 🐡 🙌 Analyses en ligne dans l'architecture de microservices: aidez et suggérez Postgres FDW Post и Post Post ̶п̶р̶о̶с̶т̶и̶т иь̶ 🐇 🏸 🤾🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'architecture de microservices, comme tout dans ce monde, a ses avantages et ses inconvénients. Certains processus deviennent plus faciles, d'autres ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Analyses en ligne dans l'architecture de microservices: aidez et suggérez Postgres FDW Post и Post Post ̶п̶р̶о̶с̶т̶и̶т иь̶</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/domclick/blog/498018/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'architecture de microservices, comme tout dans ce monde, a ses avantages et ses inconvénients. Certains processus deviennent plus faciles, d'autres plus compliqués. Et pour des raisons de vitesse de changement et de meilleure évolutivité, des sacrifices doivent être consentis. L'un d'eux est la complication de l'analyse. Si dans un monolithe toutes les analyses opérationnelles peuvent être réduites à des requêtes SQL pour une réplique analytique, alors dans une architecture multiservice, chaque service a sa propre base et il semble qu'une requête ne peut pas être supprimée (ou peut-elle être supprimée?). Pour ceux qui souhaitent savoir comment nous avons résolu le problème de l'analyse opérationnelle dans notre entreprise et comment nous avons appris à vivre avec cette solution - bienvenue.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zc/lo/cj/zclocjwvmvs1k3f9hp1yr4wy698.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mon nom est Pavel Sivash, à DomKlik je travaille dans une équipe qui est responsable de la maintenance de l'entrepôt de données analytiques. Classiquement, nos activités peuvent être attribuées à la date de l'ingénierie, mais, en fait, l'éventail des tâches est beaucoup plus large. Il existe une norme ETL / ELT pour l'ingénierie des dates, le support et l'adaptation des outils pour l'analyse des données et le développement de leurs propres outils. En particulier, pour le reporting opérationnel, nous avons décidé de «faire semblant» d'avoir un monolithe et de donner aux analystes une base dans laquelle ils disposeront de toutes les données dont ils ont besoin.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, nous avons considéré différentes options. Il était possible de créer un référentiel à part entière - nous avons même essayé, mais honnêtement, nous n'avons pas réussi à nous faire des amis assez souvent des changements dans la logique avec un processus assez lent de construction d'un référentiel et y apporter des modifications (si quelqu'un a réussi, écrivez dans les commentaires comment). On pourrait dire aux analystes: "Les gars, apprenez le python et allez aux indices analytiques", mais c'est une exigence supplémentaire pour le recrutement du personnel, et il semblait que cela devrait être évité si possible. Nous avons décidé d'essayer d'utiliser la technologie FDW (Foreign Data Wrapper): en fait, c'est le dblink standard, qui est dans le standard SQL, mais avec son interface beaucoup plus pratique. Sur la base de cela, nous avons pris une décision, qui s'est finalement stabilisée, nous nous y sommes arrêtés. Ses détails font l'objet d'un article séparé, ou peut-être pas un,parce que je veux parler de beaucoup: de la synchronisation des schémas de bases de données au contrôle d'accès et à l'anonymisation des données personnelles. Vous devez également faire une réservation que cette solution ne remplace pas de véritables bases de données et référentiels analytiques, elle ne résout qu'un problème spécifique.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au niveau supérieur, cela ressemble à ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/eu/ta/ou/eutaouuz7zwuukzyqgifafovvis.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe une base de données PostgreSQL, où les utilisateurs peuvent stocker leurs données de travail, et surtout, des répliques analytiques de tous les services sont connectées à cette base de données via FDW. </font><font style="vertical-align: inherit;">Cela permet d'écrire une requête dans plusieurs bases de données, quelle qu'elle soit: PostgreSQL, MySQL, MongoDB ou autre (fichier, API, si soudainement il n'y a pas de wrapper approprié, vous pouvez écrire le vôtre). </font><font style="vertical-align: inherit;">Eh bien, tout semble super! </font><font style="vertical-align: inherit;">Sommes-nous en désaccord? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si tout s'était terminé aussi rapidement et simplement, alors, probablement, il n'y aurait pas eu d'article.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est important de comprendre clairement comment postgres gère les requêtes vers des serveurs distants. </font><font style="vertical-align: inherit;">Cela semble logique, mais souvent ils n'y prêtent pas attention: postgres divise la demande en parties exécutées indépendamment sur des serveurs distants, recueille ces données et les calculs finaux sont effectués par lui-même, la vitesse de la demande dépendra donc grandement de la façon dont elle est écrite. </font><font style="vertical-align: inherit;">Il convient également de noter: lorsque les données proviennent d'un serveur distant, elles n'ont plus d'index, rien ne peut aider le planificateur, donc, nous seuls pouvons l'aider et le suggérer. </font><font style="vertical-align: inherit;">Et je voudrais vous en dire plus à ce sujet.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demande simple et planifier avec elle</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour montrer comment postgres exécute une requête sur une table de 6 millions de lignes sur un serveur distant, regardons un plan simple.</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">analyze</span> verbose  
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">count</span>(<span class="hljs-number">1</span>)
<span class="hljs-keyword">FROM</span> fdw_schema.table;<font></font>
<font></font>
Aggregate  (cost=418383.23..418383.24 rows=1 width=8) (actual time=3857.198..3857.198 rows=1 loops=1)<font></font>
  Output: count(1)<font></font>
  -&gt;  Foreign Scan on fdw_schema."table"  (cost=100.00..402376.14 rows=6402838 width=0) (actual time=4.874..3256.511 rows=6406868 loops=1)<font></font>
        Output: "table".id, "table".is_active, "table".meta, "table".created_dt<font></font>
        Remote SQL: <span class="hljs-keyword">SELECT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">FROM</span> fdw_schema.table<font></font>
Planning <span class="hljs-built_in">time</span>: <span class="hljs-number">0.986</span> ms<font></font>
Execution <span class="hljs-built_in">time</span>: <span class="hljs-number">3857.436</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'utilisation de l'instruction VERBOSE vous permet de voir la requête qui sera envoyée au serveur distant et les résultats que nous recevrons pour un traitement ultérieur (ligne RemoteSQL). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Allons un peu plus loin et ajoutons quelques filtres à notre requête: un par le </font><font style="vertical-align: inherit;">champ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">booléen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , un par l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horodatage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de l'intervalle et un par </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsonb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">analyze</span> verbose
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">count</span>(<span class="hljs-number">1</span>)
<span class="hljs-keyword">FROM</span> fdw_schema.table 
<span class="hljs-keyword">WHERE</span> is_active <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>
<span class="hljs-keyword">AND</span> created_dt <span class="hljs-keyword">BETWEEN</span> <span class="hljs-keyword">CURRENT_DATE</span> - <span class="hljs-built_in">INTERVAL</span> <span class="hljs-string">'7 month'</span> 
<span class="hljs-keyword">AND</span> <span class="hljs-keyword">CURRENT_DATE</span> - <span class="hljs-built_in">INTERVAL</span> <span class="hljs-string">'6 month'</span>
<span class="hljs-keyword">AND</span> meta-&gt;&gt;<span class="hljs-string">'source'</span> = <span class="hljs-string">'test'</span>;<font></font>
<font></font>
Aggregate  (cost=577487.69..577487.70 rows=1 width=8) (actual time=27473.818..25473.819 rows=1 loops=1)<font></font>
  Output: count(1)<font></font>
  -&gt;  Foreign Scan on fdw_schema."table"  (cost=100.00..577469.21 rows=7390 width=0) (actual time=31.369..25372.466 rows=1360025 loops=1)<font></font>
        Output: "table".id, "table".is_active, "table".meta, "table".created_dt<font></font>
        Filter: (("table".is_active IS TRUE) AND (("table".meta -&gt;&gt; 'source'::text) = 'test'::text) AND ("table".created_dt &gt;= (('now'::cstring)::date - '7 mons'::interval)) AND ("table".created_dt &lt;= ((('now'::cstring)::date)::timestamp <span class="hljs-keyword">with</span> <span class="hljs-built_in">time</span> zone - <span class="hljs-string">'6 mons'</span>::<span class="hljs-built_in">interval</span>)))
        <span class="hljs-keyword">Rows</span> Removed <span class="hljs-keyword">by</span> Filter: <span class="hljs-number">5046843</span>
        Remote <span class="hljs-keyword">SQL</span>: <span class="hljs-keyword">SELECT</span> created_dt, is_active, meta <span class="hljs-keyword">FROM</span> fdw_schema.table<font></font>
Planning <span class="hljs-built_in">time</span>: <span class="hljs-number">0.665</span> ms<font></font>
Execution <span class="hljs-built_in">time</span>: <span class="hljs-number">27474.118</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est là que réside le moment auquel vous devez faire attention lors de l'écriture de requêtes. </font><font style="vertical-align: inherit;">Les filtres n'ont pas été transférés sur le serveur distant, ce qui signifie que pour l'exécuter, le postgres étend les 6 millions de lignes, puis seulement pour filtrer localement (ligne de filtre) et effectuer une agrégation. </font><font style="vertical-align: inherit;">La clé du succès est d'écrire une demande afin que les filtres soient transférés vers la machine distante, et nous ne recevions et agrégions que les lignes nécessaires.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est de la merde</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec les champs booléens, tout est simple. </font><font style="vertical-align: inherit;">Dans la demande d'origine, le problème était dû à la déclaration </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si nous le remplaçons par </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous obtenons le résultat suivant:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">analyze</span> verbose
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">count</span>(<span class="hljs-number">1</span>)
<span class="hljs-keyword">FROM</span> fdw_schema.table
<span class="hljs-keyword">WHERE</span> is_active = <span class="hljs-literal">True</span>
<span class="hljs-keyword">AND</span> created_dt <span class="hljs-keyword">BETWEEN</span> <span class="hljs-keyword">CURRENT_DATE</span> - <span class="hljs-built_in">INTERVAL</span> <span class="hljs-string">'7 month'</span> 
<span class="hljs-keyword">AND</span> <span class="hljs-keyword">CURRENT_DATE</span> - <span class="hljs-built_in">INTERVAL</span> <span class="hljs-string">'6 month'</span>
<span class="hljs-keyword">AND</span> meta-&gt;&gt;<span class="hljs-string">'source'</span> = <span class="hljs-string">'test'</span>;<font></font>
<font></font>
Aggregate  (cost=508010.14..508010.15 rows=1 width=8) (actual time=19064.314..19064.314 rows=1 loops=1)<font></font>
  Output: count(1)<font></font>
  -&gt;  Foreign Scan on fdw_schema."table"  (cost=100.00..507988.44 rows=8679 width=0) (actual time=33.035..18951.278 rows=1360025 loops=1)<font></font>
        Output: "table".id, "table".is_active, "table".meta, "table".created_dt<font></font>
        Filter: ((("table".meta -&gt;&gt; 'source'::text) = 'test'::text) AND ("table".created_dt &gt;= (('now'::cstring)::date - '7 mons'::interval)) AND ("table".created_dt &lt;= ((('now'::cstring)::date)::timestamp <span class="hljs-keyword">with</span> <span class="hljs-built_in">time</span> zone - <span class="hljs-string">'6 mons'</span>::<span class="hljs-built_in">interval</span>)))
        <span class="hljs-keyword">Rows</span> Removed <span class="hljs-keyword">by</span> Filter: <span class="hljs-number">3567989</span>
        Remote <span class="hljs-keyword">SQL</span>: <span class="hljs-keyword">SELECT</span> created_dt, meta <span class="hljs-keyword">FROM</span> fdw_schema.table <span class="hljs-keyword">WHERE</span> (is_active)<font></font>
Planning <span class="hljs-built_in">time</span>: <span class="hljs-number">0.834</span> ms<font></font>
Execution <span class="hljs-built_in">time</span>: <span class="hljs-number">19064.534</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, le filtre a volé vers un serveur distant et le temps d'exécution a été réduit de 27 à 19 secondes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient de noter que l'opérateur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diffère de l'opérateur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en ce qu'il peut fonctionner avec la valeur Null. </font><font style="vertical-align: inherit;">Cela signifie que ce </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'est pas vrai</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans le filtre laissera False et Null, tandis que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! = True</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne laissera que False. </font><font style="vertical-align: inherit;">Par conséquent, lorsque vous remplacez l' </font><font style="vertical-align: inherit;">opérateur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is not</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , deux conditions par l'opérateur OR doivent être transmises au filtre, par exemple, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WHERE (col! = True) OR (col est null)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec booléen trié, passez à autre chose. </font><font style="vertical-align: inherit;">En attendant, remettez le filtre par valeur booléenne dans sa forme d'origine, pour tenir compte indépendamment de l'effet des autres modifications.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">timestamptz? </font><font style="vertical-align: inherit;">hz</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, il faut souvent expérimenter comment écrire une requête impliquant des serveurs distants, et ensuite seulement chercher une explication de la raison pour laquelle cela se produit. Très peu d'informations à ce sujet peuvent être trouvées sur Internet. Ainsi, dans des expériences, nous avons constaté que le filtre par une date fixe vole vers le serveur distant avec un bang, mais lorsque nous voulons définir la date dynamiquement, par exemple, now () ou CURRENT_DATE, cela ne se produit pas. Dans notre exemple, nous avons ajouté un filtre afin que la colonne created_at contienne exactement les données du mois précédent (BETWEEN CURRENT_DATE - INTERVAL '7 month' AND CURRENT_DATE - INTERVAL '6 month'). Qu'avons-nous fait dans ce cas?</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">analyze</span> verbose
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">count</span>(<span class="hljs-number">1</span>)
<span class="hljs-keyword">FROM</span> fdw_schema.table 
<span class="hljs-keyword">WHERE</span> is_active <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>
<span class="hljs-keyword">AND</span> created_dt &gt;= (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CURRENT_DATE</span>::timestamptz - <span class="hljs-built_in">INTERVAL</span> <span class="hljs-string">'7 month'</span>) 
<span class="hljs-keyword">AND</span> created_dt &lt;(<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CURRENT_DATE</span>::timestamptz - <span class="hljs-built_in">INTERVAL</span> <span class="hljs-string">'6 month'</span>)
<span class="hljs-keyword">AND</span> meta-&gt;&gt;<span class="hljs-string">'source'</span> = <span class="hljs-string">'test'</span>;<font></font>
<font></font>
Aggregate  (cost=306875.17..306875.18 rows=1 width=8) (actual time=4789.114..4789.115 rows=1 loops=1)<font></font>
  Output: count(1)<font></font>
  InitPlan 1 (returns $0)<font></font>
    -&gt;  Result  (cost=0.00..0.02 rows=1 width=8) (actual time=0.007..0.008 rows=1 loops=1)<font></font>
          Output: ((('now'::cstring)::date)::timestamp <span class="hljs-keyword">with</span> <span class="hljs-built_in">time</span> zone - <span class="hljs-string">'7 mons'</span>::<span class="hljs-built_in">interval</span>)<font></font>
  InitPlan <span class="hljs-number">2</span> (<span class="hljs-keyword">returns</span> $<span class="hljs-number">1</span>)<font></font>
    -&gt;  <span class="hljs-keyword">Result</span>  (<span class="hljs-keyword">cost</span>=<span class="hljs-number">0.00</span>.<span class="hljs-number">.0</span><span class="hljs-number">.02</span> <span class="hljs-keyword">rows</span>=<span class="hljs-number">1</span> width=<span class="hljs-number">8</span>) (actual <span class="hljs-built_in">time</span>=<span class="hljs-number">0.002</span>.<span class="hljs-number">.0</span><span class="hljs-number">.002</span> <span class="hljs-keyword">rows</span>=<span class="hljs-number">1</span> loops=<span class="hljs-number">1</span>)
          <span class="hljs-keyword">Output</span>: (((<span class="hljs-string">'now'</span>::cstring)::<span class="hljs-built_in">date</span>)::<span class="hljs-built_in">timestamp</span> <span class="hljs-keyword">with</span> <span class="hljs-built_in">time</span> zone - <span class="hljs-string">'6 mons'</span>::<span class="hljs-built_in">interval</span>)<font></font>
  -&gt;  <span class="hljs-keyword">Foreign</span> <span class="hljs-keyword">Scan</span> <span class="hljs-keyword">on</span> fdw_schema.<span class="hljs-string">"table"</span>  (<span class="hljs-keyword">cost</span>=<span class="hljs-number">100.02</span>.<span class="hljs-number">.306874</span><span class="hljs-number">.86</span> <span class="hljs-keyword">rows</span>=<span class="hljs-number">105</span> width=<span class="hljs-number">0</span>) (actual <span class="hljs-built_in">time</span>=<span class="hljs-number">23.475</span>.<span class="hljs-number">.4681</span><span class="hljs-number">.419</span> <span class="hljs-keyword">rows</span>=<span class="hljs-number">1360025</span> loops=<span class="hljs-number">1</span>)
        <span class="hljs-keyword">Output</span>: <span class="hljs-string">"table"</span>.id, <span class="hljs-string">"table"</span>.is_active, <span class="hljs-string">"table"</span>.meta, <span class="hljs-string">"table"</span>.created_dt<font></font>
        Filter: ((<span class="hljs-string">"table"</span>.is_active <span class="hljs-keyword">IS</span> <span class="hljs-literal">TRUE</span>) <span class="hljs-keyword">AND</span> ((<span class="hljs-string">"table"</span>.meta -&gt;&gt; <span class="hljs-string">'source'</span>::<span class="hljs-built_in">text</span>) = <span class="hljs-string">'test'</span>::<span class="hljs-built_in">text</span>))
        <span class="hljs-keyword">Rows</span> Removed <span class="hljs-keyword">by</span> Filter: <span class="hljs-number">76934</span>
        Remote <span class="hljs-keyword">SQL</span>: <span class="hljs-keyword">SELECT</span> is_active, meta <span class="hljs-keyword">FROM</span> fdw_schema.table <span class="hljs-keyword">WHERE</span> ((created_dt &gt;= $<span class="hljs-number">1</span>::<span class="hljs-built_in">timestamp</span> <span class="hljs-keyword">with</span> <span class="hljs-built_in">time</span> zone)) <span class="hljs-keyword">AND</span> ((created_dt &lt; $<span class="hljs-number">2</span>::<span class="hljs-built_in">timestamp</span> <span class="hljs-keyword">with</span> <span class="hljs-built_in">time</span> zone))<font></font>
Planning <span class="hljs-built_in">time</span>: <span class="hljs-number">0.703</span> ms<font></font>
Execution <span class="hljs-built_in">time</span>: <span class="hljs-number">4789.379</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons invité le planificateur à calculer à l'avance la date dans la sous-requête et à transmettre la variable prête à l'emploi au filtre. </font><font style="vertical-align: inherit;">Et cet indice nous a donné un excellent résultat, la requête est devenue presque 6 fois plus rapide! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encore une fois, il est important d'être prudent ici: le type de données dans la sous-requête doit être le même que le champ pour lequel nous filtrons, sinon le planificateur décidera que puisque les types sont différents et vous devez d'abord obtenir toutes les données et les filtrer localement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remettez le filtre par date à sa valeur d'origine.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Freddy vs. </font><font style="vertical-align: inherit;">Jsonb</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, les champs booléens et les dates ont déjà accéléré notre requête, mais il y avait un autre type de données. </font><font style="vertical-align: inherit;">Franchement, la bataille avec le filtrage n'est pas terminée, bien qu'il y ait des succès. </font><font style="vertical-align: inherit;">Voici donc comment nous avons réussi à passer le filtre par </font><font style="vertical-align: inherit;">champ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsonb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au serveur distant.</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">analyze</span> verbose
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">count</span>(<span class="hljs-number">1</span>)
<span class="hljs-keyword">FROM</span> fdw_schema.table 
<span class="hljs-keyword">WHERE</span> is_active <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>
<span class="hljs-keyword">AND</span> created_dt <span class="hljs-keyword">BETWEEN</span> <span class="hljs-keyword">CURRENT_DATE</span> - <span class="hljs-built_in">INTERVAL</span> <span class="hljs-string">'7 month'</span> 
<span class="hljs-keyword">AND</span> <span class="hljs-keyword">CURRENT_DATE</span> - <span class="hljs-built_in">INTERVAL</span> <span class="hljs-string">'6 month'</span>
<span class="hljs-keyword">AND</span> meta @&gt; <span class="hljs-string">'{"source":"test"}'</span>::jsonb;<font></font>
<font></font>
Aggregate  (cost=245463.60..245463.61 rows=1 width=8) (actual time=6727.589..6727.590 rows=1 loops=1)<font></font>
  Output: count(1)<font></font>
  -&gt;  Foreign Scan on fdw_schema."table"  (cost=1100.00..245459.90 rows=1478 width=0) (actual time=16.213..6634.794 rows=1360025 loops=1)<font></font>
        Output: "table".id, "table".is_active, "table".meta, "table".created_dt<font></font>
        Filter: (("table".is_active IS TRUE) AND ("table".created_dt &gt;= (('now'::cstring)::date - '7 mons'::interval)) AND ("table".created_dt &lt;= ((('now'::cstring)::date)::timestamp <span class="hljs-keyword">with</span> <span class="hljs-built_in">time</span> zone - <span class="hljs-string">'6 mons'</span>::<span class="hljs-built_in">interval</span>)))
        <span class="hljs-keyword">Rows</span> Removed <span class="hljs-keyword">by</span> Filter: <span class="hljs-number">619961</span>
        Remote <span class="hljs-keyword">SQL</span>: <span class="hljs-keyword">SELECT</span> created_dt, is_active <span class="hljs-keyword">FROM</span> fdw_schema.table <span class="hljs-keyword">WHERE</span> ((meta @&gt; <span class="hljs-string">'{"source": "test"}'</span>::jsonb))<font></font>
Planning <span class="hljs-built_in">time</span>: <span class="hljs-number">0.747</span> ms<font></font>
Execution <span class="hljs-built_in">time</span>: <span class="hljs-number">6727.815</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lieu de filtrer les opérateurs, vous devez utiliser l'opérateur d'avoir un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsonb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans un autre. </font><font style="vertical-align: inherit;">7 secondes au lieu des 29. Au départ, il s'agit de la seule option réussie de transfert de filtres via </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsonb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vers un serveur distant, mais il est important de tenir compte d'une limitation: nous utilisons la base de données version 9.6, mais nous prévoyons de terminer les derniers tests et de passer à la version 12 d'ici la fin avril. </font><font style="vertical-align: inherit;">Au fur et à mesure de la mise à jour, nous écrirons comment cela a affecté, car il y a beaucoup de changements pour lesquels il y a beaucoup d'espoirs: json_path, nouveau comportement CTE, push down (existant depuis la version 10). </font><font style="vertical-align: inherit;">J'aimerais l'essayer bientôt.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finis-le</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons vérifié comment chaque modification affecte la vitesse de la demande individuellement. </font><font style="vertical-align: inherit;">Voyons maintenant ce qui se passe lorsque les trois filtres sont écrits correctement.</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">analyze</span> verbose
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">count</span>(<span class="hljs-number">1</span>)
<span class="hljs-keyword">FROM</span> fdw_schema.table 
<span class="hljs-keyword">WHERE</span> is_active = <span class="hljs-literal">True</span>
<span class="hljs-keyword">AND</span> created_dt &gt;= (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CURRENT_DATE</span>::timestamptz - <span class="hljs-built_in">INTERVAL</span> <span class="hljs-string">'7 month'</span>) 
<span class="hljs-keyword">AND</span> created_dt &lt;(<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CURRENT_DATE</span>::timestamptz - <span class="hljs-built_in">INTERVAL</span> <span class="hljs-string">'6 month'</span>)
<span class="hljs-keyword">AND</span> meta @&gt; <span class="hljs-string">'{"source":"test"}'</span>::jsonb;<font></font>
<font></font>
Aggregate  (cost=322041.51..322041.52 rows=1 width=8) (actual time=2278.867..2278.867 rows=1 loops=1)<font></font>
  Output: count(1)<font></font>
  InitPlan 1 (returns $0)<font></font>
    -&gt;  Result  (cost=0.00..0.02 rows=1 width=8) (actual time=0.010..0.010 rows=1 loops=1)<font></font>
          Output: ((('now'::cstring)::date)::timestamp <span class="hljs-keyword">with</span> <span class="hljs-built_in">time</span> zone - <span class="hljs-string">'7 mons'</span>::<span class="hljs-built_in">interval</span>)<font></font>
  InitPlan <span class="hljs-number">2</span> (<span class="hljs-keyword">returns</span> $<span class="hljs-number">1</span>)<font></font>
    -&gt;  <span class="hljs-keyword">Result</span>  (<span class="hljs-keyword">cost</span>=<span class="hljs-number">0.00</span>.<span class="hljs-number">.0</span><span class="hljs-number">.02</span> <span class="hljs-keyword">rows</span>=<span class="hljs-number">1</span> width=<span class="hljs-number">8</span>) (actual <span class="hljs-built_in">time</span>=<span class="hljs-number">0.003</span>.<span class="hljs-number">.0</span><span class="hljs-number">.003</span> <span class="hljs-keyword">rows</span>=<span class="hljs-number">1</span> loops=<span class="hljs-number">1</span>)
          <span class="hljs-keyword">Output</span>: (((<span class="hljs-string">'now'</span>::cstring)::<span class="hljs-built_in">date</span>)::<span class="hljs-built_in">timestamp</span> <span class="hljs-keyword">with</span> <span class="hljs-built_in">time</span> zone - <span class="hljs-string">'6 mons'</span>::<span class="hljs-built_in">interval</span>)<font></font>
  -&gt;  <span class="hljs-keyword">Foreign</span> <span class="hljs-keyword">Scan</span> <span class="hljs-keyword">on</span> fdw_schema.<span class="hljs-string">"table"</span>  (<span class="hljs-keyword">cost</span>=<span class="hljs-number">100.02</span>.<span class="hljs-number">.322041</span><span class="hljs-number">.41</span> <span class="hljs-keyword">rows</span>=<span class="hljs-number">25</span> width=<span class="hljs-number">0</span>) (actual <span class="hljs-built_in">time</span>=<span class="hljs-number">8.597</span>.<span class="hljs-number">.2153</span><span class="hljs-number">.809</span> <span class="hljs-keyword">rows</span>=<span class="hljs-number">1360025</span> loops=<span class="hljs-number">1</span>)
        <span class="hljs-keyword">Output</span>: <span class="hljs-string">"table"</span>.id, <span class="hljs-string">"table"</span>.is_active, <span class="hljs-string">"table"</span>.meta, <span class="hljs-string">"table"</span>.created_dt<font></font>
        Remote <span class="hljs-keyword">SQL</span>: <span class="hljs-keyword">SELECT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">FROM</span> fdw_schema.table <span class="hljs-keyword">WHERE</span> (is_active) <span class="hljs-keyword">AND</span> ((created_dt &gt;= $<span class="hljs-number">1</span>::<span class="hljs-built_in">timestamp</span> <span class="hljs-keyword">with</span> <span class="hljs-built_in">time</span> zone)) <span class="hljs-keyword">AND</span> ((created_dt &lt; $<span class="hljs-number">2</span>::<span class="hljs-built_in">timestamp</span> <span class="hljs-keyword">with</span> <span class="hljs-built_in">time</span> zone)) <span class="hljs-keyword">AND</span> ((meta @&gt; <span class="hljs-string">'{"source": "test"}'</span>::jsonb))<font></font>
Planning <span class="hljs-built_in">time</span>: <span class="hljs-number">0.820</span> ms<font></font>
Execution <span class="hljs-built_in">time</span>: <span class="hljs-number">2279.087</span> ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, la requête semble plus compliquée, c'est une carte forcée, mais la vitesse d'exécution est de 2 secondes, ce qui est plus de 10 fois plus rapide! </font><font style="vertical-align: inherit;">Et nous parlons d'une simple requête sur un ensemble de données relativement petit. </font><font style="vertical-align: inherit;">Sur de vraies demandes, nous avons enregistré une croissance jusqu'à plusieurs centaines de fois. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour résumer: si vous utilisez PostgreSQL avec FDW, vérifiez toujours si tous les filtres sont envoyés au serveur distant, et vous serez satisfait ... Au moins jusqu'à ce que vous arriviez aux jointures entre les tables de différents serveurs. </font><font style="vertical-align: inherit;">Mais c'est l'histoire d'un autre article. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Merci pour l'attention! </font><font style="vertical-align: inherit;">Je serai heureux d'entendre des questions, des commentaires, ainsi que des histoires sur votre expérience dans les commentaires.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr498002/index.html">Guide de poche du Z3</a></li>
<li><a href="../fr498004/index.html">Station de travail dans un conteneur Docker</a></li>
<li><a href="../fr498006/index.html">Choisir un conseil en brevets</a></li>
<li><a href="../fr498012/index.html">Mikrotik RouterOS dans Docker avec Qemu</a></li>
<li><a href="../fr498014/index.html">PyDERASN: comme j'ai ajouté le support du big data</a></li>
<li><a href="../fr498020/index.html">Environ un indicateur applicable pour l'évaluation visuelle des fonctions à croissance rapide</a></li>
<li><a href="../fr498022/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 341 (du 13 au 19 avril)</a></li>
<li><a href="../fr498024/index.html">Construire des villes en un clic de souris avec Houdini et Python</a></li>
<li><a href="../fr498026/index.html">FOSS News n ° 12 - revue des nouvelles gratuites et open source du 13 au 19 avril 2020</a></li>
<li><a href="../fr498028/index.html">Simulation de pandémie Python COVID-19</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>