<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚ÄçüöÄ üíß üñ±Ô∏è Que tipo de carga nos servidores cria mecanismos de rede? üë©üèΩ‚Äçüîß üßî üôÜüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ao analisar a opera√ß√£o do subsistema de rede dos servidores, geralmente √© dada aten√ß√£o a indicadores como lat√™ncia, taxa de transfer√™ncia do sistema e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Que tipo de carga nos servidores cria mecanismos de rede?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/503636/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao analisar a opera√ß√£o do subsistema de rede dos servidores, geralmente √© dada aten√ß√£o a indicadores como lat√™ncia, taxa de transfer√™ncia do sistema e o n√∫mero de pacotes que podem ser processados ‚Äã‚Äãpor segundo (PPS, Pacotes por Segundo). Esses indicadores s√£o usados ‚Äã‚Äãpara entender sob qual carga m√°xima o computador em estudo pode funcionar. E, embora essas m√©tricas sejam importantes e geralmente possam dizer muito sobre o sistema, elas n√£o fornecem informa√ß√µes sobre o impacto do processamento de pacotes de rede nos programas em execu√ß√£o no servidor. </font><font style="vertical-align: inherit;">
Este material tem como objetivo estudar a carga criada pelos mecanismos de rede nos servidores. Em particular, falaremos sobre quanto tempo do processador a solu√ß√£o para problemas de rede pode "roubar" de v√°rios processos em execu√ß√£o nos sistemas Linux.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/q_/0y/ya/q_0yyareydlakrio4dbunpbt8fu.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Processamento de pacotes de rede no Linux</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Linux processa um n√∫mero significativo de pacotes no contexto de qualquer processo executado pelo processador no momento do processamento da IRQ correspondente. </font><font style="vertical-align: inherit;">O mecanismo de contabilidade do sistema atribuir√° os ciclos do processador usados ‚Äã‚Äãpara isso a qualquer processo em execu√ß√£o no momento. </font><font style="vertical-align: inherit;">Isso ser√° feito mesmo que esse processo n√£o tenha nada a ver com o processamento de pacotes de rede. </font><font style="vertical-align: inherit;">Por exemplo, uma equipe </font></font><code>top</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode indicar que um processo parece estar usando mais de 99% dos recursos do processador, mas, na verdade, 60% do tempo do processador ser√° gasto no processamento dos pacotes. </font><font style="vertical-align: inherit;">E isso significa que o pr√≥prio processo, resolvendo seus pr√≥prios problemas, utiliza apenas 40% dos recursos da CPU. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manipulador de entrada</font></font><code>net_rx_action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geralmente realizado muito, muito r√°pido. Por exemplo, em menos de 25 Œºs. (Esses dados foram obtidos das medi√ß√µes usando o eBPF. Se voc√™ estiver interessado nos detalhes, consulte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a> <code>net_rx_action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) O processador pode processar at√© 64 pacotes por inst√¢ncia NAPI (NIC ou RPS) antes de adiar a tarefa para outro ciclo do SoftIRQ. Um ap√≥s o outro, sem interrup√ß√£o, podem ser seguidos at√© 10 ciclos do SoftIRQ, o que leva cerca de 2 ms (voc√™ pode descobrir mais sobre isso lendo sobre </font></font><code>__do_softirq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Se o vetor SoftIRQ, ap√≥s o n√∫mero m√°ximo de ciclos ou o tempo passar, ainda tiver problemas n√£o resolvidos, a solu√ß√£o desses problemas ser√° adiada para execu√ß√£o no encadeamento</font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU espec√≠fica. </font><font style="vertical-align: inherit;">Quando isso acontece, o sistema se torna um pouco mais transparente no sentido de obter informa√ß√µes sobre a carga do processador criada pelas opera√ß√µes da rede (embora essa an√°lise seja realizada com base no pressuposto de que √© estudado o SoftIRQ, que est√° relacionado ao processamento de pacotes e n√£o a outra coisa) . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma maneira de obter os indicadores acima √© usar </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">sudo perf record -a \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:irq_handler_entry,irq:irq_handler_exit<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:softirq_entry --filter="vec == 3" \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:softirq_exit --filter="vec == 3"&nbsp; \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e napi:napi_poll \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- sleep 1<font></font>
<font></font>
sudo perf script<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√° o resultado:</font></font><br>
<br>
<pre><code class="plaintext hljs">swapper &nbsp; &nbsp; 0 [005] 176146.491879: irq:irq_handler_entry: irq=152 name=mlx5_comp2@pci:0000:d8:00.0<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491880:&nbsp; irq:irq_handler_exit: irq=152 ret=handled<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491880: &nbsp; &nbsp; irq:softirq_entry: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491942:&nbsp; &nbsp; &nbsp; &nbsp; napi:napi_poll: napi poll on napi struct 0xffff9d3d53863e88 for device eth0 work 64 budget 64<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491943:&nbsp; &nbsp; &nbsp; irq:softirq_exit: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491943: &nbsp; &nbsp; irq:softirq_entry: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491971:&nbsp; &nbsp; &nbsp; &nbsp; napi:napi_poll: napi poll on napi struct 0xffff9d3d53863e88 for device eth0 work 27 budget 64<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491971:&nbsp; &nbsp; &nbsp; irq:softirq_exit: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.492200: irq:irq_handler_entry: irq=152 name=mlx5_comp2@pci:0000:d8:00.0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, o processador est√° ocioso (da√≠ a apar√™ncia das entradas </font></font><code>swapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o processo), o IRQ √© chamado para a fila Rx na CPU 5, o processamento SoftIRQ √© chamado duas vezes, 64 pacotes s√£o processados ‚Äã‚Äãprimeiro e depois 27. O pr√≥ximo IRQ √© chamado ap√≥s 229 Œºs e inicia o ciclo novamente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esses dados foram obtidos em um sistema inativo. Mas no processador, qualquer tarefa pode ser executada. Nesse caso, a sequ√™ncia de eventos acima ocorre, interrompendo esta tarefa e executando tarefas IRQ / SoftIRQ. Ao mesmo tempo, a Contabilidade do sistema atribui ao processo interrompido a carga criada pelo processador. Como resultado, as tarefas de processamento de pacotes de rede geralmente s√£o ocultas das ferramentas convencionais de monitoramento de carga do processador. Eles s√£o executados no contexto de algum processo selecionado aleatoriamente, no contexto do "processo da v√≠tima". Isso nos leva a algumas perguntas. Como estimar o tempo durante o qual o processo √© interrompido para o processamento de pacotes? Como comparar duas solu√ß√µes de rede diferentes para entender qual delas tem um efeito menor em v√°rias tarefas resolvidas em um computador?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao usar mecanismos RSS, RPS, RFS, o processamento de pacotes geralmente √© distribu√≠do entre os n√∫cleos do processador. </font><font style="vertical-align: inherit;">Portanto, a sequ√™ncia de processamento de pacotes acima est√° relacionada a cada CPU espec√≠fica. </font><font style="vertical-align: inherit;">√Ä medida que a taxa de chegada de pacotes aumenta (acho que podemos falar sobre velocidades de 100.000 pacotes por segundo ou mais), cada CPU precisa processar milhares ou dezenas de milhares de pacotes por segundo. </font><font style="vertical-align: inherit;">O processamento de tantos pacotes afetar√° inevitavelmente outras tarefas executadas no servidor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere uma maneira de avaliar esse efeito.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desabilitando o processamento de pacotes distribu√≠dos</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para come√ßar, vamos parar o processamento distribu√≠do de pacotes desativando o RPS e configurando regras de controle de fluxo destinadas a organizar o processamento de todos os pacotes relacionados a um endere√ßo MAC espec√≠fico na √∫nica CPU conhecida por n√≥s. </font><font style="vertical-align: inherit;">Meu sistema possui 2 NICs agregadas em uma configura√ß√£o 802.3ad. </font><font style="vertical-align: inherit;">As tarefas de rede s√£o atribu√≠das a uma √∫nica m√°quina virtual em execu√ß√£o em um computador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O RPS nos adaptadores de rede est√° desabilitado da seguinte maneira:</font></font><br>
<br>
<pre><code class="plaintext hljs">for d in eth0 eth1; do<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;find /sys/class/net/${d}/queues -name rps_cpus |<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;while read f; do<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 0 | sudo tee ${f}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;done<font></font>
done<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, configuramos as regras de controle de fluxo para garantir que os pacotes entrem na m√°quina virtual de teste usando uma √∫nica CPU:</font></font><br>
<br>
<pre><code class="plaintext hljs">DMAC=12:34:de:ad:ca:fe<font></font>
sudo ethtool -N eth0 flow-type ether dst ${DMAC} action 2<font></font>
sudo ethtool -N eth1 flow-type ether dst ${DMAC} action 2<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desabilitar o RPS e usar regras de controle de fluxo nos permite garantir que todos os pacotes destinados √† nossa m√°quina virtual sejam processados ‚Äã‚Äãna mesma CPU. </font><font style="vertical-align: inherit;">Para garantir que os pacotes sejam enviados para a fila para a qual eles devem ser enviados, voc√™ pode usar um comando como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ethq</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ent√£o voc√™ pode descobrir qual CPU essa fila pertence a usar </font></font><code>/proc/interrupts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No meu caso, o turno 2 √© processado por meio da CPU 5.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comando de velocidade Openssl</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu poderia usar utilit√°rios </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font><font style="vertical-align: inherit;">analisar os tempos de execu√ß√£o do SoftIRQ respons√°veis ‚Äã‚Äãpelo processamento do tr√°fego recebido </font></font><code>bpf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas essa abordagem √© bastante complicada. Al√©m disso, o pr√≥prio processo de observa√ß√£o afeta definitivamente os resultados. Uma solu√ß√£o muito mais simples e compreens√≠vel √© identificar a carga criada pelas opera√ß√µes de rede no sistema usando alguma tarefa, que cria uma carga conhecida no sistema. Por exemplo, este √© um comando </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usado para testar o desempenho do OpenSSL. Isso permitir√° descobrir quanto recursos do processador o programa obt√©m na realidade e compar√°-lo com a quantidade de recursos que ele deve receber (isso ajudar√° a descobrir quanto recursos s√£o gastos nas tarefas de rede).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A equipe √© </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quase 100% uma equipe de espa√ßo do usu√°rio. Se voc√™ o vincular a uma determinada CPU, ele, durante a execu√ß√£o dos testes, utilizar√° todos os recursos dispon√≠veis. A equipe trabalha configurando o cron√¥metro para o intervalo especificado (aqui, por exemplo, para facilitar os c√°lculos, leva 10 segundos), executando o teste e, em seguida, quando o cron√¥metro √© acionado, usando </font></font><code>times</code><code>()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-o para descobrir quanto tempo o processador realmente conseguiu. Do ponto de vista </font></font><code>syscall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, fica assim:</font></font><br>
<br>
<pre><code class="plaintext hljs">alarm(10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0<font></font>
times({tms_utime=0, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726601344<font></font>
--- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL} ---<font></font>
rt_sigaction(SIGALRM, ...) = 0<font></font>
rt_sigreturn({mask=[]}) = 2782545353<font></font>
times({tms_utime=1000, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726602344<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou seja, acontece que </font></font><code>alarm()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muito poucas chamadas do sistema foram feitas </font><font style="vertical-align: inherit;">entre ligar </font><font style="vertical-align: inherit;">e verificar os resultados. Se o programa n√£o foi interrompido ou muito raramente, o tempo </font></font><code>tms_utime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coincide com o tempo do teste (neste caso, 10 segundos). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como se trata de um teste realizado exclusivamente no espa√ßo do usu√°rio, qualquer hora do sistema exibida </font></font><code>times()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">significa alguma carga adicional no sistema. Acontece que, embora </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este seja um processo executado na CPU, a pr√≥pria CPU pode estar ocupada com outra coisa. Por exemplo, processando pacotes de rede:</font></font><br>
<br>
<pre><code class="plaintext hljs">alarm(10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0<font></font>
times({tms_utime=0, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726617896<font></font>
--- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL} ---<font></font>
rt_sigaction(SIGALRM, ...) = 0<font></font>
rt_sigreturn({mask=[]}) = 4079301579<font></font>
times({tms_utime=178, tms_stime=571, tms_cutime=0, tms_cstime=0}) = 1726618896<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui voc√™ pode ver que foi </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">poss√≠vel trabalhar no processador por 7,49 segundos (178 + 571 em unidades de medida correspondentes a 0,01 s.). </font><font style="vertical-align: inherit;">Mas, ao mesmo tempo, 5,71 s. </font><font style="vertical-align: inherit;">esse intervalo √© representado pela hora do sistema. </font><font style="vertical-align: inherit;">Como ele </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o </font><font style="vertical-align: inherit;">est√° </font><font style="vertical-align: inherit;">ocupado com nenhum neg√≥cio no espa√ßo do kernel, isso significa que 5,71 s. </font><font style="vertical-align: inherit;">- Este √© o resultado de uma carga adicional no sistema. </font><font style="vertical-align: inherit;">Ou seja, √© a hora em que o processo foi "roubado" para atender √†s necessidades do sistema.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando o comando openssl speed para detectar a carga do sistema causada por mecanismos de rede</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora que descobrimos como a equipe funciona </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, veremos os resultados que ela produz em um servidor praticamente inativo:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ taskset -c 5 openssl speed -seconds 10 aes-256-cbc &gt;/dev/null<font></font>
Doing aes-256 cbc for 10s on 16 size blocks: 66675623 aes-256 cbc's in 9.99s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 18096647 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 4607752 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 1162429 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 145251 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 72831 aes-256 cbc's in 10.00s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como voc√™ pode ver, somos informados de que o programa passa de 9,99 a 10 segundos para processar blocos de tamanhos diferentes. Isso confirma que os mecanismos do sistema n√£o levam tempo do processador a partir do programa. Agora, usando </font></font><code>netperf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, carregaremos o servidor processando pacotes provenientes de duas fontes. Execute o teste novamente:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ taskset -c 5 openssl speed -seconds 10 aes-256-cbc &gt;/dev/null<font></font>
Doing aes-256 cbc for 10s on 16 size blocks: 12061658 aes-256 cbc's in 1.96s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 3457491 aes-256 cbc's in 2.10s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 893939 aes-256 cbc's in 2.01s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 201756 aes-256 cbc's in 1.86s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 25117 aes-256 cbc's in 1.78s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 13859 aes-256 cbc's in 1.89s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os resultados s√£o muito diferentes daqueles obtidos em um servidor inativo. Espera-se que cada um dos testes seja executado em 10 segundos, mas </font></font><code>times()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">informa que o tempo real de execu√ß√£o √© de 1,78 a 2,1 segundos. Isso significa que o tempo restante, variando de 7,9 a 8,22 segundos, foi gasto no processamento dos pacotes, no contexto do processo </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou no </font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos dar uma olhada no que a equipe divulgar√° </font></font><code>top</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ao analisar o lan√ßamento rec√©m-conclu√≠do </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="plaintext hljs">PID USER&nbsp; &nbsp; &nbsp; PR&nbsp; NI&nbsp; &nbsp; VIRT&nbsp; &nbsp; RES&nbsp; &nbsp; SHR S&nbsp; %CPU %MEM &nbsp; &nbsp; TIME+ COMMAND&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P&nbsp;<font></font>
&nbsp;8180 libvirt+&nbsp; 20 &nbsp; 0 33.269g 1.649g 1.565g S 279.9&nbsp; 0.9&nbsp; 18:57.81 qemu-system-x86 &nbsp; &nbsp; 75<font></font>
&nbsp;8374 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 99.4&nbsp; 0.0 &nbsp; 2:57.97 vhost-8180&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 89<font></font>
&nbsp;1684 dahern&nbsp; &nbsp; 20 &nbsp; 0 &nbsp; 17112 &nbsp; 4400 &nbsp; 3892 R&nbsp; 73.6&nbsp; 0.0 &nbsp; 0:09.91 openssl&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;38 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 26.2&nbsp; 0.0 &nbsp; 0:31.86 ksoftirqd/5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui voc√™ pode pensar que ele </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usa aproximadamente 73% dos recursos da CPU 5, e os </font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recursos restantes s√£o obtidos. </font><font style="vertical-align: inherit;">Mas, na realidade, no contexto </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o processamento de um n√∫mero t√£o grande de pacotes √© realizado que o pr√≥prio programa leva apenas 18 a 21% do tempo do processador para resolver seus problemas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ reduzir a carga da rede para 1 fluxo, </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ter√° a </font><font style="vertical-align: inherit;">sensa√ß√£o de que </font><font style="vertical-align: inherit;">99% dos recursos do sistema est√£o sendo consumidos.</font></font><br>
<br>
<pre><code class="plaintext hljs">&nbsp;&nbsp;PID USER&nbsp; &nbsp; &nbsp; PR&nbsp; NI&nbsp; &nbsp; VIRT&nbsp; &nbsp; RES&nbsp; &nbsp; SHR S&nbsp; %CPU %MEM &nbsp; &nbsp; TIME+ COMMAND&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P<font></font>
&nbsp;8180 libvirt+&nbsp; 20 &nbsp; 0 33.269g 1.722g 1.637g S 325.1&nbsp; 0.9 166:38.12 qemu-system-x86 &nbsp; &nbsp; 29<font></font>
44218 dahern&nbsp; &nbsp; 20 &nbsp; 0 &nbsp; 17112 &nbsp; 4488 &nbsp; 3996 R&nbsp; 99.2&nbsp; 0.0 &nbsp; 0:28.55 openssl&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
&nbsp;8374 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 64.7&nbsp; 0.0&nbsp; 60:40.50 vhost-8180&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 55<font></font>
&nbsp;&nbsp;&nbsp;38 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 S &nbsp; 1.0&nbsp; 0.0 &nbsp; 4:51.98 ksoftirqd/5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas, na realidade, verifica-se que o programa em execu√ß√£o no espa√ßo do usu√°rio obt√©m, nos 10 segundos esperados, apenas cerca de 4 segundos:</font></font><br>
<br>
<pre><code class="plaintext hljs">Doing aes-256 cbc for 10s on 16 size blocks: 26596388 aes-256 cbc's in 4.01s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 7137481 aes-256 cbc's in 4.14s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 1844565 aes-256 cbc's in 4.31s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 472687 aes-256 cbc's in 4.28s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 59001 aes-256 cbc's in 4.46s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 28569 aes-256 cbc's in 4.16s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As ferramentas convencionais de monitoramento de processos indicam que o programa usa quase todos os recursos do processador, mas, na realidade, verifica-se que 55-80% dos recursos da CPU s√£o gastos no processamento de pacotes de rede. </font><font style="vertical-align: inherit;">A taxa de transfer√™ncia do sistema ao mesmo tempo parece √≥tima (mais de 22 Gb / s por linha de 25 Gb / s), mas isso tem um tremendo impacto nos processos em execu√ß√£o nesse sistema.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sum√°rio</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui examinamos um exemplo de como os mecanismos de processamento de pacotes "roubam" os rel√≥gios do processador de um benchmark simples e n√£o muito importante. </font><font style="vertical-align: inherit;">Mas em um servidor real, os processos afetados de maneira semelhante podem ser qualquer coisa. </font><font style="vertical-align: inherit;">Podem ser processadores virtuais, threads de emulador, threads de vhost de m√°quinas virtuais. </font><font style="vertical-align: inherit;">Podem ser diferentes processos do sistema, cujo impacto pode ter um impacto diferente no desempenho desses processos e em todo o sistema. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ considera, analisando seus servidores, o impacto no desempenho real da carga associada √†s opera√ß√µes de rede?</font></font></b><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/a_/bs/aa/a_bsaactpbr8fltzymtkhqbw1d4.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt503624/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 416 (18-24 de maio de 2020)</a></li>
<li><a href="../pt503626/index.html">Teste. Erros de certifica√ß√£o ISTQB ou resolva um milh√£o de exemplos</a></li>
<li><a href="../pt503630/index.html">√ìculos de realidade aumentada: onde estamos agora?</a></li>
<li><a href="../pt503632/index.html">1000 e 1 post: feliz anivers√°rio, Habr ‚ù§</a></li>
<li><a href="../pt503634/index.html">5 descobertas JavaScript interessantes feitas no c√≥digo fonte do Vue</a></li>
<li><a href="../pt503638/index.html">6 h√°bitos √∫teis que, surpreendentemente, apenas alguns programadores t√™m</a></li>
<li><a href="../pt503642/index.html">Como chegar no LinkedIn, Facebook, Google no Vale do Sil√≠cio</a></li>
<li><a href="../pt503648/index.html">O que significa a sa√≠da de "ss -s"</a></li>
<li><a href="../pt503650/index.html">VKCup 2020 Etapa I. Um longo caminho</a></li>
<li><a href="../pt503652/index.html">Eventos digitais em Moscou de 25 a 31 de maio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>