<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ½ï¸ ğŸ“ˆ ğŸ‘©ğŸ¾â€ğŸš’ Le livre "Java Concurrency in Practice" ğŸ’“ ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘©ğŸ» ğŸ‘¨ğŸ»â€ğŸ’¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, habrozhiteli! Les flux sont une partie fondamentale de la plate-forme Java. Les processeurs multicÅ“urs sont monnaie courante et l'utilisation...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Le livre "Java Concurrency in Practice"</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/489038/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/1r/ku/4r/1rku4rb0w0tevxfiae9gxkkkzse.jpeg" align="left" alt="image"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, habrozhiteli! Les flux sont une partie fondamentale de la plate-forme Java. Les processeurs multicÅ“urs sont monnaie courante et l'utilisation efficace de la concurrence est devenue nÃ©cessaire pour crÃ©er toute application hautes performances. Une machine virtuelle Java amÃ©liorÃ©e, la prise en charge de classes hautes performances et un riche ensemble de blocs de construction pour les tÃ¢ches de parallÃ©lisation ont Ã©tÃ© Ã  un moment donnÃ© une percÃ©e dans le dÃ©veloppement d'applications parallÃ¨les. Dans Java Concurrency in Practice, les crÃ©ateurs de technologies rÃ©volutionnaires expliquent eux-mÃªmes non seulement comment ils fonctionnent, mais parlent Ã©galement des modÃ¨les de conception. Il est facile de crÃ©er un programme compÃ©titif qui semble fonctionner. Cependant, le dÃ©veloppement, le test et le dÃ©bogage de programmes multithread posent de nombreux problÃ¨mes. Le code cesse de fonctionner au moment le plus important: sous forte charge.Dans Â«Java Concurrency in PracticeÂ», vous trouverez Ã  la fois la thÃ©orie et des mÃ©thodes spÃ©cifiques pour crÃ©er des applications parallÃ¨les fiables, Ã©volutives et prises en charge. Les auteurs ne proposent pas une liste d'API et de mÃ©canismes de parallÃ©lisme; ils introduisent des rÃ¨gles de conception, des modÃ¨les et des modÃ¨les qui sont indÃ©pendants de la version Java et restent pertinents et efficaces pendant de nombreuses annÃ©es.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extrait. </font><font style="vertical-align: inherit;">SÃ©curitÃ© des fils</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous serez peut-Ãªtre surpris que la programmation compÃ©titive soit associÃ©e aux filetages ou aux verrous </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas plus que le gÃ©nie civil ne soit associÃ© aux rivets et aux poutres en I. </font><font style="vertical-align: inherit;">Bien sÃ»r, la construction de ponts nÃ©cessite l'utilisation correcte d'un grand nombre de rivets et de poutres en I, et il en va de mÃªme pour la construction de programmes compÃ©titifs, qui nÃ©cessite l'utilisation correcte de filetages et de verrous. </font><font style="vertical-align: inherit;">Mais ce ne sont que des mÃ©canismes - des moyens pour atteindre l'objectif. </font><font style="vertical-align: inherit;">Ã‰crire du code thread-safe, c'est essentiellement contrÃ´ler l'accÃ¨s Ã  un Ã©tat, et en particulier Ã  un Ã©tat mutable.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En gÃ©nÃ©ral, l'Ã©tat d'un objet correspond Ã  ses donnÃ©es stockÃ©es dans des variables d'Ã©tat, telles que des champs d'instance et statiques ou des champs d'autres objets dÃ©pendants. L'Ã©tat du hachage HashMap est partiellement stockÃ© dans le HashMap lui-mÃªme, mais aussi dans de nombreux objets Map.Entry. L'Ã©tat d'un objet comprend toutes les donnÃ©es susceptibles d'affecter son comportement. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b>     lock  block,      Â«Â»,     ,  .            blocking.   lock    Â«Â», Â«  Â».     lock ,  ,   ,    Â«Â».  â€”          .       ,          , ,         . â€” . . .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plusieurs threads peuvent accÃ©der Ã  une variable partagÃ©e, mutÃ©e - change sa valeur. En fait, nous essayons de protÃ©ger les donnÃ©es, et non le code, contre un accÃ¨s concurrentiel incontrÃ´lÃ©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La crÃ©ation d'un objet thread-safe nÃ©cessite une synchronisation pour coordonner l'accÃ¨s Ã  un Ã©tat mutÃ©, le non-respect pouvant entraÃ®ner une corruption des donnÃ©es et d'autres consÃ©quences indÃ©sirables. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque fois que plusieurs threads accÃ¨dent Ã  une variable d'Ã©tat et que l'un des threads y Ã©crit Ã©ventuellement, tous les threads doivent coordonner leur accÃ¨s Ã  l'aide de la synchronisation. La synchronisation en Java est fournie par le mot-clÃ© synchronized, qui donne un verrouillage exclusif, ainsi que des variables volatiles et atomiques et des verrous explicites.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RÃ©sistez Ã  la tentation de penser qu'il existe des situations qui ne nÃ©cessitent pas de synchronisation. </font><font style="vertical-align: inherit;">Le programme peut fonctionner et passer ses tests, mais reste dÃ©fectueux et plante Ã  tout moment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si plusieurs threads accÃ¨dent Ã  la mÃªme variable avec un Ã©tat mutÃ© sans synchronisation appropriÃ©e, alors votre programme fonctionne mal. </font><font style="vertical-align: inherit;">Il existe trois faÃ§ons de le corriger:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne partagez pas la variable d'Ã©tat dans tous les threads</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rendre la variable d'Ã©tat non mutable;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisez la synchronisation d'Ã©tat chaque fois que vous accÃ©dez Ã  la variable d'Ã©tat.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les corrections peuvent nÃ©cessiter des modifications de conception importantes, il est donc beaucoup plus facile de concevoir une classe thread-safe immÃ©diatement que de la mettre Ã  niveau plus tard.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est difficile de savoir si plusieurs threads accÃ©deront Ã  telle ou telle variable. Heureusement, les solutions techniques orientÃ©es objet qui aident Ã  crÃ©er des classes bien organisÃ©es et faciles Ã  entretenir - telles que l'encapsulation et le masquage des donnÃ©es - aident Ã©galement Ã  crÃ©er des classes thread-safe. Moins il y a de threads qui ont accÃ¨s Ã  une variable particuliÃ¨re, plus il est facile d'assurer la synchronisation et de dÃ©finir les conditions d'accÃ¨s Ã  cette variable. Le langage Java ne vous oblige pas Ã  encapsuler l'Ã©tat - il est parfaitement acceptable de stocker l'Ã©tat dans des champs publics (mÃªme les champs statiques publics) ou de publier un lien vers un objet qui est par ailleurs interne - mais mieux l'Ã©tat de votre programme est encapsulÃ©,plus il est facile de sÃ©curiser votre thread de programme et d'aider les responsables Ã  le conserver.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la conception de classes thread-safe, de bonnes solutions techniques orientÃ©es objet: encapsulation, mutabilitÃ© et spÃ©cification claire des invariants seront vos assistants.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si les bonnes solutions techniques de conception orientÃ©e objet divergent des besoins du dÃ©veloppeur, cela vaut la peine de sacrifier les rÃ¨gles de bonne conception pour des raisons de performances ou de rÃ©trocompatibilitÃ© avec le code hÃ©ritÃ©. </font><font style="vertical-align: inherit;">Parfois, l'abstraction et l'encapsulation sont en contradiction avec les performances - bien que pas aussi souvent que le pensent de nombreux dÃ©veloppeurs - mais la meilleure pratique consiste Ã  faire le bon code en premier, puis rapidement. </font><font style="vertical-align: inherit;">Essayez d'utiliser l'optimisation uniquement si les mesures de la productivitÃ© et des besoins indiquent que vous devez le faire </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En code concurrentiel, vous devez adhÃ©rer Ã  cette pratique encore plus que d'habitude. Ã‰tant donnÃ© que les erreurs de concurrence sont extrÃªmement difficiles Ã  reproduire et ne sont pas faciles Ã  dÃ©boguer, l'avantage d'un petit gain de performances sur certaines branches de code rarement utilisÃ©es peut Ãªtre assez nÃ©gligeable par rapport au risque de plantage du programme dans les conditions de fonctionnement.</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Si vous dÃ©cidez que vous devez interrompre l'encapsulation, tout n'est pas perdu. Votre programme peut toujours Ãªtre rendu sÃ»r pour les threads, mais le processus sera plus compliquÃ© et plus cher, et le rÃ©sultat ne sera pas fiable. Le chapitre 4 dÃ©crit les conditions dans lesquelles l'encapsulation des variables d'Ã©tat peut Ãªtre attÃ©nuÃ©e en toute sÃ©curitÃ©.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jusqu'Ã  prÃ©sent, nous avons utilisÃ© presque indiffÃ©remment les termes Â«classe thread-safeÂ» et Â«programme thread-safeÂ». Un programme thread-safe est-il entiÃ¨rement construit Ã  partir de classes thread-safe? Facultatif: un programme entiÃ¨rement constituÃ© de classes thread-safe peut ne pas Ãªtre thread-safe et un programme thread-safe peut contenir des classes qui ne sont pas thread-safe. Les problÃ¨mes liÃ©s Ã  la disposition des classes thread-safe sont Ã©galement traitÃ©s au chapitre 4. Dans tous les cas, le concept de classe thread-safe n'a de sens que si la classe encapsule son propre Ã©tat. Le terme Â«thread safetyÂ» peut Ãªtre appliquÃ© au code, mais il parle de l'Ã©tat et ne peut Ãªtre appliquÃ© qu'Ã  ce tableau de code qui encapsule son Ã©tat (il peut s'agir d'un objet ou de l'ensemble du programme).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1. </font><font style="vertical-align: inherit;">Qu'est-ce que la sÃ©curitÃ© des fils?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DÃ©finir la sÃ©curitÃ© des fils n'est pas facile. </font><font style="vertical-align: inherit;">Une recherche rapide sur Google vous offre de nombreuses options comme celles-ci: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... peut Ãªtre appelÃ©e Ã  partir de plusieurs threads de programme sans interactions indÃ©sirables entre les threads. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... peut Ãªtre appelÃ© par deux threads ou plus en mÃªme temps, sans nÃ©cessiter d'autre action de la part de l'appelant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compte tenu de ces dÃ©finitions, il n'est pas surprenant que nous trouvions la sÃ©curitÃ© des threads dÃ©routante! </font><font style="vertical-align: inherit;">Comment distinguer une classe thread-safe d'une classe dangereuse? </font><font style="vertical-align: inherit;">Qu'entendons-nous par le mot Â«sÃ»rÂ»? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au cÅ“ur de toute dÃ©finition raisonnable de la sÃ©curitÃ© des threads se trouve la notion d'exactitude.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'exactitude signifie que la classe est conforme Ã  sa spÃ©cification. </font><font style="vertical-align: inherit;">La spÃ©cification dÃ©finit des invariants qui limitent l'Ã©tat d'un objet et des postconditions qui dÃ©crivent les effets des opÃ©rations. </font><font style="vertical-align: inherit;">Comment savez-vous que les spÃ©cifications des classes sont correctes? </font><font style="vertical-align: inherit;">Pas question, mais cela ne nous empÃªche pas de les utiliser aprÃ¨s nous Ãªtre convaincus que le code fonctionne. </font><font style="vertical-align: inherit;">Supposons donc que l'exactitude d'un seul thread soit visible. </font><font style="vertical-align: inherit;">Nous pouvons maintenant supposer que la classe thread-safe se comporte correctement lors de l'accÃ¨s Ã  partir de plusieurs threads.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une classe est thread-safe si elle se comporte correctement lors de l'accÃ¨s Ã  partir de plusieurs threads, quelle que soit la faÃ§on dont ces threads sont planifiÃ©s ou entrelacÃ©s par l'environnement de travail, et sans synchronisation supplÃ©mentaire ou autre coordination de la part du code appelant.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un programme multithread ne peut pas Ãªtre thread-safe s'il n'est pas correct mÃªme dans un environnement monothread </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si l'objet est correctement implÃ©mentÃ©, aucune sÃ©quence d'opÃ©rations - accÃ¨s aux mÃ©thodes publiques et lecture ou Ã©criture dans les champs publics - ne doit violer ses invariants ou ses post-conditions. </font><font style="vertical-align: inherit;">Aucun ensemble d'opÃ©rations exÃ©cutÃ©es de maniÃ¨re sÃ©quentielle ou concurrentielle sur les instances d'une classe thread-safe ne peut entraÃ®ner le non-respect d'une instance. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3) </font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si l'utilisation lÃ¢che du terme correct vous dÃ©range ici, alors vous pouvez considÃ©rer une classe thread-safe comme une classe dÃ©fectueuse dans un environnement concurrentiel, ainsi que dans un environnement Ã  thread unique.</font></font></i><br>
 <br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les classes thread-safe encapsulent elles-mÃªmes toute synchronisation nÃ©cessaire et n'ont pas besoin de l'aide du client.</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1.1. </font><font style="vertical-align: inherit;">Exemple: servlet sans support d'Ã©tat interne</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le chapitre 1, nous avons rÃ©pertoriÃ© les structures qui crÃ©ent des threads et appellent des composants Ã  partir desquelles vous Ãªtes responsable de la sÃ©curitÃ© des threads. </font><font style="vertical-align: inherit;">Nous avons maintenant l'intention de dÃ©velopper un service de factorisation de servlets et d'Ã©tendre progressivement ses fonctionnalitÃ©s tout en prÃ©servant la sÃ©curitÃ© des threads. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le listing 2.1 montre une servlet simple qui dÃ©compresse un nombre d'une requÃªte, la factorise et encapsule les rÃ©sultats en rÃ©ponse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.1. </font><font style="vertical-align: inherit;">Servlet sans support d'Ã©tat interne</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@ThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatelessFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe StatelessFactorizer, comme la plupart des servlets, n'a pas d'Ã©tat interne: elle ne contient pas de champs et ne fait pas rÃ©fÃ©rence Ã  des champs d'autres classes. </font><font style="vertical-align: inherit;">L'Ã©tat d'un calcul particulier n'existe que dans les variables locales qui sont stockÃ©es dans la pile de flux et ne sont disponibles que pour le flux en cours d'exÃ©cution. </font><font style="vertical-align: inherit;">Un thread accÃ©dant Ã  StatelessFactorizer ne peut pas affecter le rÃ©sultat d'un autre thread faisant de mÃªme, car ces threads ne partagent pas l'Ã©tat.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les objets sans support d'Ã©tat interne sont toujours thread-safe.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fait que la plupart des servlets peuvent Ãªtre implÃ©mentÃ©s sans prise en charge de l'Ã©tat interne rÃ©duit considÃ©rablement la charge de threading des servlets eux-mÃªmes. </font><font style="vertical-align: inherit;">Et ce n'est que lorsque les servlets doivent se souvenir de quelque chose que les exigences relatives Ã  la sÃ©curitÃ© de leur filetage augmentent.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2. </font><font style="vertical-align: inherit;">AtomicitÃ©</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que se passe-t-il lorsqu'un Ã©lÃ©ment d'Ã©tat est ajoutÃ© Ã  un objet sans prise en charge d'Ã©tat interne? Supposons que nous voulons ajouter un compteur d'accÃ¨s qui mesure le nombre de demandes traitÃ©es. Vous pouvez ajouter un champ de type long Ã  la servlet et l'incrÃ©menter Ã  chaque demande, comme indiquÃ© dans UnsafeCountingFactorizer dans le listing 2.2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.2. Servlet qui compte les demandes sans la synchronisation nÃ©cessaire. Cela ne devrait pas Ãªtre fait.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/lj/hg/geljhgzyo9aogxu-ttztrzuawqo.jpeg" alt="image"></div><br>
<pre><code class="java hljs"><span class="hljs-meta">@NotThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeCountingFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> count = <span class="hljs-number">0</span>;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> count; }<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            ++count;<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, la classe UnsafeCountingFactorizer n'est pas adaptÃ©e aux threads, mÃªme si elle fonctionne correctement dans un environnement Ã  thread unique. Comme UnsafeSequence, il est sujet Ã  des mises Ã  jour perdues. Bien que le nombre d'opÃ©rations d'incrÃ©mentation ++ ait une syntaxe compacte, il n'est pas atomique, c'est-Ã -dire indivisible, mais une sÃ©quence de trois opÃ©rations: fournir la valeur actuelle, en ajouter une et rÃ©Ã©crire la nouvelle valeur. Dans les opÃ©rations Â«lire, changer, Ã©crireÂ», l'Ã©tat rÃ©sultant est dÃ©rivÃ© du prÃ©cÃ©dent.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En figue. </font><font style="vertical-align: inherit;">1.1, il est montrÃ© ce qui peut arriver si deux threads essaient d'augmenter le compteur en mÃªme temps, sans synchronisation. </font><font style="vertical-align: inherit;">Si le compteur est 9, alors en raison d'une coordination temporelle infructueuse, les deux threads verront la valeur 9, en ajouter un et dÃ©finir la valeur Ã  10. Ainsi, le compteur d'accÃ¨s commencera Ã  Ãªtre dÃ©calÃ© d'un. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pourriez penser qu'avoir un compteur d'accÃ¨s lÃ©gÃ¨rement inexact dans un service Web est une perte acceptable, et parfois c'est le cas. </font><font style="vertical-align: inherit;">Mais si le compteur est utilisÃ© pour crÃ©er des sÃ©quences ou des identificateurs uniques d'objets, le retour de la mÃªme valeur Ã  partir de plusieurs activations peut entraÃ®ner de graves problÃ¨mes d'intÃ©gritÃ© des donnÃ©es. </font><font style="vertical-align: inherit;">La possibilitÃ© d'apparition de rÃ©sultats incorrects en raison d'une coordination temporelle non rÃ©ussie se prÃ©sente dans une condition de race.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1. </font><font style="vertical-align: inherit;">Conditions de course</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe UnsafeCountingFactorizer a plusieurs conditions de concurrence </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Le type de condition de concurrence le plus courant est la situation Â«vÃ©rifier puis agirÂ», oÃ¹ une observation potentiellement obsolÃ¨te est utilisÃ©e pour dÃ©cider quoi faire ensuite. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b> <i>          (data race).   ,            .        ,    ,       ,   ,         ,      .               Java.       ,        ,             . UnsafeCountingFactorizer   .       16.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous rencontrons souvent une condition de course dans la vraie vie. Supposons que vous prÃ©voyez de rencontrer un ami Ã  midi au Starbucks CafÃ© sur Universitetskiy Prospekt. Mais vous dÃ©couvrirez qu'il y a deux Starbucks sur University Avenue. A 12h10, vous ne voyez pas votre ami dans le cafÃ© A et allez au cafÃ© B, mais il n'est pas lÃ  non plus. Soit votre ami est en retard, soit il est arrivÃ© au cafÃ© A immÃ©diatement aprÃ¨s votre dÃ©part, soit il Ã©tait au cafÃ© B, mais il est allÃ© vous chercher et est maintenant en route vers le cafÃ© A. Nous accepterons ce dernier, c'est-Ã -dire le pire des cas. Maintenant 12:15, et vous vous demandez tous les deux si votre ami a tenu sa promesse. Retournerez-vous dans un autre cafÃ©? Combien de fois allez-vous faire des allers-retours? Si vous n'Ãªtes pas d'accord sur un protocole, vous pouvez passer toute la journÃ©e Ã  marcher le long de l'avenue University dans une euphorie cafÃ©inÃ©e.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le problÃ¨me avec l'approche Â«faire une promenade et voir s'il est lÃ Â» est qu'une promenade le long de la rue entre deux cafÃ©s prend plusieurs minutes, et pendant ce temps, l'Ã©tat du systÃ¨me peut changer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'exemple avec Starbucks illustre la dÃ©pendance du rÃ©sultat sur la coordination temporelle relative des Ã©vÃ©nements (sur combien de temps vous attendez un ami dans un cafÃ©, etc.). </font><font style="vertical-align: inherit;">L'observation selon laquelle il n'est pas dans le cafÃ© A devient potentiellement invalide: dÃ¨s que vous sortez de la porte d'entrÃ©e, il peut entrer par la porte arriÃ¨re. </font><font style="vertical-align: inherit;">La plupart des conditions de concurrence provoquent des problÃ¨mes tels qu'une exception inattendue, des donnÃ©es Ã©crasÃ©es et une corruption de fichiers.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2. </font><font style="vertical-align: inherit;">Exemple: conditions de concurrence dans l'initialisation paresseuse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une astuce courante utilisant l'approche Â«vÃ©rifier puis agirÂ» est l'initialisation paresseuse (LazyInitRace). Son but est de reporter l'initialisation de l'objet jusqu'Ã  ce qu'il soit nÃ©cessaire et de s'assurer qu'il n'est initialisÃ© qu'une seule fois. Dans le listing 2.3, la mÃ©thode getInstance garantit que l'objet ExpensiveObject est initialisÃ© et renvoie une instance existante, ou sinon, crÃ©e une nouvelle instance et la renvoie aprÃ¨s avoir conservÃ© une rÃ©fÃ©rence Ã  celle-ci. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.3. La condition de concurrence critique est en initialisation paresseuse. Cela ne devrait pas Ãªtre fait.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/lj/hg/geljhgzyo9aogxu-ttztrzuawqo.jpeg" alt="image"></div><br>
<pre><code class="java hljs"><span class="hljs-meta">@NotThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyInitRace</span> </span>{
      <span class="hljs-keyword">private</span> ExpensiveObject instance = <span class="hljs-keyword">null</span>;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> ExpensiveObject <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)<font></font>
                instance = <span class="hljs-keyword">new</span> ExpensiveObject();
            <span class="hljs-keyword">return</span> instance;<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe LazyInitRace contient des conditions de concurrence. Supposons que les threads A et B exÃ©cutent la mÃ©thode getInstance en mÃªme temps. A voit que le champ d'instance est nul et crÃ©e un nouvel ExpensiveObject. Le thread B vÃ©rifie Ã©galement si le champ d'instance est le mÃªme null. La prÃ©sence de null dans le champ Ã  ce moment dÃ©pend de la coordination temporelle, y compris des alÃ©as de la planification et du temps nÃ©cessaire pour crÃ©er une instance de ExpensiveObject et dÃ©finir la valeur dans le champ d'instance. Si le champ d'instance est nul lorsque B le vÃ©rifie, deux Ã©lÃ©ments de code appelant la mÃ©thode getInstance peuvent obtenir deux rÃ©sultats diffÃ©rents, mÃªme si la mÃ©thode getInstance est censÃ©e toujours renvoyer la mÃªme instance.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le compteur d'accÃ¨s dans UnsafeCountingFactorizer contient Ã©galement des conditions de concurrence. L'approche Â«lire, modifier, Ã©crireÂ» implique que pour incrÃ©menter le compteur, le flux doit connaÃ®tre sa valeur prÃ©cÃ©dente et s'assurer que personne d'autre ne modifie ou n'utilise cette valeur pendant le processus de mise Ã  jour.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme la plupart des erreurs de compÃ©tition, les conditions de course ne mÃ¨nent pas toujours Ã  l'Ã©chec: la coordination temporaire est rÃ©ussie. </font><font style="vertical-align: inherit;">Mais si la classe LazyInitRace est utilisÃ©e pour instancier le registre de l'application entiÃ¨re, alors quand elle renverra diffÃ©rentes instances de plusieurs activations, les enregistrements seront perdus ou les actions recevront des reprÃ©sentations conflictuelles de l'ensemble d'objets enregistrÃ©s. </font><font style="vertical-align: inherit;">Ou si la classe UnsafeSequence est utilisÃ©e pour gÃ©nÃ©rer des identifiants d'entitÃ© dans une structure de conservation des donnÃ©es, deux objets diffÃ©rents peuvent avoir le mÃªme identifiant, violant les restrictions d'identitÃ©.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3. </font><font style="vertical-align: inherit;">Actions composÃ©es</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LazyInitRace et UnsafeCountingFactorizer contiennent une sÃ©quence d'opÃ©rations qui doit Ãªtre atomique. </font><font style="vertical-align: inherit;">Mais pour Ã©viter une condition de concurrence, il doit y avoir un obstacle pour que d'autres threads utilisent la variable pendant qu'un thread la modifie.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les opÃ©rations A et B sont atomiques si, du point de vue du thread exÃ©cutant l'opÃ©ration A, l'opÃ©ration B a Ã©tÃ© entiÃ¨rement rÃ©alisÃ©e par un autre thread ou pas mÃªme partiellement.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'atomicitÃ© de l'opÃ©ration d'incrÃ©mentation dans UnsafeSequence Ã©viterait la condition de concurrence montrÃ©e sur la Fig. 1.1. Les opÃ©rations Â«vÃ©rifier puis agirÂ» et Â«lire, changer, Ã©crireÂ» doivent toujours Ãªtre atomiques. On les appelle des actions composÃ©es - des sÃ©quences d'opÃ©rations qui doivent Ãªtre exÃ©cutÃ©es atomiquement afin de rester thread-safe. Dans la section suivante, nous considÃ©rerons le verrouillage - un mÃ©canisme intÃ©grÃ© Ã  Java qui fournit l'atomicitÃ©. En attendant, nous allons rÃ©soudre le problÃ¨me d'une autre maniÃ¨re en appliquant la classe thread-safe existante, comme indiquÃ© dans le Countingfactorizer du Listing 2.4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.4. Demandes de comptage de servlets utilisant AtomicLong</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@ThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicLong count = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> count.get(); }<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            count.incrementAndGet();<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le package java.util.concurrent.atomic contient des variables atomiques pour gÃ©rer les Ã©tats de classe. En remplaÃ§ant le type de compteur de long par AtomicLong, nous garantissons que toutes les actions qui font rÃ©fÃ©rence Ã  l'Ã©tat du compteur sont atomic1. Ã‰tant donnÃ© que l'Ã©tat de la servlet est l'Ã©tat du compteur et que le compteur est thread-safe, notre servlet devient thread-safe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsqu'un Ã©lÃ©ment d'Ã©tat unique est ajoutÃ© Ã  une classe qui ne prend pas en charge l'Ã©tat interne, la classe rÃ©sultante sera thread-safe si l'Ã©tat est complÃ¨tement contrÃ´lÃ© par l'objet thread-safe. Mais, comme nous le verrons dans la section suivante, la transition d'une variable d'Ã©tat Ã  la suivante ne sera pas aussi simple que la transition de zÃ©ro Ã  un.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque cela est possible, utilisez des objets thread-safe existants, tels que AtomicLong, pour contrÃ´ler l'Ã©tat de votre classe. </font><font style="vertical-align: inherit;">Les Ã©tats possibles des objets thread-safe existants et leurs transitions vers d'autres Ã©tats sont plus faciles Ã  maintenir et Ã  vÃ©rifier la sÃ©curitÃ© des threads que les variables d'Ã©tat arbitraires.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Â»Plus d'informations sur le livre peuvent Ãªtre trouvÃ©es sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le site Web de l'Ã©diteur</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Â» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenu</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Â» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extrait</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
pour Khabrozhiteley 25% de rÃ©duction sur le coupon - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
AprÃ¨s le paiement de la version papier du livre, un livre Ã©lectronique est envoyÃ© par e-mail.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr489022/index.html">Utilisation de RabbitMQ avec MonsterMQ Partie 2</a></li>
<li><a href="../fr489024/index.html">BibliothÃ¨que JavaScript Webix vue par un dÃ©butant. Partie 5. Travailler avec des donnÃ©es cÃ´tÃ© utilisateur</a></li>
<li><a href="../fr489026/index.html">La modification des algorithmes Google AdSense peut conduire les propriÃ©taires de sites et les webmasters</a></li>
<li><a href="../fr489028/index.html">Ã€ propos du travail Ã  distance</a></li>
<li><a href="../fr489034/index.html">La nouvelle application mobile de l'ISU pour le salut ou le salut pour ceux qui cherchent des marchÃ©s publics?</a></li>
<li><a href="../fr489040/index.html">Contact Center AI: un tiers dans une conversation est trÃ¨s bien</a></li>
<li><a href="../fr489042/index.html">Grande rÃ©ouverture de la boutique: chargement de donnÃ©es dans Android Ã  l'aide de coroutine</a></li>
<li><a href="../fr489044/index.html">Physique du texte. Partie 1. Symboles</a></li>
<li><a href="../fr489046/index.html">GAZ66 Monster Truck sans conducteur 1/16</a></li>
<li><a href="../fr489048/index.html">La journalisation et le suivi des requÃªtes sont les meilleures pratiques. Rapport Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>