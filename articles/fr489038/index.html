<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍽️ 📈 👩🏾‍🚒 Le livre "Java Concurrency in Practice" 💓 👩🏾‍🤝‍👩🏻 👨🏻‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, habrozhiteli! Les flux sont une partie fondamentale de la plate-forme Java. Les processeurs multicœurs sont monnaie courante et l'utilisation...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Le livre "Java Concurrency in Practice"</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/489038/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/1r/ku/4r/1rku4rb0w0tevxfiae9gxkkkzse.jpeg" align="left" alt="image"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, habrozhiteli! Les flux sont une partie fondamentale de la plate-forme Java. Les processeurs multicœurs sont monnaie courante et l'utilisation efficace de la concurrence est devenue nécessaire pour créer toute application hautes performances. Une machine virtuelle Java améliorée, la prise en charge de classes hautes performances et un riche ensemble de blocs de construction pour les tâches de parallélisation ont été à un moment donné une percée dans le développement d'applications parallèles. Dans Java Concurrency in Practice, les créateurs de technologies révolutionnaires expliquent eux-mêmes non seulement comment ils fonctionnent, mais parlent également des modèles de conception. Il est facile de créer un programme compétitif qui semble fonctionner. Cependant, le développement, le test et le débogage de programmes multithread posent de nombreux problèmes. Le code cesse de fonctionner au moment le plus important: sous forte charge.Dans «Java Concurrency in Practice», vous trouverez à la fois la théorie et des méthodes spécifiques pour créer des applications parallèles fiables, évolutives et prises en charge. Les auteurs ne proposent pas une liste d'API et de mécanismes de parallélisme; ils introduisent des règles de conception, des modèles et des modèles qui sont indépendants de la version Java et restent pertinents et efficaces pendant de nombreuses années.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extrait. </font><font style="vertical-align: inherit;">Sécurité des fils</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous serez peut-être surpris que la programmation compétitive soit associée aux filetages ou aux verrous </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas plus que le génie civil ne soit associé aux rivets et aux poutres en I. </font><font style="vertical-align: inherit;">Bien sûr, la construction de ponts nécessite l'utilisation correcte d'un grand nombre de rivets et de poutres en I, et il en va de même pour la construction de programmes compétitifs, qui nécessite l'utilisation correcte de filetages et de verrous. </font><font style="vertical-align: inherit;">Mais ce ne sont que des mécanismes - des moyens pour atteindre l'objectif. </font><font style="vertical-align: inherit;">Écrire du code thread-safe, c'est essentiellement contrôler l'accès à un état, et en particulier à un état mutable.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, l'état d'un objet correspond à ses données stockées dans des variables d'état, telles que des champs d'instance et statiques ou des champs d'autres objets dépendants. L'état du hachage HashMap est partiellement stocké dans le HashMap lui-même, mais aussi dans de nombreux objets Map.Entry. L'état d'un objet comprend toutes les données susceptibles d'affecter son comportement. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b>     lock  block,      «»,     ,  .            blocking.   lock    «», «  ».     lock ,  ,   ,    «».  —          .       ,          , ,         . — . . .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plusieurs threads peuvent accéder à une variable partagée, mutée - change sa valeur. En fait, nous essayons de protéger les données, et non le code, contre un accès concurrentiel incontrôlé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La création d'un objet thread-safe nécessite une synchronisation pour coordonner l'accès à un état muté, le non-respect pouvant entraîner une corruption des données et d'autres conséquences indésirables. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque fois que plusieurs threads accèdent à une variable d'état et que l'un des threads y écrit éventuellement, tous les threads doivent coordonner leur accès à l'aide de la synchronisation. La synchronisation en Java est fournie par le mot-clé synchronized, qui donne un verrouillage exclusif, ainsi que des variables volatiles et atomiques et des verrous explicites.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Résistez à la tentation de penser qu'il existe des situations qui ne nécessitent pas de synchronisation. </font><font style="vertical-align: inherit;">Le programme peut fonctionner et passer ses tests, mais reste défectueux et plante à tout moment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si plusieurs threads accèdent à la même variable avec un état muté sans synchronisation appropriée, alors votre programme fonctionne mal. </font><font style="vertical-align: inherit;">Il existe trois façons de le corriger:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne partagez pas la variable d'état dans tous les threads</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rendre la variable d'état non mutable;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisez la synchronisation d'état chaque fois que vous accédez à la variable d'état.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les corrections peuvent nécessiter des modifications de conception importantes, il est donc beaucoup plus facile de concevoir une classe thread-safe immédiatement que de la mettre à niveau plus tard.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est difficile de savoir si plusieurs threads accéderont à telle ou telle variable. Heureusement, les solutions techniques orientées objet qui aident à créer des classes bien organisées et faciles à entretenir - telles que l'encapsulation et le masquage des données - aident également à créer des classes thread-safe. Moins il y a de threads qui ont accès à une variable particulière, plus il est facile d'assurer la synchronisation et de définir les conditions d'accès à cette variable. Le langage Java ne vous oblige pas à encapsuler l'état - il est parfaitement acceptable de stocker l'état dans des champs publics (même les champs statiques publics) ou de publier un lien vers un objet qui est par ailleurs interne - mais mieux l'état de votre programme est encapsulé,plus il est facile de sécuriser votre thread de programme et d'aider les responsables à le conserver.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la conception de classes thread-safe, de bonnes solutions techniques orientées objet: encapsulation, mutabilité et spécification claire des invariants seront vos assistants.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si les bonnes solutions techniques de conception orientée objet divergent des besoins du développeur, cela vaut la peine de sacrifier les règles de bonne conception pour des raisons de performances ou de rétrocompatibilité avec le code hérité. </font><font style="vertical-align: inherit;">Parfois, l'abstraction et l'encapsulation sont en contradiction avec les performances - bien que pas aussi souvent que le pensent de nombreux développeurs - mais la meilleure pratique consiste à faire le bon code en premier, puis rapidement. </font><font style="vertical-align: inherit;">Essayez d'utiliser l'optimisation uniquement si les mesures de la productivité et des besoins indiquent que vous devez le faire </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En code concurrentiel, vous devez adhérer à cette pratique encore plus que d'habitude. Étant donné que les erreurs de concurrence sont extrêmement difficiles à reproduire et ne sont pas faciles à déboguer, l'avantage d'un petit gain de performances sur certaines branches de code rarement utilisées peut être assez négligeable par rapport au risque de plantage du programme dans les conditions de fonctionnement.</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Si vous décidez que vous devez interrompre l'encapsulation, tout n'est pas perdu. Votre programme peut toujours être rendu sûr pour les threads, mais le processus sera plus compliqué et plus cher, et le résultat ne sera pas fiable. Le chapitre 4 décrit les conditions dans lesquelles l'encapsulation des variables d'état peut être atténuée en toute sécurité.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jusqu'à présent, nous avons utilisé presque indifféremment les termes «classe thread-safe» et «programme thread-safe». Un programme thread-safe est-il entièrement construit à partir de classes thread-safe? Facultatif: un programme entièrement constitué de classes thread-safe peut ne pas être thread-safe et un programme thread-safe peut contenir des classes qui ne sont pas thread-safe. Les problèmes liés à la disposition des classes thread-safe sont également traités au chapitre 4. Dans tous les cas, le concept de classe thread-safe n'a de sens que si la classe encapsule son propre état. Le terme «thread safety» peut être appliqué au code, mais il parle de l'état et ne peut être appliqué qu'à ce tableau de code qui encapsule son état (il peut s'agir d'un objet ou de l'ensemble du programme).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1. </font><font style="vertical-align: inherit;">Qu'est-ce que la sécurité des fils?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Définir la sécurité des fils n'est pas facile. </font><font style="vertical-align: inherit;">Une recherche rapide sur Google vous offre de nombreuses options comme celles-ci: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... peut être appelée à partir de plusieurs threads de programme sans interactions indésirables entre les threads. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... peut être appelé par deux threads ou plus en même temps, sans nécessiter d'autre action de la part de l'appelant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compte tenu de ces définitions, il n'est pas surprenant que nous trouvions la sécurité des threads déroutante! </font><font style="vertical-align: inherit;">Comment distinguer une classe thread-safe d'une classe dangereuse? </font><font style="vertical-align: inherit;">Qu'entendons-nous par le mot «sûr»? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au cœur de toute définition raisonnable de la sécurité des threads se trouve la notion d'exactitude.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'exactitude signifie que la classe est conforme à sa spécification. </font><font style="vertical-align: inherit;">La spécification définit des invariants qui limitent l'état d'un objet et des postconditions qui décrivent les effets des opérations. </font><font style="vertical-align: inherit;">Comment savez-vous que les spécifications des classes sont correctes? </font><font style="vertical-align: inherit;">Pas question, mais cela ne nous empêche pas de les utiliser après nous être convaincus que le code fonctionne. </font><font style="vertical-align: inherit;">Supposons donc que l'exactitude d'un seul thread soit visible. </font><font style="vertical-align: inherit;">Nous pouvons maintenant supposer que la classe thread-safe se comporte correctement lors de l'accès à partir de plusieurs threads.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une classe est thread-safe si elle se comporte correctement lors de l'accès à partir de plusieurs threads, quelle que soit la façon dont ces threads sont planifiés ou entrelacés par l'environnement de travail, et sans synchronisation supplémentaire ou autre coordination de la part du code appelant.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un programme multithread ne peut pas être thread-safe s'il n'est pas correct même dans un environnement monothread </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si l'objet est correctement implémenté, aucune séquence d'opérations - accès aux méthodes publiques et lecture ou écriture dans les champs publics - ne doit violer ses invariants ou ses post-conditions. </font><font style="vertical-align: inherit;">Aucun ensemble d'opérations exécutées de manière séquentielle ou concurrentielle sur les instances d'une classe thread-safe ne peut entraîner le non-respect d'une instance. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3) </font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si l'utilisation lâche du terme correct vous dérange ici, alors vous pouvez considérer une classe thread-safe comme une classe défectueuse dans un environnement concurrentiel, ainsi que dans un environnement à thread unique.</font></font></i><br>
 <br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les classes thread-safe encapsulent elles-mêmes toute synchronisation nécessaire et n'ont pas besoin de l'aide du client.</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1.1. </font><font style="vertical-align: inherit;">Exemple: servlet sans support d'état interne</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le chapitre 1, nous avons répertorié les structures qui créent des threads et appellent des composants à partir desquelles vous êtes responsable de la sécurité des threads. </font><font style="vertical-align: inherit;">Nous avons maintenant l'intention de développer un service de factorisation de servlets et d'étendre progressivement ses fonctionnalités tout en préservant la sécurité des threads. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le listing 2.1 montre une servlet simple qui décompresse un nombre d'une requête, la factorise et encapsule les résultats en réponse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.1. </font><font style="vertical-align: inherit;">Servlet sans support d'état interne</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@ThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatelessFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe StatelessFactorizer, comme la plupart des servlets, n'a pas d'état interne: elle ne contient pas de champs et ne fait pas référence à des champs d'autres classes. </font><font style="vertical-align: inherit;">L'état d'un calcul particulier n'existe que dans les variables locales qui sont stockées dans la pile de flux et ne sont disponibles que pour le flux en cours d'exécution. </font><font style="vertical-align: inherit;">Un thread accédant à StatelessFactorizer ne peut pas affecter le résultat d'un autre thread faisant de même, car ces threads ne partagent pas l'état.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les objets sans support d'état interne sont toujours thread-safe.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fait que la plupart des servlets peuvent être implémentés sans prise en charge de l'état interne réduit considérablement la charge de threading des servlets eux-mêmes. </font><font style="vertical-align: inherit;">Et ce n'est que lorsque les servlets doivent se souvenir de quelque chose que les exigences relatives à la sécurité de leur filetage augmentent.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2. </font><font style="vertical-align: inherit;">Atomicité</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que se passe-t-il lorsqu'un élément d'état est ajouté à un objet sans prise en charge d'état interne? Supposons que nous voulons ajouter un compteur d'accès qui mesure le nombre de demandes traitées. Vous pouvez ajouter un champ de type long à la servlet et l'incrémenter à chaque demande, comme indiqué dans UnsafeCountingFactorizer dans le listing 2.2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.2. Servlet qui compte les demandes sans la synchronisation nécessaire. Cela ne devrait pas être fait.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/lj/hg/geljhgzyo9aogxu-ttztrzuawqo.jpeg" alt="image"></div><br>
<pre><code class="java hljs"><span class="hljs-meta">@NotThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeCountingFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> count = <span class="hljs-number">0</span>;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> count; }<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            ++count;<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, la classe UnsafeCountingFactorizer n'est pas adaptée aux threads, même si elle fonctionne correctement dans un environnement à thread unique. Comme UnsafeSequence, il est sujet à des mises à jour perdues. Bien que le nombre d'opérations d'incrémentation ++ ait une syntaxe compacte, il n'est pas atomique, c'est-à-dire indivisible, mais une séquence de trois opérations: fournir la valeur actuelle, en ajouter une et réécrire la nouvelle valeur. Dans les opérations «lire, changer, écrire», l'état résultant est dérivé du précédent.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En figue. </font><font style="vertical-align: inherit;">1.1, il est montré ce qui peut arriver si deux threads essaient d'augmenter le compteur en même temps, sans synchronisation. </font><font style="vertical-align: inherit;">Si le compteur est 9, alors en raison d'une coordination temporelle infructueuse, les deux threads verront la valeur 9, en ajouter un et définir la valeur à 10. Ainsi, le compteur d'accès commencera à être décalé d'un. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pourriez penser qu'avoir un compteur d'accès légèrement inexact dans un service Web est une perte acceptable, et parfois c'est le cas. </font><font style="vertical-align: inherit;">Mais si le compteur est utilisé pour créer des séquences ou des identificateurs uniques d'objets, le retour de la même valeur à partir de plusieurs activations peut entraîner de graves problèmes d'intégrité des données. </font><font style="vertical-align: inherit;">La possibilité d'apparition de résultats incorrects en raison d'une coordination temporelle non réussie se présente dans une condition de race.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1. </font><font style="vertical-align: inherit;">Conditions de course</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe UnsafeCountingFactorizer a plusieurs conditions de concurrence </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Le type de condition de concurrence le plus courant est la situation «vérifier puis agir», où une observation potentiellement obsolète est utilisée pour décider quoi faire ensuite. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b> <i>          (data race).   ,            .        ,    ,       ,   ,         ,      .               Java.       ,        ,             . UnsafeCountingFactorizer   .       16.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous rencontrons souvent une condition de course dans la vraie vie. Supposons que vous prévoyez de rencontrer un ami à midi au Starbucks Café sur Universitetskiy Prospekt. Mais vous découvrirez qu'il y a deux Starbucks sur University Avenue. A 12h10, vous ne voyez pas votre ami dans le café A et allez au café B, mais il n'est pas là non plus. Soit votre ami est en retard, soit il est arrivé au café A immédiatement après votre départ, soit il était au café B, mais il est allé vous chercher et est maintenant en route vers le café A. Nous accepterons ce dernier, c'est-à-dire le pire des cas. Maintenant 12:15, et vous vous demandez tous les deux si votre ami a tenu sa promesse. Retournerez-vous dans un autre café? Combien de fois allez-vous faire des allers-retours? Si vous n'êtes pas d'accord sur un protocole, vous pouvez passer toute la journée à marcher le long de l'avenue University dans une euphorie caféinée.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le problème avec l'approche «faire une promenade et voir s'il est là» est qu'une promenade le long de la rue entre deux cafés prend plusieurs minutes, et pendant ce temps, l'état du système peut changer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'exemple avec Starbucks illustre la dépendance du résultat sur la coordination temporelle relative des événements (sur combien de temps vous attendez un ami dans un café, etc.). </font><font style="vertical-align: inherit;">L'observation selon laquelle il n'est pas dans le café A devient potentiellement invalide: dès que vous sortez de la porte d'entrée, il peut entrer par la porte arrière. </font><font style="vertical-align: inherit;">La plupart des conditions de concurrence provoquent des problèmes tels qu'une exception inattendue, des données écrasées et une corruption de fichiers.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2. </font><font style="vertical-align: inherit;">Exemple: conditions de concurrence dans l'initialisation paresseuse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une astuce courante utilisant l'approche «vérifier puis agir» est l'initialisation paresseuse (LazyInitRace). Son but est de reporter l'initialisation de l'objet jusqu'à ce qu'il soit nécessaire et de s'assurer qu'il n'est initialisé qu'une seule fois. Dans le listing 2.3, la méthode getInstance garantit que l'objet ExpensiveObject est initialisé et renvoie une instance existante, ou sinon, crée une nouvelle instance et la renvoie après avoir conservé une référence à celle-ci. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.3. La condition de concurrence critique est en initialisation paresseuse. Cela ne devrait pas être fait.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/lj/hg/geljhgzyo9aogxu-ttztrzuawqo.jpeg" alt="image"></div><br>
<pre><code class="java hljs"><span class="hljs-meta">@NotThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyInitRace</span> </span>{
      <span class="hljs-keyword">private</span> ExpensiveObject instance = <span class="hljs-keyword">null</span>;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> ExpensiveObject <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)<font></font>
                instance = <span class="hljs-keyword">new</span> ExpensiveObject();
            <span class="hljs-keyword">return</span> instance;<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe LazyInitRace contient des conditions de concurrence. Supposons que les threads A et B exécutent la méthode getInstance en même temps. A voit que le champ d'instance est nul et crée un nouvel ExpensiveObject. Le thread B vérifie également si le champ d'instance est le même null. La présence de null dans le champ à ce moment dépend de la coordination temporelle, y compris des aléas de la planification et du temps nécessaire pour créer une instance de ExpensiveObject et définir la valeur dans le champ d'instance. Si le champ d'instance est nul lorsque B le vérifie, deux éléments de code appelant la méthode getInstance peuvent obtenir deux résultats différents, même si la méthode getInstance est censée toujours renvoyer la même instance.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le compteur d'accès dans UnsafeCountingFactorizer contient également des conditions de concurrence. L'approche «lire, modifier, écrire» implique que pour incrémenter le compteur, le flux doit connaître sa valeur précédente et s'assurer que personne d'autre ne modifie ou n'utilise cette valeur pendant le processus de mise à jour.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme la plupart des erreurs de compétition, les conditions de course ne mènent pas toujours à l'échec: la coordination temporaire est réussie. </font><font style="vertical-align: inherit;">Mais si la classe LazyInitRace est utilisée pour instancier le registre de l'application entière, alors quand elle renverra différentes instances de plusieurs activations, les enregistrements seront perdus ou les actions recevront des représentations conflictuelles de l'ensemble d'objets enregistrés. </font><font style="vertical-align: inherit;">Ou si la classe UnsafeSequence est utilisée pour générer des identifiants d'entité dans une structure de conservation des données, deux objets différents peuvent avoir le même identifiant, violant les restrictions d'identité.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3. </font><font style="vertical-align: inherit;">Actions composées</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LazyInitRace et UnsafeCountingFactorizer contiennent une séquence d'opérations qui doit être atomique. </font><font style="vertical-align: inherit;">Mais pour éviter une condition de concurrence, il doit y avoir un obstacle pour que d'autres threads utilisent la variable pendant qu'un thread la modifie.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les opérations A et B sont atomiques si, du point de vue du thread exécutant l'opération A, l'opération B a été entièrement réalisée par un autre thread ou pas même partiellement.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'atomicité de l'opération d'incrémentation dans UnsafeSequence éviterait la condition de concurrence montrée sur la Fig. 1.1. Les opérations «vérifier puis agir» et «lire, changer, écrire» doivent toujours être atomiques. On les appelle des actions composées - des séquences d'opérations qui doivent être exécutées atomiquement afin de rester thread-safe. Dans la section suivante, nous considérerons le verrouillage - un mécanisme intégré à Java qui fournit l'atomicité. En attendant, nous allons résoudre le problème d'une autre manière en appliquant la classe thread-safe existante, comme indiqué dans le Countingfactorizer du Listing 2.4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.4. Demandes de comptage de servlets utilisant AtomicLong</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@ThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicLong count = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> count.get(); }<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            count.incrementAndGet();<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le package java.util.concurrent.atomic contient des variables atomiques pour gérer les états de classe. En remplaçant le type de compteur de long par AtomicLong, nous garantissons que toutes les actions qui font référence à l'état du compteur sont atomic1. Étant donné que l'état de la servlet est l'état du compteur et que le compteur est thread-safe, notre servlet devient thread-safe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsqu'un élément d'état unique est ajouté à une classe qui ne prend pas en charge l'état interne, la classe résultante sera thread-safe si l'état est complètement contrôlé par l'objet thread-safe. Mais, comme nous le verrons dans la section suivante, la transition d'une variable d'état à la suivante ne sera pas aussi simple que la transition de zéro à un.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque cela est possible, utilisez des objets thread-safe existants, tels que AtomicLong, pour contrôler l'état de votre classe. </font><font style="vertical-align: inherit;">Les états possibles des objets thread-safe existants et leurs transitions vers d'autres états sont plus faciles à maintenir et à vérifier la sécurité des threads que les variables d'état arbitraires.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
»Plus d'informations sur le livre peuvent être trouvées sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le site Web de l'éditeur</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenu</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extrait</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
pour Khabrozhiteley 25% de réduction sur le coupon - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Après le paiement de la version papier du livre, un livre électronique est envoyé par e-mail.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr489022/index.html">Utilisation de RabbitMQ avec MonsterMQ Partie 2</a></li>
<li><a href="../fr489024/index.html">Bibliothèque JavaScript Webix vue par un débutant. Partie 5. Travailler avec des données côté utilisateur</a></li>
<li><a href="../fr489026/index.html">La modification des algorithmes Google AdSense peut conduire les propriétaires de sites et les webmasters</a></li>
<li><a href="../fr489028/index.html">À propos du travail à distance</a></li>
<li><a href="../fr489034/index.html">La nouvelle application mobile de l'ISU pour le salut ou le salut pour ceux qui cherchent des marchés publics?</a></li>
<li><a href="../fr489040/index.html">Contact Center AI: un tiers dans une conversation est très bien</a></li>
<li><a href="../fr489042/index.html">Grande réouverture de la boutique: chargement de données dans Android à l'aide de coroutine</a></li>
<li><a href="../fr489044/index.html">Physique du texte. Partie 1. Symboles</a></li>
<li><a href="../fr489046/index.html">GAZ66 Monster Truck sans conducteur 1/16</a></li>
<li><a href="../fr489048/index.html">La journalisation et le suivi des requêtes sont les meilleures pratiques. Rapport Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>