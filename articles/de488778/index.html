<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úäüèø üëÆ ‚òéÔ∏è Datenstrukturen: Eine Liste, die alles kann * ü§≤üèø üëãüèΩ ü•í</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Mit allem meine ich die relativ schnelle Ausf√ºhrung von Operationen an einem einzelnen Element eines Arrays. 
 
 Die Datenstrukturen, die die Liste ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Datenstrukturen: Eine Liste, die alles kann *</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488778/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Mit allem meine ich die relativ schnelle Ausf√ºhrung von Operationen an einem einzelnen Element eines Arrays. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Datenstrukturen, die die Liste implementieren, sind vollst√§ndig. </font><font style="vertical-align: inherit;">Jeder hat seine eigenen Vor- und Nachteile. </font><font style="vertical-align: inherit;">In der Java-Welt k√∂nnen Sie beispielsweise - abh√§ngig von den erforderlichen Operationen - Folgendes verwenden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add (obj), get (obj), set (index, obj): eine Grundmenge fast aller Listen, z. B. ArrayList. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add (index, obj): baumartige Strukturen, z. B. TreeList aus Apache Common-Collections. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entfernen (Index): wie oben. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enth√§lt (obj), indexOf (obj): Sie k√∂nnen eine Reihe von ArrayList und HashMap verwenden. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remove (obj): ... Ich finde es schwierig zu antworten. </font><font style="vertical-align: inherit;">In einigen F√§llen k√∂nnen Sie mit einem LinkedHashSet auskommen. </font><font style="vertical-align: inherit;">Es wird in Gegenwart der beiden vorhergehenden Punkte trivial gel√∂st, aber welche Strukturen k√∂nnen beide schnell?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als ich eine Struktur mit Quick Add (Obj), Get (Index), Remove (Index) und IndexOf (Obj) ben√∂tigte, gab Google keine Antwort. Ich habe keine Codebeispiele oder Beschreibungen solcher Strukturen gefunden. Vielleicht habe ich dort nicht gesucht, ich musste es selbst erfinden. Aber wenn jemand den Link in den Kommentaren fallen l√§sst, werde ich es sehr sch√§tzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielleicht hat jemand erkannt, dass Sie eine TreeList verwenden k√∂nnen, mit der Sie schnell Elemente in der Mitte der Liste einf√ºgen / entfernen und eine HashMap aus dem Objekt zum Index in der TreeList hinzuf√ºgen k√∂nnen, um indexOf (obj) schnell auszuf√ºhren. Und es wird eine einfache, elegante, aber falsche Entscheidung sein. Schlie√ülich m√ºssen beim Hinzuf√ºgen zur Mitte oder Entfernen aus der Mitte die Indizes im Durchschnitt f√ºr die H√§lfte der Elemente neu berechnet werden. Dies verschlechtert die Leistung auf O (n).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als n√§chstes werde ich √ºber eine Datenstruktur sprechen, die all das oben Genannte kann. Womit eine Operation an einem Element in O (log (n)) Zeit ausgef√ºhrt wird. Nun, fast - denn der Logarithmus wird in dem Fall ausgef√ºhrt, in dem alle Objekte in der Liste unterschiedlich sind. Wenn die Liste dieselben Objekte enth√§lt, kann die Leistung auf O (log (n) ^ 2) gesenkt werden.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde Sie sofort warnen, dass ich den Code hier nicht malen werde. </font><font style="vertical-align: inherit;">Es kann f√ºr den Artikel ziemlich kompliziert sein. </font><font style="vertical-align: inherit;">Aber es ist in Java geschrieben. </font><font style="vertical-align: inherit;">Basierend auf der TreeList-Klasse aus Apache Common-Collections. </font><font style="vertical-align: inherit;">Pull-Anfrage existiert bereits, aber zum Zeitpunkt des Schreibens ist der Artikel noch nicht gegossen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde auch keine bekannten Algorithmen beschreiben. </font><font style="vertical-align: inherit;">Zum Beispiel Baumausgleichsalgorithmen. </font><font style="vertical-align: inherit;">F√ºr die meisten mag es ausreichend sein, die Tatsache als selbstverst√§ndlich zu betrachten, dass der Baum im Gleichgewicht gehalten werden kann. </font><font style="vertical-align: inherit;">Dies hat keinen Einfluss auf das Verst√§ndnis der allgemeinen Idee. </font><font style="vertical-align: inherit;">Wer mehr wissen will, findet leicht Informationen. </font><font style="vertical-align: inherit;">Aber ich werde Ihnen ganz kurz einige grundlegende Dinge erz√§hlen, denn ohne die Kenntnis der Grundlagen k√∂nnen viele Schl√ºsselelemente nicht verstanden werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Links werden am Ende sein.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum ist es notwendig?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich ist es nicht so einfach, Situationen zu finden, in denen alles direkt von der Liste ben√∂tigt wird. </font><font style="vertical-align: inherit;">Es ist unwahrscheinlich, dass dies eine super notwendige Struktur ist, sonst w√ºrde jeder davon wissen. </font><font style="vertical-align: inherit;">Es k√∂nnen jedoch einige Beispiele angef√ºhrt werden, bei denen eine solche Liste n√ºtzlich sein k√∂nnte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich erkenne, dass viele der Beispiele weit hergeholt sind. </font><font style="vertical-align: inherit;">Alles oder fast alles kann auf andere Weise gel√∂st werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caching und Komprimierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meine anf√§ngliche Aufgabe, aufgrund derer ich anfing, das Problem zu untersuchen. </font><font style="vertical-align: inherit;">Spielte mit der Komprimierung bestimmter Daten und ben√∂tigte eine Liste f√ºr den Objektcache. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee ist folgende: Wenn wir ein anderes Objekt verarbeiten, suchen wir es in der Liste. </font><font style="vertical-align: inherit;">Wenn nicht gefunden, speichern Sie das Objekt und f√ºgen Sie es oben in die Liste ein. </font><font style="vertical-align: inherit;">Wenn gefunden, nehmen wir seinen Index in die Liste und speichern anstelle des Objekts nur seinen Index. Danach verschieben wir das Objekt an den Anfang der Liste. </font><font style="vertical-align: inherit;">Daher erhalten auftretende Objekte h√§ufig kleine Indizes, und nur einmal vorkommende Objekte werden schlie√ülich an das Ende der Liste verschoben und gel√∂scht.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wende</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn anstelle der √ºblichen FIFO-Warteschlange f√ºr einige Aufgaben eine √§hnliche Struktur verwendet wird, k√∂nnen die folgenden Vorg√§nge ausgef√ºhrt werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beantworten Sie die Frage: Wie viele Aufgaben befinden sich vor dieser Aufgabe in der Warteschlange? </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernen Sie Aufgaben aus der Warteschlange. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist wie in einem Supermarkt. </font><font style="vertical-align: inherit;">Wenn Sie wegen eines Schokoriegels gekommen sind, aber sehen, dass sich die Linie langsam bewegt, wird der Schokoriegel vielleicht nicht so dringend ben√∂tigt? </font><font style="vertical-align: inherit;">:) :)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Highscore-Tabelle</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir m√∂chten die Zeit speichern, in der Spieler ein Level in einem Spiel abschlie√üen. </font><font style="vertical-align: inherit;">Es gibt viele Spieler, die alle gegeneinander antreten und versuchen, die Mindestzeit anzuzeigen. </font><font style="vertical-align: inherit;">Spielerdaten k√∂nnen in ein Array gestellt und nach Zeit sortiert werden. </font><font style="vertical-align: inherit;">Mit dieser Struktur k√∂nnen Sie:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschieben Sie Spieler h√∂her in die Liste, wenn sie bessere Ergebnisse als zuvor zeigen. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernen Sie Spieler von der Liste, z. B. im Falle eines Betrugsverbots. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigen Sie jedem Spieler, wo er ist. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigen Sie die Tabelle der Datens√§tze Seite f√ºr Seite an. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigen Sie eine sp√§rliche Tabelle an Stellen an, z. B. Zeit 1, 2, 3, 5, 10, 20, 50, 100, 1000, 10000 Stellen. </font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenstruktur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Struktur basiert auf einem Baum mit einem impliziten Schl√ºssel. </font><font style="vertical-align: inherit;">Auf diesem Ansatz basiert beispielsweise TreeList in Apache Common-Collections. </font><font style="vertical-align: inherit;">Um fortzufahren, m√ºssen Sie verstehen, wie diese Struktur funktioniert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Impliziter Schl√ºsselbaum</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Baum besteht aus Knoten (Knoten). </font><font style="vertical-align: inherit;">Jeder Knoten enth√§lt eine Verkn√ºpfung zu einem Objekt, das im Knoten gespeichert ist, und zwei Verkn√ºpfungen zu anderen Knoten: links und rechts. </font><font style="vertical-align: inherit;">Der oberste Knoten wird als Wurzelknoten bezeichnet. </font><font style="vertical-align: inherit;">Im einfachsten Fall sieht der Knoten ungef√§hr so ‚Äã‚Äãaus:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  obj: T<font></font>
  left: Node&lt;T&gt;<font></font>
  right: Node&lt;T&gt;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im klassischen Bin√§rbaum f√ºr jeden Knoten im linken Teilbaum sind alle Objekte kleiner als im aktuellen Knoten und im rechten - gro√ü. </font><font style="vertical-align: inherit;">Zum Beispiel:</font></font><br>
<br>
<pre><code class="plaintext hljs">                             [ element: 25 ]<font></font>
                           /                 \<font></font>
                          /                   \<font></font>
          [ element: 14 ]                       [ element: 45 ]<font></font>
           /          \                           /          \<font></font>
          /            \                         /            \<font></font>
[ element: 10 ]    [ element: 22 ]     [ element: 27 ]    [ element: 90 ]<font></font>
                    /          \                            /<font></font>
                   /            \                          /<font></font>
            [ element: 17 ] [ element: 23 ]         [ element: 80 ] </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr unseren Zweck ist ein solcher Baum jedoch nicht geeignet. Wir m√ºssen keine sortierten Objekte speichern, aber wir m√ºssen wie in einem Array nach Index darauf zugreifen k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie kann ich ein Array in einen Baum einf√ºgen? W√§hlen wir ein Element mit dem Index i aus der Mitte des Arrays aus. Platzieren Sie das i-te Element aus dem Array im Stammknoten. 2 Teilb√§ume verlassen den Wurzelknoten. Im linken Teilbaum setzen wir die H√§lfte des Arrays mit Index &lt;i und im rechten Teil mit Index&gt; i. Wie kann man das machen? Auf die gleiche Weise: Wir w√§hlen ein Element aus der Mitte in einem Subarray aus, setzen dieses Element in einen Knoten und erhalten zwei weitere kleinere Subarrays. Und so lange, bis wir alle Elemente des Arrays in die Knoten des Baums eingef√ºgt haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Array mit den Elementen ["q", "w", "e", "r", "t", "y", "u"] k√∂nnte beispielsweise folgenderma√üen aussehen:</font></font><br>
<br>
<pre><code class="plaintext hljs">                            [el: r,  size: 7]<font></font>
                           /        :        \<font></font>
                          /         :         \<font></font>
         [el: w, size: 3]           :           [el: y, size: 3]<font></font>
           /     :    \             :             /    :     \<font></font>
          /      :     \            :            /     :      \<font></font>
[el: q, size: 1] : [el: e, size: 1] : [el: t, size: 1] : [el: u, size: 1]<font></font>
        :        :         :        :         :        :         :<font></font>
        :        :         :        :         :        :         :<font></font>
       [q]      [w]       [e]      [r]       [t]      [y]       [u]<font></font>
<font></font>
Index:  0        1         2        3         4        5         6</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das mittlere Element im Array "r" setzen wir in den Wurzelknoten. Zwei Subarrays ["q", "w", "e"] und ["t", "y", "u"] werden in den linken und rechten Teilb√§umen platziert. Dazu werden die zentralen Elemente aus den Subarrays ausgew√§hlt, in unserem Fall "w" und "y", und sie fallen in die Knoten der n√§chsten Ebene. Und so weiter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Fall ist der Baum ausgeglichen, die Tiefe aller Teilb√§ume ist gleich. Das muss aber nicht so sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der obigen Abbildung enth√§lt jeder Knoten neben dem Element und den Links zum linken und rechten Knoten die Anzahl der Elemente des gesamten Teilbaums. Diese Informationen m√ºssen korrekt aktualisiert werden, wenn sich der Baum √§ndert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie man zum Beispiel ein Element mit index = 4 in einem solchen Baum findet.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir starten den Crawl vom Wurzelknoten (Wurzel, in unserem Fall mit dem Element "r"). Wir haben 3 M√∂glichkeiten: Wir sind bereits am rechten Knoten, der rechte Knoten links, der rechte Knoten rechts. Um zu verstehen, wo nach dem gew√ºnschten Element gesucht werden muss, m√ºssen Sie die Gr√∂√üe des linken Teilbaums (in unserem Fall left.size = 3) und des aktuellen Index (in unserem Fall 4) vergleichen. Wenn diese beiden Zahlen gleich sind, haben wir den erforderlichen Knoten und das gew√ºnschte Element darin gefunden. Wenn der linke Teilbaum gr√∂√üer ist, wird der erforderliche Knoten im linken Teilbaum angezeigt. Wenn es weniger ist, m√ºssen Sie im rechten Teilbaum suchen, aber den gew√ºnschten Index reduzieren: index = index - left.size - 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da in unserem Fall left.size &lt;index, suchen wir im rechten Teilbaum nach dem Element mit dem neuen Index 4 - 3 - 1 = 0. Gehen Sie mit dem Element ‚Äûy‚Äú zum Knoten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann machen wir dasselbe wie im Wurzelknoten. Vergleiche left.size und index. Da 1&gt; 0, schauen wir in den linken Teilbaum, bewegen uns zum Knoten mit dem Element "t". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt keinen linken Teilbaum in diesem Knoten und seine Gr√∂√üe ist 0. index = left.size, was bedeutet, dass wir einen Knoten mit Index 4 gefunden haben und das erforderliche Element "t" daraus erhalten k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Pseudocode sieht es ungef√§hr so ‚Äã‚Äãaus:</font></font><br>
<br>
<pre><code class="kotlin hljs">function <span class="hljs-keyword">get</span>(node: Node&lt;T&gt;, index: int): T {
  <span class="hljs-keyword">val</span> leftSize: int = (node.left == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : node.left.size;
  <span class="hljs-keyword">if</span> (leftSize == index) {
    <span class="hljs-keyword">return</span> node.obj;<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leftSize &gt; index) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(node.left, index);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(node.right, index ‚Äî leftSize ‚Äî <span class="hljs-number">1</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe versucht, das Schl√ºsselprinzip zu beschreiben, wie ein Array in einen Baum eingef√ºgt wird. </font><font style="vertical-align: inherit;">Eine solche Struktur arbeitet nat√ºrlich langsamer als das klassische Array f√ºr O (log (n)) gegen√ºber O (1). </font><font style="vertical-align: inherit;">Dies hat jedoch einen wichtigen Vorteil: Das Hinzuf√ºgen eines Elements zur Mitte oder das Entfernen aus der Mitte funktioniert auch f√ºr O (log (n)) gegen√ºber O (n) f√ºr das Array. </font><font style="vertical-align: inherit;">Nat√ºrlich vorausgesetzt, der Baum ist mehr oder weniger ausgeglichen. </font><font style="vertical-align: inherit;">Es gibt viele Algorithmen, um einen Baum nahezu ausgewogen zu pflegen. </font><font style="vertical-align: inherit;">Zum Beispiel rot-schwarzer Baum, AVL-Baum, kartesischer Baum. </font><font style="vertical-align: inherit;">Ich werde die Details des Ausgleichs des Baumes nicht aufschreiben, jeder Algorithmus ist f√ºr uns geeignet. </font><font style="vertical-align: inherit;">Nehmen wir einfach an, dass der Baum im Durchschnitt ausgeglichen ist und seine maximale Tiefe sich nicht wesentlich von der minimalen unterscheidet.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leichte Optimierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der oben beschriebene Ansatz, bei dem die Gr√∂√üe des Baums links √ºberpr√ºft wird, ist f√ºr die Wahrnehmung praktisch, kann jedoch etwas effizienter durchgef√ºhrt werden. Um nicht jedes Mal in den linken Teilbaum zu schauen, kann man anstelle der Gr√∂√üe des Baums seine Position relativ zur Position seines √ºbergeordneten Knotens im Knoten speichern. Der Wurzelknoten speichert eine absolute Position, die der Gr√∂√üe des linken Teilbaums entspricht.</font></font><br>
<br>
<pre><code class="plaintext hljs">                             [el: r, pos: 3]<font></font>
                           /        :        \<font></font>
                          /         :         \<font></font>
         [el: w, pos: -2]           :           [el: y, pos: +2]<font></font>
           /     :    \             :             /    :     \<font></font>
          /      :     \            :            /     :      \<font></font>
[el: q, pos: -1] : [el: e, pos: +1] : [el: t, pos: -1] : [el: u, pos: +1]<font></font>
        :        :         :        :         :        :         :<font></font>
        :        :         :        :         :        :         :<font></font>
       [q]      [w]       [e]      [r]       [t]      [y]       [u]<font></font>
<font></font>
Index:  0        1         2        3         4        5         6</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel hat der Wurzelknoten "r" Position 3. Der Knoten "w" hat Position -2 relativ zum √ºbergeordneten Knoten oder die absolute Position 3 + (-2) = 1. Ebenso k√∂nnen Sie eine weitere Ebene nach unten gehen, zum Beispiel hat der Knoten "e" Position 3 + (-2) + (+1) = 2. Das hei√üt, </font><font style="vertical-align: inherit;">Der Knotenindex ist die Summe der Positionen von der Wurzel des Baums zu diesem Knoten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Optimierung bietet neben einer schnelleren Suche nach einem Element in der Liste eine schnellere und einfachere Suche nach dem Index auf dem Knoten. </font><font style="vertical-align: inherit;">Nat√ºrlich ist es etwas schwieriger geworden, die Position beim √Ñndern des Baums korrekt zu aktualisieren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indizierung hinzuf√ºgen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Baum k√∂nnen wir also ein Element nach Index nehmen, seinen Wert √§ndern, Elemente zur Mitte hinzuf√ºgen und l√∂schen. Im Wesentlichen m√ºssen wir nur eine schnelle Indexsuche nach dem Wert indexOf (obj) hinzuf√ºgen. Dann enth√§lt (obj) und entfernen (obj) wird trivial gel√∂st. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber zuerst vereinfachen wir die Aufgabe ein wenig. Erstellen wir eine Struktur, in der nur eindeutige Elemente gespeichert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um schnell nach etwas zu suchen, verwenden sie normalerweise eine Tabelle. In der Java-Welt hei√üen Tabellen Map und haben zwei Hauptimplementierungen: HashMap und TreeMap. Der Schl√ºssel zur Tabelle ist eine Verkn√ºpfung zum Objekt, und der Wert ist eine Verkn√ºpfung zu seinem Knoten:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexedTreeListSet</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  root: Node&lt;T&gt;<font></font>
  indexMap: Map&lt;T, Node&lt;T&gt;&gt;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jene. Die Struktur besteht aus zwei Teilen: dem Listenbaum selbst und der Tabelle mit Links zu Objekten und Knoten dieses Baums. Beim Aktualisieren des Baums muss auch die Tabelle aktualisiert werden. Ich werde den Prozess nicht im Detail beschreiben. Intuitiv sollte es verst√§ndlich sein: F√ºgen Sie einen Knoten hinzu - f√ºgen Sie ihn in die Tabelle ein, l√∂schen Sie den Knoten - l√∂schen Sie ihn aus der Tabelle. In der Praxis gibt es Nuancen beim Ausgleichen des Baums: Der Algorithmus sollte die Verkn√ºpfungen zwischen Knoten √§ndern und keine Objekte zwischen Knoten verschieben. Andernfalls m√ºssen Sie viele Aktualisierungen in der Tabelle vornehmen, und die Leistung nimmt ab. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ok, wir gehen davon aus, dass wir den Knoten anhand des darin enthaltenen Elements schnell finden k√∂nnen. Na und? Wir m√ºssen seinen Index finden, aber das ist noch nicht m√∂glich. Wir k√∂nnen die Knotenklasse jedoch so komplizieren, dass sie nicht nur Links zu den linken und rechten Knoten enth√§lt, sondern auch zu deren √ºbergeordneten Knoten:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  obj: T<font></font>
  left: Node&lt;T&gt;<font></font>
  right: Node&lt;T&gt;<font></font>
  parent: Node&lt;T&gt;<font></font>
  pos: int<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Aktualisieren des Baums ist nat√ºrlich etwas komplizierter, da wir jetzt den Link zum √ºbergeordneten Baum sorgf√§ltig aktualisieren m√ºssen. Wenn wir nun den Knoten kennen, k√∂nnen wir den Baum hochgehen und den Index eines beliebigen Knotens berechnen. Wenn wir die Optimierung aus dem vorherigen Kapitel verwendet haben, m√ºssen wir nur die Summe der Positionen vom aktuellen Knoten zur Wurzel berechnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei einer Liste mit eindeutigen Elementen kann das Problem als gel√∂st betrachtet werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stimmt, wir haben ein kleines Problem. </font><font style="vertical-align: inherit;">Angenommen, wir nennen set (index, obj). </font><font style="vertical-align: inherit;">Wir k√∂nnen ein Element in einem Knoten leicht durch ein anderes ersetzen, aber nur, wenn die Liste noch kein neues Element enth√§lt. </font><font style="vertical-align: inherit;">Und wenn ja, was soll ich tun? </font><font style="vertical-align: inherit;">Entfernen Sie den √ºbersch√ºssigen Gegenstand aus der alten Position und setzen Sie einen neuen ein? </font><font style="vertical-align: inherit;">Oder umgekehrt, erst hinzuf√ºgen und dann l√∂schen? </font><font style="vertical-align: inherit;">Das Ergebnis kann unterschiedlich sein. </font><font style="vertical-align: inherit;">Und Sie k√∂nnen √ºberhaupt nichts tun oder eine Ausnahme ausl√∂sen. </font><font style="vertical-align: inherit;">Es gibt keine perfekte L√∂sung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Sortieren nach Standardmethoden einer solchen Liste funktioniert h√∂chstwahrscheinlich auch nicht. </font><font style="vertical-align: inherit;">Schlie√ülich wei√ü der Sortieralgorithmus nicht, ob Objekte eindeutig sein m√ºssen, und erstellt beim Verschieben von Elementen in der Liste Duplikate.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir entfernen die Einzigartigkeit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ok, was die Sache noch komplizierter macht, lassen Sie uns die gleichen Objekte behalten. Nat√ºrlich m√ºssen Sie etwas mit dem Tisch machen. Die erste Idee, eine Liste von Knoten darin zu speichern, scheint nicht sehr gut zu sein: Mit zunehmender L√§nge der Liste nimmt die Leistung ab. Bis zu O (n), wenn alle Listenelemente gleich sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir dann, einen sortierten Knotenbaum in einer Tabelle anstelle einer Liste zu speichern. Sortiert nach Position in der Liste.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexedTreeList</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  root: Node&lt;T&gt;<font></font>
  indexMap: Map&lt;T, TreeSet&lt;Node&lt;T&gt;&gt;&gt;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Einf√ºgen / L√∂schen in / aus dem TreeSet &lt;Knoten&gt; der Gr√∂√üe m erfolgt dann w√§hrend log (m) -Vergleichen der Positionen der Knoten, und jeder Vergleich erfolgt √ºber log (n) -Zeit. Die endg√ºltige Komplexit√§t des Einf√ºgens oder L√∂schens in eine √§hnliche Struktur tritt in O (log (n) * (1 + log (m))) auf, wobei n die Gesamtzahl der Elemente in der Liste und m die Anzahl der Elemente in der Liste ist, die dem eingef√ºgten / gel√∂schten entspricht. Im schlimmsten Fall erhalten wir die Komplexit√§t O (log (n) ^ 2), wenn alle Elemente gleich sind.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein aufmerksamer Leser wird wahrscheinlich Einw√§nde erheben: Aber was ist mit Unver√§nderlichkeit? </font><font style="vertical-align: inherit;">K√∂nnen wir Objekte nicht √§ndern, wenn es sich um Tabellenschl√ºssel handelt? </font><font style="vertical-align: inherit;">Im Allgemeinen ist es. </font><font style="vertical-align: inherit;">F√ºr einen Baum, in dem sortierte Objekte in Schl√ºsseln gespeichert sind, reicht es jedoch zus√§tzlich zu den Standardregeln f√ºr Vergleiche aus, die Invariante beizubehalten: Wenn a &lt;b, sollte sich diese Eigenschaft im Laufe der Zeit nicht √§ndern. </font><font style="vertical-align: inherit;">Dies ist nur unser Fall: Wenn die Position eines Knotens kleiner als die Position eines anderen Knotens ist, bleibt diese Eigenschaft erhalten, unabh√§ngig davon, wie viele Knoten zwischen ihnen hinzugef√ºgt oder gel√∂scht wurden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist es m√∂glich, die Struktur dauerhaft zu machen?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurze Antwort: Nein, das ist unm√∂glich. </font><font style="vertical-align: inherit;">Aufgrund der Doppelverbindung des Baumes, von der Wurzel bis zu den Bl√§ttern und zur√ºck, haben wir jeden Baumknoten mit jedem verbunden. </font><font style="vertical-align: inherit;">Die Persistenz kann nicht auf diese Weise erfolgen. Sie m√ºssen die gesamte Struktur bei jeder √Ñnderung neu erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich verstehe jedoch, wie eine persistente Struktur f√ºr F√§lle implementiert werden kann, in denen keine Elemente in die Mitte der Liste eingef√ºgt werden m√ºssen. </font><font style="vertical-align: inherit;">Sie k√∂nnen am Anfang oder Ende Elemente hinzuf√ºgen und aus der Mitte l√∂schen. </font><font style="vertical-align: inherit;">Die √ºbrigen Eigenschaften sind gleich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie interessiert sind, werde ich versuchen, einen Artikel √ºber diese Struktur zu schreiben. </font><font style="vertical-align: inherit;">Vielleicht implementiere ich es sogar in Java, Kotlin oder Scala. </font><font style="vertical-align: inherit;">Aber h√∂chstwahrscheinlich wird es nicht bald sein.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Implementierungsfunktionen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier m√∂chte ich einige Funktionen beschreiben, denen ich mich stellen musste. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úber eine der Optimierungen zum Speichern der Knotenposition in der Liste habe ich oben geschrieben. Hier zeigt sich die St√§rke von Open Source: Ich habe den vorgefertigten TreeList-Code verwendet und mich nicht mit den Details des AVL-Baums, Knotenrotationen, Positionsaktualisierungen usw. befasst.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine weitere von TreeList geerbte Funktion sind die Links zu Teilb√§umen in Baumbl√§ttern. Jeder Knoten speichert boolesche leftIsPrevious und rightIsNext. Diese Variablen zeigen das Vorhandensein oder Fehlen eines linken / rechten Teilbaums an. Wenn es keinen Teilbaum gibt, wird links / rechts anstelle einer Verkn√ºpfung mit dem Teilbaum eine Verkn√ºpfung mit dem Knoten gespeichert, der dem vorherigen oder n√§chsten Element entspricht. In unserem Beispiel ["q", "w", "e", "r", "t", "y", "u"] ist der Knoten "e" belaubt und hat keine Teilb√§ume. Dementsprechend sind leftIsPrevious und rightIsNext true und left und right zeigen auf die Knoten "w" bzw. "r". Dieser Ansatz hilft dabei, die Liste schneller zu durchlaufen. Und es st√∂rt die Programmierung neuer Funktionen :)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein bisschen √ºber die Arbeit mit dem Tabellenobjekt ‚Üí Knoten. Idealerweise m√ºssen Sie ein Element beim Hinzuf√ºgen zur Struktur einmal in die Tabelle einf√ºgen und beim L√∂schen aus der Struktur einmal l√∂schen. In der Praxis konnte ich dies nicht erreichen. Wenn Sie ein Element hinzuf√ºgen, wird es der Tabelle hinzugef√ºgt. Alles ist so, wie es sollte. Wenn Sie jedoch ein Element l√∂schen, verschiebt der Ausgleichsalgorithmus manchmal Elemente zwischen Knoten. Das Ergebnis sind zwei L√∂schungen und ein Datensatz in der Tabelle anstelle einer L√∂schung. Dies kann behoben werden, wenn Sie die Optimierung aus leftIsPrevious und rightIsNext entfernen. Und sogar einen kleinen Leistungsgewinn erzielen, nicht nur beim Entfernen. In einigen Tests betrug der Anstieg 10-20%. Aber die Iterationsgeschwindigkeit sinkt signifikant, 1,5- bis 2,5-mal in meinen Tests. Ich habe mich entschlossen, die Optimierung vorerst zu verlassen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Java sind die Haupttabellentypen HashMap und TreeMap. F√ºr eine Tabelle verwendet ein Objekt ‚Üí ein Knoten standardm√§√üig HashMap. Sie k√∂nnen TreeMap jedoch mit einem aufgabenspezifischen Komparator verwenden. In diesem Fall suchen / l√∂schen indexOf (obj) und remove (obj) das Objekt, das dem angegebenen Objekt gem√§√ü dem Komparatorcode entspricht. Zum Beispiel speichern wir eine Liste von Benutzern, und der Komparator vergleicht Benutzer nur nach Namen. Dann k√∂nnen wir die Frage beantworten: "Welche Positionen der Liste haben Benutzer mit dem Namen 'Napoleon?'". Oder entfernen Sie alle Napoleons von der Liste :). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Struktur unterst√ºtzt null nicht. Sie k√∂nnen es beheben, aber es gibt kein Gef√ºhl, dass es notwendig ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Bezug auf die Tatsache, dass die Struktur ‚Äûalles wei√ü‚Äú, war ich nat√ºrlich etwas irref√ºhrend. </font><font style="vertical-align: inherit;">Nat√ºrlich ist bei der Arbeit mit einzelnen Elementen alles in Ordnung und unter bestimmten Bedingungen auch f√ºr den Logarithmus. </font><font style="vertical-align: inherit;">Sie wei√ü jedoch einige Dinge nicht, die andere Strukturen k√∂nnen. </font><font style="vertical-align: inherit;">Zum Beispiel ein kartesischer Baum mit einem impliziten Schl√ºssel, es gab Artikel dar√ºber auf dem Hub </font><font style="vertical-align: inherit;">Es wei√ü nicht, wie man schnell indexOf macht, aber es wei√ü, wie man eine Unterliste erstellt und zwei Listen f√ºr den Logarithmus zu einer verkettet (im Durchschnitt nicht garantiert), und es kann persistent gemacht werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Java wird die Leistung normalerweise mit dem jmh-Framework gemessen. </font><font style="vertical-align: inherit;">Tests wurden auf dem 2017 MacBook Pro unter Java11 durchgef√ºhrt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe die Leistung der Standard-ArrayList, TreeList aus Apache Common-Collections und meiner beiden Klassen IndexedTreeList und IndexedTreeListSet in mehreren Szenarien verglichen. </font><font style="vertical-align: inherit;">In jedem Szenario wurden 1000 Operationen desselben Typs ausgef√ºhrt, daher sollte das Ergebnis mit 1000 multipliziert werden.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code unter dem Spoiler</font></font></b><div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-meta">@Fork(1)</span>
<span class="hljs-meta">@Warmup(iterations = 3)</span>
<span class="hljs-meta">@Measurement(iterations = 5)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PerformanceCompare</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Class&gt; CLASSES = Stream.of(TreeList.class, IndexedTreeListSet.class, IndexedTreeList.class,<font></font>
            ArrayList.class)<font></font>
            .collect(Collectors.toMap(c -&gt; c.getSimpleName(), c -&gt; c));<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ITERATIONS = <span class="hljs-number">1000</span>;<font></font>
<font></font>
    <span class="hljs-meta">@State(Scope.Benchmark)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plan</span> </span>{<font></font>
<font></font>
        <span class="hljs-meta">@Param({"10", "100", "1000", "10000", "100000", "1000000"/*, "10000000"*/})</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> size;<font></font>
<font></font>
        <span class="hljs-meta">@Param({"ArrayList", "TreeList", "IndexedTreeList", "IndexedTreeListSet"})</span>
        <span class="hljs-keyword">public</span> String className;<font></font>
<font></font>
        <span class="hljs-keyword">private</span> Random random;
        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<font></font>
<font></font>
        <span class="hljs-meta">@Setup</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException </span>{<font></font>
            random = <span class="hljs-keyword">new</span> Random();<font></font>
            list = (List&lt;Integer&gt;) CLASSES.get(className).newInstance();<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<font></font>
                list.add(i);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">indexOfKnown</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value = list.indexOf(random.nextInt(plan.size));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">indexOfUnknown</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value += list.indexOf(random.nextInt());<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addRemoveRandom</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            list.add(random.nextInt(list.size() + <span class="hljs-number">1</span>), random.nextInt());<font></font>
            value += list.remove(random.nextInt(list.size()));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value += list.get(random.nextInt(list.size()));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Timeout(time = 1, timeUnit = TimeUnit.MILLISECONDS)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException </span>{<font></font>
        Options opt = <span class="hljs-keyword">new</span> OptionsBuilder()<font></font>
                .include(PerformanceCompare.class.getSimpleName())<font></font>
                .forks(<span class="hljs-number">1</span>)
<span class="hljs-comment">//                .jvmArgs("-Xms2048m", "-Xmx2048m", "-XX:MaxDirectMemorySize=512M")</span><font></font>
                .build();<font></font>
<font></font>
        <span class="hljs-keyword">new</span> Runner(opt).run();<font></font>
    }<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst habe ich die Geschwindigkeit verglichen, mit der ein zuf√§lliges Element aus einer Liste abgerufen wird. </font><font style="vertical-align: inherit;">Ich warne Sie sofort, dass bei diesem Test der Overhead sehr hoch ist. </font><font style="vertical-align: inherit;">Ergebnisse, die sich 100.000 * 1.000 Operationen pro Sekunde n√§hern, sind stark verzerrt.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testergebnis abrufen</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.get                       ArrayList       10  thrpt    5  79865.412 ¬± 10145.202  ops/s<font></font>
PerformanceCompare.get                       ArrayList      100  thrpt    5  81862.243 ¬±   983.727  ops/s<font></font>
PerformanceCompare.get                       ArrayList     1000  thrpt    5  81033.507 ¬±  4540.206  ops/s<font></font>
PerformanceCompare.get                       ArrayList    10000  thrpt    5  64096.123 ¬±  1430.361  ops/s<font></font>
PerformanceCompare.get                       ArrayList   100000  thrpt    5  41289.491 ¬± 11286.114  ops/s<font></font>
PerformanceCompare.get                       ArrayList  1000000  thrpt    5   8598.944 ¬±  2048.461  ops/s<font></font>
PerformanceCompare.get                        TreeList       10  thrpt    5  33912.275 ¬±  3754.284  ops/s<font></font>
PerformanceCompare.get                        TreeList      100  thrpt    5  21346.854 ¬±   863.588  ops/s<font></font>
PerformanceCompare.get                        TreeList     1000  thrpt    5  14808.414 ¬±   508.098  ops/s<font></font>
PerformanceCompare.get                        TreeList    10000  thrpt    5   8679.384 ¬±   109.250  ops/s<font></font>
PerformanceCompare.get                        TreeList   100000  thrpt    5   4605.998 ¬±  1028.945  ops/s<font></font>
PerformanceCompare.get                        TreeList  1000000  thrpt    5   2241.381 ¬±   768.147  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList       10  thrpt    5  34054.357 ¬±  3682.829  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList      100  thrpt    5  21934.002 ¬±  2339.947  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList     1000  thrpt    5  14626.691 ¬±   369.893  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList    10000  thrpt    5   7386.863 ¬±   342.150  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList   100000  thrpt    5   4562.126 ¬±   352.772  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList  1000000  thrpt    5   2105.718 ¬±   702.064  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet       10  thrpt    5  33317.503 ¬±  2307.829  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet      100  thrpt    5  21247.440 ¬±  1253.386  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet     1000  thrpt    5  14665.557 ¬±   487.833  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet    10000  thrpt    5   7667.214 ¬±    80.093  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet   100000  thrpt    5   3454.023 ¬±    82.994  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet  1000000  thrpt    5   1768.701 ¬±    35.878  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seltsamerweise ist hier das gr√∂√üte Interesse die Standard-ArrayList. Theoretisch sollte die Geschwindigkeit des Ausstiegs konstant sein und nicht von der Anzahl der Elemente abh√§ngen. In der Praxis h√§lt die Leistung zun√§chst etwa 90.000 * 1000 Operationen pro Sekunde (beachten Sie den Overhead), aber bei einer Listenl√§nge von mehreren tausend Elementen beginnt sie zu sinken. Dies ist auf den immer h√§ufiger auftretenden Cache-Fehler zur√ºckzuf√ºhren: Der Prozessor-Cache verf√ºgt nicht √ºber die erforderlichen Daten, und Sie m√ºssen immer h√§ufiger Daten im RAM abrufen. Mit einer Million Elementen ist die Geschwindigkeit des Tests zehnmal niedriger, aber in der Praxis ist der Leistungsabfall noch gr√∂√üer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TreeList, IndexedTreeList und IndexedTreeListSet zeigen voraussichtlich √§hnliche Ergebnisse. </font><font style="vertical-align: inherit;">Erwartet viel langsamer als ArrayList. </font><font style="vertical-align: inherit;">Selbst mit einer kleinen Anzahl von Elementen ist TreeList um ein Vielfaches langsamer als ArrayList, obwohl der Test den Unterschied nur zweimal zeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der n√§chste Test ist addRemoveRandom. </font><font style="vertical-align: inherit;">Hier f√ºge ich in jedem Test ein Element an einer zuf√§lligen Position ein und entferne ein Element an einer zuf√§lligen Position.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AddRemoveRandom-Testergebnis</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.addRemoveRandom           ArrayList       10  thrpt    5  12440.764 ¬±   485.642  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList      100  thrpt    5   9880.123 ¬±   464.014  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList     1000  thrpt    5   5288.905 ¬±  1219.055  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList    10000  thrpt    5   1024.942 ¬±   179.366  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList   100000  thrpt    5     91.219 ¬±    25.380  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList  1000000  thrpt    5      5.499 ¬±     0.400  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList       10  thrpt    5   6242.607 ¬±   350.290  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList      100  thrpt    5   3117.945 ¬±   116.066  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList     1000  thrpt    5   1829.778 ¬±    80.516  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList    10000  thrpt    5   1230.077 ¬±    53.381  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList   100000  thrpt    5    443.571 ¬±    69.207  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList  1000000  thrpt    5    308.963 ¬±    84.077  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList       10  thrpt    5   3556.511 ¬±   144.596  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList      100  thrpt    5   2120.777 ¬±    83.848  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList     1000  thrpt    5   1211.112 ¬±    92.288  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList    10000  thrpt    5    789.458 ¬±    19.450  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList   100000  thrpt    5    302.989 ¬±    40.030  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList  1000000  thrpt    5    178.822 ¬±    92.853  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet       10  thrpt    5   4138.007 ¬±   119.943  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet      100  thrpt    5   2435.803 ¬±    20.276  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet     1000  thrpt    5   1445.054 ¬±   276.909  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet    10000  thrpt    5    972.256 ¬±    19.987  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet   100000  thrpt    5    366.608 ¬±    94.487  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet  1000000  thrpt    5    227.677 ¬±    48.276  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist davon auszugehen, dass ArrayList auf kleinen Listen schneller ist. </font><font style="vertical-align: inherit;">Interessant ist jedoch, dass er in diesem Test auf Listen mit bis zu 10.000 Elementen gewinnt. </font><font style="vertical-align: inherit;">Anscheinend ist System.arrayCopy sehr gut optimiert und nutzt alle Funktionen moderner Prozessoren. </font><font style="vertical-align: inherit;">Ab 10.000 Artikeln beginnen spezialisierte Datenstrukturen zu gewinnen. </font><font style="vertical-align: inherit;">Bei 1.000.000 Elementen betr√§gt der Geschwindigkeitsunterschied das 30-50-fache. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird erwartet, dass IndexedTreeList und IndexedTreeListSet langsamer als TreeList sind. </font><font style="vertical-align: inherit;">Etwa 1,5 - 2 mal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die verbleibenden 2 Tests indexOfKnown und indexOfUnknown sollten nur das Hauptmerkmal dieser Struktur demonstrieren. </font><font style="vertical-align: inherit;">Der Unterschied zwischen den Tests besteht darin, dass wir in einem Fall nach einem Element suchen, das in der Liste enthalten ist, und in dem anderen Fall nach einem Element, das nicht in der Liste enthalten ist.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testergebnis indexOfKnown und indexOfUnknown</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.indexOfKnown              ArrayList       10  thrpt    5  41424.356 ¬±   549.047  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList      100  thrpt    5  17216.477 ¬±  1444.744  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList     1000  thrpt    5   2296.306 ¬±    76.372  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList    10000  thrpt    5    233.863 ¬±    26.926  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList   100000  thrpt    5     23.208 ¬±     2.776  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList  1000000  thrpt    5      0.919 ¬±     0.455  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList       10  thrpt    5  26740.708 ¬±  1323.125  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList      100  thrpt    5   5670.923 ¬±    99.638  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList     1000  thrpt    5    745.408 ¬±    26.827  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList    10000  thrpt    5     52.288 ¬±     1.362  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList   100000  thrpt    5      4.224 ¬±     0.855  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList  1000000  thrpt    5      0.193 ¬±     0.052  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList       10  thrpt    5  34485.128 ¬±  1582.703  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList      100  thrpt    5  29209.412 ¬±  1544.268  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList     1000  thrpt    5  21139.584 ¬±  1442.867  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList    10000  thrpt    5  12544.306 ¬±   312.097  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList   100000  thrpt    5   3538.201 ¬±   272.537  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList  1000000  thrpt    5   1420.119 ¬±   538.476  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet       10  thrpt    5  39201.995 ¬±  1887.065  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet      100  thrpt    5  34204.112 ¬±  1122.517  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet     1000  thrpt    5  25374.557 ¬±  1596.746  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet    10000  thrpt    5  14291.317 ¬±   391.180  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet   100000  thrpt    5   4215.898 ¬±   283.680  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet  1000000  thrpt    5   1729.100 ¬±  1260.815  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList       10  thrpt    5  59053.313 ¬±  1845.665  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList      100  thrpt    5  10867.572 ¬±   142.823  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList     1000  thrpt    5   1186.583 ¬±    28.003  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList    10000  thrpt    5    120.953 ¬±     4.146  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList   100000  thrpt    5     11.936 ¬±     0.320  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList  1000000  thrpt    5      0.566 ¬±     0.335  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList       10  thrpt    5  28134.237 ¬±  2291.670  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList      100  thrpt    5   3153.930 ¬±   158.734  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList     1000  thrpt    5    322.383 ¬±    44.245  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList    10000  thrpt    5     25.674 ¬±     1.787  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList   100000  thrpt    5      1.867 ¬±     0.291  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList  1000000  thrpt    5      0.093 ¬±     0.008  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList       10  thrpt    5  66625.126 ¬±  5232.668  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList      100  thrpt    5  70038.055 ¬±  5803.848  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList     1000  thrpt    5  63240.467 ¬±   885.956  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList    10000  thrpt    5  54731.988 ¬±  3950.150  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList   100000  thrpt    5  22049.476 ¬±   821.924  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList  1000000  thrpt    5   9459.862 ¬±   804.738  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet       10  thrpt    5  70274.968 ¬± 15830.355  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet      100  thrpt    5  71017.685 ¬±  6920.447  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet     1000  thrpt    5  66405.960 ¬±  1127.231  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet    10000  thrpt    5  57983.963 ¬±  3276.142  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet   100000  thrpt    5  41277.110 ¬±  9919.893  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet  1000000  thrpt    5   9840.185 ¬±  2159.352  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier haben ArrayList und TreeList fast keine √úberraschungen. Mit zunehmender Gr√∂√üe nimmt die Geschwindigkeit nahezu linear ab. Die Suche nach einem Artikel aus einer Nichtliste wird voraussichtlich zweimal langsamer sein als die Suche nach einem Artikel aus der Liste, weil Sie m√ºssen das gesamte Array anstatt der H√§lfte im Durchschnitt durchlaufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IndexedTreeList und IndexedTreeListSet zeigen hier jedoch das erwartete gute Ergebnis. Diese Datenstrukturen zeigen eine mit ArrayList vergleichbare IndexOf-Ausf√ºhrungsgeschwindigkeit, selbst bei 10 Elementen. Mit 1000 Elementen sind diese Strukturen zehnmal schneller, mit 1.000.000 1000-mal schneller. Bei der Suche nach einem Element, das nicht in der Liste enthalten ist, wird eine h√∂here Geschwindigkeit erwartet als bei der Suche nach einem Element in der Liste.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interessant ist auch die Leistungssenkung von IndexedTreeList und IndexedTreeListSet im indexOfUnknown-Test. </font><font style="vertical-align: inherit;">Hier ist die Situation √§hnlich wie im Test mit ArrayList.get. </font><font style="vertical-align: inherit;">Theoretisch h√§tten wir keinen Leistungsabfall erhalten sollen, aber in der Praxis haben wir ihn aufgrund eines Cache-Fehlers erhalten, und dies ist von Bedeutung.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstelle einer Schlussfolgerung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wei√ü immer noch nicht, ob die vorgeschlagene Struktur eine Neuheit aufweist oder nicht. Einerseits ist die Idee nicht kompliziert, wenn Sie wissen, wie der Baum mit einem impliziten Schl√ºssel funktioniert. Andererseits habe ich keine Beschreibung einer Struktur mit solchen Eigenschaften gesehen. Und wenn ja, dann ist es sinnvoll, die Struktur bekannter zu machen, es k√∂nnte f√ºr jemanden n√ºtzlich sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber selbst wenn dies ein anderes Fahrrad ist, habe ich versucht, es n√ºtzlich zu machen. Eine Pull-Anfrage in allgemeinen Sammlungen wurde erstellt, aber zum Zeitpunkt des Schreibens ist dieser Artikel noch nicht ausgegossen. Da ich wei√ü, wie langsam alles in Open Source ablaufen kann, bin ich nicht √ºberrascht, wenn sich der Prozess monatelang hinzieht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Etwas √ºberrascht √ºber das Ergebnis des Vergleichs der Leistung von ArrayList und TreeList. </font><font style="vertical-align: inherit;">Tests haben gezeigt, dass TreeList keinen Sinn macht, bis zu 10.000 Elemente in der Listengr√∂√üe zu verwenden. </font><font style="vertical-align: inherit;">Es w√§re interessant, B-Tree anstelle eines Bin√§rbaums zu versuchen. </font><font style="vertical-align: inherit;">Diese Struktur sollte den Speicher sorgf√§ltiger nutzen und h√∂chstwahrscheinlich schneller arbeiten. </font><font style="vertical-align: inherit;">Und daf√ºr k√∂nnen Sie die Idee mit Indizierung anpassen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In jedem Fall macht es Spa√ü, ein Instrument im Arsenal zu haben, das (fast) alles mit vorhersehbarer Komplexit√§t kann.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urspr√ºngliches </font></font><br>
</a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pull-Anforderungsprojekt in Apache Common-Collections </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ticket in Jira</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de488758/index.html">DEFCON-Konferenz 27. Internet-Betrugserkennung</a></li>
<li><a href="../de488762/index.html">Elegante asynchrone Programmierung mit Versprechen</a></li>
<li><a href="../de488766/index.html">Kunst und Technologie: Universit√§t von Massachusetts in Lowell</a></li>
<li><a href="../de488768/index.html">Verdammt noch mal, oder wie man auf Englisch schw√∂rt, mit einer kultivierten Person verwechselt zu werden</a></li>
<li><a href="../de488776/index.html">Verbesserungen der Barrierefreiheit in Visual Studio 2019 f√ºr Mac</a></li>
<li><a href="../de488780/index.html">Mozilla verlor im Browserkrieg, glaubt aber immer noch, dass es das Internet retten k√∂nnte</a></li>
<li><a href="../de488782/index.html">Wie gef√§llt Ihnen diese Option zur Abh√§ngigkeitsverwaltung in Python?</a></li>
<li><a href="../de488784/index.html">Kommerzialisierung von Verbesserungen der freien Software unter Copyleft-Lizenzen</a></li>
<li><a href="../de488786/index.html">Wie detailliert sollte eine User Story sein?</a></li>
<li><a href="../de488792/index.html">√úberwachung der Standortverf√ºgbarkeit in Russland am Knie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>