<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊🏿 👮 ☎️ Datenstrukturen: Eine Liste, die alles kann * 🤲🏿 👋🏽 🥒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Mit allem meine ich die relativ schnelle Ausführung von Operationen an einem einzelnen Element eines Arrays. 
 
 Die Datenstrukturen, die die Liste ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Datenstrukturen: Eine Liste, die alles kann *</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488778/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Mit allem meine ich die relativ schnelle Ausführung von Operationen an einem einzelnen Element eines Arrays. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Datenstrukturen, die die Liste implementieren, sind vollständig. </font><font style="vertical-align: inherit;">Jeder hat seine eigenen Vor- und Nachteile. </font><font style="vertical-align: inherit;">In der Java-Welt können Sie beispielsweise - abhängig von den erforderlichen Operationen - Folgendes verwenden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add (obj), get (obj), set (index, obj): eine Grundmenge fast aller Listen, z. B. ArrayList. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add (index, obj): baumartige Strukturen, z. B. TreeList aus Apache Common-Collections. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entfernen (Index): wie oben. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält (obj), indexOf (obj): Sie können eine Reihe von ArrayList und HashMap verwenden. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remove (obj): ... Ich finde es schwierig zu antworten. </font><font style="vertical-align: inherit;">In einigen Fällen können Sie mit einem LinkedHashSet auskommen. </font><font style="vertical-align: inherit;">Es wird in Gegenwart der beiden vorhergehenden Punkte trivial gelöst, aber welche Strukturen können beide schnell?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als ich eine Struktur mit Quick Add (Obj), Get (Index), Remove (Index) und IndexOf (Obj) benötigte, gab Google keine Antwort. Ich habe keine Codebeispiele oder Beschreibungen solcher Strukturen gefunden. Vielleicht habe ich dort nicht gesucht, ich musste es selbst erfinden. Aber wenn jemand den Link in den Kommentaren fallen lässt, werde ich es sehr schätzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielleicht hat jemand erkannt, dass Sie eine TreeList verwenden können, mit der Sie schnell Elemente in der Mitte der Liste einfügen / entfernen und eine HashMap aus dem Objekt zum Index in der TreeList hinzufügen können, um indexOf (obj) schnell auszuführen. Und es wird eine einfache, elegante, aber falsche Entscheidung sein. Schließlich müssen beim Hinzufügen zur Mitte oder Entfernen aus der Mitte die Indizes im Durchschnitt für die Hälfte der Elemente neu berechnet werden. Dies verschlechtert die Leistung auf O (n).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes werde ich über eine Datenstruktur sprechen, die all das oben Genannte kann. Womit eine Operation an einem Element in O (log (n)) Zeit ausgeführt wird. Nun, fast - denn der Logarithmus wird in dem Fall ausgeführt, in dem alle Objekte in der Liste unterschiedlich sind. Wenn die Liste dieselben Objekte enthält, kann die Leistung auf O (log (n) ^ 2) gesenkt werden.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde Sie sofort warnen, dass ich den Code hier nicht malen werde. </font><font style="vertical-align: inherit;">Es kann für den Artikel ziemlich kompliziert sein. </font><font style="vertical-align: inherit;">Aber es ist in Java geschrieben. </font><font style="vertical-align: inherit;">Basierend auf der TreeList-Klasse aus Apache Common-Collections. </font><font style="vertical-align: inherit;">Pull-Anfrage existiert bereits, aber zum Zeitpunkt des Schreibens ist der Artikel noch nicht gegossen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde auch keine bekannten Algorithmen beschreiben. </font><font style="vertical-align: inherit;">Zum Beispiel Baumausgleichsalgorithmen. </font><font style="vertical-align: inherit;">Für die meisten mag es ausreichend sein, die Tatsache als selbstverständlich zu betrachten, dass der Baum im Gleichgewicht gehalten werden kann. </font><font style="vertical-align: inherit;">Dies hat keinen Einfluss auf das Verständnis der allgemeinen Idee. </font><font style="vertical-align: inherit;">Wer mehr wissen will, findet leicht Informationen. </font><font style="vertical-align: inherit;">Aber ich werde Ihnen ganz kurz einige grundlegende Dinge erzählen, denn ohne die Kenntnis der Grundlagen können viele Schlüsselelemente nicht verstanden werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Links werden am Ende sein.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum ist es notwendig?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich ist es nicht so einfach, Situationen zu finden, in denen alles direkt von der Liste benötigt wird. </font><font style="vertical-align: inherit;">Es ist unwahrscheinlich, dass dies eine super notwendige Struktur ist, sonst würde jeder davon wissen. </font><font style="vertical-align: inherit;">Es können jedoch einige Beispiele angeführt werden, bei denen eine solche Liste nützlich sein könnte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich erkenne, dass viele der Beispiele weit hergeholt sind. </font><font style="vertical-align: inherit;">Alles oder fast alles kann auf andere Weise gelöst werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caching und Komprimierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meine anfängliche Aufgabe, aufgrund derer ich anfing, das Problem zu untersuchen. </font><font style="vertical-align: inherit;">Spielte mit der Komprimierung bestimmter Daten und benötigte eine Liste für den Objektcache. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee ist folgende: Wenn wir ein anderes Objekt verarbeiten, suchen wir es in der Liste. </font><font style="vertical-align: inherit;">Wenn nicht gefunden, speichern Sie das Objekt und fügen Sie es oben in die Liste ein. </font><font style="vertical-align: inherit;">Wenn gefunden, nehmen wir seinen Index in die Liste und speichern anstelle des Objekts nur seinen Index. Danach verschieben wir das Objekt an den Anfang der Liste. </font><font style="vertical-align: inherit;">Daher erhalten auftretende Objekte häufig kleine Indizes, und nur einmal vorkommende Objekte werden schließlich an das Ende der Liste verschoben und gelöscht.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wende</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn anstelle der üblichen FIFO-Warteschlange für einige Aufgaben eine ähnliche Struktur verwendet wird, können die folgenden Vorgänge ausgeführt werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beantworten Sie die Frage: Wie viele Aufgaben befinden sich vor dieser Aufgabe in der Warteschlange? </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernen Sie Aufgaben aus der Warteschlange. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist wie in einem Supermarkt. </font><font style="vertical-align: inherit;">Wenn Sie wegen eines Schokoriegels gekommen sind, aber sehen, dass sich die Linie langsam bewegt, wird der Schokoriegel vielleicht nicht so dringend benötigt? </font><font style="vertical-align: inherit;">:) :)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Highscore-Tabelle</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir möchten die Zeit speichern, in der Spieler ein Level in einem Spiel abschließen. </font><font style="vertical-align: inherit;">Es gibt viele Spieler, die alle gegeneinander antreten und versuchen, die Mindestzeit anzuzeigen. </font><font style="vertical-align: inherit;">Spielerdaten können in ein Array gestellt und nach Zeit sortiert werden. </font><font style="vertical-align: inherit;">Mit dieser Struktur können Sie:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschieben Sie Spieler höher in die Liste, wenn sie bessere Ergebnisse als zuvor zeigen. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernen Sie Spieler von der Liste, z. B. im Falle eines Betrugsverbots. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigen Sie jedem Spieler, wo er ist. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigen Sie die Tabelle der Datensätze Seite für Seite an. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigen Sie eine spärliche Tabelle an Stellen an, z. B. Zeit 1, 2, 3, 5, 10, 20, 50, 100, 1000, 10000 Stellen. </font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenstruktur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Struktur basiert auf einem Baum mit einem impliziten Schlüssel. </font><font style="vertical-align: inherit;">Auf diesem Ansatz basiert beispielsweise TreeList in Apache Common-Collections. </font><font style="vertical-align: inherit;">Um fortzufahren, müssen Sie verstehen, wie diese Struktur funktioniert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Impliziter Schlüsselbaum</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Baum besteht aus Knoten (Knoten). </font><font style="vertical-align: inherit;">Jeder Knoten enthält eine Verknüpfung zu einem Objekt, das im Knoten gespeichert ist, und zwei Verknüpfungen zu anderen Knoten: links und rechts. </font><font style="vertical-align: inherit;">Der oberste Knoten wird als Wurzelknoten bezeichnet. </font><font style="vertical-align: inherit;">Im einfachsten Fall sieht der Knoten ungefähr so ​​aus:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  obj: T<font></font>
  left: Node&lt;T&gt;<font></font>
  right: Node&lt;T&gt;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im klassischen Binärbaum für jeden Knoten im linken Teilbaum sind alle Objekte kleiner als im aktuellen Knoten und im rechten - groß. </font><font style="vertical-align: inherit;">Zum Beispiel:</font></font><br>
<br>
<pre><code class="plaintext hljs">                             [ element: 25 ]<font></font>
                           /                 \<font></font>
                          /                   \<font></font>
          [ element: 14 ]                       [ element: 45 ]<font></font>
           /          \                           /          \<font></font>
          /            \                         /            \<font></font>
[ element: 10 ]    [ element: 22 ]     [ element: 27 ]    [ element: 90 ]<font></font>
                    /          \                            /<font></font>
                   /            \                          /<font></font>
            [ element: 17 ] [ element: 23 ]         [ element: 80 ] </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für unseren Zweck ist ein solcher Baum jedoch nicht geeignet. Wir müssen keine sortierten Objekte speichern, aber wir müssen wie in einem Array nach Index darauf zugreifen können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie kann ich ein Array in einen Baum einfügen? Wählen wir ein Element mit dem Index i aus der Mitte des Arrays aus. Platzieren Sie das i-te Element aus dem Array im Stammknoten. 2 Teilbäume verlassen den Wurzelknoten. Im linken Teilbaum setzen wir die Hälfte des Arrays mit Index &lt;i und im rechten Teil mit Index&gt; i. Wie kann man das machen? Auf die gleiche Weise: Wir wählen ein Element aus der Mitte in einem Subarray aus, setzen dieses Element in einen Knoten und erhalten zwei weitere kleinere Subarrays. Und so lange, bis wir alle Elemente des Arrays in die Knoten des Baums eingefügt haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Array mit den Elementen ["q", "w", "e", "r", "t", "y", "u"] könnte beispielsweise folgendermaßen aussehen:</font></font><br>
<br>
<pre><code class="plaintext hljs">                            [el: r,  size: 7]<font></font>
                           /        :        \<font></font>
                          /         :         \<font></font>
         [el: w, size: 3]           :           [el: y, size: 3]<font></font>
           /     :    \             :             /    :     \<font></font>
          /      :     \            :            /     :      \<font></font>
[el: q, size: 1] : [el: e, size: 1] : [el: t, size: 1] : [el: u, size: 1]<font></font>
        :        :         :        :         :        :         :<font></font>
        :        :         :        :         :        :         :<font></font>
       [q]      [w]       [e]      [r]       [t]      [y]       [u]<font></font>
<font></font>
Index:  0        1         2        3         4        5         6</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das mittlere Element im Array "r" setzen wir in den Wurzelknoten. Zwei Subarrays ["q", "w", "e"] und ["t", "y", "u"] werden in den linken und rechten Teilbäumen platziert. Dazu werden die zentralen Elemente aus den Subarrays ausgewählt, in unserem Fall "w" und "y", und sie fallen in die Knoten der nächsten Ebene. Und so weiter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Fall ist der Baum ausgeglichen, die Tiefe aller Teilbäume ist gleich. Das muss aber nicht so sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der obigen Abbildung enthält jeder Knoten neben dem Element und den Links zum linken und rechten Knoten die Anzahl der Elemente des gesamten Teilbaums. Diese Informationen müssen korrekt aktualisiert werden, wenn sich der Baum ändert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie man zum Beispiel ein Element mit index = 4 in einem solchen Baum findet.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir starten den Crawl vom Wurzelknoten (Wurzel, in unserem Fall mit dem Element "r"). Wir haben 3 Möglichkeiten: Wir sind bereits am rechten Knoten, der rechte Knoten links, der rechte Knoten rechts. Um zu verstehen, wo nach dem gewünschten Element gesucht werden muss, müssen Sie die Größe des linken Teilbaums (in unserem Fall left.size = 3) und des aktuellen Index (in unserem Fall 4) vergleichen. Wenn diese beiden Zahlen gleich sind, haben wir den erforderlichen Knoten und das gewünschte Element darin gefunden. Wenn der linke Teilbaum größer ist, wird der erforderliche Knoten im linken Teilbaum angezeigt. Wenn es weniger ist, müssen Sie im rechten Teilbaum suchen, aber den gewünschten Index reduzieren: index = index - left.size - 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da in unserem Fall left.size &lt;index, suchen wir im rechten Teilbaum nach dem Element mit dem neuen Index 4 - 3 - 1 = 0. Gehen Sie mit dem Element „y“ zum Knoten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann machen wir dasselbe wie im Wurzelknoten. Vergleiche left.size und index. Da 1&gt; 0, schauen wir in den linken Teilbaum, bewegen uns zum Knoten mit dem Element "t". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt keinen linken Teilbaum in diesem Knoten und seine Größe ist 0. index = left.size, was bedeutet, dass wir einen Knoten mit Index 4 gefunden haben und das erforderliche Element "t" daraus erhalten können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Pseudocode sieht es ungefähr so ​​aus:</font></font><br>
<br>
<pre><code class="kotlin hljs">function <span class="hljs-keyword">get</span>(node: Node&lt;T&gt;, index: int): T {
  <span class="hljs-keyword">val</span> leftSize: int = (node.left == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : node.left.size;
  <span class="hljs-keyword">if</span> (leftSize == index) {
    <span class="hljs-keyword">return</span> node.obj;<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leftSize &gt; index) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(node.left, index);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(node.right, index — leftSize — <span class="hljs-number">1</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe versucht, das Schlüsselprinzip zu beschreiben, wie ein Array in einen Baum eingefügt wird. </font><font style="vertical-align: inherit;">Eine solche Struktur arbeitet natürlich langsamer als das klassische Array für O (log (n)) gegenüber O (1). </font><font style="vertical-align: inherit;">Dies hat jedoch einen wichtigen Vorteil: Das Hinzufügen eines Elements zur Mitte oder das Entfernen aus der Mitte funktioniert auch für O (log (n)) gegenüber O (n) für das Array. </font><font style="vertical-align: inherit;">Natürlich vorausgesetzt, der Baum ist mehr oder weniger ausgeglichen. </font><font style="vertical-align: inherit;">Es gibt viele Algorithmen, um einen Baum nahezu ausgewogen zu pflegen. </font><font style="vertical-align: inherit;">Zum Beispiel rot-schwarzer Baum, AVL-Baum, kartesischer Baum. </font><font style="vertical-align: inherit;">Ich werde die Details des Ausgleichs des Baumes nicht aufschreiben, jeder Algorithmus ist für uns geeignet. </font><font style="vertical-align: inherit;">Nehmen wir einfach an, dass der Baum im Durchschnitt ausgeglichen ist und seine maximale Tiefe sich nicht wesentlich von der minimalen unterscheidet.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leichte Optimierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der oben beschriebene Ansatz, bei dem die Größe des Baums links überprüft wird, ist für die Wahrnehmung praktisch, kann jedoch etwas effizienter durchgeführt werden. Um nicht jedes Mal in den linken Teilbaum zu schauen, kann man anstelle der Größe des Baums seine Position relativ zur Position seines übergeordneten Knotens im Knoten speichern. Der Wurzelknoten speichert eine absolute Position, die der Größe des linken Teilbaums entspricht.</font></font><br>
<br>
<pre><code class="plaintext hljs">                             [el: r, pos: 3]<font></font>
                           /        :        \<font></font>
                          /         :         \<font></font>
         [el: w, pos: -2]           :           [el: y, pos: +2]<font></font>
           /     :    \             :             /    :     \<font></font>
          /      :     \            :            /     :      \<font></font>
[el: q, pos: -1] : [el: e, pos: +1] : [el: t, pos: -1] : [el: u, pos: +1]<font></font>
        :        :         :        :         :        :         :<font></font>
        :        :         :        :         :        :         :<font></font>
       [q]      [w]       [e]      [r]       [t]      [y]       [u]<font></font>
<font></font>
Index:  0        1         2        3         4        5         6</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel hat der Wurzelknoten "r" Position 3. Der Knoten "w" hat Position -2 relativ zum übergeordneten Knoten oder die absolute Position 3 + (-2) = 1. Ebenso können Sie eine weitere Ebene nach unten gehen, zum Beispiel hat der Knoten "e" Position 3 + (-2) + (+1) = 2. Das heißt, </font><font style="vertical-align: inherit;">Der Knotenindex ist die Summe der Positionen von der Wurzel des Baums zu diesem Knoten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Optimierung bietet neben einer schnelleren Suche nach einem Element in der Liste eine schnellere und einfachere Suche nach dem Index auf dem Knoten. </font><font style="vertical-align: inherit;">Natürlich ist es etwas schwieriger geworden, die Position beim Ändern des Baums korrekt zu aktualisieren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indizierung hinzufügen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Baum können wir also ein Element nach Index nehmen, seinen Wert ändern, Elemente zur Mitte hinzufügen und löschen. Im Wesentlichen müssen wir nur eine schnelle Indexsuche nach dem Wert indexOf (obj) hinzufügen. Dann enthält (obj) und entfernen (obj) wird trivial gelöst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber zuerst vereinfachen wir die Aufgabe ein wenig. Erstellen wir eine Struktur, in der nur eindeutige Elemente gespeichert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um schnell nach etwas zu suchen, verwenden sie normalerweise eine Tabelle. In der Java-Welt heißen Tabellen Map und haben zwei Hauptimplementierungen: HashMap und TreeMap. Der Schlüssel zur Tabelle ist eine Verknüpfung zum Objekt, und der Wert ist eine Verknüpfung zu seinem Knoten:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexedTreeListSet</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  root: Node&lt;T&gt;<font></font>
  indexMap: Map&lt;T, Node&lt;T&gt;&gt;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jene. Die Struktur besteht aus zwei Teilen: dem Listenbaum selbst und der Tabelle mit Links zu Objekten und Knoten dieses Baums. Beim Aktualisieren des Baums muss auch die Tabelle aktualisiert werden. Ich werde den Prozess nicht im Detail beschreiben. Intuitiv sollte es verständlich sein: Fügen Sie einen Knoten hinzu - fügen Sie ihn in die Tabelle ein, löschen Sie den Knoten - löschen Sie ihn aus der Tabelle. In der Praxis gibt es Nuancen beim Ausgleichen des Baums: Der Algorithmus sollte die Verknüpfungen zwischen Knoten ändern und keine Objekte zwischen Knoten verschieben. Andernfalls müssen Sie viele Aktualisierungen in der Tabelle vornehmen, und die Leistung nimmt ab. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ok, wir gehen davon aus, dass wir den Knoten anhand des darin enthaltenen Elements schnell finden können. Na und? Wir müssen seinen Index finden, aber das ist noch nicht möglich. Wir können die Knotenklasse jedoch so komplizieren, dass sie nicht nur Links zu den linken und rechten Knoten enthält, sondern auch zu deren übergeordneten Knoten:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  obj: T<font></font>
  left: Node&lt;T&gt;<font></font>
  right: Node&lt;T&gt;<font></font>
  parent: Node&lt;T&gt;<font></font>
  pos: int<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Aktualisieren des Baums ist natürlich etwas komplizierter, da wir jetzt den Link zum übergeordneten Baum sorgfältig aktualisieren müssen. Wenn wir nun den Knoten kennen, können wir den Baum hochgehen und den Index eines beliebigen Knotens berechnen. Wenn wir die Optimierung aus dem vorherigen Kapitel verwendet haben, müssen wir nur die Summe der Positionen vom aktuellen Knoten zur Wurzel berechnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei einer Liste mit eindeutigen Elementen kann das Problem als gelöst betrachtet werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stimmt, wir haben ein kleines Problem. </font><font style="vertical-align: inherit;">Angenommen, wir nennen set (index, obj). </font><font style="vertical-align: inherit;">Wir können ein Element in einem Knoten leicht durch ein anderes ersetzen, aber nur, wenn die Liste noch kein neues Element enthält. </font><font style="vertical-align: inherit;">Und wenn ja, was soll ich tun? </font><font style="vertical-align: inherit;">Entfernen Sie den überschüssigen Gegenstand aus der alten Position und setzen Sie einen neuen ein? </font><font style="vertical-align: inherit;">Oder umgekehrt, erst hinzufügen und dann löschen? </font><font style="vertical-align: inherit;">Das Ergebnis kann unterschiedlich sein. </font><font style="vertical-align: inherit;">Und Sie können überhaupt nichts tun oder eine Ausnahme auslösen. </font><font style="vertical-align: inherit;">Es gibt keine perfekte Lösung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Sortieren nach Standardmethoden einer solchen Liste funktioniert höchstwahrscheinlich auch nicht. </font><font style="vertical-align: inherit;">Schließlich weiß der Sortieralgorithmus nicht, ob Objekte eindeutig sein müssen, und erstellt beim Verschieben von Elementen in der Liste Duplikate.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir entfernen die Einzigartigkeit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ok, was die Sache noch komplizierter macht, lassen Sie uns die gleichen Objekte behalten. Natürlich müssen Sie etwas mit dem Tisch machen. Die erste Idee, eine Liste von Knoten darin zu speichern, scheint nicht sehr gut zu sein: Mit zunehmender Länge der Liste nimmt die Leistung ab. Bis zu O (n), wenn alle Listenelemente gleich sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir dann, einen sortierten Knotenbaum in einer Tabelle anstelle einer Liste zu speichern. Sortiert nach Position in der Liste.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexedTreeList</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  root: Node&lt;T&gt;<font></font>
  indexMap: Map&lt;T, TreeSet&lt;Node&lt;T&gt;&gt;&gt;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Einfügen / Löschen in / aus dem TreeSet &lt;Knoten&gt; der Größe m erfolgt dann während log (m) -Vergleichen der Positionen der Knoten, und jeder Vergleich erfolgt über log (n) -Zeit. Die endgültige Komplexität des Einfügens oder Löschens in eine ähnliche Struktur tritt in O (log (n) * (1 + log (m))) auf, wobei n die Gesamtzahl der Elemente in der Liste und m die Anzahl der Elemente in der Liste ist, die dem eingefügten / gelöschten entspricht. Im schlimmsten Fall erhalten wir die Komplexität O (log (n) ^ 2), wenn alle Elemente gleich sind.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein aufmerksamer Leser wird wahrscheinlich Einwände erheben: Aber was ist mit Unveränderlichkeit? </font><font style="vertical-align: inherit;">Können wir Objekte nicht ändern, wenn es sich um Tabellenschlüssel handelt? </font><font style="vertical-align: inherit;">Im Allgemeinen ist es. </font><font style="vertical-align: inherit;">Für einen Baum, in dem sortierte Objekte in Schlüsseln gespeichert sind, reicht es jedoch zusätzlich zu den Standardregeln für Vergleiche aus, die Invariante beizubehalten: Wenn a &lt;b, sollte sich diese Eigenschaft im Laufe der Zeit nicht ändern. </font><font style="vertical-align: inherit;">Dies ist nur unser Fall: Wenn die Position eines Knotens kleiner als die Position eines anderen Knotens ist, bleibt diese Eigenschaft erhalten, unabhängig davon, wie viele Knoten zwischen ihnen hinzugefügt oder gelöscht wurden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist es möglich, die Struktur dauerhaft zu machen?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurze Antwort: Nein, das ist unmöglich. </font><font style="vertical-align: inherit;">Aufgrund der Doppelverbindung des Baumes, von der Wurzel bis zu den Blättern und zurück, haben wir jeden Baumknoten mit jedem verbunden. </font><font style="vertical-align: inherit;">Die Persistenz kann nicht auf diese Weise erfolgen. Sie müssen die gesamte Struktur bei jeder Änderung neu erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich verstehe jedoch, wie eine persistente Struktur für Fälle implementiert werden kann, in denen keine Elemente in die Mitte der Liste eingefügt werden müssen. </font><font style="vertical-align: inherit;">Sie können am Anfang oder Ende Elemente hinzufügen und aus der Mitte löschen. </font><font style="vertical-align: inherit;">Die übrigen Eigenschaften sind gleich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie interessiert sind, werde ich versuchen, einen Artikel über diese Struktur zu schreiben. </font><font style="vertical-align: inherit;">Vielleicht implementiere ich es sogar in Java, Kotlin oder Scala. </font><font style="vertical-align: inherit;">Aber höchstwahrscheinlich wird es nicht bald sein.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Implementierungsfunktionen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier möchte ich einige Funktionen beschreiben, denen ich mich stellen musste. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Über eine der Optimierungen zum Speichern der Knotenposition in der Liste habe ich oben geschrieben. Hier zeigt sich die Stärke von Open Source: Ich habe den vorgefertigten TreeList-Code verwendet und mich nicht mit den Details des AVL-Baums, Knotenrotationen, Positionsaktualisierungen usw. befasst.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine weitere von TreeList geerbte Funktion sind die Links zu Teilbäumen in Baumblättern. Jeder Knoten speichert boolesche leftIsPrevious und rightIsNext. Diese Variablen zeigen das Vorhandensein oder Fehlen eines linken / rechten Teilbaums an. Wenn es keinen Teilbaum gibt, wird links / rechts anstelle einer Verknüpfung mit dem Teilbaum eine Verknüpfung mit dem Knoten gespeichert, der dem vorherigen oder nächsten Element entspricht. In unserem Beispiel ["q", "w", "e", "r", "t", "y", "u"] ist der Knoten "e" belaubt und hat keine Teilbäume. Dementsprechend sind leftIsPrevious und rightIsNext true und left und right zeigen auf die Knoten "w" bzw. "r". Dieser Ansatz hilft dabei, die Liste schneller zu durchlaufen. Und es stört die Programmierung neuer Funktionen :)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein bisschen über die Arbeit mit dem Tabellenobjekt → Knoten. Idealerweise müssen Sie ein Element beim Hinzufügen zur Struktur einmal in die Tabelle einfügen und beim Löschen aus der Struktur einmal löschen. In der Praxis konnte ich dies nicht erreichen. Wenn Sie ein Element hinzufügen, wird es der Tabelle hinzugefügt. Alles ist so, wie es sollte. Wenn Sie jedoch ein Element löschen, verschiebt der Ausgleichsalgorithmus manchmal Elemente zwischen Knoten. Das Ergebnis sind zwei Löschungen und ein Datensatz in der Tabelle anstelle einer Löschung. Dies kann behoben werden, wenn Sie die Optimierung aus leftIsPrevious und rightIsNext entfernen. Und sogar einen kleinen Leistungsgewinn erzielen, nicht nur beim Entfernen. In einigen Tests betrug der Anstieg 10-20%. Aber die Iterationsgeschwindigkeit sinkt signifikant, 1,5- bis 2,5-mal in meinen Tests. Ich habe mich entschlossen, die Optimierung vorerst zu verlassen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Java sind die Haupttabellentypen HashMap und TreeMap. Für eine Tabelle verwendet ein Objekt → ein Knoten standardmäßig HashMap. Sie können TreeMap jedoch mit einem aufgabenspezifischen Komparator verwenden. In diesem Fall suchen / löschen indexOf (obj) und remove (obj) das Objekt, das dem angegebenen Objekt gemäß dem Komparatorcode entspricht. Zum Beispiel speichern wir eine Liste von Benutzern, und der Komparator vergleicht Benutzer nur nach Namen. Dann können wir die Frage beantworten: "Welche Positionen der Liste haben Benutzer mit dem Namen 'Napoleon?'". Oder entfernen Sie alle Napoleons von der Liste :). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Struktur unterstützt null nicht. Sie können es beheben, aber es gibt kein Gefühl, dass es notwendig ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Bezug auf die Tatsache, dass die Struktur „alles weiß“, war ich natürlich etwas irreführend. </font><font style="vertical-align: inherit;">Natürlich ist bei der Arbeit mit einzelnen Elementen alles in Ordnung und unter bestimmten Bedingungen auch für den Logarithmus. </font><font style="vertical-align: inherit;">Sie weiß jedoch einige Dinge nicht, die andere Strukturen können. </font><font style="vertical-align: inherit;">Zum Beispiel ein kartesischer Baum mit einem impliziten Schlüssel, es gab Artikel darüber auf dem Hub </font><font style="vertical-align: inherit;">Es weiß nicht, wie man schnell indexOf macht, aber es weiß, wie man eine Unterliste erstellt und zwei Listen für den Logarithmus zu einer verkettet (im Durchschnitt nicht garantiert), und es kann persistent gemacht werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Java wird die Leistung normalerweise mit dem jmh-Framework gemessen. </font><font style="vertical-align: inherit;">Tests wurden auf dem 2017 MacBook Pro unter Java11 durchgeführt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe die Leistung der Standard-ArrayList, TreeList aus Apache Common-Collections und meiner beiden Klassen IndexedTreeList und IndexedTreeListSet in mehreren Szenarien verglichen. </font><font style="vertical-align: inherit;">In jedem Szenario wurden 1000 Operationen desselben Typs ausgeführt, daher sollte das Ergebnis mit 1000 multipliziert werden.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code unter dem Spoiler</font></font></b><div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-meta">@Fork(1)</span>
<span class="hljs-meta">@Warmup(iterations = 3)</span>
<span class="hljs-meta">@Measurement(iterations = 5)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PerformanceCompare</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Class&gt; CLASSES = Stream.of(TreeList.class, IndexedTreeListSet.class, IndexedTreeList.class,<font></font>
            ArrayList.class)<font></font>
            .collect(Collectors.toMap(c -&gt; c.getSimpleName(), c -&gt; c));<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ITERATIONS = <span class="hljs-number">1000</span>;<font></font>
<font></font>
    <span class="hljs-meta">@State(Scope.Benchmark)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plan</span> </span>{<font></font>
<font></font>
        <span class="hljs-meta">@Param({"10", "100", "1000", "10000", "100000", "1000000"/*, "10000000"*/})</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> size;<font></font>
<font></font>
        <span class="hljs-meta">@Param({"ArrayList", "TreeList", "IndexedTreeList", "IndexedTreeListSet"})</span>
        <span class="hljs-keyword">public</span> String className;<font></font>
<font></font>
        <span class="hljs-keyword">private</span> Random random;
        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<font></font>
<font></font>
        <span class="hljs-meta">@Setup</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException </span>{<font></font>
            random = <span class="hljs-keyword">new</span> Random();<font></font>
            list = (List&lt;Integer&gt;) CLASSES.get(className).newInstance();<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<font></font>
                list.add(i);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">indexOfKnown</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value = list.indexOf(random.nextInt(plan.size));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">indexOfUnknown</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value += list.indexOf(random.nextInt());<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addRemoveRandom</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            list.add(random.nextInt(list.size() + <span class="hljs-number">1</span>), random.nextInt());<font></font>
            value += list.remove(random.nextInt(list.size()));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value += list.get(random.nextInt(list.size()));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Timeout(time = 1, timeUnit = TimeUnit.MILLISECONDS)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException </span>{<font></font>
        Options opt = <span class="hljs-keyword">new</span> OptionsBuilder()<font></font>
                .include(PerformanceCompare.class.getSimpleName())<font></font>
                .forks(<span class="hljs-number">1</span>)
<span class="hljs-comment">//                .jvmArgs("-Xms2048m", "-Xmx2048m", "-XX:MaxDirectMemorySize=512M")</span><font></font>
                .build();<font></font>
<font></font>
        <span class="hljs-keyword">new</span> Runner(opt).run();<font></font>
    }<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst habe ich die Geschwindigkeit verglichen, mit der ein zufälliges Element aus einer Liste abgerufen wird. </font><font style="vertical-align: inherit;">Ich warne Sie sofort, dass bei diesem Test der Overhead sehr hoch ist. </font><font style="vertical-align: inherit;">Ergebnisse, die sich 100.000 * 1.000 Operationen pro Sekunde nähern, sind stark verzerrt.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testergebnis abrufen</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.get                       ArrayList       10  thrpt    5  79865.412 ± 10145.202  ops/s<font></font>
PerformanceCompare.get                       ArrayList      100  thrpt    5  81862.243 ±   983.727  ops/s<font></font>
PerformanceCompare.get                       ArrayList     1000  thrpt    5  81033.507 ±  4540.206  ops/s<font></font>
PerformanceCompare.get                       ArrayList    10000  thrpt    5  64096.123 ±  1430.361  ops/s<font></font>
PerformanceCompare.get                       ArrayList   100000  thrpt    5  41289.491 ± 11286.114  ops/s<font></font>
PerformanceCompare.get                       ArrayList  1000000  thrpt    5   8598.944 ±  2048.461  ops/s<font></font>
PerformanceCompare.get                        TreeList       10  thrpt    5  33912.275 ±  3754.284  ops/s<font></font>
PerformanceCompare.get                        TreeList      100  thrpt    5  21346.854 ±   863.588  ops/s<font></font>
PerformanceCompare.get                        TreeList     1000  thrpt    5  14808.414 ±   508.098  ops/s<font></font>
PerformanceCompare.get                        TreeList    10000  thrpt    5   8679.384 ±   109.250  ops/s<font></font>
PerformanceCompare.get                        TreeList   100000  thrpt    5   4605.998 ±  1028.945  ops/s<font></font>
PerformanceCompare.get                        TreeList  1000000  thrpt    5   2241.381 ±   768.147  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList       10  thrpt    5  34054.357 ±  3682.829  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList      100  thrpt    5  21934.002 ±  2339.947  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList     1000  thrpt    5  14626.691 ±   369.893  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList    10000  thrpt    5   7386.863 ±   342.150  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList   100000  thrpt    5   4562.126 ±   352.772  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList  1000000  thrpt    5   2105.718 ±   702.064  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet       10  thrpt    5  33317.503 ±  2307.829  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet      100  thrpt    5  21247.440 ±  1253.386  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet     1000  thrpt    5  14665.557 ±   487.833  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet    10000  thrpt    5   7667.214 ±    80.093  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet   100000  thrpt    5   3454.023 ±    82.994  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet  1000000  thrpt    5   1768.701 ±    35.878  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seltsamerweise ist hier das größte Interesse die Standard-ArrayList. Theoretisch sollte die Geschwindigkeit des Ausstiegs konstant sein und nicht von der Anzahl der Elemente abhängen. In der Praxis hält die Leistung zunächst etwa 90.000 * 1000 Operationen pro Sekunde (beachten Sie den Overhead), aber bei einer Listenlänge von mehreren tausend Elementen beginnt sie zu sinken. Dies ist auf den immer häufiger auftretenden Cache-Fehler zurückzuführen: Der Prozessor-Cache verfügt nicht über die erforderlichen Daten, und Sie müssen immer häufiger Daten im RAM abrufen. Mit einer Million Elementen ist die Geschwindigkeit des Tests zehnmal niedriger, aber in der Praxis ist der Leistungsabfall noch größer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TreeList, IndexedTreeList und IndexedTreeListSet zeigen voraussichtlich ähnliche Ergebnisse. </font><font style="vertical-align: inherit;">Erwartet viel langsamer als ArrayList. </font><font style="vertical-align: inherit;">Selbst mit einer kleinen Anzahl von Elementen ist TreeList um ein Vielfaches langsamer als ArrayList, obwohl der Test den Unterschied nur zweimal zeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der nächste Test ist addRemoveRandom. </font><font style="vertical-align: inherit;">Hier füge ich in jedem Test ein Element an einer zufälligen Position ein und entferne ein Element an einer zufälligen Position.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AddRemoveRandom-Testergebnis</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.addRemoveRandom           ArrayList       10  thrpt    5  12440.764 ±   485.642  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList      100  thrpt    5   9880.123 ±   464.014  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList     1000  thrpt    5   5288.905 ±  1219.055  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList    10000  thrpt    5   1024.942 ±   179.366  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList   100000  thrpt    5     91.219 ±    25.380  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList  1000000  thrpt    5      5.499 ±     0.400  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList       10  thrpt    5   6242.607 ±   350.290  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList      100  thrpt    5   3117.945 ±   116.066  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList     1000  thrpt    5   1829.778 ±    80.516  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList    10000  thrpt    5   1230.077 ±    53.381  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList   100000  thrpt    5    443.571 ±    69.207  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList  1000000  thrpt    5    308.963 ±    84.077  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList       10  thrpt    5   3556.511 ±   144.596  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList      100  thrpt    5   2120.777 ±    83.848  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList     1000  thrpt    5   1211.112 ±    92.288  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList    10000  thrpt    5    789.458 ±    19.450  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList   100000  thrpt    5    302.989 ±    40.030  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList  1000000  thrpt    5    178.822 ±    92.853  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet       10  thrpt    5   4138.007 ±   119.943  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet      100  thrpt    5   2435.803 ±    20.276  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet     1000  thrpt    5   1445.054 ±   276.909  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet    10000  thrpt    5    972.256 ±    19.987  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet   100000  thrpt    5    366.608 ±    94.487  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet  1000000  thrpt    5    227.677 ±    48.276  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist davon auszugehen, dass ArrayList auf kleinen Listen schneller ist. </font><font style="vertical-align: inherit;">Interessant ist jedoch, dass er in diesem Test auf Listen mit bis zu 10.000 Elementen gewinnt. </font><font style="vertical-align: inherit;">Anscheinend ist System.arrayCopy sehr gut optimiert und nutzt alle Funktionen moderner Prozessoren. </font><font style="vertical-align: inherit;">Ab 10.000 Artikeln beginnen spezialisierte Datenstrukturen zu gewinnen. </font><font style="vertical-align: inherit;">Bei 1.000.000 Elementen beträgt der Geschwindigkeitsunterschied das 30-50-fache. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird erwartet, dass IndexedTreeList und IndexedTreeListSet langsamer als TreeList sind. </font><font style="vertical-align: inherit;">Etwa 1,5 - 2 mal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die verbleibenden 2 Tests indexOfKnown und indexOfUnknown sollten nur das Hauptmerkmal dieser Struktur demonstrieren. </font><font style="vertical-align: inherit;">Der Unterschied zwischen den Tests besteht darin, dass wir in einem Fall nach einem Element suchen, das in der Liste enthalten ist, und in dem anderen Fall nach einem Element, das nicht in der Liste enthalten ist.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testergebnis indexOfKnown und indexOfUnknown</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.indexOfKnown              ArrayList       10  thrpt    5  41424.356 ±   549.047  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList      100  thrpt    5  17216.477 ±  1444.744  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList     1000  thrpt    5   2296.306 ±    76.372  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList    10000  thrpt    5    233.863 ±    26.926  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList   100000  thrpt    5     23.208 ±     2.776  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList  1000000  thrpt    5      0.919 ±     0.455  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList       10  thrpt    5  26740.708 ±  1323.125  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList      100  thrpt    5   5670.923 ±    99.638  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList     1000  thrpt    5    745.408 ±    26.827  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList    10000  thrpt    5     52.288 ±     1.362  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList   100000  thrpt    5      4.224 ±     0.855  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList  1000000  thrpt    5      0.193 ±     0.052  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList       10  thrpt    5  34485.128 ±  1582.703  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList      100  thrpt    5  29209.412 ±  1544.268  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList     1000  thrpt    5  21139.584 ±  1442.867  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList    10000  thrpt    5  12544.306 ±   312.097  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList   100000  thrpt    5   3538.201 ±   272.537  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList  1000000  thrpt    5   1420.119 ±   538.476  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet       10  thrpt    5  39201.995 ±  1887.065  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet      100  thrpt    5  34204.112 ±  1122.517  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet     1000  thrpt    5  25374.557 ±  1596.746  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet    10000  thrpt    5  14291.317 ±   391.180  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet   100000  thrpt    5   4215.898 ±   283.680  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet  1000000  thrpt    5   1729.100 ±  1260.815  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList       10  thrpt    5  59053.313 ±  1845.665  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList      100  thrpt    5  10867.572 ±   142.823  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList     1000  thrpt    5   1186.583 ±    28.003  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList    10000  thrpt    5    120.953 ±     4.146  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList   100000  thrpt    5     11.936 ±     0.320  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList  1000000  thrpt    5      0.566 ±     0.335  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList       10  thrpt    5  28134.237 ±  2291.670  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList      100  thrpt    5   3153.930 ±   158.734  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList     1000  thrpt    5    322.383 ±    44.245  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList    10000  thrpt    5     25.674 ±     1.787  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList   100000  thrpt    5      1.867 ±     0.291  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList  1000000  thrpt    5      0.093 ±     0.008  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList       10  thrpt    5  66625.126 ±  5232.668  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList      100  thrpt    5  70038.055 ±  5803.848  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList     1000  thrpt    5  63240.467 ±   885.956  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList    10000  thrpt    5  54731.988 ±  3950.150  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList   100000  thrpt    5  22049.476 ±   821.924  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList  1000000  thrpt    5   9459.862 ±   804.738  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet       10  thrpt    5  70274.968 ± 15830.355  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet      100  thrpt    5  71017.685 ±  6920.447  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet     1000  thrpt    5  66405.960 ±  1127.231  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet    10000  thrpt    5  57983.963 ±  3276.142  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet   100000  thrpt    5  41277.110 ±  9919.893  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet  1000000  thrpt    5   9840.185 ±  2159.352  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier haben ArrayList und TreeList fast keine Überraschungen. Mit zunehmender Größe nimmt die Geschwindigkeit nahezu linear ab. Die Suche nach einem Artikel aus einer Nichtliste wird voraussichtlich zweimal langsamer sein als die Suche nach einem Artikel aus der Liste, weil Sie müssen das gesamte Array anstatt der Hälfte im Durchschnitt durchlaufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IndexedTreeList und IndexedTreeListSet zeigen hier jedoch das erwartete gute Ergebnis. Diese Datenstrukturen zeigen eine mit ArrayList vergleichbare IndexOf-Ausführungsgeschwindigkeit, selbst bei 10 Elementen. Mit 1000 Elementen sind diese Strukturen zehnmal schneller, mit 1.000.000 1000-mal schneller. Bei der Suche nach einem Element, das nicht in der Liste enthalten ist, wird eine höhere Geschwindigkeit erwartet als bei der Suche nach einem Element in der Liste.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interessant ist auch die Leistungssenkung von IndexedTreeList und IndexedTreeListSet im indexOfUnknown-Test. </font><font style="vertical-align: inherit;">Hier ist die Situation ähnlich wie im Test mit ArrayList.get. </font><font style="vertical-align: inherit;">Theoretisch hätten wir keinen Leistungsabfall erhalten sollen, aber in der Praxis haben wir ihn aufgrund eines Cache-Fehlers erhalten, und dies ist von Bedeutung.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstelle einer Schlussfolgerung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich weiß immer noch nicht, ob die vorgeschlagene Struktur eine Neuheit aufweist oder nicht. Einerseits ist die Idee nicht kompliziert, wenn Sie wissen, wie der Baum mit einem impliziten Schlüssel funktioniert. Andererseits habe ich keine Beschreibung einer Struktur mit solchen Eigenschaften gesehen. Und wenn ja, dann ist es sinnvoll, die Struktur bekannter zu machen, es könnte für jemanden nützlich sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber selbst wenn dies ein anderes Fahrrad ist, habe ich versucht, es nützlich zu machen. Eine Pull-Anfrage in allgemeinen Sammlungen wurde erstellt, aber zum Zeitpunkt des Schreibens ist dieser Artikel noch nicht ausgegossen. Da ich weiß, wie langsam alles in Open Source ablaufen kann, bin ich nicht überrascht, wenn sich der Prozess monatelang hinzieht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Etwas überrascht über das Ergebnis des Vergleichs der Leistung von ArrayList und TreeList. </font><font style="vertical-align: inherit;">Tests haben gezeigt, dass TreeList keinen Sinn macht, bis zu 10.000 Elemente in der Listengröße zu verwenden. </font><font style="vertical-align: inherit;">Es wäre interessant, B-Tree anstelle eines Binärbaums zu versuchen. </font><font style="vertical-align: inherit;">Diese Struktur sollte den Speicher sorgfältiger nutzen und höchstwahrscheinlich schneller arbeiten. </font><font style="vertical-align: inherit;">Und dafür können Sie die Idee mit Indizierung anpassen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In jedem Fall macht es Spaß, ein Instrument im Arsenal zu haben, das (fast) alles mit vorhersehbarer Komplexität kann.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ursprüngliches </font></font><br>
</a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pull-Anforderungsprojekt in Apache Common-Collections </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ticket in Jira</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de488758/index.html">DEFCON-Konferenz 27. Internet-Betrugserkennung</a></li>
<li><a href="../de488762/index.html">Elegante asynchrone Programmierung mit Versprechen</a></li>
<li><a href="../de488766/index.html">Kunst und Technologie: Universität von Massachusetts in Lowell</a></li>
<li><a href="../de488768/index.html">Verdammt noch mal, oder wie man auf Englisch schwört, mit einer kultivierten Person verwechselt zu werden</a></li>
<li><a href="../de488776/index.html">Verbesserungen der Barrierefreiheit in Visual Studio 2019 für Mac</a></li>
<li><a href="../de488780/index.html">Mozilla verlor im Browserkrieg, glaubt aber immer noch, dass es das Internet retten könnte</a></li>
<li><a href="../de488782/index.html">Wie gefällt Ihnen diese Option zur Abhängigkeitsverwaltung in Python?</a></li>
<li><a href="../de488784/index.html">Kommerzialisierung von Verbesserungen der freien Software unter Copyleft-Lizenzen</a></li>
<li><a href="../de488786/index.html">Wie detailliert sollte eine User Story sein?</a></li>
<li><a href="../de488792/index.html">Überwachung der Standortverfügbarkeit in Russland am Knie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>