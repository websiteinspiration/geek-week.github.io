<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüöí üë©üèº‚Äçüîß üë©üèº‚Äçüé® Measuring memory bandwidth on the knee üåå ü§öüèæ üö§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A few weeks ago in a conversation over dinner, a colleague complained about some kind of slow process. He calculated the number of bytes generated, th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Measuring memory bandwidth on the knee</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487898/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A few weeks ago in a conversation over dinner, a colleague complained about some kind of slow process. He calculated the number of bytes generated, the number of processing cycles, and ultimately, the amount of RAM. A colleague said that a modern GPU with a memory bandwidth of more than 500 GB / s would eat up its task and not choke. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It seemed to me that this is an interesting approach. Personally, I have not previously evaluated performance objectives from this perspective. Yes, I know about the difference in processor and memory performance. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2de/d86/182/2ded861823d832e2e382d1e97e0ec147.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I know how to write code that makes heavy use of the cache. I know the approximate delay figures. But this is not enough to immediately assess the memory bandwidth.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is a thought experiment. </font><font style="vertical-align: inherit;">Imagine in memory a continuous array of a billion 32-bit integers. </font><font style="vertical-align: inherit;">This is 4 gigabytes. </font><font style="vertical-align: inherit;">How long will it take to iterate over this array and add up the values? </font><font style="vertical-align: inherit;">How many bytes per second can the CPU read from RAM? </font><font style="vertical-align: inherit;">Continuous data? </font><font style="vertical-align: inherit;">Random access? </font><font style="vertical-align: inherit;">How well can this process be parallelized? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You will say that these are useless questions. </font><font style="vertical-align: inherit;">Real programs are too complex to make such a naive landmark. </font><font style="vertical-align: inherit;">And there is! </font><font style="vertical-align: inherit;">The real answer is ‚Äúdepending on the situation.‚Äù </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, I think this issue is worth exploring. </font><font style="vertical-align: inherit;">I am not trying to find the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">answer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">But I think that we can define some upper and lower boundaries, some interesting points in the middle and learn something in the process.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The numbers every programmer should know</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you read programming blogs, you probably came across "numbers that every programmer should know." </font><font style="vertical-align: inherit;">They look something like this:</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link to L1 cache 0.5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incorrect 5 ns prediction</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Link to L2 cache 7 ns 14x to L1 cache</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mutex Capture / Release 25 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Link to main memory 100 ns 20x to L2 cache, 200x to L1 cache</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compress 1000 bytes with Zippy 3000 ns 3 Œºs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sending 1000 bytes over a 1 Gbps network 10,000 ns 10 Œºs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Random Read 4000 with SSD 150,000 ns 150 Œºs ~ 1GB / s SSD</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Read 1 MB sequentially from 250,000 ns 250 Œºs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Round-trip packet inside the data center 500,000 ns 500 Œºs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 MB sequential read in SSD 1,000,000 ns 1,000 Œºs 1 ms ~ 1 GB / s SSD, 4x memory</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Disk search 10,000,000 ns 10,000 Œºs 10 ms 20x to data center</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Read 1 MB sequentially from disk 20,000,000 ns 20,000 Œºs 20 ms 80x to memory, 20x to SSD</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Package Sending CA-&gt; Netherlands-&gt; CA 150,000,000 ns 150,000 Œºs 150 ms</font></font></pre> <br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jonas Boner</font></font></a></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Great list. </font><font style="vertical-align: inherit;">He pops up on HackerNews at least once a year. </font><font style="vertical-align: inherit;">Every programmer should know these numbers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But these numbers are about something else. </font><font style="vertical-align: inherit;">Latency and bandwidth are not the same thing.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delay in 2020</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That list was compiled in 2012, and this article of 2020, times have changed. </font><font style="vertical-align: inherit;">Here are the numbers for Intel i7 with </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StackOverflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hit in L1 cache, ~ 4 cycles (2.1 - 1.2 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hit in the L2 cache, ~ 10 cycles (5.3 - 3.0 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hit in the L3 cache, for a single core ~ ‚Äã‚Äã40 cycles (21.4 - 12.0 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hit in L3 cache, together for another kernel ~ 65 cycles (34.8 - 19.5 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hit the L3 cache, with a change for another kernel ~ 75 cycles (40.2 - 22.5 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Local RAM ~ 60 ns</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interesting! </font><font style="vertical-align: inherit;">What changed?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 has become slower; </font></font><code>0,5 ‚Üí 1,5 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L2 faster; </font></font><code>7 ‚Üí 4,2 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ratio of L1 and L2 is much reduced; </font></font><code>2,5x  14</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(wow!)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L3 cache has now become the standard; </font></font><code> 12  40 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM has become faster; </font></font><code>100 ‚Üí 60 </code></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will not draw far-reaching conclusions. </font><font style="vertical-align: inherit;">It is unclear how the original numbers were calculated. </font><font style="vertical-align: inherit;">We will not compare apples with oranges. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here are some figures from </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wikichip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on the bandwidth and cache size of my processor.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory Bandwidth: 39.74 Gigabytes per second</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L1 cache: 192 kilobytes (32 KB per core)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L2 Cache: 1.5 megabytes (256 KB per core)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L3 Cache: 12 megabytes (shared; 2 MB per core)</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What I want to know:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM performance upper limit</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lower limit</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 / L2 / L3 Cache Limits</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naive benchmarking</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's do some tests. </font><font style="vertical-align: inherit;">To measure bandwidth, I wrote a simple C ++ program. </font><font style="vertical-align: inherit;">Very approximately she looks like this.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Generate random elements</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>; ++i) <span class="hljs-comment">// one billion ints</span>
    nums.push_back(rng() % <span class="hljs-number">1024</span>); <span class="hljs-comment">// small nums to prevent overflow</span><font></font>
<font></font>
<span class="hljs-comment">// Run test with 1 to 12 threads</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> thread_count = <span class="hljs-number">1</span>; thread_count &lt;= MAX_THREADS; ++thread_count) {
    <span class="hljs-keyword">auto</span> slice_len = nums.size() / thread_count;<font></font>
    <font></font>
    <span class="hljs-comment">// for-each thread</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> thread = <span class="hljs-number">0</span>; thread &lt; thread_count; ++thread) {<font></font>
        <font></font>
        <span class="hljs-comment">// partition data</span>
        <span class="hljs-keyword">auto</span> begin = nums.begin() + thread * slice_len;
        <span class="hljs-keyword">auto</span> end = (thread == thread_count - <span class="hljs-number">1</span>)<font></font>
            ? nums.end() : begin + slice_len;<font></font>
<font></font>
        <span class="hljs-comment">// spawn threads</span>
        futures.push_back(<span class="hljs-built_in">std</span>::async([begin, end] { <font></font>
            <font></font>
            <span class="hljs-comment">// sum ints sequentially</span>
            <span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = begin; ptr &lt; end; ++ptr)<font></font>
                sum += *ptr;<font></font>
            <span class="hljs-keyword">return</span> sum;<font></font>
        }));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// combine results</span>
    <span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; <span class="hljs-built_in">future</span> : futures)<font></font>
        sum += <span class="hljs-built_in">future</span>.get();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Some details are omitted. But you understood the idea. Create a large, continuous array of elements. Divide the array into separate fragments. Process each fragment in a separate thread. Accumulate results. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You also need to measure random access. It is very difficult. I tried several ways, eventually decided to mix pre-computed indexes. Each index exists exactly once. Then the inner loop iterates over the indices and computes </font></font><code>sum += nums[index]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = <span class="hljs-comment">/* ... */</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt; indices = <span class="hljs-comment">/* shuffled */</span>;<font></font>
<font></font>
<span class="hljs-comment">// random access</span>
<span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = indices.begin(); ptr &lt; indices.end(); ++ptr) {
    <span class="hljs-keyword">auto</span> idx = *ptr;<font></font>
    sum += nums[idx];<font></font>
}<font></font>
<span class="hljs-keyword">return</span> sum;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In calculating the throughput, I </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do not</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> consider the memory of the index array. </font><font style="vertical-align: inherit;">Only bytes that contribute to the total are counted </font></font><code>sum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">I do not benchmark my hardware, but assess the ability to work with data sets of different sizes and with different access schemes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will carry out tests with three data types: </font></font><br>
<br>
<code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- the main 32-bit integer </font></font><br>
<code>matri4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- contains </font></font><code>int[16]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">fits in a 64-byte cache line </font></font><br>
<code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- uses built-in tools</font></font><code>__m256i</code><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Big block</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My first test works with a large block of memory. A 1 GB block of </font></font><code>N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">items is highlighted and filled with small random values. A simple loop iterates over an array N times, so it accesses the memory in volume </font></font><code>N </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to calculate the sum </font></font><code>int64_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Several threads split the array, and each gets access to the same number of elements. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d36/45d/2d1/d3645d2d119e28f1306945258d1b422b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TA-dah! In this graph, we take the average execution time of the summation operation and convert it from </font></font><code>runtime_in_nanoseconds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to </font></font><code>gigabytes_per_second</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pretty good result. </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can sequentially read 11 GB / s in a single stream. It scales linearly until it reaches 38 GB / s. Tests </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faster, but rest against the same ceiling.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is a clear and obvious ceiling on how much data we can read from RAM per second. </font><font style="vertical-align: inherit;">On my system, this is approximately 40 GB / s. </font><font style="vertical-align: inherit;">This complies with current specifications listed above. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Judging by the bottom three graphs, random access is slow. </font><font style="vertical-align: inherit;">Very, very slow. </font><font style="vertical-align: inherit;">Single-threaded performance </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a negligible 0.46 GB / s. </font><font style="vertical-align: inherit;">This is 24 times slower than sequential stacking at 11.03 GB / s! </font><font style="vertical-align: inherit;">The test </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shows the best result, because it runs on full cache lines. </font><font style="vertical-align: inherit;">But it is still four to seven times slower than sequential access, and peaks at only 8 GB / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Small block: sequential read</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On my system, the L1 / L2 / L3 cache size for each stream is 32 KB, 256 KB, and 2 MB. What happens if you take a 32-kilobyte block of elements and iterate over it 125,000 times? This is 4 GB of memory, but we will always go to the cache. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2bd/662/3dd/2bd6623dd63d0eae81548f4b5e6d4599.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Awesome! Single-threaded performance is similar to reading a large block, about 12 GB / s. Except that this time, multithreading breaks through the 40 GB / s ceiling. It makes sense. The data remains in the cache, so the RAM bottleneck does not appear. For data that did not fit in the L3 cache, the same ceiling of about 38 GB / s applies. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The test </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shows similar results to the circuit, but even faster; 31 GB / s in single-threaded mode, 171 GB / s in multi-threaded. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/929/9ab/ceb/9299abceb2e779406f598b76c00beba5.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's look at </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pay attention to the y axis.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f96/7b2/9c6/f967b29c6f839f0536667b9918fabd70.png"><br>
<br>
<code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">performed exceptionally fast. </font><font style="vertical-align: inherit;">It is 10 times faster than </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">On a 16 KB block, it even breaks through 1000 GB / s! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviously, this is a surface synthetic test. </font><font style="vertical-align: inherit;">Most applications do not perform the same operation with the same data a million times in a row. </font><font style="vertical-align: inherit;">The test does not show performance in the real world. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But the lesson is clear. </font><font style="vertical-align: inherit;">Inside the cache, data is processed </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quickly</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">With a very high ceiling when using SIMD: more than 100 GB / s in single-threaded mode, more than 1000 GB / s in multi-threaded. </font><font style="vertical-align: inherit;">Writing data to the cache is slow and with a hard limit of about 40 GB / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Small block: random read</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's do the same, but now with random access. </font><font style="vertical-align: inherit;">This is my favorite part of the article. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/983/854/ef8/983854ef856e17e37493e9c8b928d318.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reading random values ‚Äã‚Äãfrom RAM is slow, only 0.46 GB / s. </font><font style="vertical-align: inherit;">Reading random values ‚Äã‚Äãfrom the L1 cache is very fast: 13 GB / s. </font><font style="vertical-align: inherit;">This is faster than reading serial data </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from RAM (11 GB / s). </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/59a/7bf/b72/59a7bfb728445b69a7947523ab9b0900.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The test </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shows a similar result for the same template, but about twice as fast as </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d99/bc2/f70/d99bc2f70c2f7bda177f70ec166bd74a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Random access is </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">insanely fast.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Random Access Findings</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Free reading from memory is slow. </font><font style="vertical-align: inherit;">Catastrophically slow. </font><font style="vertical-align: inherit;">Less than 1 GB / s for both test cases </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">At the same time, random reads from the cache are surprisingly fast. </font><font style="vertical-align: inherit;">It is comparable to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sequential</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reading from RAM. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/dde/0a4/52b/dde0a452b8f293758c2efe1760115306.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It needs to be digested. </font><font style="vertical-align: inherit;">Random access to the cache is comparable in speed to sequential access to RAM. </font><font style="vertical-align: inherit;">The drop from L1 16 KB to L2 256 KB is only half or less. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I think that this will have profound consequences.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linked lists are considered harmful</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chasing a pointer (jumping on pointers) is bad. </font><font style="vertical-align: inherit;">Very very bad. </font><font style="vertical-align: inherit;">How much is performance decreasing? </font><font style="vertical-align: inherit;">See for yourself. </font><font style="vertical-align: inherit;">I did an extra test that wraps </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>std::unique_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Each access goes through a pointer. </font><font style="vertical-align: inherit;">Here is a terrible, just catastrophic result.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">     1 thread | </font><font style="vertical-align: inherit;">matrix4x4 | </font><font style="vertical-align: inherit;">unique_ptr | </font><font style="vertical-align: inherit;">diff |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------- | --------------- | ------------ | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Large Block - Seq | </font><font style="vertical-align: inherit;">14.8 GB / s | </font><font style="vertical-align: inherit;">0.8 GB / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Seq | </font><font style="vertical-align: inherit;">31.6 GB / s | </font><font style="vertical-align: inherit;">2.2 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Seq | </font><font style="vertical-align: inherit;">22.2 GB / s | </font><font style="vertical-align: inherit;">1.9 GB / s | </font><font style="vertical-align: inherit;">12x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Large Block - Rand | </font><font style="vertical-align: inherit;">2.2 GB / s | </font><font style="vertical-align: inherit;">0.1 GB / s | </font><font style="vertical-align: inherit;">22x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Rand | </font><font style="vertical-align: inherit;">23.2 GB / s | </font><font style="vertical-align: inherit;">1.7 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Rand | </font><font style="vertical-align: inherit;">15.2 GB / s | </font><font style="vertical-align: inherit;">0.8 GB / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font>
<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
     6 threads | </font><font style="vertical-align: inherit;">matrix4x4 | </font><font style="vertical-align: inherit;">unique_ptr | </font><font style="vertical-align: inherit;">diff |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------- | --------------- | ------------ | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Large Block - Seq | </font><font style="vertical-align: inherit;">34.4 GB / s | </font><font style="vertical-align: inherit;">2.5 GB / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Seq | </font><font style="vertical-align: inherit;">154.8 GB / s | </font><font style="vertical-align: inherit;">8.0 GB / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Seq | </font><font style="vertical-align: inherit;">111.6 GB / s | </font><font style="vertical-align: inherit;">5.7 GB / s | </font><font style="vertical-align: inherit;">20x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Large Block - Rand | </font><font style="vertical-align: inherit;">7.1 GB / s | </font><font style="vertical-align: inherit;">0.4 GB / s | </font><font style="vertical-align: inherit;">18x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 KB - Rand | </font><font style="vertical-align: inherit;">95.0 GB / s | </font><font style="vertical-align: inherit;">7.8 GB / s | </font><font style="vertical-align: inherit;">12x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 KB - Rand | </font><font style="vertical-align: inherit;">58.3 GB / s | </font><font style="vertical-align: inherit;">1.6 GB / s | </font><font style="vertical-align: inherit;">36x |</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The sequential summation of values ‚Äã‚Äãbehind the pointer is performed at a speed of less than 1 GB / s </font><font style="vertical-align: inherit;">The double-skipped random access speed of the cache is only 0.1 GB / s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chasing a pointer slows down code execution 10-20 times. </font><font style="vertical-align: inherit;">Do not let your friends use linked lists. </font><font style="vertical-align: inherit;">Please think about the cache.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Budget Estimation for Frames</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is common for game developers to set a limit (budget) for the load on the CPU and memory. But I have never seen a bandwidth budget. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In modern games, FPS continues to grow. Now it is at 60 FPS. VR operates at a frequency of 90 Hz. I have a 144 Hz gaming monitor. It's awesome, so the 60 FPS seems like shit. I will never return to the old monitor. Esports and streamers Twitch monitors 240 Hz. This year, Asus introduced a 360 Hz monster at CES. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My processor has an upper limit of about 40 GB / s. That seems like a big number! However, at a frequency of 240 Hz, only 167 MB per frame is obtained. A realistic application can generate 5 GB / s traffic at 144 Hz, which is only 69 MB per frame. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is a table with a few numbers.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        | </font><font style="vertical-align: inherit;">1 | </font><font style="vertical-align: inherit;">10 | </font><font style="vertical-align: inherit;">30 | </font><font style="vertical-align: inherit;">60 | </font><font style="vertical-align: inherit;">90 | </font><font style="vertical-align: inherit;">144 | </font><font style="vertical-align: inherit;">240 | </font><font style="vertical-align: inherit;">360 |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------- | ------- | -------- | -------- | -------- | ------ - | -------- | -------- | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
40 GB / s | </font><font style="vertical-align: inherit;">40 GB | </font><font style="vertical-align: inherit;">4 GB | </font><font style="vertical-align: inherit;">1.3 GB | </font><font style="vertical-align: inherit;">667 MB | </font><font style="vertical-align: inherit;">444 MB | </font><font style="vertical-align: inherit;">278 MB | </font><font style="vertical-align: inherit;">167 MB | </font><font style="vertical-align: inherit;">111 MB |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 GB / s | </font><font style="vertical-align: inherit;">10 GB | </font><font style="vertical-align: inherit;">1 GB | </font><font style="vertical-align: inherit;">333 MB | </font><font style="vertical-align: inherit;">166 MB | </font><font style="vertical-align: inherit;">111 MB | </font><font style="vertical-align: inherit;">69 MB | </font><font style="vertical-align: inherit;">42 MB | </font><font style="vertical-align: inherit;">28 MB |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 1 GB / s | </font><font style="vertical-align: inherit;">1 GB | </font><font style="vertical-align: inherit;">100 MB | </font><font style="vertical-align: inherit;">33 MB | </font><font style="vertical-align: inherit;">17 MB | </font><font style="vertical-align: inherit;">11 MB | </font><font style="vertical-align: inherit;">7 MB | </font><font style="vertical-align: inherit;">4 MB | </font><font style="vertical-align: inherit;">3 MB |</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It seems to me that it is useful to assess problems from this perspective. </font><font style="vertical-align: inherit;">This makes it clear that some ideas are not feasible. </font><font style="vertical-align: inherit;">Reaching 240 Hz is not easy. </font><font style="vertical-align: inherit;">This will not happen by itself.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The numbers every programmer should know (2020)</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The previous list is out of date. </font><font style="vertical-align: inherit;">Now it needs to be updated and brought into compliance by 2020. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here are a few numbers for my home computer. </font><font style="vertical-align: inherit;">This is a mixture of AIDA64, Sandra and my benchmarks. </font><font style="vertical-align: inherit;">The figures do not give a complete picture and are only a starting point.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latency L1: 1 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L2 Delay: 2.5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Delay L3: 10 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAM Latency: 50 ns</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(per thread)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L1 band: 210 GB / s</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L2 band: 80 GB / s</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L3 Band: 60 GB / s</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(whole system)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAM band: 45 GB / s</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It would be nice to create a small, simple open source benchmark. </font><font style="vertical-align: inherit;">Some C file that can be run on desktop computers, servers, mobile devices, consoles, etc. But I'm not the kind of person who writes such a tool.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denial of responsibility</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Measuring memory bandwidth is difficult. </font><font style="vertical-align: inherit;">Very difficult. </font><font style="vertical-align: inherit;">There are probably errors in my code. </font><font style="vertical-align: inherit;">Many unaccounted factors. </font><font style="vertical-align: inherit;">If you have some criticism for my technique, you are probably right. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ultimately, I think this is normal. </font><font style="vertical-align: inherit;">This article is not about the exact performance of my desktop. </font><font style="vertical-align: inherit;">This is a problem statement from a certain point of view. </font><font style="vertical-align: inherit;">And about how to learn how to do some rough mathematical calculations.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A colleague shared an interesting opinion with me about GPU memory bandwidth and application performance. </font><font style="vertical-align: inherit;">This prompted me to study the memory performance on modern computers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For approximate calculations, here are some numbers for a modern desktop:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM performance</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maximum: </font></font><code>45 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On average, approximately: </font></font><code>5 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimum: </font></font><code>1 /</code></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 / L2 / L3 Cache Performance (per core)</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maximum (c simd): </font></font><code>210 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>80 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>60 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On average, approximately: </font></font><code>25 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>15 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>9 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimum: </font></font><code>13 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>8 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>3,5 /</code></li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sample ratings are related to performance </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Real code will never be so simple. </font><font style="vertical-align: inherit;">But for calculations on a napkin, this is a reasonable starting point. </font><font style="vertical-align: inherit;">You need to adjust this figure based on the memory access patterns in your program, the characteristics of your equipment and code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, the most important thing is a new way to think about problems. </font><font style="vertical-align: inherit;">Presenting the problem in bytes per second or bytes per frame is another lens to look through. </font><font style="vertical-align: inherit;">This is a useful tool just in case. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thanks for reading.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source</font></font></h1><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmark C ++ </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python Graph </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data.json</font></font></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further research</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This article only slightly touched on the topic. </font><font style="vertical-align: inherit;">I probably won‚Äôt go into it. </font><font style="vertical-align: inherit;">But if he did, then he could cover some of the following aspects:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recording performance</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">False sharing</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance </font></font><code>std::atomic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(or lack thereof)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance counters</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLB Performance</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cache Protocols</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System specifications</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tests were conducted on my home PC. </font><font style="vertical-align: inherit;">Only stock settings, no overclocking.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS: Windows 10 v1903 build 18362</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU: Intel i7-8700k @ 3.70 GHz</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM: 2x16 GSkill Ripjaw DDR4-3200 (16-18-18-38 @ 1600 MHz)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motherboard: Asus TUF Z370-Plus Gaming</font></font></li>
</ul></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en487884/index.html">5 things I would like to know before developing the exchange</a></li>
<li><a href="../en487888/index.html">CSRF at Umbraco CMS</a></li>
<li><a href="../en487890/index.html">Translate speech to text on iOS using the Speech framework</a></li>
<li><a href="../en487894/index.html">BarsUP.AM: how we developed a tool for protecting information of web applications</a></li>
<li><a href="../en487896/index.html">When death turns into art: epitaphs of famous people with a deep meaning in English</a></li>
<li><a href="../en487900/index.html">pyqtdeploy, or we pack the Python program in exe'shnik ... the hard way</a></li>
<li><a href="../en487902/index.html">From fire to fire: refractory solid-state electrolyte for lithium-ion batteries</a></li>
<li><a href="../en487906/index.html">The book "Computer Networks. Principles, Technologies, Protocols: Anniversary Edition ¬ª</a></li>
<li><a href="../en487908/index.html">The beginning of the war of technological processes: 5 nm and 3 nm</a></li>
<li><a href="../en487910/index.html">Natural laws and elegant mathematics: problems and solutions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>