<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📶 ❕ 🧑🏻 Comment Gatsby a contourné Next.js 🧣 😉 👶🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'auteur de l'article, dont nous publions la traduction aujourd'hui, travaille comme programmeur à Antler. Cette société est un générateur mondial de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Comment Gatsby a contourné Next.js</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/500228/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'auteur de l'article, dont nous publions la traduction aujourd'hui, travaille comme programmeur à Antler. </font><font style="vertical-align: inherit;">Cette société est un générateur mondial de startups. </font><font style="vertical-align: inherit;">Il y a plusieurs jours de démonstration à Antler plusieurs fois par an, réunissant de nombreux créateurs de startups et investisseurs du monde entier. </font><font style="vertical-align: inherit;">La situation autour de COVID-19 a forcé Antler à traduire ses événements dans un format en ligne.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/hq/r9/an/hqr9anmkfyicv4znlhi2ynk16rm.jpeg"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'entreprise voulait s'assurer que les visiteurs de leurs événements virtuels, sans être distraits par quoi que ce soit, et ne rester coincés nulle part, verraient la chose la plus importante. </font><font style="vertical-align: inherit;">À savoir, les idées de startups présentées au public, exprimées comme le contenu de pages Web. </font><font style="vertical-align: inherit;">Les journées de démonstration virtuelle peuvent intéresser un public assez large. </font><font style="vertical-align: inherit;">Certains membres de ce public peuvent participer pour la première fois à quelque chose comme ça. </font><font style="vertical-align: inherit;">Par conséquent, l'entreprise devait tout faire de la meilleure façon possible et fournir un chargement à grande vitesse des pages représentant les startups. </font><font style="vertical-align: inherit;">Ils ont décidé que ce n'est que le cas lorsqu'une application Web progressive haute performance (PWA, Progressive Web App) peut être utile. </font><font style="vertical-align: inherit;">Le principal problème était de trouver la bonne technologie pour développer la PWA.</font></font><br>
<a name="habracut"></a><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f54/6f9/1fa/f546f91fa52e40c139cc78fe26b1ad06.gif"></div><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu de serveur ou générateur de site statique?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour commencer, je vais vous présenter un peu le cours. Tous nos projets sont basés sur React et la bibliothèque Material-UI. En conséquence, nous avons initialement décidé de ne pas s'écarter de cette pile technologique, ce qui nous permettrait d'assurer une vitesse de développement élevée et de rendre le nouveau projet compatible avec ce que nous avons déjà. La principale différence entre ce nouveau projet et nos autres applications React est que la base de données pour eux a été créée à l'aide de l'application create-react et qu'ils ont été entièrement rendus sur le client (CSR, Client-Side Rendering). Cela a notamment conduit au fait que lors du chargement initial de l'application, les utilisateurs étaient obligés d'observer un écran blanc vierge pendant le chargement, le traitement et l'exécution du code JavaScript du projet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avions besoin d'un niveau de performance sans compromis. Par conséquent, nous avons commencé à penser à utiliser le rendu côté serveur (SSR, rendu côté serveur) ou un générateur de site statique (SSG, Static Site Generator) afin que le chargement initial des applications soit le plus rapide possible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos données sont stockées dans Cloud Firestore, et nous y accédons en utilisant Algolia. Cela nous permet de contrôler, au niveau du champ de la base de données, l'accès public aux données avec des clés API restreintes. Cela améliore également les performances des requêtes. Par expérience, nous savons que les requêtes Algolia sont plus rapides que la normale et que le SDK JavaScript Firestore compressé a une taille de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">86 Ko</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dans le cas de l'Algolie, c'est </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7,5 Kb</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, nous voulions rendre les données que nous donnons aux clients aussi fraîches que possible. Cela nous aiderait à corriger très rapidement des données erronées qui pourraient être publiées accidentellement. Alors que la pratique standard du SSG prévoit la mise en œuvre de demandes de données pertinentes lors de l'assemblage du projet, nous nous attendions à ce que dans notre base de données les données soient écrites assez souvent. En particulier, nous parlons d'un enregistrement de données initié par des administrateurs utilisant l'interface </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">firetable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et à l'initiative des fondateurs des projets utilisant le portail web. Cela conduit à un montage compétitif du projet. De plus, en raison des caractéristiques structurelles de notre base de données, des modifications mineures peuvent conduire à de nouvelles opérations d'assemblage de projet. Cela rend notre pipeline CI / CD extrêmement inefficace. Par conséquent, nous avions besoin que les demandes de réception de données du référentiel soient exécutées chaque fois qu'un utilisateur demande le chargement d'une page. Malheureusement, cela signifiait que notre solution ne serait pas un exemple de projet SSG «propre».</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialement, notre application a été créée sur la base de Gatsby, car nous utilisions déjà des landing pages construites sur Gatsby, et sur l'une d'elles, la bibliothèque Material-UI était déjà utilisée. </font><font style="vertical-align: inherit;">La première version du projet a formé une page qui, pendant le chargement des données, affichait un "squelette". </font><font style="vertical-align: inherit;">Dans le même temps, la première peinture contentieuse (FCP) était de l'ordre de 1 seconde.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d75/578/718/d7557871834d0d244f8501327d68810d.gif"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Téléchargement du "squelette" de la page avec chargement ultérieur des données</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
La solution s'est avérée intéressante, mais elle avait ses inconvénients, car les données de sortie de la page ont été téléchargées à l'initiative du client:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour voir le contenu de la page, les utilisateurs devraient attendre le téléchargement de cette page elle-même et les données qui y sont affichées, obtenues à travers 4 demandes à l'Algolia.</font></font></li>
<li>    JS-    .   ,  React   «»      .         DOM.</li>
<li>         .  ,  ,    .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conséquence, au cours du long week-end, j'ai décidé d'expérimenter avec la version SSR du projet créé à l'aide de Next.js. Heureusement pour moi, la documentation de Material-UI avait un exemple de projet pour Next.js. Par conséquent, je n'avais pas besoin d'apprendre tout ce framework à partir de zéro. Je viens de parcourir certaines parties du didacticiel et de la documentation. J'ai converti l'application en un projet rendu sur le serveur. Lorsqu'un utilisateur a demandé un chargement de page, le serveur a exécuté les demandes de données nécessaires pour remplir la page. Cette étape nous a permis de résoudre les trois problèmes ci-dessus. Voici les résultats des tests pour deux options d'application.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b60/0da/cda/b600dacda702f25e97808ed9f762ff8c.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résultats de la recherche d'applications à l'aide de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google PageSpeed ​​Insights</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . A gauche se trouve Gatsby (SSG), à droite se trouve Next.js (SSR) ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">image originale</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Le FCP pour la version Next.js du projet était environ 3 fois plus élevé que pour sa version basée sur Gatsby. La version Gatsby du projet avait un indice de vitesse de 3,3 secondes, tandis que la version Next.js avait 6,2 secondes. Le temps jusqu'au premier octet (TTFB, Time To First Byte) était de 2,56 secondes lors de l'utilisation de Next.js et de 10-20 ms lors de l'utilisation de Gatsby.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient de noter que la version Next.js du site a été déployée sur un autre service (ici, nous avons utilisé les services d'hébergement ZEIT Now et Firebase - cela pourrait également affecter l'augmentation du TTFB). Mais, malgré cela, il était clair que le transfert des opérations de téléchargement de données vers le serveur faisait apparaître le site plus lentement, malgré le fait que tous les documents de la page étaient chargés à peu près en même temps. Le fait est que dans la version Next.js du projet, l'utilisateur ne voit pendant un certain temps qu'une page blanche vierge.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e0/8a2/ab3/6e08a2ab3bcb4c06471cc92545848d8a.gif"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capture d'écran montrant le chargement de deux versions d'une application. </font><font style="vertical-align: inherit;">Le téléchargement ne s'est pas terminé en même temps. </font><font style="vertical-align: inherit;">Les enregistrements sont synchronisés dès que vous appuyez sur la touche Entrée.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Tout cela nous donne une leçon importante dans le domaine du développement Web: vous devez donner aux utilisateurs un retour visuel. </font><font style="vertical-align: inherit;">Une</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> étude a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> révélé que les applications qui utilisent des écrans squelettiques semblent se charger plus rapidement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce résultat, d'ailleurs, ne correspond pas à l'ambiance que vous auriez pu ressentir si vous lisiez des articles sur le développement web au cours des dernières années. </font><font style="vertical-align: inherit;">À savoir, nous parlons du fait qu'il n'y a rien de mal à utiliser les ressources du client et que le SSR n'est pas une solution complète aux problèmes de performances.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performances de génération de site statique: comparaison de Gatsby et Next.js</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors que les deux cadres à l'étude, Gatsby et Next.js, sont connus respectivement pour leur capacité à générer des sites statiques et le rendu de serveur, la </font><font style="vertical-align: inherit;">prise en charge de SSG a été améliorée </font><font style="vertical-align: inherit;">dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next.js 9.3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui en fait un concurrent de Gatsby. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au moment d'écrire ces lignes, la capacité de Next.js à générer des sites statiques était encore très récente. Elle avait un peu plus d'un mois. Elle est toujours signalée sur la première page du projet. Maintenant, il n'y a pas beaucoup de comparaisons des capacités SSG de Gatsby et Next.js (ou peut-être qu'il n'y a pas encore de telles comparaisons). En conséquence, j'ai décidé de mener ma propre expérience.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai rendu la version Gatsby du projet à l'état lorsque les données ont été téléchargées sur le client, et j'ai fait en sorte que les deux versions de l'application aient exactement le même ensemble de fonctionnalités. À savoir, j'ai dû supprimer ce dont les plugins Gatsby sont responsables: fonctions SEO, génération de favicons, manifeste PWA. Afin de comparer exclusivement les bundles JavaScript créés par les frameworks, je n'ai pas inclus dans les projets des images et autres contenus téléchargés depuis des sources externes. Les deux versions de l'application ont été déployées sur la plate-forme d'hébergement Firebase. Pour référence, deux versions de l'application ont été créées sur la base de Gatsby 2.20.9 et Next.js 9.3.4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai exécuté Lighthouse sur mon ordinateur 6 fois pour chaque version. Les résultats ont montré un léger avantage pour Gatsby.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82a/522/059/82a522059afba13a70e62df76144b6e6.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valeurs moyennes obtenues après 6 lancements Lighthouse pour chaque framework ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">image originale</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En termes d'évaluation globale des performances, la version Next.js n'était que légèrement derrière la version Gatsby. Il en va de même pour le FCP et l'indice de vitesse. Le Next First Potential First Input Delay pour la version Next.js de l'application est légèrement plus élevé que pour la version Gatsby.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin de mieux comprendre ce qui se passe, je me suis tourné vers l'onglet Réseau des outils de développement Chrome. Il s'est avéré que dans la version Next.js du projet, le nombre de fragments dans lesquels le code JavaScript est divisé est 3 de plus que dans la version Gatsby (à l'exclusion des fichiers manifestes), mais le code compressé est 20 Ko plus petit. Les demandes supplémentaires nécessaires pour télécharger ces fichiers peuvent-elles l'emporter sur les avantages d'un ensemble plus petit au point de nuire aux performances?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27b/d84/d9a/27bd84d9aad10ae1f3421a0f829c3fa2.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la version Gatsby du projet, 7 requêtes sont exécutées pour télécharger 379 Ko de données. Dans la version Next.js du projet - 12 demandes de téléchargement de 359 Ko de données ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">image d'origine</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Si vous analysez les performances JavaScript, les outils de développement indiquent que la version Next.js du projet a besoin de 300 ms supplémentaires pour le premier rendu, et que cette version passe plus de temps sur la tâche Évaluer le script. Dans les outils du développeur, cette tâche a même été marquée comme une «tâche longue».</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24b/1be/11c/24b1be11c62fc6a1561a413555e53c0f.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse des performances des différentes options de projet à l'aide de l'onglet Performances des outils de développement Chrome ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">image d'origine</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
J'ai comparé le code du projet pour savoir s'il existe des différences dans leur implémentation qui pourraient affecter les performances. À l'exception de la suppression du code inutile et des corrections associées aux types TypeScript manquants, la seule différence était la mise en œuvre d'un défilement fluide de la page lors du déplacement vers ses parties individuelles. Cette fonctionnalité a été précédemment introduite par un fichier</font></font><code>gatsby-browser.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et a été déplacée vers un</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> composant importé dynamiquement</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Par conséquent, ce code ne s'exécuterait que dans un navigateur. (Nous avons utilisé le package npm à</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> défilement lisse</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et lors de son importation, il a besoin d'un objet</font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.) Ce problème peut être le coupable, mais je ne sais tout simplement pas comment il est géré dans Next.js.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gatsby est plus pratique du point de vue du développeur</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalement, j'ai décidé d'opter pour la version Gatsby du projet. De plus, ici, je n'ai pas pris en compte le très petit avantage de performance que Gatsby a montré par rapport au mécanisme SSG Next.js (je ne me cramponnerai pas sérieusement à l'avantage de 0,6 seconde?). Le fait est que dans la version Gatsby du projet, de nombreuses fonctionnalités PWA sont déjà implémentées, et je n'ai pas vu l'intérêt de les implémenter à nouveau dans la version Next.js de l'application. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque je venais de créer la première version Gatsby du projet, j'ai pu ajouter rapidement quelques fonctionnalités PWA utiles au projet. Par exemple, pour ajouter à chaque page mes propres balises META nécessaires au référencement, je n'ai eu qu'à </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lire le manuel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pour équiper le projet d'un manifeste PWA, je n'avais besoin que d'utiliser le </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">plugin</font></a><font style="vertical-align: inherit;"> approprié</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Afin d'équiper le projet de favicons qui prendraient en charge toutes les plates-formes disponibles (et dans ce cas, il y a toujours un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terrible gâchis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), je n'ai même pas eu à faire quoi que ce soit, car le support favicon fait partie du plugin responsable du manifeste. C'est très confortable!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'implémentation des mêmes fonctionnalités dans la version Next.js de l'application nécessiterait plus de travail. Il faudrait que je cherche des manuels de formation, toutes sortes de «bonnes pratiques». Et le fait que je réussirais, de toute façon, ne me donnerait aucun avantage. Après tout, néanmoins, la version Next.js du projet ne diffère pas en performances supérieures à sa version Gatsby. C'est d'ailleurs la raison pour laquelle j'ai décidé de simplement désactiver les fonctionnalités correspondantes de la version Gatsby du projet, en la comparant à la version Next.js. La documentation Next.js est plus concise que la documentation Gatsby (peut-être le fait est que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next.js est</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plus petit que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gatsby</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">J'aime beaucoup le tutoriel gamified Next.js. </font><font style="vertical-align: inherit;">Mais la documentation Gatsby plus complète est plus précieuse avec le développement réel de PWA, même si à première vue elle semble énorme.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/010/138/800/0101388008c84ce2dda5f6f8f522cf6d.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation Gatsby</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Vrai, je ne peux pas me taire sur les points forts de Next.js:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grâce au tutoriel et à la documentation concise de Next.js, il semble que ce framework puisse être appris plus rapidement que Gatsby.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le système de chargement de données utilisé dans Next.js est basé sur des fonctions asynchrones et l'API Fetch. </font><font style="vertical-align: inherit;">Par conséquent, lors du développement de Next.js, le développeur n'a pas le sentiment qu'il a besoin d'apprendre GraphQL afin de tirer pleinement parti des capacités du framework.</font></font></li>
<li> Next.js    TypeScript,      Gatsby        ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   </a> (    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>).     Next.js      ,     ,        ,        .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grâce au fait que Next.js a amélioré le support SSG, ce framework est devenu un outil puissant qui permet, au niveau de chaque page individuelle, de choisir la méthode de travail avec. </font><font style="vertical-align: inherit;">Il peut s'agir de SSR, SSG ou CSR. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, si je pouvais générer cette application sous une forme complètement statique, Next.js me conviendrait mieux, car je pourrais utiliser l'Algolia JS-API standard et conserver le code de chargement des données </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le même fichier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que et le code du composant. </font><font style="vertical-align: inherit;">Étant donné qu'Algolia n'a pas d'API GraphQL intégrée et qu'il n'y a pas de plugin Gatsby pour Algolia, l'implémentation d'un tel mécanisme dans Gatsby nécessiterait l'ajout de ce code </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à un nouveau fichier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Et cela va à l'encontre de la manière déclarative intuitive de décrire les pages.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À propos des moyens supplémentaires d'améliorer les performances du projet</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir résolu le problème du choix d'un cadre, il peut être noté qu'il existe d'autres moyens d'améliorer les performances du projet qui ne sont pas liés au cadre. </font><font style="vertical-align: inherit;">Ces améliorations pourraient bien porter la cote du projet Lighthouse à 100.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liste de diffusion de mars</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algolia </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">,</font></a><font style="vertical-align: inherit;"> il a été recommandé d'ajouter un indice </font></font><code>preconnect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour augmenter encore la vitesse d'exécution des requêtes. </font><font style="vertical-align: inherit;">(Vrai, malheureusement, le mauvais fragment de code est donné dans la newsletter. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici le</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bon code.)</font></font></li>
<li>    .   JS-  CSS-,  webpack- Gatsby.   Gatsby  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>   .  ,       ,   Netlify  Amazon S3. ,  Firebase Hosting,  ,    .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons des images JPEG et PNG téléchargées par les créateurs de startups dans l'application. </font><font style="vertical-align: inherit;">Nous ne les compressons pas et ne les optimisons pas. </font><font style="vertical-align: inherit;">L'amélioration de cet aspect de notre application est tout un défi et dépasse la portée de ce projet. </font><font style="vertical-align: inherit;">De plus, ce serait génial si toutes ces images étaient converties au format WebP. </font><font style="vertical-align: inherit;">Par conséquent, nous devions stocker des images en utilisant un seul format graphique très efficace. </font><font style="vertical-align: inherit;">Malheureusement, comme pour de nombreuses autres fonctionnalités PWA, l'équipe de développement de Safari WebKit crée une dépendance avec le support WebP. </font><font style="vertical-align: inherit;">Maintenant, c'est le seul navigateur majeur qui </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne prend pas en charge</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ce format.</font></font></li>
</ul><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sommaire</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous résumons brièvement ce dont nous parlions ici, nous pouvons dire ce qui suit:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La sortie de la version "squelettique" de la page pendant le chargement des données par le client crée à l'utilisateur un sentiment de fonctionnement plus rapide du site Web que lorsque l'utilisateur regarde une page vierge pendant que le serveur charge les données.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La version gatsby du site n'était que légèrement plus rapide que la version Next.js. </font><font style="vertical-align: inherit;">Cependant, le système de plug-in Gatsby et la documentation de projet de haute qualité augmentent la convivialité de ce cadre pour le développeur.</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chers lecteurs! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisez-vous des générateurs de sites statiques ou des systèmes de rendu côté serveur pour accélérer vos projets?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/a_/bs/aa/a_bsaactpbr8fltzymtkhqbw1d4.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr500216/index.html">Oubliez l'Anthropocène: nous sommes entrés dans l'ère de la synthèse</a></li>
<li><a href="../fr500218/index.html">Modèle épidémiologique Covid-19</a></li>
<li><a href="../fr500220/index.html">Disques vinyle et cassettes directement dans votre Android</a></li>
<li><a href="../fr500222/index.html">Téléphones sans fil des biplans britanniques de la Première Guerre mondiale</a></li>
<li><a href="../fr500224/index.html">Nez électronique DIY</a></li>
<li><a href="../fr500232/index.html">Apprendre Akka.NET: serveur d'un jeu en ligne simple</a></li>
<li><a href="../fr500234/index.html">Pourquoi j'ai fait un projet de comptabilité des dépenses personnelles pour Git + JS</a></li>
<li><a href="../fr500238/index.html">Dis moi ce qui te tracasse</a></li>
<li><a href="../fr500244/index.html">En dehors du tableau</a></li>
<li><a href="../fr500246/index.html">Protection et piratage de la Xbox 360 (partie 3)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>