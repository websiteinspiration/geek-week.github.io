<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏄 🗯️ 🔔 Programmation d'un jeu pour un appareil embarqué sur ESP32: lecteur, batterie, son 🖕🏾 🚣🏼 🏇🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Début: système d'assemblage, saisie, affichage .
 
 Partie 4: conduire
 Odroid Go dispose d'un emplacement pour carte microSD, qui sera utile pour tél...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programmation d'un jeu pour un appareil embarqué sur ESP32: lecteur, batterie, son</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503876/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/800/42e/44b80042e94aa2f2da9da2d2296461ad.jpg" alt="image"></div><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Début: système d'assemblage, saisie, affichage</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 4: conduire</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go dispose d'un emplacement pour carte microSD, qui sera utile pour télécharger des ressources (sprites, fichiers audio, polices), et peut-être même pour sauvegarder l'état du jeu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le lecteur de carte est connecté via SPI, mais IDF facilite l'interaction avec la carte SD en extrayant les appels SPI et en utilisant </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonctions </font><strong><font style="vertical-align: inherit;">POSIX</font></strong><font style="vertical-align: inherit;"> standard </font><font style="vertical-align: inherit;">comme </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fopen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fread</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fwrite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tout cela est basé sur la bibliothèque </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FatFs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donc la carte SD doit être formatée au format FAT standard.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est connecté au même bus SPI que l'écran LCD, mais utilise une ligne de sélection de puce différente. </font><font style="vertical-align: inherit;">Lorsque nous devons lire ou écrire sur la carte SD (et cela ne se produit pas très souvent), le pilote SPI commutera le signal CS de l'écran vers le lecteur de carte SD, puis effectuera l'opération. </font><font style="vertical-align: inherit;">Cela signifie que lors de l'envoi de données à l'écran, nous ne pouvons effectuer aucune opération avec la carte SD, et vice versa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour le moment, nous faisons tout dans un seul thread et utilisons la transmission de blocage via SPI à l'écran, donc il ne peut y avoir de transactions simultanées avec la carte SD et l'écran LCD. </font><font style="vertical-align: inherit;">Dans tous les cas, il y a une forte probabilité que nous chargeons toutes les ressources au moment du lancement.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modification de ESP-IDF</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous essayons d'initialiser l'interface de la carte SD après l'initialisation de l'affichage, nous rencontrerons un problème qui rend impossible le chargement d'Odroid Go. </font><font style="vertical-align: inherit;">ESP-IDF v4.0 ne prend pas en charge l'accès partagé au bus SPI lorsqu'il est utilisé avec une carte SD. </font><font style="vertical-align: inherit;">Récemment, les développeurs ont ajouté cette fonctionnalité, mais elle n'est pas encore dans une version stable, nous allons donc apporter nous-mêmes une petite modification à l'IDF. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commentez la ligne 303 </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp-idf / components / driver / sdspi_host.c</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Initialize SPI bus</span>
<span class="hljs-keyword">esp_err_t</span> ret = spi_bus_initialize((<span class="hljs-keyword">spi_host_device_t</span>)slot, &amp;buscfg,<font></font>
    slot_config-&gt;dma_channel);<font></font>
<span class="hljs-keyword">if</span> (ret != ESP_OK) {<font></font>
    ESP_LOGD(TAG, <span class="hljs-string">"spi_bus_initialize failed with rc=0x%x"</span>, ret);
    <span class="hljs-comment">//return ret;</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir effectué cette modification, nous verrons toujours une erreur lors de l'initialisation, mais cela ne provoquera plus le redémarrage de l'ESP32, car le code d'erreur ne se propage pas ci-dessus.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisation</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57f/4f8/b0f/57f4f8b0fcca66e243637eeb68b39ff7.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/554/eae/9ec/554eae9ec4a3e850eb44e817e8b7b181.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous devons indiquer à IDF quelles broches ESP32 sont connectées au lecteur MicroSD afin qu'il configure correctement le pilote SPI sous-jacent, qui communique réellement avec le lecteur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les notes générales </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VSPI.XXXX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont à nouveau utilisées dans le </font><strong><font style="vertical-align: inherit;">diagramme</font></strong><font style="vertical-align: inherit;"> , mais nous pouvons les parcourir jusqu'aux numéros de contact réels sur ESP32. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'initialisation est similaire à l'initialisation LCD, mais au lieu de la structure de configuration générale SPI, nous utilisons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdspi_slot_config_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est destiné à une carte SD connectée via le bus SPI. Nous configurons les numéros de contact et les propriétés de montage de carte correspondants dans le système FatFS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La documentation IDF ne recommande pas d'utiliser la fonction </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_vfs_fat_sdmmc_mount</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le code du programme terminé. Il s'agit d'une fonction wrapper qui effectue de nombreuses opérations pour nous, mais jusqu'à présent, elle fonctionne assez normalement, et probablement rien ne changera à l'avenir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le paramètre </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"/ sdcard"</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><font style="vertical-align: inherit;">cette fonction définit le point de montage virtuel de la carte SD, que nous utiliserons ensuite comme préfixe lors de l'utilisation de fichiers. Si nous avions un fichier nommé "test.txt" sur notre carte SD, le chemin que nous utiliserions pour le lier serait "/sdcard/test.txt". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après l'initialisation de l'interface de la carte SD, l'interaction avec les fichiers est triviale: on peut simplement utiliser des appels standard aux fonctions </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POSIX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui est très pratique.</font></font><br>
<br>
<blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">   8.3</a>,              .    ,   <b>fopen</b>   .        <b>make menuconfig</b>,       ,     <b>8.3</b>.</blockquote><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d94/62f/94a/d9462f94aeec7fbdce989e34967e637d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai créé </font><font style="vertical-align: inherit;">un sprite 64x64 </font><font style="vertical-align: inherit;">en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aseprite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (terrible) qui utilise seulement deux couleurs: complètement noir (pixel désactivé) et complètement blanc (pixel activé). Aseprite n'a pas la possibilité d'enregistrer la couleur RGB565 ou d'exporter en tant que bitmap brut (c'est-à-dire sans compression et en-têtes d'image), j'ai donc exporté l'image-objet au format PNG temporaire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, en utilisant </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ImageMagick, j'ai</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> converti les données en un fichier PPM, qui a transformé l'image en données brutes non compressées avec un simple en-tête. Ensuite, j'ai ouvert l'image dans un éditeur hexadécimal, supprimé l'en-tête et converti la couleur 24 bits en 16 bits, supprimant toutes les occurrences </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x000000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et toutes les occurrences </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">L'ordre des octets ici n'est pas un problème, car </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne changent pas lors du changement de l'ordre des octets. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fichier brut peut être téléchargé à </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partir d'ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">FILE* spriteFile = fopen(<span class="hljs-string">"/sdcard/key"</span>, <span class="hljs-string">"r"</span>);<font></font>
assert(spriteFile);<font></font>
<font></font>
<span class="hljs-keyword">uint16_t</span>* sprite = (<span class="hljs-keyword">uint16_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">64</span> * <span class="hljs-number">64</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>));<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i)<font></font>
{<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; ++j)<font></font>
	{<font></font>
		fread(sprite, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>), <span class="hljs-number">64</span> * <span class="hljs-number">64</span>, spriteFile);<font></font>
	}<font></font>
}<font></font>
<font></font>
fclose(spriteFile);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, nous ouvrons le fichier de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clé</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contenant des octets bruts et le lisons dans le tampon. </font><font style="vertical-align: inherit;">À l'avenir, nous chargerons les ressources de sprite différemment, mais pour une démo, cela suffit.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> spriteRow = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = y; row &lt; y + <span class="hljs-number">64</span>; ++row)<font></font>
{<font></font>
	spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = x; col &lt; x + <span class="hljs-number">64</span>; ++col)<font></font>
	{<font></font>
		<span class="hljs-keyword">uint16_t</span> pixelColor = sprite[<span class="hljs-number">64</span> * spriteRow + spriteCol];<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pixelColor != <span class="hljs-number">0</span>)<font></font>
		{<font></font>
			gFramebuffer[row * LCD_WIDTH + col] = color;<font></font>
		}<font></font>
<font></font>
		++spriteCol;<font></font>
	}<font></font>
<font></font>
	++spriteRow;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour dessiner un sprite, nous parcourons itérativement son contenu. </font><font style="vertical-align: inherit;">Si le pixel est blanc, nous le dessinons dans la couleur sélectionnée par les boutons. </font><font style="vertical-align: inherit;">S'il est noir, nous le considérons comme un fond et ne dessinons pas.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Votre navigateur ne prend pas en charge la vidéo HTML5.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_4/media/sprite_drawing.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'appareil photo de mon téléphone déforme considérablement les couleurs. </font><font style="vertical-align: inherit;">Et désolé de l'avoir secouée. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour tester l'enregistrement de l'image, nous allons déplacer la clé à un certain endroit sur l'écran, changer sa couleur, puis écrire le tampon d'image sur la carte SD afin qu'elle puisse être visualisée sur l'ordinateur.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span> (input.menu)<font></font>
{<font></font>
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* snapFilename = <span class="hljs-string">"/sdcard/framebuf"</span>;<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Writing snapshot to %s"</span>, snapFilename);<font></font>
<font></font>
	FILE* snapFile = fopen(snapFilename, <span class="hljs-string">"wb"</span>);<font></font>
	assert(snapFile);<font></font>
<font></font>
		fwrite(gFramebuffer, <span class="hljs-keyword">sizeof</span>(gFramebuffer[<span class="hljs-number">0</span>]), LCD_WIDTH * LCD_HEIGHT, snapFile);<font></font>
	}<font></font>
<font></font>
	fclose(snapFile);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Appuyez sur la touche Menu pour enregistrer le contenu du tampon d'image dans un fichier appelé </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">framebuf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ce sera un tampon d'image brut, donc les pixels resteront toujours au format RGB565 avec l'ordre des octets inversé. </font><font style="vertical-align: inherit;">Nous pouvons à nouveau utiliser ImageMagick pour convertir ce format en PNG pour le visualiser sur un ordinateur.</font></font><br>
<br>
<pre><code class="cpp hljs">convert -depth <span class="hljs-number">16</span> -size <span class="hljs-number">320</span>x240+<span class="hljs-number">0</span> -endian msb rgb565:FRAMEBUF snap.png</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr, nous pouvons implémenter la lecture / écriture au format BMP / PNG et nous débarrasser de tout ce tracas avec ImageMagick, mais ce n'est qu'un code de démonstration. </font><font style="vertical-align: inherit;">Jusqu'à présent, je n'ai pas décidé quel format de fichier je veux utiliser pour stocker les sprites.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0bd/09c/e66/0bd09ce669a61276676a87b01c15e6f2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est la! </font><font style="vertical-align: inherit;">Le tampon de trame Odroid Go s'affiche sur l'ordinateur de bureau.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Références</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schéma Odroid Go</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation ESP-IDF: SDMMC</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 5: batterie</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go possède une batterie lithium-ion, nous pouvons donc créer un jeu auquel vous pouvez jouer en déplacement. </font><font style="vertical-align: inherit;">C'est une idée tentante pour quelqu'un qui a joué le premier Gameboy enfant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, nous avons besoin d'un moyen de demander le niveau de batterie de l'Odroid Go. </font><font style="vertical-align: inherit;">La batterie est connectée au contact de l'ESP32, nous pouvons donc lire la tension pour avoir une idée approximative du temps de fonctionnement restant.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schème</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f2/ceb/13b/1f2ceb13bf408d8773f22047464e4e66.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le diagramme montre </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> connecté à la </font><font style="vertical-align: inherit;">tension </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBAT</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> après avoir été tiré à la terre par une résistance. Deux résistances ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R21</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R23</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) forment un diviseur de tension similaire à celui utilisé sur la croix du gamepad; les résistances ont à nouveau la même résistance de sorte que la tension est la moitié de l'original. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En raison du diviseur de tension, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lira une tension égale à la moitié de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBAT</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cela est probablement dû au fait que les contacts ADC de l'ESP32 ne peuvent pas lire la haute tension de la batterie lithium-ion (4,2 V à la charge maximale). Quoi qu'il en soit, cela signifie que pour obtenir la vraie tension, vous devez doubler la tension lue à partir de l'ADC (ADC).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la lecture de la valeur de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous obtenons une valeur numérique, mais perdons la valeur analogique qu'elle représente. Nous avons besoin d'un moyen d'interpréter une valeur numérique avec un ADC sous la forme d'une tension analogique physique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDF vous permet de calibrer l'ADC, qui essaie de donner un niveau de tension basé sur la tension de référence. Cette tension de référence ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vref</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) est de 1100 mV par défaut, mais en raison des caractéristiques physiques, chaque appareil est légèrement différent. ESP32 dans Odroid Go a un Vref défini manuellement, «flashé» dans eFuse, que nous pouvons utiliser comme un Vref plus précis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La procédure sera la suivante: d'abord, nous allons configurer l'étalonnage ADC, et lorsque nous voulons lire la tension, nous prendrons un certain nombre d'échantillons (par exemple, 20) pour calculer les lectures moyennes; nous utilisons ensuite l'IDF pour convertir ces lectures en tension. Le calcul de la moyenne élimine le bruit et donne des lectures plus précises. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, il n'y a pas de connexion linéaire entre la tension et la charge de la batterie. Lorsque la charge diminue, la tension baisse, lorsqu'elle augmente, elle augmente, mais de manière imprévisible. Tout ce que l'on peut dire: si la tension est inférieure à 3,6 V environ, la batterie est déchargée, mais il est étonnamment difficile de convertir avec précision le niveau de tension en pourcentage de la charge de la batterie.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour notre projet, ce n'est pas particulièrement important. </font><font style="vertical-align: inherit;">Nous pouvons implémenter une approximation approximative pour informer le joueur de la nécessité de charger rapidement l'appareil, mais nous n'en souffrirons pas, en essayant d'obtenir le pourcentage exact.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LED d'état</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/0ad/2d6/b520ad2d63e2a4c59924debb6c3613bc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur le panneau avant sous l'écran Odroid Go, il y a une LED bleue (LED), que nous pouvons utiliser à n'importe quelle fin. Vous pouvez leur montrer que l'appareil est allumé et fonctionne, mais dans ce cas, lorsque vous jouez dans l'obscurité, une LED bleu vif brillera sur votre visage. Par conséquent, nous l'utiliserons pour indiquer une faible charge de la batterie (bien que je préfère une couleur rouge ou ambre pour cela). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour utiliser la LED, vous devez définir </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme sortie, puis lui appliquer un signal haut ou bas pour allumer et éteindre la LED. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je pense qu'une </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">résistance de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2 kΩ ( </font><strong><font style="vertical-align: inherit;">résistance de limitation de courant</font></strong><font style="vertical-align: inherit;"> ) sera suffisante pour que nous ne brûlions pas la LED et fournissions trop de courant à partir de la broche GPIO.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La LED a une résistance assez faible, donc si 3,3 V lui est appliqué, alors nous la brûlerons en changeant le courant. </font><font style="vertical-align: inherit;">Pour se protéger contre cela, une résistance est généralement connectée en série avec la LED. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, les résistances de limitation de courant pour les LED sont généralement bien inférieures à 2 kΩ, donc je ne comprends pas pourquoi la résistance </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R7</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une telle résistance.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisation</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">adc1_channel_t</span> BATTERY_READ_PIN = ADC1_GPIO36_CHANNEL;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BATTERY_LED_PIN = GPIO_NUM_2;<font></font>
<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">esp_adc_cal_characteristics_t</span> gCharacteristics;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeBatteryReader</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-comment">// Configure LED</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; BATTERY_LED_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure ADC</span><font></font>
	{<font></font>
		adc1_config_width(ADC_WIDTH_BIT_12);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
<font></font>
    	<span class="hljs-keyword">esp_adc_cal_value_t</span> type = esp_adc_cal_characterize(<font></font>
    		ADC_UNIT_1, ADC_ATTEN_DB_11, ADC_WIDTH_BIT_12, <span class="hljs-number">1100</span>, &amp;gCharacteristics);<font></font>
<font></font>
    	assert(type == ESP_ADC_CAL_VAL_EFUSE_VREF);<font></font>
    }<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Battery reader initialized"</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'abord, nous définissons la LED GPIO comme sortie afin de pouvoir la commuter si nécessaire. </font><font style="vertical-align: inherit;">Ensuite, nous configurons la broche ADC, comme nous l'avons fait dans le cas d'une croix - avec une largeur de bit de 12 et une atténuation minimale. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_characterize</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> effectue des calculs pour nous de caractériser l'ADC afin que nous puissions plus tard convertir les lectures numériques en stress physique.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lecture de la batterie</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">Odroid_ReadBatteryLevel</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SAMPLE_COUNT = <span class="hljs-number">20</span>;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> raw = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sampleIndex = <span class="hljs-number">0</span>; sampleIndex &lt; SAMPLE_COUNT; ++sampleIndex)<font></font>
	{<font></font>
		raw += adc1_get_raw(BATTERY_READ_PIN);<font></font>
	}<font></font>
<font></font>
	raw /= SAMPLE_COUNT;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> voltage = <span class="hljs-number">2</span> * esp_adc_cal_raw_to_voltage(raw, &amp;gCharacteristics);<font></font>
<font></font>
	<span class="hljs-keyword">return</span> voltage;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous prenons vingt échantillons bruts de l'ADC au contact de l'ADC, puis les divisons pour obtenir la valeur moyenne. Comme mentionné ci-dessus, cela contribue à réduire le bruit des lectures. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous utilisons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_raw_to_voltage</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour convertir la valeur brute en tension réelle. En raison du diviseur de tension mentionné ci-dessus, nous doublons la valeur de retour: la valeur lue sera la moitié de la tension réelle de la batterie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lieu de trouver des moyens délicats de convertir cette tension en un pourcentage de la charge de la batterie, nous retournerons une tension simple. Laissez la fonction appelante décider d'elle-même ce qu'elle doit faire de la tension - que ce soit pour la transformer en pourcentage de la charge, ou simplement l'interpréter comme une valeur élevée ou faible.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La valeur est renvoyée en millivolts, la fonction appelante doit donc effectuer la conversion appropriée. </font><font style="vertical-align: inherit;">Cela empêche le débordement du flotteur.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Réglage LED</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_EnableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">1</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_DisableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">0</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces deux fonctions simples suffisent pour utiliser la LED. </font><font style="vertical-align: inherit;">Nous pouvons soit allumer ou éteindre la lumière. </font><font style="vertical-align: inherit;">Laissez la fonction appelante décider quand le faire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pourrions créer une tâche qui surveillerait périodiquement la tension de la batterie et changerait en conséquence l'état de la LED, mais je ferais mieux d'interroger la tension de la batterie dans notre cycle principal, puis de décider comment régler la tension de la batterie à partir de là.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Démo</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint32_t</span> batteryLevel = Odroid_ReadBatteryLevel();<font></font>
<font></font>
<span class="hljs-keyword">if</span> (batteryLevel &lt; <span class="hljs-number">3600</span>)<font></font>
{<font></font>
	Odroid_EnableBatteryLight();<font></font>
}<font></font>
<span class="hljs-keyword">else</span><font></font>
{<font></font>
	Odroid_DisableBatteryLight();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons simplement demander le niveau de la batterie dans le cycle principal, et si la tension est inférieure à la valeur seuil, allumez la LED, indiquant le besoin de charge. </font><font style="vertical-align: inherit;">Sur la base des matériaux étudiés, je peux dire que 3600 mV (3,6 V) est un bon signe d'une faible charge des batteries lithium-ion, mais les batteries elles-mêmes sont complexes.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Références</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schéma Odroid Go</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation ESP-IDF: ADC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caractéristiques de la batterie</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 6: son</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La dernière étape pour obtenir une interface complète avec tout le matériel Odroid Go est d'écrire une couche sonore. Ayant fini avec cela, nous pouvons commencer à évoluer vers une programmation plus générale du jeu, moins liée à la programmation pour Odroid. Toutes les interactions avec les périphériques seront effectuées via les fonctions </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En raison de mon manque d'expérience en programmation sonore et du manque de bonne documentation de la part d'IDF, lorsque je travaillais sur un projet, la mise en œuvre du son prenait le plus de temps. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fin de compte, il ne fallait pas tellement de code pour jouer le son. La plupart du temps a été consacré à la conversion des données audio en ESP32 souhaité et à la configuration du pilote audio ESP32 pour correspondre à la configuration matérielle.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bases du son numérique</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le son numérique se compose de deux parties: l' </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enregistrement</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lecture</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Record</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour enregistrer du son sur un ordinateur, nous devons d'abord le convertir de l'espace d'un signal continu (analogique) en l'espace d'un signal discret (numérique). </font><font style="vertical-align: inherit;">Cette tâche est accomplie à l'aide d'un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convertisseur analogique-numérique (ADC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (dont nous avons parlé lorsque nous avons travaillé avec la croix dans la partie 2). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'ADC reçoit un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">échantillon de l'</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> onde entrante et numérise la valeur, qui peut ensuite être enregistrée dans un fichier.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jouer</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un fichier audio numérique peut être renvoyé de l'espace numérique à l'espace analogique à l'aide d'un convertisseur </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">numérique-analogique (DAC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">DAC ne peut reproduire des valeurs que dans une certaine plage. </font><font style="vertical-align: inherit;">Par exemple, un DAC 8 bits avec une source de 3,3 V peut produire des tensions analogiques dans la plage de 0 à 3,3 mV par pas de 12,9 mV (3,3 V divisé par 256). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le DAC prend des valeurs numériques et les reconvertit en tension, qui peut être transmise à un amplificateur, un haut-parleur ou tout autre appareil capable de recevoir un signal audio analogique.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taux d'échantillonnage</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de l'enregistrement d'un son analogique via l'ADC, des échantillons sont prélevés à une certaine fréquence et chaque échantillon est un «instantané» du signal sonore à un moment donné. Ce paramètre est appelé </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la fréquence d'échantillonnage</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et est mesuré en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hertz</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus la fréquence d'échantillonnage est élevée, plus nous recréons avec précision les fréquences du signal d'origine. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le théorème de Nyquist-Shannon (Kotelnikov)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stipule (en termes simples) que la fréquence d'échantillonnage doit être deux fois la fréquence de signal la plus élevée que nous voulons enregistrer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'oreille humaine peut entendre approximativement dans la plage </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de 20 Hz à 20 kHz</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donc la fréquence d'échantillonnage de </font><strong><font style="vertical-align: inherit;">44,1 kHz est le</font></strong><font style="vertical-align: inherit;"> plus souvent utilisée pour recréer de la musique de haute qualité</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui est légèrement plus de deux fois la fréquence maximale que l'oreille humaine peut reconnaître. Cela garantit qu'un ensemble complet de fréquences d'instruments et de voix sera recréé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, chaque échantillon occupe de l'espace dans le fichier, nous ne pouvons donc pas sélectionner la fréquence d'échantillonnage maximale. Cependant, si vous n'échantillonnez pas assez rapidement, vous pouvez perdre des informations importantes. La fréquence d'échantillonnage sélectionnée doit dépendre des fréquences présentes dans le son recréé. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La lecture doit être effectuée à la même fréquence d'échantillonnage que la source, sinon le son et sa durée seront différents.</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que dix secondes de son soient enregistrées à une fréquence d'échantillonnage de 16 kHz. </font><font style="vertical-align: inherit;">Si vous le jouez avec une fréquence de 8 kHz, alors sa tonalité sera plus basse et la durée sera de vingt secondes. </font><font style="vertical-align: inherit;">Si vous le jouez avec une fréquence d'échantillonnage de 32 kHz, la tonalité audible sera plus élevée et le son lui-même durera cinq secondes. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette vidéo montre la différence de taux d'échantillonnage avec des exemples.</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peu profond</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fréquence d'échantillonnage n'est que la moitié de l'équation. Le son a également une </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">profondeur de bits</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , c'est-à-dire le nombre de bits par échantillon. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque l'ADC capture un échantillon d'un signal audio, il doit convertir cette valeur analogique en numérique, et la plage de valeurs capturées dépend du nombre de bits utilisés. 8 bits (256 valeurs), 16 bits (65 526 valeurs), 32 bits (4 294 967 296 valeurs), etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le nombre de bits par échantillon est lié à la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plage dynamique du</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son, c'est-à-dire avec les parties les plus bruyantes et les plus silencieuses. La profondeur de bits la plus courante pour la musique est de 16 bits. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendant la lecture, il est nécessaire de fournir la même profondeur de bits que la source, sinon le son et sa durée changeront.</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, vous avez un fichier audio avec quatre échantillons stockés sur 8 bits: [0x25, 0xAB, 0x34, 0x80]. </font><font style="vertical-align: inherit;">Si vous essayez de les lire comme s'ils étaient en 16 bits, vous n'obtiendrez que deux échantillons: [0x25AB, 0x3480]. </font><font style="vertical-align: inherit;">Cela entraînera non seulement des valeurs incorrectes d'échantillons sonores, mais divisera également de moitié le nombre d'échantillons, et donc la durée du son. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est également important de connaître le format des échantillons. </font><font style="vertical-align: inherit;">8 bits non signé, 8 bits non signé, 16 bits non signé, 16 bits non signé, etc. </font><font style="vertical-align: inherit;">Habituellement, 8 bits ne sont pas signés et 16 bits sont signés. </font><font style="vertical-align: inherit;">S'ils sont confus, le son sera considérablement déformé. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette vidéo montre la différence de profondeur de bits avec des exemples.</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fichiers WAV</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le plus souvent, les données audio brutes sur un ordinateur sont stockées au </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">format WAV</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui a un en-tête simple qui décrit le format audio (fréquence d'échantillonnage, profondeur de bits, taille, etc.), suivi des données audio elles-mêmes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le son n'est pas compressé du tout (contrairement aux formats comme MP3), nous pouvons donc facilement le lire sans avoir besoin d'une bibliothèque de codecs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le principal problème avec les fichiers WAV est qu'en raison du manque de compression, ils peuvent être assez volumineux. La taille du fichier est directement liée à la durée, la fréquence d'échantillonnage et la profondeur de bits. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taille = Durée (en secondes) x Taux d'échantillonnage (échantillons / s) x Profondeur de bits (bit / échantillon)</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fréquence d'échantillonnage affecte le plus la taille du fichier, donc le moyen le plus simple d'économiser de l'espace est de sélectionner une valeur suffisamment faible. </font><font style="vertical-align: inherit;">Nous allons créer un son old-school, donc une fréquence d'échantillonnage basse nous convient.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I2S</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'ESP32 possède des périphériques, grâce auxquels il est relativement simple de fournir une interface avec un équipement audio: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inter-IC Sound (I2S)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le protocole I2S est assez simple et se compose de seulement trois signaux: un signal d'horloge, un choix de canaux (gauche ou droite), ainsi que la ligne de données elle-même. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fréquence d'horloge dépend de la fréquence d'échantillonnage, de la profondeur de bits et du nombre de canaux. Les battements sont remplacés pour chaque bit de données.Par conséquent, pour une bonne reproduction du son, vous devez régler la fréquence d'horloge en conséquence. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fréquence d'horloge = Fréquence d'échantillonnage (échantillons / s) x Profondeur de bits (bits / échantillon) x Nombre de canaux</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le pilote du microcontrôleur I2S ESP32 a deux modes possibles: il peut soit émettre des données vers les contacts connectés à un récepteur I2S externe, qui peut décoder le protocole et transférer des données vers l'amplificateur, soit il peut transférer des données vers le DAC ESP32 interne émettant un signal analogique qui peut être transmis à amplificateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go n'a pas de décodeur I2S sur la carte, nous devrons donc utiliser le DAC ESP32 8 bits interne, c'est-à-dire que nous devons utiliser un son 8 bits. </font><font style="vertical-align: inherit;">L'appareil dispose de deux DAC, l'un connecté à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , l'autre à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La procédure ressemble à ceci:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous transférons les données audio vers le pilote I2S</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le pilote I2S envoie les données audio au DAC interne 8 bits</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le DAC interne émet un signal analogique</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le signal analogique est transmis à l'amplificateur sonore</font></font></li>
<li>      </li>
<li>  </li>
</ol><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/d93/a8e/2d9d93a8ed6eceb35846c0f31e336ec9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous regardons le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">circuit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> audio dans </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">le circuit Odroid Go</font></a><font style="vertical-align: inherit;"> , nous verrons deux broches GPIO ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) connectées aux entrées de l'amplificateur de son ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PAM8304A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'IO25 est</font></font></strong><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
également connecté au signal </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD de l'</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> amplificateur, c'est-à-dire au contact qui allume ou éteint l'amplificateur (un signal faible signifie un arrêt). Les sorties de l'amplificateur sont connectées à un haut-parleur ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N'oubliez pas que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont des sorties de DAC ESP32 8 bits, c'est-à-dire qu'un DAC est connecté à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et l'autre à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entrées différentielles de l'</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> amplificateur de son. Les entrées différentielles sont utilisées pour réduire le bruit provoqué par les </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interférences électromagnétiques</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tout bruit présent dans un signal sera également présent dans un autre. Un signal est soustrait d'un autre, ce qui élimine le bruit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous regardez les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spécifications de l’amplificateur de son</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , il dispose d’un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">circuit d’application typique</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est la manière recommandée par le fabricant d’utiliser l’amplificateur.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/044/d2a/323/044d2a323366c5ddb3c3b87f918bf5f9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il recommande de connecter </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> à la masse, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au signal d'entrée et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au signal marche / arrêt. S'il y a un bruit de 0,005 V, alors avec </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN- </font></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0V + 0,005V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sera lu </font><font style="vertical-align: inherit;">, et avec </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN + 0,005V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Les signaux d'entrée doivent être soustraits les uns des autres et obtenir la vraie valeur du signal ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sans bruit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, les concepteurs d'Odroid Go n'ont pas utilisé la configuration recommandée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois de plus en regardant le circuit Odroid Go, nous voyons que les concepteurs ont connecté la sortie DAC à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et que la même sortie DAC est connectée à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ DAKOTA DU SUD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Il s'agit d'un signal d'arrêt avec un niveau bas actif, donc pour que l'amplificateur fonctionne, vous devez définir un signal haut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela signifie que pour utiliser l'amplificateur, nous ne devons pas utiliser l' </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme DAC, mais comme sortie GPIO avec un signal toujours élevé. Cependant, dans ce cas, un signal haut est réglé sur </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui n'est pas recommandé par la spécification de l'amplificateur (il doit être mis à la terre). Ensuite, nous devons utiliser le DAC connecté à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , car notre sortie I2S doit être alimentée en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cela signifie que nous n'atteindrons pas la réduction de bruit nécessaire, car </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN- n'est</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas connecté à la terre. Un bruit doux émane constamment des haut-parleurs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous devons garantir la configuration correcte du pilote I2S, car nous voulons utiliser uniquement le DAC connecté à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si nous </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisions</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un DAC connecté à </font><strong><font style="vertical-align: inherit;">IO25</font></strong><font style="vertical-align: inherit;"> , il </font><strong><font style="vertical-align: inherit;">éteindrait</font></strong><font style="vertical-align: inherit;"> constamment le signal de l'amplificateur et le son serait terrible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus de cette bizarrerie, lors de l'utilisation d'un DAC interne 8 bits, le pilote I2S dans l'ESP32 nécessite la transmission d'échantillons 16 bits, mais envoie uniquement l'octet de poids fort au DAC 8 bits. </font><font style="vertical-align: inherit;">Par conséquent, nous devons prendre notre son 8 bits et le coller dans un tampon deux fois plus grand, tandis que le tampon sera à moitié vide. </font><font style="vertical-align: inherit;">Ensuite, nous le transmettons au pilote I2S et il transmet au DAC l'octet de poids fort de chaque échantillon. </font><font style="vertical-align: inherit;">Malheureusement, cela signifie que nous devons «payer» pour 16 bits, mais nous ne pouvons utiliser que 8 bits.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multitâche</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, le jeu ne peut pas fonctionner sur un seul cœur, comme je le voulais à l'origine, car il semble y avoir un bug dans le pilote I2S. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le pilote I2S doit utiliser DMA (comme le pilote SPI), c'est-à-dire que nous pourrions simplement lancer le transfert d'I2S, puis continuer notre travail pendant que le pilote I2S transmet des données audio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais à la place, le CPU est bloqué pendant la durée du son, ce qui est totalement inadapté au jeu. Imaginez que vous appuyez sur le bouton de saut, puis que l'image-objet du joueur interrompt son mouvement pendant 100 ms pendant la lecture du son de saut.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour résoudre ce problème, nous pouvons profiter du fait qu'il y a deux cœurs à bord de l'ESP32. </font><font style="vertical-align: inherit;">Nous pouvons créer une tâche (c'est-à-dire un fil) dans le deuxième noyau, qui traitera de la reproduction sonore. </font><font style="vertical-align: inherit;">Grâce à cela, nous pouvons transférer le pointeur vers le tampon sonore de la tâche principale du jeu à la tâche sonore, et la tâche sonore initie le transfert de I2S et est bloquée pendant la durée de la lecture du son. </font><font style="vertical-align: inherit;">Mais la tâche principale sur le premier noyau (avec traitement d'entrée et rendu) continuera de s'exécuter sans blocage.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sachant cela, nous pouvons lancer correctement le pilote I2S. </font><font style="vertical-align: inherit;">Pour ce faire, vous n'avez besoin que de quelques lignes de code, mais la difficulté est de savoir quels paramètres vous devez définir pour une bonne reproduction du son.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> AUDIO_AMP_SD_PIN = GPIO_NUM_25;<font></font>
<font></font>
<span class="hljs-keyword">static</span> QueueHandle_t gQueue;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlayTask</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span>
</span>{
	<span class="hljs-keyword">for</span>(;;)<font></font>
	{<font></font>
		QueueData data;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (xQueueReceive(gQueue, &amp;data, <span class="hljs-number">10</span>))<font></font>
		{<font></font>
			<span class="hljs-keyword">size_t</span> bytesWritten;<font></font>
			i2s_write(I2S_NUM_0, data.buffer, data.length, &amp;bytesWritten, portMAX_DELAY);<font></font>
			i2s_zero_dma_buffer(I2S_NUM_0);<font></font>
		}<font></font>
<font></font>
		vTaskDelay(<span class="hljs-number">1</span> / portTICK_PERIOD_MS);<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeAudio</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-comment">// Configure the amplifier shutdown signal</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; AUDIO_AMP_SD_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
<font></font>
		gpio_set_level(AUDIO_AMP_SD_PIN, <span class="hljs-number">1</span>);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure the I2S driver</span><font></font>
	{<font></font>
		<span class="hljs-keyword">i2s_config_t</span> i2sConfig= {};<font></font>
<font></font>
		i2sConfig.mode = I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_DAC_BUILT_IN;<font></font>
		i2sConfig.sample_rate = <span class="hljs-number">5012</span>;<font></font>
		i2sConfig.bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT;<font></font>
		i2sConfig.communication_format = I2S_COMM_FORMAT_I2S_MSB;<font></font>
		i2sConfig.channel_format = I2S_CHANNEL_FMT_ONLY_LEFT;<font></font>
		i2sConfig.dma_buf_count = <span class="hljs-number">8</span>;<font></font>
		i2sConfig.dma_buf_len = <span class="hljs-number">64</span>;<font></font>
<font></font>
		ESP_ERROR_CHECK(i2s_driver_install(I2S_NUM_0, &amp;i2sConfig, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>));<font></font>
		ESP_ERROR_CHECK(i2s_set_dac_mode(I2S_DAC_CHANNEL_LEFT_EN));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Create task for playing sounds so that our main task isn't blocked</span><font></font>
	{<font></font>
		gQueue = xQueueCreate(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(QueueData));<font></font>
		assert(gQueue);<font></font>
<font></font>
		BaseType_t result = xTaskCreatePinnedToCore(&amp;PlayTask, <span class="hljs-string">"I2S Task"</span>, <span class="hljs-number">1024</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>);<font></font>
		assert(result == pdPASS);<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, nous configurons l' </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (qui est connecté au signal de mise hors tension de l'amplificateur) en tant que sortie afin qu'il puisse contrôler l'amplificateur sonore, et lui appliquons un signal élevé pour allumer l'amplificateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous configurons et installons le pilote I2S lui-même. </font><font style="vertical-align: inherit;">Je vais analyser chaque partie de la configuration ligne par ligne, car chacune des lignes nécessite une explication:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mode</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous définissons le pilote comme un maître (contrôlant le bus), un émetteur (car nous transférons des données aux destinataires), et le configurons pour utiliser le DAC 8 bits intégré (car la carte Odroid Go n'a pas de DAC externe).</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">taux d'échantillonnage</font></font><ul>
<li>    5012,      ,   ,      .   ,      ,          .    -,           2500 .</li>
</ul></li>
<li>bits_per_sample<ul>
<li>  ,    ESP32  8-,   I2S ,      16    ,   8     .</li>
</ul></li>
<li>communication_format<ul>
<li>      ,   ,   -   ,   8-      16- .</li>
</ul></li>
<li>channel_format<ul>
<li> GPIO,    <strong>IN+</strong>   —  <strong>IO26</strong>,       «»   I2S.  ,  I2S      ,      <strong>IO25</strong>,      ,          .</li>
</ul></li>
<li>dma_buf_count  dma_buf_len<ul>
<li>  DMA-   ( )  ,        ,   ,        IDF.       ,     .</li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous créons une file d'attente - c'est ainsi que FreeRTOS envoie des données entre les tâches. Nous mettons les données dans la file d'attente d'une tâche et les extrayons de la file d'attente d'une autre tâche. Créez une structure appelée </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui combine le pointeur vers le tampon audio et la longueur du tampon en une seule structure qui peut être mise en file d'attente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, créez une tâche qui s'exécute sur le deuxième cœur. Nous le connectons à la fonction </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayTask</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui effectue la lecture du son. La tâche elle-même est une boucle sans fin qui vérifie constamment s'il y a des données dans la file d'attente. S'ils le sont, elle les envoie au pilote I2S afin qu'ils puissent être lus. Il bloquera l'appel </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i2s_write</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et cela nous convient, car la tâche est effectuée sur un noyau distinct du thread principal du jeu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un appel à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i2s_zero_dma_buffer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est requis pour que, une fois la lecture terminée, il ne reste plus aucun son des haut-parleurs. </font><font style="vertical-align: inherit;">Je ne sais pas s'il s'agit d'un bogue du pilote I2S ou du comportement attendu, mais sans cela, une fois la mémoire tampon de son terminée, le haut-parleur émet un signal parasite.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jouer son</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_PlayAudio</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span>* buffer, <span class="hljs-keyword">size_t</span> length)</span>
</span>{<font></font>
	QueueData data = {};<font></font>
<font></font>
	data.buffer = buffer;<font></font>
	data.length = length;<font></font>
<font></font>
	xQueueSendToBack(gQueue, &amp;data, portMAX_DELAY);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que la configuration complète est déjà terminée, l'appel à la fonction de lecture du tampon audio lui-même est extrêmement simple, car le travail principal est effectué dans une autre tâche. </font><font style="vertical-align: inherit;">Nous plaçons le pointeur sur le tampon et la longueur du tampon dans la structure </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , puis le mettons dans la file d'attente utilisée par la fonction </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayTask</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En raison de ce schéma de fonctionnement, un tampon audio doit terminer la lecture avant de pouvoir démarrer le second tampon. </font><font style="vertical-align: inherit;">Par conséquent, si un saut et une prise de vue se produisent simultanément, le premier son sera joué avant le second, et non simultanément avec lui. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Très probablement, à l'avenir, je mélangerai différents sons de trame dans le tampon sonore qui est transmis au pilote I2S. </font><font style="vertical-align: inherit;">Cela vous permettra de jouer plusieurs sons en même temps.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Démo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous générerons nos propres effets sonores à l'aide de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsfxr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , un outil spécialement conçu pour générer le type de sons de jeu dont nous avons besoin. </font><font style="vertical-align: inherit;">Nous pouvons directement définir la fréquence d'échantillonnage et la profondeur de bits, puis générer le fichier WAV. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai créé un simple effet sonore de saut qui ressemble au son du saut de Mario. </font><font style="vertical-align: inherit;">Il a une fréquence d'échantillonnage de 5012 (comme nous l'avons configuré lors de l'initialisation) et une profondeur de bits de 8 (car le DAC est de 8 bits).</font></font><br>
<br>
<div class="oembed"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://austinmorlan.com/posts/embedded_game_programming_6/media/jump.wav</font></font></a></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lieu d'analyser le fichier WAV directement dans le code, nous ferons quelque chose de similaire à ce que nous avons fait pour charger le sprite dans la démo de la partie 4: nous supprimerons l'en-tête WAV du fichier en utilisant l'éditeur hexadécimal. Grâce à cela, le fichier lu sur la carte SD ne sera que des données brutes. De plus, nous ne lirons pas la durée du son, nous l'écrirons dans le code. À l'avenir, nous chargerons les ressources sonores différemment, mais cela suffit pour la démo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fichier brut peut être téléchargé à </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partir d'ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Load sound effect</span>
<span class="hljs-keyword">uint16_t</span>* soundBuffer;
<span class="hljs-keyword">int</span> soundEffectLength = <span class="hljs-number">1441</span>;<font></font>
{<font></font>
	FILE* soundFile = fopen(<span class="hljs-string">"/sdcard/jump"</span>, <span class="hljs-string">"r"</span>);<font></font>
	assert(soundFile);<font></font>
<font></font>
	<span class="hljs-keyword">uint8_t</span>* soundEffect = <span class="hljs-built_in">malloc</span>(soundEffectLength);<font></font>
	assert(soundEffect);<font></font>
<font></font>
	soundBuffer = <span class="hljs-built_in">malloc</span>(soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	assert(soundBuffer);<font></font>
<font></font>
	fread(soundEffect, soundEffectLength, <span class="hljs-number">1</span>, soundFile);<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; soundEffectLength; ++i)<font></font>
    {<font></font>
        <span class="hljs-comment">// 16 bits required but only MSB is actually sent to the DAC</span>
        soundBuffer[i] = (soundEffect[i] &lt;&lt; <span class="hljs-number">8u</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous chargeons les données 8 bits </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tampon </font><strong><font style="vertical-align: inherit;">soundEffect</font></strong><font style="vertical-align: inherit;"> 8 bits </font><font style="vertical-align: inherit;">, puis copions ces données dans le tampon </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soundBuffer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16 bits </font><font style="vertical-align: inherit;">, où les données seront stockées dans les huit bits de poids fort. </font><font style="vertical-align: inherit;">Je le répète - cela est nécessaire en raison des caractéristiques de la mise en œuvre de Tsahal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir créé un tampon 16 bits, nous pouvons jouer le son d'un clic sur un bouton. </font><font style="vertical-align: inherit;">Il serait logique d'utiliser le bouton de volume pour cela.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> lastState = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (;;)<font></font>
{<font></font>
	[...]<font></font>
<font></font>
	<span class="hljs-keyword">int</span> thisState = input.volume;<font></font>
<font></font>
	<span class="hljs-keyword">if</span> ((thisState == <span class="hljs-number">1</span>) &amp;&amp; (thisState != lastState))<font></font>
	{<font></font>
		Odroid_PlayAudio(soundBuffer, soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	}<font></font>
<font></font>
	lastState = thisState;<font></font>
<font></font>
	[...]<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous surveillons l'état du bouton afin que, accidentellement, en un seul clic, vous </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'appeliez</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas accidentellement </font><strong><font style="vertical-align: inherit;">Odroid_PlayAudio</font></strong><font style="vertical-align: inherit;"> plusieurs fois.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Votre navigateur ne prend pas en charge la vidéo HTML5.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_6/media/demo.mp4" type="video/mp4"></video></div></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La source</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout le code source est </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Références</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schéma Odroid Go</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fiche technique de l'amplificateur audio</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation ESP-IDF: DAC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation ESP-IDF: I2S</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Format de fichier WAVE</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vidéo: Explication de la profondeur de bits</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vidéo: Explication du taux d'échantillonnage</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr503854/index.html">Utilisez SIL au maximum</a></li>
<li><a href="../fr503858/index.html">Le livre "Terraform: infrastructure au niveau du code"</a></li>
<li><a href="../fr503860/index.html">Configuration de l'environnement du réseau de neurones Mask R-CNN</a></li>
<li><a href="../fr503864/index.html">Organisation des saveurs chez Flutter</a></li>
<li><a href="../fr503866/index.html">Publication du développement de la feuille de route Zextras Suite pour 2020</a></li>
<li><a href="../fr503880/index.html">Comment j'ai appris à ne pas m'inquiéter et à aimer la vision industrielle</a></li>
<li><a href="../fr503884/index.html">Comment apprendre à travailler de manière asynchrone</a></li>
<li><a href="../fr503888/index.html">Algorithme AdaBoost</a></li>
<li><a href="../fr503890/index.html">L'histoire de la façon dont j'ai configuré Azure AD B2C sur React et React Native Partie 1 (Tutoriel)</a></li>
<li><a href="../fr503892/index.html">Mitap: Quarantaine, partez</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>