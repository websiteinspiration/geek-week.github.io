<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÑ üóØÔ∏è üîî Programmation d'un jeu pour un appareil embarqu√© sur ESP32: lecteur, batterie, son üñïüèæ üö£üèº üèáüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="D√©but: syst√®me d'assemblage, saisie, affichage .
 
 Partie 4: conduire
 Odroid Go dispose d'un emplacement pour carte microSD, qui sera utile pour t√©l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programmation d'un jeu pour un appareil embarqu√© sur ESP32: lecteur, batterie, son</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503876/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/800/42e/44b80042e94aa2f2da9da2d2296461ad.jpg" alt="image"></div><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©but: syst√®me d'assemblage, saisie, affichage</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 4: conduire</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go dispose d'un emplacement pour carte microSD, qui sera utile pour t√©l√©charger des ressources (sprites, fichiers audio, polices), et peut-√™tre m√™me pour sauvegarder l'√©tat du jeu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le lecteur de carte est connect√© via SPI, mais IDF facilite l'interaction avec la carte SD en extrayant les appels SPI et en utilisant </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonctions </font><strong><font style="vertical-align: inherit;">POSIX</font></strong><font style="vertical-align: inherit;"> standard </font><font style="vertical-align: inherit;">comme </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fopen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fread</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fwrite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tout cela est bas√© sur la biblioth√®que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FatFs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donc la carte SD doit √™tre format√©e au format FAT standard.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est connect√© au m√™me bus SPI que l'√©cran LCD, mais utilise une ligne de s√©lection de puce diff√©rente. </font><font style="vertical-align: inherit;">Lorsque nous devons lire ou √©crire sur la carte SD (et cela ne se produit pas tr√®s souvent), le pilote SPI commutera le signal CS de l'√©cran vers le lecteur de carte SD, puis effectuera l'op√©ration. </font><font style="vertical-align: inherit;">Cela signifie que lors de l'envoi de donn√©es √† l'√©cran, nous ne pouvons effectuer aucune op√©ration avec la carte SD, et vice versa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour le moment, nous faisons tout dans un seul thread et utilisons la transmission de blocage via SPI √† l'√©cran, donc il ne peut y avoir de transactions simultan√©es avec la carte SD et l'√©cran LCD. </font><font style="vertical-align: inherit;">Dans tous les cas, il y a une forte probabilit√© que nous chargeons toutes les ressources au moment du lancement.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modification de ESP-IDF</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous essayons d'initialiser l'interface de la carte SD apr√®s l'initialisation de l'affichage, nous rencontrerons un probl√®me qui rend impossible le chargement d'Odroid Go. </font><font style="vertical-align: inherit;">ESP-IDF v4.0 ne prend pas en charge l'acc√®s partag√© au bus SPI lorsqu'il est utilis√© avec une carte SD. </font><font style="vertical-align: inherit;">R√©cemment, les d√©veloppeurs ont ajout√© cette fonctionnalit√©, mais elle n'est pas encore dans une version stable, nous allons donc apporter nous-m√™mes une petite modification √† l'IDF. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commentez la ligne 303 </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp-idf / components / driver / sdspi_host.c</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Initialize SPI bus</span>
<span class="hljs-keyword">esp_err_t</span> ret = spi_bus_initialize((<span class="hljs-keyword">spi_host_device_t</span>)slot, &amp;buscfg,<font></font>
    slot_config-&gt;dma_channel);<font></font>
<span class="hljs-keyword">if</span> (ret != ESP_OK) {<font></font>
    ESP_LOGD(TAG, <span class="hljs-string">"spi_bus_initialize failed with rc=0x%x"</span>, ret);
    <span class="hljs-comment">//return ret;</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s avoir effectu√© cette modification, nous verrons toujours une erreur lors de l'initialisation, mais cela ne provoquera plus le red√©marrage de l'ESP32, car le code d'erreur ne se propage pas ci-dessus.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisation</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57f/4f8/b0f/57f4f8b0fcca66e243637eeb68b39ff7.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/554/eae/9ec/554eae9ec4a3e850eb44e817e8b7b181.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous devons indiquer √† IDF quelles broches ESP32 sont connect√©es au lecteur MicroSD afin qu'il configure correctement le pilote SPI sous-jacent, qui communique r√©ellement avec le lecteur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les notes g√©n√©rales </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VSPI.XXXX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont √† nouveau utilis√©es dans le </font><strong><font style="vertical-align: inherit;">diagramme</font></strong><font style="vertical-align: inherit;"> , mais nous pouvons les parcourir jusqu'aux num√©ros de contact r√©els sur ESP32. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'initialisation est similaire √† l'initialisation LCD, mais au lieu de la structure de configuration g√©n√©rale SPI, nous utilisons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdspi_slot_config_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est destin√© √† une carte SD connect√©e via le bus SPI. Nous configurons les num√©ros de contact et les propri√©t√©s de montage de carte correspondants dans le syst√®me FatFS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La documentation IDF ne recommande pas d'utiliser la fonction </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_vfs_fat_sdmmc_mount</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le code du programme termin√©. Il s'agit d'une fonction wrapper qui effectue de nombreuses op√©rations pour nous, mais jusqu'√† pr√©sent, elle fonctionne assez normalement, et probablement rien ne changera √† l'avenir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le param√®tre </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"/ sdcard"</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><font style="vertical-align: inherit;">cette fonction d√©finit le point de montage virtuel de la carte SD, que nous utiliserons ensuite comme pr√©fixe lors de l'utilisation de fichiers. Si nous avions un fichier nomm√© "test.txt" sur notre carte SD, le chemin que nous utiliserions pour le lier serait "/sdcard/test.txt". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s l'initialisation de l'interface de la carte SD, l'interaction avec les fichiers est triviale: on peut simplement utiliser des appels standard aux fonctions </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POSIX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui est tr√®s pratique.</font></font><br>
<br>
<blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">   8.3</a>,              .    ,   <b>fopen</b>   .        <b>make menuconfig</b>,       ,     <b>8.3</b>.</blockquote><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d94/62f/94a/d9462f94aeec7fbdce989e34967e637d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai cr√©√© </font><font style="vertical-align: inherit;">un sprite 64x64 </font><font style="vertical-align: inherit;">en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aseprite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (terrible) qui utilise seulement deux couleurs: compl√®tement noir (pixel d√©sactiv√©) et compl√®tement blanc (pixel activ√©). Aseprite n'a pas la possibilit√© d'enregistrer la couleur RGB565 ou d'exporter en tant que bitmap brut (c'est-√†-dire sans compression et en-t√™tes d'image), j'ai donc export√© l'image-objet au format PNG temporaire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, en utilisant </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ImageMagick, j'ai</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> converti les donn√©es en un fichier PPM, qui a transform√© l'image en donn√©es brutes non compress√©es avec un simple en-t√™te. Ensuite, j'ai ouvert l'image dans un √©diteur hexad√©cimal, supprim√© l'en-t√™te et converti la couleur 24 bits en 16 bits, supprimant toutes les occurrences </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x000000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et toutes les occurrences </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">L'ordre des octets ici n'est pas un probl√®me, car </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne changent pas lors du changement de l'ordre des octets. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fichier brut peut √™tre t√©l√©charg√© √† </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partir d'ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">FILE* spriteFile = fopen(<span class="hljs-string">"/sdcard/key"</span>, <span class="hljs-string">"r"</span>);<font></font>
assert(spriteFile);<font></font>
<font></font>
<span class="hljs-keyword">uint16_t</span>* sprite = (<span class="hljs-keyword">uint16_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">64</span> * <span class="hljs-number">64</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>));<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i)<font></font>
{<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; ++j)<font></font>
	{<font></font>
		fread(sprite, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>), <span class="hljs-number">64</span> * <span class="hljs-number">64</span>, spriteFile);<font></font>
	}<font></font>
}<font></font>
<font></font>
fclose(spriteFile);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, nous ouvrons le fichier de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cl√©</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contenant des octets bruts et le lisons dans le tampon. </font><font style="vertical-align: inherit;">√Ä l'avenir, nous chargerons les ressources de sprite diff√©remment, mais pour une d√©mo, cela suffit.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> spriteRow = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = y; row &lt; y + <span class="hljs-number">64</span>; ++row)<font></font>
{<font></font>
	spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = x; col &lt; x + <span class="hljs-number">64</span>; ++col)<font></font>
	{<font></font>
		<span class="hljs-keyword">uint16_t</span> pixelColor = sprite[<span class="hljs-number">64</span> * spriteRow + spriteCol];<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pixelColor != <span class="hljs-number">0</span>)<font></font>
		{<font></font>
			gFramebuffer[row * LCD_WIDTH + col] = color;<font></font>
		}<font></font>
<font></font>
		++spriteCol;<font></font>
	}<font></font>
<font></font>
	++spriteRow;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour dessiner un sprite, nous parcourons it√©rativement son contenu. </font><font style="vertical-align: inherit;">Si le pixel est blanc, nous le dessinons dans la couleur s√©lectionn√©e par les boutons. </font><font style="vertical-align: inherit;">S'il est noir, nous le consid√©rons comme un fond et ne dessinons pas.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Votre navigateur ne prend pas en charge la vid√©o HTML5.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_4/media/sprite_drawing.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'appareil photo de mon t√©l√©phone d√©forme consid√©rablement les couleurs. </font><font style="vertical-align: inherit;">Et d√©sol√© de l'avoir secou√©e. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour tester l'enregistrement de l'image, nous allons d√©placer la cl√© √† un certain endroit sur l'√©cran, changer sa couleur, puis √©crire le tampon d'image sur la carte SD afin qu'elle puisse √™tre visualis√©e sur l'ordinateur.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span> (input.menu)<font></font>
{<font></font>
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* snapFilename = <span class="hljs-string">"/sdcard/framebuf"</span>;<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Writing snapshot to %s"</span>, snapFilename);<font></font>
<font></font>
	FILE* snapFile = fopen(snapFilename, <span class="hljs-string">"wb"</span>);<font></font>
	assert(snapFile);<font></font>
<font></font>
		fwrite(gFramebuffer, <span class="hljs-keyword">sizeof</span>(gFramebuffer[<span class="hljs-number">0</span>]), LCD_WIDTH * LCD_HEIGHT, snapFile);<font></font>
	}<font></font>
<font></font>
	fclose(snapFile);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Appuyez sur la touche Menu pour enregistrer le contenu du tampon d'image dans un fichier appel√© </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">framebuf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ce sera un tampon d'image brut, donc les pixels resteront toujours au format RGB565 avec l'ordre des octets invers√©. </font><font style="vertical-align: inherit;">Nous pouvons √† nouveau utiliser ImageMagick pour convertir ce format en PNG pour le visualiser sur un ordinateur.</font></font><br>
<br>
<pre><code class="cpp hljs">convert -depth <span class="hljs-number">16</span> -size <span class="hljs-number">320</span>x240+<span class="hljs-number">0</span> -endian msb rgb565:FRAMEBUF snap.png</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien s√ªr, nous pouvons impl√©menter la lecture / √©criture au format BMP / PNG et nous d√©barrasser de tout ce tracas avec ImageMagick, mais ce n'est qu'un code de d√©monstration. </font><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, je n'ai pas d√©cid√© quel format de fichier je veux utiliser pour stocker les sprites.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0bd/09c/e66/0bd09ce669a61276676a87b01c15e6f2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est la! </font><font style="vertical-align: inherit;">Le tampon de trame Odroid Go s'affiche sur l'ordinateur de bureau.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©f√©rences</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sch√©ma Odroid Go</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation ESP-IDF: SDMMC</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 5: batterie</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go poss√®de une batterie lithium-ion, nous pouvons donc cr√©er un jeu auquel vous pouvez jouer en d√©placement. </font><font style="vertical-align: inherit;">C'est une id√©e tentante pour quelqu'un qui a jou√© le premier Gameboy enfant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par cons√©quent, nous avons besoin d'un moyen de demander le niveau de batterie de l'Odroid Go. </font><font style="vertical-align: inherit;">La batterie est connect√©e au contact de l'ESP32, nous pouvons donc lire la tension pour avoir une id√©e approximative du temps de fonctionnement restant.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sch√®me</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f2/ceb/13b/1f2ceb13bf408d8773f22047464e4e66.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le diagramme montre </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> connect√© √† la </font><font style="vertical-align: inherit;">tension </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBAT</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> apr√®s avoir √©t√© tir√© √† la terre par une r√©sistance. Deux r√©sistances ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R21</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R23</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) forment un diviseur de tension similaire √† celui utilis√© sur la croix du gamepad; les r√©sistances ont √† nouveau la m√™me r√©sistance de sorte que la tension est la moiti√© de l'original. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En raison du diviseur de tension, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lira une tension √©gale √† la moiti√© de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBAT</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cela est probablement d√ª au fait que les contacts ADC de l'ESP32 ne peuvent pas lire la haute tension de la batterie lithium-ion (4,2 V √† la charge maximale). Quoi qu'il en soit, cela signifie que pour obtenir la vraie tension, vous devez doubler la tension lue √† partir de l'ADC (ADC).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la lecture de la valeur de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous obtenons une valeur num√©rique, mais perdons la valeur analogique qu'elle repr√©sente. Nous avons besoin d'un moyen d'interpr√©ter une valeur num√©rique avec un ADC sous la forme d'une tension analogique physique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDF vous permet de calibrer l'ADC, qui essaie de donner un niveau de tension bas√© sur la tension de r√©f√©rence. Cette tension de r√©f√©rence ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vref</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) est de 1100 mV par d√©faut, mais en raison des caract√©ristiques physiques, chaque appareil est l√©g√®rement diff√©rent. ESP32 dans Odroid Go a un Vref d√©fini manuellement, ¬´flash√©¬ª dans eFuse, que nous pouvons utiliser comme un Vref plus pr√©cis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La proc√©dure sera la suivante: d'abord, nous allons configurer l'√©talonnage ADC, et lorsque nous voulons lire la tension, nous prendrons un certain nombre d'√©chantillons (par exemple, 20) pour calculer les lectures moyennes; nous utilisons ensuite l'IDF pour convertir ces lectures en tension. Le calcul de la moyenne √©limine le bruit et donne des lectures plus pr√©cises. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, il n'y a pas de connexion lin√©aire entre la tension et la charge de la batterie. Lorsque la charge diminue, la tension baisse, lorsqu'elle augmente, elle augmente, mais de mani√®re impr√©visible. Tout ce que l'on peut dire: si la tension est inf√©rieure √† 3,6 V environ, la batterie est d√©charg√©e, mais il est √©tonnamment difficile de convertir avec pr√©cision le niveau de tension en pourcentage de la charge de la batterie.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour notre projet, ce n'est pas particuli√®rement important. </font><font style="vertical-align: inherit;">Nous pouvons impl√©menter une approximation approximative pour informer le joueur de la n√©cessit√© de charger rapidement l'appareil, mais nous n'en souffrirons pas, en essayant d'obtenir le pourcentage exact.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LED d'√©tat</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/0ad/2d6/b520ad2d63e2a4c59924debb6c3613bc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur le panneau avant sous l'√©cran Odroid Go, il y a une LED bleue (LED), que nous pouvons utiliser √† n'importe quelle fin. Vous pouvez leur montrer que l'appareil est allum√© et fonctionne, mais dans ce cas, lorsque vous jouez dans l'obscurit√©, une LED bleu vif brillera sur votre visage. Par cons√©quent, nous l'utiliserons pour indiquer une faible charge de la batterie (bien que je pr√©f√®re une couleur rouge ou ambre pour cela). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour utiliser la LED, vous devez d√©finir </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme sortie, puis lui appliquer un signal haut ou bas pour allumer et √©teindre la LED. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je pense qu'une </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©sistance de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2 kŒ© ( </font><strong><font style="vertical-align: inherit;">r√©sistance de limitation de courant</font></strong><font style="vertical-align: inherit;"> ) sera suffisante pour que nous ne br√ªlions pas la LED et fournissions trop de courant √† partir de la broche GPIO.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La LED a une r√©sistance assez faible, donc si 3,3 V lui est appliqu√©, alors nous la br√ªlerons en changeant le courant. </font><font style="vertical-align: inherit;">Pour se prot√©ger contre cela, une r√©sistance est g√©n√©ralement connect√©e en s√©rie avec la LED. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, les r√©sistances de limitation de courant pour les LED sont g√©n√©ralement bien inf√©rieures √† 2 kŒ©, donc je ne comprends pas pourquoi la r√©sistance </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R7</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une telle r√©sistance.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisation</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">adc1_channel_t</span> BATTERY_READ_PIN = ADC1_GPIO36_CHANNEL;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BATTERY_LED_PIN = GPIO_NUM_2;<font></font>
<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">esp_adc_cal_characteristics_t</span> gCharacteristics;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeBatteryReader</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-comment">// Configure LED</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; BATTERY_LED_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure ADC</span><font></font>
	{<font></font>
		adc1_config_width(ADC_WIDTH_BIT_12);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
<font></font>
    	<span class="hljs-keyword">esp_adc_cal_value_t</span> type = esp_adc_cal_characterize(<font></font>
    		ADC_UNIT_1, ADC_ATTEN_DB_11, ADC_WIDTH_BIT_12, <span class="hljs-number">1100</span>, &amp;gCharacteristics);<font></font>
<font></font>
    	assert(type == ESP_ADC_CAL_VAL_EFUSE_VREF);<font></font>
    }<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Battery reader initialized"</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'abord, nous d√©finissons la LED GPIO comme sortie afin de pouvoir la commuter si n√©cessaire. </font><font style="vertical-align: inherit;">Ensuite, nous configurons la broche ADC, comme nous l'avons fait dans le cas d'une croix - avec une largeur de bit de 12 et une att√©nuation minimale. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_characterize</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> effectue des calculs pour nous de caract√©riser l'ADC afin que nous puissions plus tard convertir les lectures num√©riques en stress physique.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lecture de la batterie</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">Odroid_ReadBatteryLevel</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SAMPLE_COUNT = <span class="hljs-number">20</span>;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> raw = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sampleIndex = <span class="hljs-number">0</span>; sampleIndex &lt; SAMPLE_COUNT; ++sampleIndex)<font></font>
	{<font></font>
		raw += adc1_get_raw(BATTERY_READ_PIN);<font></font>
	}<font></font>
<font></font>
	raw /= SAMPLE_COUNT;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> voltage = <span class="hljs-number">2</span> * esp_adc_cal_raw_to_voltage(raw, &amp;gCharacteristics);<font></font>
<font></font>
	<span class="hljs-keyword">return</span> voltage;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous prenons vingt √©chantillons bruts de l'ADC au contact de l'ADC, puis les divisons pour obtenir la valeur moyenne. Comme mentionn√© ci-dessus, cela contribue √† r√©duire le bruit des lectures. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous utilisons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_raw_to_voltage</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour convertir la valeur brute en tension r√©elle. En raison du diviseur de tension mentionn√© ci-dessus, nous doublons la valeur de retour: la valeur lue sera la moiti√© de la tension r√©elle de la batterie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lieu de trouver des moyens d√©licats de convertir cette tension en un pourcentage de la charge de la batterie, nous retournerons une tension simple. Laissez la fonction appelante d√©cider d'elle-m√™me ce qu'elle doit faire de la tension - que ce soit pour la transformer en pourcentage de la charge, ou simplement l'interpr√©ter comme une valeur √©lev√©e ou faible.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La valeur est renvoy√©e en millivolts, la fonction appelante doit donc effectuer la conversion appropri√©e. </font><font style="vertical-align: inherit;">Cela emp√™che le d√©bordement du flotteur.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©glage LED</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_EnableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">1</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_DisableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">0</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces deux fonctions simples suffisent pour utiliser la LED. </font><font style="vertical-align: inherit;">Nous pouvons soit allumer ou √©teindre la lumi√®re. </font><font style="vertical-align: inherit;">Laissez la fonction appelante d√©cider quand le faire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pourrions cr√©er une t√¢che qui surveillerait p√©riodiquement la tension de la batterie et changerait en cons√©quence l'√©tat de la LED, mais je ferais mieux d'interroger la tension de la batterie dans notre cycle principal, puis de d√©cider comment r√©gler la tension de la batterie √† partir de l√†.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©mo</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint32_t</span> batteryLevel = Odroid_ReadBatteryLevel();<font></font>
<font></font>
<span class="hljs-keyword">if</span> (batteryLevel &lt; <span class="hljs-number">3600</span>)<font></font>
{<font></font>
	Odroid_EnableBatteryLight();<font></font>
}<font></font>
<span class="hljs-keyword">else</span><font></font>
{<font></font>
	Odroid_DisableBatteryLight();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons simplement demander le niveau de la batterie dans le cycle principal, et si la tension est inf√©rieure √† la valeur seuil, allumez la LED, indiquant le besoin de charge. </font><font style="vertical-align: inherit;">Sur la base des mat√©riaux √©tudi√©s, je peux dire que 3600 mV (3,6 V) est un bon signe d'une faible charge des batteries lithium-ion, mais les batteries elles-m√™mes sont complexes.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©f√©rences</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sch√©ma Odroid Go</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation ESP-IDF: ADC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caract√©ristiques de la batterie</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 6: son</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La derni√®re √©tape pour obtenir une interface compl√®te avec tout le mat√©riel Odroid Go est d'√©crire une couche sonore. Ayant fini avec cela, nous pouvons commencer √† √©voluer vers une programmation plus g√©n√©rale du jeu, moins li√©e √† la programmation pour Odroid. Toutes les interactions avec les p√©riph√©riques seront effectu√©es via les fonctions </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En raison de mon manque d'exp√©rience en programmation sonore et du manque de bonne documentation de la part d'IDF, lorsque je travaillais sur un projet, la mise en ≈ìuvre du son prenait le plus de temps. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fin de compte, il ne fallait pas tellement de code pour jouer le son. La plupart du temps a √©t√© consacr√© √† la conversion des donn√©es audio en ESP32 souhait√© et √† la configuration du pilote audio ESP32 pour correspondre √† la configuration mat√©rielle.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bases du son num√©rique</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le son num√©rique se compose de deux parties: l' </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enregistrement</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lecture</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Record</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour enregistrer du son sur un ordinateur, nous devons d'abord le convertir de l'espace d'un signal continu (analogique) en l'espace d'un signal discret (num√©rique). </font><font style="vertical-align: inherit;">Cette t√¢che est accomplie √† l'aide d'un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convertisseur analogique-num√©rique (ADC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (dont nous avons parl√© lorsque nous avons travaill√© avec la croix dans la partie 2). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'ADC re√ßoit un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©chantillon de l'</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> onde entrante et num√©rise la valeur, qui peut ensuite √™tre enregistr√©e dans un fichier.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jouer</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un fichier audio num√©rique peut √™tre renvoy√© de l'espace num√©rique √† l'espace analogique √† l'aide d'un convertisseur </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">num√©rique-analogique (DAC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">DAC ne peut reproduire des valeurs que dans une certaine plage. </font><font style="vertical-align: inherit;">Par exemple, un DAC 8 bits avec une source de 3,3 V peut produire des tensions analogiques dans la plage de 0 √† 3,3 mV par pas de 12,9 mV (3,3 V divis√© par 256). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le DAC prend des valeurs num√©riques et les reconvertit en tension, qui peut √™tre transmise √† un amplificateur, un haut-parleur ou tout autre appareil capable de recevoir un signal audio analogique.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taux d'√©chantillonnage</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de l'enregistrement d'un son analogique via l'ADC, des √©chantillons sont pr√©lev√©s √† une certaine fr√©quence et chaque √©chantillon est un ¬´instantan√©¬ª du signal sonore √† un moment donn√©. Ce param√®tre est appel√© </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la fr√©quence d'√©chantillonnage</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et est mesur√© en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hertz</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus la fr√©quence d'√©chantillonnage est √©lev√©e, plus nous recr√©ons avec pr√©cision les fr√©quences du signal d'origine. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le th√©or√®me de Nyquist-Shannon (Kotelnikov)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stipule (en termes simples) que la fr√©quence d'√©chantillonnage doit √™tre deux fois la fr√©quence de signal la plus √©lev√©e que nous voulons enregistrer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'oreille humaine peut entendre approximativement dans la plage </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de 20 Hz √† 20 kHz</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donc la fr√©quence d'√©chantillonnage de </font><strong><font style="vertical-align: inherit;">44,1 kHz est le</font></strong><font style="vertical-align: inherit;"> plus souvent utilis√©e pour recr√©er de la musique de haute qualit√©</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui est l√©g√®rement plus de deux fois la fr√©quence maximale que l'oreille humaine peut reconna√Ætre. Cela garantit qu'un ensemble complet de fr√©quences d'instruments et de voix sera recr√©√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, chaque √©chantillon occupe de l'espace dans le fichier, nous ne pouvons donc pas s√©lectionner la fr√©quence d'√©chantillonnage maximale. Cependant, si vous n'√©chantillonnez pas assez rapidement, vous pouvez perdre des informations importantes. La fr√©quence d'√©chantillonnage s√©lectionn√©e doit d√©pendre des fr√©quences pr√©sentes dans le son recr√©√©. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La lecture doit √™tre effectu√©e √† la m√™me fr√©quence d'√©chantillonnage que la source, sinon le son et sa dur√©e seront diff√©rents.</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que dix secondes de son soient enregistr√©es √† une fr√©quence d'√©chantillonnage de 16 kHz. </font><font style="vertical-align: inherit;">Si vous le jouez avec une fr√©quence de 8 kHz, alors sa tonalit√© sera plus basse et la dur√©e sera de vingt secondes. </font><font style="vertical-align: inherit;">Si vous le jouez avec une fr√©quence d'√©chantillonnage de 32 kHz, la tonalit√© audible sera plus √©lev√©e et le son lui-m√™me durera cinq secondes. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette vid√©o montre la diff√©rence de taux d'√©chantillonnage avec des exemples.</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peu profond</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fr√©quence d'√©chantillonnage n'est que la moiti√© de l'√©quation. Le son a √©galement une </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">profondeur de bits</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , c'est-√†-dire le nombre de bits par √©chantillon. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque l'ADC capture un √©chantillon d'un signal audio, il doit convertir cette valeur analogique en num√©rique, et la plage de valeurs captur√©es d√©pend du nombre de bits utilis√©s. 8 bits (256 valeurs), 16 bits (65 526 valeurs), 32 bits (4 294 967 296 valeurs), etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le nombre de bits par √©chantillon est li√© √† la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plage dynamique du</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son, c'est-√†-dire avec les parties les plus bruyantes et les plus silencieuses. La profondeur de bits la plus courante pour la musique est de 16 bits. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendant la lecture, il est n√©cessaire de fournir la m√™me profondeur de bits que la source, sinon le son et sa dur√©e changeront.</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, vous avez un fichier audio avec quatre √©chantillons stock√©s sur 8 bits: [0x25, 0xAB, 0x34, 0x80]. </font><font style="vertical-align: inherit;">Si vous essayez de les lire comme s'ils √©taient en 16 bits, vous n'obtiendrez que deux √©chantillons: [0x25AB, 0x3480]. </font><font style="vertical-align: inherit;">Cela entra√Ænera non seulement des valeurs incorrectes d'√©chantillons sonores, mais divisera √©galement de moiti√© le nombre d'√©chantillons, et donc la dur√©e du son. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est √©galement important de conna√Ætre le format des √©chantillons. </font><font style="vertical-align: inherit;">8 bits non sign√©, 8 bits non sign√©, 16 bits non sign√©, 16 bits non sign√©, etc. </font><font style="vertical-align: inherit;">Habituellement, 8 bits ne sont pas sign√©s et 16 bits sont sign√©s. </font><font style="vertical-align: inherit;">S'ils sont confus, le son sera consid√©rablement d√©form√©. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette vid√©o montre la diff√©rence de profondeur de bits avec des exemples.</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fichiers WAV</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le plus souvent, les donn√©es audio brutes sur un ordinateur sont stock√©es au </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">format WAV</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui a un en-t√™te simple qui d√©crit le format audio (fr√©quence d'√©chantillonnage, profondeur de bits, taille, etc.), suivi des donn√©es audio elles-m√™mes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le son n'est pas compress√© du tout (contrairement aux formats comme MP3), nous pouvons donc facilement le lire sans avoir besoin d'une biblioth√®que de codecs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le principal probl√®me avec les fichiers WAV est qu'en raison du manque de compression, ils peuvent √™tre assez volumineux. La taille du fichier est directement li√©e √† la dur√©e, la fr√©quence d'√©chantillonnage et la profondeur de bits. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taille = Dur√©e (en secondes) x Taux d'√©chantillonnage (√©chantillons / s) x Profondeur de bits (bit / √©chantillon)</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fr√©quence d'√©chantillonnage affecte le plus la taille du fichier, donc le moyen le plus simple d'√©conomiser de l'espace est de s√©lectionner une valeur suffisamment faible. </font><font style="vertical-align: inherit;">Nous allons cr√©er un son old-school, donc une fr√©quence d'√©chantillonnage basse nous convient.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I2S</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'ESP32 poss√®de des p√©riph√©riques, gr√¢ce auxquels il est relativement simple de fournir une interface avec un √©quipement audio: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inter-IC Sound (I2S)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le protocole I2S est assez simple et se compose de seulement trois signaux: un signal d'horloge, un choix de canaux (gauche ou droite), ainsi que la ligne de donn√©es elle-m√™me. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fr√©quence d'horloge d√©pend de la fr√©quence d'√©chantillonnage, de la profondeur de bits et du nombre de canaux. Les battements sont remplac√©s pour chaque bit de donn√©es.Par cons√©quent, pour une bonne reproduction du son, vous devez r√©gler la fr√©quence d'horloge en cons√©quence. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fr√©quence d'horloge = Fr√©quence d'√©chantillonnage (√©chantillons / s) x Profondeur de bits (bits / √©chantillon) x Nombre de canaux</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le pilote du microcontr√¥leur I2S ESP32 a deux modes possibles: il peut soit √©mettre des donn√©es vers les contacts connect√©s √† un r√©cepteur I2S externe, qui peut d√©coder le protocole et transf√©rer des donn√©es vers l'amplificateur, soit il peut transf√©rer des donn√©es vers le DAC ESP32 interne √©mettant un signal analogique qui peut √™tre transmis √† amplificateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go n'a pas de d√©codeur I2S sur la carte, nous devrons donc utiliser le DAC ESP32 8 bits interne, c'est-√†-dire que nous devons utiliser un son 8 bits. </font><font style="vertical-align: inherit;">L'appareil dispose de deux DAC, l'un connect√© √† </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , l'autre √† </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La proc√©dure ressemble √† ceci:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous transf√©rons les donn√©es audio vers le pilote I2S</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le pilote I2S envoie les donn√©es audio au DAC interne 8 bits</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le DAC interne √©met un signal analogique</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le signal analogique est transmis √† l'amplificateur sonore</font></font></li>
<li>      </li>
<li>  </li>
</ol><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/d93/a8e/2d9d93a8ed6eceb35846c0f31e336ec9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous regardons le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">circuit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> audio dans </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">le circuit Odroid Go</font></a><font style="vertical-align: inherit;"> , nous verrons deux broches GPIO ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) connect√©es aux entr√©es de l'amplificateur de son ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PAM8304A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'IO25 est</font></font></strong><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
√©galement connect√© au signal </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD de l'</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> amplificateur, c'est-√†-dire au contact qui allume ou √©teint l'amplificateur (un signal faible signifie un arr√™t). Les sorties de l'amplificateur sont connect√©es √† un haut-parleur ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N'oubliez pas que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont des sorties de DAC ESP32 8 bits, c'est-√†-dire qu'un DAC est connect√© √† </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et l'autre √† </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entr√©es diff√©rentielles de l'</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> amplificateur de son. Les entr√©es diff√©rentielles sont utilis√©es pour r√©duire le bruit provoqu√© par les </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interf√©rences √©lectromagn√©tiques</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tout bruit pr√©sent dans un signal sera √©galement pr√©sent dans un autre. Un signal est soustrait d'un autre, ce qui √©limine le bruit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous regardez les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sp√©cifications de l‚Äôamplificateur de son</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , il dispose d‚Äôun </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">circuit d‚Äôapplication typique</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est la mani√®re recommand√©e par le fabricant d‚Äôutiliser l‚Äôamplificateur.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/044/d2a/323/044d2a323366c5ddb3c3b87f918bf5f9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il recommande de connecter </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† la masse, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au signal d'entr√©e et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au signal marche / arr√™t. S'il y a un bruit de 0,005 V, alors avec </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN- </font></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0V + 0,005V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sera lu </font><font style="vertical-align: inherit;">, et avec </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN + 0,005V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Les signaux d'entr√©e doivent √™tre soustraits les uns des autres et obtenir la vraie valeur du signal ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sans bruit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, les concepteurs d'Odroid Go n'ont pas utilis√© la configuration recommand√©e. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois de plus en regardant le circuit Odroid Go, nous voyons que les concepteurs ont connect√© la sortie DAC √† </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et que la m√™me sortie DAC est connect√©e √† </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ DAKOTA DU SUD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Il s'agit d'un signal d'arr√™t avec un niveau bas actif, donc pour que l'amplificateur fonctionne, vous devez d√©finir un signal haut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela signifie que pour utiliser l'amplificateur, nous ne devons pas utiliser l' </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme DAC, mais comme sortie GPIO avec un signal toujours √©lev√©. Cependant, dans ce cas, un signal haut est r√©gl√© sur </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui n'est pas recommand√© par la sp√©cification de l'amplificateur (il doit √™tre mis √† la terre). Ensuite, nous devons utiliser le DAC connect√© √† </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , car notre sortie I2S doit √™tre aliment√©e en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cela signifie que nous n'atteindrons pas la r√©duction de bruit n√©cessaire, car </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN- n'est</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas connect√© √† la terre. Un bruit doux √©mane constamment des haut-parleurs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous devons garantir la configuration correcte du pilote I2S, car nous voulons utiliser uniquement le DAC connect√© √† </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si nous </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisions</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un DAC connect√© √† </font><strong><font style="vertical-align: inherit;">IO25</font></strong><font style="vertical-align: inherit;"> , il </font><strong><font style="vertical-align: inherit;">√©teindrait</font></strong><font style="vertical-align: inherit;"> constamment le signal de l'amplificateur et le son serait terrible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus de cette bizarrerie, lors de l'utilisation d'un DAC interne 8 bits, le pilote I2S dans l'ESP32 n√©cessite la transmission d'√©chantillons 16 bits, mais envoie uniquement l'octet de poids fort au DAC 8 bits. </font><font style="vertical-align: inherit;">Par cons√©quent, nous devons prendre notre son 8 bits et le coller dans un tampon deux fois plus grand, tandis que le tampon sera √† moiti√© vide. </font><font style="vertical-align: inherit;">Ensuite, nous le transmettons au pilote I2S et il transmet au DAC l'octet de poids fort de chaque √©chantillon. </font><font style="vertical-align: inherit;">Malheureusement, cela signifie que nous devons ¬´payer¬ª pour 16 bits, mais nous ne pouvons utiliser que 8 bits.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multit√¢che</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, le jeu ne peut pas fonctionner sur un seul c≈ìur, comme je le voulais √† l'origine, car il semble y avoir un bug dans le pilote I2S. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le pilote I2S doit utiliser DMA (comme le pilote SPI), c'est-√†-dire que nous pourrions simplement lancer le transfert d'I2S, puis continuer notre travail pendant que le pilote I2S transmet des donn√©es audio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais √† la place, le CPU est bloqu√© pendant la dur√©e du son, ce qui est totalement inadapt√© au jeu. Imaginez que vous appuyez sur le bouton de saut, puis que l'image-objet du joueur interrompt son mouvement pendant 100 ms pendant la lecture du son de saut.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour r√©soudre ce probl√®me, nous pouvons profiter du fait qu'il y a deux c≈ìurs √† bord de l'ESP32. </font><font style="vertical-align: inherit;">Nous pouvons cr√©er une t√¢che (c'est-√†-dire un fil) dans le deuxi√®me noyau, qui traitera de la reproduction sonore. </font><font style="vertical-align: inherit;">Gr√¢ce √† cela, nous pouvons transf√©rer le pointeur vers le tampon sonore de la t√¢che principale du jeu √† la t√¢che sonore, et la t√¢che sonore initie le transfert de I2S et est bloqu√©e pendant la dur√©e de la lecture du son. </font><font style="vertical-align: inherit;">Mais la t√¢che principale sur le premier noyau (avec traitement d'entr√©e et rendu) continuera de s'ex√©cuter sans blocage.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sachant cela, nous pouvons lancer correctement le pilote I2S. </font><font style="vertical-align: inherit;">Pour ce faire, vous n'avez besoin que de quelques lignes de code, mais la difficult√© est de savoir quels param√®tres vous devez d√©finir pour une bonne reproduction du son.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> AUDIO_AMP_SD_PIN = GPIO_NUM_25;<font></font>
<font></font>
<span class="hljs-keyword">static</span> QueueHandle_t gQueue;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlayTask</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span>
</span>{
	<span class="hljs-keyword">for</span>(;;)<font></font>
	{<font></font>
		QueueData data;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (xQueueReceive(gQueue, &amp;data, <span class="hljs-number">10</span>))<font></font>
		{<font></font>
			<span class="hljs-keyword">size_t</span> bytesWritten;<font></font>
			i2s_write(I2S_NUM_0, data.buffer, data.length, &amp;bytesWritten, portMAX_DELAY);<font></font>
			i2s_zero_dma_buffer(I2S_NUM_0);<font></font>
		}<font></font>
<font></font>
		vTaskDelay(<span class="hljs-number">1</span> / portTICK_PERIOD_MS);<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeAudio</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-comment">// Configure the amplifier shutdown signal</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; AUDIO_AMP_SD_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
<font></font>
		gpio_set_level(AUDIO_AMP_SD_PIN, <span class="hljs-number">1</span>);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure the I2S driver</span><font></font>
	{<font></font>
		<span class="hljs-keyword">i2s_config_t</span> i2sConfig= {};<font></font>
<font></font>
		i2sConfig.mode = I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_DAC_BUILT_IN;<font></font>
		i2sConfig.sample_rate = <span class="hljs-number">5012</span>;<font></font>
		i2sConfig.bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT;<font></font>
		i2sConfig.communication_format = I2S_COMM_FORMAT_I2S_MSB;<font></font>
		i2sConfig.channel_format = I2S_CHANNEL_FMT_ONLY_LEFT;<font></font>
		i2sConfig.dma_buf_count = <span class="hljs-number">8</span>;<font></font>
		i2sConfig.dma_buf_len = <span class="hljs-number">64</span>;<font></font>
<font></font>
		ESP_ERROR_CHECK(i2s_driver_install(I2S_NUM_0, &amp;i2sConfig, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>));<font></font>
		ESP_ERROR_CHECK(i2s_set_dac_mode(I2S_DAC_CHANNEL_LEFT_EN));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Create task for playing sounds so that our main task isn't blocked</span><font></font>
	{<font></font>
		gQueue = xQueueCreate(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(QueueData));<font></font>
		assert(gQueue);<font></font>
<font></font>
		BaseType_t result = xTaskCreatePinnedToCore(&amp;PlayTask, <span class="hljs-string">"I2S Task"</span>, <span class="hljs-number">1024</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>);<font></font>
		assert(result == pdPASS);<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, nous configurons l' </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (qui est connect√© au signal de mise hors tension de l'amplificateur) en tant que sortie afin qu'il puisse contr√¥ler l'amplificateur sonore, et lui appliquons un signal √©lev√© pour allumer l'amplificateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous configurons et installons le pilote I2S lui-m√™me. </font><font style="vertical-align: inherit;">Je vais analyser chaque partie de la configuration ligne par ligne, car chacune des lignes n√©cessite une explication:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mode</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous d√©finissons le pilote comme un ma√Ætre (contr√¥lant le bus), un √©metteur (car nous transf√©rons des donn√©es aux destinataires), et le configurons pour utiliser le DAC 8 bits int√©gr√© (car la carte Odroid Go n'a pas de DAC externe).</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">taux d'√©chantillonnage</font></font><ul>
<li>    5012,      ,   ,      .   ,      ,          .    -,           2500 .</li>
</ul></li>
<li>bits_per_sample<ul>
<li>  ,    ESP32  8-,   I2S ,      16    ,   8     .</li>
</ul></li>
<li>communication_format<ul>
<li>      ,   ,   -   ,   8-      16- .</li>
</ul></li>
<li>channel_format<ul>
<li> GPIO,    <strong>IN+</strong>   ‚Äî  <strong>IO26</strong>,       ¬´¬ª   I2S.  ,  I2S      ,      <strong>IO25</strong>,      ,          .</li>
</ul></li>
<li>dma_buf_count  dma_buf_len<ul>
<li>  DMA-   ( )  ,        ,   ,        IDF.       ,     .</li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous cr√©ons une file d'attente - c'est ainsi que FreeRTOS envoie des donn√©es entre les t√¢ches. Nous mettons les donn√©es dans la file d'attente d'une t√¢che et les extrayons de la file d'attente d'une autre t√¢che. Cr√©ez une structure appel√©e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui combine le pointeur vers le tampon audio et la longueur du tampon en une seule structure qui peut √™tre mise en file d'attente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, cr√©ez une t√¢che qui s'ex√©cute sur le deuxi√®me c≈ìur. Nous le connectons √† la fonction </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayTask</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui effectue la lecture du son. La t√¢che elle-m√™me est une boucle sans fin qui v√©rifie constamment s'il y a des donn√©es dans la file d'attente. S'ils le sont, elle les envoie au pilote I2S afin qu'ils puissent √™tre lus. Il bloquera l'appel </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i2s_write</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et cela nous convient, car la t√¢che est effectu√©e sur un noyau distinct du thread principal du jeu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un appel √† </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i2s_zero_dma_buffer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est requis pour que, une fois la lecture termin√©e, il ne reste plus aucun son des haut-parleurs. </font><font style="vertical-align: inherit;">Je ne sais pas s'il s'agit d'un bogue du pilote I2S ou du comportement attendu, mais sans cela, une fois la m√©moire tampon de son termin√©e, le haut-parleur √©met un signal parasite.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jouer son</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_PlayAudio</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span>* buffer, <span class="hljs-keyword">size_t</span> length)</span>
</span>{<font></font>
	QueueData data = {};<font></font>
<font></font>
	data.buffer = buffer;<font></font>
	data.length = length;<font></font>
<font></font>
	xQueueSendToBack(gQueue, &amp;data, portMAX_DELAY);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√âtant donn√© que la configuration compl√®te est d√©j√† termin√©e, l'appel √† la fonction de lecture du tampon audio lui-m√™me est extr√™mement simple, car le travail principal est effectu√© dans une autre t√¢che. </font><font style="vertical-align: inherit;">Nous pla√ßons le pointeur sur le tampon et la longueur du tampon dans la structure </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , puis le mettons dans la file d'attente utilis√©e par la fonction </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayTask</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En raison de ce sch√©ma de fonctionnement, un tampon audio doit terminer la lecture avant de pouvoir d√©marrer le second tampon. </font><font style="vertical-align: inherit;">Par cons√©quent, si un saut et une prise de vue se produisent simultan√©ment, le premier son sera jou√© avant le second, et non simultan√©ment avec lui. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tr√®s probablement, √† l'avenir, je m√©langerai diff√©rents sons de trame dans le tampon sonore qui est transmis au pilote I2S. </font><font style="vertical-align: inherit;">Cela vous permettra de jouer plusieurs sons en m√™me temps.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©mo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous g√©n√©rerons nos propres effets sonores √† l'aide de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsfxr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , un outil sp√©cialement con√ßu pour g√©n√©rer le type de sons de jeu dont nous avons besoin. </font><font style="vertical-align: inherit;">Nous pouvons directement d√©finir la fr√©quence d'√©chantillonnage et la profondeur de bits, puis g√©n√©rer le fichier WAV. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai cr√©√© un simple effet sonore de saut qui ressemble au son du saut de Mario. </font><font style="vertical-align: inherit;">Il a une fr√©quence d'√©chantillonnage de 5012 (comme nous l'avons configur√© lors de l'initialisation) et une profondeur de bits de 8 (car le DAC est de 8 bits).</font></font><br>
<br>
<div class="oembed"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://austinmorlan.com/posts/embedded_game_programming_6/media/jump.wav</font></font></a></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lieu d'analyser le fichier WAV directement dans le code, nous ferons quelque chose de similaire √† ce que nous avons fait pour charger le sprite dans la d√©mo de la partie 4: nous supprimerons l'en-t√™te WAV du fichier en utilisant l'√©diteur hexad√©cimal. Gr√¢ce √† cela, le fichier lu sur la carte SD ne sera que des donn√©es brutes. De plus, nous ne lirons pas la dur√©e du son, nous l'√©crirons dans le code. √Ä l'avenir, nous chargerons les ressources sonores diff√©remment, mais cela suffit pour la d√©mo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fichier brut peut √™tre t√©l√©charg√© √† </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partir d'ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Load sound effect</span>
<span class="hljs-keyword">uint16_t</span>* soundBuffer;
<span class="hljs-keyword">int</span> soundEffectLength = <span class="hljs-number">1441</span>;<font></font>
{<font></font>
	FILE* soundFile = fopen(<span class="hljs-string">"/sdcard/jump"</span>, <span class="hljs-string">"r"</span>);<font></font>
	assert(soundFile);<font></font>
<font></font>
	<span class="hljs-keyword">uint8_t</span>* soundEffect = <span class="hljs-built_in">malloc</span>(soundEffectLength);<font></font>
	assert(soundEffect);<font></font>
<font></font>
	soundBuffer = <span class="hljs-built_in">malloc</span>(soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	assert(soundBuffer);<font></font>
<font></font>
	fread(soundEffect, soundEffectLength, <span class="hljs-number">1</span>, soundFile);<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; soundEffectLength; ++i)<font></font>
    {<font></font>
        <span class="hljs-comment">// 16 bits required but only MSB is actually sent to the DAC</span>
        soundBuffer[i] = (soundEffect[i] &lt;&lt; <span class="hljs-number">8u</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous chargeons les donn√©es 8 bits </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tampon </font><strong><font style="vertical-align: inherit;">soundEffect</font></strong><font style="vertical-align: inherit;"> 8 bits </font><font style="vertical-align: inherit;">, puis copions ces donn√©es dans le tampon </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soundBuffer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16 bits </font><font style="vertical-align: inherit;">, o√π les donn√©es seront stock√©es dans les huit bits de poids fort. </font><font style="vertical-align: inherit;">Je le r√©p√®te - cela est n√©cessaire en raison des caract√©ristiques de la mise en ≈ìuvre de Tsahal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s avoir cr√©√© un tampon 16 bits, nous pouvons jouer le son d'un clic sur un bouton. </font><font style="vertical-align: inherit;">Il serait logique d'utiliser le bouton de volume pour cela.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> lastState = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (;;)<font></font>
{<font></font>
	[...]<font></font>
<font></font>
	<span class="hljs-keyword">int</span> thisState = input.volume;<font></font>
<font></font>
	<span class="hljs-keyword">if</span> ((thisState == <span class="hljs-number">1</span>) &amp;&amp; (thisState != lastState))<font></font>
	{<font></font>
		Odroid_PlayAudio(soundBuffer, soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	}<font></font>
<font></font>
	lastState = thisState;<font></font>
<font></font>
	[...]<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous surveillons l'√©tat du bouton afin que, accidentellement, en un seul clic, vous </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'appeliez</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas accidentellement </font><strong><font style="vertical-align: inherit;">Odroid_PlayAudio</font></strong><font style="vertical-align: inherit;"> plusieurs fois.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Votre navigateur ne prend pas en charge la vid√©o HTML5.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_6/media/demo.mp4" type="video/mp4"></video></div></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La source</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout le code source est </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©f√©rences</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sch√©ma Odroid Go</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fiche technique de l'amplificateur audio</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation ESP-IDF: DAC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation ESP-IDF: I2S</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Format de fichier WAVE</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vid√©o: Explication de la profondeur de bits</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vid√©o: Explication du taux d'√©chantillonnage</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr503854/index.html">Utilisez SIL au maximum</a></li>
<li><a href="../fr503858/index.html">Le livre "Terraform: infrastructure au niveau du code"</a></li>
<li><a href="../fr503860/index.html">Configuration de l'environnement du r√©seau de neurones Mask R-CNN</a></li>
<li><a href="../fr503864/index.html">Organisation des saveurs chez Flutter</a></li>
<li><a href="../fr503866/index.html">Publication du d√©veloppement de la feuille de route Zextras Suite pour 2020</a></li>
<li><a href="../fr503880/index.html">Comment j'ai appris √† ne pas m'inqui√©ter et √† aimer la vision industrielle</a></li>
<li><a href="../fr503884/index.html">Comment apprendre √† travailler de mani√®re asynchrone</a></li>
<li><a href="../fr503888/index.html">Algorithme AdaBoost</a></li>
<li><a href="../fr503890/index.html">L'histoire de la fa√ßon dont j'ai configur√© Azure AD B2C sur React et React Native Partie 1 (Tutoriel)</a></li>
<li><a href="../fr503892/index.html">Mitap: Quarantaine, partez</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>