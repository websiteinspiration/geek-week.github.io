<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏼 🛍️ 🏼 Pengalokasi memori 🙌 🏹 👩🏼‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Belum lama ini, setelah studi yang sangat ketat tentang pengalokasian dan algoritma alokasi memori, serta aplikasi mereka berikutnya da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Pengalokasi memori</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505632/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo semuanya! </font><font style="vertical-align: inherit;">Belum lama ini, setelah studi yang sangat ketat tentang pengalokasian dan algoritma alokasi memori, serta aplikasi mereka berikutnya dalam praktik, saya muncul dengan ide untuk menulis artikel yang akan menggambarkan mereka sedetail mungkin. </font><font style="vertical-align: inherit;">Saya pikir topik ini akan sangat populer, karena ada sangat sedikit sumber di jaringan, terutama di bagian berbahasa Rusia, yang didedikasikan untuk masalah ini.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata pengantar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mulai dengan, saya ingin segera mencatat bahwa jika seseorang pertama kali mendengar istilah "pengalokasi", "algoritma alokasi memori" dan tidak mengerti mengapa ini semua diperlukan, maka sebelum membaca artikel ini, saya sarankan Anda membiasakan diri dengan </font><font style="vertical-align: inherit;">sumber </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Artikel ini menjelaskan dengan baik masalah apa yang ada di pengalokasi memori standar, dan untuk tujuan apa perlu menggunakan metode alokasi memori lain, selain yang standar. </font><font style="vertical-align: inherit;">Di sini saya hanya akan berbicara tentang algoritma distribusi itu sendiri, dan, tentu saja, pada akhirnya saya akan memberikan implementasi dari salah satu pengalokasi, yang dapat digunakan tanpa masalah dalam wadah standar C ++.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dasar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lima operasi utama yang dapat dilakukan pada pengalokasi secara konseptual disorot (saya ingin mencatat bahwa tidak semua pengalokasi dapat secara eksplisit sesuai dengan antarmuka ini):</font></font><br>
<br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buat</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><i><font style="vertical-align: inherit;">buat</font></i><font style="vertical-align: inherit;"> pengalokasi dan berikan sejumlah memori;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengalokasikan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - memilih blok dengan ukuran tertentu dari area memori yang dikendalikan oleh pengalokasi;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deallocate</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - membebaskan blok tertentu;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gratis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - membebaskan semua blok yang dialokasikan dari memori pengalokasi (memori yang dialokasikan untuk pengalokasi tidak dibebaskan);</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menghancurkan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - menghancurkan pengalokasi dengan rilis berikutnya memori yang dialokasikan ke pengalokasi.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linear Allocator</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linear Allocator, itu juga "linear" - ini adalah jenis pengalokasi paling sederhana. Idenya adalah untuk menyimpan penunjuk ke awal blok memori untuk pengalokasi yang dialokasikan, dan juga menggunakan penunjuk yang berbeda atau representasi numerik, yang perlu dipindahkan setiap kali alokasi dari pengalokasi tersebut selesai. Dalam pengalokasi ini, fragmentasi internal diminimalkan karena semua elemen dimasukkan secara berurutan (lokalitas spasial), dan satu-satunya fragmentasi di antara mereka adalah penyelarasan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lebih lanjut, saya mengusulkan untuk mempertimbangkan beberapa contoh yang akan ditunjukkan dengan jelas secara rinci bagaimana pengalokasi ini bekerja. Ambil beberapa blok memori sama dengan 14 byte dan berikan ke kontrol pengalokasi. Seperti yang bisa dilihat dari gambar di bawah ini, kita menyimpan pointer ke awal memori ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mulai</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), dan juga menyimpan dua pointer, atau dua representasi numerik yang berisi informasi tentang total ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akhir</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dan </font><font style="vertical-align: inherit;">ukuran memori yang </font><font style="vertical-align: inherit;">digunakan ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">digunakan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/aa/wg/vgaawgiqzerseegtgqvk0qbjhus.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bayangkan bahwa pengalokasi menerima permintaan untuk mengalokasikan 4 byte memori. </font><font style="vertical-align: inherit;">Tindakan pengalokasi pada pelaksanaan permintaan ini adalah sebagai berikut:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">periksa apakah ada cukup memori untuk dialokasikan;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyimpan pointer yang digunakan saat ini, yang nantinya akan diberikan kepada pengguna sebagai pointer ke blok memori yang dialokasikan dari pengalokasi;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggeser pointer yang digunakan dengan jumlah yang sama dengan ukuran blok memori yang dialokasikan, yaitu </font><font style="vertical-align: inherit;">dengan 4 byte.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/wp/3q/_r/wp3q_r2dp-ywsaou93vzk8zhqkk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, misalnya, permintaan datang untuk alokasi 8 byte dan, karenanya, tindakan pengalokasi akan persis sama terlepas dari ukuran blok memori yang dialokasikan. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/di/g4/ih/dig4ihecjl8qfasqqonhdqtt2lm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi di sini sudah akan menjadi sedikit lebih menarik, misalnya, jika permintaan datang untuk mengalokasikan hanya 1 byte, dan jika kita tidak ingin menyelaraskan blok dalam memori (misalnya, alamat yang merupakan kelipatan dari 2, 4, ...), maka tindakan pengalokasi akan tetap sama persis.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vz/x_/cc/vzx_cc45oildurtaxdyi7n9fi7i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi, jika kita perlu mengalokasikan blok memori dengan penyelarasan tertentu (misalnya, penyelarasan alamat kelipatan 2), maka tindakan pengalokasi sedikit berubah. Itu berubah bukan dalam hal implementasi, tetapi dalam hal itu, selain data itu sendiri sama dengan volume satu byte, kami juga mengambil satu byte tambahan dari memori pengalokasi untuk penyelarasan, yang tidak membawa arti apa pun. Inilah tepatnya fragmentasi minimal memori yang sangat mungkin di dalam pengalokasi linier. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jx/xg/pz/jxxgpzvrvs9nhyodrphmi1xg1sy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hebat, sekarang saatnya berbicara tentang membebaskan memori. Seperti disebutkan sebelumnya, jenis pengalokasian ini tidak mendukung pelepasan blok memori tertentu secara selektif. Artinya, jika kita menggambar analogi yang halus dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc / gratis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , memiliki pointer ke, katakanlah, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFAA00</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kami dapat membebaskan blok memori ini, tetapi pengalokasi linier tidak dapat mengizinkan kami melakukan ini. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mj/es/_0/mjes_04nsdmq3bfiolwehoxwdfk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang bisa kita lakukan adalah membebaskan semua memori yang ditempati seluruhnya di dalam pengalokasi dan terus bekerja dengannya seolah-olah itu benar-benar kosong.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/aa/wg/vgaawgiqzerseegtgqvk0qbjhus.png"><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengalokasi kolam renang</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gagasan pengalokasi blok adalah bahwa ia membagi sebagian besar memori menjadi potongan-potongan kecil </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan ukuran yang sama</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pada intinya, ini juga merupakan pengalokasi yang sangat sederhana, karena ketika alokasi diminta, ia hanya mengembalikan salah satu lokasi memori bebas dari ukuran tetap, dan ketika diminta untuk dibebaskan, ia hanya menyimpan area memori ini untuk digunakan di masa mendatang. Dengan demikian, distribusinya sangat cepat, dan fragmentasi masih sangat kecil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, serta dengan pengalokasi linier, saya mengusulkan untuk mempertimbangkan segala sesuatu dengan contoh untuk memahami secara lebih rinci cara kerjanya, jadi kami mengambil beberapa blok memori sebesar 12 byte dan memberikannya kepada kontrol pengalokasi. Seperti yang dapat Anda lihat dari gambar di bawah ini, kami menjaga pointer ke awal (</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mulai</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dan akhir ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akhir</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dari memori yang dikendalikan oleh pengalokasi, serta daftar ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freeblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dari alamat blok gratis di pengalokasi. Sebagai sarana untuk menyimpan data yang bloknya sibuk atau gratis, Anda dapat menggunakan banyak alat, misalnya, array nilai Boolean, tetapi saya hanya memutuskan untuk memilih daftar yang hanya terhubung, karena itu yang paling sederhana dan jelas mencirikan konsep ini (omong-omong, tautan daftar dapat disimpan dalam blok memori bebas, sehingga menghilangkan biaya memori tambahan).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/co/6s/5o/co6s5o7c7ufuvofrrb1oqwke8vy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika permintaan datang untuk mengalokasikan satu blok memori, maka tindakan pengalokasi sangat primitif. Pertama, dia memeriksa apakah ada tautan dalam daftar blok gratis, jika tidak ada, maka tidak sulit untuk menebak bahwa memori dalam pengalokasi telah habis. Jika ada setidaknya satu tautan di sana, maka itu hanya menghapus tautan root atau tail (dalam implementasi ini tail link diberikan) dan memberikan alamatnya kepada pengguna. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uc/j_/44/ucj_44gjfi99_jf4whquo4sra78.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika permintaan datang untuk alokasi beberapa blok memori, maka pengalokasi dengan cara yang sama melakukan tindakan yang sama pada gilirannya, dijelaskan pada langkah sebelumnya.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ri/qc/zy/riqczyaeceqtxdshywd0py4r0nw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adapun rilis blok, jika permintaan untuk rilis tiba, maka pengalokasi hanya menambahkan alamat ini ke salah satu ujung daftar yang hanya terhubung. Perlu dicatat saat itu bahwa, misalnya, alamat yang tidak cocok dengan alamat memori pengalokasi, misalnya, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xEFAB12</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">dapat datang sebagai alamat blok yang akan </font><b><font style="vertical-align: inherit;">dibebaskan</font></b><font style="vertical-align: inherit;"> , dan kemudian akan mungkin bahwa kami akan memberikan pengguna sepotong memori yang bukan milik kami (tentu saja , ini akan menyebabkan perilaku yang tidak terdefinisi atau jika Anda sangat beruntung, maka cukup dengan crash program). Untuk menghindari kemungkinan masalah ini, cukup </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mulai</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akhiri digunakan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang memungkinkan Anda untuk memeriksa apakah pengguna salah dengan alamat selama permintaan untuk operasi rilis.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/0n/ed/gd0nedbx2nlhsrxggnymb42keey.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain melampaui memori yang tidak dikendalikan oleh pengalokasi, ada masalah lain yang mungkin terjadi. </font><font style="vertical-align: inherit;">Seorang pengguna dapat datang dengan permintaan untuk benar-benar melepaskan alamat yang terletak di area memori pengalokasi, tetapi tidak sama dengan alamat awal dari salah satu blok, katakanlah sebuah blok dengan alamat </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFAA07</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Operasi ini, tentu saja, akan mengarah pada perilaku yang tidak terdefinisi. </font><font style="vertical-align: inherit;">Jika ada kebutuhan untuk memeriksa tambahan apakah pengguna melakukan semuanya dengan benar, maka dimungkinkan untuk melacaknya. </font><font style="vertical-align: inherit;">Untuk melacak ini, ada banyak solusi, misalnya, untuk menyimpan alamat dan blok yang ditempati juga, atau bahkan memeriksa alamat untuk banyaknya ukuran blok dalam pengalokasi (semuanya tergantung pada imajinasi dan pada situasi tertentu di mana pengalokasi digunakan).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3u/mn/hw/3umnhwagefbl_eysi3zl6yhu9be.png"><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alokasi pengalokasian</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebenarnya, ini adalah evolusi cerdas dari pengalokasi linier yang memungkinkan Anda untuk mengelola memori seperti tumpukan. Semuanya sama seperti sebelumnya, kita menyimpan pointer dengan blok "header" (selanjutnya akan digunakan sebagai </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">header</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ke alamat memori saat ini dan bergerak maju untuk setiap alokasi. Tidak seperti pengalokasi linier, kita juga dapat memindahkannya kembali, yaitu melakukan operasi deallocate, yang tidak didukung oleh pengalokasi linier. Seperti sebelumnya, prinsip lokalitas spasial dipertahankan, dan fragmentasi masih minimal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mengusulkan untuk mempertimbangkan beberapa contoh semua dengan blok memori yang sama 14 byte. Seperti halnya pengalokasi linier, kami juga menyimpan pointer ke awal memori ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mulai</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dan akhir ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akhir)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), serta penunjuk ke ujung memori yang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">digunakan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><i><font style="vertical-align: inherit;">digunakan</font></i><font style="vertical-align: inherit;"> ). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ba/sb/qv/basbqv8yj_v1sijo_td54pa472k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika permintaan alokasi memori tiba, selain mengalokasikan sejumlah memori yang diminta oleh pengguna, kami juga mengalokasikan header (pengguna tidak akan berinteraksi dengannya dengan cara apa pun), di mana kami menyimpan informasi tentang berapa banyak byte yang dialokasikan (dalam contoh ini, ukuran header adalah 2 byte). Misalnya, jika Anda menerima permintaan alokasi 2 byte, maka status pengalokasi akan persis sama seperti pada gambar di bawah ini. Penting untuk dicatat bahwa pengguna tidak akan diberi pointer ke heading, tetapi ke blok segera setelah heading, yaitu, dalam contoh ini, ini adalah blok dengan alamat </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFAA02</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/qb/q2/bgqbq2fei1egpmowdnmz9vciplo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Situasi serupa akan, misalnya, dengan alokasi 6 byte.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/up/pf/x_/uppfx_dpultvroggfr2rvy7lxhc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi dengan rilis, semuanya sedikit lebih menarik (seperti yang dibahas sebelumnya, kami hanya dapat mengalokasikan dan membebaskan memori menggunakan algoritma </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LIFO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Pertama, dari penunjuk yang diminta pengguna untuk dibebaskan, Anda harus mengurangi ukuran tajuk, lalu dereferensi nilainya dan hanya setelah itu pindahkan penunjuk yang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">digunakan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke ukuran tajuk bersama dengan ukuran blok yang diperoleh dari tajuk. </font><font style="vertical-align: inherit;">Di sini, seperti halnya pengalokasi blok, situasi pembebasan blok memori "acak" juga dimungkinkan, yang juga akan mengarah pada perilaku yang tidak terdefinisi. </font><font style="vertical-align: inherit;">Terserah semua orang untuk menambah pengalokasi dengan cek tambahan atau tidak. </font><font style="vertical-align: inherit;">Yang paling penting adalah jangan melupakan momen ini. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/as/fh/s4/asfhs4qflx43fwr9jizq-zmsatq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, setelah memahami dasar-dasarnya, saatnya mempelajari sesuatu yang lebih serius.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Pengalokasi standar primitif"</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, implementasi dari pengalokasi akan disajikan, yang dapat digunakan tanpa masalah dengan STL. Algoritma alokasi memori dalam pengalokasi ini akan mirip dengan algoritma yang digunakan oleh pengalokasi standar. Saya ingin segera mencatat bahwa saya tidak berpura-pura menjadi implementasi malloc yang lengkap, saya hanya mengambil konsep dasar darinya dengan penambahan logika saya di beberapa tempat. Semua seluk-beluk dan nuansa, tentu saja, tidak diperhitungkan dalam implementasi ini ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algoritma didasarkan pada interaksi dengan "potongan" (selanjutnya akan digunakan sebagai </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bagian</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dalam implementasi ini, ukurannya statis dan harus kelipatan empat, serta semua alokasi memori dari memori pengalokasi disejajarkan dengan kelipatan empat), yang akan dibahas nanti. Sebagai contoh, ambil bagian dengan ukuran 16 byte. Di dalamnya, itu akan berisi pointer ke awal ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mulai</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dan akhir ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akhir</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dari memori, pointer ke blok memori maksimum ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dan banyak ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kunci pembuka gratis)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), di mana tajuk blok gratis akan disimpan. Ukuran header dalam implementasi ini adalah 4 byte, tetapi dapat dengan mudah bervariasi dalam ukuran untuk keperluan yang Anda butuhkan. Misalnya, jika Anda tahu pasti bahwa ukuran blok memori yang dialokasikan tidak lebih dari nilai numerik maksimum yang dapat direpresentasikan dalam satu atau dua variabel byte, maka Anda dapat menggunakan header 1 atau 2 byte. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nr/xq/3f/nrxq3fcbnoooxnu0hehls2dghim.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam operasi mengalokasikan memori dari suatu bagian, pertama-tama Anda perlu memeriksa apakah ada cukup memori (dalam implementasi ini, ini adalah operasi yang konstan, kami hanya membandingkannya dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">header dan, jika ukuran memori yang dialokasikan kurang dari blok maksimum, maka kami memiliki memori yang cukup untuk alokasi ini). Jika ada cukup memori, maka kami cukup memberikan alamat memori mengikuti header, seperti pada pengalokasi stack, dan juga menghapus header sebelumnya dari set blok bebas dan hanya setelah itu tambahkan header baru ke blok memori yang baru dialokasikan. Penting untuk dicatat bahwa jika kita mengalokasikan memori dari blok maksimum, maka kita perlu memperbarui nilai blok maksimum. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5m/lm/yw/5mlmywi79wh3uutr-ug7ko7s9em.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam pilihan berikutnya, semuanya terjadi persis sama seperti pada langkah sebelumnya.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3m/2m/i9/3m2mi9xd9qmnf6ngnqjf8wfnzd0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi sekarang, segera setelah memori di bagian tersebut berakhir, pengalokasi mengambil dan hanya membuat bagian lain dengan ukuran yang sama atau lebih besar (dalam implementasi ini, semua bagian memiliki ukuran yang sama). Juga bermanfaat untuk memastikan bahwa ukuran blok yang mungkin untuk alokasi tidak melebihi ukuran plot dikurangi ukuran header. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fy/fz/6g/fyfz6gthdrfysccjef_xcphihb0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, di bagian baru, Anda dapat dengan mudah mengalokasikan blok memori yang diperlukan. Alokasi memori akan terjadi dalam skenario yang persis sama seperti pada bagian sebelumnya.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/al/eu/gc/aleugc_fka3uvpmju9gw66dpn1w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang sedikit tentang mengapa dalam implementasi ini ukuran plot harus kelipatan empat. Jawabannya sangat sederhana - ini dilakukan untuk kemudahan implementasi dan persepsi algoritma. Karena situasi seperti itu mungkin terjadi pada akhir bagian masih ada beberapa area memori, yang tidak cocok dengan header (contoh ini ditunjukkan pada gambar berikut). Untuk mengatasi masalah ini, dimungkinkan untuk mengisi memori ini dengan penyelarasan tambahan, baik membuat ukuran header lebih kecil atau menggunakan alat tambahan untuk melacak masalah yang mungkin terjadi, jika tidak, memori ini akan hilang dan yang paling penting, di masa depan, memori yang hilang dapat menumpuk!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rq/rp/mv/rqrpmvvpbx1thpxjfbqcictzq1o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum mengosongkan memori, Anda perlu menentukan di bagian mana blok tersebut berada (dalam implementasi saat ini, operasi ini adalah kompleksitas linier sehubungan dengan jumlah total bagian, jika dipahami bahwa akan ada sejumlah besar bagian, maka dapat dibuat konstan dengan menambahkan indeks bagian ke header, di mana memori dialokasikan). Dalam berikut ini, operasi deallokasi identik dengan pengalokasi tumpukan, kecuali bahwa Anda perlu menambahkan alamat header dari blok deallocated ke set blok gratis, serta memperbarui </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blokir maksimum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jika ukuran blok yang baru dirilis lebih besar dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fw/sl/yl/fwslyluxwv00a8mwazxe2iakd00.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penting untuk dicatat bahwa dalam implementasi ini, dengan setiap rilis memori berikutnya, upaya dilakukan untuk defrag di area di mana memori dibebaskan. Defragmentasi diperlukan untuk menggabungkan blok bebas menjadi blok besar. Misalnya, dalam situasi ini, seperti pada gambar di bawah ini, kita tidak akan dapat mengalokasikan 6 byte, bahkan jika ukuran memori bebas memungkinkan kita untuk melakukan ini, tetapi fragmentasi memberi tahu kita dengan tegas dan tegas "tidak"! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tm/ec/dp/tmecdpyhyynvn0ahzubdxltorvo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operasi defrag sangat primitif. Esensinya terletak pada kenyataan bahwa setelah operasi membebaskan memori, ia memeriksa untuk melihat apakah dua blok tetangga di sebelah kiri dan di sebelah kanan yang dibebaskan itu bebas. Jika dua blok tetangga bebas, maka mereka digabungkan menjadi satu unit tunggal.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jt/1u/hl/jt1uhl_a7d3xo2a3f9kedx_7waq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya juga ingin mencatat bahwa implementasi ini akan sangat mengerikan untuk bekerja dengan mengalokasikan blok memori yang kecil, misalnya sama dengan 1 byte. </font><font style="vertical-align: inherit;">Dalam situasi ini, kami mendapatkan +7 byte tambahan untuk mengalokasikan hanya satu byte memori karena fakta bahwa ukuran header adalah 4 byte dan ditambah 3 byte untuk merobek alamat yang harus merupakan kelipatan empat. </font><font style="vertical-align: inherit;">Dengan ini, saya ingin mengatakan bahwa Anda tidak boleh secara membuta menggunakan algoritma alokasi memori apa pun, karena alih-alih optimasi yang lama ditunggu-tunggu, kadang-kadang Anda hanya bisa mendapatkan biaya tambahan. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/r2/ez/v3/r2ezv39toknyjxexeamoq05g3r8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya pikir teorinya akan cukup dan karena itu, seperti yang dikatakan Linus Torvalds: “ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obrolan tidak berharga. </font><font style="vertical-align: inherit;">Tunjukkan kodenya</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . " </font><font style="vertical-align: inherit;">Baiklah, mari kita mulai ...</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penerapan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Persyaratan untuk pengalokasi diberikan dalam standar C ++ di bab " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persyaratan pengalokasi [pengalokasi.perlu]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Berdasarkan persyaratan tersebut, antarmuka pengalokasi paling primitif yang dapat digunakan dalam STL akan terlihat seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">Allocator</span> 
{</span>
    <span class="hljs-keyword">typedef</span> T value_type;<font></font>
    Allocator( );<font></font>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; 
    <span class="hljs-title">Allocator</span>(<span class="hljs-title">const</span> &lt;T&gt;&amp; <span class="hljs-title">other</span>);</span>
    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(T* ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">U</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>==(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T&gt;&amp;, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U&gt;&amp;);</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">U</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>!=(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T&gt;&amp;, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U&gt;&amp;);</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diasumsikan bahwa wadah STL tidak mengakses pengalokasi secara langsung, tetapi melalui template std :: dialokasikanator_traits, yang menyediakan nilai-nilai seperti:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">typedef</span> T* pointer;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> T* const_pointer; <font></font>
… <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nah, kami sudah tahu persyaratannya, sekarang akhirnya kami mulai menulis pengalokasi. </font><font style="vertical-align: inherit;">Untuk mulai dengan, kami akan menulis beberapa antarmuka atau adaptor, pada kenyataannya sulit untuk memanggil keduanya, jadi biarlah semacam "lapisan" di mana, dengan menggunakan strategi, kami dapat dengan mudah mengubah algoritma alokasi memori untuk tujuan tertentu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Common interface for interaction with STL</span>
<span class="hljs-comment">// containers and algorithms. You can manually change</span>
<span class="hljs-comment">// allocation algorithm with different 'AllocationStrategy'</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// In this implementation was not implented 'adress' and 'max_size'</span>
<span class="hljs-comment">// unnecessary functions for.</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">Allocator</span>
{</span>
    <span class="hljs-keyword">static_assert</span>(!<span class="hljs-built_in">std</span>::is_same_v&lt;T, <span class="hljs-keyword">void</span>&gt;, <span class="hljs-string">"Type of the allocator can not be void"</span>);
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> value_type = T;<font></font>
<font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocStrategy</span>&gt;
    <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">Allocator</span>;</span><font></font>
    <font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rebind</span>
    {</span>
        <span class="hljs-keyword">using</span> other = Allocator&lt;U, AllocationStrategy&gt;;<font></font>
    };<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    Allocator() = <span class="hljs-keyword">default</span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Allocator</span><span class="hljs-params">(AllocationStrategy&amp; strategy)</span> <span class="hljs-keyword">noexcept</span>
        : <span class="hljs-title">m_allocation_strategy</span><span class="hljs-params">(&amp;strategy)</span> </span>{}<font></font>
    <font></font>
    Allocator(<span class="hljs-keyword">const</span> Allocator&amp; other) <span class="hljs-keyword">noexcept</span><font></font>
        : m_allocation_strategy(other.m_allocation_strategy) {}<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-title">Allocator</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Allocator&lt;U, AllocationStrategy&gt;&amp; other)</span> <span class="hljs-keyword">noexcept</span>
        : <span class="hljs-title">m_allocation_strategy</span><span class="hljs-params">(other.m_allocation_strategy)</span> </span>{}<font></font>
    <font></font>
    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span>
    </span>{<font></font>
        assert(m_allocation_strategy &amp;&amp; <span class="hljs-string">"Not initialized allocation strategy"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(m_allocation_strategy-&gt;allocate(count_objects * <span class="hljs-keyword">sizeof</span>(T)));<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* memory_ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span>
    </span>{<font></font>
        assert(m_allocation_strategy &amp;&amp; <span class="hljs-string">"Not initialized allocation strategy"</span>);<font></font>
        m_allocation_strategy-&gt;deallocate(memory_ptr, count_objects * <span class="hljs-keyword">sizeof</span>(T));<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-keyword">typename</span>... Args&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(U* ptr, Args&amp;&amp;... args)</span>
    </span>{
        <span class="hljs-keyword">new</span> (<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(ptr)) U { <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)... };<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(U* ptr)</span>
    </span>{<font></font>
        ptr-&gt;~U();<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:<font></font>
    AllocationStrategy* m_allocation_strategy = <span class="hljs-literal">nullptr</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>==(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T, AllocationStrategy&gt;&amp; <span class="hljs-title">lhs</span>, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U, AllocationStrategy&gt;&amp; <span class="hljs-title">rhs</span>)
{</span>
    <span class="hljs-keyword">return</span> lhs.m_allocation_strategy == rhs.m_allocation_strategy;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>!=(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T, AllocationStrategy&gt;&amp; <span class="hljs-title">lhs</span>, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U, AllocationStrategy&gt;&amp; <span class="hljs-title">rhs</span>)
{</span>
    <span class="hljs-keyword">return</span> !(lhs == rhs);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berkat strategi alokasi memori, kita dapat melakukan sesuatu seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> AllocatorForSmallObjects = Allocator&lt;T, StrategyForSmallObjects&gt;;
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> AllocatorForBigObjects = Allocator&lt;T, StrategyForBigObjects&gt;;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artinya, kita dapat secara fleksibel mengubah algoritma distribusi untuk keperluan yang diperlukan dalam situasi tertentu. </font><font style="vertical-align: inherit;">Satu-satunya persyaratan untuk AllocationStrategy adalah bahwa mereka harus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengalokasikan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membatalkan </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">alokasi </font></i><i><font style="vertical-align: inherit;">operasi</font></i><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-comment">// Strategy for manipulation memory chunks, like</span>
<span class="hljs-comment">// a primitive malloc allocator.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Warning: if you try to deallocate some random block</span>
<span class="hljs-comment">// of the memory, most of all it will be an undefined behavior,</span>
<span class="hljs-comment">// because current implementation doesn't check this possible situation.</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE = <span class="hljs-number">16'384u</span>&gt;<font></font>
class CustomAllocationStrategy<font></font>
{<font></font>
    <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE != <span class="hljs-number">0u</span>, <span class="hljs-string">"Chunk size must be more, than zero"</span>);
    <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE &lt;= <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;::max(),
        <span class="hljs-string">"Chunk size must be less or equal max value of the uint32_t"</span>);
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{<font></font>
        assert(size &lt; CHUNK_SIZE &amp;&amp; <span class="hljs-string">"Incorrect chunk size for future usage"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0u</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : m_chunks)<font></font>
        {<font></font>
            <span class="hljs-keyword">void</span>* allocated_block = chunk.tryReserveBlock(size);
            <span class="hljs-keyword">if</span> (allocated_block) <span class="hljs-comment">//if the block was not reserved, then memory in the chunk has run out</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> allocated_block;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        m_chunks.push_back(details::Chunk&lt;CHUNK_SIZE&gt;{});<font></font>
        <span class="hljs-keyword">auto</span>&amp; chunk = m_chunks.back();
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* allocated_block = chunk.tryReserveBlock(size);
        <span class="hljs-keyword">return</span> allocated_block;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* memory_ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-keyword">if</span> ( (!memory_ptr) || (size == <span class="hljs-number">0u</span>) )<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* deallocation_ptr = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(memory_ptr);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : m_chunks)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (chunk.isInside(deallocation_ptr))<font></font>
            {<font></font>
                chunk.releaseBlock(deallocation_ptr);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;details::Chunk&lt;CHUNK_SIZE&gt;&gt; m_chunks{ <span class="hljs-number">1u</span> };<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya wadah standar digunakan. </font><font style="vertical-align: inherit;">Saya setuju bahwa akan ada banyak alokasi dari heap. </font><font style="vertical-align: inherit;">Saya pikir bagi mereka yang akan menulis pengalokasi mereka, ini tidak akan dapat diterima. </font><font style="vertical-align: inherit;">Sebagai alternatif, tentu saja, Anda dapat menulis sendiri wadah atau menggunakan milik orang lain, dipertajam untuk kebutuhan tertentu, tetapi dalam implementasi ini saya mencoba menyajikan materi semudah mungkin, sehingga pilihan saya jatuh pada wadah standar.</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">namespace</span> details<font></font>
{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-title">getAlignmentPadding</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> not_aligned_address, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> alignment)</span>
    </span>{
        <span class="hljs-keyword">if</span> ( (alignment != <span class="hljs-number">0u</span>) &amp;&amp; (not_aligned_address % alignment != <span class="hljs-number">0u</span>) )<font></font>
        {<font></font>
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> multiplier = (not_aligned_address / alignment) + <span class="hljs-number">1u</span>;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> aligned_address = multiplier * alignment;
            <span class="hljs-keyword">return</span> aligned_address - not_aligned_address;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0u</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Current chunk implementation works only with size</span>
    <span class="hljs-comment">// aligned by 4 bytes, because HEADER_SIZE now also 4 bytes.</span>
    <span class="hljs-comment">// You can modify it with HEADER_SIZE without problems for your purposes.</span><font></font>
<font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE&gt;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chunk</span>
    {</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> HEADER_SIZE = <span class="hljs-number">4u</span>;
        <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE % HEADER_SIZE == <span class="hljs-number">0</span>, <span class="hljs-string">"CHUNK_SIZE must be multiple of the four"</span>);
        <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE &gt; HEADER_SIZE, <span class="hljs-string">"CHUNK_SIZE must be more than HEADER_SIZE"</span>);
    <span class="hljs-keyword">public</span>:<font></font>
        Chunk()<font></font>
        {<font></font>
            m_blocks.resize(CHUNK_SIZE);<font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* init_header = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(m_blocks.data());<font></font>
            *init_header = CHUNK_SIZE - HEADER_SIZE;<font></font>
            m_max_block = init_header;<font></font>
            m_free_blocks.insert(init_header);<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isInside</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* address)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
        </span>{
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* start_chunk_address = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(m_blocks.data());
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* end_chunk_address = start_chunk_address + CHUNK_SIZE;
            <span class="hljs-keyword">return</span> (start_chunk_address &lt;= address) &amp;&amp; (address &lt;= end_chunk_address);<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* <span class="hljs-title">tryReserveBlock</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> allocation_size)</span>
        </span>{
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> not_aligned_address = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt;(m_max_block) + allocation_size;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> alignment_padding = getAlignmentPadding(not_aligned_address, HEADER_SIZE);
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> allocation_size_with_alignment = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;(allocation_size + alignment_padding);
            <span class="hljs-keyword">if</span> ( (!m_max_block) || (allocation_size_with_alignment &gt; *m_max_block) ) <span class="hljs-comment">// Check on enaught memory for allocation</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-comment">// Find min available by size memory block</span>
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> min_it = <span class="hljs-built_in">std</span>::min_element(m_free_blocks.cbegin(), m_free_blocks.cend(), [allocation_size_with_alignment] (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* rhs)<font></font>
            {<font></font>
                <span class="hljs-keyword">if</span> (*rhs &lt; allocation_size_with_alignment)<font></font>
                {<font></font>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
                }<font></font>
                <font></font>
                <span class="hljs-keyword">return</span> (*lhs &lt; *rhs) &amp;&amp; (*lhs &gt;= allocation_size_with_alignment);<font></font>
            });<font></font>
            <font></font>
            assert(min_it != m_free_blocks.cend() &amp;&amp; <span class="hljs-string">"Internal logic error with reserve block, something wrong in implementation..."</span>);<font></font>
            assert(**min_it &gt;= allocation_size_with_alignment &amp;&amp; <span class="hljs-string">"Internal logic error with reserve block, something wrong in implementation..."</span>);<font></font>
            <font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* header_address = *min_it;
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* new_header_address =
                <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(header_address) + HEADER_SIZE + allocation_size_with_alignment);
            <span class="hljs-keyword">if</span> (m_free_blocks.find(new_header_address) == m_free_blocks.cend()) <span class="hljs-comment">// check if there is free memory in the current block</span><font></font>
            {<font></font>
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> old_block_size = *header_address;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> difference = old_block_size - HEADER_SIZE;
                <span class="hljs-keyword">if</span> (difference &gt;= allocation_size_with_alignment) <span class="hljs-comment">// check if there is enough space for another block</span><font></font>
                {<font></font>
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> new_block_size = difference - allocation_size_with_alignment;<font></font>
                    *new_header_address = new_block_size;<font></font>
                    m_free_blocks.insert(new_header_address);<font></font>
                }<font></font>
            }<font></font>
            <font></font>
            m_free_blocks.erase(header_address);<font></font>
            *header_address = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;(allocation_size);
            <span class="hljs-keyword">if</span> (header_address == m_max_block) <span class="hljs-comment">// if the maximum block were changed, then need to find the maximum block again</span><font></font>
            {<font></font>
                <span class="hljs-comment">// Find max block by size</span>
                <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> max_it = <span class="hljs-built_in">std</span>::max_element(m_free_blocks.cbegin(), m_free_blocks.cend(), [] (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* rhs)<font></font>
                {<font></font>
                    <span class="hljs-keyword">return</span> (*lhs) &lt; (*rhs);<font></font>
                });<font></font>
                <font></font>
                <span class="hljs-comment">// If there are no free blocks, therefore the memory in this chunk is over</span>
                m_max_block = (max_it != m_free_blocks.cend()) ? (*max_it) : (<span class="hljs-literal">nullptr</span>);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(header_address) + HEADER_SIZE;<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">releaseBlock</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* block_ptr)</span>
        </span>{
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* header_address = block_ptr - HEADER_SIZE;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> size_relized_block = *header_address;
            <span class="hljs-keyword">if</span> ( (!m_max_block) || (size_relized_block &gt; *m_max_block) ) <span class="hljs-comment">// if the relized block is greater than the maximum, then need to replace it</span><font></font>
            {<font></font>
                m_max_block = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address);<font></font>
            }<font></font>
                <font></font>
            m_free_blocks.insert(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address));
            <span class="hljs-keyword">auto</span> forward_it = m_free_blocks.find(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address));
            <span class="hljs-keyword">auto</span> backward_it = tryDefragment(forward_it, m_free_blocks.end());<font></font>
            tryDefragment(<span class="hljs-built_in">std</span>::make_reverse_iterator(backward_it), m_free_blocks.rend());<font></font>
        }<font></font>
    <span class="hljs-keyword">private</span>:
        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> DstIterator, <span class="hljs-keyword">typename</span> SrcIterator&gt;
        <span class="hljs-keyword">constexpr</span> DstIterator <span class="hljs-title">getIterator</span><span class="hljs-params">(SrcIterator it)</span> <span class="hljs-keyword">const</span>
        </span>{
            <span class="hljs-keyword">using</span> iterator = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::iterator;
            <span class="hljs-keyword">using</span> reverse_iterator = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::reverse_iterator;
            <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">( (<span class="hljs-built_in">std</span>::is_same_v&lt;SrcIterator, iterator&gt;) &amp;&amp; (<span class="hljs-built_in">std</span>::is_same_v&lt;DstIterator, reverse_iterator&gt;) )</span>
            </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_reverse_iterator(it);<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">constexpr</span> ( (<span class="hljs-built_in">std</span>::is_same_v&lt;SrcIterator, reverse_iterator&gt;) &amp;&amp; (<span class="hljs-built_in">std</span>::is_same_v&lt;DstIterator, iterator&gt;) )<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> it.base();<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> it;<font></font>
            }<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;
        Iterator <span class="hljs-title">tryDefragment</span><span class="hljs-params">(Iterator start_it, Iterator end_it)</span>
        </span>{
            <span class="hljs-comment">// primitive defragmentation algorithm - connects two neighboring</span>
            <span class="hljs-comment">// free blocks into one with linear complexity</span><font></font>
   <font></font>
            <span class="hljs-keyword">auto</span> current_it = start_it++;
            <span class="hljs-keyword">auto</span> next_it = start_it;
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* current_header_address = *current_it;
            <span class="hljs-keyword">if</span> ( (current_it != end_it) &amp;&amp; (next_it != end_it) )<font></font>
            {<font></font>
                <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* next_header_address = *next_it;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> current_block_size = *current_header_address;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* available_current_block_address =
                    <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(current_header_address) + HEADER_SIZE + current_block_size);
                <span class="hljs-keyword">if</span> (available_current_block_address == next_header_address)<font></font>
                {<font></font>
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> next_block_size = *next_header_address;
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> new_current_block_size = current_block_size + HEADER_SIZE + next_block_size;<font></font>
                    *current_header_address = new_current_block_size;<font></font>
                    <span class="hljs-keyword">if</span> (new_current_block_size &gt; *m_max_block)<font></font>
                    {<font></font>
                        m_max_block = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(current_header_address);<font></font>
                    }<font></font>
                            <font></font>
                    <span class="hljs-keyword">auto</span> delete_it = getIterator&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::iterator&gt;(next_it);
                    <span class="hljs-keyword">return</span> getIterator&lt;Iterator&gt;(m_free_blocks.erase(delete_it));<font></font>
                }<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-keyword">return</span> current_it;<font></font>
        }<font></font>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt; m_blocks;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt; m_free_blocks;
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* m_max_block;<font></font>
    };<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang sedikit tentang bagaimana Anda dapat menghias penggunaan pengalokasi bersama dengan wadah standar: </font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE = <span class="hljs-number">16'384u</span>&gt;
<span class="hljs-keyword">using</span> CustomAllocator = Allocator&lt;T, CustomAllocationStrategy&lt;CHUNK_SIZE&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> CustomAllocatorWithStackChunks = Allocator&lt;T, CustomAllocationStrategy&lt;<span class="hljs-number">1'024u</span>&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> CustomAllocatorWithHeapChunks = Allocator&lt;T, CustomAllocationStrategy&lt;<span class="hljs-number">16'384u</span>&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_vector = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_list = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;T, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_set = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;T, <span class="hljs-built_in">std</span>::less&lt;T&gt;, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_unordered_set = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_set</span>&lt;T, <span class="hljs-built_in">std</span>::hash&lt;T&gt;, <span class="hljs-built_in">std</span>::equal_to&lt;T&gt;, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-keyword">using</span> custom_map = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;K, V, <span class="hljs-built_in">std</span>::less&lt;K&gt;, CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">const</span> K, V&gt;&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-keyword">using</span> custom_unordered_map = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;K, <span class="hljs-built_in">std</span>::hash&lt;K&gt;, <span class="hljs-built_in">std</span>::equal_to&lt;K&gt;, CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">const</span> K, V&gt;&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">using</span> custom_string = <span class="hljs-built_in">std</span>::basic_string&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">std</span>::char_traits&lt;<span class="hljs-keyword">char</span>&gt;, CustomAllocator&lt;<span class="hljs-keyword">char</span>&gt;&gt;;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda juga dapat menggunakan pengalokasi dengan pointer pintar, tetapi untuk ini Anda harus menulis layer kecil: </font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_unique_ptr = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;T, <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(T*)&gt;&gt;;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Allocator, <span class="hljs-keyword">typename</span> T </span>= <span class="hljs-keyword">typename</span> Allocator::value_type, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-function">custom_unique_ptr&lt;T&gt; <span class="hljs-title">make_custom_unique</span><span class="hljs-params">(Allocator allocator, Args&amp;&amp;... args)</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> custom_deleter = [allocator](T* ptr) <span class="hljs-keyword">mutable</span><font></font>
    {<font></font>
        allocator.destroy(ptr);<font></font>
        allocator.deallocate(ptr, <span class="hljs-number">1u</span>);<font></font>
    };<font></font>
        <font></font>
    <span class="hljs-keyword">void</span>* memory_block = allocator.allocate(<span class="hljs-number">1u</span>);
    <span class="hljs-keyword">if</span> (memory_block)<font></font>
    {<font></font>
        T* object_block = <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(memory_block);<font></font>
        allocator.construct(object_block, <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...);
        <span class="hljs-keyword">return</span> custom_unique_ptr&lt;T&gt;{ object_block, custom_deleter };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nah dan sekarang, akhirnya, contoh menggunakan semua ini:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span>
</span>{<font></font>
    CustomAllocationStrategy allocation_area{};<font></font>
<font></font>
    CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt; custom_int_allocator{ allocation_area };<font></font>
    custom_vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">vector</span>{ custom_int_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0u</span>; i &lt; <span class="hljs-number">100</span>; ++i)<font></font>
    {<font></font>
        <span class="hljs-built_in">vector</span>.push_back(i);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">vector</span>.at(i) &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-built_in">vector</span>.resize(<span class="hljs-number">16u</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : <span class="hljs-built_in">vector</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
<font></font>
CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt; custom_int_allocator_copy = <span class="hljs-built_in">vector</span>.get_allocator();<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr1 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">100</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr2 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">500</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr3 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">1000</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr4 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">1500</span>);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *ptr1 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr2 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr3 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr4 &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-keyword">float</span>&gt; custom_float_allocator { custom_int_allocator };<font></font>
    custom_list&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-built_in">list</span>{ { <span class="hljs-number">10.0f</span>, <span class="hljs-number">11.0f</span>, <span class="hljs-number">12.0f</span>, <span class="hljs-number">13.0f</span>, <span class="hljs-number">14.0f</span>, <span class="hljs-number">15.0f</span> }, custom_float_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">float</span> val : <span class="hljs-built_in">list</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; custom_pair_allocator{ allocation_area };<font></font>
    custom_map&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt; <span class="hljs-built_in">map</span>{ { { <span class="hljs-number">1.0</span>, <span class="hljs-number">100.0</span> }, { <span class="hljs-number">2.0</span>, <span class="hljs-number">200.0</span> } }, custom_pair_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; it : <span class="hljs-built_in">map</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"{"</span> &lt;&lt; it.first &lt;&lt; <span class="hljs-string">" : "</span> &lt;&lt; it.second &lt;&lt; <span class="hljs-string">"} "</span>;<font></font>
    }<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-keyword">double</span>&gt; custom_double_allocator{ allocation_area };<font></font>
    custom_set&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-built_in">set</span>{ { <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">3000.0</span> }, custom_double_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">double</span> val : <span class="hljs-built_in">set</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
<font></font>
    CustomAllocator&lt;<span class="hljs-keyword">char</span>&gt; custom_char_allocator{ allocation_area };<font></font>
    custom_string string1{ <span class="hljs-string">"First allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string string2{ <span class="hljs-string">"Second allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string string3{ <span class="hljs-string">"Third allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string result_string = string1 + string2 + string3;<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; result_string;<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya ingin fokus pada kenyataan bahwa implementasi ini adalah yang paling primitif, tetapi dapat dengan mudah diperluas ke arah yang Anda butuhkan, jadi semuanya ada di tangan Anda!</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terima kasih atas perhatiannya, semoga artikel ini bermanfaat bagi seseorang. </font><font style="vertical-align: inherit;">Saya juga berharap semua orang sukses dalam interaksi mereka yang dekat dengan memori, dan yang paling penting, jangan lupa kata-kata yang sangat penting dari Donald Knuth: " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimalisasi prematur adalah akar dari semua kejahatan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ." </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tautkan ke </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositori</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan implementasi penuh dari pengalokasi.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber yang digunakan</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/en/post/274827</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/mtrebi/memory-allocators</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id505614/index.html">Suku bunga deposito bank terbesar jatuh ke minimum historis: bagaimana ini mempengaruhi ekonomi, dan di mana pertukaran</a></li>
<li><a href="../id505616/index.html">Pengakuan alfabet Rusia: dari mengumpulkan dataset hingga membuat GUI</a></li>
<li><a href="../id505618/index.html">Templat GRASP: Pembuat</a></li>
<li><a href="../id505620/index.html">HackTheBox. Walkthrough Nest. NTFS stream, membalikkan C # dan SMB walker</a></li>
<li><a href="../id505624/index.html">Bagaimana cara memproses bingkai data dengan miliaran catatan dalam hitungan detik?</a></li>
<li><a href="../id505634/index.html">Pengaturan Proxy untuk WSL (Ubuntu)</a></li>
<li><a href="../id505640/index.html">Objektivitas Peringkat Publikasi</a></li>
<li><a href="../id505642/index.html">Coroutine transparan</a></li>
<li><a href="../id505644/index.html">Pemegang hak cipta mencoba: Pelajaran video musik YouTube dengan penguraian lagu orang lain mungkin hilang</a></li>
<li><a href="../id505648/index.html">Dua kesalahan Einstein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>