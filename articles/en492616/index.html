<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔 👩🏾‍🏭 💘 Packer, Terraform and Ansible: Kubernetes cluster deployment in an hour 👩🏿‍🎨 👩🏿‍💼 ♠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, my name is Andrey Schukin, I help large companies migrate services and systems to the CROC Cloud. Together with colleagues from Southbridge, which...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Packer, Terraform and Ansible: Kubernetes cluster deployment in an hour</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/croccloudteam/blog/492616/"><img src="https://habrastorage.org/webt/0m/2c/zt/0m2cztx1saqv1v7e8a3mrliht_k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hi, my name is Andrey Schukin, I help large companies migrate services and systems to the CROC Cloud. Together with colleagues from Southbridge, which runs Kubernetes courses at the Slerm training center, we recently conducted a webinar for our customers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I decided to take materials from an excellent lecture by Pavel Selivanov and write a post for those who are just starting to work with cloud provisioning tools and don’t know where to start. Therefore, I will talk about the stack of technologies that are used in our training and production of CROC Cloud. Let's talk about modern approaches to infrastructure management, about a bunch of Packer, Terraform and Ansible components, as well as about the Kubeadm tool with which we will install.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Under the cut will be a lot of text and configs. </font><font style="vertical-align: inherit;">There is a lot of material, so I added post navigation. </font><font style="vertical-align: inherit;">We also prepared a small repository where we put everything we needed for our training deployment. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not give chickens names. </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baked cakes are more healthy than fried ones. </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We start the oven. </font><font style="vertical-align: inherit;">Packer </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terraform - infrastructure as code </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Launch Terraform </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cluster structure Kubernetes </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubeadm </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository with all files</font></font></a><br>
 <a name="habracut"></a><br>
<a name="1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not give names to chickens</font></font></h2><br>
<img src="https://habrastorage.org/webt/j0/0w/v1/j00wv1h7pcevviakk2iocfleqjk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are many different concepts of infrastructure management. One of them is called Pets vs. Cattle, that is, "pets against livestock." This concept describes two opposing approaches to infrastructure. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagine we have a favorite dog. We take care of her, take him to the veterinarian, comb out the fur, and in general it is unique to us among many other dogs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In another case, we have a chicken coop. We also take care of chickens, feed, heat and try to create the most comfortable conditions. Nevertheless, chickens are a rather faceless resource for us, which fulfills its function of laying eggs, and at best we designate them as "that powdered black that always pecks cement." If the chicken stops laying eggs or breaks its paw, then most likely it will simply provide us with a delicious broth for lunch. In fact, we do not care about the fate of an individual chicken, but about the chicken coop as a whole as a production line. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In IT, a similar approach began to be applied as soon as tools appeared that lowered the entry threshold for engineers and made it possible to deploy and maintain complex clusters in a fully automatic mode.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Previously, we had a small number of servers that were monitored, tuned manually and looked after in every possible way. In monitoring, logs from the Cthulhu, Aylith, and Dagon servers flashed. Traditions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then virtualization firmly entered our lives, and the names from the works of Lovecraft and Star Trek gave way to the more utilitarian “vlg-vlt-vault01.company.ru”. There are a lot of servers, but we still raised the services more or less manually, eliminating the problems on each machine if necessary.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now the approach to maintaining the infrastructure completely coincides with programming. </font><font style="vertical-align: inherit;">We add another level of abstraction and stop bothering about individual nodes. </font><font style="vertical-align: inherit;">Each one has a faceless index instead of a name, and in case of a problem the virtual machine simply kills and rises from the working snapshot. </font><font style="vertical-align: inherit;">There are tools that allow you to implement this approach. </font><font style="vertical-align: inherit;">In our case, the first tool is the CROC Cloud, the second is Terraform.</font></font><br>
<br>
<a name="2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baked cakes are healthier than fried</font></font></h2><br>
<img src="https://habrastorage.org/webt/hs/pp/oa/hsppoaujv0lhrk0u3dt6ust0rry.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In infrastructure management there is a contrast between the two approaches Fried vs. Baked, that is, “fried against baked”. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Fried approach implies that you have a vanilla OS image, for example, CentOS 7. Then, after deploying the OS, we use the configuration management system in order to bring the system to the target state. For example, using Ansible, Chef, Puppet or SaltStack.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything works fine, especially when there are not very many servers. When there is a need for a massive deployment, we are faced with performance issues. Hundreds of servers synchronously begin to devour network resources, CPU, RAM and IOPS in the process of rolling many new packages. Moreover, this process can be delayed for a rather long time. In short, the circuit is absolutely operational, but not so interesting from the point of view of minimizing downtime during accidents.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Baked approach implies that you have ready-made “baked” OS images on which you have already installed all the necessary packages, configured the configuration and everything else. </font><font style="vertical-align: inherit;">At the output, we have an abstract snapshot template, sharpened for the performance of some function. </font><font style="vertical-align: inherit;">Deploying infrastructure from such baked images takes significantly less time and reduces downtime to a minimum. </font><font style="vertical-align: inherit;">A very similar ideology is used in multi-layer Docker images, in which no one pokes his hands unnecessarily. </font><font style="vertical-align: inherit;">Nailed the container - picked up a new one.</font></font><br>
<br>
<a name="3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We start the oven. </font><font style="vertical-align: inherit;">Packer</font></font></h2><br>
<img src="https://habrastorage.org/webt/xw/mr/im/xwmrimtkl-6qvfcrae3xo4zdf7q.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our infrastructure, we use several Hashicorp products, some of which turned out to be extremely successful. Let's start our magic with preparing and baking an image using the Packer tool. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Packer uses a JSON Template, that is, template files that contain a description of what needs to be obtained as a “baked” virtual machine (VM). After creating the template, the file is transferred to Packer, and the necessary permissions for creating the server in the cloud are configured. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Packer allows you to raise VMs locally in KVM, VirtualBox, Vagrant, AWS, GCP, Alibaba Cloud, OpenStack, etc. It is convenient to work with Packer in the CROC Cloud, since it implements AWS interfaces, that is, all the tools that are written for AWS, work with the CROC Cloud.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After setting the necessary templates, Packer raises VM CROC in the Cloud, waits for it to start, and then the “provider” enters the work - provisioner: a utility that must complete image preparation. </font><font style="vertical-align: inherit;">In our case, this is Ansible, although Packer can work with other options. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When the VM is ready, Packer creates its image and places it in the CROC Cloud so that other VMs can be launched from the same image.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Base.json structure</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the beginning of the file there is a section in which variables are declared:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"variables" : {<font></font>
 "source_ami_name": "{{env SOURCE_AMI_NAME}}",<font></font>
 "ami_name": "{{env AMI_NAME}}",<font></font>
 "instance_type": "{{env INSTANCE_TYPE}}",<font></font>
 "kubernetes_version": "{{env KUBERNETES_VERSION}}",<font></font>
 "docker_version": "{{env DOCKER_VERSION}}",<font></font>
 "subnet_id": "",<font></font>
 "availability_zone": "",<font></font>
},</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main set of these variables will be set from the settings.json file. </font><font style="vertical-align: inherit;">And those variables that change frequently are more convenient to set from the console when starting Packer and building a new image. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following is the Builders section:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"builders" : [<font></font>
 {<font></font>
  "type": "amazon-ebs",<font></font>
  "region": "croc",<font></font>
  "skip_region_validation": true,<font></font>
  "custom_endpoint_ec2": "https://api.cloud.croc.ru",<font></font>
  "source_ami": "",<font></font>
  "source_ami_filter": {<font></font>
   "filters": {<font></font>
    "name": "{{user `source_ami_name`}}"<font></font>
    "state": "available",<font></font>
    "virtualization-type": "kvm-virtio"<font></font>
     },<font></font>
...</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Target clouds and the VM startup method are described here. Please note that in this case the amazon-ebs type is declared, but for Packer to work with the CROC Cloud, the corresponding address in custom_endpoint_ec2 is set. Our infrastructure has an API that is almost completely compatible with Amazon Web Services, so if you have ready-made developments for this platform, then for the most part you will only need to specify a custom API entry point - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">api.cloud.croc.ru</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in our example.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is worth noting the source_ami_filter section separately. </font><font style="vertical-align: inherit;">Here the initial image of the VM is set, in which the necessary changes will be made. </font><font style="vertical-align: inherit;">However, Packer requires an AMI for this image, i.e. its random identifier. </font><font style="vertical-align: inherit;">Since this identifier is rarely known in advance and changes with each update, the source AMI is set not as a specific value, but as a variable source_ami_filter. </font><font style="vertical-align: inherit;">In this case, the determining parameter of the filter is the name of the image. </font><font style="vertical-align: inherit;">This name is set in the variables through the settings.json file. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, the VM settings are defined: the type of instance, processor, memory size, allocated space, etc. are specified:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"instance_type": "{{user `instance_type`}}",<font></font>
"launch_block_device_mappings": [<font></font>
 {<font></font>
  "device_name": "disk1",<font></font>
  "volume_type": "io1",<font></font>
  "volume_size": "8",<font></font>
  "iops": "1000",<font></font>
  "delete_on_termination": "true"<font></font>
 }<font></font>
],</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Following in base.json are the parameters for connecting to this VM:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"availability_zone": "{{user `availability_zone`}}",<font></font>
"subnet_id": "{{user `subnet_id`}}",<font></font>
"associate_public_ip_address": true,<font></font>
"ssh_username": "ec2-user",<font></font>
"ami_name": "{{user `ami_name`}}"<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is important to note the subnet_id parameter here. </font><font style="vertical-align: inherit;">It must be set manually, because without specifying the VM subnet in the CROC Cloud it is impossible to create. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another parameter that requires prior preparation is associate_public_ip_address. </font><font style="vertical-align: inherit;">You need to select a white IP address, because after creating the VM Packer will begin to apply the necessary settings through Ansible. </font><font style="vertical-align: inherit;">In this case, Ansible connects to the VM via SSH, which requires a white IP address or VPN. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The last section is the Provisioners:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"provisioners": [<font></font>
 {<font></font>
  "type": "ansible",<font></font>
  "playbook_file": "playbook.yml",<font></font>
  "extra_arguments": [<font></font>
   "--extra-vars",<font></font>
   "kubernetes_version={{user `kubernetes_version`}}",<font></font>
   "--extra-vars",<font></font>
   "docker_version={{user `docker_version`}}"<font></font>
   ]<font></font>
  }<font></font>
]</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These are the providers, that is, the utilities with which Packer configures the server. </font><font style="vertical-align: inherit;">In this case, ansible type provider is used. </font><font style="vertical-align: inherit;">The following is the playbook_file parameter, which defines the Ansible roles and the hosts on which the specified roles will be applied. </font><font style="vertical-align: inherit;">Additional options extra_arguments are presented below, which, when starting Ansible, transmit versions of Kubernetes and Docker.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CROC Cloud Preparation</font></font></h3><br>
 <img src="https://habrastorage.org/webt/23/_s/uo/23_suoef0us5ia6kjgn8xteomba.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to our configuration files, we need to do a few things from the side of the cloud control panel so that all the magic works. </font><font style="vertical-align: inherit;">We need to select a white IP and create a working subnet, which we will use when deploying.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Click Highlight Address. </font><font style="vertical-align: inherit;">Packer will find the desired white IP address on its own.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Click Create Subnet and specify a subnet and mask. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Copy the subnet ID. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insert this value into the subnet_id parameter of the Packer startup command. </font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/24/0w/gp/240wgpvzi8oyy6ixwzdj8cougqk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then run Packer. </font><font style="vertical-align: inherit;">He finds the original VM image, deploys it in the CROC Cloud, and performs the Ansible role on it. </font><font style="vertical-align: inherit;">The new VM can be seen in the CROC Cloud in the "Instances" section. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ol/aj/ui/olajuiprqljv50bi2opn4xlqcvs.png"> <br>
 <br>
<img src="https://habrastorage.org/webt/rq/0d/ri/rq0drint5cwvddjxbd7czcyfp9a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After finishing work, Packer removes the VM from the cloud and leaves a ready-made image in its place, which can be found in the "Templates" section. </font><font style="vertical-align: inherit;">The entire Kubernetes infrastructure will be created from this image.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ansible</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As mentioned earlier, the playbook parameter is passed in the parameters of the Ansible provider. </font><font style="vertical-align: inherit;">The playbook.yml file itself looks like this:</font></font><br>
<br>
<pre><code class="plaintext hljs">- hosts: all<font></font>
  become: true<font></font>
<font></font>
  roles:<font></font>
  | - base</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The file transfers to Ansible that on all hosts it is necessary to fulfill the role of base. </font><font style="vertical-align: inherit;">If there are other roles, you can add them to the same file as a list. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The base role allows you to get a ready-made cluster with a single command. </font><font style="vertical-align: inherit;">The main.yml file shows what exactly this role does:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adds a Docker repository to the system template. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adds the Kubernetes repository to the system template. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installs the necessary packages. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creates a directory for configuring the Docker daemon. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configures the machine according to the daemon.json.j2 configuration file. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loads the br_netfilter kernel.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Includes the necessary options for br_netfilter.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Includes Docker and Kubelet components.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Runs Docker in VM.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Runs a command that downloads the Docker images necessary for Kubernetes to work.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, the installed packages are set in the main.yml file from the vars directory. </font><font style="vertical-align: inherit;">In our case, we install the docker-ce package, as well as the three packages necessary for Kubernetes to work: kubelet, kubeadm and kubectl.</font></font><br>
<br>
<a name="4"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terraform - infrastructure as code</font></font></h2><br>
<img src="https://habrastorage.org/webt/o4/um/wi/o4umwitq-qh_zpwr0thmcmejis0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terraform is a very functional tool from HashiCorp for cloud orchestration. It has its own specific HCL language, which is often used in other products of the company, for example, in HashiCorp Vault and Consul. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The basic principle is similar to all configuration management systems. You simply indicate the target state in the desired format, and the system calculates the algorithm of how to achieve this. Another thing is that, unlike the same Ansible, which works as a black box on complex playbooks, Terraform can issue a plan of future actions in a form convenient for analysis. This is important when planning complex infrastructure changes. After planning the necessary actions, run the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terraform apply</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">and Terraform will deploy the infrastructure described in the files.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Like Packer, this tool supports AWS, GCP, Alibaba Cloud, Azure, OpenStack, VMware, etc.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We describe the project</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Terraform directory has a set of files with the extension .tf. </font><font style="vertical-align: inherit;">These files describe the components of the infrastructure with which we will work. </font><font style="vertical-align: inherit;">Break the project into functional modules. </font><font style="vertical-align: inherit;">Such a structure makes it easier to control versioning and assemble each project from ready-made convenient blocks. </font><font style="vertical-align: inherit;">For our option, the following structure is suitable:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.tf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">network.tf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">security_groups.tf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">master.tf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">master.tpl</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Main.tf file structure</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start with the main.tf file, in which access to the cloud is configured. </font><font style="vertical-align: inherit;">In particular, several parameters are announced that configure Terraform to work with the CROC Cloud:</font></font><br>
<br>
<pre><code class="plaintext hljs">provider "aws" {<font></font>
 endpoints {<font></font>
  ec2 = "https://api.cloud.croc.ru"<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, the file describes that Terraform must independently create a private key and upload its public part to all servers. </font><font style="vertical-align: inherit;">The private key itself is issued at the end of Terraform:</font></font><br>
<br>
<pre><code class="plaintext hljs">resource "tls_private_key" "ssh" {<font></font>
 algorithm = "RSA"<font></font>
}<font></font>
resource "aws_key_pair" "kube" {<font></font>
 key_name = "terraform"<font></font>
 public_key = "${tls_private_key.ssh.public_key_openssh}"<font></font>
}<font></font>
output "ssh" {<font></font>
value = "${tls_private_key.ssh.private_key_pem}"<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The structure of the network.tf file</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This file describes the network components needed to start the VM:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">data "aws_availability_zones" "az" {<font></font>
 state = "available"<font></font>
}<font></font>
resource "aws_vpc" "kube" {<font></font>
 cidr_block = "${var.vpc_cidr}"<font></font>
}<font></font>
resource "aws_eip" "master" {<font></font>
 count = "1"<font></font>
 vpc = true<font></font>
}<font></font>
resource "aws_subnet" "private" {<font></font>
 vpc_id = "${aws_vpc.kube.id}"<font></font>
 count = "${length(data.aws_availability_zones.az.names)}"<font></font>
 cidr_block = "${var.private_subnet_cidr_list[count.index]}"<font></font>
 availability_zone = "${data.aws_availability_zones.az.names[count.index]}"<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terraform uses two types of components:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resource - what needs to be created;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data - what you need to get.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, the data parameter indicates that Terraform should receive the availability zones of the specified cloud, which are in the available state. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first parameter resource describes the creation of a virtual private cloud, and the next parameter describes the creation of Elastic IP Address. For the Kubernetes cluster, we order this IP address through Terraform. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Further, in each of the accessibility zones, and at the moment CROC has two cloud services, its own subnet is created. A resource of type aws_subnet is declared, and the ID of the aws_vpc generated is passed as part of this parameter. But, since the ID of this resource is still unknown, we specify the aws_vpc.kube.id parameter, which refers to the created resource and substitutes the value from the ID field.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the number of created subnets is determined by the number of cloud availability zones and this number can change over time, this parameter is set through the length variable (data.aws_availability_zones.az.names), i.e. the length of the list of access zones received through the data parameter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The last two parameters are cidr_block (the allocated subnet) and the availability zone in which this subnet is created. </font><font style="vertical-align: inherit;">The last parameter is also set via a variable that takes a value from the data list according to the index of the loop declared by </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[count.index]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Security_groups.tf file structure</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Security groups are a kind of firewall for clouds, which can be created not inside the VM itself, but by the cloud. </font><font style="vertical-align: inherit;">In this case, the firewall describes two rules. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first rule creates a security group called kube. </font><font style="vertical-align: inherit;">This security group is needed to allow all outgoing traffic from Kubernetes nodes, allowing the nodes to freely access the Internet. </font><font style="vertical-align: inherit;">Inbound traffic to Kubernetes nodes from the subnets of the nodes themselves is also allowed. </font><font style="vertical-align: inherit;">Thus, Kubernetes nodes can work among themselves without restrictions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second rule creates the ssh security group. </font><font style="vertical-align: inherit;">It allows SSH connection from any IP address to port 22 of the Kubernetes cluster VM:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">resource "aws_security_group" "kube" {<font></font>
 vpc_id = "${aws_vpc.kube.id}"<font></font>
 name   = "kubernetes"<font></font>
 # Allow all outbound<font></font>
 egress {<font></font>
  from_port = 0<font></font>
  to_port = 0<font></font>
  protocol = "-1"<font></font>
  cidr_blocks = ["0.0.0.0/0"]<font></font>
 }<font></font>
 # Allow all internal<font></font>
 ingress {<font></font>
  from_port = 0<font></font>
  to_port = 0<font></font>
  protocol = "-1"<font></font>
  cidr_blocks = ["${var.vpc_cidr}"]<font></font>
 }<font></font>
}<font></font>
resource "aws_security_group" "ssh" {<font></font>
 vpc_id = "${aws_vpc.kube.id}"<font></font>
 name   = "ssh"<font></font>
<font></font>
 # Allow all inbound<font></font>
 ingress {<font></font>
  from_port = 22<font></font>
  to_port = 22<font></font>
  protocol = "tcp"<font></font>
  cidr_blocks = ["0.0.0.0/0"]<font></font>
 }<font></font>
}</code></pre><br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Master node. </font><font style="vertical-align: inherit;">Master.tf file structure</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The master.tf file describes the creation of several templates and instances. </font><font style="vertical-align: inherit;">In particular, a Kubernetes master instance is being created. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The ami variable sets the AMI of the source image for the VM. </font><font style="vertical-align: inherit;">The following describes the type of VM and the subnet in which it is created. </font><font style="vertical-align: inherit;">When defining a subnet, a cycle is again used to create VMs in each availability zone. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, the used security groups and the key that was specified in the main.tf file are declared. </font><font style="vertical-align: inherit;">The user_data field contains the execution of a set of cloud-init scripts, the results of which will be implemented in the VM:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">resource "aws_instance" "master" {<font></font>
 count = "1"<font></font>
 ami = "${var.kubernetes_ami}"<font></font>
 instance_type = "c3.large"<font></font>
 disable_api_termination = false<font></font>
 instance_initiated_shutdown_behavior = "terminate"<font></font>
 source_dest_check = false<font></font>
 subnet_id = "${aws_subnet.private.*.id[count.index % length(data.aws_availability_zones.az.names)]}"<font></font>
 associate_public_ip_address = true<font></font>
 vpc_security_group_ids = [<font></font>
  "${aws_security_group.ssh.id}",<font></font>
  "${aws_security_group.kube.id}",<font></font>
 ]<font></font>
 key_name = "${aws_key_pair.kube.key_name}"<font></font>
 user_data = "${data.template_cloudinit_config.master.rendered}"<font></font>
 monitoring = "true"<font></font>
}</code></pre><br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Master node. </font><font style="vertical-align: inherit;">Cloud init</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud-init</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a tool that Canonical is developing. </font><font style="vertical-align: inherit;">It allows you to automatically execute in a cloud infrastructure a certain set of commands after starting a VM. </font><font style="vertical-align: inherit;">Terraform has mechanisms for </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">integrating with it using templates</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since it is impossible to “bake” everything necessary in the VM, after starting, depending on its type, it must either join the Kubernetes cluster or initialize the Kubernetes cluster. </font><font style="vertical-align: inherit;">In the cloud-init file template called master.tpl, several actions are performed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Configuration files for Kubeadm are recorded:</font></font><br>
<br>
<pre><code class="plaintext hljs">#cloud-config<font></font>
<font></font>
    write_files:<font></font>
    - path: etc/kubernetes/kubeadm.conf<font></font>
      owner: root:root<font></font>
      content:<font></font>
    ...</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. A set of commands is executed:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the IP address of the wizard is written to the generated configuration file;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the master in the Kubernetes cluster is initialized with the kubeadm init command;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the Kubernetes cluster, the Calico overlay network is installed with the kubectl apply command.</font></font></li>
</ul><br>
 <pre><code class="plaintext hljs">runcmd:<font></font>
         - sed -i "s/CONTROL_PLANE_IP/$(curl http://169.254.169.254/latest/meta-data-local-ipv4)/g" /etc/kubernetes/kubeadm.conf<font></font>
         - kubeadm init --config /etc/kubernetes/kubeadm.conf<font></font>
         - mkdir -p $HOME/.kube<font></font>
         - sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<font></font>
         - sudo chown $(id -u):$(id -g) $HOME/.kube/config<font></font>
         - kubectl apply -f https://docs.projectcalico.org/v3.8/manifests/calico.yaml</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After executing the commands when starting the VM, a working Kubernetes cluster is obtained from one master node. </font><font style="vertical-align: inherit;">The remaining nodes will join this master node.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ordinary nodes. </font><font style="vertical-align: inherit;">node.tf</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The node.tf file is similar to the master.tf file. </font><font style="vertical-align: inherit;">Resources are also created here, which in this case are called node. </font><font style="vertical-align: inherit;">The only difference is that the master node is created in a single instance, and the number of working nodes created is set via the nodes_count variable:</font></font><br>
<br>
<pre><code class="plaintext hljs">resource "aws_instance" "node" {<font></font>
 count = "${var.nodes_count}"<font></font>
 ami = "${var.kubernetes_ami}"<font></font>
 instance_type = "c3.large"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The cloud-init file for working nodes executes only one command - kubeadm join. </font><font style="vertical-align: inherit;">This command attaches the finished machine to the Kubernetes cluster using the authorization token that we send.</font></font><br>
<br>
<a name="5"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Launch Terraform</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When launched, Terraform uses several modules:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AWS module</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">template module;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLS module responsible for key generation. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These modules must be installed on the local machine:</font></font><br>
<br>
<pre><code class="plaintext hljs">terraform init terraform/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Together with this command, the directory in which all the necessary files are located is indicated. </font><font style="vertical-align: inherit;">When initializing, Terraform downloads all the specified modules, after which you need to execute the terraform plan command:</font></font><br>
<br>
<pre><code class="plaintext hljs">terraform plan -var-file terraform/vars/dev.tfvars terraform/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Please note that in addition to the directory with the Terraform files, the var-file is indicated, which contains the values ​​of the variables used in the Terraform files. </font><font style="vertical-align: inherit;">The vars directory can contain multiple .tfvars files, which allows you to manage different types of infrastructures with one set of Terraform files. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The dev.tfvars file itself contains the following important variables:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes_version (installable version of Kubernetes);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes_ami (AMI image that Packer created). </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After setting the necessary values ​​of the variables, run the terraform plan command, after which Terraform will present a list of actions necessary to achieve the state described in the Terraform files. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After checking this list, apply the proposed changes: </font></font><br>
<br>
<code>terraform apply -auto-approve -var-file terraform/vars/dev.tfvars terraform/</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From the terraform plan command, it is distinguished by the presence of a key - auto-approve, which eliminates the need to confirm the changes made. </font><font style="vertical-align: inherit;">You can omit this key, but then each action will need to be confirmed manually.</font></font><br>
<br>
<a name="6"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes Cluster Structure</font></font></h2><br>
<img src="https://habrastorage.org/webt/zs/i-/c3/zsi-c326-ips2acfurg_trunzhm.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Kubernetes cluster consists of a master node that performs management functions and working nodes that run applications installed in the cluster. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Four components are installed on the master node that ensure the operation of this system:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ETCD, i.e. Kubernetes Database</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API Server, through which we store information in Kubernetes and get information from it;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controller Manager</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scheduler </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Two additional components are installed on the working nodes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kube-proxy (responsible for generating network rules in the Kubernetes cluster);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubelet (responsible for sending the command to the Docker daemon to run applications in the Kubernetes cluster). </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Between the nodes, the Calico network plug-in works.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cluster Workflow Diagram</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/oz/ew/f3/ozewf310dnhdmnx2gg4ozhzb1rc.png"><br>
,      Kubernetes    replicaset.<br>
<br>
<ol>
<li>     API-,     ETCD.        .</li>
<li>API-      .</li>
<li>Controller-manager   API-   ,    «»,    .</li>
<li>Scheduler       .       ETCD  API-.</li>
<li>Kubelet  API-  Docker    .</li>
<li>Docker   .</li>
<li>Kubelet   API-   ,     .</li>
</ol><br>
 ,    Kubernetes  ,      .       ,           ,     YAML-.  ,   ,    API-.       .<br>
</div></div><br>
<a name="7"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubeadm</font></font></h2><br>
<img src="https://habrastorage.org/webt/wd/sw/cu/wdswcujzvnx4ynnrbi_ec9c1gr8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The last element worth mentioning is Kubeadm. </font><font style="vertical-align: inherit;">Deploying a new Kubernetes cluster is always a painstaking process. </font><font style="vertical-align: inherit;">At each stage, there are risks of errors due to the human factor, and many tasks are simply very routine and long. </font><font style="vertical-align: inherit;">For example, pouring certificates for TLS encryption between nodes and keeping them up to date. </font><font style="vertical-align: inherit;">This is where utilities for basic template automation come to the rescue. </font><font style="vertical-align: inherit;">The trick of Kubeadm is that it is officially certified to work with Kubernetes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It allows you to:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Install, configure, and run all major cluster components</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manage certificates, including rotate them and write out new ones;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manage cluster component versions (upgrade and downgrade). </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the same time, Kubeadm is not a complete Kubernetes cluster management system, but is a kind of building block that allows you to configure Kubernetes on the node on which Kubeadm utility is running. </font><font style="vertical-align: inherit;">This means that an orchestration system is needed that will run all the necessary VMs, configure them and run Kubeadm on all nodes. </font><font style="vertical-align: inherit;">It is for these purposes that Terraform is used.</font></font><br>
<br>
<a name="8"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository with all files</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we put all the files and configs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in one place, so that it would be more convenient for you. </font><font style="vertical-align: inherit;">If you don’t have a private cloud at hand, but you want to go through all these steps yourself and test the deployment in practice, write to us at cloud@croc.ru. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will give you a demo version for tests and advise on all issues. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And soon there will be a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new Slurm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where you can create your own cluster. </font><font style="vertical-align: inherit;">CROC promo code has a 10% discount. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For those who already work with Kubernetes, there is an </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">advanced course</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The discount is the same. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Colleagues, Habraparser breaks the markup of the code. </font><font style="vertical-align: inherit;">Please take the source from GitHub from the link above.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en492600/index.html">Semi-Scientific Guide to Hosting a WiFi Router</a></li>
<li><a href="../en492604/index.html">Working with View asynchronously using coroutine</a></li>
<li><a href="../en492606/index.html">Toolkit issues in large projects</a></li>
<li><a href="../en492608/index.html">Features delivery features in large projects</a></li>
<li><a href="../en492612/index.html">Decorative ceiling light Leek Celebrity</a></li>
<li><a href="../en492622/index.html">“Hey bully, bring whiskey!”, Or About English words with Irish roots</a></li>
<li><a href="../en492628/index.html">Confidence interval for the number of patients with coronavirus (mortality calculation)</a></li>
<li><a href="../en492632/index.html">Quarantined small business: panic is the enemy of reason</a></li>
<li><a href="../en492636/index.html">What does it mean to be effective?</a></li>
<li><a href="../en492638/index.html">Scaling a Redux app with ducks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>