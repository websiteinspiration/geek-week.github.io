<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏯️ 🤺 💑 プロセッサの設計と製造方法：CPU設計 🛀🏾 ☕️ 👩🏾‍🤝‍👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="プロセッサが高レベルでどのように機能するかがわかったところで、次に、内部コンポーネントの設計プロセスの分析について詳しく説明します。これは、プロセッサ開発に関するシリーズの2番目の記事です。以下に概説する概念を理解できるように、最初のパートを最初に学習することをお勧めします。
 
 パート1：コンピ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>プロセッサの設計と製造方法：CPU設計</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457178/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21c/c0b/840/21cc0b840973fba68f6536c6b5ad31a5.jpg" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセッサが高レベルでどのように機能するかがわかったところで、次に、内部コンポーネントの設計プロセスの分析について詳しく説明します。これは、プロセッサ開発に関するシリーズの2番目の記事です。以下に概説する概念を理解できるように、最初のパートを最初に学習することをお勧めします。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート1：コンピューターアーキテクチャの基本</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（命令セットアーキテクチャ、キャッシング、パイプライン、ハイパースレッディング）</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート2：CPU設計プロセス</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（回路、トランジスタ、ロジックゲート、同期）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パート3：チップレイアウトと物理製造（VLSIおよびシリコン製造）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パート4 ：コンピュータアーキテクチャの現在の傾向と重要な将来の方向性（海のアクセラレータ、3次元統合、FPGA、ニアメモリコンピューティング）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご存知かもしれませんが、プロセッサや他のほとんどのデジタルデバイスはトランジスタで構成されています。 3つの接点を持つ制御されたスイッチとしてトランジスタを認識する最も簡単な方法。シャッターがオンのとき、トランジスタに電流が流れる場合があります。シャッターがオフの時は電流が流れません。シャッターは部屋の照明スイッチのようなものですが、それははるかに小さく、速く、電気的に制御できるだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近のプロセッサで使用されているトランジスタには、pMOS（PMOS）とnMOS（NMOS）の2つの主要なタイプがあります。 ｎＭＯＳトランジスタは、ゲートが充電されるか、または高電圧を有するときに電流を流し、ｐＭＯＳトランジスタは、ゲートが放電されるか、または低電圧を有するときに電流を流す。これらのタイプのトランジスタを相補的に組み合わせることにより、CMOSロジックエレメントを作成できます。この記事では、トランジスタの動作の特徴を詳細に分析することはしませんが、シリーズの第3部ではこれについて触れます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
論理要素は、入力信号を受け取り、演算を実行し、結果を出力する単純なデバイスです。たとえば、ANDエレメント（AND）は、すべてのゲート入力がオンの場合にのみ、その出力信号をオンにします。インバーターまたはエレメントNOT（NOT）は、入力が無効な場合にその出力をオンにします。これらの2つのシャッターを組み合わせて、入力がどれもオンになっていない場合にのみ、出力をオンにするNAND要素を取得できます。 OR（OR）、OR-NOT（NOR）、排他的OR（XOR）、および反転付き排他的OR（XNOR）など、論理機能を持つ他の要素があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、トランジスタから2つの単純な要素がどのように組み立てられるかを示しています：インバーターとNAND。インバータでは、pMOSトランジスタ（上）が電源に接続され、nMOSトランジスタ（下）がグランドに接続されています。 pMOSトランジスタの指定では、小さな円がゲートに接続されています。入力がオフになるとpMOSデバイスが電流を流し、入力がオンになるとnMOSデバイスが電流を流すので、出力信号（Out）が常に入力信号（In）の反対になることが簡単にわかります。 NANDエレメントを見ると、4つのトランジスタが必要であり、少なくとも1つの入力がオフになっている場合、出力は常に無効になっていることがわかります。この方法でトランジスタを接続して単純なネットワークを形成するプロセスは、プロセッサ内のより複雑なロジックエレメントやその他の回路を設計するために使用されるプロセスと同じです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f1e/1ff/453/f1e1ff4532cc9c9463de1f8acee827fc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
論理要素の形のビルディングブロックは非常に単純なので、機能するコンピューターにどのように変化するかを理解するのは困難です。設計プロセスは、いくつかの要素を組み合わせて、単純な機能を実行できる小さなデバイスを作成することで構成されます。次に、これらのデバイスの多くを組み合わせて、より複雑な機能を実行するものを作成できます。個々のコンポーネントを組み合わせて動作する構造を作成するプロセスは、今日のチップを作成するために現在使用されているプロセスとまったく同じです。唯一の違いは、現代のチップは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数十億の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トランジスタで</font><font style="vertical-align: inherit;">構成されていることです</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小さな例として、単純な加算器、つまり1ビットの全加算器を取り上げます。 A、B、およびキャリーイン（転送入力信号）の3つの入力信号を受け取り、合計（合計）およびキャリーアウト（転送出力信号）の2つの出力信号を作成します。最も単純な回路は5つの論理要素を使用し、それらを互いに接続して任意のサイズの加算器を作成できます。現代のスキームでは、ロジックと転送信号の一部を最適化することでこのプロセスが改善されますが、基本的な原理は変わりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サム出力はAまたはBのいずれかですが、両方にはなりません。または、入力キャリー信号があり、AとBがオンになっているか、両方がオフになっています。転送出力はもう少し複雑です。 AとBが同時にオンであるか、またはキャリーインがあり、AまたはBのいずれかがオンである場合にアクティブになります。複数の1ビット加算器を接続して幅の広い加算器を作成するには、前のビットのキャリーアウトを現在のビットのキャリーインに接続するだけです。回路が複雑になるほど、ロジックは混乱しますが、これは2つの数値を加算する最も簡単な方法です。最近のプロセッサはより高度な加算器を使用していますが、その回路はそのようなレビューには複雑すぎます。加算器に加えて、プロセッサには、これらすべての浮動小数点演算の除算、乗算、およびバージョンのためのデバイスも含まれています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/052/486/af6/052486af63f774bb4ec814f3bb31a5b2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力信号に対して機能を実行するための要素のシーケンスのこのような組み合わせは、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">組み合わせロジック</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。ただし、コンピュータで使用されるロジックのタイプはこれだけではありません。データの保存やステータスの追跡ができなければ、あまり役に立ちません。データを保存できるようにするには、シーケンシャルロジックが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シーケンシャルロジックは、インバーターやその他のロジックエレメントをきちんと接続することで構築され、その出力がフィードバック信号をエレメントの入力に送信します。これらのフィードバックループは1ビットのデータを格納するために使用され、</font><em><font style="vertical-align: inherit;">スタティックRAM</font></em><font style="vertical-align: inherit;">と呼ばれ</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、またはSRAM。保存されたデータは常に正の電圧またはグランドに直接接続されるため、このメモリはダイナミックRAM（DRAM）ではなくスタティックRAMと呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つのSRAMビットを実装する標準的な方法は、以下に示す6トランジスタ回路です。 WL（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワードライン</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）と</font><font style="vertical-align: inherit;">マークされた一番上の信号</font><font style="vertical-align: inherit;">はアドレスであり、それがオンになると、この1ビットのセルに格納されたデータは</font><font style="vertical-align: inherit;">BLとマークされ</font><font style="vertical-align: inherit;">た</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビットラインに</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">送信</font><font style="vertical-align: inherit;">されます。 BLB出力は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビットラインバー</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。これはビットラインの反転値です。 2つのタイプのトランジスタを認識し、M3とM1がM4とM2のようにインバータを形成することを理解する必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43c/428/111/43c4281117b07528ff8f7f3d43efd196.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SRAMは、プロセッサ内部の超高速キャッシュとレジスタを構築するために使用されます。このメモリは非常に安定していますが、データの各ビットを保存するには6〜8個のトランジスタが必要です。したがって、DRAMと比較すると、コスト、複雑さ、チップ上の面積の点で非常に高価です。一方、ダイナミックRAMは、論理ゲートを使用するのではなく、小さなコンデンサにデータを格納します。コンデンサは電源またはグラウンドに接続されていないため、コンデンサの電圧は大幅に変動する可能性があるため、ダイナミックと呼ばれます。コンデンサに格納されたデータにアクセスするために使用されるトランジスタは1つだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DRAMはビットあたり1つのトランジスタしか必要とせず、非常にスケーラブルであるため、高密度で安価に実装できます。 DRAMの欠点は、コンデンサの電荷が非常に小さいため、常に更新する必要があることです。そのため、コンピュータの電源をオフにすると、すべてのコンデンサが放電され、RAMのデータが失われます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a5/bca/616/2a5bca6162fbbb1a91894d7ed1c73d37.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Intel、AMD、Nvidiaなどの企業はプロセッサの回路図を公開していないため、最新のプロセッサでこのような完全な回路を表示することは不可能です。ただし、この単純な加算器を使用すると、プロセッサの最も複雑な部分でさえ、論理要素とメモリ要素、さらにはトランジスタに分割できるという考えを得ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかのプロセッサコンポーネントがどのように作成されるかがわかったので、すべてをまとめて同期する方法を理解する必要があります。プロセッサのすべての主要コンポーネントは、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クロック信号に</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接続されてい</font><em><font style="vertical-align: inherit;">ます</font></em><font style="vertical-align: inherit;">。交互に高電圧と低電圧があり、</font><em><font style="vertical-align: inherit;">周波数（frequency）</font></em><font style="vertical-align: inherit;">と呼ばれる特定の間隔で変化します</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。プロセッサー内部のロジックは通常、値を切り替え、クロック信号が電圧を低から高に変化させるときに計算を実行します。すべてのパーツを同期させることにより、データが常に適切なタイミングで到着し、プロセッサーに不具合が発生しないことを保証できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クロック速度を上げてプロセッサーのパフォーマンスを上げることができると聞いたことがあるかもしれません。このパフォーマンスの向上は、プロセッサ内のトランジスタとロジックのスイッチングが意図したよりも頻繁に発生し始めるためです。 1秒あたりのサイクル数が多いため、より多くの作業を実行でき、プロセッサーのパフォーマンスが向上します。ただし、これはある程度当てはまります。最近のプロセッサは通常、3.0 GHz〜4.5 GHzの周波数で動作し、この値は過去10年間あまり変化していません。金属チェーンが最も弱いリンクよりも強くないように、プロセッサーは最も遅い部分よりも速く実行できません。各クロックサイクルの終わりまでに、各プロセッサエレメントはその作業を完了する必要があります。一部のパーツがまだ完成していない場合は、その後、クロックが速すぎてプロセッサが動作しなくなります。デザイナーはこれを最も遅い部分と呼びます</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クリティカルパス（クリティカルパス）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であり、プロセッサが動作できる最大周波数を決定します。特定の周波数を超えると、トランジスタには、十分な速さでスイッチングし、故障し始めたり、誤った出力値を出力したりする時間がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセッサの電圧を上げることで、トランジスタのスイッチングを高速化できますが、これも一定の限界まで機能します。電圧をかけすぎると、プロセッサが焼ける危険があります。プロセッサの周波数または電圧を上げると、常により多くの熱を放出し、より多くの電力を消費し始めます。これは、プロセッサの電力が周波数に正比例し、電圧の2乗に比例するためです。プロセッサの消費電力を決定するために、各トランジスタは、値が変化したときに充電または放電する必要がある小さなコンデンサと見なします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
電源はプロセッサの非常に重要な部分であり、場合によってはチップ上の物理的な接点の最大半分が電源または接地にのみ使用できます。全負荷時の一部のチップは150アンペア以上を消費する可能性があり、このすべての電流を使用する場合は、非常に注意深く制御する必要があります。比較のために：中央処理装置は、原子炉よりも単位面積あたりの熱を多く生成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最新のプロセッサのクロック信号は非常に複雑で、多くの異なるデバイスを制御する必要があるため、総電力の約30〜40％を占めます。エネルギーを節約するために、ほとんどの低電力プロセッサは、使用されていないときはチップの一部を無効にします。これは、クロックをオフにする（この方法はクロックゲーティングと呼ばれます）または電源をオフにする（パワーゲーティング）ことで実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クロック信号は、プロセッサの設計に別の困難をもたらします。それらの周波数は常に増加しているため、物理法則が作業に影響し始めます。非常に高速な光にもかかわらず、高性能プロセッサには十分な大きさではありません。クロック信号をチップの一方の端に接続すると、信号がもう一方の端に到達するまでに、かなりの量だけ同期が外れます。チップのすべての部分を同期させるために、クロック信号はいわゆるHツリーを使用して分配されます。これは、すべての端点が中心から正確に同じ距離にあることを保証する構造です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7b/98e/f3b/d7b98ef3bf167f06b89da6608b23f9e5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チップ内の個々のトランジスタ、クロック信号、および電源接点の設計は、非常に単調で難しい作業であるように思われるかもしれませんが、これは確かにそうです。何千人ものエンジニアがIntel、Qualcomm、AMDなどの企業で働いていても、チップのすべての側面を手動で設計することはできません。この規模のチップを設計するには、設計と電気回路を自動的に生成する多くの高度なツールを使用します。そのようなツールは通常、コンポーネントが何をすべきかについての高レベルの説明を取得し、これらの要件を満たす最適なハードウェア構成を決定します。最近、</font><em><font style="vertical-align: inherit;">高位合成</font></em><font style="vertical-align: inherit;">と呼ばれる開発ライン</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これにより、開発者はコードで必要な機能を指定できます。その後、コンピュータが機器でそれを達成するための最良の方法を決定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードを介してコンピュータープログラムを記述できるのと同じように、デザイナーはハードウェアデバイスをコードで記述できます。 VerilogやVHDLなどの言語を使用すると、機器の設計者は、作成した回路の機能を表現できます。そのようなプロジェクトのシミュレーションと検証を行った後、それらを電気回路を構成する特定のトランジスタに合成できます。検証フェーズは、新しいキャッシュまたはカーネルを設計するほどエキサイティングではないように見えますが、それよりもはるかに重要です。企業に採用された設計エンジニアごとに、5人以上の検証エンジニアがいる場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合、新しいプロジェクトの検証には、チップ自体を作成するよりも多くの時間と費用がかかります。企業は検証に多くの時間とお金を費やしています。なぜなら、チップを生産に送った後は修正できないからです。ソフトウェアでエラーが発生した場合は、パッチをリリースできますが、機器の動作は異なります。たとえば、Intel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部のPentiumチップ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">の浮動小数点除算モジュールにバグを</font></a><font style="vertical-align: inherit;">発見</font><font style="vertical-align: inherit;">し、その結果、現在の20億ドルに相当する損失をもたらしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つのチップに数十億個のトランジスタが存在する可能性があることを理解し、それらがすべて何をしているのかを理解することは困難です。チップを個々の内部コンポーネントに分解すると、少し簡単になります。論理要素はトランジスタで構成され、論理要素は特定のタスクを実行する機能モジュールに結合され、これらの機能モジュールは互いに接続されて、シリーズの最初の部分で説明したコンピューターアーキテクチャを形成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの設計作業は自動化されていますが、上記により、購入したばかりの新しいCPUがいかに複雑であるかを理解できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シリーズの第2部では、CPUの設計プロセスについて説明しました。</font><font style="vertical-align: inherit;">トランジスタ、論理ゲート、電源信号とクロック信号、デザインの合成、検証について説明しました。</font><font style="vertical-align: inherit;">第3部では、チップの物理的な生産に必要なものを見つけます。</font><font style="vertical-align: inherit;">すべての企業は製造プロセスがいかに近代的であるかを自慢するのが大好きですが（Intel-10nm、AppleおよびAMD-7nmなど）、これらの数字は実際にはどういう意味ですか？</font><font style="vertical-align: inherit;">これについては、次のパートで説明します。</font></font><br>
<br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推奨読書</font></font></h5><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロプロセッサとパソコンの歴史</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディスプレイ技術の比較：TN vs. </font><font style="vertical-align: inherit;">VA対 </font><font style="vertical-align: inherit;">IPS</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4GHz CPUバトル：AMD第2世代Ryzen対 </font><font style="vertical-align: inherit;">Intel 8th-Gen Core</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーマルスロットリングとは何ですか？</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja457156/index.html">将来のコンピューティングシステムは何か</a></li>
<li><a href="../ja457160/index.html">C ++でデリゲートを実装する私のアプローチ：実行時に不明なパラメーターで関数を呼び出す</a></li>
<li><a href="../ja457164/index.html">ReactiveUIとAvaloniaの例を使用してディスクに状態を保存するクロスプラットフォームの.NET Coreアプリケーションでのナビゲーション</a></li>
<li><a href="../ja457168/index.html">PythonとTextBlobによるプロトタイプ感情分析</a></li>
<li><a href="../ja457172/index.html">ScreenLogger-笑顔、隠されたカメラがあなたを撃ちます</a></li>
<li><a href="../ja457180/index.html">公式サイトNode.jsがロシア語になりました</a></li>
<li><a href="../ja457182/index.html">REXX言語、40周年</a></li>
<li><a href="../ja457184/index.html">ASP.NET Coreサイト用のrobots.txtを動的に作成する</a></li>
<li><a href="../ja457186/index.html">Visual Studio CodeのPython-6月のリリース</a></li>
<li><a href="../ja457188/index.html">穏やかな穏やかな争い</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>